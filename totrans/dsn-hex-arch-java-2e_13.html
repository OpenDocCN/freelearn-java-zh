<html><head></head><body>
<div id="_idContainer081">
<h1 class="chapter-number" id="_idParaDest-209"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-210"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.2.1">Persisting Data with Output Adapters and Hibernate Reactive</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about some of the advantages that can be brought to a system by using Quarkus reactive capabilities. </span><span class="koboSpan" id="kobo.3.2">Our first step on the reactive road was to implement Reactive input adapters</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.4.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">RESTEasy Reactive</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">Although the input adapters’ endpoints are being served reactively, we still have the output adapters working in a synchronous and </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">blocking fashion.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">To turn the hexagonal system into a more Reactive one, in this chapter, we’ll first learn how to configure </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">Object Relational Mapping</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.11.1">ORM</span></strong><span class="koboSpan" id="kobo.12.1">) on system entities by using Hibernate Reactive and </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">Panache</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">Once the system entities are properly configured, we’ll learn how to use these entities to connect to a MySQL </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">database reactively.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">The following are the topics we’ll cover in </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Introducing Hibernate Reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">Panache</span></strong></span></li>
<li><span class="koboSpan" id="kobo.21.1">Enabling reactive behavior on </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">output adapters</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Testing reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">output adapters</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.25.1">As we have already implemented reactive input adapters in the previous chapter, our goal here is to extend the reactive behavior in a hexagonal system by implementing reactive output adapters. </span><span class="koboSpan" id="kobo.25.2">This implementation takes place at the Framework hexagon, which is the architecture element where we concentrate </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">on adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">By the end of this chapter, you’ll have learned how to integrate Quarkus with a hexagonal system to access databases reactively. </span><span class="koboSpan" id="kobo.27.2">By understanding the required configuration steps and fundamental implementation details, you’ll be able to implement reactive output adapters. </span><span class="koboSpan" id="kobo.27.3">This knowledge will help you tackle situations where non-blocking I/O requests offer more advantages than </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">I/O-blocking ones.</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">To compile and run the code examples presented in this chapter, you need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.32.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.34.1"> installed on your computer. </span><span class="koboSpan" id="kobo.34.2">They are all available for Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Also, you’ll need </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">Docker</span></strong><span class="koboSpan" id="kobo.38.1"> installed on </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">your machine.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.44.1">Introducing Hibernate Reactive and Panache</span></h1>
<p><span class="koboSpan" id="kobo.45.1">The available technologies and techniques to handle database operations in Java have evolved a lot in the last few years. </span><span class="koboSpan" id="kobo.45.2">Based on the </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">Java Persistence API</span></strong><span class="koboSpan" id="kobo.47.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.48.1">JPA</span></strong><span class="koboSpan" id="kobo.49.1">) specification, we’ve been presented with different ORM implementations such as Spring Data JPA, EclipseLink, and, of course, Hibernate. </span><span class="koboSpan" id="kobo.49.2">These</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.50.1"> technologies make our lives easier by abstracting</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.51.1"> away much of the plumber work required to deal </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">with databases.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Quarkus is integrated with Hibernate ORM and its reactive counterpart, Hibernate Reactive. </span><span class="koboSpan" id="kobo.53.2">Also, Quarkus comes with a library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">Panache</span></strong><span class="koboSpan" id="kobo.55.1">, which simplifies our interaction </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">with databases.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Next, we’ll take a brief look at Hibernate Reactive and Panache’s </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">main features.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.59.1">Hibernate Reactive features</span></h2>
<p><span class="koboSpan" id="kobo.60.1">It’s rare, if not impossible, to find </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.61.1">a silver-bullet solution that solves all problems related to database access. </span><span class="koboSpan" id="kobo.61.2">When we talk about the reactive and imperative approaches to database handling, it’s fundamental to understand the advantages and disadvantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">both approaches.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">What’s so appealing about the imperative approach to database access is the simplicity with which you develop your code. </span><span class="koboSpan" id="kobo.63.2">There are fewer things to adjust and think about when you need to read or persist things using an imperative approach. </span><span class="koboSpan" id="kobo.63.3">However, this approach may cause setbacks when its blocking nature starts to impact the use cases of your system. </span><span class="koboSpan" id="kobo.63.4">To avoid such setbacks, we have the reactive approach, enabling us to deal with databases in a non-blocking fashion, but not without additional complexities in our development and the new problems and challenges that arise when reactively </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">handling databases.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">The original Hibernate implementation was conceived to solve the problems that developers had to deal with when mapping Java objects to database entities. </span><span class="koboSpan" id="kobo.65.2">The original implementation relies on I/O blocking synchronous communication to interact with databases. </span><span class="koboSpan" id="kobo.65.3">It’s been, and still is, the most conventional way to access databases in Java. </span><span class="koboSpan" id="kobo.65.4">On the other hand, Hibernate Reactive arose from the urge for reactive programming movements and the need</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.66.1"> for asynchronous communication to database access. </span><span class="koboSpan" id="kobo.66.2">Instead of I/O blocking, Hibernate Reactive relies upon I/O non-blocking communication to interact </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">with databases.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">The entity mapping properties remain the same in a reactive implementation. </span><span class="koboSpan" id="kobo.68.2">However, what changes is how we open a database’s Reactive connection and how we should structure the software code to handle database </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">entities reactively.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">When using Quarkus, there is no need to provide a reactive persistence configuration based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">persistence.xml</span></strong><span class="koboSpan" id="kobo.72.1"> file because Quarkus already configures it for us. </span><span class="koboSpan" id="kobo.72.2">Still, we will briefly explore it to have an idea of how Hibernate Reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">alone works.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">To set up Hibernate Reactive, you can follow the standard approach to configuring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">META-INF/persistence.xml</span></strong><span class="koboSpan" id="kobo.76.1"> file, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
&lt;persistence-unit name="mysql"&gt;
    &lt;provider&gt;
       org.hibernate.reactive.provider
       .ReactivePersistenceProvider
    &lt;/provider&gt;
    &lt;class&gt;dev.davivieria.SomeObject&lt;/class&gt;
    &lt;properties&gt;
    &lt;property name=»javax.persistence.jdbc.url»
       value=»jdbc:mysql://localhost/hreact"/&gt;
    &lt;/properties&gt;
&lt;/persistence-unit&gt;</span></pre> <p><span class="koboSpan" id="kobo.79.1">Note that we’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">ReactivePersistenceProvider</span></strong><span class="koboSpan" id="kobo.81.1"> to open a reactive connection to the database. </span><span class="koboSpan" id="kobo.81.2">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">persistence.xml</span></strong><span class="koboSpan" id="kobo.83.1"> file is properly configured, we can start using Hibernate</span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.84.1"> Reactive in </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">our code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
import static javax.persistence.Persistence.createEnti
  tyManagerFactory;
SessionFactory factory = createEntityManagerFactory (
persistenceUnitName ( args ) ).unwrap(SessionFac
  tory.class);
/** Code omitted **/
public static String persistenceUnitName(String[] args) {
    return args.length &gt; 0 ?
</span><span class="koboSpan" id="kobo.86.2">    args[0] : "postgresql-example";
}</span></pre> <p><span class="koboSpan" id="kobo.87.1">We start by importing the static </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">javax.persistence.Persistence.createEntityManagerFactory</span></strong><span class="koboSpan" id="kobo.89.1"> method provided by Hibernate Reactive. </span><span class="koboSpan" id="kobo.89.2">This static method facilitates the creation of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">SessionFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">In order to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">SessionFactory</span></strong><span class="koboSpan" id="kobo.94.1"> object, the system uses the properties defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">persistence.xml</span></strong><span class="koboSpan" id="kobo.96.1"> file. </span><span class="koboSpan" id="kobo.96.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">SessionFactory</span></strong><span class="koboSpan" id="kobo.98.1">, we can start reactive communication with </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
SomeObject someObject = new SomeObject();
factory.withTransaction(
     (
org.hibernate.reactive.mutiny.Mutiny.
</span><span class="koboSpan" id="kobo.100.2">  Transaction session,
org.hibernate.reactive.mutiny.Mutiny.Transaction tx) -&gt;
session.persistAll(someObject)).subscribe();</span></pre> <p><span class="koboSpan" id="kobo.101.1">To persist data, first, we need to create a transaction by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">withTransaction</span></strong><span class="koboSpan" id="kobo.103.1"> method. </span><span class="koboSpan" id="kobo.103.2">Inside a transaction, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">persistAll</span></strong><span class="koboSpan" id="kobo.105.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">SessionFactory</span></strong><span class="koboSpan" id="kobo.107.1"> to persist an object. </span><span class="koboSpan" id="kobo.107.2">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">subscribe</span></strong><span class="koboSpan" id="kobo.109.1"> method to trigger the persistence operation in a </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">non-blocking way.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">By establishing a layer</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.112.1"> between the application and the database, Hibernate provides all the basic things we need to handle databases </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">in Java.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">Now, let’s see how </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Panache</span></strong><span class="koboSpan" id="kobo.116.1"> can make things </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">even simpler.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.118.1">Panache features</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Panache</span></strong><span class="koboSpan" id="kobo.120.1"> sits on top of Hibernate and enhances it even more by providing a simple interface for handling the database entities. </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">Panache</span></strong><span class="koboSpan" id="kobo.122.1"> was primarily developed to work with the Quarkus framework, and it is</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.123.1"> a library aimed to abstract much of the boilerplate code required to handle the database entities. </span><span class="koboSpan" id="kobo.123.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Panache</span></strong><span class="koboSpan" id="kobo.125.1">, you can easily apply database patterns such as </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Active Record</span></strong><span class="koboSpan" id="kobo.127.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">Repository</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">Let’s briefly see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">do that.</span></span></p>
<h3><span class="koboSpan" id="kobo.131.1">Applying the Active Record pattern</span></h3>
<p><span class="koboSpan" id="kobo.132.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">Active Record</span></strong><span class="koboSpan" id="kobo.134.1"> pattern, we use</span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.135.1"> the class that represents the database</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.136.1"> entity to make changes in the database. </span><span class="koboSpan" id="kobo.136.2">To enable this behavior, we need to extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">PanacheEntity</span></strong><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">Look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
@Entity
@Table(name="locations")
public class Location extends PanacheEntity {
    @Id @GeneratedValue
    private Integer id;
    @NotNull @Size(max=100)
    public String country;
    @NotNull @Size(max=100)
    public String state;
    @NotNull @Size(max=100)
    public String city;
}</span></pre> <p><span class="koboSpan" id="kobo.141.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">Location</span></strong><span class="koboSpan" id="kobo.143.1"> class is a regular Hibernate-based entity that extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">PanacheEntity</span></strong><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">Besides extending </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">PanacheEntity</span></strong><span class="koboSpan" id="kobo.147.1">, there is nothing new in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">Location</span></strong><span class="koboSpan" id="kobo.149.1"> class. </span><span class="koboSpan" id="kobo.149.2">We have</span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.150.1"> annotations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">@NotNull</span></strong><span class="koboSpan" id="kobo.152.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">@Size</span></strong><span class="koboSpan" id="kobo.154.1"> that we use to validate </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">The following are some of the things </span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.157.1">we can do with an Active </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">Record entity:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.159.1">To list entities, we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">listAll</span></strong><span class="koboSpan" id="kobo.161.1"> method. </span><span class="koboSpan" id="kobo.161.2">This method is available on </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Location</span></strong><span class="koboSpan" id="kobo.163.1"> because we’re extending the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">PanacheEntity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.166.1">
List&lt;Location&gt; locations = Location.listAll();</span></pre></li> <li><span class="koboSpan" id="kobo.167.1">To delete all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Location</span></strong><span class="koboSpan" id="kobo.169.1"> entities, we can call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">deleteAll</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.172.1">
Location.deleteAll();</span></pre></li> <li><span class="koboSpan" id="kobo.173.1">To find a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Location</span></strong><span class="koboSpan" id="kobo.175.1"> entity by its ID, we can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">findByIdOptional</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.177.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.178.1">
Optional&lt;Location&gt; optional = Location.findByIdOp
  tional(locationId);</span></pre></li> <li><span class="koboSpan" id="kobo.179.1">To persist a </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Location</span></strong><span class="koboSpan" id="kobo.181.1"> entity, we have to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">persist</span></strong><span class="koboSpan" id="kobo.183.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Location</span></strong><span class="koboSpan" id="kobo.185.1"> instance we</span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.186.1"> intend </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">to persist:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.188.1">
Location location = new Location();
location.country = "Brazil";
location.state = "Sao Paulo";
location.city = "Santo Andre";
location.persist();</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.189.1">Every time we execute one of the preceding described operations, they are immediately committed to </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">Now, let’s see how to use </span><a id="_idIndexMarker864"/><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">Panache</span></strong><span class="koboSpan" id="kobo.193.1"> to apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">Repository pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.195.1">Applying the Repository pattern</span></h3>
<p><span class="koboSpan" id="kobo.196.1">Instead of using an</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.197.1"> entity class to perform actions on the database, we use a separate class that is usually dedicated to providing database operations in the </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.198.1">Repository pattern. </span><span class="koboSpan" id="kobo.198.2">This kind of class works like a repository interface for </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">To apply the Repository pattern, we should use regular </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">Hibernate entities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
@Entity
@Table(name="locations")
public class Location {
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.203.1">Note that at this time, we’re not extending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">PanacheEntity</span></strong><span class="koboSpan" id="kobo.205.1"> class. </span><span class="koboSpan" id="kobo.205.2">In the Repository pattern, we don’t call the database operations directly through the entity class. </span><span class="koboSpan" id="kobo.205.3">Instead, we call them through the repository class. </span><span class="koboSpan" id="kobo.205.4">Here is an example of how we can implement a </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">repository class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
@Ap</span><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.208.1">plicationScoped
public class LocationRepository implements PanacheReposi
  tory&lt;Location&gt; {
   public Location findByCity(String city){
       return find ("city", city).firstResult();
   }
   public Location findByState(String state){
       return find("state", state).firstResult();
   }
   public void deleteSomeCountry(){
       delete ("country", "SomeCountry");
  }
}</span></pre> <p><span class="koboSpan" id="kobo.209.1">By implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">PanacheRepository</span></strong><span class="koboSpan" id="kobo.211.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">LocationRepository</span></strong><span class="koboSpan" id="kobo.213.1"> class, we’re enabling all the standard operations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">findById</span></strong><span class="koboSpan" id="kobo.215.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">delete</span></strong><span class="koboSpan" id="kobo.217.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">persist</span></strong><span class="koboSpan" id="kobo.219.1">, and so on that are present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">PanacheEntity</span></strong><span class="koboSpan" id="kobo.221.1"> class. </span><span class="koboSpan" id="kobo.221.2">Also, we can define our own custom queries, as we</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.222.1"> did in the preceding example, by using</span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.223.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">find</span></strong><span class="koboSpan" id="kobo.225.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">delete</span></strong><span class="koboSpan" id="kobo.227.1"> methods provided by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">PanacheEntity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Note that we annotated the repository class as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">@ApplicationScoped</span></strong><span class="koboSpan" id="kobo.232.1"> bean. </span><span class="koboSpan" id="kobo.232.2">This means we can inject and use it in </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">other classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
@Inject
LocationRepository locationRepository;
public Location findLocationByCity(City city){
    return locationRepository.findByCity(city);
}</span></pre> <p><span class="koboSpan" id="kobo.235.1">Here, we have the most common operations </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.236.1">available on the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">repository class:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.238.1">To list all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">Location</span></strong><span class="koboSpan" id="kobo.240.1"> entities, we </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.241.1">need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">listAll</span></strong><span class="koboSpan" id="kobo.243.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">LocationRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
List&lt;Location&gt; locations = locationReposi
  tory.listAll();</span></pre></li> <li><span class="koboSpan" id="kobo.248.1">By calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">deleteAll</span></strong><span class="koboSpan" id="kobo.250.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">LocationRepository</span></strong><span class="koboSpan" id="kobo.252.1">, we remove all the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1"> entities:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.255.1">
locationRepository.deleteAll();</span></pre></li> <li><span class="koboSpan" id="kobo.256.1">To find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Location</span></strong><span class="koboSpan" id="kobo.258.1"> entity by its ID, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">findByIdOptional</span></strong><span class="koboSpan" id="kobo.260.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">LocationRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.264.1">
Optional&lt;Location&gt; optional = locationReposi
  tory.findByIdOptional(locationId);</span></pre></li> <li><span class="koboSpan" id="kobo.265.1">To persist a </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">Location</span></strong><span class="koboSpan" id="kobo.267.1"> entity, we need to pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">Location</span></strong><span class="koboSpan" id="kobo.269.1"> instance to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">persist</span></strong><span class="koboSpan" id="kobo.271.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">LocationRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.275.1">
Location location = new Location();
location.country = "Brazil";
location.state = "Sao Paulo";
location.city = "Santo Andre";
locationRepository.persist(location);</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.276.1">In the preceding examples, we are executing all database operations using the repository class. </span><span class="koboSpan" id="kobo.276.2">The methods we call here are the same as those present in the entity class from the Active Record approach. </span><span class="koboSpan" id="kobo.276.3">The only difference here is the usage of the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">repository class.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">By learning how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Panache</span></strong><span class="koboSpan" id="kobo.280.1"> to apply the Active Record and Repository patterns, we increase our capacity to provide good approaches to handling database entities. </span><span class="koboSpan" id="kobo.280.2">There is no better or worse pattern. </span><span class="koboSpan" id="kobo.280.3">The project’s circumstances will ultimately dictate which pattern is </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">more suitable.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Panache</span></strong><span class="koboSpan" id="kobo.283.1"> is a library made </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.284.1">especially for Quarkus. </span><span class="koboSpan" id="kobo.284.2">So, the best way to connect Hibernate Reactive objects such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">SessionFactory</span></strong><span class="koboSpan" id="kobo.286.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Transaction</span></strong><span class="koboSpan" id="kobo.288.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Panache</span></strong><span class="koboSpan" id="kobo.290.1"> is by delegating the database configuration to Quarkus, which will automatically provide these objects </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">Now that we’re acquainted </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.293.1">with Hibernate Reactive and </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Panache</span></strong><span class="koboSpan" id="kobo.295.1">, let’s see how we can implement output adapters in a </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">hexagonal system.</span></span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.297.1">Enabling reactive behavior on output adapters</span></h1>
<p><span class="koboSpan" id="kobo.298.1">One of the most </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.299.1">important benefits of using hexagonal architecture is the improved flexibility to change technologies without significant refactoring. </span><span class="koboSpan" id="kobo.299.2">The hexagonal system is designed so that its domain logic and business rules are oblivious to the technologies utilized to </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">execute them.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">There is no free lunch – when we decide to use the hexagonal architecture, we have to pay the price for the benefits that this architecture can provide. </span><span class="koboSpan" id="kobo.301.2">(By price, I mean a considerable increase in the effort and complexity required to structure the system code by following the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">hexagonal principles.)</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">If you’re concerned about code reuse, you may find some practices awkward to decouple code from specific technologies. </span><span class="koboSpan" id="kobo.303.2">For example, consider a scenario in which we have a domain entity class and a database entity class. </span><span class="koboSpan" id="kobo.303.3">We may argue, </span><em class="italic"><span class="koboSpan" id="kobo.304.1">why not have just one class that serves both purposes?</span></em><span class="koboSpan" id="kobo.305.1"> Well, in the end, it’s all a matter of priorities. </span><span class="koboSpan" id="kobo.305.2">If the coupling of the domain and technology-specific classes is not an issue for you, go ahead. </span><span class="koboSpan" id="kobo.305.3">In this case, you will not have the burden of maintaining a domain model plus all the infrastructure code that supports it. </span><span class="koboSpan" id="kobo.305.4">However, the same code would serve different purposes, thus </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.306.1">violating the </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.308.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.309.1">SRP</span></strong><span class="koboSpan" id="kobo.310.1">). </span><span class="koboSpan" id="kobo.310.2">Otherwise, if you see a risk in using the same code for serving different purposes, then the output adapters </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">can help.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">In </span><a href="B19777_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.313.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.314.1">, </span><em class="italic"><span class="koboSpan" id="kobo.315.1">Wrapping Business Rules Inside the Domain Hexagon</span></em><span class="koboSpan" id="kobo.316.1">, we introduced an output adapter that integrated the application with the filesystem. </span><span class="koboSpan" id="kobo.316.2">In </span><a href="B19777_04.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.317.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.318.1">, </span><em class="italic"><span class="koboSpan" id="kobo.319.1">Creating Adapters to Interact with the Outside World</span></em><span class="koboSpan" id="kobo.320.1">, we created a more elaborated output adapter to communicate with an H2 in-memory database. </span><span class="koboSpan" id="kobo.320.2">Now that we have the Quarkus toolkit at our</span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.321.1"> disposal, we can create reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">output adapters.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.323.1">Configuring reactive data sources</span></h2>
<p><span class="koboSpan" id="kobo.324.1">To continue the </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.325.1">reactive effort that we started in the previous chapter by implementing reactive input adapters, we’ll create and connect reactive output adapters to these reactive input adapters by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.327.1">Let’s get started by configuring the required dependencies in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">pom.xml</span></strong><span class="koboSpan" id="kobo.329.1"> file of the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">Framework hexagon:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.331.1">
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    artifactId&gt;quarkus-reactive-mysql-client
      &lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
   &lt;artifactId&gt;quarkus-hibernate-reactive-panache&lt;/ar
      tifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.332.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">quarkus-reactive-mysql-client</span></strong><span class="koboSpan" id="kobo.334.1"> dependency contains the libraries we need to open a reactive connection with MySQL databases and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">quarkus-hibernate-reactive-panache</span></strong><span class="koboSpan" id="kobo.336.1"> dependency contains Hibernate Reactive and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Panache</span></strong><span class="koboSpan" id="kobo.338.1">. </span><span class="koboSpan" id="kobo.338.2">It’s important to note that this library is especially suited for reactive activities. </span><span class="koboSpan" id="kobo.338.3">For non-reactive activities, Quarkus offers a </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">different library.</span></span></p></li> <li><span class="koboSpan" id="kobo.340.1">Now, we need to configure</span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.341.1"> the database connection on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">application.properties</span></strong><span class="koboSpan" id="kobo.343.1"> file from the Bootstrap hexagon. </span><span class="koboSpan" id="kobo.343.2">Let’s start with t</span><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.344.1">he data </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">source properties:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.346.1">
quarkus.datasource.db-kind = mysql
quarkus.datasource.reactive = true
quarkus.datasource.reactive.url = mysql://lo
  calhost:3306/inventory
quarkus.datasource.username = root
quarkus.datasource.password = password</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.347.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">quarkus.datasource.db-kind</span></strong><span class="koboSpan" id="kobo.349.1"> property is not mandatory because Quarkus can infer the database kind by looking into the specific database client that is loaded from Maven dependencies. </span><span class="koboSpan" id="kobo.349.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">quarkus.datasource.reactive</span></strong><span class="koboSpan" id="kobo.351.1"> set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">true</span></strong><span class="koboSpan" id="kobo.353.1">, we’re enforcing reactive connections. </span><span class="koboSpan" id="kobo.353.2">We need to specify the reactive database connection URL </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">quarkus.datasource.reactive.url</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.357.1">Finally, we have to define the </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">Hibernate configuration:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.359.1">
quarkus.hibernate-orm.sql-load-script=inventory.sql
quarkus.hibernate-orm.database.gener</span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.360.1">ation = drop-and-
  create
quarkus.hibernate-orm.log.sql = true</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.361.1">After Quarkus has created the database and its tables, you can load a </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">.sql</span></strong><span class="koboSpan" id="kobo.363.1"> file to execute more instructions on the database. </span><span class="koboSpan" id="kobo.363.2">By default, it searches for and loads a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">import.sql</span></strong><span class="koboSpan" id="kobo.365.1">. </span><span class="koboSpan" id="kobo.365.2">We can change this behavior by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">quarkus.hibernate-orm.sql-load-script</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.367.1"> property.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.368.1">Be aware of not using </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">quarkus.hibernate-orm.database.generation = drop-and-create</span></strong><span class="koboSpan" id="kobo.370.1"> in production. </span><span class="koboSpan" id="kobo.370.2">Otherwise, it will drop all your database tables. </span><span class="koboSpan" id="kobo.370.3">If you don’t set any value, the default one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">none</span></strong><span class="koboSpan" id="kobo.372.1">, is used. </span><span class="koboSpan" id="kobo.372.2">The default behavior doesn’t make any changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">the database.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.374.1">And, finally, we enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">quarkus.hibernate-orm.log.sql</span></strong><span class="koboSpan" id="kobo.376.1"> to see which SQL queries Hibernate is executing behind the hood. </span><span class="koboSpan" id="kobo.376.2">I recommend you enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">log</span></strong><span class="koboSpan" id="kobo.378.1"> feature only for development purposes. </span><span class="koboSpan" id="kobo.378.2">When running the application in production, don’t</span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.379.1"> forget to disable </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">this option.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.381.1">Let’s now see how to configure application entities to work with a </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">MySQL database.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.383.1">Configuring entities</span></h2>
<p><span class="koboSpan" id="kobo.384.1">The topology and inventory system</span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.385.1"> requires four database tables to store its data: routers, switches, networks, and location. </span><span class="koboSpan" id="kobo.385.2">Each one of these tables will be mapped to a Hibernate entity class properly configured to work with a MySQL </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">data source.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">We’ll apply the Repository pattern, so we won’t have the entities to perform database operations. </span><span class="koboSpan" id="kobo.387.2">Instead, we’ll create separate repository classes to trigger actions on the database, but before creating repository classes, let’s start by implementing Hibernate entities for the topology and inventory system. </span><span class="koboSpan" id="kobo.387.3">We’ll configure these entities to work with </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">MySQL databases.</span></span></p>
<h3><span class="koboSpan" id="kobo.389.1">The Router entity</span></h3>
<p><span class="koboSpan" id="kobo.390.1">For this entity and</span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.391.1"> the others that will be</span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.392.1"> implemented subsequently, we should create classes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">dev.davivieira.topologyinventory.framework.adapters.output.mysql.data</span></strong><span class="koboSpan" id="kobo.394.1"> package of the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">Framework hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">Here is what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">Router</span></strong><span class="koboSpan" id="kobo.398.1"> entity class should </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
@Entity(name = "RouterData")
@Table(name = "routers")
@EqualsAndHashCode(exclude = "routers")
public class RouterData implements Serializable {
    @Id
    @Column(name="router_id", columnDefinition =
      «BINARY(16)")
    private UUID routerId;
    @Column(name="router_parent_core_id",
    columnDefinition = "BINARY(16)")
    private UUID routerParentCoreId;
   /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.401.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">routerId</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">routerParentCoreId</span></strong><span class="koboSpan" id="kobo.405.1"> fields, we must set </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">columnDefinition</span></strong><span class="koboSpan" id="kobo.407.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">@Column</span></strong><span class="koboSpan" id="kobo.409.1"> annotation parameter, to </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">BINARY(16)</span></strong><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">It’s a requirement to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">UUID</span></strong><span class="koboSpan" id="kobo.413.1"> attributes work on</span><a id="_idIndexMarker882"/> <span class="No-Break"><span class="koboSpan" id="kobo.414.1">MySQL databases.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">Then, we create the relationship </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.416.1">mapping between routers and </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">other tables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
{
    /**Code omitted**/
   @ManyToOne(cascade = CascadeType.ALL)
   @JoinColumn(name="location_id")
   private LocationData routerLocation;
   @OneToMany(cascade = {CascadeType.MERGE},
   fetch = FetchType.EAGER)
   @JoinColumn(name="router_id")
   private List&lt;SwitchData&gt; switches;
   @OneToMany(cascade = CascadeType.ALL, fetch =
     FetchType.EAGER)
   @JoinColumn(name="router_parent_core_id")
   private Set&lt;RouterData&gt; routers;
   /**Code omitted**/
}</span></pre> <p><span class="koboSpan" id="kobo.419.1">Here, we define a many-to-one relation between routers and location. </span><span class="koboSpan" id="kobo.419.2">After that, we have two one-to-many relationships </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.420.1">with switches and routers, respectively. </span><span class="koboSpan" id="kobo.420.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">fetch = FetchType.EAGER</span></strong><span class="koboSpan" id="kobo.422.1"> property is used to avoid any mapping </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.423.1">errors that may occur during the </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">reactive connections.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">Let’s move on to the configuration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Switch</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.427.1">entity class.</span></span></p>
<h3><span class="koboSpan" id="kobo.428.1">The Switch entity</span></h3>
<p><span class="koboSpan" id="kobo.429.1">The following code shows us how </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.430.1">we should implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Switch</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.432.1">entity</span></span><span class="No-Break"><a id="_idIndexMarker887"/></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
@Entity
@Table(name = "switches")
public class SwitchData {
    @ManyToOne
    private RouterData router;
    @Id
    @Column(name="switch_id", columnDefinition =
      «BINARY(16)")
    private UUID switchId;
    @Column(name="router_id", columnDefinition =
      «BINARY(16)")
    private UUID routerId;
    @OneToMany(cascade = CascadeType.ALL, fetch =
      FetchType.EAGER)
    @JoinColumn(name="switch_id")
    private Set&lt;NetworkData&gt; networks;
    @ManyToOne
    @JoinColumn(name="location_id")
    private LocationData switchLocation;
    /**Code omitted**/
}</span></pre> <p><span class="koboSpan" id="kobo.435.1">We have omitted other column attributes to focus only on the IDs and relationships. </span><span class="koboSpan" id="kobo.435.2">We start by defining a many-to-one </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.436.1">relationship between switches and a router. </span><span class="koboSpan" id="kobo.436.2">The primary key is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">switchId</span></strong><span class="koboSpan" id="kobo.438.1"> field, which happens to be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">UUID</span></strong><span class="koboSpan" id="kobo.440.1"> attribute. </span><span class="koboSpan" id="kobo.440.2">We </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.441.1">have another </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">UUID</span></strong><span class="koboSpan" id="kobo.443.1"> attribute for mapping the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">routerId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1"> field.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Also, there is a one-to-many relationship between a switch and networks, and a many-to-one relationship between switches and </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">a location.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">Now, let’s configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Network</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.450.1">entity class.</span></span></p>
<h3><span class="koboSpan" id="kobo.451.1">The Network entity</span></h3>
<p><span class="koboSpan" id="kobo.452.1">Although we do not consider </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.453.1">networks to be entities in the domain model, they have a separate table in the database. </span><span class="koboSpan" id="kobo.453.2">So, at the Framework hexagon level, we treat them as database entities, but when they reach the Domain hexagon, we treat them as value objects. </span><span class="koboSpan" id="kobo.453.3">This example shows that </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.454.1">the hexagon system dictates how the data will be treated at the Domain hexagon level. </span><span class="koboSpan" id="kobo.454.2">By doing so, the hexagonal system shields the domain model from </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">technical details.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">We implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Network</span></strong><span class="koboSpan" id="kobo.458.1"> entity class </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
@Entity
@Table(name = "networks")
public class NetworkData {
    @ManyToOne
    @JoinColumn(name="switch_id")
    private SwitchData switchData;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name="network_id")
    private int id;
   /**Code omitted**/
}</span></pre> <p><span class="koboSpan" id="kobo.461.1">This is a straightforward entity class with a many-to-one relationship between networks and a switch. </span><span class="koboSpan" id="kobo.461.2">For networks, we rely on the database to generate network IDs. </span><span class="koboSpan" id="kobo.461.3">Also, networks are not considered entities in the domain model. </span><span class="koboSpan" id="kobo.461.4">Instead, we treat networks as value objects that are controlled by an aggregate. </span><span class="koboSpan" id="kobo.461.5">For aggregates, we need to handle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">UUID</span></strong><span class="koboSpan" id="kobo.463.1">, but for value objects, we do not. </span><span class="koboSpan" id="kobo.463.2">That’s why we don’t handle UUIDs for network </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">database entities.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">We still need to implement</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.466.1"> one last entity for location. </span><span class="koboSpan" id="kobo.466.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">do that.</span></span></p>
<h3><span class="koboSpan" id="kobo.468.1">The Location entity</span></h3>
<p><span class="koboSpan" id="kobo.469.1">In networks, location is not</span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.470.1"> considered an entity at the Domain hexagon level, but because we have a separate table for location, we need to treat it as a</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.471.1"> database entity at the Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">hexagon level.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">The following code is used to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">Location</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.475.1">entity class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
Entity
@Table(name = "location")
public class LocationData {
    @Id
    @Column(name="location_id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int locationId;
    @Column(name="address")
    private String address;
    @Column(name="city")
    private String city;
    /**Code omitted**/
}</span></pre> <p><span class="koboSpan" id="kobo.477.1">We again rely on the database’s built-in ID generation mechanism to handle IDs for location data. </span><span class="koboSpan" id="kobo.477.2">After that, we have attributes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">address</span></strong><span class="koboSpan" id="kobo.479.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">city</span></strong><span class="koboSpan" id="kobo.481.1"> that are part of </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">a location.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">Now that we have all the </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.484.1">required entities adequately configured, we can move ahead and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Panache</span></strong><span class="koboSpan" id="kobo.486.1"> to create reactive repository classes, which we’ll use to trigger database operations with the</span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.487.1"> entities </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">we’ve configured.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.489.1">Implementing reactive repository classes</span></h2>
<p><span class="koboSpan" id="kobo.490.1">By implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">PanacheRepositoryBase</span></strong><span class="koboSpan" id="kobo.492.1"> interface, you create a reactive repository class. </span><span class="koboSpan" id="kobo.492.2">We’ll need </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.493.1">one repository class for router operations and another for </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">switch operations.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">It’s paramount to define only one repository for the aggregate root. </span><span class="koboSpan" id="kobo.495.2">In our case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Router</span></strong><span class="koboSpan" id="kobo.497.1"> entity is the aggregate root for router management operations, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Switch</span></strong><span class="koboSpan" id="kobo.499.1"> is the aggregate root for switch management operations. </span><span class="koboSpan" id="kobo.499.2">The purpose of an aggregate is to ensure consistency across all objects that are controlled by such an aggregate. </span><span class="koboSpan" id="kobo.499.3">The entry point for any aggregate is always the aggregate root. </span><span class="koboSpan" id="kobo.499.4">To ensure aggregate consistency in a database transaction, we define only one repository class, which is dedicated to controlling the database operations based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">aggregate root.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">The classes we’re about to implement are located in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">dev.davivieira.topologyinventory.framework.adapters.output.mysql.repository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1"> package:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.504.1">The following code implements the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">RouterManagementRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.506.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.507.1">
@ApplicationScoped
public class RouterManagementRepository implements Pa
  nacheRepositoryBase&lt;RouterData, UUID&gt; {
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.508.1">Note that we’re passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">RouterData</span></strong><span class="koboSpan" id="kobo.510.1"> as the entity we’re working on and </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">UUID</span></strong><span class="koboSpan" id="kobo.512.1"> as the attribute type mapped to be used by the ID. </span><span class="koboSpan" id="kobo.512.2">If we don’t need any custom queries, we can leave this class empty because </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">Panache</span></strong><span class="koboSpan" id="kobo.514.1"> already provides lots of standard </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">database operations.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.516.1">Note that we’re also annotating that class with </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">@ApplicationScoped</span></strong><span class="koboSpan" id="kobo.518.1">, so we can inject that </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.519.1">component in other places, such as the output adapter, which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">implement soon.</span></span></p></li> <li><span class="koboSpan" id="kobo.521.1">The following code implements the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">SwitchManagementRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.523.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.524.1">
@ApplicationScoped
public class SwitchManagementRepository implements Pa
  nacheRepositoryBase&lt;SwitchData, UUID&gt; {
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.525.1">Here, we’re following the same approach we did for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">RouterManagementRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1"> class.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.528.1">With the reactive repository classes properly implemented, we’re ready to create reactive output adapters. </span><span class="koboSpan" id="kobo.528.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">do that!</span></span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.530.1">Implementing reactive output adapters</span></h2>
<p><span class="koboSpan" id="kobo.531.1">Just to recap, we need to </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.532.1">provide an adapter implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.534.1"> output </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">port interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
public interface RouterManagementOutputPort {
    Router retrieveRouter(Id id);
    boolean removeRouter(Id id);
    Router persistRouter(Router router);
}</span></pre> <p><span class="koboSpan" id="kobo.537.1">When implementing the MySQL output adapter, we’ll provide a reactive implementation for each one of the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">method declarations.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">We also need to</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.540.1"> implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">SwitchManagementOutputPort</span></strong><span class="koboSpan" id="kobo.542.1"> output </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">adapter interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
public interface SwitchManagementOutputPort {
    Switch retrieveSwitch(Id id);
}</span></pre> <p><span class="koboSpan" id="kobo.545.1">It’s simpler, as there’s just one method for which we need to provide a </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">reactive implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Let’s start by implementing the reactive output adapter for </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">router management.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.549.1">Reactive router management of the MySQL output adapter</span></h2>
<p><span class="koboSpan" id="kobo.550.1">In order to enable the hexagonal</span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.551.1"> system to communicate with a MySQL database, we need to create a new output adapter to</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.552.1"> allow such integration (because we’re using Quarkus, such an output adapter implementation is fairly simple). </span><span class="koboSpan" id="kobo.552.2">We’ll use the following steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">do so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.554.1">We start by injecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">RouterManagementRepository</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.556.1">repository class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
@ApplicationScoped
public class RouterManagementMySQLAdapter implements
  RouterManagementOutputPort {
    @Inject
    RouterManagementRepository
      routerManagementRepository;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.558.1">We’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">RouterManagementRepository</span></strong><span class="koboSpan" id="kobo.560.1"> repository to make </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">database operations.</span></span></p></li> <li><span class="koboSpan" id="kobo.562.1">Then, we</span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.563.1"> implement</span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.564.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">retrieveRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.566.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.567.1">
@Override
public Router retrieveRouter(Id id) {
    var routerData =
    routerManagementRepository.findById(id.getUuid())
      .subscribe()
      .asCompletionStage()
      .join();
    return RouterMapper.routerDataToDomain(router
      Data);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.568.1">When we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">routerManagementRepository.findById(id.getUuid())</span></strong><span class="koboSpan" id="kobo.570.1">, the system starts an I/O non-blocking operation. </span><span class="koboSpan" id="kobo.570.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">subscribe</span></strong><span class="koboSpan" id="kobo.572.1"> call tries to resolve the item produced by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">findById</span></strong><span class="koboSpan" id="kobo.574.1"> operation. </span><span class="koboSpan" id="kobo.574.2">Then, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">asCompletionStage</span></strong><span class="koboSpan" id="kobo.576.1"> to receive the item. </span><span class="koboSpan" id="kobo.576.2">Finally, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">join</span></strong><span class="koboSpan" id="kobo.578.1">, which returns the result value when the operation </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">is complete.</span></span></p></li> <li><span class="koboSpan" id="kobo.580.1">Now, we</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.581.1"> need to implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">removeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.583.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.584.1">
@Override
public Router removeRouter(Id id) {
 return routerManagementRepository
        .deleteById(
        id.getUuid())
        .subscribe().asCompletionStage().join();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.585.1">Here, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">routerManagementRepository.deleteById(id.getUuid())</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.587.1">Panache</span></strong> <a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.588.1">operation to remove a router from the database. </span><span class="koboSpan" id="kobo.588.2">After that, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">subscribe</span></strong><span class="koboSpan" id="kobo.590.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">asCompletionStage</span></strong><span class="koboSpan" id="kobo.592.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">join</span></strong><span class="koboSpan" id="kobo.594.1"> to execute the </span><a id="_idIndexMarker906"/><span class="No-Break"><span class="koboSpan" id="kobo.595.1">operations reactively.</span></span></p></li> <li><span class="koboSpan" id="kobo.596.1">Finally, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">persistRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.598.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
@Override
public Router persistRouter(Router router) {
    var routerData =
    RouterH2Mapper.routerDomainToData(router);
    Panache.withTransaction(
    ()-&gt;routerManagementRepository.persist
    (routerData));
    return router;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.600.1">The construct is different here. </span><span class="koboSpan" id="kobo.600.2">To ensure that the transaction will not be lost between the client and server during the request, we wrap the persistence operation inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">Panache.withTransaction</span></strong><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">This is a requirement for operations where we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">persist data.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.604.1">Let’s now implement the reactive output adapter for </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">switch management.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.606.1">Reactive switch management of the MySQL output adapter</span></h2>
<p><span class="koboSpan" id="kobo.607.1">The approach used here is the same</span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.608.1"> one utilized when we implemented the reactive output adapter for router management. </span><span class="koboSpan" id="kobo.608.2">We’ll</span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.609.1"> execute the following steps to implement the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">output adapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.611.1">Let’s start by injecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">SwitchManagementRepository</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.613.1">repository class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.614.1">
@ApplicationScoped
public class SwitchManagementMySQLAdapter implements
  SwitchManagementOutputPort {
    @Inject
    SwitchManagementRepository
      switchManagementRepository;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.615.1">As we already saw, the </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.616.1">injection of a repository class is required so we can use it to trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">database operations.</span></span></p></li> <li><span class="koboSpan" id="kobo.618.1">After that, we im</span><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.619.1">plement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">retrieveSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.621.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.622.1">
@Override
public Switch retrieveSwitch(Id id) {
    var switchData =
    switchManagementRepository.findById(id.getUuid())
       .subscribe()
       .asCompletionStage()
       .join();
    return RouterMapper.switchDataToDo
      main(switchData);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.623.1">We use this method to retrieve a </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">Switch</span></strong><span class="koboSpan" id="kobo.625.1"> object reactively. </span><span class="koboSpan" id="kobo.625.2">There are no persistence methods because all the write operations should always occur through a router management </span><a id="_idIndexMarker910"/><span class="No-Break"><span class="koboSpan" id="kobo.626.1">output adapter.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.627.1">By implementing reactive </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.628.1">output adapters in the hexagonal system, we can tap into the advantages of reactive programming techniques. </span><span class="koboSpan" id="kobo.628.2">With hexagonal architecture, it’s not a big deal to have both reactive and imperative output adapters serving different needs in the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">same system.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">The Quarkus reactive features for databases are paramount for anyone venturing into developing reactive systems. </span><span class="koboSpan" id="kobo.630.2">We can provide a reactive alternative to how our application deals with databases by understanding how to use these features. </span><span class="koboSpan" id="kobo.630.3">That does not mean that the reactive approach is always a better choice than the traditional imperative one; it’s up to you and your project’s needs to decide which approach is </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">more suitable.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">Now that we’ve implemented the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">RouterManagementMySQLAdapter</span></strong><span class="koboSpan" id="kobo.634.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">SwitchManagementMySQLAdapter</span></strong><span class="koboSpan" id="kobo.636.1"> output adapters, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">test them.</span></span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.638.1">Testing the reactive output adapters</span></h1>
<p><span class="koboSpan" id="kobo.639.1">We need to implement </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.640.1">unit tests to ensure the methods from the output adapters are working as expected. </span><span class="koboSpan" id="kobo.640.2">Here is an example of how we can create unit tests </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">RouterManagementMySQLAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.644.1">
@QuarkusTest
public class RouterManagementMySQLAdapterTest {
    @InjectMock
    RouterManagementMySQLAdapter
    routerManagementMySQLAdapter;
    @Test
    public void testRetrieveRouter() {
        Router router = getRouter();
        Mockito.when(
        routerManagementMySQLAdapter.
</span><span class="koboSpan" id="kobo.644.2">        retrieveRouter(router.getId())).thenReturn(router);
        Router retrievedRouter =
        routerManagementMySQLAdapter.
</span><span class="koboSpan" id="kobo.644.3">        retrieveRouter(router.getId());
        Assertions.assertSame(router, retrievedRouter);
    }
   /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.645.1">It’s possible to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">@InjectMock</span></strong><span class="koboSpan" id="kobo.647.1"> annotation to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">RouterManagementMySQLAdapter</span></strong><span class="koboSpan" id="kobo.649.1"> output adapter. </span><span class="koboSpan" id="kobo.649.2">When executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">testRetrieveRouter</span></strong><span class="koboSpan" id="kobo.651.1"> test method, we can mock a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">routerManagementMySQLAdapter.retrieveRouter(router.getId)</span></strong><span class="koboSpan" id="kobo.653.1"> by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">Mockito.when</span></strong><span class="koboSpan" id="kobo.655.1">. </span><span class="koboSpan" id="kobo.655.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">thenReturn</span></strong><span class="koboSpan" id="kobo.657.1"> method returns the object that our mock test should return. </span><span class="koboSpan" id="kobo.657.2">In this case, it is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">Router</span></strong><span class="koboSpan" id="kobo.659.1"> object. </span><span class="koboSpan" id="kobo.659.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">Assertions.assertSame(router, retrievedRouter)</span></strong><span class="koboSpan" id="kobo.661.1">, we can assert the result for the execution </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">retrieveRouter(router.getId)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.665.1">We won’t need to implement</span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.666.1"> new test classes to execute integration tests for Reactive output adapters. </span><span class="koboSpan" id="kobo.666.2">We can rely on the same tests used in the previous chapter to test the reactive input adapters. </span><span class="koboSpan" id="kobo.666.3">These tests call the input adapters, which, in turn, call the output adapters by using the use </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">case operations.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">However, what changes is that we’ll need a MySQL database to test the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">output adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Quarkus provides Docker-based containers that we can use for development purposes or testing. </span><span class="koboSpan" id="kobo.670.2">In order to enable such a database container, there is no need to provide a detailed data source connection configuration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">application.properties</span></strong><span class="koboSpan" id="kobo.672.1"> file. </span><span class="koboSpan" id="kobo.672.2">Here is how we should configure that file for </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">testing purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
quarkus.datasource.db-kind=mysql
quarkus.datasource.reactive=true
quarkus.hibernate-orm.database.generation=drop-and-create
quarkus.hibernate-orm.sql-load-script=inventory.sql
quarkus.vertx.max-event-loop-execute-time=100</span></pre> <p><span class="koboSpan" id="kobo.675.1">Note that we’re not specifying a </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.676.1">database connection URL. </span><span class="koboSpan" id="kobo.676.2">By doing that, Quarkus understands that it needs to provide a database. </span><span class="koboSpan" id="kobo.676.3">The previously described </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">application.properties</span></strong><span class="koboSpan" id="kobo.678.1"> file should be placed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">tests/resource/</span></strong><span class="koboSpan" id="kobo.680.1"> directory. </span><span class="koboSpan" id="kobo.680.2">Inside this directory, we should also place the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">inventory.sql</span></strong><span class="koboSpan" id="kobo.682.1"> file, which loads data into the database. </span><span class="koboSpan" id="kobo.682.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">.sql</span></strong><span class="koboSpan" id="kobo.684.1"> file is available in this chapter’s </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">You can override entries in </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">application.properties</span></strong><span class="koboSpan" id="kobo.688.1"> to use environment variables. </span><span class="koboSpan" id="kobo.688.2">This may be useful for configurations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">quarkus.hibernate-orm.database.generation</span></strong><span class="koboSpan" id="kobo.690.1"> where you can set the property value based on the application’s environment variables. </span><span class="koboSpan" id="kobo.690.2">For example, for local or development purposes, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">${DB_GENERATION}</span></strong><span class="koboSpan" id="kobo.692.1">, an environment variable that resolves to </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">drop-and-create</span></strong><span class="koboSpan" id="kobo.694.1">. </span><span class="koboSpan" id="kobo.694.2">In production, this environment variable can resolve </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">none</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">After properly setting up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">application.properties</span></strong><span class="koboSpan" id="kobo.700.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">inventory.sql</span></strong><span class="koboSpan" id="kobo.702.1"> files, we can test the application by running the following command in the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">root directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.704.1">
$ mvn test</span></pre> <p><span class="koboSpan" id="kobo.705.1">The following output shows the MySQL Docker container being brought up to be used </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">during tests:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.707.1">
2021-10-10 01:33:40,242 INFO  [  .0.24]] (build-10) Creating container for image: mysql:8.0.24
2021-10-10 01:33:40,876 INFO  [  .0.24]] (build-10) Starting container with ID: 67e788aab66f2f2c6bd91c0be1a164117294ac29cc574941ad41ff5760de918c
2021-10-10 01:33:41,513 INFO  [  .0.24]] (build-10) Container mysql:8.0.24 is starting: 67e788aab66f2f2c6bd91c0be1a164117294ac29cc574941ad41ff5760de918c
2021-10-10 01:33:41,520 INFO  [  .0.24]] (build-10) Waiting for database connection to become available at jdbc:mysql://localhost:49264/default using query 'SELECT 1'
2021-10-10 01:34:01,078 INFO  [  .0.24]] (build-10) Container is started (JDBC URL: jdbc:mysql://localhost:49264/default)
2021-10-10 01:34:01,079 INFO  [  .0.24]] (build-10) Container mysql:8.0.24 started in PT20.883579S
2021-10-10 01:34:01,079 INFO  [io.qua.dev.mys.dep.MySQLDevServicesProcessor] (build-10) Dev Services for MySQL started.</span></pre> <p><span class="koboSpan" id="kobo.708.1">Quarkus creates a database called </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">default</span></strong><span class="koboSpan" id="kobo.710.1">, where the tables are created. </span><span class="koboSpan" id="kobo.710.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">inventory.sql</span></strong><span class="koboSpan" id="kobo.712.1"> file is run </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.713.1">against this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">default</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.715.1"> database.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">After the database is ready, Quarkus starts testing the system, resulting in a result similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">following one:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.718.1">
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 32.672 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.NetworkManagementAdapterTest
[INFO] Running dev.davivieira.topologyinventory.framework.adapters.input.rest.RouterManagementAdapterTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.232 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.RouterManagementAdapterTest
[INFO] Running dev.davivieira.topologyinventory.framework.adapters.input.rest.SwitchManagementAdapterTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.088 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.SwitchManagementAdapterTest
[INFO] Running dev.davivieira.topologyinventory.framework.adapters.input.rest.outputAdapters.RouterManagementMySQLAdapterTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.116 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.outputAdapters.RouterManagementMySQLAdapterTest
[INFO] Running dev.davivieira.topologyinventory.framework.adapters.input.rest.outputAdapters.SwitchManagementMySQLAdapterTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.013 s - in dev.davivieira.topologyinventory.framework.adapters.input.rest.outputAdapters.SwitchManagementMySQLAdapterTest</span></pre> <p><span class="koboSpan" id="kobo.719.1">In order to test the output </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.720.1">adapters, we need to call the input adapters. </span><span class="koboSpan" id="kobo.720.2">If we can test the input adapters successfully, that means we’re also testing the output </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">adapters successfully.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.722.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.723.1">Hibernate Reactive and </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">Panache</span></strong><span class="koboSpan" id="kobo.725.1"> make our lives much easier when we need to handle databases reactively using Quarkus. </span><span class="koboSpan" id="kobo.725.2">We learned that Hibernate Reactive is built on top of the traditional Hibernate implementation but with the addition of </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">reactive features.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">While looking into </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">Panache</span></strong><span class="koboSpan" id="kobo.729.1">, we learned that it can help us implement the Active Record and Repository patterns to implement database operations. </span><span class="koboSpan" id="kobo.729.2">For the hands-on part, we implemented database entities, repositories, and reactive output adapters, which we used together to interact with the MySQL database. </span><span class="koboSpan" id="kobo.729.3">Finally, we configured the hexagonal system tests to use the MySQL Docker container that </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">Quarkus provides.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">In the next chapter, we’ll learn about some techniques for packaging the hexagonal system in a Docker image. </span><span class="koboSpan" id="kobo.731.2">We’ll also learn how to run the hexagonal system in a Kubernetes cluster. </span><span class="koboSpan" id="kobo.731.3">This knowledge will enable us to make our hexagonal application ready to be deployed in </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">cloud-based environments.</span></span></p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.733.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.734.1">Which Java specification does Hibernate </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">Reactive implement?</span></span></li>
<li><span class="koboSpan" id="kobo.736.1">What is the difference between the Active Record and </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">Repository patterns?</span></span></li>
<li><span class="koboSpan" id="kobo.738.1">Whi</span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.739.1">ch interface should we implement to apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">Repository pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.741.1">Why should we run write operations inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">withTransaction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.743.1"> method?</span></span></li>
</ol>
<h1 id="_idParaDest-225"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.744.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.745.1">Hibernate Reactive implements the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.746.1">JPA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.747.1"> specification.</span></span></li>
<li><span class="koboSpan" id="kobo.748.1">The Active Record pattern allows us to use the entity class to perform operations on the database, whereas we have a dedicated class in the Repository pattern to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">such operations.</span></span></li>
<li><span class="koboSpan" id="kobo.750.1">We should implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">PanacheRepositoryBase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.752.1"> interface.</span></span></li>
<li><span class="koboSpan" id="kobo.753.1">To ensure the database transaction won’t be lost during the </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">reactive operation.</span></span></li>
</ol>
</div>
</body></html>