- en: Basics of Akka Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Streams基础知识
- en: In this chapter, we’ll take a closer look at Akka Streams. We will start with
    a basic description of streams in general, and Reactive Streams in particular.
    We'll touch on the concept of back pressure and provide some motivation for you
    to use Akka Streams as a concrete implementation of the Reactive Streams standard.
    We'll reimplement our bakery yet again, this time using streams as a design abstraction.
    This will allow us to examine in detail the basics of Akka Streams, such as flows
    and graphs, error handling, and testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解Akka Streams。我们将从一般流的描述开始，特别是反应式流的描述。我们将触及反压的概念，并为你提供一些使用Akka
    Streams作为反应式流标准的具体实现的动机。我们将再次实现我们的面包店，这次使用流作为设计抽象。这将使我们能够详细检查Akka Streams的基本知识，如流和图、错误处理和测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reactive Streams
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式流
- en: Back pressure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反压
- en: Akka Streams philosophy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka Streams哲学
- en: Akka Streams essential concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka Streams基本概念
- en: Sources and sinks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源和汇
- en: Flows
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: Graphs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图
- en: Logging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Materialization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实化
- en: Failure handling
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障处理
- en: Testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Installed Scala
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装的Scala
- en: Installed SBT
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装的SBT
- en: 'Source code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter13](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter13).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在GitHub上找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter13](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter13)。
- en: Introduction to Akka Streams
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Streams简介
- en: The word *stream* is vastly overloaded in meaning in modern computing. It carries
    many different meanings depending on the context. For instance, in Java, in different
    times streaming meant an abstraction over blocking IO, non-blocking IO, and later,
    a way to express data processing queries.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算中，“流”这个词在意义上被大量复用。它根据上下文的不同承载着许多不同的含义。例如，在Java中，在不同的时期，“流”意味着对阻塞IO、非阻塞IO的抽象，后来又成为表达数据处理查询的一种方式。
- en: In essence, a stream in computing is just a flow of data or instructions. Usually,
    the content of a stream is not loaded into memory fully. This possibility to process
    basically unlimited amounts of information on devices with limited memory capacity
    is a motivating factor for the rise of streams, popularity that has been happening
    recently.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，计算中的流只是数据或指令的流动。通常，流的内容不会完全加载到内存中。这种在内存容量有限的设备上处理基本上无限量的信息的能力是流兴起的一个推动因素，这种流行趋势最近正在发生。
- en: The definition of the stream as a flow implies that it should have some source
    and a destination of data elements. In computing, these concepts are naturally
    expressed in the code in a way that on one side of the flow the code emits data
    and on another side other code consumes this data. The emitting side is usually
    called the **producer** and the receiving side is respectively a **consumer**.
    Usually, there will be a portion of data in the memory which was already issued
    by the producer but not yet ingested by the consumer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 流作为流动的定义意味着它应该有一些数据元素来源和目的地。在计算中，这些概念自然地在代码中以某种方式表达，即在流动的一侧代码发出数据，在另一侧其他代码消费这些数据。发出数据的一侧通常被称为**生产者**，接收数据的一侧相应地称为**消费者**。通常，在内存中会有一些数据，这些数据已经被生产者发出但尚未被消费者摄取。
- en: 'This aspect of the stream brings up the next idea: it should be possible to
    manipulate data in-flight by code in-between, the same way a water heater is plugged
    in between the inlet and a water tap and *changes* cold water into hot water.
    Interestingly, the presence of a water heater in this scenario is not known to
    the producer or to the consumer. If the scenario is that the water flow increases
    in intensity, we could easily imagine having another heater plugged in or replacing
    the existing one with a more powerful model. The water heater becomes the property
    of the flow in the sense that the quantity of the water received by the consumer
    depends on the amounts emitted by the producer, but the temperature depends on
    properties of the pipe system, or in essence, of the flow.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 流的这一特性引发了下一个想法：应该可以通过中间的代码在飞行中操纵数据，就像热水器插在进水口和水龙头之间，*改变*冷水为热水一样。有趣的是，在这个场景中，生产者或消费者并不知道热水器的存在。如果水流强度增加，我们可以很容易地想象插入另一个热水器或用更强大的型号替换现有的一个。热水器在意义上成为流的所有权，即消费者接收到的水量取决于生产者发出的量，但温度取决于管道系统的特性，或者说本质上就是流的特性。
- en: 'This is the basic idea behind using streams: a stream is usually seen as a
    combination of producer, consumer, and transformation steps in between. In a streaming
    scenario, the producer and consumer become less interesting and the main focus
    shifts to the transformation steps in the middle. For the sake of modularity and
    code reuse, defining many tiny transformations is usually considered to be a preferable
    approach.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用流的基本理念：流通常被视为生产者、消费者以及中间的转换步骤的组合。在流式传输场景中，生产者和消费者变得不那么有趣，主要焦点转向中间的转换步骤。为了模块化和代码重用，定义许多微小的转换通常被认为是更可取的方法。
- en: Depending on the art of transferring data between the parts of the stream, we
    distinguish between pushing and pulling elements of the stream.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在流的部分之间传输数据的技术，我们区分流的推送和拉取元素。
- en: With the push, it is the producer who controls the process. The data is pushed
    to the stream as soon as it becomes available and the rest of the stream is supposed
    to be able to absorb it. Naturally, it is not always possible to consume data
    which is produced at an unpredictable rate. In the case of streaming, it is dealt
    with by dropping data or using buffers. Dropping data is sometimes appropriate
    but more often is undesired. Buffers have limited size and thus can become full
    if data is produced faster than it is consumed for a long period of time. A full
    buffer yet again leads to memory overflow or the need to drop data. Visibly, with
    the push model, a combination of a fast producer and a slow consumer is a problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送模型中，生产者控制整个过程。数据一旦可用，就会推送到流中，其余的流应该能够吸收它。自然地，并不是总是可能以不可预测的速度消费生产出的数据。在流式传输的情况下，这通常通过丢弃数据或使用缓冲区来处理。丢弃数据有时是合适的，但更常见的是不希望这样做。缓冲区的大小有限，因此如果数据产生速度超过消费速度，长时间内可能会填满。满缓冲区再次导致内存溢出或需要丢弃数据。显然，在推送模型中，快速生产者和慢速消费者的组合是一个问题。
- en: With the pull model, it is the consumer who drives the process. It tries to
    read the data from the stream as soon as it needs it. If there is some data, it
    is taken. If there is no data, the consumer has a choice between waiting for it
    or trying again at a later moment. Usually, both possibilities are less than ideal.
    Waiting for the data is usually done by blocking and polling data, which means
    excessive consumption of resources and delays between the moment the data becomes
    available and its consumption. Evidently, the pull model is not optimal in the
    case of a slow producer and fast consumer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉取模型中，消费者驱动整个过程。它试图在需要时尽快从流中读取数据。如果有数据，就取走。如果没有数据，消费者可以选择等待或稍后再次尝试。通常，这两种可能性都不太理想。等待数据通常是通过阻塞和轮询数据来完成的，这意味着资源过度消耗以及数据可用和消费之间的延迟。显然，在慢速生产者和快速消费者的情况下，拉取模型并不是最优的。
- en: This dichotomy led to the creation of the dynamic pull-push concept named Reactive
    Streams and an initiative of the same name in 2013 by engineers at Lightbend,
    Netflix, and Pivotal.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种二分法导致了名为反应式流的动态拉取-推送概念的创造，以及2013年由Lightbend、Netflix和Pivotal的工程师发起的同名倡议。
- en: Reactive Streams and backpressure
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流和背压
- en: Reactive Streams ([http://www.reactive-streams.org](http://www.reactive-streams.org)) is
    an initiative to provide a standard for asynchronous stream processing with non-blocking
    backpressure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 反应流([http://www.reactive-streams.org](http://www.reactive-streams.org))是一个旨在提供异步流处理非阻塞背压标准的倡议。
- en: The non-blocking back pressure is a mechanism to deal with deficiencies of both
    pull and push semantics in the streaming environment. It is better explained by
    an example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞背压是一种处理流环境中拉取和推送语义缺陷的机制。通过一个例子来解释会更好。
- en: Imagine a building site with a foreman responsible for timely delivery of building
    materials among other duties. The site can only accommodate as much as 100 tons
    of materials. The foreman can order materials from another company but the orders
    are taken by one of the truck drivers as soon as one is in the company's office
    and not bringing materials to the customer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个建筑工地，工头负责及时交付建筑材料，以及其他职责。工地只能容纳最多 100 吨的材料。工头可以从另一家公司订购材料，但订单是由卡车司机在公司的办公室接收，而不是将材料运送给客户。
- en: The pull behavior for the foreman would be to call a contractor and wait until
    a truck driver is in the office and answers the call (blocking pull) or make calls
    periodically with the hope that this time somebody will pick up the phone (polling).
    In our case, the foreman sends a voice message to the contractor asking for 100
    tons of materials and returns to his daily work instead. This is a non-blocking
    pull.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工头来说，拉取行为可能是打电话给承包商并等待卡车司机在办公室并接听电话（阻塞拉取），或者定期打电话，希望这次有人会接电话（轮询）。在我们的案例中，工头给承包商发送语音消息，要求
    100 吨材料，然后返回日常工作。这是一种非阻塞拉取。
- en: The contractor accepts the order as soon as they have the capacity to do so.
    They are about to send a couple of trucks with the capacity of 32 tons each but
    realize they cannot send more than 100 tons because the building site won't be
    able to receive such volume. Therefore, only three trucks and 96 tons of materials
    are sent.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 承包商一旦有足够的能力，就会接受订单。他们准备发送几辆每辆容量为 32 吨的卡车，但意识到他们不能发送超过 100 吨，因为工地无法接收这么大的量。因此，只发送了三辆卡车和
    96 吨材料。
- en: After 30 tons of materials are consumed, the foreman realizes that they can
    order more from the contractor to avoid the building site becoming idle later
    if the rest of materials are quickly consumed. They order another 30 tons. But
    the contractor remembers that there are still another 4 tons remaining from the
    previous order so it is safe to send another full truck with 32 tons which can
    fit in the single truck. We reflect the fact that some demand in the first request
    was satisfied later by consecutive delivery and saying that requests are additive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗了 30 吨材料后，工头意识到他们可以再从承包商那里订购更多，以避免如果剩余材料快速消耗，工地后来变得闲置。他们又订购了 30 吨。但承包商记得前一个订单还剩下另外
    4 吨，所以可以安全地发送另一辆载有 32 吨的整车，这可以装进一辆单独的卡车。我们反映的事实是，第一次请求中的一些需求是通过连续交付后来得到满足的，我们说请求是可累加的。
- en: And this is basically how the backpressure concept of Reactive Streams works.
    It is arguable that in reality the approach would be better reflected by the name
    *forward ease* but probably this name wouldn't take off as *back-pressure* did.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是反应流背压概念的工作方式。在现实中，这种方法可能更好地反映为“向前轻松”，但这个名字可能不会像“背压”那样流行。
- en: The Reactive Stream specification strives to define a low-level API which can
    be implemented by different libraries in order to achieve interoperability between
    implementation. The standard defines the API and the **Technology Compatibility
    Kit** (**TCK**) which is a standard test suite for the API implementations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 反应流规范努力定义一个低级 API，它可以由不同的库实现，以实现实现之间的互操作性。该标准定义了 API 和**技术兼容性工具包**（**TCK**），这是一个
    API 实现的标准测试套件。
- en: TCK purpose is to help library authors to validate that their implementations
    adhere to the standard.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TCK 的目的是帮助库作者验证他们的实现是否符合标准。
- en: 'The API contains the following components:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: API 包含以下组件：
- en: Publisher
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者
- en: Subscriber
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者
- en: Subscription
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅
- en: Processor
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器
- en: The `Publisher` represents the source, the `Subscriber` relates to the consumer,
    the Processor is a processing stage of the stream, and the `Subscription` is a
    representation of the back-pressure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`发布者`代表源，`订阅者`与消费者相关，处理器是流的处理阶段，而`订阅`是背压的表示。'
- en: All of the methods defined in the API return `void` which means they are intended
    to be executed without the caller waiting for the result, hence the *async**hronous
    stream processing* in the definition of the Reactive Streams standard.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: API中定义的所有方法都返回`void`，这意味着它们旨在在不等待调用者等待结果的情况下执行，因此Reactive Streams标准定义中的*异步流处理*。
- en: Reactive Streams is a library standard and defines how libraries are expected
    to communicate with each other in order to be able to interoperate. It is expected
    that libraries will offer different, higher-level APIs to the user, likely reflecting
    some aspects of the implementation details.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams是一个库标准，定义了库如何相互通信，以便能够进行交互。预计库将为用户提供不同的高级API，可能反映了某些实现细节。
- en: Akka Streams is one of such libraries built using Akka actors as the underlying
    technology. It implements the Reactive Streams standard and has a rich, high-level
    API which allows you to describe streams using high-level DSL and also exhibits
    the underlying Akka machinery.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams是使用Akka演员作为底层技术构建的此类库之一。它实现了Reactive Streams标准，并具有丰富的、高级的API，允许您使用高级DSL描述流，并展示了底层的Akka机制。
- en: Akka Streams
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Streams
- en: The purpose of Akka Streams ([https://doc.akka.io/docs/akka/2.5.13/stream/stream-introduction.html](https://doc.akka.io/docs/akka/2.5.13/stream/stream-introduction.html))
    is to offer an intuitive and safe way to formulate stream processing setups such
    that we can execute them efficiently and with bounded resource usage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams（[https://doc.akka.io/docs/akka/2.5.13/stream/stream-introduction.html](https://doc.akka.io/docs/akka/2.5.13/stream/stream-introduction.html)）的目的是提供一种直观且安全的方式来制定流处理设置，以便我们可以高效地执行它们，并且资源使用量有限。
- en: Akka Streams fully implements a Reactive Stream standard in order to interoperate
    with another compliant Reactive Streams library, but this fact is usually considered
    to be an implementation detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams完全实现了Reactive Stream标准，以便与其他符合Reactive Streams规范的库进行交互，但这一事实通常被视为实现细节。
- en: The initial motivation for Akka Streams was the fact that all Akka actor systems
    share the same sets of technical problems, which adds accidental complexity and
    needs to be solved for almost every single project separately over and over again.
    For example, Akka does not have any general flow control mechanism, and in order
    to prevent an actor's mailboxes from overflowing, it needs to be implemented as
    a home-grown solution within every application. Another common pain point is the
    at-most-once messaging semantics, which is less than ideal in most cases, but
    also dealt with on an individual basis. Yet another inconvenience Akka is criticized
    for is its untyped nature. The absence of types makes it impossible to check the
    soundness of possible interactions between actors at the compile time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams最初的动机是所有Akka actor系统都面临着相同的技术问题，这增加了意外的复杂性，并且几乎需要为每个单独的项目单独解决多次。例如，Akka没有通用的流控制机制，并且为了防止actor的邮箱溢出，它需要在每个应用程序中实现为自制的解决方案。另一个常见的痛点是至多一次的消息语义，这在大多数情况下都不理想，但也是逐个解决的。另一个Akka受到批评的不便之处是其无类型性质。类型的缺失使得在编译时检查actor之间可能交互的健全性成为不可能。
- en: Akka Streams aim to solve this problem by placing a streaming layer on top of
    the actor system. This layer adheres to the small set of architectural principles
    to provide a consistent user experience. These principles are a comprehensive
    domain model for stream processing and compositionally. The focus of the library
    lies in modular data transformation. In this sense, Reactive Streams are just
    an implementation detail for how data is passed between steps of the flow and
    Akka actors are the implementation detail for individual steps.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams旨在通过在actor系统之上放置一个流层来解决此问题。这一层遵循一组小的架构原则，以提供一致的用户体验。这些原则是流处理和组合的全面领域模型。库的重点在于模块化数据转换。从这个意义上说，Reactive
    Streams只是数据在流程步骤之间传递的实现细节，而Akka演员则是单个步骤的实现细节。
- en: The principle of the completeness of the domain model for distributed bounded
    stream processing means that Akka Streams has a rich DSL that allows you to express
    all aspects of the domain, such as single processing and transformation steps
    and their interconnections, streams with complex graph topologies, back-pressure,
    error and failure handling, buffering and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式有界流处理的领域模型完整性的原则意味着 Akka Streams 拥有一个丰富的 DSL，允许你表达领域的各个方面，例如单个处理和转换步骤及其相互连接，具有复杂图拓扑的流，背压，错误和故障处理，缓冲等等。
- en: 'The modularity principle means that the definition of single transformations,
    multiple transformations connected in specific ways, or even whole graphs must
    be freely shareable. This principle leads to the design decision to make the description
    of the stream separate from the execution of the stream. Therefore, a user of
    Akka Streams has to go over the following three steps to execute a stream:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化原则意味着单个转换、以特定方式连接的多个转换，甚至整个图的定义必须是可自由共享的。这一原则导致了将流描述与流执行分离的设计决策。因此，Akka Streams
    的用户必须完成以下三个步骤来执行流：
- en: Describe the stream in the form of building blocks and connections between them.
    The result of this step is usually called a *blueprint* in Akka documentation.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以构建块及其之间连接的形式描述流。这一步骤的结果通常在 Akka 文档中被称为**蓝图**。
- en: Materialize the blueprint which creates an instance of the flow. The materialization
    is done by providing a materializer which in Akka takes the form of using an actor
    system or an actor context to create actors for each processing stage.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 材料化蓝图以创建流的实例。材料化是通过提供一个材料化器来完成的，在 Akka 中，这采取使用 actor 系统或 actor 上下文为每个处理阶段创建
    actor 的形式。
- en: Execute a materialized stream using one of the `run` methods.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `run` 方法之一执行材料化流。
- en: In practice, usually the last two steps are combined and the materializer is
    provided as an implicit parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，通常最后两个步骤会合并，并将材料化器作为隐式参数提供。
- en: With this theory in mind, let's take a look at what building and executing streams
    with Akka Streams looks like in practice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个理论，让我们看看在实际中如何使用 Akka Streams 构建和执行流。
- en: Setup and dependency
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和依赖
- en: 'In order to make Akka Streams available in our project, we need to put the
    following dependency into the `build.sbt` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Akka Streams 可用于我们的项目，我们需要将以下依赖项放入 `build.sbt` 文件中：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives us the possibility to import related classes in our examples using
    the following import statements:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用以下导入语句在我们的示例中导入相关类：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These import statements are assumed to be present in every example later in
    this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下导入语句在本书后面的每个示例中都是现成的。
- en: 'We will also need a wrapper which would provide an actor system in order for
    us to be able to create materializers for our streams. The wrapper will need to
    terminate the actor system as soon as stream processing is finished:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个包装器，以便我们能够为我们的流创建材料化器。包装器需要在流处理完成后立即终止actor系统：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, before we dive into the code, we need some vocabulary to be able to describe
    what we are doing in our examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们深入代码之前，我们需要一些词汇来描述我们在示例中所做的工作。
- en: Essential concepts
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心概念
- en: Let's take a look at the vocabulary Akka Streams uses to describe streams and
    their elements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Akka Streams 用来描述流及其元素的词汇表。
- en: As described earlier, every stream has producer, consumer, and transformation
    steps. In Akka Streams they are named `Source`, `Sink`, and `Flow` respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个流都有生产者、消费者和转换步骤。在 Akka Streams 中，它们分别命名为 `Source`、`Sink` 和 `Flow`。
- en: More formally, in Akka Streams any building block of a stream is named a **processing
    stage**. A processing stage with a single output is a `Source`, a single input
    is a `Sink` and with one input, and one output is a `Flow`. By connecting a source
    and a sink to the flow we build a *Runnable Graph* which can be executed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，在 Akka Streams 中，任何流构建块都被称为**处理阶段**。具有单个输出的处理阶段是 `Source`，单个输入的是 `Sink`，具有一个输入和一个输出的则是
    `Flow`。通过将源和汇连接到流中，我们构建了一个可执行的**可运行图**。
- en: 'There are also special processing stages:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些特殊的处理阶段：
- en: Fan-in with two or more inputs and one output
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有两个或多个输入和一个输出的扇入
- en: Fan-out with one input and two or more outputs
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有一个输入和两个或更多输出的扇出
- en: Bidiflow with two inputs and two outputs pointing in opposite directions
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有两个输入和两个输出且方向相反的Bidiflow
- en: 'We made up the following diagram with all processing stages interconnected
    to simplify grasping the concept. The dotted lines represent the backpressure
    we mentioned earlier:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制了以下图，其中所有处理阶段相互连接，以简化概念的理解。虚线表示我们之前提到的背压：
- en: '![](img/5c4245c1-3382-4c1f-b4ba-2979973eee88.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c4245c1-3382-4c1f-b4ba-2979973eee88.png)'
- en: Figure 1\. Different processing stages interconnected in runnable graph
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.可运行图中的不同处理阶段相互连接
- en: Structure of the example
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例结构
- en: 'Let''s see how the streaming implementation changes the shape of our bakery
    app we''ve built [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An
    Introduction to the Akka and Actor Models*, and [Chapter 12](caabef7a-c854-4b39-b8fb-ac17b8ba6eee.xhtml),
    *Building Reactive Applications with Akka Typed*. To recap, this is the design
    of the bakery represented with actors:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看流式实现是如何改变我们构建的面包店应用的形状的[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，*Akka和Actor模型简介*，以及[第12章](caabef7a-c854-4b39-b8fb-ac17b8ba6eee.xhtml)，*使用Akka
    Typed构建响应式应用*。为了回顾，这是用actor表示的面包店设计：
- en: '![](img/d52ca074-5c4e-4cc6-9483-44fc2e9966af.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d52ca074-5c4e-4cc6-9483-44fc2e9966af.png)'
- en: 'Actors in this hierarchy had the following responsibilities:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层次结构中的actor有以下职责：
- en: The **Manager** initiated new baking rounds and performed the transfer of work
    packages between subordinates and supervised them.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经理**启动新的烘焙轮次，并在下属之间转移工作包，并监督他们。'
- en: The **Boy** was given a shopping list and acquired groceries from the remote
    system.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**男孩**被分配了一个购物清单，并从远程系统中获取了杂货。'
- en: The **Chef** created and used a number of mixers of limited capacity in order
    to convert given groceries into dough.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厨师**创建并使用了一些有限容量的搅拌机，以便将给定的杂货转换为面团。'
- en: The **Cook** formed a number of raw cookies from the given dough.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厨师**从提供的面团中制作了若干块生饼干。'
- en: The **Baker** baked raw cookies in the **Oven** of fixed size. It maintained
    an internal queue of raw cookies in case the rest of the bakery was making them
    quicker than the **Oven** was able to bake them.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面包师**在固定大小的**烤箱**中烘焙生饼干。它维护一个内部队列，以备面包店的其余部分制作生饼干的速度超过**烤箱**烘焙的速度时使用。'
- en: The **Oven** and **Mixers** represent hardware resources. They convert raw cookies
    into edible cookies and groceries into dough respectively but do so after some
    delay and with possible failures.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烤箱**和**搅拌机**代表硬件资源。它们将生饼干转换为可食用的饼干，将杂货转换为面团，但这样做会有延迟，并且可能发生故障。'
- en: Now we have the possibility of defining relationships between participants in
    a more static way, so we will only keep initiating the behavior of the **Manager**
    and organize the work transfer at the flow level by connecting involved transformation
    steps directly together.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有更多可能性以更静态的方式定义参与者之间的关系，因此我们只保留启动**经理**的行为，并通过直接连接涉及的转换步骤在流程级别组织工作转移。
- en: 'This is what the structure of our bakery will look like, represented in processing
    stages:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们面包店的架构，以处理阶段表示：
- en: '![](img/44f816ea-b937-4c20-bb97-a0d330b85555.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44f816ea-b937-4c20-bb97-a0d330b85555.png)'
- en: The hierarchical structure of the actor system has transformed into the flat
    data flow. Obviously, there are no `Mixers` and `Oven` anymore in this diagram.
    What happened to them? Well, we're cheating a bit by hiding the internal details
    of transformation steps here. In reality, some of these steps are composite blocks
    constructed from smaller components. Let's describe how it looks in detail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: actor系统的层次结构已经转变为扁平的数据流。显然，这个图中不再有`搅拌机`和`烤箱`。它们怎么了？嗯，我们在隐藏转换步骤的内部细节上有点作弊。实际上，这些步骤中的一些是由更小的组件构建的复合块。让我们详细描述一下它的样子。
- en: 'The **Manager** only kept his initiating behavior. This will be represented
    by a timer source which will tick every now and then and push others to bake some
    cookies. The **Boy** can''t work with just the **Manager**''s desire so we need
    the **Manager** to give a proper shopping list to it. Thus we''ll have to convert
    the ticking urge into the **Shopping List** as represented in the next diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**经理**只保留了其启动行为。这将被表示为一个定时源，它将不时地滴答作响，并推动其他人烘焙一些饼干。**男孩**不能仅仅通过**经理**的愿望来工作，因此我们需要**经理**给它一个适当的购物清单。因此，我们必须将滴答的冲动转换为**购物清单**，如下一图所示：'
- en: '![](img/607a425b-dd5f-4dd2-b1e6-27e99fedde2a.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/607a425b-dd5f-4dd2-b1e6-27e99fedde2a.png)'
- en: This composite block has exactly one output and no inputs and therefore it is
    clearly a `Source[ShoppingList]`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复合块恰好有一个输出和没有输入，因此它显然是一个`Source[ShoppingList]`。
- en: The real type of the source is `Source[+Out, +Mat]` as it is also taken into
    the account the materialization aspect. The materialization is non-essential for
    us for now so we'll talk about simplified pseudo-types as we describe the structure
    of the flow.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 源的实际类型是`Source[+Out, +Mat]`，因为它还考虑了物化方面。对于现在来说，物化对我们来说不是必要的，所以我们将在描述流结构时讨论简化的伪类型。
- en: The `Boy` and the `Cook` are simple steps; both of them can be seen as a transformation
    of input into the output, and we'll look at the details of this transformation
    in a moment. From this description, we can conclude that the `Boy` is a `Flow[ShoppingList,
    Groceries]` and a `Cook` is just a `Flow[Dough, RawCookies].`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boy`和`Cook`是简单的步骤；它们都可以被视为将输入转换为输出的转换，我们稍后会详细探讨这个转换。从这一描述中，我们可以得出结论，`Boy`是一个`Flow[ShoppingList,
    Groceries]`，而`Cook`只是一个`Flow[Dough, RawCookies]`。'
- en: 'The `Chef` is clearly not as simple as his siblings. It needs to create a number
    of **Mixer** corresponding to the amount of groceries, use them in parallel to
    mix the dough, and combine the results together before sending them further. We''ll
    represent this with the following structure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chef`显然不像他的兄弟姐妹那样简单。它需要创建与食材数量相对应的多个**搅拌器**，并行使用它们来搅拌面团，并在将它们发送到下一步之前将结果合并在一起。我们将用以下结构来表示这一点：'
- en: '![](img/c939d6b8-f579-4a1c-bb76-6e1d6781e2e7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c939d6b8-f579-4a1c-bb76-6e1d6781e2e7.png)'
- en: 'There is more going on in this diagram than we described before. This is because
    we combine the flow from building blocks with a single responsibility and we need
    to do transformations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图中的内容比我们之前描述的要多。这是因为我们将具有单一职责的构建块流与转换结合起来，我们需要进行转换：
- en: We need to divide incoming groceries into portions suitable for a single mixer;
    this is the **Divide** step.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将进来的食材分成适合单个搅拌器的份量；这就是**分割**步骤。
- en: Next, we need to be sure that work is evenly distributed among the mixers to
    avoid the situation where we need to wait for one of the mixers because it got
    multiple work packages. This is where **Balance** comes in play.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保工作在搅拌器之间均匀分配，以避免出现需要等待某个搅拌器因为它接收了多个工作包的情况。这就是**平衡**发挥作用的地方。
- en: The involvement of multiple mixers is obvious.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多个搅拌器的参与是显而易见的。
- en: The **Merge** step's responsibility is to be a fan-in block; it merges multiple
    streams of small portions of dough into a single stream of the same pieces.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并**步骤的职责是成为一个扇入块；它将多个小份面团的多个流合并成一个相同块的单一流。'
- en: Finally we **Combine** small pieces into one big bowl before we give it further
    to process.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们将其进一步加工之前，我们需要将小块面团**合并**成一个大的碗。
- en: The kinds of internal sub-flows are as following the **Divide**, **Combine**
    and all of the **Mixer**s are just Flows, the **Balance** is fan-out and the **Merge**
    is fan-in. The resulting type is the `Flow[Groceries, Dough]`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内部子流的类型如下：**分割**、**合并**以及所有的**搅拌器**都是流，**平衡**是扇出，**合并**是扇入。结果类型是`Flow[Groceries,
    Dough]`。
- en: 'The Baker is also not as simple as it appears in the previous diagram because
    it hides an oven and the interactions with it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 面包师在之前的图中看起来并不简单，因为它隐藏了一个烤箱以及与之的交互：
- en: '![](img/e11fc87c-6ccb-487b-8f62-4cc3c052b5b5.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e11fc87c-6ccb-487b-8f62-4cc3c052b5b5.png)'
- en: The **Oven** in this diagram has one input and one output so this is just a
    `Flow[RawCookies,ReadyCookies]`. The **Baker** has two inputs and two outputs
    and its shape is a `BidiFlow[RawCookies, RawCookies, ReadyCookies, ReadyCookies]`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的**烤箱**有一个输入和一个输出，所以这只是一个`Flow[RawCookies,ReadyCookies]`。**面包师**有两个输入和两个输出，其形状是`BidiFlow[RawCookies,
    RawCookies, ReadyCookies, ReadyCookies]`。
- en: The resulting type of combination is `Flow[RawCookies,ReadyCookies]`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的组合类型是`Flow[RawCookies,ReadyCookies]`。
- en: In the example built earlier, with an actor system the **Baker** maintained
    an internal queue of raw cookies as they arrived if the oven was not empty. This
    has a disadvantage that in the case of a really eager `Manager` the baking process
    could be initiated quite often and the raw cookies could arrive at the baker at
    much quicker pace than the oven can possibly bake them. The queue of the raw cookies
    can thus grow indefinitely large until it occupies all available space, and we'll
    need to either throw away raw cookies to free some space or close the bakery because
    there is no place for other actors to work.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前构建的示例中，使用演员系统时，**面包师**在烤箱不为空时维护了一个内部队列，以存放到达的生饼干。这有一个缺点，即如果`经理`非常急切，烘焙过程可能会被频繁启动，而生饼干到达面包师的速度可能会比烤箱烘焙的速度快得多。因此，生饼干的队列可能会无限增长，直到占用所有可用空间，我们可能需要丢弃生饼干以腾出空间，或者关闭面包房，因为没有其他演员可以工作的空间。
- en: In this version of the bakery we decided not to implement any queue but rely
    on the back pressure instead. We would expect the `Oven` to communicate with the
    `Baker` if it can't accept more work. The `Baker` will do the same, all the way
    back to the `Manger`, so that it won't be possible to even express the desire
    to have more cookies baked until there is more oven capacity available. With different
    buffering strategies, it is possible to manage how much work in progress there
    is at the bakery at any moment. For the purpose of the example, we'll set this
    limit low to demonstrate back pressure in action.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的面包房中，我们决定不实现任何队列，而是依赖背压。我们预计如果`Oven`无法接受更多工作，它会与`Baker`通信。`Baker`也会这样做，一直追溯到`Manger`，这样就不可能表达出需要更多烘焙饼干的需求，除非有更多的烤箱容量可用。通过不同的缓冲策略，可以管理在任何时刻面包房中正在进行的工作量。为了示例的目的，我们将这个限制设置得较低，以展示背压的作用。
- en: The last step of our flow is a `Customer`, which is of type `Sink[ReadyCookies]`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们流的最后一步是一个`Customer`，其类型为`Sink[ReadyCookies]`。
- en: Now let's switch gears and set in the code the structure we came up with.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转换思路，将我们构思的结构编码到代码中。
- en: Basics of Akka Streams
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Streams 基础知识
- en: Elements of the Akka Streams flow are usually defined using constructors of
    the appropriate type. We'll implement building blocks which constitute our diagram
    one by one, starting with the simplest and moving on to the increasingly complex
    as we go over them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams 流的元素通常使用适当类型的构造函数来定义。我们将逐一实现构成我们图表的构建块，从最简单的开始，逐渐过渡到越来越复杂的。
- en: Sources and sinks
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源和汇
- en: 'The simplest component of our flow is possibly the `Consumer`. It is just a
    sink which is supposed to print out information about incoming data. To construct
    it, we''ll use the `Sink` factory, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们流中最简单的组件可能是`Consumer`。它只是一个汇，应该打印出有关传入数据的信息。为了构建它，我们将使用`Sink`工厂，如下所示：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Sink` factory offers more than two dozens different constructors to define
    a sink. We're utilizing one of the simplest, which invokes a provided function
    for each element of the stream.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sink` 工厂提供了二十多种不同的构造函数来定义汇。我们正在利用其中最简单的一个，它为流中的每个元素调用一个提供的函数。'
- en: Here we see that the real type of it is the `Sink[ReadyCookies, Future[Done]]`.
    This reflects the type `ReadyCookies` elements and the type the `Sink` is materialized
    to. In this case, it is materialized into `Success` if stream ends by reaching
    its end and to the `Failure` if there is a failure in the stream.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到它的实际类型是`Sink[ReadyCookies, Future[Done]]`。这反映了`ReadyCookies`元素的类型以及`Sink`被物化为的类型。在这种情况下，如果流通过到达其结束而结束，则物化为`Success`，如果流中发生故障，则物化为`Failure`。
- en: 'Now we''ll take a look at the opposite end of the stream and define a source. 
    The `Source` factory similarly provides almost three dozens of different methods
    to create a source. We don''t want to overwhelm our bakery''s team with work so
    we decided to use a timed source of data:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看流的另一端并定义一个源。`Source` 工厂同样提供了近三十种不同的方法来创建源。我们不希望压倒我们的面包房团队，所以我们决定使用一个定时数据源：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This represents the first block in our composite `Source` and its type is no-fit
    for our `Boy`, so we need to implement the second block of the diagram, the generator,
    and connect both together. This is more easily done than explained:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了我们复合`Source`的第一个块，它的类型不适合我们的`Boy`，因此我们需要实现图表的第二块，即生成器，并将两者连接起来。这比解释起来更容易：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We basically just map over the input but ignore it and return a `shoppingList`
    instead. Now our `Source` has a proper type so that we can connect a `Boy` to
    it later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上只是映射输入，但忽略它，并返回一个`shoppingList`。现在我们的`Source`有了合适的类型，这样我们就可以稍后将其连接到`Boy`。
- en: 'There is a subtle aspect of this implementation which we didn''t take into
    the account. We have a predefined interval with the intention that the rest of
    the flow is not overwhelmed with requests. But at the same time, we''re about
    to rely on the back pressure from the `Oven` for the same purpose. This is not
    optimal because if we pick too big an interval, our bakery will be under-utilized
    and if we pick too small an interval, this will be the back pressure which will
    manage the flow. We can simplify our source to the form that will just produce
    shopping lists and put them into the pipeline as soon as there is some downstream
    capacity available:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现有一个我们未考虑到的微妙之处。我们有一个预定义的间隔，目的是不让流的其他部分被请求淹没。但与此同时，我们正准备依赖`Oven`的背压来达到同样的目的。这并不理想，因为如果我们选择太大的间隔，我们的面包店将得不到充分利用；如果我们选择太小的间隔，这将是由背压来管理的流。我们可以简化我们的源，使其只产生购物清单，并在下游有可用容量时立即将它们放入管道：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we just repeat the `NotUsed` element (which provides a nice syntax) and
    then replace it with the random shopping list as before. The difference is that
    the manager will generate a shopping list every time there is a demand for that
    without potentially waiting too long because of the timer settings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是重复了`NotUsed`元素（它提供了一个很好的语法），然后像之前一样用随机购物清单替换它。不同的是，经理将在有需求时每次都生成购物清单，而不会因为计时器设置而等待太长时间。
- en: Flows
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: Now that we have the source and the sink, let's implement the flow itself. Again,
    we will start with the simplest parts and switch to the more complex as we progress.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了源和汇，让我们来实现流本身。同样，我们将从最简单的部分开始，随着我们的进展逐步转向更复杂的部分。
- en: The easiest flow building block is surely the `Cook`. It could be implemented
    as a map function called on the preceding flow definition but for composing reasons,
    we'd like to define it separately.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易的流构建块无疑是`Cook`。它可以作为一个在先前的流定义上调用的映射函数来实现，但出于组合的原因，我们希望单独定义它。
- en: 'The approach of the flow definition is consistent with the previous two—the
    `Flow` constructor is the way to go. The flow is defined in terms of operations
    on the input but the definition itself is decoupled from this input. Again there
    are lots of methods to choose from; for our purposes, we pick the simple `map`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 流定义的方法与前面两个保持一致——`Flow`构造函数是最佳选择。流是在输入操作的基础上定义的，但定义本身与这个输入是解耦的。再次强调，有很多方法可以选择；就我们的目的而言，我们选择简单的`map`：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `cook`'s flow is just mapping over the input dough and converting it to
    the output, raw cookies, as it represented by the type annotation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`cook`的流只是映射输入面团，并将其转换为输出，即未加工的饼干，正如类型注解所表示的那样。'
- en: The Boy is quite similar to the `Cook` in the sense that it is a simple building
    block which transforms its input into the output. There is one caveat though—our
    `Boy` needs to communicate with the remote actor in order to do this.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，《男孩》与`Cook`非常相似，因为它是一个简单的构建块，将输入转换为输出。不过有一个需要注意的地方——我们的`Boy`需要与远程演员进行通信才能完成这个任务。
- en: Akka Streams is built upon Akka and thus offers some possibilities to utilize
    and communicate with actors at different stages; for instance, it is possible
    to use an `ActorRef` as a source or sink. The remoting aspect in this situation
    turns out to be just an implementation and configuration detail because of Akka's
    location transparency.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams建立在Akka之上，因此提供了一些在不同阶段利用和与演员通信的可能性；例如，可以使用`ActorRef`作为源或汇。在这种情况下，远程方面由于Akka的位置透明性，实际上只是一个实现和配置细节。
- en: 'In our use case, the most appropriate way to communicate with a Seller deployed
    in the remote shop system will be an ask pattern. Let''s do this step by step.
    First, we''ll look up a remote actor in order to be able to communicate with it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，与远程商店系统中部署的卖家进行通信的最合适方式将是询问模式。让我们一步一步来做。首先，我们将查找远程演员，以便能够与之通信：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Given an `ActorSystem`, we look up an actor using an address of the remote system
    and an actor path. We know there should be exactly one actor, therefore we resolve
    one reference. Depending on the result of the lookup it will return either `Success`
    with the reference we need or a `Failure[ActorNotFound]`. The failure will be
    propagated via the error flow and will lead to the termination of the stream because
    we don't define how to handle it. Let's call this the desired behavior because
    without a seller we won't be able to convert a shopping list into groceries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`ActorSystem`，我们使用远程系统的地址和演员路径来查找一个演员。我们知道应该只有一个演员，因此我们解析一个引用。根据查找的结果，它将返回所需的引用的`Success`或`Failure[ActorNotFound]`。失败将通过错误流传播，并导致流终止，因为我们没有定义如何处理它。让我们称这为期望的行为，因为没有卖家，我们无法将购物清单转换为食品。
- en: 'We can use a `Future[ActorRef]` to talk to the actor:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Future[ActorRef]`与演员进行通信：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we not only need an `ActorSystem` but also an `ExecutionContext` in order
    to be able to map over the `Future` we acquire from the `lookupSeller`. We're
    using the actor reference (if there is one) as a parameter to call `Flow.ask`. 
    The type of the `Flow` corresponds to the expected input type and the type of
    the `ask`—to the expected output type.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不仅需要一个`ActorSystem`，还需要一个`ExecutionContext`，以便能够映射从`lookupSeller`获取的`Future`。我们使用演员引用（如果有）作为参数来调用`Flow.ask`。`Flow`的类型对应于预期的输入类型和`ask`的类型——预期的输出类型。
- en: 'Now we can use another `Flow` constructor to convert a `Future[Flow]` to the
    `Flow`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用另一个`Flow`构造函数将`Future[Flow]`转换为`Flow`：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `lazyInitAsync` translates an internal `Flow` of the `Future` into the normal
    `Flow`. This sub-flow has a proper type of input and output and thus we can plug
    it into our flow definition later.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazyInitAsync`将`Future`的内部`Flow`转换为正常的`Flow`。这个子流有适当的输入和输出类型，因此我们可以稍后将其插入到我们的流定义中。'
- en: It is important to extend the configuration in the `application.conf` with properties,
    needed for the Akka remoting as described in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml),
    *An Introduction to the Akka and Actor Models*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application.conf`中扩展配置以包含Akka远程所需的属性非常重要，如第11章所述，*Akka和Actor模型简介*。
- en: The next composite step we're going to implement is a `Baker`, including its
    constituent `Oven`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的是下一个复合步骤，即`Baker`，包括其组成部分`Oven`。
- en: 'The `Oven` needs to spend some time turning raw cookies into edible cookies
    and we could implement this by introducing a bit of blocking behavior. But doing
    so will affect the rest of the system by needlessly consuming available threads.
    Because of this, we''ll use another feature of Akka Streams, `Flow.delay`, which
    allows us to shift the emission of elements in time:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Oven`需要花费一些时间将原始饼干转化为可食用的饼干，我们可以通过引入一点阻塞行为来实现这一点。但这样做会通过无谓地消耗可用线程来影响系统的其余部分。因此，我们将使用Akka
    Streams的另一个功能，`Flow.delay`，它允许我们在时间上延迟元素的发射：'
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we only have one `Oven`, we define a buffer size to be of the initial and
    maximum size of 1\. We also don't want to drop arriving raw cookies or release
    cookies which are not ready yet, therefore we define an overflow strategy to be
    a back pressure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个`Oven`，我们定义一个缓冲区大小为初始和最大大小为1。我们也不希望丢弃到达的原始饼干或释放尚未准备好的饼干，因此我们定义一个溢出策略为背压。
- en: 'The `bake` method is a trivial conversion once again:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`bake`方法再次是一个简单的转换：'
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, with this `Oven` we can define a `Baker` which we planned to give a type
    of `BidiFlow`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个`Oven`，我们可以定义一个`Baker`，我们计划给它一个`BidiFlow`类型：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to do this, we need to separately define the `inFlow` and `outFlow`
    for both flow directions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要分别定义两个方向的`inFlow`和`outFlow`。
- en: 'The `outFlow` is just passing cookies that are ready to the consumer and we
    already know how to do that:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`outFlow`只是将准备好的饼干传递给消费者，我们已经知道如何做这件事：'
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `inFlow` is a bit more involving because we need to regroup incoming raw
    cookies from groups of some random quantity to groups with the size of the oven.
    We''ll do this by defining a sub-source of single cookies and then grouping them
    as desired. Here is the first step:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`inFlow`稍微复杂一些，因为我们需要将来自某些随机数量的原始饼干分组到具有烤箱大小的组中。我们将通过定义单个饼干的子源并将它们按所需方式分组来实现这一点。以下是第一步：'
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''re creating a source: the number of single cookies. The regrouping logic
    looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个源：单个饼干的数量。重新组合逻辑如下：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `flatMapConcat` consumes one source after another and concatenates the results.
    We then group the stream of single cookies to the stream of `List[RawCookie]`
    of `ovenSize`. Lastly, we reduce this list of single cookies into `RawCookie(ovenSize)`
    as `Oven` expects it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMapConcat`逐个消耗源，并将结果连接起来。然后，我们将单个饼干的流分组到`ovenSize`的`List[RawCookie]`流中。最后，我们将单个饼干的列表缩减为`Oven`期望的`RawCookie(ovenSize)`。'
- en: 'Now we can combine a baker''s `BidiFlow` and oven''s Flow into the composite
    Flow by joining them:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过连接将面包师傅的`BidiFlow`和烤箱的`Flow`组合成复合`Flow`：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `join` method adds a given `Flow` as a final transformation to the stack
    of `BidiFlows`. In our case, the size of the stack is one and the type of the
    resulting flow is `Flow[RawCookies, ReadyCookies, NotUsed]`. The resulting sub-flow
    hides all of the details of regrouping the cookies and waiting for their readiness,
    leaving us with a nice definition.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`方法将一个给定的`Flow`作为最终转换添加到`BidiFlows`的堆栈中。在我们的情况下，堆栈的大小为1，结果的流类型为`Flow[RawCookies,
    ReadyCookies, NotUsed]`。这个子流程隐藏了重新分组饼干和等待它们准备好的所有细节，为我们提供了一个简洁的定义。'
- en: Graphs
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: The final piece of our flow is a `Chef`. It incorporates work management across
    Mixers. Let's implement `Mixers` first.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们流程的最后一部分是一个`Chef`。它整合了混合器的工作管理。让我们首先实现`Mixers`。
- en: 'The mixing behavior itself is straightforward but to mimic real hardware we
    include a block for the time of mixing:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 混合行为本身很简单，但为了模仿真实硬件，我们包括一个混合时间的块：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because of the mixing behavior, we need to use a special async flow constructor
    to start a separate thread for every mixer. In order to better control how threads
    are assigned, we''ll put into the configuration a definition of the separate pinned
    thread dispatcher which assigns one thread per sub-flow:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于混合行为，我们需要使用一个特殊的异步流程构造函数来为每个混合器启动一个单独的线程。为了更好地控制线程的分配方式，我们将在配置中添加一个单独的固定线程调度器的定义，该调度器为每个子流程分配一个线程：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this definition in place, we are now able to define the blocking mixing
    behavior:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此定义到位后，我们现在能够定义阻塞的混合行为：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `async` constructor takes a buffer size as a parameter and we want our mixers
    not to have any large buffers assigned to them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`构造函数接受一个缓冲区大小作为参数，我们希望我们的混合器不要分配任何大缓冲区。'
- en: 'The work management can be implemented as a separate concept which closely
    resembles one of the recipes from the Akka Streams documentation cookbook—the
    Balancer. It takes a worker `subFlow` and a count of workers and constructs a
    graph with the given number of workers:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 工作管理可以作为一个独立的概念实现，它类似于Akka Streams文档食谱中的某个配方——平衡器。它接受一个工作`subFlow`和工作者数量，并构建一个具有给定工作者数量的图：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Balance` block is a fan-out flow with several outputs. It distributes stream
    elements evenly between the workers. With `waitForAllDownstreams = false` we specify
    that the distribution can start as soon as at least one of the workers demands
    a job. With `false` we change the behavior to wait for all of the workers to demand
    a job before it will be distributed. The `Merge` is a fan-in block with a specified
    number of inputs. By specifying `eagerComplete = false` we tell it to wait for
    all down streams to complete as compared to completing as soon as one of the workers
    is done.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Balance`块是一个具有多个输出的扇出流。它将流元素均匀地分配给工作者。通过`waitForAllDownstreams = false`，我们指定一旦至少有一个工作者要求工作，分配就可以开始。通过`false`，我们将行为更改为在所有工作者要求工作之前等待分配。`Merge`是一个具有指定输入数量的扇入块。通过指定`eagerComplete
    = false`，我们告诉它等待所有下游完成，而不是在任何一个工作者完成时立即完成。'
- en: 'Then we construct a graph using `GraphDSL.create()` and provide actual graph
    building logic as a parameter. First, we convert `balanceBlock` and `mergeBlock`
    into Shapes by adding them to the `builder`. Then we connect as many sub-flows
    as needed to the balancer and merge using the `~>` syntax provided by the `import
    GraphDSL.Implicits._`. The `for` comprehension for five workers would be equivalent
    to the following plain definition:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`GraphDSL.create()`构造一个图，并提供实际的图构建逻辑作为参数。首先，我们将`balanceBlock`和`mergeBlock`转换为形状，并将它们添加到`builder`中。然后，我们使用`import
    GraphDSL.Implicits._`提供的`~>`语法将所需数量的子流程连接到平衡器并合并。五个工作者的`for`推导式相当于以下简单的定义：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Having this graph defined, we can specify the rest of the `Balancer` flow using
    another `Flow` constructor:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了此图之后，我们可以使用另一个`Flow`构造函数来指定其余的`Balancer`流程：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can use it to construct our `Chef` sub-flow:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来构建我们的`Chef`子流程：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, again we split `Groceries` into a stream of smaller portions, mix each
    of these portions using a dedicated mixer in parallel, and combine them using
    the same technique we used before with the `Baker` and `Oven`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次将“杂货”分成更小的部分，并使用专用混合器并行混合每一部分，然后使用之前与“面包师”和“烤箱”相同的技巧将它们组合起来。
- en: Logging
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: In `Cook`'s flow, we used two `print` statements in order to see how the `Cook`
    was doing. It's OK for our example but we would be better off with proper logging.
    Let's improve on that.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cook`的流程中，我们使用了两个`print`语句来查看`Cook`的表现。对于我们的例子来说是可以的，但我们会更倾向于使用适当的日志。让我们改进这一点。
- en: 'Akka provides a `log` method which takes a logger name as a parameter and can
    be called on any processing stage in the flow. Let''s use it instead of our `print`
    statements:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Akka提供了一个`log`方法，它接受一个日志名称作为参数，可以在流程中的任何处理阶段调用。让我们用它来代替我们的`print`语句：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we're writing into the log elements of the flow before and after transformation
    and also providing an optional logging configuration in order to specify log levels
    for different types of events.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在日志中写入流程在转换前后的元素，并提供可选的日志配置，以指定不同类型事件的日志级别。
- en: 'To see the effect of these changes we need to extend the `application.conf`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这些更改的效果，我们需要扩展`application.conf`：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, after starting our example, we''ll see the following entries in the log:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在启动我们的示例之后，我们将在日志中看到以下条目：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With logging in place, we have finished defining all of the parts of our flow
    and can try to bring them together.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置日志后，我们已经定义了流程的所有部分，可以尝试将它们组合在一起。
- en: Materialization
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物化
- en: 'Now we can specify the whole flow for our bakery:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的面包店指定整个流程：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we first construct the full flow by combining sub-flows we defined before.
    Then we convert the flow to runnable graph by attaching the `manager` Source and
    the `consumer` Sink.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先通过组合之前定义的子流程来构建完整的流程。然后，我们通过附加“manager”源和“consumer”汇来将流程转换为可运行的图。
- en: We also specify that we want to keep the right materialized value. The left
    materialized value would be the result of the stream, which is `NotUsed` in our
    case because we just writing produced cookies to the console. The right value
    is a future which is completed when the flow has finished running and we want
    to use it to shut down our actor system as soon is it happens.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定我们想要保留正确的物化值。左边的物化值将是流的结果，在我们的例子中是`NotUsed`，因为我们只是将生产的饼干写入控制台。右边的值是一个当流程完成后完成的未来，我们希望用它来关闭我们的actor系统，一旦发生就立即关闭。
- en: Finally, we run the graph by bringing an `ActorMaterializer` in scope and calling
    the corresponding `run` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将`ActorMaterializer`引入作用域并调用相应的`run`方法来运行图。
- en: 'Our system runs and bakes tasty cookies, but unfortunately, we forgot to take
    an important aspect into account: Mixers in our setup are liable to hardware failure.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统运行并烘焙美味的饼干，但不幸的是，我们忘记考虑一个重要的方面：在我们的设置中，混合器容易发生硬件故障。
- en: Handling failure
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理故障
- en: 'In order to make the mixing step more realistic we''ll add a couple of exceptions
    and throw them in randomly at the mixing stage. This will simulate hardware failures
    appearing at unpredicted times. The mixer can throw one of the three exceptions
    the same way it did before in the actor-based examples in the previous two chapters:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使混合步骤更真实，我们将添加几个异常，并在混合阶段随机抛出它们。这将模拟在不可预测的时间出现的硬件故障。混合器可以像在前两章基于actor的示例中那样抛出三种异常之一：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The realistic `mix` method could look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`mix`方法可能看起来像这样：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are a couple of different ways the exceptions can be dealt with. The
    most straightforward approach would be to catch them directly in the logic:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 异常可以以几种不同的方式处理。最直接的方法是在逻辑中直接捕获它们：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the case of slow rotation, we decide to ignore the issue, keep the mixed
    stuff, and just give the mixer double the time to finish the mixing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在慢速旋转的情况下，我们决定忽略这个问题，保留混合物，并给混合器双倍的时间来完成混合。
- en: This works but it has an obvious disadvantage that we tangle our business and
    error-handling implementations. More often then not this is undesirable because
    the code for both aspects usually have different natures. The happy path contains
    business-related code and error handling is of a technical essence. Therefore
    it is usually preferred to separate these code paths. In our case, it is justified
    to handle the failure at the stage level because we don't want to drop the element
    of the stream.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但它有一个明显的缺点，那就是我们混淆了业务和错误处理实现。这种情况通常是不受欢迎的，因为这两个方面的代码通常具有不同的性质。快乐路径包含与业务相关的代码，而错误处理具有技术本质。因此，通常更倾向于将这些代码路径分开。在我们的案例中，在阶段级别处理失败是合理的，因为我们不希望丢弃流中的元素。
- en: 'Akka offers alternative ways to specify failure handling. One of them is recovery
    logic which can be defined for the stage so that failure is converted into the
    final element of the stream:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Akka提供了指定失败处理的其他方法。其中之一是恢复逻辑，可以为阶段定义，以便将失败转换为流的最终元素：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here we decide to return an empty bowl of dough in the case of motor failure.
    The stream is then completed but this is fine in our case because our mixers are
    one-off sub-flows anyway.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们决定在电机故障的情况下返回一个空的面团碗。然后流完成，但在这个案例中这没关系，因为我们的搅拌器本身就是一次性子流程。
- en: The `recover` method is a special case of the `recoverWithRetries`. The latter
    accepts not only a partial function for decision-making but also a number of retries
    in the case multiple failures happen in the same processing stage.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover`方法是`recoverWithRetries`的特殊情况。后者不仅接受用于决策的部分函数，还在同一处理阶段发生多次失败的情况下接受重试次数。'
- en: Now we are only missing a decision as to how to handle the `StrongVibrationException`.
    If we decide not to handle it, the default behavior will be able to stop the whole
    stream. If that happens, the downstream stages will get informed about the failure
    and upstream stages will be cancelled.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们唯一缺少的是如何处理`StrongVibrationException`的决定。如果我们决定不处理它，默认行为将能够停止整个流。如果发生这种情况，下游阶段将得知失败，上游阶段将被取消。
- en: 'We definitely don''t want to close our bakery in case one of our mixers vibrates
    too much. Quite the opposite; we''d like to ignore this completely. Some stages
    support a defining supervision strategy the same way actors do. We can use this
    possibility to define a common error-handling behavior. First, we need to define
    a decision strategy:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对不希望因为我们的搅拌器振动得太厉害而关闭我们的面包店。恰恰相反；我们希望完全忽略这一点。一些阶段支持与演员相同的方式定义监督策略。我们可以利用这种可能性来定义一个通用的错误处理行为。首先，我们需要定义一个决策策略：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are three strategies available—stop, restart, and resume:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种策略可用——停止、重启和恢复：
- en: The stopping strategy is the default one and it will stop the processing stage
    and propagate the failure of up and downstream stages.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止策略是默认的，它将停止处理阶段并传播上下游阶段的失败。
- en: The resuming strategy just drops the current element and the stream continues.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复策略只是丢弃当前元素，流继续。
- en: Restart is similar to resume—it drops current element and the stream continues
    but before that the stage is restarted and so any internal state is cleared.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重启与恢复类似——它丢弃当前元素，流继续，但在那之前阶段被重启，因此任何内部状态都被清除。
- en: In our decider, we just want the stream to continue in the case of strong vibrations,
    but stop in the case of any other failure. We handle both other types of exceptions
    in addition to a supervision strategy and therefore we're safe with this decision.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的决策器中，我们只想在强振动的情况下让流继续，但在任何其他失败的情况下停止。我们除了监督策略外还处理其他类型的异常，因此这个决定是安全的。
- en: 'This is how we apply our supervision strategy to the definition of the processing
    stage:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何将我们的监督策略应用到处理阶段的定义中：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, if we start our example, it will run and deal with hardware failures as
    expected.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们启动我们的示例，它将按预期运行并处理硬件故障。
- en: It looks good but we're not done because we haven't tested our bakery yet.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来不错，但我们还没有完成，因为我们还没有测试我们的面包店。
- en: Testing
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Testing stream-based code might look complex because of the interconnectedness
    of all of the parts of the system. But more often than not testing streams boils
    down to unit-testing processing stages in isolation and relying on the Akka Streams
    that data flow between this stages will happen as expected.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统的各个部分相互关联，基于流的代码的测试可能看起来很复杂。但更常见的是，测试流归结为在隔离状态下对处理阶段进行单元测试，并依赖于Akka Streams确保这些阶段之间的数据流按预期发生。
- en: 'Frequently, no special testing library is needed. Let''s demonstrate this by
    testing our source:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，不需要特殊的测试库。让我们通过测试我们的源来演示这一点：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to run this test snippet we need an implicit materializer to be in
    scope:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个测试片段，我们需要一个隐式材料化器在作用域内：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The general approach is that in order to test a `Sink` it can be attached to
    the special `Source`, and for a `Source` under test, we'll need a special `Sink`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通用方法是，为了测试一个`Sink`，它可以连接到特殊的`Source`，而对于正在测试的`Source`，我们需要一个特殊的`Sink`。
- en: In both cases, sequence-based `Source`s and Sinks are probably the most useful
    ones. In our example, we're testing that our source emits at least one hundred
    shopping lists and does this in a timely manner. The results are available as
    a `Seq[ShoppingList]` and can be inspected if needed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，基于序列的`Source`和`Sink`可能是最有用的。在我们的例子中，我们正在测试我们的源至少发出一百个购物清单，并且以及时的方式完成。结果可以作为`Seq[ShoppingList]`提供，并在需要时进行检查。
- en: 'In order to test a flow, we need to provide both a test `Source` and `Sink`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一个流程，我们需要提供测试`Source`和`Sink`：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we see the same approach. After defining the test input and output we
    drive the flow under test and verify that the output has expected properties.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到相同的方法。在定义测试输入和输出后，我们驱动被测试的流程，并验证输出具有预期的属性。
- en: There is an undesirable call to `Await.result` in both cases which relates to
    the fact that running the Akka Streams flow produces a `Future`. We can improve
    on that by using testing techniques as described in [Chapter 5](dba6e932-4169-4b60-9bde-26ac2073a1ab.xhtml),
    *Property-Based Testing in Scala*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，都存在对`Await.result`的不理想调用，这与运行Akka Streams流程产生`Future`的事实相关。我们可以通过使用如[第5章](dba6e932-4169-4b60-9bde-26ac2073a1ab.xhtml)中描述的测试技术来改进这一点，*基于属性的Scala测试*。
- en: Alternatively, it is also possible to use test toolkits provided by other Akka
    libraries.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以使用其他Akka库提供的测试工具包。
- en: Akka TestKit
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka TestKit
- en: 'Akka Streams offers integration with Akka actors via the `actorRef` method.
    It is available as a Sink constructor so we can use an actor to receive elements
    of the flow which are then represented as messages received by the actor. It is
    convenient to use `TestProbe` from the Akka `TestKit` to verify assumptions about
    the flow. First, we need to add a dependency to the Akka `TestKit` in `build.sbt`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams通过`actorRef`方法提供与Akka actors的集成。它作为Sink构造函数可用，因此我们可以使用一个actor来接收流程的元素，这些元素随后被表示为actor接收到的消息。使用Akka
    `TestKit`中的`TestProbe`来验证关于流程的假设是方便的。首先，我们需要在`build.sbt`中添加对Akka `TestKit`的依赖：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is an example of how the `TestProbe` can be employed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何使用`TestProbe`的例子：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We test that there will be one message coming from the flow if one message goes
    into it. This time we're not waiting for the future to complete but formulate
    our assumptions with the syntax the `TestProbe` supports.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试如果有一个消息进入流程，那么流程将会有一个消息输出。这次我们不是等待未来完成，而是使用`TestProbe`支持的语法来制定我们的假设。
- en: By now, you should have recognized the pattern we're using. First, set up the
    source and/or the sink, then wait for the flow to complete, and finally verify
    assumptions about the output of the flow. Surely enough, the Akka team abstracted
    this in a special test kit provided for Akka Streams.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经识别出我们使用的模式。首先，设置源和/或汇，然后等待流程完成，最后验证关于流程输出的假设。当然，Akka团队为Akka Streams提供了一个特殊的测试套件来抽象这一点。
- en: Streams TestKit
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streams TestKit
- en: 'In order to use the Akka Streams `TestKit`, we need to add another dependency
    to our project configuration to `build.sbt`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Akka Streams `TestKit`，我们需要在我们的项目配置中添加另一个依赖到`build.sbt`：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s see how the `TestSink` and `TestSource` provided by this module can
    simplify the way we formulate our testing logic. Now we''ll test the whole flow
    from the `Boy` to the `Baker`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个模块提供的`TestSink`和`TestSource`如何简化我们制定测试逻辑的方式。现在我们将测试从`Boy`到`Baker`的整个流程：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this scenario, we first create `TestSink` and `TestSource` probes using constructors
    provided by the testing toolkit. Then we materialize them to `publisher` and `subscriber`
    in order to be able to drive the flow. Here, we're using the `toMat` syntax again.
    Until now, we implicitly used the default value (`Keep.left`) but now we want
    to keep both materialized results of the flow and of the sink. Running the flow
    returns its materialized instance which is a pair: `TestPublisher` and `TestSubscriber`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们首先使用测试工具包提供的构造函数创建`TestSink`和`TestSource`探针。然后我们将它们实体化为`publisher`和`subscriber`，以便能够驱动流程。在这里，我们再次使用`toMat`语法。到目前为止，我们隐式地使用了默认值（`Keep.left`），但现在我们希望保留流程和sink的实体化结果。运行流程返回其实体化实例，它是一个对：`TestPublisher`和`TestSubscriber`。
- en: We then use `subscriber` to request 10 messages from the flow. In Reactive Streams,
    the producer is not supposed to send anything downstream until there is demand,
    and we express the demand with this call. We expect the flow to output elements
    representing `RawCookies(12)`. Thus, our `subscriber.request` translates to 120
    cookies to be produced.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`subscriber`从流程中请求10条消息。在Reactive Streams中，生产者不应该在存在需求之前向下游发送任何内容，我们通过这个调用表达需求。我们期望流程输出代表`RawCookies(12)`的元素。因此，我们的`subscriber.request`转换为要生产的120个饼干。
- en: Having this demand, we then initiate the flow by sending the next shopping list
    from the source.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在有这种需求的情况下，我们从源发送下一个购物清单以启动流程。
- en: Finally, we expect at least two batches of cookies to arrive at the sink. We
    provide sufficient time for the stream to push messages through all of the stages,
    accounting for delays in the mixing and baking stage.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们期望至少有两批饼干到达sink。我们为流通过所有阶段提供足够的时间，考虑到混合和烘焙阶段的延迟。
- en: We also cannot reliably predict how many cookies will be made because of the
    way we drop messages at the mixing stage in the case of `MotorOverheatException`
    and `SlowRotationSpeedException`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`MotorOverheatException`和`SlowRotationSpeedException`的情况下在混合阶段丢弃消息的方式，我们也不能可靠地预测将制作多少饼干。
- en: In this example, we barely scratched the surface of all of the possibilities
    provided by the Akka Streams `TestKit`. As you develop Akka Streams-based systems
    it is worth revisiting both the documentation and the source code of the library
    and keeping in mind the different testing approaches they offer.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是触及了Akka Streams `TestKit`提供的所有可能性的表面。随着你开发基于Akka Streams的系统，值得重新查阅库的文档和源代码，并记住它们提供的不同测试方法。
- en: Running the application
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Please refer to [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you still have to install Java and/or
    SBT.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然需要安装Java和/或SBT，请参阅[附录A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml)，*准备环境和运行代码示例*。
- en: 'We will run our application in the terminal the same way we did in [Chapter
    11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction to the Akka
    and Actor Models* and [Chapter 12](caabef7a-c854-4b39-b8fb-ac17b8ba6eee.xhtml), *Building
    Reactive Applications with Akka Typed*, using two separate terminal sessions for
    `Store` and `BakeryApp` using the following commands:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，*Akka和Actor模型简介*和[第12章](caabef7a-c854-4b39-b8fb-ac17b8ba6eee.xhtml)，*使用Akka
    Typed构建响应式应用程序*相同的方式在终端中运行我们的应用程序，使用两个独立的终端会话分别运行`Store`和`BakeryApp`，使用以下命令：
- en: '`sbt "runMain ch13.BakeryApp"`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt "runMain ch13.BakeryApp"`'
- en: '`sbt "runMain ch13.Store"`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt "runMain ch13.Store"`'
- en: We prefer this method because of its conciseness. If you're about to run the
    app in interactive mode, please consult [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An
    Introduction to the Akka and Actor Models*, for a detailed explanation of this
    approach.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢这种方法，因为它简洁。如果你即将以交互模式运行应用程序，请参阅[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，*Akka和Actor模型简介*，以获取对此方法的详细解释。
- en: 'In our examples, we expect the remote `Store` app to be available at the moment
    we start the main `Bakery` stream. Because of this, we have to start the `Store`
    first or the `BakeryApp` will exit with an exception at the moment it fails to
    connect to the store. The next screenshot shows two terminal windows with commands
    to run the `Store` entered in the left window and the `BakeryApp` started in the
    right window. In the following screenshot, we can see that the `Store` has already
    been running for some time and the BakeryApp has just started to execute:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们期望远程的 `Store` 应用在启动主 `Bakery` 流时可用。因此，我们必须首先启动 `Store`，否则 `BakeryApp`
    将在无法连接到存储时以异常退出。下一个截图显示了两个终端窗口，左侧窗口中输入了运行 `Store` 的命令，右侧窗口中启动了 `BakeryApp`。在接下来的截图中，我们可以看到
    `Store` 已经运行了一段时间，而 `BakeryApp` 刚开始执行：
- en: '![](img/471c2012-abc6-46db-87a0-284f5147748a.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/471c2012-abc6-46db-87a0-284f5147748a.png)'
- en: The `Bakery` in the right terminal will now run until stopped with the *Ctrl*
    + *C* shortcut or the terminal window is closed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧终端中的 `Bakery` 现在将一直运行，直到使用 *Ctrl* + *C* 快捷键停止或关闭终端窗口。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Traditional streaming solutions suffer from one of two issues. In the case of
    pulling, there is a need for locking or extensive use of resources on the side
    of the quick consumer. In the case of pushing, there is a possibility that a number
    of messages to process will grow bigger than the available memory, requiring a
    slow consumer to drop messages or terminate because of the memory overflow. Reactive
    Streams solves this problem by defining dynamic asynchronous pull-push with back
    pressure. Akka Streams implements the Reactive Streams standard using Akka which
    allows for seamless integration with both technologies.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的流解决方案存在两个问题之一。在拉取的情况下，需要快速消费者端锁定或大量使用资源。在推送的情况下，要处理的消息数量可能会超过可用内存，需要慢速消费者丢弃消息或因内存溢出而终止。反应式流通过定义具有背压的动态异步拉-推来解决此问题。Akka
    Streams 使用 Akka 实现了反应式流标准，这允许与这两种技术无缝集成。
- en: Streams in Akka are built from blocks called stages or flows. These blocks can
    be nested and connected to each other, forming graphs. Graphs with single input
    and single output can be made runnable by connecting them to the source and sink.
    Graph definitions can be freely shared and reused.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 中的流是由称为阶段或流程的块构建的。这些块可以嵌套并相互连接，形成图。通过将它们连接到源和汇，具有单个输入和单个输出的图可以变得可执行。图定义可以自由共享和重用。
- en: Running a graph requires a materializer and produces a materialized value depending
    on the graph and sink definition.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个图需要一个材料化器，并产生一个根据图和汇定义的材料化值。
- en: Error handling in Akka Streams can be done in different ways including catching
    errors directly in the flow definition, defining a recovery method with optional
    retries and/or overriding a supervision strategy for processing stages which support
    it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Streams 中的错误处理可以通过不同的方式完成，包括在流程定义中直接捕获错误，定义一个带有可选重试和/或覆盖支持它的处理阶段的监督策略的恢复方法。
- en: The modular nature of the flow definition allows for straightforward testing
    of single stages and their combinations. In order to reduce boilerplate for recurring
    test setup and expectation definitions, Akka Streams offers special test toolkit.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 流定义的模块化特性允许对单个阶段及其组合进行直接测试。为了减少重复测试设置和期望定义的样板代码，Akka Streams 提供了特殊的测试工具包。
- en: The reader is encouraged to take a look at the official Akka documentation at [https://doc.akka.io/docs/akka/current/stream/index.html ](https://doc.akka.io/docs/akka/current/stream/index.html)to
    explore the possibilities offered by Akka Streams in more detail.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励读者查看官方 Akka 文档[https://doc.akka.io/docs/akka/current/stream/index.html](https://doc.akka.io/docs/akka/current/stream/index.html)，以更详细地了解
    Akka Streams 提供的可能性。
- en: Questions
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name two different modes associated with "classic" streams. What is problematic
    with them?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出与“经典”流相关的两种不同模式。它们有什么问题？
- en: Why are Reactive Streams considered as workable in dynamic pull-push mode?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么反应式流被认为在动态拉-推模式下是可行的？
- en: What are the typical building blocks of Akka Stream's graph?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Akka Stream 图的典型构建块是什么？
- en: How do we convert a graph into a runnable graph?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将一个图转换为可执行的图？
- en: What is the main goal of having materialization as a separate explicit step?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要将材料化作为一个单独的明确步骤的主要目标？
- en: Describe the effects of applying different supervision strategies.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述应用不同监督策略的效果。
- en: Which main abstractions provide an Akka Streams `TestKit`? Why are they useful?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些主要抽象提供了Akka Streams `TestKit`？为什么它们是有用的？
- en: Further reading
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Christian Baxter, *Mastering Akka: **Master the art of creating scalable, concurrent,
    and reactive applications using Akka*
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Christian Baxter，《精通Akka：**掌握使用Akka创建可扩展、并发和响应式应用程序的技艺》
- en: Héctor Veiga Ortiz, Piyush Mishra,*Akka Cookbook: Learn how to use the Akka
    framework to build effective applications in Scala*
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Héctor Veiga Ortiz, Piyush Mishra，《Akka 烹饪书：学习如何使用Akka框架在Scala中构建有效的应用程序》
- en: Rambabu Posa, *Scala Reactive Programming: Build fault-tolerant, robust, and
    distributed applications in Scala*
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rambabu Posa，《Scala Reactive Programming：在Scala中构建容错、健壮和分布式应用程序》
