- en: Migrating Your Code to Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at what it takes to start with a pre-Java
    9 code base and have it compile or run with minimal changes in the new Java 9
    platform. We also looked at some problems you could face with your legacy code
    and how to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working on a code base that you expect to make many changes or enhancements
    to, then you'll want to do more than just run it in Java 9\. You'll want to take
    advantage of the modularity features that Java 9 provides. Of course, you shouldn't
    always blindly rewrite your application to use modules just because you can! The
    advantages of modularity--strong encapsulation and reliable configuration--are
    the most useful in applications where there is a large code base with clear boundaries
    and multiple teams working on it. In this chapter, we'll take a look at how you
    can use those new modularity features and gradually introduce them to your pre-Java
    9 codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics we''ll be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Migration strategy for codebases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-release JARs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be working on the shopping bag example that we've looked at in the previous
    chapter. We've got it compiling and running in the Java 9 platform. We'll now
    be adding modularity features to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how do you go about doing something like that? In the case of a small application,
    like the example code we are looking at, it is trivial to make a complete change
    across the application--you can split a small codebase into modules based on the
    roles that different types in your code performs. And then wrap the individual
    modules in modules with the right module definitions. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, most real-world applications are much larger and more complex.
    Thus, they cannot be modularized with a **big bang** approach. You'll have to
    gradually chunk away at it, moving portions of the application into modules. How
    would this work in an application where a portion of the code is modularized while
    the rest isn't? In addition, most applications, especially enterprise Java applications,
    use some kind of a framework or library to handle application infrastructure.
    What does Java 9 migration mean in those cases? Would the libraries need to be
    rewritten to use modules as well? Could you modularize your application while
    the libraries are not yet modularized? Before we answer these questions, let's
    first understand what the migration goal is. What are we trying to achieve?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the migration goal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume you are done with the steps in the previous chapter and your legacy
    code now complies or runs in Java 9\. You are ready for the next step--to migrate
    your code to use Java 9 modules! What does that look like?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very high-level picture that shows the different elements of a typical
    pre-Java 9 application running on a Java 9 platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can break a typical application down into three distinct layers. At the
    very top layer are the **application classes and jars**. Typical applications
    have a combination of **application classes and jars** along with any internal
    libraries, such as shared utility components. All of these are application specific.
    Since the application is yet to be migrated to Java 9, this layer consists of
    classes and jars in the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: The second layer denotes any **frameworks** that the application might be using.
    It's very rare to find Java applications these days that do not use an application
    framework of some sort. Frameworks such as Spring, Vaadin, JSF, and Hibernate
    are very commonly used. These are typically bundled into the application as `.jar`
    files, either downloaded manually or through a dependency management utility such
    as Maven or Gradle. Will the libraries be in the classpath or the module path?
    It depends on the library, and if the authors have migrated it to Java 9\. If
    the libraries are already migrated, all you need to do is simply add them to the
    module path! However, for the sake of this chapter, let's assume that the libraries
    are still not migrated, so that you know how to tackle the more complex scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The third layer is the underlying **Java Platform** that powers it all. This,
    as we've seen in this book, is a fully modularized platform as of Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are assuming that none of the application code or the libraries are
    Java 9 modules, they are primarily running in the class path, and the module path
    is completely empty. This is just the way we left our code at the end of the previous
    chapter. Here''s the *before* picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The goal is to create modules and move everything from the **classpath** into
    the **module path**. Once we are done, the **classpath** will be empty and everything
    that the application needs will run from the **module path**. Here''s the ideal
    *after* picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that in the *after* picture, we aren't even using the **classpath** anymore.
    All the code and binaries we need are now converted to modules and made available
    in the **module path**. Thus, in an ideal world, there is no need to even pass
    the classpath argument! Also, notice that I have intentionally changed the representation
    of modules to random sizes. This is to highlight that there might not be a one-to-one
    mapping between the JARs and classes in the classpath to the converted modules.
    You might break a single JAR in your Java 8 application into multiple modules
    in Java 9 or merge multiple JARs into a single module.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea about what the end goal is, let's look at the migration
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning the migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go through the migration process by working on the sample shopping bag
    application. It's a simple app that contains three classes--one to read user input,
    one to provide a shopping bag functionality, and one class with a main method
    to drive execution--iteratively taking in user input, adding it to the shopping
    bag, and then printing the contents of the bag. The application has a dependency
    on the commons collections JAR file for the Bag data structure. It also calls
    the Java logging API to log the start and end times to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The shopping bag application has code that is referred to as a *monolith*. That
    is, all the code that forms the app is in one code base. This is really a simplification,
    and does not represent a real-world application that could span multiple projects
    and have different build artifacts that are bundled together. We'll keep things
    simple and run through the migration process with the simplified monolithic code
    base first and then expand it to a multi-project setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are starting with the code in the `01-legacy-app` folder. The application
    code is in the `src` folder and the commons collections JAR in the `lib` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first step to modularizing this application is to create one big module
    that wraps around the entire application. We've run this application in the classpath
    in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb), *Preparing
    Your Code for Java 9*. The platform helped us there by creating an unnamed module
    that housed all of our code, which was an automatic process. This time, we'll
    do this ourselves by creating a module for our application called `packt.shoppingbag`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, just like before, let''s assign a module source folder where the source
    of all the modules resides. You can either create a new folder or use the existing
    `src` folder. I''ll choose the latter. In the `src` folder, create a module room
    folder, `packt.shoppingbag`, and a `module-info.java` file within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's just an empty module descriptor for now. We'll get back to this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a module root, you can move the entire source (with the package
    name folder hierarchy) into the module root folder. The source code in the `11-migrating-application/02-migrating-to-one-module`
    folder represents this state of the code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we have now is far from a *modular* Java application. However, it does
    technically have one module. So, the way to compile and execute this application
    needs to be similar to what we've done so far in this book. That is, use the module
    source path argument for the source location containing the module root and the
    module path argument to point to the location of the compiled modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try compiling this application. We''ll first create a folder called
    out to contain the compiled classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the javac command we''ve used all along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, you''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The compiler is unable to find the commons collections dependency. Makes sense!
    The JAR in the `lib` folder and we never told the compiler about it. Now, can
    we add this JAR to the class path and compile again?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Nope, that won''t work either. Why is that? Here''s a picture of the application
    we have now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve moved the application code into the **module path**, but the library
    (in our case, a single JAR file) still exists in the **classpath**. And, since
    it is in the **classpath**, it is a part of the automatically created unnamed
    module. We''ve already seen how the unnamed module reads all resolved modules
    by default. Thus, any code in the unnamed module can access types in the **module
    path**. This is what we did in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Preparing Your Code for Java 9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, what we are trying to do here is the other way round. We want a module
    in the **module path** to access types from the **unnamed module**, and there's
    the problem. It turns out that no other module can read the **unnamed module**!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is an intentional restriction. Every module needs to meet the requirements
    of strong encapsulation and reliable configuration. If a module were to read the
    class path, we'd basically be tossing reliable configuration out of the window!
    Since the class path does not have reliable configuration, there's no way the
    platform can verify if the module has everything it needs. So, preventing explicit
    Java 9 modules from accessing the classpath is a Good Thing™.
  prefs: []
  type: TYPE_NORMAL
- en: It does cause a major problem with migration though. Moving code from the class
    path to the module path is taking it down a one-way street. Once the code is crossed
    over to the module path, it cannot access anything from the class path. It's not
    so much an issue for your application code. Like we've seen, you can take your
    entire code base and put it in a giant named module, like we did with the shopping
    bag app. And now, none of your code is in the classpath. Great! However, what
    about libraries? Almost every Java application has third-party libraries and frameworks
    that are mostly JARs pulled in from the internet and bundled into the classpath.
    Since we don't control or maintain the library code, we cannot put their code
    in a module and wrap them with a module descriptor. So, until the authors of your
    libraries get to migrate their code to Java 9, you are stuck with non-modular
    libraries. How can your types access them? Do you have to hold off on modularizing
    your code until the very last library you use has its code migrated to Java 9?
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, that's not the case. The platform helps, once again, with the ability
    to create modules from JARs automatically. These modules are called **automatic
    modules**.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to avoid the problems with third-party library dependencies, which
    we just discussed, the Java platform has a mechanism to automatically create modules
    from JAR files. You don't need to access the library code or even create a module
    descriptor. All you need is the JAR file. This works great because, for any third-party
    library, the one thing that you are sure to have is the JAR file!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, what does it take to convert a JAR file into an automatic module and
    drop them into your application? The answer is--nothing! All you need to do is
    drop any JAR file into the module path. The platform automatically converts it
    into a module. Here are the things that the platform does to every JAR that it
    encounters in the module path:'
  prefs: []
  type: TYPE_NORMAL
- en: It automatically converts the JAR into a module and gives it a name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets up the module definition--What the module reads and exports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And since they are now modules with a name (albeit automatically created), your
    code can depend on and require them just like any other module.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the preceding two options in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic module naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a JAR file, how does the platform know what to name it? For instance,
    if I were to drop the JAR file we are currently working with--`commons-collections4-4.1.jar`--into
    the module path, what would be the name of the module that gets created from it?
  prefs: []
  type: TYPE_NORMAL
- en: Naming of an automatic module is based off of the name of the JAR file, without
    the `.jar` extension. For example, if your JAR is named `foo.jar`, the name of
    the automatic module is `foo`! But, wait! What about invalid characters? It's
    very common to have the `-` character in the JAR name, but it's not allowed in
    module names. In such cases, the `-` character is automatically replaced by the
    `.` character. So, if the JAR file's name is `my-lib.jar` , the name of the automatic
    module would be `my.lib`.
  prefs: []
  type: TYPE_NORMAL
- en: While this naming works, it can be a hassle. It's because most JARs (especially
    ones from Maven or Gradle build systems) commonly have the version number in the
    name. This means that every time you get a new version of the JAR, the name of
    the module changes! To prevent that, and to make the library module names consistent,
    the automatic module name drops the version number from the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, given a JAR file name, the automatic module naming does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It drops the `.jar` file extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It replaces `-` characters with `.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It removes the version string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the JAR, `commons-collections4-4.1.jar`, gets the automatic module name--
    `commons.collections4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JAR file name** | **Automatic module name** |'
  prefs: []
  type: TYPE_TB
- en: '| `commons-lang-1.2.10.jar` | `commons.lang` |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-core-4.3.10.RELEASE.jar` | `spring.core` |'
  prefs: []
  type: TYPE_TB
- en: '| `guice-4.1.0.jar` | `guice` |'
  prefs: []
  type: TYPE_TB
- en: Automatic module definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the automatic module *require* and *export*? The answer is--everything!
    Remember that the platform creates the module descriptor automatically, so it
    has no idea what the module needs or what it will be used for. To make sure things
    work, it creates the least restrictive module definition possible.
  prefs: []
  type: TYPE_NORMAL
- en: It `requires transitive` all resolved modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It exports all modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reads the unnamed module (that is, all code in the classpath)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you agree that this is the worst module definition you can possibly create
    for a module. However, this is required to ensure that the libraries in the Java
    ecosystem work seamlessly as automatic modules. This is not the ideal end state.
    We'd like to move to an environment where all the libraries are modularized too,
    and we work with actual modular JAR files with well-defined `requires` and `exports`
    definitions in the module path. Until that happens, automatic modules help get
    us going with the migration.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the automatic modules `requires transitive` all resolved modules.
    You read that right! When you depend on an automatic module, you read *everything*,
    whether you want it or not! Be very cautious about what dependencies you use.
    Just because you get readability to any module doesn't mean it's okay to use it.
    Always keep the module definition in mind. Automatic modules are just a stop-gap
    arrangement. You don't want to take the readability relationship you get for granted.
    Remember that when the automatic module goes away, the transitive readability
    goes away with it.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating with automatic modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this knowledge of automatic modules, let's resume the migration of the
    shopping bag application. We need to get the commons collection JAR out of the
    classpath and made into an automatic module. To do that, rather than moving the
    JAR, we'll just supply the `--module-path` argument with the path to the JAR (the
    `lib` folder), thereby making the JAR file in the module path. (Unlike the classpath,
    you don't have to specify the file name. Just the folder location will do.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the compiler command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following different errors now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This fix should be a bit more obvious. The compiler is complaining that the
    `packt.shoppingbag` module does not *require* the modules whose types it uses.
    It uses the logging API (in module `java.logging`) and the Commons Collections
    API (from the now-created automatic module called `commons.collections4`). Let''s
    add them both as dependencies in `module-info.java`. Note that we are using the
    automatic module name to establish read relationships just like any other Java
    9 module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this sample application, we are using just one JAR file. It is far from a
    realistic scenario. Most real-world applications have multiple JARs. So, this
    step would involve converting all the necessary JARs into automatic modules by
    adding them to the module path and then adding the right `requires` declaration
    in your module definition files.
  prefs: []
  type: TYPE_NORMAL
- en: When compiling again, things should work without any errors. To execute, we'll
    use the same `java` command with the `--module-path` flag that we've used before,
    with one minor change. We need to add the `lib` folder to the module path, because
    we, again, want the commons collections JAR to be treated as an automatic module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use the delimiter (`:` for macOS/Linux and `;` for Windows) to separate the
    two module paths--`out`, which has the compiled modules, and `lib`, which has
    the JAR. Everything should work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: There is one potential problem that could result from automatic modules that
    you need to watch out for. Remember the split package problem that we discussed
    in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb), *Module
    Resolution, Readability, and Accessibility*? It is not possible for a single package
    to exist in two different modules in Java 9\. However, it is possible for a package
    to exist in two different JARs. Now what happens when you take two such JARs that
    share a package and make them as automatic modules? They don't work, because they
    result in the split package problem. If you encounter this problem with any library
    of yours, there is unfortunately not much you can do. You'll either have to move
    things back to the classpath, or bug the library developers to have them fix their
    code. Or both!
  prefs: []
  type: TYPE_NORMAL
- en: Using jdeps to outline module relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used `jdeps` to identify the usage of internal JDK APIs. The tool can do
    much more than that! One feature that comes in handy when migrating code to Java
    9 is the `-summary` option. What this does is go through your compiled modules
    and identify the relationships between different modules. This makes sure that
    you get the right `requires` relationship specified in your modules, including
    the automatic modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `jdeps` command in the `11-migrating-application/02-migrating-to-one-module`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `-recursive` flag instructs `jdeps` to recursively navigate subfolders and
    list the dependencies of modules found in them too.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you get a really helpful output listing what module reads what.
    This is very handy when you have a bunch of JAR dependencies that were compiled
    in Java 8 or earlier, and you are trying to add them as automatic modules; rather
    than guessing what modules need to read these automatic modules, you can just
    run this command and get a good overview.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring into smaller modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have your codebase in the module source path, the next steps would
    be to gradually break it down into smaller modules. This effort depends on the
    size of your codebase and how much of it you want to tackle at a time. You can
    choose to leave the single module as is and only create modules for any new code
    that you write. Thus, the legacy code does not get the benefit of modularity concepts,
    but any new code does. However, it is highly recommended to do the following two
    steps at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: Find modular versions or equivalents for your libraries and move the JARs out
    of the module path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Break down the module into smaller modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 1** removes the broad transitive dependencies that automatic modules
    give you, so that you can get more fine-grained control over your dependencies.
    This depends on the libraries you use and if the authors have gotten to migrating
    them to Java 9\. Once a library gets updated to Java 9, the updated version can
    still be placed in the module path, but this time, since they''ll have a proper
    module descriptor, the platform will not need to convert them to automatic modules.
    You might have to check if the new name of the Java 9 modules in those libraries
    are different from the automatic module names you had previously used, and if
    they are, update your module descriptors to use the new library module name.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2** makes sure that the legacy code also gets the benefits of strong
    encapsulation and reliable configuration. Since unlike step 1, we can control
    step 2, let''s do just that for the shopping bag application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we''d like to split the code into the following three modules:'
  prefs: []
  type: TYPE_NORMAL
- en: User Input module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bag module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I know this is an overkill for this small application. However, it helps as
    an example, illustrating the next step in the migration.
  prefs: []
  type: TYPE_NORMAL
- en: The `11-migrating-application/03-splitting-modules` folder contains the state
    of the application after separating the code into multiple modules. Note the module
    descriptors in each module narrow down the dependencies, making it clear which
    part of the code needs those external APIs. The `java.logging` is required just
    by the `packt.app` module. The commons collection is required by `packt.bag`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling larger codebases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sample application we modularized is very simple and not a representation
    of most real-world applications. Here are a couple of characteristics in which
    most applications differ:'
  prefs: []
  type: TYPE_NORMAL
- en: They have a *broader* code base that spans multiple projects. These projects
    may reside in different source locations and may be hooked to a build system.
    The build of the main application then gathers the right dependencies together
    to form the final application build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have many more framework dependencies that have more complex needs. Frameworks
    such as Spring or Hibernate require access to your application code to do reflection.
    They might scan your classes for annotations and do various things such as dependency
    injection and object-relational mapping. In that sense, it is not just your application
    code that needs access to libraries as automatic modules; even such automatic
    modules would need access to your application code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given such a large Java 8 code base, how do you even begin migrating? Here
    are some steps that you''d typically follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Draw module boundaries and create a high-level module map:'
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, modularizing existing code starts with having at least a rough
    high-level idea of the modules you need and how you plan to split the code base.
    We've looked at some strategies and tips to help you draw module boundaries in
    [Chapter 9](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb), *Module Design
    Patterns and Strategies*. Depending on the complexity of your code, you'll need
    to either look at the code in entirety or in high-level parts and come up with
    some module names and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a rough idea about what your modules will be, you can create a
    module graph that represents the dependencies between these modules. Don't get
    too involved in the details. This is just a rough sketch and you may be inclined
    to make changes to either the modules or their relationships as you get into the
    weeds and start refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**: Modularize the *main* application:'
  prefs: []
  type: TYPE_NORMAL
- en: Among all the code projects that a large application consists of, there's usually
    one that can be classified as the *main* project. It is the one that perhaps starts
    the execution or the project that is built and deployed as the application. That
    would be a good place to start. You can follow the steps you learned in this chapter
    to bring that application over to the module path first.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**: Use the module overrides for special library needs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a framework like Spring or Hibernate, you are sure to run
    into problems when using them as automatic modules. That''s because those frameworks
    typically need access to your code base to reflectively scan your classes for
    annotations. We know that automatic modules read all resolved modules. So, it
    technically reads your application modules that could have Spring annotations.
    However, if your modules do not *export* the packages, it''ll still be unable
    to access them. You can get around this problem in a couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `opens` declaration to the packages that contain such annotations in
    your module definition so that the libraries have access to reflect on the necessary
    classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `--add-opens` command-line arguments to achieve the same result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 4**: Leverage automatic modules for in-house build artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: There's no reason why you should not use automatic modules even for your own
    application JARs. Let's say you are migrating a large Maven application with multiple
    artifact dependencies on other projects that are built in-house (or code that
    you own). Those in-house artifacts can be added to the module path and converted
    into automatic modules too. One thing to watch out for here is the split package
    problem. Since we are dealing with in-house code, there's a good chance that there
    are package overlaps between JARs. In such cases, you'll need to refactor your
    code to make sure there are no overlapping packages in JAR files. You can do this
    refactoring while using an older version of Java too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5a**: Break down the *main* project into smaller modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, following the process we used in this chapter, start chunking away pieces
    of the monolithic module into smaller pieces. Establish clearer dependencies among
    the smaller modules as you go.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5b**: Migrate modules from the leaf up:'
  prefs: []
  type: TYPE_NORMAL
- en: In parallel to **Step 5a**, you can also start migrating projects other than
    the main project too. Since you've built your module tree, the order of migration
    of modules becomes clear. You can make your migration significantly easier by
    ordering the modules you choose to migrate from the leaf of the module dependency
    tree and work your way toward the top. The ideal candidate for migration is a
    module that does not have any other application module dependency. Dependency
    on Java modules is okay though!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say this is your target module graph for the code that
    you plan to achieve after migration. The graph includes just your application
    modules. Any dependency on platform modules is excluded in this graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first set of modules you should pick for migration are **D** and **E**.
    Once they are done, migrate **C**, then **A** and **B**.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at steps and strategies to follow when migrating applications to
    the Java modules. How about libraries? Let's say you are the maintainer of an
    open source library that is used by many people. Or, perhaps, you maintain a library
    that's used by multiple teams in your organization. How would you migrate such
    a code base? Wouldn't that require you to follow the same steps we've covered
    to migrate applications? Well, mostly yes. However, there are certain things you
    need to do differently with libraries. This section covers those details.
  prefs: []
  type: TYPE_NORMAL
- en: What's perhaps the biggest difference with libraries is that you no longer work
    in the *context* of an application. A library could be used by multiple applications.
    These applications could be using multiple versions of Java. How could you create
    a single library JAR that could work for all those cases? Thankfully, there are
    some features in the platform that make this easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into those specific problems, let''s look at what it takes to
    migrate library code to use Java 9 modules. Here are some high-level steps you
    need to follow as a library author:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eliminate the JDK internal API usage**: This is no different from what we
    did for applications. We need to make sure the library is a good Java 9 citizen.
    Calls to JDK internals or deprecated APIs are a no-no. Refactor your code to avoid
    the calls or use a replacement that our friendly `jdeps` tool with the `--jdk-internals`
    option suggests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Eliminate any split packages**: We''ve looked at how split packages cause
    problems with automatic modules. You''ll need to make sure your JARs do not contain
    packages that could potentially exist in other JARs in your organization. If other
    teams own libraries whose packages conflict with yours, you''ll need to work with
    them to streamline the package names'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify a name for your core library module**: As with any module, you need
    to come up with a name for the library. This is not that big of a deal when working
    with libraries that are used only in your organization. However, it''s a much
    more important step when dealing with open source modules. Like we''ve covered
    in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb), *Creating
    Your First Java Module*, module names can follow reverse domain name convention.
    You can opt to go with a shorter name for strictly in-house libraries to ease
    readability and communication, because name conflicts are less likely in such
    cases.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Start refactoring and converting your code into modules**: This involves
    moving your code into module root folders, adding module descriptors, and defining
    the `requires` and `exports` definitions for your modules. Be careful about any
    types that you encapsulate. If there are consumers of your library using those
    types, they''ll not be able to use them anymore, unless they add the `--add-exports` overrides.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with application migration, I highly recommend that you survey your library
    code and come up with a high-level module diagram that outlines the relationships
    between modules before you start digging into the code and moving files around.
    It will save you a lot of time and work!
  prefs: []
  type: TYPE_NORMAL
- en: '**Add transitive dependencies or wrap around dependency leakage**: There''s
    a chance that your library code depends on other libraries. They may be other
    in-house libraries or open source JARs. These libraries may not be migrated to
    Java 9 yet, and we have the same problem we did for application dependencies.
    Here, again, you''ll need to use automatic modules for the JARs that your library
    depends on. If using your APIs requires access to those libraries, it''s a good
    idea to add require transitive on those libraries in your module definition. If
    possible, wrap around those types so that the code consuming your library doesn''t
    have to be aware of this dependency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reserving library names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you are a library developer who is not ready to migrate your code
    to Java 9 yet. We know that's not a problem. Other Java 9 applications can still
    consume your library by dropping the JAR into the module path, thus making an
    automatic module out of it. They use the auto-generated module name from the JAR
    file name and use that in their module definition files. However, what if you
    have a really cool name for your module that you plan to use when you eventually
    get to migrating to Java 9? Does it mean that all the consumers will then have
    to go to all the module definitions that specify the auto-generated name and update
    them to the new module name? That can be tedious.
  prefs: []
  type: TYPE_NORMAL
- en: The Java 9 platform gives library authors an option to *reserve* a module name
    for their libraries, even before migrating their libraries to Java 9\. So, you,
    as a library author, can specify what you want your Java 9 module name to be in
    the `META-INF/MANIFEST.MF` file in your JAR. You can do this in your Java 8 compiled
    JAR. Once you do that and bundle it into your JAR file, when it is dropped into
    the module path in a Java 9 application, the platform picks that name up as the
    automatic module name. It essentially overrides the automatic naming of modules
    from the JAR file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you specify your preferred automatic module name in your JAR file.
    Create a file called `MANIFEST.MF` file in the `META_INF` folder in the root of
    the JAR file. Add the following line to specify the preferred automatic module
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once you've done this, the JAR is given this name instead of the name from the
    JAR file name when the platform converts it into an automatic module. And all
    the consumers have to refer to your JAR in the module path by using this preferred
    module name. Thus, when you do get to migrating your module to Java 9, you can
    use the preferred name in the module descriptor and the consumers of your library
    won't need to change their module descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Using jdeps to create module descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you start breaking down your library JARs into modules, depending on the
    size of your library, you may have a lot of work to do. It's not straightforward
    to identify which modules you'll need to `require` and which you'll need to `export`.
    The `jdeps` tool has another trick up its sleeve. It can look at your JAR files
    and automatically come up with module descriptors for you to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try this for the commons-collections JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `jdeps` has generated a module root folder with the same automatic
    naming algorithm we''ve seen before. Inside that folder, it has created a `module-info.java`
    file that it has populated with the `requires` and `exports` declarations that
    it identified by scanning the classes in the JARs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can run this command and point to multiple JARs, and it'll do this for every
    single JAR, which also benefits from any relationships between the JARs. The generated
    `module-info.java` files for those related modules will include the relationship
    too!
  prefs: []
  type: TYPE_NORMAL
- en: Remember to use this feature just as a starting point to define your module
    definitions. The platform cannot obviously guess the perfect module definition
    for your library just by looking at the code. It's your job as the author of the
    library to come up with what it requires and what it encapsulates or exports.
    There is also a technical limitation here. The `jdeps` does static code analysis,
    so it will not be able to catch any runtime reflective access that libraries may
    perform. If your library is using reflection, you'll need to manually add the `exports` or `opens` declarations
    to the right modules yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Building libraries for multiple Java versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When migrating applications, we had to deal with the scenario that the dependent
    libraries might not all be migrated to Java 9\. When dealing with libraries, you''ll
    need to tackle the opposite problem. The applications consuming your library may
    not all be Java 9\. You''ll have to support Java 8 (or perhaps even older versions
    of Java in some cases). How do you, as a library author, create library distributions
    for all those versions? Before Java 9, you used to have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: You could create separate JARs for each Java version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your library code, you could use reflection to do a *feature check*. For
    example, you could reflectively access a platform API that was introduced in Java
    8\. If it works, you are in Java 8\. If not, drop down to Java 7, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these options are tedious. There is a new alternative with Java 9, with
    a feature called *multi-release JARs*. The concept is simple. You create a special
    JAR file called a *multi-release JAR* that contains classes for all versions of
    Java you are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it works. Multi-release JARs have a special structure that holds
    the classes within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what you''ll find in a multi-release JAR file, corresponding to the
    numbering in the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a root `META-INF` folder with a `MANIFEST.MF` file that contains the
    following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Multi-Release: true`'
  prefs: []
  type: TYPE_NORMAL
- en: This tells the platform that this is a multi-release JAR and thus needs to be
    treated differently
  prefs: []
  type: TYPE_NORMAL
- en: The JAR root also contains a default version of the compiled classes, just like
    any other JAR. Remember, this JAR targets multiple Java versions and it could
    hold multiple target versions of the same class. The classes at the root folder
    are the *default* base versions that could potentially apply to multiple Java
    versions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a folder called `versions` inside `META-INF.` To target multiple runtimes,
    the JAR packages classes into sub-folders here. There's one folder for each Java
    version you want to target. Each such folder contains classes that have been specifically
    compiled for that release version. So, if the JAR is used in that version of the
    Java platform, the classes in the version folder override the classes in the `multirelease` folder
    and are picked up instead. If the JAR is used in a platform version that does
    not have classes in the `META-INF` folder, or the class needed doesn't exist in
    the version folder, the runtime falls back to the contents of the `multirelease` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the default versions of the classes are in the root location in
    the JAR file. This is why you can use the JAR file with older versions of Java
    too. To older Java versions, a multi-release JAR file looks just like an ordinary
    JAR file--the root location is all the platform looks at, and the versions folder
    is ignored!
  prefs: []
  type: TYPE_NORMAL
- en: Let's try creating a simple multi-release JAR. The `11-migrating-application/04-multirelease-jars`
    folder contains an extremely simple library. It's called `mylib` and it has a
    class with a method that prints the contents of a list passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like to create a multi-release JAR for this library targeting two different
    versions of Java:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The base version of the library targets all pre-Java 9 versions. It contains
    code that performs a `for` loop and prints the contents of the list as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java 9 specific version of this library has two changes--it declares itself
    as a Java 9 module with `module-info.java` and it uses `forEach` and a function
    reference to print the contents of the list, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The two versions of the library are in two separate folders. Since there will
    be two separate versions of the same class, it helps to separate them this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the structure of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step to making a multi-release JAR is to add the `MANIFEST.MF` file
    that declares it. Add this file at the root of the project with a single line,
    shown next. Make sure you match the statement exactly without any extra spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create the folders that hold the compiled classes. We''ll create
    a folder called `out` and have two subfolders--`base` for the base classes and
    `9` for the Java 9 version, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will compile the classes into these two folders by setting the right
    release versions. The `--release` parameter to the `javac` command lets you target
    specific Java versions for your compiled classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command compiles the `PrintList.java` class with target release
    7, and places the complied output in the `out/base` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don't need to have multiple versions of Java installed on your
    machine to achieve this. Java 9 has the ability to generate classes targeting
    different versions of Java by itself! This is analogous to the `-target` flag
    in Java that has been available in earlier versions of the Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll compile the Java 9 version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are two Java files this time--`PrintList.java` and `module-info.java`.
    The complied classes go to the `out/9` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the compiled classes, it''s time to create a multi-release
    JAR. Let''s first create a JAR file with the base version classes. We also supply
    the `MANIFEST.MF` file to be included in the JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `-c` option tells the `jar` tool to create a new JAR, and `f` option is
    used to specify the JAR file name (here, `mylib.jar`). The `-C` option changes
    the directory the tool is looking for to `out.base` and lets it compile classes
    there (as specified by "`.`").
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates the JAR file and adds the base classes to it. Next, let''s add
    the Java 9 classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `-u` options tells the `jar` tool to update the JAR rather than create one.
    We are targeting release 9 this time, and including compiled classes in the `out/9`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to add all the classes in your JAR file for every version. Try
    to keep version-specific classes to a minimum. If there are common classes in
    the base version that the version-specific copy can reuse, you just don't include
    it here. The platform will fall back to the base folder for classes it doesn't
    find for that specific version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the contents of the JAR file that''s generated. This is the structure
    we have already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that the multi-release JAR feature was introduced in Java 9\. So, you
    cannot really create version-specific alternatives in your JAR for Java 8 or earlier.
    Those versions of the platform will not know to read from the `META-INF/versions` folder.
    They'd just use the compiled classes in the JAR root folder. This is, however,
    a good feature to use if you need to create new Java-9-only classes. Since those
    classes will end up in the `META-INF/versions` folder, older platforms will ignore
    them. Once future versions of Java are released, this feature can be used for
    those versions too. So, you can have a `META-INF/versions/10` folder targeting
    the Java 10 platform, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to migrate a pre-Java 9 application to use
    the Java 9 modularity features. You learned how to plan the overall migration
    strategy, and what the ideal end goal of such a migration is. You also learned
    about a new feature in the platform that lets you handle dependencies and libraries
    that are not modular--automatic modules. We looked at how automatic modules are
    named, how they behave, and how we can use them in our migration process.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned how to approach migrating libraries. We looked at some factors
    to consider when migrating the library code, as well as the multi-release JAR
    feature that lets us create single JARs that target multiple Java platform versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we'll wrap things up by looking at two important
    aspects that Java developers commonly deal with--build tooling and unit testing.
    We will understand how they work in the context of a modular Java application.
  prefs: []
  type: TYPE_NORMAL
