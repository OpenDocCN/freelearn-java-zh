- en: Exploring the Features of WebDriver
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at various basic and advanced interactions that a user
    can perform on a web page using WebDriver. In this chapter, we will discuss the
    different capabilities and features of WebDriver that enable test script developers
    to have better control over WebDriver, and consequently of the web application
    that is being tested. The features that we are going to cover in this chapter
    are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Taking screenshots
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating target windows and iFrames
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Navigate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for WebElements to load
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling cookies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started without any further delay.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Taking screenshots
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking a screenshot of a web page is a very useful capability of WebDriver.
    This is very handy when your test case fails, and you want to see the state of
    the application when the test case failed. The `TakesScreenShot` interface in
    the WebDriver library is implemented by all of the different variants of WebDriver,
    such as Firefox Driver, Internet Explorer Driver, Chrome Driver, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The `TakesScreenShot` capability is enabled in all of the browsers by default.
    Because this is a read-only capability, a user cannot toggle it. Before we see
    a code example that uses this capability, we should look at an important method
    of the `TakesScreenShot` interface—`getScreenshotAs().`
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for `getScreenshotAs()` is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `OutputType` is another interface of the WebDriver library. We can ask
    WebDriver to output the screenshot in three different formats : `BASE64`, `BYTES`
    (raw data), and `FILE`. If you choose the `FILE` format, it writes the data into
    a `.png` file, which will be deleted once the JVM is killed. So, you should always
    copy that file into a safe location so that it can be used for later reference.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The return type is a specific output that depends on the selected `OutputType`.
    For example, selecting `OutputType.BYTES` will return a `byte`array, and selecting
    `OutputType.FILE` will return a file object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the browser used, the output screenshot will be one of the following,
    in order of preference:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The entire page
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current window
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A visible portion of the current frame
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The screenshot of the entire display containing the browser
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you are using Firefox Driver, `getScreenshotAs()` takes a screenshot
    of the entire page, but Chrome Driver returns only the visible portion of the
    current frame.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to take a look at the following code example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we used the `getScreenshotAs()` method to take the screenshot
    of the web page and save it to a file format. We can open the saved image from
    the target folder and examine it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Locating target windows and Frames
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebDriver enables the developers to switch between multiple child windows, browser
    tabs, and frames used in the application. For example, when you click on an internet
    banking link on a bank web application, it will open the internet banking application
    in a separate window or Tab. At this point, you may want to switch back to the
    original window to handle some events. Similarly, you may have to deal with a
    web application that is divided into two frames on the web page. The frame on
    the left may contain navigation items, and the frame on the right displays the
    appropriate web page, based on what is selected in the frame on the left. Using
    WebDriver, you can develop test cases that can easily handle such complex situations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The `WebDriver.TargetLocator` interface is used to locate a given frame or window.
    In this section, we will see how WebDriver handles switching between browser windows
    and between two frames in the same window.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Switching among windows
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will see a code example for handling multiple windows. For this chapter,
    there is an HTML file provided with this book named `Window.html`. It is a very
    basic web page that links to Google's search page. When you click on the link,
    the Google's search page is opened in a different window. Every time you open
    a web page using WebDriver in a browser window, WebDriver assigns a window handle
    to that. WebDriver uses the window handle to identify the window. At this point,
    in WebDriver, there are two window handles registered. Now, on the screen, you
    can see that the Google's search page is in the front and has the focus. At this
    point, if you want to switch to the first browser window, you can use WebDriver's
    `switchTo()` method to do that.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for `TargetLocator` is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This method returns the `WebDriver.TargetLocator` instance, where you can tell
    the WebDriver whether to switch between browser windows or frames. Let''s see
    how WebDriver deals with this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Observe the following line in the preceding code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, the driver returns the assigned identifier for the window. Now, before
    we move on to a different window, it is better to store this value so that if
    we want to switch back to this window, we can use this handle or identifier. To
    retrieve all the window handles that are registered with your driver so far, you
    can use the following method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will return the set of identifiers of all of the browser window handles
    opened in the driver session so far. Now, in our example, after we open Google''s
    search page, the window corresponding to it is shown in front with the focus.
    If you want to go back to the first window, you have to use the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will bring the first window into focus.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Switching between frames
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now see how we can handle switching between the frames of a web page.
    In the HTML files supplied with this book, you will see a file named `Frames.html`.
    If you open that, you will see two HTML files loaded in two different frames.
    Let''s see how we can switch between them and type into the text boxes available
    in each frame:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have used `switchTo().frame` instead of `switchTo().window`
    because we are moving across frames.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for `frame` is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method takes the index of the frame that you want to switch to. If your
    web page has three frames, WebDriver indexes them as 0, 1, and 2, where the zero
    index is assigned to the first frame encountered in the DOM. Similarly, you can
    switch between frames using their names by using the previous overloaded method.
    The API syntax is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can pass the name of the frame or its ID. Using this, you can switch to
    the frame if you are not sure about the index of the target frame. The other overloaded
    method is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The input parameter is the WebElement of the frame. Let''s consider our code
    example: First, we have switched to our first frame and typed into the text field.
    Then, instead of directly switching to the second frame, we have come to the main
    or default content and then switched to the second frame. The code for that is
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is very important. If you don't do this and try to switch to the second
    frame while you are still in the first frame, your WebDriver will complain, saying
    that it couldn't find a frame with index 1\. This is because the WebDriver searches
    for the second frame in the context of the first frame, which is obviously not
    available. So, you have to first come to the top-level container and switch to
    the frame you are interested in.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'After switching to the default content, you can now switch to the second frame
    using the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thus, you can switch between the frames and execute the corresponding WebDriver
    actions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Handling alerts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from switching between windows and frames, you may have to handle various
    modal dialogs in a web application. For this, WebDriver provides an API to handle
    alert dialogs. The API for that is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding method will switch to the currently active modal dialog on the
    web page. This returns an `Alert` instance, where appropriate actions can be taken
    on that dialog. If there is no dialog currently present, and you invoke this API,
    it throws back a `NoAlertPresentException`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Alert` interface contains a number of APIs to execute different actions.
    The following list discusses them, one after the other:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`void accept()`: This is equivalent to the **OK** button action on the dialog.
    The corresponding **OK** button actions are invoked when the `accept()` action
    is taken on a dialog.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void dismiss()`: This is equivalent to clicking on the **CANCEL** action button.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.String getText()`: This will return the text that appears on the
    dialog. This can be used if you want to evaluate the text on the modal dialog.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void sendKeys(java.lang.String keysToSend)`: This will allow the developer
    to type in some text into the alert if the alert has some provision for it.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Navigate
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, WebDriver talks to individual browsers natively. This way it has
    better control, not just over the web page, but over the browser itself. **Navigate**
    is one such feature of WebDriver that allows the test script developer to work
    with the browser's back, forward, and refresh controls. As users of a web application,
    quite often, we use the browser's back and forward controls to navigate between
    the pages of a single application, or, sometimes, multiple applications. As a
    test-script developer, you may want to develop tests that observe the behavior
    of the application when browser navigation buttons are clicked, especially the
    back button. For example, if you use your navigation button in a banking application,
    the session should expire and the user should be logged out. So, using the WebDriver's
    navigation feature, you can emulate those actions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The method that is used for this purpose is `navigate()`. The following is
    its API syntax:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Obviously, there is no input parameter for this method, but the return type
    is the `WebDriver.Navigation` interface, which contains all of the browser navigation
    options that help you navigate through your browser's history.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see a code example and then analyze the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code opens the demo application's Homepage, and, at first, searches
    for `Phone`; then, after the search results are loaded. Now that we have a navigation
    history created in the browser, it uses WebDriver navigation to go back in the
    browser history, and then go forward and refresh the page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the navigation methods used in the preceding code. The line
    of code that initially loads the demo application''s Homepage uses the `to()`
    method of the `Navigation` class, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `driver.navigate()` method returns the `WebDriver.Navigation` interface
    on which the `to()` method is used to navigate to a web URL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The input parameter for this method is the `url` string that has to be loaded
    in the browser. This method will load the page in the browser by using the `HTTP
    GET` operation, and it will block everything else until the page is completely
    loaded. This method is the same as the `driver.get(String url)` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WebDriver.Navigation` interface also provides an overloaded method of
    this `to()` method to make it easy to pass the URL. The API syntax for it is as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, in the code example, we did a search for `Phone`. Then, we tried to use
    Navigation''s `back()` method to emulate our browser''s back button, using the
    following line of code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will take the browser to the home page. The API syntax for this method
    is pretty straightforward; it''s as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method doesn't take any input and doesn't return anything as well, but
    it takes the browser one level back in its history.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the next method in the navigation is the `forward()` method, which is
    pretty much similar to the `back()` method, but it takes the browser one level
    in the opposite direction. In the preceding code example, the following is invoked:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The API syntax for the method is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method doesn't take any input, and doesn't return anything either, but
    it takes the browser one level forward in its history.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of code in the code example uses the `refresh()` method of WebDriver''s
    navigation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This method will reload the current URL to emulate the browser''s *refresh*
    (*F5* key) action. The API syntax is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the syntax is very similar to the `back()` and `forward()` methods,
    and this method will reload the current URL. Hence, these are the various methods
    WebDriver provides developers to emulate some browser actions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for WebElements to load
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a previous UI automation experience, I'm sure you would have come
    across a situation where your test script couldn't find an element on the web
    page because the web page was still loading. This could happen due to various
    reasons. One classic example is when the application server or web server is serving
    the page too slowly due to resource constraints; the other could be when you are
    accessing the page on a very slow network. The reason could be that the element
    on the web page is not loaded by the time your test script tries to find it. This
    is where you have to calculate and configure the average wait time for your test
    scripts to wait for WebElements to load on the web page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver provides test-script developers with a very handy feature to manage
    wait time. *Wait time* is the time your driver will wait for the WebElement to
    load, before it gives up and throws `NoSuchElementException`. Remember, in [Chapter
    1](9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml)*, Introducing WebDriver and WebElements*,
    we discussed the `findElement(By by)` method that throws a   `NoSuchElementException`
    when it cannot find the target WebElement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways by which you can make the WebDriver wait for WebElement.
    They are **Implicit Wait** **Time** and **Explicit Wait** **Time**. Implicit timeouts
    are common to all the WebElements and have a global timeout period associated
    with them, but the explicit timeouts can be configured to individual WebElements.
    Let's discuss each of them here.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Implicit wait time
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicit wait time is used when you want to configure the WebDriver's wait time
    as a whole for the application under test. Imagine you have hosted a web application
    on a local server and on a remote server. Obviously, the time to load for a web
    page hosted on a local server would be less than the time for the same page hosted
    on a remote server, due to network latency. Now, if you want to execute your test
    cases against each of them, you may have to configure the wait time accordingly,
    such that your test case doesn't end up spending more time waiting for the page,
    or spend nowhere near enough time, and timeout. To handle these kinds of wait-time
    issues, WebDriver provides an option to set the implicit wait time for all of
    the operations that the driver does using the `manage()` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式等待时间用于您想要配置测试应用程序中 WebDriver 的整体等待时间时。想象一下，您已经在本地服务器和远程服务器上托管了一个 Web 应用程序。显然，托管在本地服务器上的网页加载时间会小于托管在远程服务器上的相同网页的加载时间，这是由于网络延迟造成的。现在，如果您想针对每个服务器执行测试用例，您可能需要相应地配置等待时间，以确保您的测试用例不会花费太多时间等待页面，或者花费的时间远远不够，从而导致超时。为了处理这类等待时间问题，WebDriver
    提供了一个选项，可以通过 `manage()` 方法为驱动程序执行的所有操作设置隐式等待时间。
- en: 'Let''s see a code example of implicit wait time:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个隐式等待时间的代码示例：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s analyze the following highlighted line of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下突出显示的代码行：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `driver.manage().timeouts()` returns the `WebDriver.Timeouts` interface,
    which declares a method named `implicitlyWait`, which is where you specify the
    amount of time the driver should wait when searching for a WebElement on a web
    page if it is not immediately present. Periodically, the WebDriver will poll for
    the WebElement on the web page, until the maximum wait time specified to the previous
    method is over. In the preceding code, 10 seconds is the maximum wait time your
    driver will wait for any WebElement to load on your browser. If it loads within
    this time period, WebDriver proceeds with the rest of the code; otherwise, it
    will throw `NoSuchElementException`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`driver.manage().timeouts()` 返回 `WebDriver.Timeouts` 接口，该接口声明了一个名为 `implicitlyWait`
    的方法，您可以在其中指定当在网页上搜索 WebElement 时，如果它不是立即出现，则驱动程序应该等待多长时间。WebDriver 将定期在网页上轮询 WebElement，直到之前方法指定的最大等待时间结束。在前面的代码中，10
    秒是您的驱动程序将等待任何 WebElement 在浏览器中加载的最大等待时间。如果在这个时间范围内加载，WebDriver 将继续执行其余代码；否则，它将抛出
    `NoSuchElementException`。
- en: Use this method when you want to specify a maximum wait time, which is generally
    common for most of the WebElements on your web application. The various factors
    that influence the performance of your page are network bandwidth, server configuration,
    and so on. Based on those conditions, as a developer of your WebDriver test cases,
    you have to arrive at a value for the maximum implicit wait time, such that your
    test cases don't take too long to execute, and, at the same time, don't timeout
    very frequently.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要指定一个最大等待时间时，这通常是您 Web 应用程序上大多数 WebElement 的通用做法。影响您页面性能的各种因素包括网络带宽、服务器配置等。根据这些条件，作为
    WebDriver 测试用例的开发者，您必须确定一个最大隐式等待时间的值，以确保您的测试用例不会执行时间过长，同时也不会频繁超时。
- en: Explicit wait time
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式等待时间
- en: Implicit timeout is generic to all the WebElements of a web page. But, if you
    have one specific WebElement in your application, where you want to wait for a
    very long time, this approach may not work. Setting the implicit wait time to
    the value of this very long time period will delay your entire test suite execution.
    So, you have to make an exception for only a particular case, such as this WebElement.
    To handle such scenarios, WebDriver has an explicit wait time for a WebElement.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式超时适用于网页上的所有 WebElement。但是，如果您在应用程序中有一个特定的 WebElement，您希望等待非常长的时间，这种方法可能不起作用。将隐式等待时间设置为这个非常长的时间段将延迟整个测试套件的执行。因此，您必须为特定情况（如这个
    WebElement）做出例外。为了处理这类场景，WebDriver 为 WebElement 提供了显式等待时间。
- en: 'So, let''s see how you can wait for a particular WebElement using WebDriver,
    with the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看如何使用 WebDriver 等待特定的 WebElement，以下是一段代码示例：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The highlighted code is where we have created a conditional wait for a particular
    WebElement. The `ExpectedCondition` interface can be used to apply the conditional
    wait to a WebElement. Here, WebDriver will wait for a maximum of 20 seconds for
    this particular WebElement. The implicit timeout doesn't get applied for this
    WebElement. If the WebElement doesn't load within the 20 seconds maximum wait
    time, as we know, the driver throws a `NoSuchElementException`. Thus, you can
    override the implicit wait time exclusively for the WebElements you think will
    take more time, by using this handy explicit wait time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Handling cookies
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you are automating the demo application. There could be many scenarios
    you want to automate, such as searching for products, adding products to the shopping
    cart, checkout, returns, and so on. For all these actions, one common thing is
    to have to log into the demo application in each of the test cases. So, logging
    into the application in every test case of yours will increase the overall test
    execution time significantly. To reduce the execution time of your test cases,
    you can actually skip signing in for every test case. This can be done by signing
    in once and writing all the cookies of that domain into a file. From the next
    login onward, you can actually load the cookies from the file and add them to
    the driver.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch all the cookies that are loaded for a web page, WebDriver provides
    the following method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will return all the cookies that the web page stores in the current session.
    Each cookie is associated with a name, value, domain, path, expiry, and the status
    of whether it is secure or not. The server to validate a client cookie parses
    all of these values. Now, we will store all of this information for each cookie
    in a file so that our individual test cases read from this file and load that
    information into the driver. Hence, you can skip the login, because once your
    driver session has this information in it, the application server treats your
    browser session as authenticated and directly takes you to your requested URL.
    The following is a quick code to store the cookie information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'From now on, for every test case or a set of test cases, load the cookie information
    from the `browser.data` file, and add it to the driver using the following method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After you add this information to your browser session and go to the dashboard
    page, it will automatically redirect you to the home page, without asking for
    a login, thus avoiding a login every time, for every test case. The code that
    adds all of the previous cookies to the driver is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Hence, we can be directly taken to the home page without logging in again and
    again. As you can see, after creating the driver instance, we have the following
    line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ideally, this line should be visible after we have set the cookies to the driver.
    But the reason it is at the top is that the WebDriver doesn't allow you to set
    the cookies directly to this session, because it treats those cookies as if they
    were from a different domain. Try removing the previous line of code and execute
    it, and you will see the error. So, initially, you will try to visit the home
    page to set the domain value of the driver to the application server domain and
    load all the cookies. When you execute this code, initially, you will see the
    home page of the application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Hence, you can avoid entering the username and the password on the server, validating
    them again and again for each test, and thereby save a lot of time, by using the
    WebDriver's cookies feature.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed various features of WebDriver, such as capturing
    screenshots and handling `Windows` and `Frames`. We also discussed implicit and
    explicit wait conditions for synchronization, and we used Navigation and the cookies
    API. Using these features will help you test your target web application more
    effectively, by designing more innovative test frameworks and test cases. In the
    next [chapter](ff724e47-f410-4c90-bc11-cf0fbd340773.xhtml), we will look at the
    **Actions** API to perform user interaction using keyboard and mouse events.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which are the different formats we can use to output a screenshot?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we switch to another browser tab with Selenium?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: The `defaultContent()` method will switch to the previously
    selected frame.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What navigation methods are available with Selenium?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we add a cookie using Selenium?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between an implicit wait and an explicit wait.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further information
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about how you can use a set of predefined expected conditions
    while using an explicit wait at [https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html](https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about WebDriver's features in Chapter 4*, Working with Selenium
    API* and Chapter 5 *, Synchronizing Tests,* in *Selenium Testing Tools Cookbook*,
    2nd Edition, by Unmesh Gundecha, Packt Publications.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
