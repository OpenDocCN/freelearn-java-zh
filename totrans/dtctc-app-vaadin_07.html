<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing CRUD User Interfaces</h1>
                </header>
            
            <article>
                
<p>Most business applications have to deal with data manipulation. Users are able to see, change, delete, and add data. All these actions are executed according to and in the context of a set of rules dictated by the business. In its more fundamental form, business applications include graphical user interfaces to perform<span> </span>CRUD<span> </span>actions over the data. <strong>CRUD</strong> is an acronym for<span> </span><strong>Create, Read, Update, and Delete</strong>. This chapter explores the design and implementation of CRUD views.</p>
<p>We'll start with a quick discussion about CRUD views from a <strong>User Experience</strong> (<strong>UX</strong>) perspective. Then, we will move on to how to design and implement CRUD user interfaces using two different UI designs. This chapter also explains the basics of data binding, shows how to use the Java Bean Validation API, and demonstrates how to render UI components inside<span> </span><kbd>Grid</kbd> components.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>CRUD user interface design</li>
<li>Data binding</li>
<li>Validating with JSR-303</li>
<li>Grid renderers</li>
<li>Filtering</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/szGaRy">https://goo.gl/szGaRy</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CRUD user interface design</h1>
                </header>
            
            <article>
                
<p>UX in the context of <strong>user interfaces</strong> (<strong>UI</strong>) refers to the degree of quality in the interaction between the user and the UI. An application designed with UX in mind enhances the user satisfaction by improving its usability. Simplicity is key in the process of UX design, but avoid falling into a minimalistic design, which may otherwise spoil usability.</p>
<div class="packt_tip packt_infobox">You can find more information about simplicity, minimalism, and general myths about UX design at <a href="http://uxmyths.com">http://uxmyths.com</a>.</div>
<p>UX design may include several disciplines, including wireframing, prototyping, testing, and validating designs. In this section, we'll explore variations of typical CRUD views. Examples of this kind of views are the admin views for managing registered users, views for internal application configuration, or views used by<span> </span><strong>DevOps</strong><span> </span>members.</p>
<div class="packt_infobox">DevOps is a softwares engineering discipline that unifies software development and software operation (deployment and infrastructure management).</div>
<p><span>We'll avoid the term CRUD for more sophisticated views that might include all of the CRUD operations. In general, these views are business-specific, and developers should design them according to the particularities of each case.</span></p>
<p>CRUD views are about<span> </span><em>record</em><span> </span>editing. Records are items that are usually understood as a whole. Some are suitable for tabular presentation, while others are not; for example, events on a calendar. When designing a CRUD view, think about the following factors:</p>
<ul>
<li><strong>Record complexity</strong>: How many fields does the record contain? Do the fields change depending on the state of other fields? Are there any complex fields such as maps or calendars? How complex are the validation rules?</li>
<li><strong>Editing frequency</strong>: How often do users need to edit the record? Do they need a quick way to edit certain fields?</li>
<li><strong>Context awareness</strong>: Do users need extra data when editing a record? Do they need, or would they benefit from, seeing other records when editing one?</li>
</ul>
<div class="packt_tip"><span>As a rule of thumb, think about how frequently users will perform the actions on the view, and if they can benefit from seeing many records at a time or not. If the frequency is high for any operation, and they won't benefit from seeing other records in the view, don't use a <em>generic</em> CRUD interface. Implement the view tailored to the use case.</span></div>
<p>Let's analyze three CRUD user interface designs: in-place fields, modal pop-up windows, and hierarchical menus.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">In-place fields</h1>
                </header>
            
            <article>
                
<p>With this design, users can activate a field to edit a single value. Data can be presented in a tabular format, in which case, clicking a cell would activate an input field, which would allow the user to directly edit the value. The following figure shows an example of this kind of interface:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-204 image-border" src="assets/35e20d1c-121d-4f7a-865b-c0e31333f633.jpg" style=""/></div>
<p>The <strong>Vaadin Framework</strong> allows this through the<span> </span><kbd>Grid.addComponentColumn</kbd><span> </span>method. The following line adds  a<span> </span><kbd>Button</kbd><span> </span>to an existing<span> </span><kbd>Grid</kbd>:</p>
<pre>grid.<strong>addComponentColumn</strong>(user -&gt; new Button("Delete", e -&gt; deleteClicked(user)));</pre>
<p>There are advantages and disadvantages of using this option. The main advantage is speed. Users can quickly edit a value, and there's no need to navigate to other views in order to edit the data; however, implementing the<span> </span><kbd>add</kbd><span> </span>operation requires extra considerations. When the user clicks the<span> </span><span class="packt_screen">Add</span><span> </span>button, a new empty row is added; however, it's not easy to know when the row can be saved (in a database, for example). Is a completely empty row a valid record? One way of solving this is by only persisting the record when all the values in it are valid. Another disadvantage is evident when the record has many fields, which, in this case, means a grid with many columns. Editing the data in columns that are scrolled out of the view requires extra interaction from the user, which wipes out the advantage of editing data quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modal pop-up windows</h1>
                </header>
            
            <article>
                
<p>This kind of user interface shows a modal window anytime the user wants to create, modify, or delete a record. A first approach to this is to combine in-place editors with modal windows. When the user clicks or double-clicks a row, an editor is placed on top of the row, showing all the input fields required to edit the data, and the buttons to cancel the action or save the data. <span>This is exactly what </span><kbd>Grid</kbd><span> editors are in Vaadin Framework, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-205 image-border" src="assets/5610e18f-b17c-404e-9a2c-b708baebb7d1.png" style=""/></div>
<p>This is enabled as follows:</p>
<pre>grid.<strong>getEditor</strong>().<strong>setEnabled</strong>(true);</pre>
<p>A second approach is to actually show a modal window that blocks any other interaction with other parts of the page. The following is a figure of this kind of interface:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-206 image-border" src="assets/3182171e-c5c3-4372-9ada-b3202220c36c.png" style=""/></div>
<p>There are several advantages of this approach. The window allows any kind of design for the form it contains. Input fields can be grouped if they are related, help text or instructions can be added, and validation errors can be shown in multiple ways. It is also an intuitive <em>dead-end view</em>; users cannot navigate anywhere else but back, which makes it an easy-to-use interaction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hierarchical menus</h1>
                </header>
            
            <article>
                
<p>When data can be represented in a hierarchical way, it can serve as the<span> </span><em>Read</em><span> </span>part in CRUD, and as a navigation tool. The following figure shows a CRUD of<span> </span><em>Organizations</em>, <em>Departments</em>, and <em>Employees</em><span> </span>records:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-207 image-border" src="assets/92892c05-ea83-4a83-a2a4-b677f87b11b9.jpg" style=""/></div>
<p>A key element in this kind of design is the use of most of the available space for the forms containing the input fields. Forms are shown in<span> </span><em>view mode,</em><span> </span>and are made editable when the user clicks an <span class="packt_screen">edit</span><span> </span>button. In the preceding figure, a short representation of the records appears in the navigation menu itself. In order to edit one record, the user can click it from the menu. When a record can be associated with one or many records of another type, they are grouped and shown in a hierarchical fashion in the menu. Top-level items in the menu don't necessarily need to be records themselves, since they can serve as a different kind of grouping. For example, a top item could show the <span class="packt_screen">Organizations</span> option having all the actual organization records as <em>children</em>.</p>
<p>This kind of design works well for configuration options; however, it has the disadvantage of showing many options at the same time, which might cause a distraction for end users. For example, a user might forget to click the<span> </span><strong>Save</strong><span> </span>button after editing some fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The domain model</h1>
                </header>
            
            <article>
                
<p>The following sections show how to implement CRUD views using two different designs: a<span> </span><kbd>Grid</kbd><span> </span>in editable mode, and modal windows. But first, we need to implement a <strong>domain model</strong>. We'll use JPA and<span> </span><em>repository classes</em>, which we explained in the previous chapters. The domain model consists of simple classes to model a role-based schema:<span> </span><kbd>User</kbd><span>, </span>and<span> </span><kbd>Role</kbd>. It also includes the corresponding<span> </span><kbd>UserRepository</kbd><span> </span>and<span> </span><kbd>RoleRepository</kbd><span> </span>classes.</p>
<p>Let's start with the simplest of the classes, <kbd>Role</kbd>. The following is the full implementation of this class:</p>
<pre>@Entity<br/><strong>@Data<br/></strong><span>public class </span>Role {<br/><br/>    <span>@Id<br/></span><span>    @GeneratedValue<br/></span><span>    </span><span>private </span>Long <span>id</span><span>;<br/></span><span><br/></span><span>    private </span>String <span>name</span><span>;<br/></span><span><br/></span><span>    private </span>Boolean <span>module1Authorized</span><span>;<br/></span><span><br/></span><span>    private </span>Boolean <span>module2Authorized</span><span>;<br/></span><span><br/></span><span>    </span><span>@Override<br/></span><span>    </span><span>public </span>String <strong>toString</strong>() {<br/>        <span>return </span><strong>name</strong><span>;<br/></span><span>    </span>}<br/>}</pre>
<p>Besides the usual JPA configuration stuff (such as the<span> </span><kbd>@Entity</kbd>,<span> </span><kbd>@Id</kbd>, and<span> </span><kbd>@GeneratedValue</kbd><span> </span>annotations), the most interesting thing in this class is that there are no <kbd>getters</kbd> and <kbd>setters</kbd>. Nevertheless, <kbd>getters</kbd> and <kbd>setters</kbd> for each Java field in the class exist! This is thanks to<span> </span><em>Project Lombok</em>, a library that reduces the amount of boilerplate code needed in Java programs. Lombok generates code at the class level. In the previous class, we used the<span> </span><kbd>@Data</kbd><span> </span>annotation in order to tell Lombok to generate <kbd>getters</kbd> and <kbd>setters</kbd>, and<span> </span><kbd>toString</kbd>, <kbd>equals</kbd>, and<span> </span><kbd>hashCode</kbd><span> </span>methods. Since the<span> </span><kbd>toString</kbd><span> </span>method generated by Lombok doesn't fit our requirements, we override it and provided a custom one.</p>
<p>In order to use Lombok, you need to install it in your IDE, and add the dependency to the<span> </span><kbd>pom.xml</kbd><span> </span>file:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.projectlombok<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>lombok<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>1.16.18<span>&lt;/version&gt;<br/></span><span>    &lt;scope&gt;</span>provided<span>&lt;/scope&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<p>You can find installation instructions for IntelliJ IDEA, NetBeans, Eclipse, and other IDEs at: <a href="https://projectlombok.org">https://projectlombok.org</a>. After installing Lombok, you'll be able to use <kbd>autocomplete</kbd> and any other features of your IDE in order to use the generated code, even when you don't see it in the Java class. For example, the following screenshot shows <strong>IntelliJ IDEA</strong> suggesting the generated <kbd>getName</kbd><span> </span>method when using the autocomplete feature:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-208 image-border" src="assets/4cec7d32-4af6-48de-9fb3-8c93a3ded99a.png" style=""/></div>
<div class="packt_tip">You can use your own implementations for the <kbd>getters</kbd>, <kbd>setters</kbd>,<span> </span><kbd>equals</kbd>, and<span> </span><kbd>hashCode</kbd><span> </span>instead of using Lombok. Most IDEs, if not all of them have features to generate these methods at the source code level; however, Lombok source files become much shorter, making them easier to maintain in most cases.<span> </span><kbd>@Data</kbd><span> </span>is not the only useful annotation offered by Lombok. See the documentation at <a href="https://projectlombok.org">https://projectlombok.org</a><span> </span>for more information about its features.</div>
<p>The following is the implementation of the<span> </span><kbd>User</kbd><span> </span>class, which uses Lombok as well:</p>
<pre><span>@Entity<br/></span><span>@Data<br/></span><span>public class </span><strong>User</strong> {<br/><br/>    <span>@Id<br/></span><span>    @GeneratedValue<br/></span><span>    </span><span>private </span>Long <span>id</span><span>;<br/></span><span><br/></span><span>    </span><span>private </span>String <span>firstName</span><span>;<br/></span><span><br/></span><span>    </span><span>private </span>String <span>lastName</span><span>;<br/></span><span><br/></span><span>    </span><span>private </span>String <span>email</span><span>;<br/></span><span><br/></span>    <span>private </span>String <span>password</span><span>;<br/></span><span><br/></span><span>    private boolean </span><span>blocked</span><span>;<br/></span><span><br/></span><span>    </span><span><strong>@ManyToMany(fetch = FetchType.EAGER)</strong><br/></span>    <span>private </span>Set&lt;Role&gt; <span>roles</span><span>;<br/></span><span><br/></span><strong>    @ManyToOne<br/></strong><span>    </span><span>private </span>Role <span>mainRole</span><span>;</span><span><br/></span>}</pre>
<p>Notice the<span> </span><kbd>@ManyToMany</kbd><span> </span>annotation in the<span> </span><kbd>roles</kbd><span> </span>field. What's the difference between<span> </span><kbd>@ManyToMany</kbd><span> </span>and<span> </span><kbd>@OneToMany</kbd>? The<span> </span><kbd>-ToMany</kbd><span> </span>part means that every<span> </span><kbd>User</kbd><span> </span>can be associated with many<span> </span><kbd>Role</kbd> objects. The<span> </span><kbd>@Many-</kbd><span> </span>part means that every<span> </span><kbd>Role</kbd><span> </span>can have many<span> </span><kbd>User</kbd> instances. If<span> </span><kbd>@OneToMany</kbd><span> </span>was used, the<span> </span><kbd>@One-</kbd><span> </span>part would mean that every<span> </span><kbd>Role</kbd><span> </span>can be associated with only one<span> </span><kbd>User</kbd>, which is clearly not what we want in this model.</p>
<div class="packt_tip">Why does the<span> </span><kbd>@ManyToMany</kbd><span> </span>annotation specify <kbd>FetchType.EAGER</kbd><span> </span>for the fetch strategy? Hibernate uses<span> </span><kbd>Fetch.LAZY</kbd><span> </span>by default, which might cause a <kbd>LazyInitializationException</kbd>. <kbd>Lazy</kbd> fetch can be useful if you want to load the data when it is actually needed. This, however, requires an open Hibernate session when the collection is accessed. In a web environment, the session is usually closed after the request is handled. Since we need to show<span> </span><kbd>Role</kbd><span> </span>data in the views, the best approach is to eagerly fetch the data. A common practice in many applications is to use the<span> </span><em>Open Session in View</em><span> </span>pattern; however, this might as well be considered an anti-pattern. Always consider using DTO projections instead of the Open Session in the View pattern. For a more detailed discussion about this topic, visit <a href="https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern">https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern</a>.</div>
<p>The last part of the domain model is the repository classes. For the<span> </span><kbd>RoleRepository</kbd><span> </span>class, we only need a method to find all the<span> </span><kbd>Role</kbd> objects, and another to save a new one, as shown in the following snippet of code:</p>
<pre><span>public class </span>RoleRepository {<br/><br/>    <span>public static </span>List&lt;Role&gt; <span>findAll</span>() { ... }<br/><br/>    <span>public static </span>Role <span>save</span>(Role role) { ... }<br/>}</pre>
<p>And for completeness, the following are the methods in the <kbd>UserRepository</kbd><span> </span>class:</p>
<pre><span>public class </span>UserRepository {<br/><br/>    <span>public static </span>List&lt;User&gt; <span>findAll</span>() { ... }<br/><br/>    <span>public static </span>User <span>findById</span>(Long id) { ... }<br/><br/>    <span>private static </span>User <span>getById</span>(Long id<span>, </span>EntityManager em) { ... }<br/><br/>    <span>public static </span>User <span>save</span>(User user) { ... }<br/><br/>    <span>public static void </span><span>delete</span>(User user) { ... }<br/>}</pre>
<div class="packt_infobox"><span>The actual implementation of the methods is omitted here for simplicity, but you can find the complete source code of this chapter's example in the </span><kbd>Data-centric-Applications-with-Vaadin-8\chapter-07</kbd><span> Maven project of the source code that accompanies this book.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a CRUD using an editable Grid component</h1>
                </header>
            
            <article>
                
<p>In this section, we'll implement a component containing an editable<span> </span><kbd>Grid</kbd>. The following is a screenshot of the application showing the <kbd>Grid</kbd><span> </span>component in edit mode:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-209 image-border" src="assets/caefa9c4-cd6c-404b-aeac-ec0e398d1191.png" style=""/></div>
<p><span>For simplicity, in this example, we'll omit the </span><em>add</em><span> and the <em>delete</em> CRUD operations for now. </span>Let's start by creating a class to encapsulate the component as follows:</p>
<pre><span>public class </span>EditableGridCrud <span>extends </span>Composite {<br/><br/>    <span>private </span><strong>Grid&lt;User&gt; grid </strong>= <span>new </span>Grid&lt;&gt;()<span>;<br/></span><span><br/></span><span>    public </span><span>EditableGridCrud</span>() {<br/>        initLayout()<span>;<br/></span><span>        </span>initBehavior()<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>initLayout</span>() {<br/>        <span>grid</span>.setSizeFull()<span>;<br/></span><span>        </span>VerticalLayout layout = <span>new </span>VerticalLayout(<span>grid</span>)<span>;<br/></span><span><br/></span><span>        </span>setCompositionRoot(layout)<span>;<br/></span><span>        </span>setSizeFull()<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><strong>initBehavior()</strong> {<br/><span>    </span>}<br/>}</pre>
<p>The class, which extends<span> </span><kbd>Composite</kbd>, declares a<span> </span><kbd>Grid</kbd> to show<span> </span><kbd>User</kbd><span> </span>instances. There are several constructors available in the <kbd>Grid</kbd><span> </span>class:</p>
<ul>
<li><kbd>Grid()</kbd>: Creates a new<span> </span><kbd>Grid</kbd><span>, </span>without columns. Columns have to be manually added.</li>
<li><kbd>Grid(String caption)</kbd>: The same as<span> </span><kbd>Grid()</kbd><span>, </span>but sets a caption.</li>
<li><kbd>Grid(Class&lt;T&gt; beanType)</kbd>: Creates a new<span> </span><kbd>Grid</kbd><span> </span>and automatically creates columns for each property (having a <kbd>getter</kbd> and a <kbd>setter</kbd>) in the specified class. Columns can be retrieved by a name using the<span> </span><kbd>getColumn(String)</kbd><span> </span>method.</li>
<li><span><kbd>Grid(DataProvider&lt;T, ?&gt; dataProvider)</kbd>: Creates a new <kbd>Grid</kbd> without columns. It accepts a <kbd>DataProvider</kbd>, which is an abstraction to provide data from any kind of backend. You can implement this interface, or use the implementations available in the framework. If you are not familiar with data providers, refer to the official documentation at: <a href="https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html">https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html</a>.</span></li>
<li><kbd>Grid(String caption, DataProvider&lt;T, ?&gt; dataProvider)</kbd>: The same as<span> </span><kbd>Grid(DataProvider)</kbd><span>, </span>but sets a caption.</li>
<li><span><kbd>Grid(String caption, Collection&lt;T&gt; items)</kbd>: Creates a new <kbd>Grid</kbd> without columns, and sets a caption. The provided collection is used to fetch the data that is going to be rendered in the <kbd>Grid</kbd> (a <kbd>DataProvider</kbd> is used behind the scenes).</span></li>
</ul>
<p>At this point, we have a<span> </span><kbd>Grid</kbd><span> </span>component without columns and without rows (data).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the read operation</h1>
                </header>
            
            <article>
                
<p>The<span> </span><em>read</em> <span>CRUD operation</span><span> </span>can be thought of as the action of showing all the<span> </span><kbd>User</kbd> instances inside the<span> </span><kbd>Grid</kbd>.</p>
<p>Since the<span> </span><kbd>Grid</kbd><span> </span>doesn't have any columns at this point, adding rows to it won't make any difference, so let's start by adding columns. The easiest way to add columns to a<span> </span><kbd>Grid</kbd><span> </span>is<span> </span>by passing<span> </span>the type of the bean (<kbd>User</kbd>) to the<span> </span><kbd>Grid</kbd> constructor:</p>
<pre>Grid grid = new Grid(<strong>User.class</strong>);</pre>
<p>After this, we can add columns by using the property names in the bean. For example:</p>
<pre>grid.setColumns("firstName", "lastName");</pre>
<p>However, this is not type-safe. When manually adding columns to a<span> </span><kbd>Grid</kbd>, a better approach is not to use the <span><kbd>Grid(Class&lt;T&gt; beanType)</kbd> constructor, and instead use a <kbd>ValueProvider</kbd>. Let's do this in the example application:</span></p>
<pre><span>public class </span>EditableGridCrud <span>extends </span>Composite {<br/>    ...<br/><br/>    <span>private void </span><span>initBehavior</span>() {<br/><span>        </span><span>grid</span>.addColumn(User::getFirstName).setCaption("First name")<span>;<br/></span><span>        </span><span>grid</span>.addColumn(User::getLastName).setCaption("Last name")<span>;<br/></span><span>        </span><span>grid</span>.addColumn(User::getEmail).setCaption("Email")<span>;<br/></span><span>        </span><span>grid</span>.addColumn(User::getPassword).setCaption("Password")<span>;<br/></span><span>        </span><span>grid</span>.addColumn(User::isBlocked).setCaption("Blocked")<span>;<br/></span><span>    </span>}<br/> }</pre>
<p>This is a better approach, since it's completely type-safe. The<span> </span><kbd>addColumn</kbd><span> </span>method accepts a<span> </span><kbd>ValueProvider</kbd>, a functional interface compatible with any getter in the bean type. The<span> </span><kbd>addColumn</kbd><span> </span>method returns an instance of<span> </span><kbd>Grid.Column</kbd><span>, </span>from which we can configure any additional properties for it. In the previous snippet of code, we configured the column's caption. All the<span> </span><kbd>setXX</kbd><span> </span>methods return the same instance of<span> </span><kbd>Column</kbd>, which allows you to chain calls to further configure the column. For example, you can set the column's caption and width as follows:</p>
<pre><span>grid</span>.addColumn(User::getFirstName)<br/>    .<strong>setCaption</strong>("First name")<br/>    .<strong>setWidth</strong>(150)<span>;</span></pre>
<p>With the columns in place, we can now add rows to the<span> </span><kbd>Grid</kbd>. This is as simple as calling the<span> </span><kbd>setItems(Collection)</kbd><span> </span>method, and passing a<span> </span><kbd>Collection</kbd><span> </span>of<span> </span><kbd>User</kbd> instances. Since we will need to reload the content of the <kbd>Grid</kbd> after editing a row, it's a good idea to encapsulate the call to<span> </span><kbd>setItems</kbd><span> </span>as follows:</p>
<pre><span>public class </span>EditableGridCrud <span>extends </span>Composite {<br/>    ...<br/><br/><span>    public </span><span>EditableGridCrud</span>() {<br/>        initLayout()<span>;<br/></span><span>        </span>initBehavior()<span>;<br/></span><span>        </span><strong>refresh()</strong><span><strong>;</strong><br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>refresh</span>() {<br/>        <span>grid</span>.<strong>setItems(UserRepository.findAll())</strong><span>;<br/></span><span>    </span>}<br/>    ...<br/><br/>}</pre>
<p>There's a slight security problem at this point, and by "slight", I mean "major". Passwords are shown in plain text in the<span> </span><kbd>Grid</kbd>. We want to keep the<span> </span><span class="packt_screen">Password</span><span> </span>column, so that it plays nice with the<span> </span><kbd>Grid</kbd><span> </span>editor later, but we want to show a series of asterisks (<kbd>********</kbd>) instead of the actual passwords. This can be done through the <kbd>Renderer</kbd> interface. A<span> </span><kbd>Renderer</kbd><span> </span>is an extension that <em>draws</em> client-side representations of a value. We can use the provided<span> </span><kbd>TextRenderer</kbd><span> </span>implementation to change the text shown in the<span> </span><span class="packt_screen">Password</span><span> </span>column as follows:</p>
<pre><span>grid</span>.addColumn(User::getPassword)<br/>        .setCaption(<span>"Password"</span>)<br/>        <strong>.setRenderer(user -&gt; "********", new TextRenderer());</strong></pre>
<p>The<span> </span><kbd>setRenderer</kbd><span> </span>method accepts a<span> </span><kbd>ValueProvider</kbd><span> </span>and a<span> </span><kbd>Renderer</kbd>. Instead of returning<span> </span><kbd>user.getPassword()</kbd><span>, </span>we return the <kbd>"********"</kbd><span> </span>string, no matter what the value of the password is.<span> </span><kbd>TextRenderer</kbd><span> </span>will take the string, and<span> </span><em>draw</em><span> </span>it as text. There are many other<span> </span><kbd>Renderers</kbd><span> </span>that would take the value and draw it in many other forms; for example, as a<span> </span><kbd>Button</kbd><span> </span>or<span> </span><kbd>HTML</kbd>. The following figure shows the implementations included with the framework:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-210 image-border" src="assets/651f918f-6f97-4382-80fa-86657a9b8d0b.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the update operation</h1>
                </header>
            
            <article>
                
<p>The update CRUD operation is implemented through the<span> </span><kbd>Grid.Editor</kbd><span> </span>class. Enabling the editor is as easy as calling the following:</p>
<pre>grid.<strong>getEditor</strong>()<strong>.setEnabled</strong>(true);</pre>
<p>However, the<span> </span><kbd>Editor</kbd><span> </span>needs a way to know what kind of input component to use for each column, and also where to get the values for these input components, and how to set the values back in the bean once the user edits them. This is done with the help of two methods:<span> </span><kbd>Grid.Editor.getBinder</kbd><span> , </span>and<span> </span><kbd>Grid.Column.setEditorBinding</kbd>. You should be familiar with the<span> </span><kbd>Binder</kbd><span> </span>class in the Vaadin Framework; it is a utility class that allows you to connect <kbd>setters</kbd> and <kbd>getters</kbd> with input components, as well as<span> v</span>alidators,<span> c</span>onverters, and other configurations for<span> </span><em>data-binding</em>. You can get the<span> </span><kbd>Binder</kbd><span> </span>instance by calling the<span> </span><kbd>getBinder</kbd><span> </span>method:</p>
<pre><strong>Binder&lt;User&gt;</strong> binder = grid.getEditor().<strong>getBinder</strong>();</pre>
<div class="packt_infobox">The basic idea of the<span> </span><kbd>Binder</kbd><span> </span>class is that you can specify an input component and bind a getter and a setter:<br/>
<kbd>binder.bind(textField, User::getFirstName, User::setLastName);</kbd>.<br/>
<span>If you are not familiar with the </span><kbd>Binder</kbd><span> class, go through the must-read documentation at: </span><a href="https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html">https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html</a>.</div>
<p>With the<span> </span><kbd>Editor</kbd><span> </span>enabled, we can set an input component for each column. For example, we can use a<span> </span><kbd>TextField</kbd><span> </span>for the<span> </span><span class="packt_screen">First Name</span> column <span>using the <kbd>setEditorBinding</kbd> method </span>as follows:</p>
<pre><span>grid</span>.addColumn(User::getFirstName)<br/>        .setCaption(<span>"First Name"</span>)<br/>        .<strong>setEditorBinding</strong>(binder<br/>                .forField(<strong>new TextField()</strong>)<br/>                .bind(User::<strong>getFirstName</strong><span>, </span>User::<strong>setFirstName</strong>))<span>;<br/></span></pre>
<p>The<span> </span><kbd>setEditorBinding</kbd><span> </span>accepts a<span> </span><kbd>Binding</kbd><span> </span>instance that we can easily get from the<span> </span><kbd>binder</kbd>. We use the<span> </span><kbd>forField</kbd><span> </span>method in the<span> </span><kbd>Binder</kbd><span> </span>to specify a new<span> </span><kbd>TextField</kbd><span>, </span>and the<span> </span><kbd>bind</kbd><span> </span>method, which returns an instance of<span> </span><kbd>Binding</kbd>, to configure the corresponding <kbd>getter</kbd> and setter in the<span> </span><kbd>User</kbd><span> </span>bean. The end result is that when you double-click a row in the<span> </span><kbd>Grid</kbd>, the<span> </span><kbd>Editor</kbd><span> </span>will present a new<span> </span><kbd>TextField</kbd><span> </span>in the first name cell, which will set its value to what<span> </span><kbd>User::getFirstName</kbd><span> </span>returns, and will call <kbd>User::setFirstName</kbd>, passing the value in the<span> </span><kbd>TextField</kbd> <span>when you click the </span><span class="packt_screen">Save</span><span> button.</span></p>
<div class="packt_tip">Be careful when you set several editor bindings and copy/paste code. You might forget to change one of the three method references, which would result in strange behaviors, such as values not being updated or values being updated in wrong fields in the bean.</div>
<p>In order to persist the edited<span> </span><kbd>User</kbd><span> </span>instance, we need to add an<span> </span><kbd>EditorSaveListener</kbd>, which, conveniently, is a functional interface. We add this listener using the <kbd>addSaveListener</kbd> as follows:</p>
<pre>grid.getEditor().<strong>addSaveListener</strong>(e -&gt; <strong>save(e.getBean())</strong>);</pre>
<p>The<span> </span><kbd>save</kbd><span> </span>method can be simply implemented as follows:</p>
<pre><span>public class </span>EditableGridCrud <span>extends </span>Composite {<br/>    ...<br/><br/>    <span>private void </span><strong>save(User user)</strong> {<br/>        UserRepository.<span>save</span>(user)<span>;<br/></span><span>        </span>refresh()<span>;<br/></span><span>    </span>}<br/>    ...<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Bean Validation with JSR-303</h1>
                </header>
            
            <article>
                
<p>JSR-303 is the specification for <strong>Java Bean Validation</strong>. It makes it possible to use annotations such as<span> </span><kbd>@NotNull</kbd><span>, </span><kbd>@Email</kbd><span>, and </span><kbd>@Size</kbd><span> to indicate constraints in a Java Bean. Java Bean Validation is a specification and there are several implementations for it, two of the most popular ones being <strong>Hibernate Validation</strong> and <em>Apache Bean Validation</em>. Since we are already using Hibernate in this chapter's example, it makes sense to use Hibernate Validation as well. This is done by adding the <kbd>hibernate-validator</kbd> dependency in the <kbd>pom.xml</kbd> file:</span></p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span><strong>org.hibernate</strong><span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span><strong>hibernate-validator</strong><span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>6.0.2.Final<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<p>After this, we can use the annotations available in the<span> </span><kbd>javax.validation.constraints</kbd><span> </span>package in the<span> </span><kbd>User</kbd><span> </span>class. The following code adds<span> </span><em>not-null</em><span> </span>constraints to the<span> </span><kbd>firstName</kbd>,<span> </span><kbd>lastName</kbd>, and<span> </span><kbd>password</kbd><span> </span>fields, an<span> </span><em>email-format</em><span> </span>constraint to the<span> </span><kbd>email</kbd><span> </span>field, and a<span> </span><em>size</em><span> </span>(or length) constraint to the<span> </span><kbd>password</kbd><span> </span>field:</p>
<pre><span>...<br/>public class </span>User {<br/>    ...<br/><span><br/></span><strong>    @NotNull<br/></strong><span>    </span><span>private </span>String <span>firstName</span><span>;<br/></span><span><br/></span><span>    </span><span><strong>@NotNull</strong><br/></span><span>    </span><span>private </span>String <span>lastName</span><span>;<br/></span><span><br/></span><span>    </span><span><strong>@Email</strong><br/></span><span>    </span><span>private </span>String <span>email</span><span>;<br/></span><span><br/></span><span>    </span><span><strong>@NotNull</strong><br/></span><strong>    @Size(min = 8, max = 100)</strong><br/>    <span>private </span>String <span>password</span><span>;<br/></span><span><br/></span><span>    ...<br/></span>}</pre>
<p>In order to make it work with the<span> </span><kbd>Editor</kbd>, we need to add <kbd>BeanValidators</kbd><span> </span>to its<span> </span><kbd>Binder</kbd>. The following snippet of code shows how to add it to the<span> </span><span class="packt_screen">First Name</span> column:</p>
<pre><span>grid</span>.addColumn(User::getFirstName)<br/>        .setCaption(<span>"First Name"</span>)<br/>        .setEditorBinding(binder<br/>                .forField(<span>new </span>TextField())<br/><strong>                .withNullRepresentation("")</strong><br/><strong>                .withValidator(new BeanValidator(User.class, "firstName"))</strong><br/>                .bind(User::getFirstName<span>, </span>User::setFirstName))<span>;<br/></span></pre>
<p>Notice that we also called<span> </span><kbd>withNullRepresentation</kbd>. This allows us to use an empty <kbd>String</kbd> on the client side, and interpret them as null values on the server side. The<span> </span><kbd>BeanValidator</kbd><span> </span>implementation is provided by the framework, and will take care of running validations for each JavaBean Validation annotation in the<span> </span><kbd>User</kbd><span> </span>class.</p>
<div class="packt_tip">Unfortunately, you have to specify the name of the property as a <kbd>String</kbd> literal, which is not type-safe, and might lead to problems if you forget to update it when you refactor the name of the property. On the other hand, modern IDEs are capable of suggesting such changes when you use the tools for refactoring Java identifiers.</div>
<p>You can use the same approach to configure the<span> </span><kbd>Editor</kbd><span> </span>for the rest of the columns in the<span> </span><kbd>Grid</kbd>.</p>
<div class="packt_infobox"><span>As an exercise, try implementing the <kbd>add</kbd> operation by creating a button to add a new empty row. When the button is clicked, you can create and persist a new <kbd>User</kbd> (you will have to set default values for the <kbd>firstName</kbd>, <kbd>lastName</kbd>, and <kbd>password</kbd> fields of the <kbd>User</kbd> class), refresh the <kbd>Grid</kbd>, and open the editor for the new <kbd>User</kbd> using the </span><kbd>grid.getEditor().editRow(rowIndex)</kbd><span> method.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a CRUD using Grids and forms</h1>
                </header>
            
            <article>
                
<p>In this section, we'll develop a CRUD user interface using modal pop-up windows to show a form for adding and editing<span> </span><kbd>User</kbd><span> </span>instances. The following is a screenshot of the finished form:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-211 image-border" src="assets/d395e297-9851-40f4-9c87-9285f41a0285.png" style=""/></div>
<p>Let's start with the following component:</p>
<pre><span>public class </span>CustomCrud <span>extends </span>Composite {<br/><br/>    <span>private </span>Button <span>refresh </span>= <span>new </span>Button(<span>""</span><span>, </span><strong>VaadinIcons.REFRESH</strong>)<span>;<br/></span><span>    private </span>Button <span>add </span>= <span>new </span>Button(<span>""</span><span>, </span><strong>VaadinIcons.PLUS</strong>)<span>;<br/></span><span>    private </span>Button <span>edit </span>= <span>new </span>Button(<span>""</span><span>, </span><strong>VaadinIcons.PENCIL</strong>)<span>;<br/></span><span><br/></span><span>    private </span>Grid&lt;User&gt; <span>grid </span>= <span>new </span>Grid&lt;&gt;(<strong>User.class</strong>)<span>;</span><span><br/></span><span><br/></span><span>    public </span><span>CustomCrud</span>() {<br/>        initLayout()<span>;<br/></span><span>        </span>initBehavior()<span>;<br/></span><span>        </span>refresh()<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>initLayout</span>() {<br/>        <strong>CssLayout header</strong> = <span>new </span>CssLayout(<span>refresh</span><span>, </span><span>add</span><span>, </span><span>edit</span>)<span>;<br/></span><span>        </span>header.<strong>addStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP)</strong><span>;<br/></span><span><br/></span><span>        </span><span>grid</span>.setSizeFull()<span>;<br/></span><span><br/></span><span>        </span>VerticalLayout layout = <span>new </span>VerticalLayout(header<span>, </span><span>grid</span>)<span>;<br/></span><span>        </span>layout.setExpandRatio(<span>grid</span><span>, </span><span>1</span>)<span>;<br/></span><span>        </span>setCompositionRoot(layout)<span>;<br/></span><span>        </span>setSizeFull()<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>initBehavior</span>() {<br/>    }<br/><br/>    public void refresh() {<br/>    }<br/>}</pre>
<p>There are a few things to take notice of here. We are using the <kbd>Grid(Class&lt;T&gt; beanType)</kbd><span> </span>constructor, which means columns are created automatically, and we'll be able to reference them later by name. We are using the<span> </span><kbd>VaadinIcons</kbd><span> </span>class to set icons instead of text for the refresh (read), add, and update buttons. This class is included in the Vaadin Framework. Finally, we are using a<span> </span><kbd>CssLayout</kbd> with the<span> </span><kbd>LAYOUT_COMPONENT_GROUP</kbd><span> </span>style, which makes the buttons look like a toolbar. The following is a screenshot of the component at this point:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-212 image-border" src="assets/b8903e5b-b814-4ae9-80be-64cb58039c36.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the read operation</h1>
                </header>
            
            <article>
                
<p>We can start by configuring the columns we actually want to show in the<span> </span><kbd>Grid</kbd>. Since the columns were automatically created by the constructor, we can set their visibility by name using the<span> </span><kbd>setColumns</kbd><span> </span>method:</p>
<pre><span>...<br/>    private void initLayout() {<br/>        ...<br/>        grid</span>.setColumns(<span>"firstName"</span><span>, </span><span>"lastName"</span><span>, </span><span>"email"</span><span>, </span><span>"mainRole"</span>)<span>;<br/>        ...<br/>    }<br/>...</span></pre>
<p>In contrast to the previous editable<span> </span><kbd>Grid</kbd>, we don't need the<span> </span><em>Password</em><span> </span>column here, since we are not using an<span> </span><kbd>Editor</kbd>.</p>
<p>We can continue by adding a click listener to the<span> </span><kbd>refresh</kbd><span> </span>button, and implementing the<span> </span><kbd>refresh</kbd><span> </span>method. This is pretty straightforward:</p>
<pre>...<br/>    private void initBehavior() {<br/><strong>        grid.asSingleSelect().addValueChangeListener(e -&gt; updateHeader());</strong><br/><strong>        refresh.addClickListener(e -&gt; refresh());</strong><br/>    }<br/><br/>    public void refresh() {<br/><strong>        grid.setItems(UserRepository.findAll());<br/>        updateHeader();</strong><br/>    }<br/><br/>    private void <strong>updateHeader()</strong> {<br/>        boolean selected = !grid.asSingleSelect().isEmpty();<br/>        edit.setEnabled(selected);<br/>    }<br/>...</pre>
<p><span>We introduced a new </span><kbd>updateHeader</kbd><span> method to enable or disable the </span><kbd>edit</kbd><span> button depending on the selection state in the <kbd>Grid</kbd>. It makes sense to have the <kbd>edit</kbd> button enabled only when there's a row selected</span><span>. We need to call this method when we refresh the list and when the value selected in the <kbd>Grid</kbd> changes (see the <kbd>Grid.addValueChangeListener</kbd> method).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the create and update operations</h1>
                </header>
            
            <article>
                
<p>The<span> </span><em>create</em><span> </span>CRUD operation starts when the user clicks the<span> </span><kbd>add</kbd><span> </span>button. Similarly, the<span> </span><em>update</em><span> </span>CRUD operation starts when the user clicks the<span> </span><kbd>update</kbd><span> </span>button. We need the following <em>infrastructur</em><em>e</em><span> </span>code:</p>
<pre><span>...<br/>private void </span><span>initBehavior</span>() {<br/>    ...<span><br/></span><strong>    add.addClickListener(e -&gt; showAddWindow());<br/>    edit.addClickListener(e -&gt; showEditWindow());<br/></strong>}<br/><br/>private void <strong>showAddWindow</strong>() {<br/>    <strong>UserFormWindow</strong> window = new UserFormWindow("Add", <strong>new User()</strong>);<br/>    getUI().addWindow(window);<br/>}<br/><br/>private void <strong>showEditWindow</strong>() {<br/>    UserFormWindow window = new UserFormWindow("Edit", <strong>grid.asSingleSelect().getValue()</strong>);<br/>    getUI().addWindow(window);<br/>}<br/><br/></pre>
<p>When any of the buttons is clicked, we show a<span> </span><kbd>UserFormindow</kbd> (implemented shortly). For the<span> </span><kbd>add</kbd><span> </span>button, we pass a new<span> </span><kbd>User</kbd><span> </span>instance. For the<span> </span><kbd>update</kbd><span> </span>button, we pass the<span> </span><kbd>User</kbd><span> </span>instance selected in the<span> </span><kbd>Grid</kbd>. We can implement<span> </span><kbd>UserWindow</kbd> as an inner class inside<span> </span><kbd>CustomCrud</kbd>. We'll omit the details of the layout configuration, and focus on the data binding part. Let's start with the following:</p>
<pre><span>private class </span>UserFormWindow <span>extends </span>Window { // inner to CustomCrud<br/><br/>    <span>private </span>TextField <strong>firstName </strong>= <span>new </span>TextField(<span>"First name"</span>)<span>;<br/></span><span>    private </span>TextField <strong>lastName </strong>= <span>new </span>TextField(<span>"Last name"</span>)<span>;<br/></span><span>    private </span>TextField <strong>email </strong>= <span>new </span>TextField(<span>"Email"</span>)<span>;<br/></span><span>    private </span>PasswordField <strong>password </strong>= <span>new </span>PasswordField(<span>"Password"</span>)<span>;<br/></span><span>    private </span>CheckBoxGroup&lt;Role&gt; <strong>roles </strong>= <span>new </span>CheckBoxGroup&lt;&gt;(<span>"Roles"</span><span>, </span><strong>RoleRepository.findAll()</strong>)<span>;<br/></span><span>    private </span>ComboBox&lt;Role&gt; <strong>mainRole </strong>= <span>new </span>ComboBox&lt;&gt;(<span>"Main Role"</span><span>, </span><strong>RoleRepository.findAll()</strong>)<span>;<br/></span><span>    private </span>CheckBox <strong>blocked </strong>= <span>new </span>CheckBox(<span>"Blocked"</span>)<span>;<br/></span><span><br/></span><span>    private </span>Button <span>cancel </span>= <span>new </span>Button(<span>"Cancel"</span>)<span>;<br/></span><span>    private </span>Button <span>save </span>= <span>new </span>Button(<span>"Save"</span><span>, </span>VaadinIcons.<span>CHECK</span>)<span>;<br/></span><span><br/></span><span>    public </span><span>UserFormWindow</span>(String caption<span>, </span>User user) {<br/>        initLayout(caption)<span>;<br/></span><span>        </span>initBehavior(user)<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>initLayout</span>(String caption) {<br/>        ...<br/><span>    </span>}<br/><br/>    <span>private void </span><span>initBehavior</span>(User user) {<br/><span>    </span>}<br/>}</pre>
<p>All the input fields in the form are members of the<span> </span><kbd>UserFormWindow</kbd><span> </span>class, and are added to some sort of layout in the<span> </span><kbd>initLayout</kbd><span> </span>method (not shown). The<span> </span><kbd>initBehaviour</kbd><span> </span>method should configure the data binding between the<span> </span><kbd>User</kbd><span> </span>instance and the input fields. It also should add behavior to the<span> </span><kbd>cancel</kbd><span> </span>and<span> </span><kbd>save</kbd><span> </span>buttons. Let's think about what's required before we start coding:</p>
<ul>
<li>We need data-binding. In the Vaadin Framework, that usually means using a<span> </span><kbd>Binder</kbd>.</li>
<li>We need to bind the fields in the<span> </span><kbd>UserFormWindow</kbd><span> </span>class to the fields in the<span> </span><kbd>User</kbd><span> </span>class.</li>
<li>We need to make sure that the input fields show the correct values initially.</li>
<li>We need to make sure that the values in the input fields are written in the<span> </span><kbd>User</kbd><span> </span>instance when the<span> </span><span class="packt_screen">save</span><span> </span>button is clicked.</li>
<li>We need to make sure no values are written in the<span> </span><kbd>User</kbd><span> </span>instance when the<span> </span><span class="packt_screen">cancel</span><span> </span>button is clicked.</li>
</ul>
<p>Now, we can start coding:</p>
<pre><span>private void </span><span>initBehavior</span>(User user) { // inside UserFormWindow<br/>    Binder&lt;User&gt; binder = <strong>new Binder&lt;&gt;(User.class)</strong><span>;<br/></span><span>    </span>binder.<strong>bindInstanceFields(this)</strong><span>;<br/></span><span>    </span>binder.<strong>readBean(user)</strong><span>;</span><span><br/></span>}</pre>
<p>Two important things happen in the previous code: one) all the Java fields that are also input fields in the<span> </span><kbd>UserFormWindow</kbd><span> </span>class are bound to the Java fields in the<span> </span><kbd>User</kbd><span> </span>class (with the <kbd>bindIntanceFields</kbd><span> </span>call); and two), all the values in the Java fields of the <kbd>User</kbd> class are set to the corresponding input fields in the<span> </span><kbd>UserFormWindow</kbd><span> </span>class (with the<span> </span><kbd>readBean</kbd><span> </span>call).</p>
<p>Finally, the following code adds the behavior to the buttons:</p>
<pre><span>private void </span><span>initBehavior</span>(User user) { // inside UserFormWindow<br/><span>    ...<br/><br/>    </span><span>cancel</span>.addClickListener(e -&gt; <strong>close()</strong>)<span>;<br/></span><span>    </span><span>save</span>.addClickListener(e -&gt; {<br/>        <span>try </span>{<br/><span>            </span><strong>binder.writeBean(user)</strong><span><strong>;</strong><br/></span><span>            </span>UserRepository.<span>save</span>(<span>user</span>)<span>;<br/></span><span>            </span>close()<span>;<br/></span><span>            </span>refresh()<span>;<br/></span><span>            </span>Notification.<span>show</span>(<span>"User saved"</span>)<span>;<br/></span><span><br/></span><span>        </span>} <span>catch </span>(<strong>ValidationException</strong> ex) {<br/>            Notification.<span>show</span>(<span>"Please fix the errors and try again"</span>)<span>;<br/></span><span>        </span>}<br/>    })<span>;<br/></span>}</pre>
<p>The listener on the <kbd>cancel</kbd><span> </span>button only has to call <kbd>Window.close()</kbd><span> </span>(inherited). The listener on the <kbd>save</kbd><span> </span>button calls<span> </span><kbd>writeBean</kbd><span> </span>in order to write the values in the input fields in the<span> </span><kbd>user</kbd><span> </span>instance.</p>
<p>Notice that<span> </span><kbd>writeBean</kbd><span> </span>throws a<span> </span><kbd>ValidationException</kbd>. There are no validations at the moment, though. Adding the JavaBean Validation constraints we have in the<span> </span><kbd>User</kbd><span> </span>class is as simple as changing the<span> </span><kbd>Binder</kbd><span> </span>implementation:</p>
<pre><span>private void </span><span>initBehavior</span>(User user) { // inside UserFormWindow<br/>    <strong>BeanValidationBinder</strong>&lt;User&gt; binder = new <strong>BeanValidationBinder</strong>&lt;&gt;(User.class);<span><br/>    ...<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the delete operation</h1>
                </header>
            
            <article>
                
<p>Let's implement the<span> </span><em>delete</em><span> </span>CRUD operation using a different approach. Instead of simply adding one single button for the operation, we'll add a delete button on each row in the<span> </span><kbd>Grid</kbd>. The simplest way of adding a UI component inside a<span> </span><kbd>Grid</kbd><span> </span>is by using the<span> </span><kbd>addComponentColumn</kbd><span> </span>method:</p>
<pre><span>public class </span>CustomCrud <span>extends </span>Composite {<br/>    ...<br/><br/>    <span>private void </span><span>initLayout</span>() {<br/>        ...<br/><span><br/>        </span><span>grid</span>.<strong>addComponentColumn</strong>(user -&gt; <span>new </span>Button(<span>"Delete"</span><span>, </span>e -&gt; <strong>deleteClicked</strong>(<span>user</span>)))<span>;<br/>        ...<br/></span><span>    </span>}<br/>    ...<br/><br/>    <span>private void </span><strong>deleteClicked</strong>(User user) {<br/>        <strong>showRemoveWindow</strong>(user)<span>;<br/></span><span>        </span>refresh()<span>;<br/></span><span>    </span>}<br/><br/>    private void <strong>showRemoveWindow</strong>(User user) {<br/>        Window window = new <strong>RemoveWindow</strong>(user);<br/>        window.setModal(true);<br/>        window.center();<br/>        getUI().addWindow(window);<br/>    }<br/>}</pre>
<p>The<span> </span><kbd>addComponentColumn</kbd><span> </span>method accepts a<span> </span><kbd>ValueProvider</kbd><span> </span>used to get a UI component. The constructor used to create the <kbd>Button</kbd><span> </span>accepts a click listener that, in turn, calls the <kbd>showRemoveWindow</kbd><span> </span>method, passing the<span> </span><kbd>User</kbd><span> </span>instance corresponding to the row where the button resides. The actual implementation of the<span> </span><kbd>RemoveWindow</kbd><span> </span>class is left as an exercise.</p>
<div class="packt_tip">The<span> </span><kbd>addComponentColumn</kbd><span> </span>method is a shortcut to<span> </span><kbd>addColumn(user -&gt; new Button("Delete", e -&gt; deleteClicked(user)), new ComponentRenderer())</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Crud UI add-on</h1>
                </header>
            
            <article>
                
<p>Thanks to its open source nature, there are hundreds of third-party components and utilities published available at: <a href="https://vaadin.com/directory">https://vaadin.com/directory</a>. One of them does almost all the work we have done in this chapter. The following class shows how to implement a CRUD user interface using the<span> </span><kbd>Crud UI add-on</kbd><span> </span>available at <a href="https://vaadin.com/directory/component/crud-ui-add-on">https://vaadin.com/directory/component/crud-ui-add-on</a><span>, which is </span>maintained by the author of this book:</p>
<pre><span>public class </span>CrudAddOn <span>extends </span>Composite {<br/><br/>    <span>private </span>GridCrud&lt;User&gt; <span>crud </span>= <span>new </span><strong>GridCrud</strong>&lt;&gt;(<strong>User.</strong><span><strong>class</strong>, new </span><strong>HorizontalSplitCrudLayout</strong>())<span>;<br/></span><span><br/></span><span>    public </span><span>CrudAddOn</span>() {<br/>        initLayout()<span>;<br/></span><span>        </span>initBehavior()<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>initLayout</span>() {<br/>        <span>crud</span>.getGrid().<strong>setColumns</strong>(<span>"firstName"</span><span>, </span><span>"lastName"</span><span>, </span><span>"email"</span><span>, </span><span>"mainRole"</span>)<span>;<br/></span><span>        </span><span>crud</span>.<strong>getCrudFormFactory().setVisibleProperties</strong>(<span>"firstName"</span><span>, </span><span>"lastName"</span><span>, </span><span>"email"</span><span>, </span><span>"password"</span><span>, </span><span>"roles"</span><span>, </span><span>"mainRole"</span><span>, </span><span>"blocked"</span>)<span>;<br/></span><span><br/></span><span>        </span><span>crud</span>.getCrudFormFactory().<strong>setFieldType</strong>(<span>"password"</span><span>, </span>PasswordField.<span>class</span>)<span>;<br/></span><span>        </span><span>crud</span>.getCrudFormFactory().<strong>setFieldProvider</strong>(<span>"roles"</span><span>, new </span>CheckBoxGroupProvider&lt;&gt;(RoleRepository.<span>findAll</span>()))<span>;<br/></span><span>        </span><span>crud</span>.getCrudFormFactory().setFieldProvider(<span>"mainRole"</span><span>, new </span>ComboBoxProvider&lt;&gt;(<span>"Main Role"</span><span>, </span>RoleRepository.<span>findAll</span>()))<span>;<br/></span><span><br/></span><span>        </span>VerticalLayout layout = <span>new </span>VerticalLayout(<span>crud</span>)<span>;<br/></span><span>        </span>setCompositionRoot(layout)<span>;<br/></span><span>        </span>setSizeFull()<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>initBehavior</span>() {<br/>        <span>crud</span>.<strong>setFindAllOperation</strong>(() -&gt; UserRepository.<span>findAll</span>())<span>;<br/></span><span>        </span><span>crud</span>.<strong>setAddOperation</strong>(user -&gt; UserRepository.<span>save</span>(user))<span>;<br/></span><span>        </span><span>crud</span>.<strong>setUpdateOperation</strong>(user -&gt; UserRepository.<span>save</span>(user))<span>;<br/></span><span>        </span><span>crud</span>.<strong>setDeleteOperation</strong>(user -&gt; UserRepository.<span>delete</span>(user))<span>;<br/></span><span>        </span><span>crud</span>.<strong>getCrudFormFactory</strong>().setUseBeanValidation(<span>true</span>)<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>The add-on offers several configuration options, such as the possibility to configure a layout, set field providers, and use JavaBean Validation. It also delegates the CRUD operations to your own code, allowing you to use any kind of Java backend technology. The following is a screenshot of the CRUD component created with the Crud UI add-on:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-213 image-border" src="assets/09d24af9-0ffb-409c-bc9d-cfffc25b8d59.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering</h1>
                </header>
            
            <article>
                
<p>Filtering can be implemented by adding UI components such as a<span> </span><kbd>TextField</kbd> and a<span> </span><kbd>ComoboBox</kbd> with value listeners on them. When the user changes the filtering components, the value listeners update the data<span> </span>by passing<span> </span>their values to the backend and updating the view accordingly. For example, in order to filter by<span> </span>last<span> </span>name, the<span> </span><kbd>UserRepository.findAll</kbd><span> </span>method should accept a string with the value to match:</p>
<pre><span>public class </span>UserRepository {<br/><br/>    public static List&lt;User&gt; findAll(<strong>String lastName</strong>) {<br/>        return JPAService.runInTransaction(em -&gt;<br/>                em.createQuery("select u from User u <strong>where u.lastName like :lastName</strong>")<br/>                        .setParameter("<strong>lastName</strong>", <strong>lastName</strong>)<br/>                        .getResultList()<br/>        );<br/>    }<br/>    ...<br/>}</pre>
<div class="packt_infobox">Always keep in mind that <kbd>findAll</kbd> methods are useful and safe to use when they return a small number of results. When this is not the case, you should add <em>lazy loading</em> capabilities like the ones discussed in <a href="a297744e-ca27-423b-96a2-b28326405871.xhtml" target="_blank">Chapter 9</a>, <em>Lazy Loading</em>.</div>
<p>Assuming there is a<span> </span><kbd>lastNameFilter</kbd><span> </span>input component (of type<span> </span><kbd>TextField</kbd>, for example), the <kbd>Grid</kbd> should be populated using the new method, and passing the value in the filter:</p>
<pre>grid.setItems(UserRepository.findAll(<strong>lastNameFilter.getValue()</strong>));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to implement <em>generic</em><span> </span>CRUD user interfaces. We studied three different UI designs for CRUD user interfaces: i<span>n-place fields, modal pop-up windows, and hierarchical menus. We learned about Project Lombok, which allows us to reduce the amount of boilerplate code needed in Java programs, and we implemented a domain model using JPA and JavaBean Validation constraints. We also covered data binding with the <kbd>Binder</kbd> class, <kbd>Grid</kbd> renderers, and filtering.</span></p>
<p>In the next chapter, we'll explore another interesting topic that is useful in many business applications: generating and visualizing reports.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>