<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module Design Patterns and Strategies</h1>
                
            
            <article>
                
<p class="calibre2">In the previous few chapters, we did a deep dive into several modularity features in Java 9 that enable you to build Java applications with modules. You've learned how to use the dependency declarations and services to establish module dependencies. You've also learned how to use jlink to build modular runtimes that can be distributed. In this chapter, we'll look at a slightly less objective concern--how to build good applications with modules in Java. Now that you've acquired the knowledge to create and use modules, what are the recommended ways to do that? What are the best practices and patterns that you should use? Here's what we'll cover in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">Understanding how to design modules--what a module should ideally be and where module boundaries should be drawn</li>
<li class="calibre15">Understanding how to design good APIs for those modules</li>
<li class="calibre15">Learning about several best practices to create modules, as well as patterns, to use the module system effectively</li>
</ul>
<p class="calibre2">Many of the patterns discussed in this chapter come with usable code examples, available in the folderÂ <kbd class="calibre12">09-module-patterns</kbd>. Each example has been carefully crafted to help explain the pattern being discussed with minimal information overhead. Feel free to use and experiment with these code examples as you explore these patterns. Also, remember to revisit this chapter during your Java 9 modularity journey to brush up your knowledge of these patterns. It's often the case that rereading and thinking about design patterns at any time offers new perspectives to the challenges you have going on at that time.</p>
<p class="calibre2">Let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designing modules</h1>
                
            
            <article>
                
<p class="calibre2">Over the years, the first step in designing a Java application has usually involved the design of the packages and classes, as well as the interactions between them. It also perhaps involved designing some shared libraries. For instance, you'd move reusable code into a separate project and bundle it into your application as a JAR file. With Java 9 modules, you now have a new aspect to consider that significantly impacts the design process. Irrespective of whether you are creating a new application from scratch or you are migrating an existing classpath application into a modular application, there are some common questions you'll need to answer--How do you come up with a modular design? How do you choose what a module should be? How much code and functionality should be in a module? Where do you draw module boundaries in specific scenarios? For example, a question you might often run into is--Given a functionality or a set of classes and packages, should they belong to <em class="calibre22">Module A</em> or <em class="calibre22">Module B</em>? And how do you achieve good design principles for modules such as reusability, extensibility and maintainability?</p>
<p class="calibre2">As with most software design challenges, there are no right answers that apply for all scenarios. In fact, some of the -ility factors pull against each other, and most designs involve making a calculated trade-off. However, having some guidelines and best practices should get us started with tackling these challenges that can then be refined and tweaked as per specific use cases.</p>
<p class="calibre2">Among the first steps in designing and building a modular application, it helps to have a high level idea of what the modules and APIs will be. For simple projects, it can be tempting to just fire off the IDE and start coding. But for anything serious, it helps to spend some time and design a rough picture of the modules involved, their public APIs and their dependencies on each other before you start coding. Let's start looking at some principles and factors to keep in mind when designing modules and deciding what it should do.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scoping</h1>
                
            
            <article>
                
<p class="calibre2">Perhaps the most obvious way of deciding what makes a module is based on what it is about. In other words, its <em class="calibre22">scope</em>. If you were to break down any reasonably complex application, you'd immediately come up with high level functional areas that begin to separate out from each other. For instance, a banking application might have account related functionality that's separate from credit functionality and so on. In the case of existing Java applications, these different concerns might already be under different top-level packages. In the case of new applications, the various aspects of the business problem can give us clues. Distinct business areas stand out to form an initial high level classification, which can then perhaps be broken down into further chunks. So, in our banking example, account functionality might be split into savings and checking account functionality, account transfer related code, bill pay, and so on. This way of using the business concern to break down the application problem domain is a good strategy to get to smaller units that can then be good candidates for modules. You'll likely have to go through several levels of breaking down the scope until you arrive at a level where each unit feels like they could be separate modules.</p>
<p class="calibre2">Note that, while this is a good strategy to start breaking the problem in a top-down manner, it doesn't help you decide when to stop breaking things down! How do you know if your modules are too big? Or too fragmented? You'll have to look at other factors in this section to help make that decision.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Team structure</h1>
                
            
            <article>
                
<p class="calibre2">There's a popular adage in software design called <strong class="calibre1">Conway's Law</strong>, which suggests that the design of software in any organization is influenced by the structure of teams in the organization and the way they communicate with each other. It makes perfect sense if you think about it. Software development teams often tend to work on isolated libraries and code bases (or at least, code <em class="calibre22">areas</em>) that <em class="calibre22">talk</em> to other libraries and code bases developed by other teams. In a sense, there's almost a one-to-one mapping between teams and the set of code assets they work on. This can be a valuable factor that influences where module boundaries are drawn and how modules designs begin to separate from one another. Each team works on one or more modules, and so all the code that a given team would work on becomes a part of their set of modules.</p>
<p class="calibre2">This is useful for a variety of reasons. Teams can work on their code and ship out functionality independent of other teams. They are assigned <em class="calibre22">ownership</em> of modules, so they can handle bug fixes or code maintenance. Additionally, when starting out a new project, when two teams need to work on modules where one depends on the other, both teams can together come up with an <em class="calibre22">API contract</em> that they agree with. Then, each team can work on their modules separately and in parallel, although the dependent modules are not yet available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reusability</h1>
                
            
            <article>
                
<p class="calibre2">One of the tenets of modularity is reusability. We earlier used the analogy of building blocks to describe modules. The idea of plugging in reusable modules together to create different applications is very powerful indeed! In order to make modules reusable, they should ideally have the following characteristics:</p>
<ul class="calibre14">
<li class="calibre15">They should have some specialized and limited responsibility. A module that does too many things is hard to reuse effectively.</li>
<li class="calibre15">They should be independent--If a module depends on a whole lot of other modules to function, it becomes harder to reuse the module itself.</li>
<li class="calibre15">It should be configurable--If the module is tweak-able and can be made to work for different use cases, it makes the module more amenable to reuse.</li>
</ul>
<p class="calibre2">These characteristics do come with some trade-offs though! Here are a couple of them:</p>
<ul class="calibre14">
<li class="calibre15">Having smaller <em class="calibre22">specialized</em> or <em class="calibre22">single purpose</em> modules sometimes results in very small and fragmented modules, often requiring multiple modules to get anything done.</li>
<li class="calibre15">Configurable APIs in modules often results in more complicated APIs, since the consumers have to deal with more knobs and levers to tweak and operate in order to work with your module. One way to get around this problem is to provide sensible defaults and provide configuration just as an override.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modularizing by concerns</h1>
                
            
            <article>
                
<p class="calibre2">When designing modules, it'll be quickly apparent to you that not all modules are alike. Modules can be classified into multiple different types depending on various characteristics. One such classification can be achieved by their functionality or the concerns they address. At the highest level, you can classify modules into two different types:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Vertical concerns</strong>: Business and application specific functionality. Solves a specific problem in the business domain. For example, the accounts module in a banking application.</li>
<li class="calibre15"><strong class="calibre1">Horizontal concerns</strong>: Crosscutting functionalities that are not business or application specific. Instead, they provide low level functionality or framework that's business-agnostic. For example, logging or security modules.</li>
</ul>
<p class="calibre2">When designing modules, a good rule to try and follow is to not mix these two concerns. If you design modules specifically for one of the two concerns, it improves clarity and reuse. For example, in the address book application, the module <kbd class="calibre12">packt.sortutil</kbd> provided generic sorting ability while being completely agnostic of what it's sorting, thereby addresses a horizontal concern. The module <kbd class="calibre12">packt.addressbook</kbd> deals with specific address book application functionality, thereby addressing a vertical concern.</p>
<p class="calibre2">As you can imagine, the type of module influences its design. For instance, reusability wouldn't likely be a primary focus when designing a module addressing a vertical concern, but it's vital when designing a module with cross-cutting concerns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modularizing by layers</h1>
                
            
            <article>
                
<p class="calibre2">Another useful factor that can help us draw module boundaries is application layers. A typical application involves layers or tiers of functionality like the UI layer, business layer, data layer, and so on. That's a great way to draw some initial module boundaries before then looking at other categories to modularize further. A module should ideally not be a part of multiple application tiers. Sometimes, different tiers are deployed on different physical hardware. So, having tier separations guide module boundaries make logistical sense as well when it comes to deployments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modularizing by change patterns</h1>
                
            
            <article>
                
<p class="calibre2">An approach that I've found helpful to verify module boundaries is analyzing patterns of new feature additions to your application. If most of the typical changes you make to your code base involves having to modify multiple modules, that might be a clue that your modules are too fragmented or the separation of modules could be better. It's OK if you are modifying multiple low-level modules (that is, with horizontal concerns) for an average code change or enhancement. But if each change or enhancement to your application requires you to modify too many modules with vertical concerns, you might want to re-look at the module boundaries and see if those different modules contain code that should ideally be together in the same module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designing API</h1>
                
            
            <article>
                
<p class="calibre2">We've looked at some guidelines and tips for drawing module boundaries and creating modules. How about the process of creating APIs? This might seem obvious, but the standard best practice of a separate public API and private implementation still applies here.</p>
<p class="calibre2">The goal when designing the module API is to expose a standard, consistent, and possibly unchanging programming interface as the <strong class="calibre1">public</strong> API of the module. The details of implementation that are internal to the module should be encapsulated. This is, in principle, no different from method and member variable encapsulation for classes. Design a public API for your modules that you want the consumers to work with. The implementation details are hidden in encapsulated packages and serve two purposes:</p>
<ul class="calibre14">
<li class="calibre15">To reduce and simplify effort for the consumer so that they don't have to know the internals</li>
<li class="calibre15">To allow the module to change and evolve the implementation without having an impact on the consumers of the module</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java modules coding patterns and strategies</h1>
                
            
            <article>
                
<p class="calibre2">We've so far looked at some general higher level, almost common-sensical patterns, that apply to modularity in Java. Now let's dive into code. Let's look at some code patterns and strategies that can help you as you as you start designing modules and their APIs. Each of these strategies are presented with explanation about the pattern, why and when you should consider using them. Many of them have accompanying code examples for you to refer to. Some of these might be obvious. In fact, we've even applied some of the patterns when building the sample address book application we've worked on in this book. I hope this consolidated list provides you with a good reference to these patterns when designing and building modular applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 1 - Public interface, private implementation, and factory class</h1>
                
            
            <article>
                
<p class="calibre2">Separate the public API from the internal encapsulated implementation (we've already seen this strategy implemented in the sorting utility module of the address book viewer application earlier in the book). Also, expose a factory API method that creates new instances of the interface.</p>
<p class="calibre2">Here's how it works:</p>
<ul class="calibre14">
<li class="calibre15">The exported types are interfaces or abstract classes that are as lightweight as possible.</li>
<li class="calibre15">The classes that contain the actual logic implement the interfaces in the exported packages. These types are not exported. Thus, all the implementation details are safely hidden away.</li>
<li class="calibre15">There are factory classes in the exposed packages that form the APIs. These create a new instance of the right implementation class. The return types of these factory APIs deal with interfaces only.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example</h1>
                
            
            <article>
                
<p class="calibre2">A sample implementation of this pattern is available in the folderÂ <kbd class="calibre12">09-module-patterns/01-seperate-interface-impl</kbd>. The module <kbd class="calibre12">pattern.one</kbd> has the interface <kbd class="calibre12">PublicInterface</kbd> exposed in the <kbd class="calibre12">pattern.one.external</kbd> package, while the implementation classes <kbd class="calibre12">PrivateImplA</kbd> and <kbd class="calibre12">PrivateImplB</kbd> are in the encapsulated <kbd class="calibre12">pattern.one.internal</kbd> package:</p>
<pre class="calibre23">    module pattern.one { 
      exports pattern.one.external; 
    } </pre>
<p class="calibre2">We'd like the consuming modules to access the private instances through the public interface type. To facilitate this, there's a factory class <kbd class="calibre12">Factory</kbd> exposed by the module. This class has a public method <kbd class="calibre12">getApiInstance</kbd> that takes in an argument and then based on the value, returns the right implementation class. In the sample code, there's a simple <kbd class="calibre12">boolean</kbd> flag that affects whether one implementation instance is returned over another, but in a real-world module, this selection criteria would be more meaningful to what's returned, as this is how the consumer picks the right API instance based on their requirements. The return type of the factory method is an instance of the public interface. Thus, the consumer module doesn't know about the implementation details:</p>
<pre class="calibre23">    public class Factory { 
      public PublicInterface getApiInstance(boolean selector) { 
        if (selector) { 
          return new PrivateImplA(); 
        } 
        return new PrivateImplB(); 
      } 
    } </pre>
<p class="calibre2">Benefits:</p>
<ul class="calibre14">
<li class="calibre15">Hides the details from the consumer so that they don't have to know the internals</li>
<li class="calibre15">Allows you to change the implementation or add new implementation types without the consumers having to change the way they interact with the module</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 2 - Services for multiple dynamic implementations</h1>
                
            
            <article>
                
<p class="calibre2">An alternative way to abstract implementation types is to use them as services. This is an extension of the previous pattern, but while ensuring more loosely coupled and dynamic implementations.</p>
<p class="calibre2">Here's how it works:</p>
<ul class="calibre14">
<li class="calibre15">There's a service interface module that exposes the service interface type.</li>
<li class="calibre15">One or more <em class="calibre22">service</em> implementation modules provide implementations for that service using the <kbd class="calibre12">provides</kbd> clause in the module definition.</li>
<li class="calibre15">The consumer module does not directly depend on the implementation modules. It <kbd class="calibre12">requires</kbd> only the service interface module and declares that it <kbd class="calibre12">uses</kbd> the service.</li>
<li class="calibre15">Code in the consumer module looks up service instances using the <kbd class="calibre12">ServiceLoader</kbd> API.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example</h1>
                
            
            <article>
                
<p class="calibre2">The sample code implementation is available atÂ  <kbd class="calibre12">09-module-patterns/02-services</kbd>. The <kbd class="calibre12">pattern.two.service</kbd> module exports the <kbd class="calibre12">PublicInterface</kbd>. It doesn't contain any implementation classes of its own:</p>
<pre class="calibre23">    module pattern.two.service { 
      exports pattern.two.external; 
    } </pre>
<p class="calibre2">Two implementation modules <kbd class="calibre12">pattern.two.implA</kbd> and <kbd class="calibre12">pattern.two.implB</kbd> both contain implementations of the service that are declared using <kbd class="calibre12">provides</kbd> in the module declaration. Both implementation modules <kbd class="calibre12">require</kbd> the service module <kbd class="calibre12">pattern.two.service</kbd> to access the interface. Here's how the module definition for one of the implementation modules looks like:</p>
<pre class="calibre23">    module pattern.two.implA { 
      requires pattern.two.service; 
      provides pattern.two.external.PublicInterface with <br class="title-page-name"/>       pattern.two.implA.ImplA; 
    } </pre>
<p class="calibre2">The consumer module also depends on the service interface module, and <em class="calibre22">not</em> on the implementation modules. The <kbd class="calibre12">uses</kbd> clause in the module definition indicates that the module will need to look up the service:</p>
<pre class="calibre23">    module consumer { 
      requires pattern.two.service; 
      uses pattern.two.external.PublicInterface; 
    } </pre>
<p class="calibre2">Benefits:</p>
<ul class="calibre14">
<li class="calibre15">Provides an additional layer of abstraction between the service consumer and provider logic.</li>
<li class="calibre15">Completely loose coupling between consumer and implementation modules. There's no hard-wired <kbd class="calibre12">requires</kbd> dependency on the implementation modules.</li>
<li class="calibre15">Flexibility in the implementation options available. Modules can be dropped in the module path at runtime, and as long as they implement and provide the service interface, they can be plugged in to the application.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 3 - Optional dependencies</h1>
                
            
            <article>
                
<p class="calibre2">We've seen how Java did not have an option for reliable configuration up until Java 9. You could add or remove certain classes and JARs from the classpath before running and the application would still execute (or at least, starts executing)! There are some utility libraries and frameworks in Java that have made good use of this flexibility.</p>
<p class="calibre2">Consider the Spring Framework. Spring is a popular application framework that uses and orchestrates functionality across a lot of other dependent libraries and frameworks by scanning the classpath for available libraries that it can work with. If you'd like Spring to use some of these supported libraries, just dropping certain necessary jars into the classpath is enough for Spring to pick it up and use its functionality. And if you don't, the Spring framework can still function without them, albeit without the optional functionality.</p>
<p class="calibre2">This flexibility plays an important role in the ease of use of these frameworks. Now, with Java 9 and strict requirements for module dependencies, wouldn't we be losing this flexibility? There's no optionally dropping jars into the classpath anymore! Things are much more strict and controlled now. Every module that a given module needs should be explicitly specified with a <kbd class="calibre12">requires</kbd> clause in the module definition. Given this new state of affairs, how could you build such modules that are optional and with <em class="calibre22">drop-in</em> flexibility?</p>
<p class="calibre2">The answer is optional dependencies. In Java 9, you can specify a given module dependency as optional by using the <kbd class="calibre12">requires static</kbd> qualifier. The syntax is:</p>
<pre class="calibre23">    module &lt;module-name&gt; { 
      ... 
      requires static &lt;optional-module-dependency&gt;; 
    } </pre>
<p class="calibre2">The <kbd class="calibre12">static</kbd> qualifier tells the module system that the module <kbd class="calibre12">required</kbd> is optional. The module should still be available at compile time (because <kbd class="calibre12">javac</kbd> needs to compile the code and references after all!). But it is optional at runtime. If the module isn't available during runtime, <kbd class="calibre12">java</kbd> won't complain about the module's unavailability like it would with the <kbd class="calibre12">requires</kbd> only clause. It proceeds with execution assuming you know what you are doing. This new feature enables you to have modules with a bunch of <kbd class="calibre12">require static</kbd> optional dependencies, which can be freely dropped into the module path.</p>
<p class="calibre2">Here's how it works:</p>
<ul class="calibre14">
<li class="calibre15">When you have a module that optionally depends on one or more modules, use the <kbd class="calibre12">requires static</kbd> clause to establish optional dependency in the module definition. If <em class="calibre22">module A</em> optionally requires <em class="calibre22">module B</em>, you specify <kbd class="calibre12">requires static B</kbd> in module A's definition.</li>
<li class="calibre15">During development and compile time, you don't <em class="calibre22">have</em> to do anything different. You could use the exported types from the optional dependencies just like a regular <kbd class="calibre12">requires</kbd> dependency. As always, the module(s) with the optional dependency needs to be available at compile time for the code to compile.</li>
<li class="calibre15">At runtime however, things are different. This time, you can execute your application irrespective of whether the module with the optional dependency is available or not. If the module is available, it gets picked up fine. But if it isn't, you get a <kbd class="calibre12">NoClassDefFound</kbd> error. While it's not mandatory, it's a good idea to write code to handle this error scenario, in case the module you optionally require isn't available.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example</h1>
                
            
            <article>
                
<p class="calibre2">Consider the sample code atÂ <kbd class="calibre12">09-module-patterns/03-optional-dependencies</kbd>. The <kbd class="calibre12">pattern.three</kbd> is a module that optionally requires <kbd class="calibre12">pattern.three.optlib</kbd>. It uses the optional library if available, but the module is perfectly happy if it isn't available at runtime. To establish this optional nature of this dependency, <kbd class="calibre12">pattern.three</kbd> uses the <kbd class="calibre12">requires static</kbd> clause:</p>
<pre class="calibre23">    module pattern.three { 
      requires static pattern.three.optlib; 
      exports pattern.three.external; 
    } </pre>
<p class="calibre2">The <kbd class="calibre12">pattern.three.optlib</kbd> has a simple library class that prints a message to the console. Nothing surprising here:</p>
<pre class="calibre23">    public class LibImpl { 
      public void publicApi() { 
        System.out.println("Called API method in LibImpl"); 
      } 
    } </pre>
<p class="calibre2">Now, the code in the module <kbd class="calibre12">pattern.three</kbd> can directly import and use the exported types of the optional module (in this case, <kbd class="calibre12">LibImpl</kbd>). But this is not a good idea. By specifying that a dependency is optional, you are essentially asking the platform to let go of its reliable configuration guarantee and to <em class="calibre22">not</em> check and ensure that the module is available. This opens the possibility that this dependency is not satisfied at runtime. For this reason, it's the responsibility of the module now to be able to handle both the presence and absence of the module. Rather than have the <kbd class="calibre12">NoClassDefFound</kbd> error thrown to the user, we can be smart about using the optional types only if they are available. We can use the <kbd class="calibre12">Class.forName</kbd> API to examine if the class does exist.</p>
<p class="calibre2">This is the code in the <kbd class="calibre12">Util</kbd> class in module <kbd class="calibre12">pattern.three</kbd>. This is one way to reflect and use the types from optional dependencies:</p>
<pre class="calibre23">    try { 
      Class&lt;?&gt; clazz = Class.forName("pattern.three.lib.LibImpl"); 
      LibImpl impl = (LibImpl) clazz.getConstructor()<br class="title-page-name"/>                      .newInstance(); // Create new instance 
      impl.publicApi(); // Call the API 
    } catch (ReflectiveOperationException e) { 
        System.out.println("Did not find the Impl class module"); 
    } </pre>
<p class="calibre2">As with the previous examples, we have a <kbd class="calibre12">consumer</kbd> module that requires <kbd class="calibre12">pattern.three</kbd> and has a <kbd class="calibre12">Main</kbd> type that calls the module's API. Before executing the application, here's another important thing for you to know about optional dependencies. They don't get picked up in the module resolution process! So, we'll have to explicitly add the module to the execution process.</p>
<div class="packt_infobox">In <a target="_blank" href="part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre27"><span class="packt_screen">Chapter 8</span></a>, <em class="calibre29">Understanding Linking and Using</em> <em class="calibre29">jlink</em>, we discussed the module resolution process and how the Java Platform resolves the tree of dependencies by recursively fetching all dependent modules that are required in the module definition. It doesn't do that for optional dependencies! During the module resolution process, if the runtime encounters theÂ <span class="packt_screen"><kbd class="calibre28">requires static</kbd>Â </span>dependency, it does not resolve that module and its dependencies. These optional modules could be compiled and ready, sitting in the module path along with the other modules, but the runtime still doesn't see it. This brings up an interesting problem. How does the Java runtime know that these optional modules exist in the module path if it doesn't even look it up?<br class="calibre25"/>
<br class="calibre25"/>
The solution is to add the modules manually into the module resolution process. Remember theÂ <span class="packt_screen"><kbd class="calibre28">--add-modules</kbd>Â </span>option we passed toÂ <span class="packt_screen"><kbd class="calibre28">jlink</kbd>Â </span>in <a target="_blank" href="part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre27">Chapter 8</a>, <em class="calibre29">Understanding Linking and Using</em><span class="packt_screen">Â </span><em class="calibre29">jlink</em>? We used that flag to haveÂ <span class="packt_screen"><kbd class="calibre28">jlink</kbd>Â </span>include modules to the resolution process. TheÂ <span class="packt_screen"><kbd class="calibre28">java</kbd>Â </span>command too has that flag available to include modules. So, to have the runtime <em class="calibre29">see</em> and use the optional modules, we'll need to add it using theÂ <span class="packt_screen"><kbd class="calibre28">--add-modules</kbd>Â </span>flag.</div>
<p class="calibre2">You can compile the example code with the <kbd class="calibre12">javac</kbd> command as usual. No changes here:</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -p src -d out $(find . -name '*.java')</strong>  </pre>
<p class="calibre2">When running, however, you need to add all the modules that are optional dependencies using the <kbd class="calibre12">--add-modules</kbd> flag. Here, <kbd class="calibre12">pattern.three.optlib</kbd> is the optional dependency. So, here's the command you use to execute the <kbd class="calibre12">Main</kbd> class in the <kbd class="calibre12">consumer</kbd> module and the resulting output:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out --add-modules pattern.three.optlib -m <br class="title-page-name"/>  consumer/app.Main</strong>
<br class="title-page-name"/><strong class="calibre1">Called API method in LibImpl</strong></pre>
<p class="calibre2">Try removing the compiled <kbd class="calibre12">pattern.three.optlib</kbd> module from the <kbd class="calibre12">out</kbd> directory and run it again without the <kbd class="calibre12">-add-modules</kbd> option:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out -m consumer/app.Main</strong>
<br class="title-page-name"/><strong class="calibre1">Did not find the Impl class module</strong>  </pre>
<p class="calibre2">This time, you get the <em class="calibre22">fallback</em> code executed because the necessary class isn't available. The important distinction here is that the code still runs. It wouldn't have if the dependency wasn't optional.</p>
<div class="packt_tip">TheÂ <span class="packt_screen"><kbd class="calibre28">--add-modules</kbd>Â </span>parameter is sensitive to the order, in that it should appear <em class="calibre29">before</em> theÂ <span class="packt_screen"><kbd class="calibre28">-m</kbd>Â </span>parameter. So, the following command will not work:<br class="calibre25"/>
<br class="calibre25"/>
<kbd class="calibre28">java --module-path out -m consumer/app.Main --add-modules out/pattern.three.optlib # Doesn't work</kbd></div>
<p class="calibre2">Benefits:</p>
<ul class="calibre14">
<li class="calibre15">Allows you to create libraries that are <em class="calibre22">plug-and-play</em>. You can create a <em class="calibre22">main</em> library module that depends on additional modules optionally, thereby providing runtime flexibility in the modules and functionality that are actually a part of the execution.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 4 - Optional dependencies using services</h1>
                
            
            <article>
                
<p class="calibre2">While reading about optional module dependencies, a thought might have occurred to you--how about using services? We've learned in <a target="_blank" href="part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 7</a>, <em class="calibre22">Introducing Services</em>, about how using services in Java modules provides a flexible and loosely coupled way of having modules work with each other. With services, you don't have to specify a readability relationship with <kbd class="calibre12">requires</kbd>. Modules that provide services are optional, not just in runtime, but also during compile time! So aren't services already better than optional dependencies?</p>
<p class="calibre2">The simple answer is yes. Services are definitely the preferred way of decoupling modules and removing <em class="calibre22">hard</em> dependencies. This is what we'll examine in this pattern. However, they do have a problem and won't work as well as you'd imagine. Let's explore why.</p>
<p class="calibre2">Here's how it works:</p>
<p class="calibre2">When using services, you typically achieve abstraction by creating two types--the interface (which <em class="calibre22">is</em> the service) and the implementations of the interface (which are the providers of the service). You don't <em class="calibre22">have</em> to do this, of course. You can have a Java class itself be the service type. But what we are discussing now applies to that too.</p>
<p class="calibre2">Given two modules A and B, if you'd like module A to optionally depend on B, you could use the previous pattern and use <kbd class="calibre12">requires static B</kbd> in the module definition of A. However, if you'd like to use services, you'll need to assign one or more Java interfaces or classes as <em class="calibre22">service types</em>. The <kbd class="calibre12">module A</kbd> needs to specify that it <kbd class="calibre12">uses</kbd> these types:</p>
<pre class="calibre23">    module A { 
      uses &lt;service-type&gt;; 
    } </pre>
<p class="calibre2">And <kbd class="calibre12">module B</kbd> needs to <kbd class="calibre12">provide</kbd> the services:</p>
<pre class="calibre23">    module B { 
      provides &lt;service-type&gt; with &lt;implementation-type&gt;; 
    } </pre>
<p class="calibre2">Now, B is technically optional. The application can run irrespective of whether module B exists in the module path or not! Seems simple enough, doesn't it? But there's a catch! Which module should the service type reside in? Is it module A or module B? It cannot be module B, because in that case, module A would need to <em class="calibre22">require</em> module B to access the service type in B, which defeats the whole purpose of making B optional! It could reside in module A, but now module B should depend on module A to access the service type. Thus module B <kbd class="calibre12">requires</kbd> A and module A <kbd class="calibre12">exports</kbd> the package containing the service type.</p>
<p class="calibre2">But wait! Our original goal was to make module A optionally depend on B. What we've ended up with now is module B depending on A! That seems the wrong way around, but if you think about the service dynamic, A is still using the implementation provided by B, and B is only dependent on A to get the service type. It is still confusing and it's not obvious what's going on just by looking at the module definitions. One way to solve the problem is to move the service types to a third <kbd class="calibre12">module C</kbd> which is required by both A and B. Now both A and B have access to the service types, and thus, are fully decoupled. This option might not always be feasible, and it is awkward to have a separate module just to solve this problem. But when it <em class="calibre22">is</em> possible, this approach of using services is one of the best ways to achieve flexibility and theÂ <em class="calibre22">drop-anything-you-need</em>Â mechanism that exists with some libraries and frameworks in Java 8 and earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example</h1>
                
            
            <article>
                
<p class="calibre2">Look at the sample code at <kbd class="calibre12">09-module-patterns/04-optional-dependencies-with-services</kbd>.We have two modules, <kbd class="calibre12">pattern.four</kbd> and <kbd class="calibre12">pattern.four.optlib</kbd>. We want <kbd class="calibre12">pattern.four</kbd> to optionally depend on <kbd class="calibre12">pattern.four.optlib</kbd> using the services pattern we've seen so far.</p>
<p class="calibre2">The module <kbd class="calibre12">pattern.four</kbd> contains a service type <kbd class="calibre12">LibInterface</kbd> that it exports. It also declares that it uses provider implementations of <kbd class="calibre12">LibInterface</kbd>, which is what essentially makes <kbd class="calibre12">LibInterface</kbd> a service type:</p>
<pre class="calibre23">    module pattern.four { 
      exports pattern.four.external; 
      uses pattern.four.external.LibInterface; 
    } </pre>
<p class="calibre2">The module <kbd class="calibre12">pattern.four.optlib</kbd> provides an implementation of the <kbd class="calibre12">LibInterface</kbd> service type. It also depends on <kbd class="calibre12">pattern.four</kbd> to access the service type in the first place. This is the seemingly inverted relationship we discussed earlier:</p>
<pre class="calibre23">    module pattern.four.optlib { 
      requires pattern.four; 
      provides pattern.four.external.LibInterface with <br class="title-page-name"/>       pattern.four.lib.LibImpl;  
    } </pre>
<p class="calibre2">There's a class <kbd class="calibre12">LibImpl</kbd> in <kbd class="calibre12">pattern.four.optlib</kbd> that implementsÂ <kbd class="calibre12">LibInterface</kbd> as declared in the preceding module definition:</p>
<pre class="calibre23">    public class LibImpl implements LibInterface { 
      public void publicApi() { 
        System.out.println("Called API method in Service"); 
      } 
    } </pre>
<p class="calibre2">The module <kbd class="calibre12">pattern.four</kbd> is now totally unaware of <kbd class="calibre12">pattern.four.optlib</kbd>. It uses the <kbd class="calibre12">ServiceLoader</kbd> API to get any available instances, and if the optional module is available, it's happy to use it:</p>
<pre class="calibre23">    public class Util { 
      public void utilMethod() { 
        Iterable&lt;LibInterface&gt; libInstances =<br class="title-page-name"/>          ServiceLoader.load(LibInterface.class); 
        for (LibInterface libInstance : libInstances) { 
          libInstance.publicApi(); 
        } 
      } 
    } </pre>
<p class="calibre2">Benefits:</p>
<ul class="calibre14">
<li class="calibre15">Extends the <em class="calibre22">plug-and-play</em>Â concept that the previous pattern solved and adds a new level of decoupling. Modules can be optional both at compile time and runtime!</li>
<li class="calibre15">Extends the one-to-one dependency of <kbd class="calibre12">requires static</kbd> with the services providing one-to-many dependency. There could be multiple modules providing services that are optionally picked up by the module using the services.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 6 - Bundle model classes as separate sharable modules</h1>
                
            
            <article>
                
<p class="calibre2">It's common for many enterprise applications to deal with multiple layers and tiers. They usually need to communicate and share data among them, and a frequently used pattern is to exchange data using model objects or <strong class="calibre1">Data Transfer Objects</strong> (<strong class="calibre1">DTOs</strong>). They are an example of code that needs to be shared across multiple layers and modules.</p>
<p class="calibre2">A good pattern to follow is to create separate modules just for the model (or DTO) classes. These modules can then be read by any module that needs access to those types. This could be a lightweight module containing just the model classes and not much else.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 7 - Open modules for reflection</h1>
                
            
            <article>
                
<p class="calibre2">Reflection is an important feature in the Java programming language, allowing the ability to inspect and modify types dynamically at runtime. This is another feature that has been put to good use by frameworks such as Spring, Hibernate, and others. These frameworks use reflection to examine your classes for annotations and interface implementations to infer information about how to treat your code. You might use reflection in your own code to achieve this dynamic functionality.</p>
<p class="calibre2">How does reflection fit into the concepts of modularity we've learned so far? Like we've seen before, the default behavior of strong encapsulation that protects types in a module from static access offers similar protection for reflective access as well. A Java type can be accessed through reflection if it's in a module that exports it, and the type calling the reflection API is in a module that reads the other module.</p>
<p class="calibre2">This results in a potential problem because of how reflection has been traditionally used in Java, especially in many of the frameworks like we've mentioned earlier. Frameworks like Spring expect to scan through your entire code base looking for classes that are annotated with certain key annotations. A lot of reflection API usage in Java code bases over the years have been implemented with an implicit understanding that the classes being reflected on are available for them to access. Once you move those types into modules, all the encapsulated types are effectively sealed off and not available for reflection. One easy solution is to expose everything! So, every module exposes all types that need to be accessed reflectively. But this is not a good idea because of the concept of the module API we've discussed earlier. The type that a module exposes using the <kbd class="calibre12">exports</kbd> clause is the module API. By exposing an otherwise private type just because it contains an annotation for the Spring framework, Hibernate, JPA, or any other such framework that uses reflection, we are adversely impacting the API of the module and the purpose of string encapsulation is defeated.</p>
<p class="calibre2">To address this issue and to still provide an option of using reflection with such frameworks, the platform has introduced a concept called <strong class="calibre1">open modules</strong>. These are a type of Java modules that still encapsulate types like we are familiar with, but with one major difference. The encapsulated types in these open modules are available for reflective access at runtime, without you having to allow compile-time access that an <kbd class="calibre12">exports</kbd> declaration would have provided.</p>
<p class="calibre2">How do you make a Java module an <em class="calibre22">open module</em>? Very simple. Just add the <kbd class="calibre12">open</kbd> keyword in front of the module definition in <kbd class="calibre12">module-info.java</kbd>:</p>
<pre class="calibre23">    open module &lt;module-name&gt; { 
    } </pre>
<p class="calibre2">With this, the contents of the module are still encapsulated (except for any packages that you <kbd class="calibre12">export</kbd> in the module definition). But all the packages in the module are now available for access at runtime using reflection by any module that reads this module.</p>
<div class="packt_infobox">Remember that theÂ <span class="packt_screen"><kbd class="calibre28">open</kbd>Â </span>keyword doesn't make the module open for reflective access for all modules. A module that needs to access any such types using reflection will still need to <em class="calibre29">read</em> the module that contains the type using theÂ <span class="packt_screen"><kbd class="calibre28">requires</kbd>Â </span>keyword.</div>
<p class="calibre2">Not only entire modules, but even individual packages can be marked as open with theÂ Â <span><kbd class="calibre12">opens</kbd></span> keyword followed by the specific package you'd like to open for reflection. This provides more fine-grained control when you know that there are only certain classes in the module that need to be reflected upon:</p>
<pre class="calibre23">    module modulename { 
      opens package.one; 
      opens package.two to anothermodule; 
      exports package.three; 
    } </pre>
<p class="calibre2">In the preceding example, the package <kbd class="calibre12">package.one</kbd> is available for reflection by all modules that read module <kbd class="calibre12">modulename</kbd>. The package <kbd class="calibre12">package.two</kbd> is available for reflective access only by module <kbd class="calibre12">anothermodule</kbd>, if it chooses to <em class="calibre22">require</em> it. And package <kbd class="calibre12">package.three</kbd> is available for both reflective and compile-time access because it is exported.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example</h1>
                
            
            <article>
                
<p class="calibre2">In the sample code at <kbd class="calibre12">09-module-patterns/06-open-modules</kbd>, the module <kbd class="calibre12">pattern.six</kbd> contains the type <kbd class="calibre12">Contact.java</kbd> in the package <kbd class="calibre12">pattern.six.internal</kbd>. Let's assume we'd like for this class to be internal to the module and not exposed. However, we'd like to be able to access the <kbd class="calibre12">Contact</kbd> class reflectively from another module <kbd class="calibre12">consumer</kbd>.</p>
<p class="calibre2">Here's the code in the <kbd class="calibre12">consumer</kbd> module that is doing reflection:</p>
<pre class="calibre23">    try { 
      Class clazz = Class.forName("pattern.six.internal.Contact"); 
      Constructor&lt;?&gt; ctor = clazz.getConstructor(); 
      Object object = ctor.newInstance(new Object[] {  }); 
      System.out.println("Successfully created object using <br class="title-page-name"/>       reflection"); 
    } catch (ReflectiveOperationException e) { 
        System.out.println("Did not find the Impl class module"); 
    } </pre>
<p class="calibre2">The consumer module establishes a dependency on the module <kbd class="calibre12">pattern.six</kbd> first:</p>
<pre class="calibre23">    module consumer { 
      requires pattern.six; 
    } </pre>
<p class="calibre2">But that's not enough! The module <kbd class="calibre12">pattern.six</kbd> should either export the type or declare that it's an open module.</p>
<p class="calibre2">Here's how the module definition for <kbd class="calibre12">pattern.six</kbd> looks like:</p>
<pre class="calibre23">    open module pattern.six {   
    } </pre>
<p class="calibre2">Notice that the contents of the module aren't technically exported, so the types in the module are still encapsulated for static access. However, since the module is open, the types are available for reflection. Running <kbd class="calibre12">Main</kbd> in the <kbd class="calibre12">consumer</kbd> module should work now.</p>
<p class="calibre2">Benefits:</p>
<ul class="calibre14">
<li class="calibre15">Allows selective exposing types for reflection only.</li>
<li class="calibre15">Useful for situations where the types need to be <em class="calibre22">scanned</em> for annotations and implementations by application frameworks and libraries that use that approach. For example, packages in modules containing Spring or Hibernate annotations can be declared as open to make them accessible by such frameworks. You can now do that while still maintaining encapsulation for traditional access.</li>
</ul>
<p class="calibre2">Remember that with theÂ <span><kbd class="calibre12">open</kbd></span> andÂ <span><kbd class="calibre12">opens</kbd></span> declarations, you are technically letting go of strict encapsulation by allowing packages to be accessed reflectively. This is still a good option, and at least, much better than exporting packages, when all you want to enable is reflective access. The intent is made clear to the consumers of your module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 8 - Use tooling for version control</h1>
                
            
            <article>
                
<p class="calibre2">As discussed in <a target="_blank" href="part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 3</a>, <em class="calibre22">Handling Inter-Module Dependencies</em>, one important feature of most module systems is conspicuously absent in Java modularity--that of module versioning and version management. If you've dealt with build and packaging tools in the Java ecosystem such as Maven and Gradle, you might have come across the fact that all their library artifacts have version numbers associated with them. With Maven or Gradle, when you establish a dependency on another artifact or library module (and I'm using the word module loosely here), you not only have to specify its name and coordinates, you also have to specify its version number.</p>
<p class="calibre2">With Java module dependencies, there's no way to specify version-based dependency. The <kbd class="calibre12">requires</kbd> syntax, <kbd class="calibre12">requires &lt;module-name&gt;;</kbd> just accepts the module name, and not the version. For example, you can specify that your module depends on the <kbd class="calibre12">google.guava</kbd> module. But you cannot specify that it depends on version <kbd class="calibre12">1.5.2</kbd> of <kbd class="calibre12">google.guava</kbd>. The Java Platform Module System specification clearly states that versioning isn't one of the goals of the module specification. The idea is to leverage the existing build tools and containers to solve this problem, which they have already done in earlier versions of Java.</p>
<p class="calibre2">If you are not familiar with what the build tools such as Maven or Gradle do, their job in <em class="calibre22">pulling in</em> dependencies can be classified into two parts. I am simplifying, of course, but at a high level, these tools do the following:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Provide a way for each project to specify what other libraries they are dependent on.</li>
<li value="2" class="calibre15">Pull in those libraries during build and adding the JARs to the classpath so that the project that needs them has the necessary libraries available to use. These JARs are typically downloaded from a central repository based on the dependencies and version numbers specified.</li>
</ol>
<p class="calibre2">Because tools such as Maven and Gradle does #2 above, it is essential for them to have all the details--not only which library to download, but also which version of the library to download. Remember, it needs to download the right jar from a repository with thousands of libraries with multiple versions of each. The Java module system does #1 but not #2, but not for the purposes of fetching or downloading artifacts from somewhere. It just assumes the modules are already there! This is why versions do not apply here. The version of the module you have in the module path is the version that will be used.</p>
<p class="calibre2">This is where something like Maven fundamentally differs from JPMS. The build tools deal with build artifacts--downloading and assembling packaged jar file distributables. A Java module is not a build-time artifact, but a compile time and runtime artifact. Maven concerns with making sure the right dependencies are assembled. The Java Module system is concerned with compile and runtime integrity of binaries that have already been assembled.</p>
<p class="calibre2">This allows the option of using build tools such as Maven or Gradle to download the right versions of modular JAR files and dependencies, thereby leaving the fully prepared set of modules available in the module path for the module system to then take over and use.</p>
<p class="calibre2">We'll look at Maven integration with Java 9 modular applications in much more detail in <a target="_blank" href="part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 12</a>, <span><em class="calibre22">Using Build Tools and Testing Java Modules</em>.</span></p>
<div class="packt_tip">Do not use version numbers in your module names. It is very tempting to create multiple modules with the version numbers trailing the names--with module names such asÂ <span class="packt_screen"><kbd class="calibre28">my.module.v1</kbd></span>,Â <span class="packt_screen"><kbd class="calibre28">my.module.v2</kbd>,Â </span>and so on. This is not recommended because this does not provide any indication about the relationship and the similarities between two different versions of the same module, and is essentially a <em class="calibre29">hack</em> to get versioning to work with Java modules. A much better way is to let a build system bring in the right version of modules as discussed, and the platform does not have to deal with versioning.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 9 - Design for changes</h1>
                
            
            <article>
                
<p class="calibre2">As with building any API, you have to keep your users in mind when you'll eventually plan to change it. Thus, you'll have to keep possible future changes in mind when you design it! The exported packages in your module are the public API, so your users could be accessing any of them. This means that changing any types in the exported packages of your module will need to be approached with caution, as it could potentially break any consumers of your module.</p>
<p class="calibre2">Of course, this depends on the change itself. If you are adding a new type to an exported package, or are adding new member variables or methods to existing exported types, the changes are still backward compatible. But if you want to remove member variables from exported types or change method signatures, you end up breaking code that uses those APIs.</p>
<p class="calibre2">Here are some guidelines that help minimize possible changes to module APIs:</p>
<ul class="calibre14">
<li class="calibre15">Keep the exported types as lightweight as possible. We've already seen how you can expose interface types that are backed by encapsulated implementation types. Having lesser moving parts in exposed types makes them less likely to change in future.</li>
<li class="calibre15">When you plan to make backward incompatible changes, plan to give your module consumers a heads up. This could be in the form of the <kbd class="calibre12">@Deprecated</kbd> annotation on the methods that you plan to remove, for example. If possible, try to provide both the old and new APIs together (with clear deprecation notices on the old APIs) so that the consumers of your module have enough time to switch their code to use your new APIs.</li>
</ul>
<p class="calibre2">TheÂ  <kbd class="calibre12">@Deprecated</kbd> annotation in Java 9 can be used on a module declaration too! This is very handy when you want to mark a complete module for deprecation. Here's an example:</p>
<pre class="calibre23">    @Deprecated(since = "9", forRemoval = true)<br class="title-page-name"/>    module mymodule {   
    } </pre>
<p class="calibre2">This marks the module as deprecated from Java 9 onward, and also that it could be a removed in any future release. If any module tries to use your module with aÂ  <kbd class="calibre12">requires</kbd>, the compiler will issue a warning about the deprecation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 10 - Protect against dependency leakage</h1>
                
            
            <article>
                
<p class="calibre2">In <a target="_blank" href="part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 5</a>, <em class="calibre22">Using Platform APIs</em>, we've looked at how dependent types can be leaked by an API and it may not be very obvious it's doing so. The best practice to follow is to make the usage of your module as lightweight as possible. Ideally, using your module should be as simple as adding a <kbd class="calibre12">requires</kbd> clause for the module and then just using it!</p>
<p class="calibre2">Here are some guidelines to follow:</p>
<ul class="calibre14">
<li class="calibre15">Make sure your module is self-sufficient. You shouldn't need to depend on another module to use it.</li>
<li class="calibre15">If your module's APIs need to return types that are a part of another module, try to encapsulate them into types that are exposed in your own module. If your APIs could throw exceptions that are a part of another module, try to catch them and re-throw custom exceptions that are exposed by your module.</li>
<li class="calibre15">If using your module's APIs requires usage of types in other modules and cannot be wrapped like mentioned previously, make sure those modules have transitive dependency so that the consumers of your module automatically get them.</li>
</ul>
<p class="calibre2">As the third guideline implies, sometimes you may want to enable transitive dependencies and allow types from other modules to be a part of your module's APIs. As with most best practices, you will need to examine this on a case-by-case basis as there is no right answer that applies in all situations.</p>
<p class="calibre2">A note of caution, however. Once you establish a transitive dependency in your module on another module, it is very easy for those types to creep into your APIs. For example, let's say you are working on module <strong class="calibre1">A</strong> that exposes a bunch of different APIs. Assume that the usage of one of those APIs requires a type from module <strong class="calibre1">B</strong> and it just cannot be avoided. The solution is to have a transitive dependency on module <strong class="calibre1">B</strong>, so that any consumer of your module also gets the type from <strong class="calibre1">B</strong>:</p>
<div class="packt_figure"><img class="image-border74" src="../images/00081.jpeg"/></div>
<p class="calibre2">Now, once the transitive dependency is established, you can very easily build new APIs in module <strong class="calibre1">A</strong> that also require types from <strong class="calibre1">B</strong>. <strong class="calibre1">B</strong> is transitive anyway, so the consumer already has access to those types. So, there's no need to prevent that or wrap those types from <strong class="calibre1">B</strong> anymore, is there? Well, this is a slippery slope! The more types of a transitive module you use, the more coupled that module becomes to your own. It's harder to decouple it if you choose to refactor module <strong class="calibre1">A</strong> in the future, perhaps to remove the dependency on <strong class="calibre1">B</strong>. This is why I would still recommend wrapping types and preventing leakage of dependent types in your APIs even if those types are transitively available to the consuming module. The primary goal in designing a module should be to establish a purpose and an API for a module, and not to blindly add whateverÂ  <kbd class="calibre12">requires</kbd> declarations it takes just to get things to work!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern 11 - Aggregator and facade modules</h1>
                
            
            <article>
                
<p class="calibre2">We've looked at aggregator modules in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 6</a>, <em class="calibre22">Module Resolution, Readability, and Accessibility</em>. Aggregator modules allows us to create modules that consolidate a set of libraries that are commonly used so that the consumers can require just one aggregator module rather than the more tedious process of finding the right list of modules to require. Using aggregator modules is a good pattern to use when you have multiple modules in your application that need a standard set of dependencies to be <em class="calibre22">required</em>. This not only makes the process of establishing dependencies on new modules easier, it also allows you to change and update that list of dependencies in one place and have it reflected across all other modules in your application or organization.</p>
<p class="calibre2">Following is an example aggregator module that provides transitive dependency on three other modules:</p>
<div class="packt_figure"><img class="image-border75" src="../images/00082.jpeg"/></div>
<p class="calibre2">There's another pattern that's closely related that I like to call <em class="calibre22">facade modules</em>. These are an extension of aggregator modules in that they do offer dependencies to a group of modules using transitive dependencies, but they might also contain logic that deals with types from multiple modules. While aggregator modules just do transitive dependencies and do not necessarily contain logic of their own, the <em class="calibre22">facade module</em> might contain logic to do things like choose an API from one of the modules based on certain criteria, co-ordinate and synchronize calls across multiple module APIs, and so on.</p>
<p class="calibre2">Both aggregator and facade modules are designed for special use cases and act as <em class="calibre22">wrappers</em> around the underlying modules. Since they perform consolidation of modules for this reason, they may not offer the best reuse opportunities. But that's OK! Like we've discussed before, the best modules to facilitate reuse are simple single-purpose modules. However, aggregator and facade modules provide a middle ground between extremely fragmented modules that are pain to use and specialized modules that are easier to use but lack flexibility. A very handy pattern to use in such cases, when you are trying to strike that balance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example</h1>
                
            
            <article>
                
<p class="calibre2">In the sample code atÂ <kbd class="calibre12">09-module-patterns/09-aggregator-and-facade-modules</kbd>, the module <kbd class="calibre12">pattern.nine.facade</kbd> acts as an aggregator and facade module that consolidates two separate modules--<kbd class="calibre12">module.one</kbd> and <kbd class="calibre12">module.two</kbd>. It has a transitive dependency on both those modules, so any module that reads <kbd class="calibre12">pattern.nine.facade</kbd> also automatically reads those two modules:</p>
<pre class="calibre23">    module pattern.nine.facade { 
      requires transitive module.one; 
      requires transitive module.two; 
      exports pattern.nine.external; 
    } </pre>
<p class="calibre2">Not only does the module do that, it also has a thin <em class="calibre22">facade</em> API. There's a class it exports--<kbd class="calibre12">FacadeApi</kbd> that has an example method to illustrate how a method can <em class="calibre22">choose</em> between two implementations. Here, the method chooses one of two implementations based on an input String value. But you can easily imagine facade APIs written in such a module that offer help around business rules or logic of your application that affects which libraries are used:</p>
<pre class="calibre23">    public void facadeMethod(String apiChoice) { 
      if ("one".equals(apiChoice)) { 
        apiOne.apiMethod(); 
      } 
      else if ("two".equals(apiChoice)) { 
        apiTwo.apiMethod(); 
      } 
    } </pre>
<p class="calibre2">Now, the <kbd class="calibre12">consumer</kbd> module that reads <kbd class="calibre12">pattern.nine.facade</kbd> has two options. It can either access the library modules directly (And it can because of the transitive dependencies--it transitively reads both <kbd class="calibre12">module.one</kbd> and <kbd class="calibre12">module.two</kbd>). Or, it can call the API through the facade method to get help on which one to call. Both work perfectly fine, as you can see in the following code:</p>
<pre class="calibre23">    public static void main(String[] args) { 
      FacadeApi facade = new FacadeApi(); 
      ApiTwo apiTwo = new ApiTwo(); 
      facade.facadeMethod("one"); // Calling the API through the facade 
      apiTwo.apiMethod(); // Calling the other API directly 
    }</pre>
<div class="packt_figure"><img class="image-border76" src="../images/00083.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we've looked at some guidelines and best practices to create modules and identify module boundaries. When creating a new application or when migrating an existing legacy application to Java modules, it's always a good idea to have a map of the modules and their interactions designed in advance. We've looked at some best practices that let you figure out what a module should be made of and what would cause you to segregate logic into separate modules.</p>
<p class="calibre2">We then looked at a list of best practices and ideas to use in your code. Many of the best practices discussed previously come with simplified code examples. Each example is intentionally bare-bone with code that demonstrates just the pattern being discussed and little else, so that you can easily pick any of them up and tweak them further or apply them in your own code.</p>
<p class="calibre2">Now that we have these patterns in your tool belt, let's tackle a major challenge that Java developers will face when moving to Java 9, migration of existing code. There have been years and years of Java development and tons of legacy code of various complexities that has been built using earlier versions of Java. How do we approach moving them to take advantage of Java modules? Before that, would they even work with Java 9? Let's begin to answer those questions, as well as understand what it takes to get your code read for such a migration in the next chapter.</p>


            </article>

            
        </section>
    </body></html>