- en: '*Chapter 9*: CRUD, Transactions, and Locking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover a must-know mix of fundamental notions about CRUD
    operations, transactions, and locking. These three topics are heavily exploited
    in almost any database application. In a common scenario, an application has a
    significant number of CRUD operations that are executed in explicitly demarcated
    logical transactions and, in certain cases, they also need to explicitly control
    the concurrent access to data to prevent **race conditions**, **lost updates**,
    and other **SQL phenomena** (or SQL anomalies).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CRUD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating (updatable) records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter09](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the awesome DSL-fluent API for expressing complex SQL, jOOQ can be used
    to express *everyday* SQL operations as well. These are known as `INSERT`), `SELECT`),
    `UPDATE`), and `DELETE`)), and jOOQ facilitates them via a dedicated API that
    involves `UpdatableRecord` types. In other words, the jOOQ Code Generator generates
    a `UpdatableRecord` (a record that can be fetched and stored again in the database)
    for each table that has a primary key (not just a simple unique key!). Tables
    without a primary key (`org.jooq.TableRecord`) are rightly considered non-updatable
    by jOOQ. You can easily recognize a jOOQ `UpdatableRecord` because it has to extend
    the `UpdatableRecordImpl` class (simply inspect your generated records from `jooq.generated.tables.records`).
    Next, jOOQ exposes a CRUD API that allows you to operate directly on these updatable
    records instead of writing DSL-fluent queries (which fits better for complex queries
    that involve more than one table).
  prefs: []
  type: TYPE_NORMAL
- en: If you need a quick reminder about jOOQ records, please check out [*Chapter
    3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The jOOQ CRUD API fits like a glove for **normalized** databases, so for tables
    that have primary keys (simple or composed) or unique lifespans, a primary key
    is inserted only once into a table. Once it's been inserted, it cannot be changed
    or re-inserted after being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you know, jOOQ tries to greet you in any case you have, so if you
    need updatable primary keys, then rely on `Settings.updatablePrimaryKeys()`.
  prefs: []
  type: TYPE_NORMAL
- en: The jOOQ CRUD API facilitates several operations, including insert (`insert()`),
    update (`update()`), delete (`delete()`), merge (`merge()`) and the handy store
    (`store()`). Besides these operations, we have the well-known `selectFrom()`,
    which is useful for reading (`SELECT`) from a single table directly into a `Result`
    of updatable records.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we look at several CRUD examples, is important to know about
    a set of methods that can influence the behavior of updatable records and CRUD
    operations. These methods are `attach()`, `detach()`, `original()`, `changed()`,
    `reset()`, and `refresh()`.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching/detaching updatable records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roughly, jOOQ updatable records are just Java objects that can live independently
    of the database and can be manipulated in memory. So long as an updatable record
    doesn't need to interact with the database, it can remain in the `Configuration`
    that, among other things, has the coordinates to connect to the database that
    this updatable record will interact with. After an updatable record has been attached,
    it will remain like this for as long as the corresponding `Configuration` lives
    or until it is explicitly detached by calling `detach()`.
  prefs: []
  type: TYPE_NORMAL
- en: When we fetch updatable records from the database, jOOQ will automatically attach
    them to the currently used `Configuration` and implicitly to the involved database
    connection. This connection may be used internally for subsequent interactions
    with the fetched updatable records with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To be precise, jOOQ doesn't hold references to a JDBC `Connection` but to `ConnectionProvider`
    from `Configuration`. In terms of transactions or connection pooling, this might
    be relevant. For instance, if we are using a Spring `TransactionAwareDataSourceProxy`,
    an attached record can be fetched in one transaction and stored in another transparently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following read operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `sr` record was automatically attached by jOOQ to the `Configuration` part
    of `ctx`. Next, we can successfully execute other operations that interact with
    the database, such as `sr.update()`, `sr.delete()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider a brand-new record that''s been created by the client,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Such records are not automatically attached to any existent `Configuration`.
    They haven''t been fetched from the database, so jOOQ will justifiably expect
    that you''ll explicitly/manually attach them to a `Configuration` whenever this
    is necessary (for instance, before calling `sr.insert()`). This can be done by
    explicitly calling the `DSLContext.attach()` or `UpdatableRecord.attach()` methods,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to avoid the `attach()` explicit call, we can rely on the `DSLContext.newRecord()`
    alternative. Since `DSLContext` contains the `Configuration` part, jOOQ will do
    the attachment automatically. So, here, you should use the following code snippet
    (if you want to populate the record from a POJO, then use the `newRecord(Table<R>
    table, Object o)` flavor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `srNew` has been attached, we can execute operations that interact with
    the database. Attempting to execute such operations on a detached updatable record
    will lead to an exception that states `org.jooq.exception.DetachedException`:
    *Cannot execute query. No Connection configured.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An updatable record can be explicitly detached with `UpdatableRecord.detach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While an updatable record is serializable, the underlying `Connection` (or
    `DataSource`) of `Configuration` is non-serializable. Nevertheless, you don''t
    have to detach records before serialization. The internals of `DefaultConfiguration`
    ensure that anything that isn''t `Serializable` (for instance, `DefaultConnectionProvider`)
    isn''t serialized. Re-attaching will still be necessary after de-serialization,
    though. Support for serialization on jOOQ radar will eventually be deprecated:
    [https://github.com/jOOQ/jOOQ/issues/2359](https://github.com/jOOQ/jOOQ/issues/2359).'
  prefs: []
  type: TYPE_NORMAL
- en: From this, don't conclude that serializing/de-serializing records is a day-to-day
    task. Most of the time, records are used to populate views (for instance, via
    Thymeleaf) or they are exported as CSV, JSON, HTML, and so on via jOOQ support,
    as you'll see in the next chapter. None of these actions requires an explicit
    detach.
  prefs: []
  type: TYPE_NORMAL
- en: What's an original (updatable) record?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every (updatable) record holds a reference to its *current* values and its *original*
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the record was fetched from the database, then the fetched values represent
    the *original* and the *current* values at the same time. Next, the *current*
    values can be modified in memory, while the *original* values remain in place.
    For example, let''s assume that the following query fetches the `SALE.FISCAL_YEAR`
    field, which is *2005* and that, after fetching it, we set it to *2002*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the *original* value of the fiscal year is *2005* and the *current*
    value is *2002*. After inserting/updating a record, the *current* values that
    have been inserted/updated become the *original* values. For instance, after updating
    `sr`, the *original* value of the fiscal year becomes *2002*, just like the *current*
    value. This way, `sr` mirrors the latest state of the database. So, after an update,
    the *original* values reflect only what has been sent to the database by default.
    Trigger-generated values are not fetched back by default. For that to work, `Settings.returnAllOnUpdatableRecord()`
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a new record, the *original* values are always `null` and remain
    like this until the record is inserted or updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we need the *original* values, we can call `Record.original()`. Without
    arguments, the `original()` method returns a brand-new record that''s been populated
    with the *original* values. If `sr` is attached when calling `original()`, then
    `srOriginal` is attached as well; otherwise, it is detached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying an argument as a `Field`, `Name`, `String`, or integer (index),
    we can extract the *original* value of a certain field. Here is a type-safe and
    a non-type-safe approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the *current* and *original* values of a record in your hands can be
    useful for making decisions after comparing these values between them or with
    other values, for creating side-by-side views of original data and current data,
    and so on. In the bundled code, called *OriginalRecords* (available for MySQL),
    you can see an example of rendering a side-by-side view for a `PRODUCT` via Thymeleaf.
    The relevant Thymeleaf code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Side-by-side view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Side-by-side view
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's focus on marking (updatable) records as changed/unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Marking (updatable) records as changed/unchanged
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A record whose *original* values are exactly the same as the *current* values
    is considered *unchanged*. By calling the `Record.changed()` flag method, we can
    find out if a record is considered as *changed* or *unchanged* by jOOQ. For instance,
    a record that has been fetched from the database and never modified is *unchanged*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if we set the same fiscal year that was fetched from the database (*2005*),
    this record is marked as *changed*. On the other hand, a brand-new record is considered
    *changed*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `changed()` operates at the field level since it''s a `BitSet`
    that''s the same length as the number of record fields. In other words, each field
    of a record has the `changed()` flag method. All we have to do is pass the field
    as an argument of `changed()` as a `Field`, `Name`, `String`, or `int` (representing
    the index):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we attempt to insert or update a record, jOOQ inspects the *changed*
    flags to determine which fields should be part of the generated query. This is
    great, because by rendering only the *changed* fields, jOOQ allows *default* values
    (specified via `CREATE TABLE` DDL statements) to be set for the omitted fields.
    If none of the fields were *changed* then jOOQ can prevent an insert/update from
    being executed (we'll cover this in more detail later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can enforce/suppress the execution of such statements by explicitly
    turning on (or off) the *changed* flag. We can do so by marking all the fields
    as *changed*/*unchanged*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do the same by marking only certain fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to how you juggle these flags since is quite easy to mess things
    up and render some unfortunate DML statements. Next, let's talk about resetting
    records.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting an (updatable) record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By resetting a record, we `false`. This can be accomplished without interacting
    with the database. We can reset all the fields by using `Record.reset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset only certain fields by using `reset(Field`/`Name`/`String`/`int)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You'll see this method at work in the forthcoming sections. Finally, let's talk
    about how to refresh a record.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing an updatable record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By refreshing an updatable record, we synchronize the record''s original values
    with the database''s latest state, and we revert the currentvalues in case they
    had been set. Practically, `UpdatableRecord.refresh()` is materialized in a `SELECT`
    round trip that loads the data in the original values of the record and sets all
    the changed flags to `false`. Refreshing all the fields of the record can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can partially refresh the updatable record using `refresh``(Field<?>...
    fields)` or `refresh``(Collection<? extends Field<?>> fields)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `SELECT` is rendered to fetch only the specified fields. As you'll
    see shortly, this `refresh()` method is quite useful when mixed with optimistic
    locking.
  prefs: []
  type: TYPE_NORMAL
- en: You can find these examples in *SimpleCRUDRecords* (available for MySQL and
    PostgreSQL). Next, let's talk about inserting updatable records.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting updatable records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just a quick note to be sure that this section is not misunderstood: `insert()`
    can be called on any `TableRecord`, not just the `UpdatableRecord` ones; no primary
    key is necessary for `insert()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inserting updatable records can be done via `UpdatableRecord.insert()`
    and its overloads. Typically, we insert brand-new records or records that have
    been loaded from POJOs (for instance, via the `from(POJO)` or `newRecord(Table<R>
    table, Object o)` methods) that are considered and treated by jOOQ as new records.
    Here is a simple and classical example of creating and inserting an updatable
    record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you create it like so, then you need to explicitly call `attach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: jOOQ generates and executes the `INSERT` statement. Moreover, by default, jOOQ
    tries to load any generated keys (the `IDENTITY`/`SEQUENCE` values, which are
    supported by most databases) from the database and turn them back into records
    that conform to the following note.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The JDBC `getGeneratedKeys()` approach is only used when there's no better approach.
    In Db2, Firebird, MariaDB, Oracle, PostgreSQL, and, soon, H2, there is native
    `RETURNING` or `<data change delta table>` support that favors single round trips.
    Sometimes, if `getGeneratedKeys()` isn't supported, or only poorly, then an extra
    round trip may be needed with an extra `SELECT` statement. This is particularly
    true for many dialects when `Settings.returnAllOnUpdatableRecord()` is active.
  prefs: []
  type: TYPE_NORMAL
- en: So, calling `sr.getSaleId()` after `INSERT` will return the database-generated
    primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you just need to re-insert the data that's contained in an updatable
    record. By default, since the record is *unchanged* after being inserted (`changed()`
    returns `false`), executing another `insert()` renders an `INSERT` of defaults
    (`INSERT INTO sale VALUES (default, default, ...)`). If the `CREATE TABLE` DDL
    doesn't provide default values for all the rendered defaults, then this will result
    in an error; that is, *Field 'foo' doesn't have a default value*. But, as you
    can see in the bundled code, this behavior can be controlled via `withInsertUnchangedRecords(false)`.
    Setting this flag to `false` will suppress any attempt to execute an `INSERT`
    of defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert the same data without creating a new record, you can manually mark
    the record fields as changed (notice that we mark the primary key as *unchanged*,
    so it is omitted from the generated `INSERT` to avoid a duplicate key error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you want to re-insert only certain fields, then mark only those
    fields as *changed*. On the other hand, if you want to re-insert the data and
    create a new record as well, then rely on the `UpdatableRecord.copy()` method.
    The `copy()` method is quite handy because it duplicates this record in memory,
    marks all fields as *changed*, and doesn''t copy the primary key or any other
    main unique key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: More examples, including inserting without returning the generated primary key
    and inserting and returning all fields, can be found in the bundled code, *SimpleCRUDRecords*
    (available for MySQL and PostgreSQL). Next, let's focus on updating records.
  prefs: []
  type: TYPE_NORMAL
- en: Updating updatable records (this sounds funny)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, an updatable record is fetched from the database and is changed
    in memory. Subsequently, these changes are propagated to the database by calling
    `UpdatableRecord.update()` or its flavors, which allows us to nominate the fields
    that should be updated. Let''s fetch a record and change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print `sr` at the console, then the result will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Displaying the modified record on the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Displaying the modified record on the console
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `fiscal_year` and `sale` are marked with an asterisk (`*`) by jOOQ.
    This asterisk highlights the fields that have been changed and that will participate
    in the following `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL in MySQL dialect is as follows (the rendered `UPDATE` relies
    on the primary key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: By default, updating a record that is already up to date has no effect. Of course,
    if you rely on `changed()` to mark all/some fields as *changed*, then you force
    jOOQ to execute the corresponding `UPDATE`. You can practice forcing an update
    via `Settings.withUpdateUnchangedRecords(UpdateUnchangedRecords)` in the bundled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting updatable records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A fetched updatable record can be deleted via `UpdatableRecord.delete()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the rendered `DELETE` relies on the primary key (or main unique
    key). After deletion, all the fields of the deleted record are automatically marked
    as *changed*, so you can easily insert it again by calling `insert()`.
  prefs: []
  type: TYPE_NORMAL
- en: Merging updatable records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever we want to execute a `MERGE` statement for an updatable record (brand
    new or fetched from the database), we can call `UpdatableRecord.merge()`. In this
    case, jOOQ renders an `INSERT ... ON DUPLICATE KEY UPDATE` (this is emulated,
    depending on the used dialect), so it delegates the task of choosing between `INSERT`
    and `UPDATE` to the database. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `srNew` will be inserted. Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Here, `srFetched` will be updated based on the primary key. Practically, jOOQ
    will render an SQL that updates the row, regardless of which (unique) key value
    is already present.
  prefs: []
  type: TYPE_NORMAL
- en: Storing updatable records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing an updatable record can be done by calling the `UpdatableRecord.store()`
    method. This method results in an `INSERT` or an `UPDATE`, depending on the primary
    key's state. The decision of rendering an `INSERT` or an `UPDATE` is made by jOOQ,
    not by the database, as in the case of `MERGE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, calling `store()` for new updatable records results in an `INSERT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'If the updatable record was fetched from the database and its primary key was
    not changed, then jOOQ will render an `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If the updatable record was fetched from the database and its primary key was
    changed, then jOOQ will render an `INSERT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can still force an `UPDATE` of the primary key via `withUpdatablePrimaryKeys(true)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as Lukas Eder shared: *"I think it''s worth mentioning that updating
    primary keys is very much against all principles of normalization. It was introduced
    for those cases where users have very good reasons to do so, and those reasons
    are very rare (usually data migrations or fixing broken data, but even then, they''re
    probably more likely to use SQL statements than updatable records)."*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see these examples in *SimpleCRUDRecords* (available for MySQL and PostgreSQL).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you prefer to work with POJOs and jOOQ's DAO, then you'll
    like to check out the examples from *SimpleDaoCRUDRecords* (available for MySQL
    and PostgreSQL). These examples relies on DAO's `insert()`, `update()`, `delete()`,
    and `merge()`. Moreover, you'll see the `withReturnRecordToPojo()` setting at
    work. Next, let's focus on using updatable records in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using updatable records in HTTP conversations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jOOQ's updatable records can be used in web applications or, in other words,
    in conversations that span across requests over the stateless HTTP protocol. Next,
    we'll develop several Spring Boot samples that are meant to highlight what we've
    learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Using insert(), update(), and delete()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s try to build a Spring Boot sample application that uses updatable records
    and `insert()`, `update()`, and `delete()`. While relying on the Spring MVC design
    pattern, let''s consider the following scenario: our main goal is to provide a
    list of all bank transactions (`BANK_TRANSACTION`) that belong to the same payment
    (`PAYMENT`) of a certain customer. The user should be able to insert a new bank
    transaction and delete or modify an existing one.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing all bank transactions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The page that displays the bank transactions should look as follows (*transactions.html*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – All bank transactions of a certain payment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – All bank transactions of a certain payment
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from the controller endpoint, which should be accessed to produce
    the output shown in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'In the highlighted code, we call the service that''s responsible for accessing
    the repository that executes the query for fetching all the transactions for a
    certain payment. This query is quite simple (of course, in reality, you won''t
    hardcode the values of `CUSTOMER_NUMBER` and `CHECK_NUMBER` – these can represent
    something such as the login payment credentials):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the fetched `Result<BankTransactionRecord>` is returned in the controller
    endpoint listed previously and stored in the model (Spring Boot''s `Model`) as
    a request attribute named `all` (`ALL_BANK_TRANSACTION_ATTR = "all"`). To render
    the page that''s returned from this controller endpoint (*transactions.html*)
    we can rely on the popular Thymeleaf template engine (of course, you can use any
    other template engine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: From the returned page (*transactions.html*), we can choose to insert a new
    transaction or modify an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a new bank transaction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inserting a new bank transaction can be done by rendering the link like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This link reaches a controller endpoint that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this controller endpoint creates a new `BankTransactionRecord` that is
    stored in the model via the `NEW_BANK_TRANSACTION_ATTR` request attribute. The
    returned page, *newtransaction.html*, is rendered like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Creating a new bank transaction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Creating a new bank transaction
  prefs: []
  type: TYPE_NORMAL
- en: 'Pressing the *Save* button triggers a `POST` request that reaches the following
    controller endpoint (`/new`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'So, Spring Boot populates the `btr` record with the submitted data, and we
    insert it into the database (before inserting it, in the service method (not listed
    here), we associate this new transaction with the corresponding payment via `btr.setCustomerNumber()`
    and `btr.setCheckNumber()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a new bank transaction, we must attach it before inserting it.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a bank transaction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's consider that updating a bank transaction implies a four-step wizard.
    In the case of simple wizards, we can use a single `<form/>` that is submitted
    at the last step of the wizard. However, in the case of dynamic wizards, we must
    use one `<form/>` per panel since we must submit the data at each step to decide
    which is going to be the next panel and what it will contain. So, in such cases,
    we must implement a long HTTP conversation that's capable of storing the user
    data while navigating back and forth between the panels. Commonly, this is done
    by storing data via the client's HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s keep it as simple as possible and assume that the four-step wizard looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Four-step wizard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Four-step wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'Before entering this wizard, we must click on the *Modify* link that corresponds
    to the bank transaction that we plan to edit. This will hit the following controller
    endpoint while sending the transaction ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '`BankTransactionRecord` can be fetched via the following repository method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Since this is the transaction that should live across our wizard panels, we
    must store it in the model via the session attribute, `BANK_TRANSACTION_ATTR =
    "bt"`. Next, we must return the first panel of the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Edit bank name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we''ve edited the bank name, we must click on *Next* to submit the data.
    This reaches the following controller endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just allow Spring Boot to synchronize the `btr` session record with
    the submitted data. Next, we must return the second panel.
  prefs: []
  type: TYPE_NORMAL
- en: Edit IBAN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we''ve edited the bank name, we must edit the IBAN and click *Next* (we
    can also click *Back* and edit the bank name again). After editing the IBAN, the
    submitted data hits the controller endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Again, we allow Spring Boot to synchronize the `btr` session record with the
    submitted data. Next, we must return the third panel.
  prefs: []
  type: TYPE_NORMAL
- en: Edit the card type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we''ve edited the bank''s IBAN, we must choose the card type and click
    *Next* (we can also click *Back* and edit the bank IBAN again). After choosing
    the card type, the submitted data hits the controller endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Again, we allow Spring Boot to synchronize the `btr` session record with the
    submitted data. Next, we must return the last panel.
  prefs: []
  type: TYPE_NORMAL
- en: Edit the transferred amount
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we must edit the transferred amount and submit it to the controller
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UPDATE` method is used in a repository method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we must clean up the HTTP session to remove the updatable record.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the wizard data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is a common feature of any wizard to provide a *Reset* button for reverting
    the data from the current panel or from the entire wizard to the latest saved
    data. Our *Reset* button is relying on jOOQ''s `reset()` method to reset the wizard
    (all three panels):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can use `reset(Field`/`Name`/`String`/`int)` to implement a reset
    per panel feature. Finally, let's delete a bank transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a bank transaction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As shown in *Figure 9.5*, each panel of our wizard contains a *Delete* button,
    which allows us to delete this bank transaction. The code for its controller endpoint
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `DELETE` is rendered by a call of `delete()` in the following repository
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is called *CRUDRecords*. If you prefer to use POJOs and jOOQ's
    DAO, then check out *DaoCRUDRecords* and the REST version (for Postman, ARC, and
    so on), which is called *DaoCRUDRESTRecords*. These three applications are available
    for MySQL. For brevity, we skipped any validation and error handling code.
  prefs: []
  type: TYPE_NORMAL
- en: Using merge() versus store()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s consider the following scenario: we have loaded and displayed the payments
    (`PAYMENT`) of a certain customer (for instance, `PAYMENT.CUSTOMER_NUMBER.eq(103L)`).
    The user should be able to insert new payments for this customer or update the
    amount of an existing payment. To solve this task, we have two approaches that
    are almost the same. These are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Insert/update payment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Insert/update payment
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the design on the left-hand side, to insert a new payment, we can
    simply type a new (unique) *Check Number* (for instance, received via SMS) and
    the corresponding *Invoice Amount*. To update the *Invoice Amount* of an existing
    payment, we must type its current *Check Number* from the bottom table (for instance,
    to update the second payment from the table, we must type the *Check Number* *JM555205*).
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the right-hand side design, to insert a new payment, we just type
    the *Invoice Amount*; the *Check Number* is auto-generated and pre-filled by the
    application. However, to update the *Invoice Amount* of an existing payment, we
    must load the payment first via the corresponding *Load* link in the bottom table.
    This will fetch the corresponding payment from the database so that we can type
    in the new amount value and update it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the left-hand side design via merge()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s focus on the left-hand side design. After the user submits the payment
    form, Spring Boot creates a new `PaymentRecord` and populates it with the submitted
    data. Next, based on the submitted *Check Number*, we must determine if this is
    a new payment or an update of an existing payment to execute an `INSERT` or an
    `UPDATE`. So, it is time for `merge()` to do its job and render an SQL that delegates
    the task of choosing between `INSERT` and `UPDATE` to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: That's all the important code! Notice that, before merging, we need to attach
    the relevant `PaymentRecord`. Remember that Spring Boot has created this record,
    so it is not attached to any `Configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the complete application for this code, which is called *MergeRecords*.
    If you prefer to use POJOs and jOOQ's DAO, then check out *DaoMergeRecords*. Both
    applications are available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the right-hand side design via store()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we wish to implement the right-hand side design, then we must start by preparing
    a brand-new `PaymentRecord` (for instance, we must generate the *Check Number*)
    and storing it via an HTTP session attribute (`PAYMENT_ATTR`). This `PaymentRecord`
    is returned to the user. However, if the user wants to update the *Invoice Amount*
    of an existing payment, then they have the option to click on the corresponding
    *Load* link in the bottom table. The following query can be used to fetch the
    relevant `RecordPayment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'The fetched `PaymentRecord` overrides the one from the HTTP session and is
    returned to the user. When the user submits the data, Spring Boot synchronizes
    the `PaymentRecord` value that''s stored in `PAYMENT_ATTR` (which can be the new
    `PaymentRecord` or the fetched `PaymentRecord`) with the submitted data. This
    time, we can let jOOQ choose between `INSERT` and `UPDATE` via `store()` since
    this method distinguishes between a new `PaymentRecord` and a fetched `PaymentRecord`
    and acts accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: The application that uses `store()` is named *StoreRecords* (available for MySQL).
    Now, let's move on and talk about navigating (updatable) records.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating (updatable) records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ exposes several navigation methods that can be used for attached (updatable)
    records only (`TableRecord` and `UpdatableRecord`). To use these methods, please
    consider the following note.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: While these methods are very convenient/appealing, they are also a big N+1 risk.
    `UpdatableRecord` is great for CRUD, but if you aren't using CRUD, then you shouldn't
    use `UpdatableRecord`. It's better to project only the columns you need and try
    to use joins or other SQL utilities to fetch data from multiple tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods navigate based on the foreign key references. For instance, with
    an attached `DepartmentRecord`, we can navigate its parent (`OFFICE`) via `fetchParent(ForeignKey<R,
    O> key)`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Keys.DEPARTMENT_OFFICE_FK` foreign key was generated by the jOOQ Code
    Generator based on our `CREATE TABLE` DDL. In terms of MySQL dialect, jOOQ renders
    the following SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also fetch `Table<OfficeRecord>` via `parent()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, with an attached `OfficeRecord`, we can fetch the employees (`EMPLOYEE`)
    via `fetchChildren(ForeignKey<O,R> key)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the SQL that''s rendered for the MySQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also fetch `Table<OfficeRecord>` via `children()` (using `children()`
    is often preferable to `fetchChildren()` because it encourages writing queries
    rather than navigating `UpdatableRecord` directly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can reuse `fetchChildren()` to fetch the customers (`CUSTOMER`) of
    a certain employee (`EmployeeRecord`). This will result in every `CustomerRecord`
    of that `EmployeeRecord`. Finally, with an attached `CustomerRecord`, we can fetch
    its details (`CUSTOMERDETAIL`) via `fetchChild(ForeignKey<O, R> key)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL for the MySQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'In the bundled code (*NavigationRecords*, which is available for MySQL), you
    can see all these methods collaborating to obtain something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Navigating between records'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Navigating between records
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are also quite handy for looping the parent/children of a record
    and taking some action. Here is an example of using `fetchParent()` to fetch the
    `EmployeeRecord` details of each `SaleRecord` that has less than *2,000* sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, each call of `fetchParent()` executes a separate `SELECT`,
    which is far away from being a good choice. However, an interesting method that''s
    helpful in this case is `fetchParents()`, which can fetch all the parents of a
    list of records in a single `SELECT`. This means that we can rewrite the previous
    query like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need `Table<EmployeeRecord>`, then use `parents()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that these kinds of loops are really bad from a performance perspective!
  prefs: []
  type: TYPE_NORMAL
- en: If there's no business logic in the client, it should be a single `DELETE` statement
    with a semi-join (for instance, an `IN` predicate). So, don't take these loop
    examples at face value. I know that this approach feels easier but I strongly
    recommend avoiding it. Don't implement such loops all over the application and
    then complain about jOOQ being slow, just like when people complain about Hibernate
    being slow when these navigational loops are simply wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The only reason why anyone should ever process data row by row is that each
    row requires very complex business logic that can't be expressed in SQL or otherwise
    pushed into the database. People get this wrong in all languages, including PL/SQL.
    They loop over rows because it's convenient and they prefer 3GLs over SQL-the-4GL,
    and then they run queries on a row-by-row basis because they can. So, to justify
    the previous loops, we need to at least add some `businessLogicHere(saleRecord)`
    method calls to hint at the row-by-row approach being necessary in this particular
    case.
  prefs: []
  type: TYPE_NORMAL
- en: You can find these examples in *NavigationParentsRecords* (available for MySQL).
    Next, let's focus on using explicit transactions and jOOQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among other benefits, transactions give us the ACID properties. We can distinguish
    between *read-only* and *read-write* transactions, different isolation levels,
    different propagation strategies, and so on. While Spring Boot supports a comprehensive
    transactional API (Spring TX) that's commonly used via `@Transactional` and `TransactionTemplate`,
    jOOQ comes with a simple transaction API (and an `org.jooq.TransactionProvider`
    SPI) that fits perfectly in the context of fluent style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram highlights the main implementations of this SPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – jOOQ transaction providers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – jOOQ transaction providers
  prefs: []
  type: TYPE_NORMAL
- en: Starting with jOOQ 3.17 we have support for transactions in R2DBC as well. So,
    jOOQ 3.17 come with support for reactive transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mainly, the jOOQ API for blocking transactions can be used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have `transaction(TransactionalRunnable)`, which returns `void` and
    `transactionResult(TransactionalCallable)` for returning a result. The former
    wraps the transactional code in jOOQ's `org.jooq.TransactionalRunnable` functional
    interface, while the latter wraps the transactional code in jOOQ's `org.jooq.TransactionalCallable`
    functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the fact that, inside a jOOQ transaction, you must use `DSLContext`
    that's been obtained from the given (`configuration`, not `ctx` (the injected
    `DSLContext`).
  prefs: []
  type: TYPE_NORMAL
- en: SpringTransactionProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of Spring Boot's context, jOOQ delegates the task of handling the transactions
    (*begin*, *commit*, and *rollback*) to `SpringTransactionProvider`, an implementation
    of the `org.jooq.TransactionProvider` SPI that's meant to allow Spring Transaction
    to be used with JOOQ. By default, you'll get a *read-write* transaction with no
    name (`null`) whose propagation is set to `PROPAGATION_NESTED`, and the isolation
    level is set to the default isolation level of the underlying database; that is,
    `ISOLATION_DEFAULT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever want to decouple `SpringTransactionProvider` (for instance, to
    avoid potential incompatibilities between Spring Boot and jOOQ), then use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve decoupled `SpringTransactionProvider`, jOOQ will execute the transaction
    via the jOOQ''s `DefaultTransactionProvider` and `DefaultConnectionProvider` with
    *auto-commit* mode set to `false` (if it was `true` before the transaction, then
    jOOQ will restore it after the transaction). `DefaultTransactionProvider` supports
    nested transactions that have been implemented via JDBC''s `java.sql.Savepoint`.
    In [*Chapter 18*](B16833_18.xhtml#_idTextAnchor338), *jOOQ SPI (Providers and
    Listeners)*, you''ll learn how to implement a `TransactionProvider`, but for now,
    let''s look at some examples of jOOQ transactions. Let''s start from a simple
    transaction that highlights the commit/rollback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to handle/prevent rollbacks, then you can wrap the transactional
    code in a `try-catch` block and act as you consider; if you want to do some work
    (for instance, do some cleanup work) and roll back, then just throw the exception
    at the end of the `catch` block. Otherwise, by catching `RuntimeException`, we
    can prevent a rollback from occurring if something went wrong while executing
    the SQL statements from jOOQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: jOOQ nested transactions look like Matrioska dolls. We nest the transactional
    code by nesting calls of `transaction()`/`transactionResult()`. Here, the transactions
    will be automatically demarcated by jOOQ with savepoints. Of course, no one is
    prevented from extracting these lambdas into methods and composing them as higher-order
    functions, just like you can compose Spring-annotated transactional methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of nesting two jOOQ transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, if something goes wrong in one of the transactions, then the subsequent
    transactions (inner transactions) will not be executed and all the outer transactions
    will be rolled back. But sometimes, we may want to roll back only the current
    transaction and not affect the outer transactions, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples in *JOOQTransaction* (available for MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: ThreadLocalTransactionProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another jOOQ built-in transaction provider is `ThreadLocalTransactionProvider`.
    This provider implements thread-bound transaction semantics. In other words, a
    transaction and its associated `Connection` will never leave the thread that started
    the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: An important requirement of `ThreadLocalTransactionProvider` is that we must
    pass a custom `ConnectionProvider` implementation directly to this provider instead
    of passing it to `Configuration`. We can write our own `CustomProvider` or rely
    on a jOOQ built-one such as `MockConnectionProvider` (for tests), `DefaultConnectionProvider`,
    `DataSourceConnectionProvider`, or `NoConnectionProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we choose `DataSourceConnectionProvider`, then, in a Spring
    Boot application, we can use a `DataSource` (for instance, `HikariDataSource`)
    that has already been prepared by Spring Boot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you are using Spring Boot 2.5.0+, then you can profit from
    the `DefaultConfigurationCustomizer` functional interface. This interface defines
    a method called `customize(DefaultConfiguration configuration)`, which is a handy
    way to customize jOOQ''s `DefaultConfiguration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, we can inject the `DSLContext` information that's been built by Spring
    Boot based on our `Configuration` and take advantage of thread-bound transaction
    semantics, which is usually exactly what Spring uses. You can check out an example
    by looking at *ThreadLocalTransactionProvider{1,2}*, which is available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about jOOQ asynchronous transactions.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ asynchronous transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `transaction()` and `transactionResult()` are synchronous, jOOQ also
    has `transactionAsync()` and `transactionResultAsync()`, which can be used to
    shape asynchronous transactions. Here are two asynchronous transactions that act
    independently of each other – they run in concurrent threads. The first one commits,
    while the second one rolls back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: If you don't want to rely on the default `Executor` (`ForkJoinPool.commonPool()`),
    then use `transactionAsync(Executor exctr, TransactionalRunnable tr)` or `transactionResultAsync(Executor
    exctr, TransactionalCallable<T> tc)`, respectively. But unlike what `CompletableFuture`
    does, jOOQ will remember `Executor` in its `CompletionStage` implementation so
    that it doesn't have to be provided on every ensuing asynchronous call.
  prefs: []
  type: TYPE_NORMAL
- en: However, asynchronous transactions work very badly with Spring, which usually
    assumes thread-bound transactions. Go to [https://github.com/spring-projects/spring-boot/issues/24049](https://github.com/spring-projects/spring-boot/issues/24049)
    to see a discussion about this.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the complete code in *JOOQTransactionAsync* (available for MySQL).
    Next, let's look at some examples of using/choosing `@Transactional` or the jOOQ
    transaction API.
  prefs: []
  type: TYPE_NORMAL
- en: '@Transactional versus the jOOQ transaction API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right off the bat, I wish to enforce an important note (most of you probably
    already know and respect these statements, but a quick reminder is always welcome).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A non-transactional-context refers to a context with no explicit transaction
    boundaries, *not* to a context with no physical database transaction. All database
    statements are executed in the context of a physical database transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Without specifying the explicit boundaries of the transaction (via `@Transactional`,
    `TransactionTemplate`, the jOOQ transaction API, and so on), jOOQ *may* use a
    different database connection for each statement. Whether or not jOOQ uses a different
    connection per statement is defined by `ConnectionProvider`. This statement is
    true for `DataSourceConnectionProvider` (and even then, it depends on `DataSource`)
    but false for `DefaultConnectionProvider`. In the worst-case scenario, this means
    that the statements that define a *logical transaction* don't benefit from ACID
    and they are prone to lead to *race condition* bugs and SQL *phenomena*. Each
    statement is executed in a separate transaction (*auto-commit* mode), which may
    result in a high database connection acquisition request rate, which is not good!
    On medium/large applications, reducing the database connection acquisition request
    rate next to short transactions will sustain performance since your application
    will be ready to face high traffic (a high number of concurrent requests).
  prefs: []
  type: TYPE_NORMAL
- en: Never combine `@Transactional`/`TransactionTemplate` and the jOOQ transaction
    API to solve a task in common (the same is true for Java/Jakarta EE transactions,
    of course). This may lead to unexpected behaviors. So long as Spring transactions
    and jOOQ transactions are not interleaved, it is safe to use them in the same
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to use Spring transactions *only* consists of annotating your repository/service
    class with `@Transactional(readOnly=true)` and explicitly setting `@Transactional`
    only on methods that should be allowed to execute write statements. However, if
    the same repository/service uses jOOQ transactions as well, then you should explicitly
    annotate each method, not the class itself. This way, you avoid inheriting `@Transactional(readOnly=true)`
    in methods that explicitly use jOOQ transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider several examples that are meant to reveal the best practices
    for using transactions. Let''s start with the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'This method runs in a non-transactional context and executes two read statements.
    Each read is executed by the database in a separate physical transaction that
    requires a separate database connection. Keep in mind that this may not be true,
    depending on `ConnectionProvider`. Relying on `@Transactional(readOnly=true)`
    is much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: This time, a single database connection and a single transaction are used. `readOnly`
    come with a bunch of advantages, including that your team members cannot accidentally
    add write statements (such attempt result in an error), read-only transactions
    can be optimized at the database level (this is database vendor-specific), you
    must explicitly set the transaction isolation level as expected, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, having no transaction and setting auto-commit to `true` only makes
    sense if you execute a single read-only SQL statement, but it doesn't lead to
    any significant benefit. Therefore, even in such cases, it's better to rely on
    explicit (declarative) transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you consider that the `readOnly=true` flag isn''t needed, then
    the following code can be executed in a jOOQ transaction as well (by default,
    this is a read-write transaction):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, exactly like Spring''s `TransactionTemplate` (which can be used
    as well), the jOOQ transaction can strictly demarcate the transactional code.
    In other words, the `@Transactional` annotation acquires the database connection
    and starts the transaction immediately when entering the method. Then, it commits
    the transaction at the end of the method. This means that the potentially non-transactional
    code of a `@Transactional` method (the code that shapes business logic that doesn''t
    need to run in a transaction) still runs inside the current transaction, which
    can lead to a long-running transaction. On the other hand, jOOQ transactions (just
    like `TransactionTemplate`) allow us to isolate and orchestrate the transactional
    code to run in transactions and the rest of the code outside of transactions.
    Let''s look at a scenario where using a jOOQ transaction (or `TransactionTemplate`)
    is a better choice than using `@Transactional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, jOOQ fetches the whole result set into memory via the connection
    that''s been opened by `@Transactional`. This means that the streaming operations
    (for instance, `map()`) don''t need transactions, but Spring will close this transaction
    at the end of the method. This can result in a potentially long-running transaction.
    While we can avoid this issue by splitting the code into separate methods, we
    can also rely on a jOOQ transaction (or `TransactionTemplate`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: This is much better because we've removed the streaming operations from the
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of executing one or more DML operations in a method, it should be
    annotated with `@Transactional`, explicitly use the jOOQ transaction API, or use
    `TransactionTemplate` to demarcate the transactional code. Otherwise, Spring Boot
    will report an `SQLException`: *Connection is read-only. Queries leading to data
    modification are not allowed*. You can see such an example next to the previous
    examples in *SpringBootTransactional* (available for MySQL).'
  prefs: []
  type: TYPE_NORMAL
- en: It is a well-known shortcoming of Spring transactions that `@Transactional`
    is ignored if it is added to a `private`, `protected`, or package-protected method
    or to a method that's been defined in the same class as where it is invoked. By
    default, `@Transactional` only works on `public` methods that should be added
    to classes and are different from where they are invoked. However, this issue
    can easily be avoided by using the jOOQ transaction API or `TransactionTemplate`,
    which don't suffer from these issues. You can explore some examples by looking
    at the *JOOQTransactionNotIgnored* application (available for MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: A strong argument for choosing the Spring transactions for our jOOQ queries
    is that we can benefit from Spring transactions' isolation levels and propagation
    strategies. In the bundled code, you can find a suite of seven applications –
    one for each of the seven propagation levels supported by Spring transactions
    – that exemplifies the usage of jOOQ queries and Spring transaction propagations.
    These applications are called *Propagation{Foo}* and are available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, jOOQ queries can be used in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: Only with Spring transactions (you can take advantage of Spring transactions'
    features at full capacity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only with jOOQ transactions (in the context of Spring Boot, you'll get read-write,
    nested transactions that rely on the database's isolation level)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining them without interleaving Spring with jOOQ transactions to accomplish
    common tasks (in other words, once you open a Spring transaction, ensure that
    any subsequent inner transaction is a Spring one as well. If you open a jOOQ transaction,
    then ensure that any subsequent inner transaction is a jOOQ one.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking reactive transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, starting with jOOQ 3.17, we can take advantage of reactive
    transactions or transactions in R2DBC. Reactive transactions are easy to use via
    `Publisher`, as they have the same semantics as JDBC’s blocking APIs Here is an
    example of how to write a nested reactive transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: Being in Spring Boot, this example relies on Project Reactor ([https://projectreactor.io/](https://projectreactor.io/)),
    but you can use any other reactive library. More examples are available in the
    bundled code for MySQL, *jOOQReactiveTransaction*.
  prefs: []
  type: TYPE_NORMAL
- en: Locking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Locking** is used to orchestrate concurrent access to data to prevent *race
    condition* threads, deadlocks, *lost updates*, and other SQL *phenomena*.'
  prefs: []
  type: TYPE_NORMAL
- en: Among the most popular locking mechanisms, we have **optimistic** and **pessimistic**
    *locking*. As you'll see shortly, jOOQ supports both of them for CRUD operations.
    So, let's start with *optimistic locking*.
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic locking overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Optimistic locking* is commonly related to the **lost updates** SQL phenomena,
    so let''s quickly overview this anomaly.'
  prefs: []
  type: TYPE_NORMAL
- en: A *lost update* is a popular anomaly that can seriously affect data integrity.
    A transaction reads a record and uses this information to make business decisions
    (for instance, decisions that may lead to that record being modified) without
    being aware that, in the meantime, a concurrent transaction has modified that
    record and committed it. When the first transaction commits, it is unaware of
    the lost update. This may cause data integrity issues (for example, the inventory
    can report a negative value, a certain payment can be lost, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the scenario shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Lost update phenomena'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Lost update phenomena
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take this scenario step-by-step, then the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: John and Mary fetch the invoice amount (*2,300*) of the same payment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mary considers that the current invoice amount is too much, so she updates the
    amount from *2,300* to *2,000*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: John's transaction is not aware of Mary's update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: John considers that the current invoice amount is not enough, so he updates
    the amount to *2,800*, without being aware of Mary's decision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This anomaly affects the **Read Committed** isolation level and can be avoided
    by setting the **Repeatable Read** or **Serializable** isolation level. For the
    **Repeatable Read** isolation level without **Multi-Version Concurrency Control**
    (**MVCC**), the database uses shared locks to reject other transactions' attempts
    to modify an already fetched record.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the presence of MVCC databases, there is no need for locks since
    we can use the application-level optimistic locking mechanism. Typically, application-level
    optimistic locking starts by adding an integer field (typically named `version`)
    to the corresponding table(s). By default, this field is 0, and each `UPDATE`
    attempts to increment it by 1, as shown in the following diagram (this is also
    known as *versioned* optimistic locking):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Versioned optimistic locking (via numeric field)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – Versioned optimistic locking (via numeric field)
  prefs: []
  type: TYPE_NORMAL
- en: This time, John is aware of Mary's decision, so he can make further decisions
    based on this information. In application-level optimistic locking, the application
    is responsible for handling the `version` field. The application should set the
    `version` value and append the proper `WHERE` clause to the executed `UPDATE`/`DELETE`
    to check the `version` value against the database. Moreover, if no `UPDATE`/`DELETE`
    has happened because `WHERE version=?` failed, then the application is responsible
    for signaling this behavior, meaning that the corresponding transaction contains
    *stale* data. Commonly, it does this by throwing a meaningful exception. As you'll
    see next, jOOQ aligns with this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: With long conversations that span several (HTTP) requests, besides the application-level
    optimistic locking mechanism, you must keep the old data snapshots (for instance,
    jOOQ updatable records). In web applications, they can be stored in the HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ optimistic locking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the jOOQ optimistic locking mechanism for CRUD operations is disabled.
    It can be enabled via the `withExecuteWithOptimisticLocking()` setting, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can toggle this setting locally by using a `Configuration` as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ optimistic locking via SELECT … FOR UPDATE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, without further settings, jOOQ will intercept any CRUD `UPDATE`/`DELETE`
    (executed explicitly via `update()`/`delete()` or generated via `merge()`/`store()`),
    and will attempt to determine if the record contains *stale* data. For this, jOOQ
    acquires a database-exclusive read/write lock for the involved data via `SELECT
    … FOR UPDATE`, which is practically done via pessimistic locking. Next, jOOQ compares
    the fetched data with the data to be updated/deleted. Practically, the fetched
    data is compared against the *original* values of the record to be updated/deleted.
    If the record data is not *stale*, then jOOQ executes `UPDATE`/`DELETE` against
    the database; otherwise, it will throw a specific `org.jooq.exception.DataChangedException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, before updating the amount of a payment (`PAYMENT.INVOICE_AMOUNT`),
    jOOQ will execute the following `SELECT` (MySQL dialect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite easy to enable this type of optimistic locking, but it has two
    main shortcomings: it uses exclusive locks and is applied to all CRUD `DELETE`/`UPDATE`,
    which means it''s also applied to all tables.'
  prefs: []
  type: TYPE_NORMAL
- en: However, jOOQ also supports optimistic locking via the TIMESTAMP or VERSION
    fields. This kind of implementation is more popular, so let's look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ optimistic locking via the TIMESTAMP/VERSION fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already know from the previous section that jOOQ optimistic locking is enabled
    via the `withExecuteWithOptimisticLocking(true)` flag. Next, we must add a field
    of the `TIMESTAMP` type (for TIMESTAMP optimistic locking) or the `INT` type (for
    VERSION optimistic locking) for the corresponding table(s). For instance, let''s
    add the `PAYMENT` table (for the MySQL dialect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you don''t have to add both of them! Decide what type of optimistic
    locking you need and add the corresponding field. Next, we must inform the jOOQ
    Code Generator about the fact that these fields should be used for optimistic
    locking. We can do so programmatically or declaratively. For Maven applications,
    you can do this via `<recordVersionFields/>` or `recordTimestampFields/>`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: For Gradle, please look at the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, jOOQ optimistic locking based on the TIMESTAMP/VERSION fields
    is ready to be used. Two jOOQ flags are useful for controlling (enable/disable)
    optimistic locking based on the TIMESTAMP/VERSION fields. These two flags are
    set to `true` by default (`withUpdateRecordVersion()` and `withUpdateRecordTimestamp()`),
    so you don't have to enable them explicitly. However, you can use them to disable
    this type of optimistic locking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, at this point, there is an important aspect that you should be
    aware of. So far, jOOQ uses optimistic locking based on the TIMESTAMP/VERSION
    fields for any record of the `PaymentRecord` type, that is updated/deleted, but
    it still employees `SELECT … FOR UPDATE` for the rest of the records that execute
    CRUD `UPDATE`/`DELETE` statements. If this is not what you need, then you can
    explicitly enable the jOOQ flag setting (disabled by default); that is, `withExecuteWithOptimisticLockingExcludeUnversioned()`.
    For instance, you can instruct jOOQ to use only optimistic locking based on the
    TIMESTAMP/VERSION fields, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we group all these settings into a logical diagram, we can obtain something:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – jOOQ optimistic locking settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – jOOQ optimistic locking settings
  prefs: []
  type: TYPE_NORMAL
- en: If you can choose between versions and timestamps, then go for versions. jOOQ
    has to support timestamps too if a legacy system uses them, or for quick wins,
    but with timestamps, there's always the risk of a lack of precision. For instance,
    when two updates happen in a very short time, the timestamps may still be the
    same. This can't happen with versions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's try to apply the jOOQ optimist locking based on the VERSION field
    to the *StoreRecords* application (the application that's available for MySQL
    that uses `store()` was created in the *Using merge() versus store()* section).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I assume that you are already familiar with the *StoreRecords* code that shapes
    the following scenario: we must load and display the payments (`PAYMENT`) of a
    certain customer (for instance, `PAYMENT.CUSTOMER_NUMBER.eq(103L)`). The user
    should be able to insert new payments for this customer or update the amount of
    an existing payment via a user interface, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – INSERT/UPDATE PAYMENT'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – INSERT/UPDATE PAYMENT
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, we use `store()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: Here, if two concurrent transactions update the same payment, then our code
    is prone to the *lost updates* anomaly, so we must engage in optimistic locking.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve already added the `version` field to `PAYMENT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also added the settings for enabling jOOQ optimistic locking based
    on the VERSION field, so we have set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good! From the perspective of optimistic locking, the interesting
    part starts when we call the `store()` method. If we attempt to store a new `PaymentRecord`,
    then `store()` will produce an `INSERT` statement that is not affected by optimistic
    locking. However, if this `PaymentRecord` needs to be updated, then optimistic
    locking will enrich the `WHERE` clause of the generated `UPDATE` (the same goes
    for `DELETE`) with an explicit check of the `version` number, as shown in the
    following MySQL `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `version` number from the database doesn''t match the version number
    from the `WHERE` clause, then this record contains *stale* data (another transaction
    has modified this data). This will lead to a jOOQ `DataChangedException` that
    can be handled in our controller endpoint, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if `DataChangedException` occurs, then we must add a global error in `BindingResult`
    that contains the message *Another user updated the data*. This message will be
    rendered via Thymeleaf next to a button labeled *Refresh*, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Signaling stale data to the user'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Signaling stale data to the user
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember jOOQ''s `refresh()` method? This is the perfect place to highlight
    its usability because the user should see the latest state of the record. This
    is the perfect job for `refresh()`. In this case, the `reset()` method doesn''t
    help since `reset()` restores the record to its in-memory original values, which
    is a different thing. So, let''s use `refresh()` to execute a `SELECT` that will
    fetch the latest state of this `PaymentRecord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: 'After refreshing, the user sees the data that was updated earlier by the concurrent
    transaction and can decide whether they wish to continue with their update. To
    reproduce this scenario, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch two browsers (mainly, two users or HTTP sessions).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In both, use the *Load* link to fetch the same payment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For user A, update the invoice amount and click *Finish*. This should successfully
    update the payment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For user B, update the invoice amount and click *Finish*. Since user A already
    updated this payment, you should see the message shown in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click *Refresh*. Now, you should see the invoice amount that was set by user
    A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For user B, try to update again. This time, it will work as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a conclusion, if an explicit `UPDATE`/`DELETE` or `UPDATE` resulted from
    calling `store()`, jOOQ VERSION/TIMESTAMP optimistic locking will enrich the `WHERE`
    clause of the generated `UPDATE`/`DELETE` with an explicit check of the numeric
    values of timestamp fields. In the case of calling `merge()`, an explicit `INSERT`
    or `UPDATE` is rendered, depending on whether the numeric/timestamp values are
    present or not in the record.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this example can be found in *OLVersionStoreRecords*.
    The alternative, which is for using a TIMESTAMP field, can be found in *OLTimestampStoreRecords*.
    Finally, the `SELECT … FOR UPDATE` solution can be found in *OLPLStoreRecords*.
    All of them are available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Retrying a failed transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's consider that our scenario gets updated. If a transaction didn't update
    a payment with an invoice amount larger than the current amount, then this transaction
    should be retried without user interaction (so, in this case, we don't care about
    the lost updates). Otherwise, the user should see the current amount and perform
    the update from the interface (there will be no *Refresh* button since the refresh
    should be done automatically).
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can we retry a failed transaction from the application? In Spring Boot,
    this is equivalent to executing the failed `@Transactional storePayment(PaymentRecord
    pr)` method again, which can be done via Spring Retry. Once you''ve added Spring
    Retry (see the bundled code), you must adjust the `storePayment(PaymentRecord
    pr)` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: So, this time, we catch `DataChangedException` and analyze the *current* value
    of the invoice amount against the refreshed record (the latest state from the
    database). If the current amount is larger than the fetched amount, then we set
    it in place of the fetched amount and throw the caught `DataChangedException`.
    This will trigger the Spring Retry mechanism, will should retry this transaction.
    Otherwise, we must throw a custom `OptimisticLockingRetryFailed` exception, which
    will lead to an explicit message for the user. You can practice this example in
    *OLRetryVersionStoreRecords* (available for MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: Pessimistic locking overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pessimistic locking is about locking rows (or cells) via exclusive/shared locks
    until the transaction that acquired these locks finishes its tasks. Depending
    on the lock's strength, other transactions may partially interact with these rows/cells
    or they will have to abort or wait for the resource to become available (lock-free).
    From the well-known `SELECT … FOR UPDATE` (exclusive read/write lock for rows
    (record lock)) and `SELECT … FOR UPDATE OF` (exclusive read/write locks for cells
    specific to Oracle) to `SELECT … FOR UPDATE NOWAIT` and `SELECT … FOR UPDATE WAIT
    n` (also specific to Oracle), to the more relaxed `SELECT ... FOR UPDATE SKIP
    LOCKED`, `SELECT … FOR SHARE`, and PostgreSQL-specific `SELECT … FOR NO KEY UPDATE` and `SELECT
    … FOR KEY SHARE`, jOOQ supports them all.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ pessimistic locking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in the *Pessimistic locking overview* section, jOOQ supports
    a significant number of locks of the `SELECT … FOR FOO` type. For instance, we
    can explicitly call `SELECT … FOR UPDATE` via `forUpdate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'If transaction A executes this statement, then it locks the corresponding rows.
    The other transaction, transaction B, must wait for transaction A to release this
    exclusive lock before performing its tasks on the same resource. Check out this
    scenario in the *ForUpdate* application (available for MySQL) – pay attention
    that this application results in an exception: `MySQLTransactionRollbackException`:
    *Lock wait timeout exceeded; try restarting transaction*. Also, check out *ForUpdateForeignKey*
    (available for PostgreSQL) – this example highlights the effect of `FOR UPDATE`
    on foreign keys that''s caused by the fact this lock affects the referenced rows
    from other tables as well, not just the rows from the current table.'
  prefs: []
  type: TYPE_NORMAL
- en: So, remaining in the same context, `SELECT … FOR UPDATE` locks all the selected
    rows across all the involved tables (listed in the `FROM` clause, joined, and
    so on). If table X and table Y are involved in such a case, then `SELECT … FOR
    UPDATE` locks the rows of both tables, even if transaction A affects only rows
    from table X. On the other hand, transaction B needs to acquire locks from table
    Y, but it cannot do so until transaction A releases the locks on tables X and
    Y.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such scenarios, Oracle has `SELECT … FOR UPDATE OF`, which allows us to
    nominate the columns that should be locked. In this case, Oracle only acquires
    locks on the rows of the table(s) that have the column name listed in `FOR UPDATE
    OF`. For instance, the following statements only lock rows from `PRODUCTLINE`,
    even if the `PRODUCT` table is also involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `PRODUCT` table isn''t locked, another statement can obtain locks
    on its rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: If we remove `.of(PRODUCT.PRODUCT_NAME)`, then this statement will attempt to
    lock rows from `PRODUCTLINE` as well, so it will have to wait for the lock to
    release on that table. You can check out this example by going to the *ForUpdateOf*
    application (available for Oracle).
  prefs: []
  type: TYPE_NORMAL
- en: 'If a transaction were to acquire a lock or fail immediately, then we should
    use `SELECT … FOR UPDATE NOWAIT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the transaction needs to wait for a fixed amount of time, then
    we must rely on the `SELECT … FOR UPDATE WAIT n` lock (Oracle), where `n` is the
    time to wait, given in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check out an example in *ForUpdateWait* (available for Oracle). As
    you''ll see, transaction A acquires a lock immediately, while transaction B waits
    for a certain amount of time before acquiring a lock on the same resource. If
    this time expires before transaction A releases the lock, then you''ll get an
    error stating *ORA-30006: resource busy; acquire with WAIT timeout expired*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following scenario: to provide a high-quality description
    of products, we have reviewers that analyze each product and write a proper description.
    Since this is a concurrent process on the `PRODUCT` table, the challenge consists
    of coordinating the reviewers so that they don''t review the same product at the
    same time. To pick a product for review, the reviewer should skip the products
    that have already been reviewed (`PRODUCT.PRODUCT_DESCRIPTION.eq("PENDING")`)
    and the products that are currently in review. This is what we call a concurrent
    table-based queue (also known as job queues or batch queues).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a job for `SKIP LOCKED`. This SQL option is available in many databases
    (Oracle, MySQL 8, PostgreSQL 9.5, and so on) and it instructs the database to
    skip the locked rows and to lock the rows that have not been locked previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: If transaction A executes this statement, then it may lock the `PENDING` products
    with IDs *1*, *2*, and *3*. While transaction A holds this lock, transaction B
    executes the same statement and will lock the `PENDING` products with IDs *4*,
    *5*, and *6*. You can see this scenario in *ForUpdateSkipLocked* (available for
    MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'A weaker form of `SELECT … FOR UPDATE` is the `SELECT … FOR SHARE` query. This
    ensures referential integrity when inserting child records for a parent. For instance,
    transaction A executes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: 'However, transaction B cannot `UPDATE` if transaction A holds the `SHARE` lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, transaction C cannot `DELETE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: You can check out this example in *ForShare* (available for PostgreSQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with version 9.3, PostgreSQL supports two more locking clauses: `SELECT
    … FOR NO KEY UPDATE` and `SELECT … FOR KEY SHARE`. The former acts similarly to
    the `FOR UPDATE` locking clause but it does not block `SELECT … FOR KEY SHARE`.
    For instance, transaction A uses `SELECT … FOR NO KEY UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if transaction A holds a lock on this resource, transaction B can acquire
    a `SELECT … FOR KEY SHARE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'However, transaction C cannot acquire a `SELECT … FOR SHARE` on this resource
    if transaction A doesn''t release its lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: You can check out this example in *ForNoKeyUpdate* (available for PostgreSQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `SELECT … FOR KEY SHARE` is the weakest lock. For instance, transaction
    A acquires the following type of lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'While transaction A holds this lock, transaction B can perform updates if it
    doesn''t attempt to update `SALE_ID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'Transaction B will have to wait for transaction A to release the lock since
    it attempts to update `SALE_ID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, transaction C cannot `DELETE` if transaction A holds the `KEY SHARE`
    lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: You can see this example in *ForNoKeyUpdate* (available for PostgreSQL).
  prefs: []
  type: TYPE_NORMAL
- en: Deadlocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deadlocks are not specific to databases – they can occur in any scenario involving
    a concurrency environment (concurrency control) and they mainly define a situation
    when two processes cannot advance because they are waiting for each other to finish
    (release the lock). In the case of a database, a classical deadlock can be represented
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – A classical case of a deadlock'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – A classical case of a deadlock
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have two transactions that don't use explicit locks (the database itself
    relies on locks since it detects whether a transaction has attempted to modify
    data). Transaction A has acquired a lock on the `SALE` resource, and it doesn't
    release it until it manages to acquire another lock on the `ORDER` resource, which
    is currently locked by transaction B. At the same time, transaction B holds a
    lock on the `ORDER` resource, and it doesn't release it until it manages to acquire
    a lock on the `SALE` resource, which is currently locked by transaction A. You
    can see this scenario exemplified in *Deadlock* (available for MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, using explicit locks doesn''t mean that deadlocks cannot happen anymore.
    For instance, in *DeadlockShare* (available for MySQL), you can see explicit usage
    of `SELECT … FOR SHARE` that causes a deadlock. It is very important to understand
    what each type of lock does and what other locks are permitted (if any) while
    a certain lock is present. The following table covers the common locks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Lock acquisition permissions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_9.15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Lock acquisition permissions
  prefs: []
  type: TYPE_NORMAL
- en: Databases automatically scan transactions to discover deadlocks (or the so-called
    lock-wait cycles). When a deadlock occurs, the database attempts to fix it by
    aborting one of the transactions. This releases the lock and allows the other
    transaction to progress. In this context, always rely on `NOWAIT` or explicit
    short timeouts to avoid deadlocks. While the database can recover after a deadlock,
    it can only do so after the timeout (if any). So, a long timeout means keeping
    a database connection busy for a long time, and this is a performance penalty.
    Moreover, locking too much data may affect scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm glad that you've come this far and that we've managed to cover the three
    main topics of this chapter – CRUD, transactions, and locking. At this point,
    you should be familiar with jOOQ UpdatableRecords and how they work in the context
    of CRUD operations. Among other things, we've learnt about cool stuff such as
    the must-know `attach()`/`detach()`, the handy `original()` and `reset()`, and
    the fancy `store()` and `refresh()` operations. After that, we learned how to
    handle transactions in the context of Spring Boot and jOOQ APIs before tackling
    optimistic and pessimistic locking in jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to batching, bulking and loading files
    into the database via jOOQ. We'll also do single-thread and multi-thread batching.
  prefs: []
  type: TYPE_NORMAL
