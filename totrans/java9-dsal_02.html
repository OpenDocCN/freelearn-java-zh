<html><head></head><body>
<div class="book" title="Chapter&#xA0;2.&#xA0;Cogs and Pulleys &#x2013; Building Blocks" id="I3QM1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Cogs and Pulleys – Building Blocks</h1></div></div></div><p class="calibre8">We discussed algorithms in the previous chapter, but the title of the book also includes the term "data structure." So what is a data structure? A data structure is an organization of data in memory that is<a id="id24" class="calibre1"/> generally optimized so it can be used by a particular algorithm. We have seen that an algorithm is a list of steps that leads to a desired outcome. In the case of a program, there is always some input and output. Both input and output contain data and hence must be organized in some way or another. Therefore, the input and output of an algorithm are data structures. In fact, all the intermediate states that an algorithm has to go through must also be stored in some form of a data structure. Data structures don't have any use without algorithms to manipulate them, and algorithms cannot work without data structures. It's because this is how they get input and emit output or store their intermediate states. There are a lot of ways in which data can be organized. Simpler data structures are also different types of variables. For example, <code class="email">int</code> is a data structure that stores one 4-byte integer value. We can even have classes that store a set of specific types of values. However, we also need to think about how to store a collection of a large number of the same type of values. In this book, we will spend the rest of the time discussing a collection of values of the same type because how we store a collection determines which algorithm can work on them. Some of the most common ways of storing a collection of values have their own names; we will discuss them in this chapter. They are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Arrays</li><li class="listitem">Linked lists</li><li class="listitem">Doubly linked lists</li><li class="listitem">Circular linked lists</li></ul></div><p class="calibre8">These are the basic building blocks that we will use to build more complex data structures. Even if we don't use them directly, we will use their concepts.</p></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Cogs and Pulleys &#x2013; Building Blocks" id="I3QM1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Arrays"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec12" class="calibre1"/>Arrays</h1></div></div></div><p class="calibre8">If you are a <a id="id25" class="calibre1"/>Java programmer, you must have worked with arrays. Arrays are the basic storage mechanisms available for a sequence of data. The best thing about arrays is that the elements of an array are collocated sequentially and can be accessed completely and randomly with single instructions.</p><p class="calibre8">The traversal of an array element by an element is very simple. Since any element can be accessed randomly, you just keep incrementing an index and keep accessing the element at this index. The following code shows both traversal and random access in an array:</p><div class="informalexample"><pre class="programlisting">    public static void printAllElements(int[] anIntArray){ 
        for(int i=0;i&lt;anIntArray.length;i++){ 
            System.out.println(anIntArray[i]); 
        } 
    }</pre></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Cogs and Pulleys &#x2013; Building Blocks" id="I3QM1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Arrays">
<div class="book" title="Insertion of elements in an array"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec10" class="calibre1"/>Insertion of elements in an array</h2></div></div></div><p class="calibre8">All the elements in an array are stored in contiguous memory. This makes it possible to access any<a id="id26" class="calibre1"/> element in a constant amount of time. A program simply needs to compute the offset that corresponds to an index, and it reads the information directly. But this means they are also limited and have a fixed size. If you want to insert a new element into an array, you will need to create a new array with one more element and copy the entire data from the original data along with the new value. To avoid all this complexity, we will start with moving an existing element to a new position. What we are looking to do is to take an element out, shift all the elements up to the target position to make space in this position, and insert the value we extracted in the same place.</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00003.jpeg" alt="Insertion of elements in an array" class="calibre9"/><div class="caption"><p class="calibre15">Figure 1: Insertion of an existing array element into a new location</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">The preceding <a id="id27" class="calibre1"/>figure explains what we mean by this operation. The thin black arrows show the movement of the element that is being reinserted, and the thick white arrow shows the shift of the elements of the array. In each case, the bottom figure shows the array after the reinsertion is done. Notice that the shifting is done either to the left or right, depending on what the start and end index are. Let's put this in code:</p><div class="informalexample"><pre class="programlisting">       public static void insertElementAtIndex(int[] array, int startIndex, int targetIndex){ 
         int value = array[startIndex]; 
         if(startIndex==targetIndex){ 
            return; 
         }else if(startIndex &lt; tarGetIndex){ 
            for(int i=startIndex+1;i&lt;=targetIndex;i++){ 
                array[i-1]=array[i]; 
            } 
            array[targetIndex]=value; 
         }else{ 
            for(int i=startIndex-1;i&gt;=targetIndex;i--){ 
                array[i+1]=array[i]; 
            } 
            array[targetIndex]=value; 
         } 
       }</pre></div><p class="calibre8">What would be the<a id="id28" class="calibre1"/> running time complexity of the preceding algorithm? For all our cases, we will only consider the worst case. When does an algorithm perform worst? To understand this, let's see what the most frequent operation in an algorithm is. It is of course the shift that happens in the loop. The number of shifts become maximum when <code class="email">startIndex</code> is at the beginning of the array and <code class="email">targetIndex</code> at the end or vice versa. This is when all but one element has to be shifted one by one. The running time in this case must be some constant times the number of elements of the array plus some other constant to account for the non-repeating operations. So it is <span class="strong"><em class="calibre12">T(n) =  K(n-1)+C</em></span> for some constants <span class="strong"><em class="calibre12">K</em></span> and <span class="strong"><em class="calibre12">C</em></span>, where <span class="strong"><em class="calibre12">n</em></span> is the number of elements in the array and <span class="strong"><em class="calibre12">T(n)</em></span> is the running time of the algorithm. This can be expressed as follows:</p><p class="calibre8">
<span class="strong"><em class="calibre12">T(n) = K(n-1)+C = Kn + (C-K)</em></span>
</p><p class="calibre8">The following steps explain the expression:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">As per rule 1 of the definition of <span class="strong"><strong class="calibre2">big O</strong></span>, <span class="strong"><em class="calibre12">T(n) = O(Kn + (C-K))</em></span>.</li><li class="listitem" value="2">As per rule 3, <span class="strong"><em class="calibre12">T(n) = O(Kn)</em></span>.</li><li class="listitem" value="3">We know<span class="strong"><em class="calibre12"> |-(C-K)| &lt; |Kn + (C-K)|</em></span> is true for sufficiently large <span class="strong"><em class="calibre12">n</em></span>. Therefore, as per rule 3, since <span class="strong"><em class="calibre12">T(n) = O(Kn + (C-K))</em></span>, it means <span class="strong"><em class="calibre12">T(n) = O(Kn + (C-K) + (-(C-K)))</em></span>, that is, <span class="strong"><em class="calibre12">T(n) = O(Kn)</em></span>.</li><li class="listitem" value="4">And, finally, as per rule 2, <span class="strong"><em class="calibre12">T(n) = O(n)</em></span>.</li></ol><div class="calibre13"/></div><p class="calibre8">Now since the array is the major input in the algorithm, the size of the input is represented by <span class="strong"><em class="calibre12">n</em></span>. So we will say, the running time of the algorithm is <span class="strong"><em class="calibre12">O(n)</em></span>, where <span class="strong"><em class="calibre12">n</em></span> is the size of the input.</p></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Cogs and Pulleys &#x2013; Building Blocks" id="I3QM1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Arrays">
<div class="book" title="Insertion of a new element and the process of appending it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec11" class="calibre1"/>Insertion of a new element and the process of appending it</h2></div></div></div><p class="calibre8">Now we<a id="id29" class="calibre1"/> move on to the process of insertion of a new element. Since<a id="id30" class="calibre1"/> arrays are fixed in size, insertion requires us to create a new array and copy all the earlier elements into it. The following figure explains the idea of an insertion made in a new array:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Insertion of a new element and the process of appending it" class="calibre9"/><div class="caption"><p class="calibre15">Figure 2: Insertion of a new element into an array</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">The <a id="id31" class="calibre1"/>following code does exactly that:</p><div class="informalexample"><pre class="programlisting">    public static int [] insertExtraElementAtIndex(int[] array, int index, int value){ 
        int [] newArray = new int[array.length+1]; </pre></div><p class="calibre8">First, you <a id="id32" class="calibre1"/>copy all the elements before the targeted position as they are in the original array:</p><div class="informalexample"><pre class="programlisting">        for(int i=0;i&lt;index;i++){ 
            newArray[i] = array[i]; 
        } </pre></div><p class="calibre8">Then, the new value must be put in the correct position:</p><div class="informalexample"><pre class="programlisting">        newArray[index]=value;</pre></div><p class="calibre8">In the end, copy the rest of the elements in the array by shifting their position by one:</p><div class="informalexample"><pre class="programlisting">        for(int i=index+1;i&lt;newArray.length;i++){ 
            newArray[i]=array[i-1]; 
        } 
        return newArray; 
    }</pre></div><p class="calibre8">When we have the code ready, appending it would mean just inserting it at the end, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    public static int[] appendElement(int[] array, int value){ 
        return insertExtraElementAtIndex(array, array.length, value); 
    }</pre></div><p class="calibre8">What is the running time complexity of the preceding algorithm? Well, no matter what we do, we must copy all the elements of the original array to the new array, and this is the operation in<a id="id33" class="calibre1"/> the loop. So the running time is <span class="strong"><em class="calibre12">T(n) = Kn + C</em></span> for <a id="id34" class="calibre1"/>some constants <span class="strong"><em class="calibre12">K</em></span> and <span class="strong"><em class="calibre12">C</em></span>, and <span class="strong"><em class="calibre12">n</em></span> is the size of the array, which is the size of the input. I leave it to you to verify the steps in order to figure out this: <span class="strong"><em class="calibre12">T(n) = O(n)</em></span>.</p></div></div></div>

<div class="book" title="Linked list"><div class="book" id="J2B82-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>Linked list</h1></div></div></div><p class="calibre8">Arrays are great<a id="id35" class="calibre1"/> for storing data. We have also seen that any element of an array can be read in <span class="strong"><em class="calibre12">O(1)</em></span> time. But arrays are fixed in size. Changing the size of an array means creating a new array and copying all the elements to the original array. The simplest recourse to the resizing problem is to store each element in a different object and then hold a reference in each element to the next element. This way, the process of adding a new element will just involve creating the element and attaching it at the end of the last element of the original linked list. In another variation, the new element can be added to the beginning of the existing linked list:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Linked list" class="calibre9"/><div class="caption"><p class="calibre15">Figure 3: An example of a linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">
<span class="strong"><em class="calibre12">Figure 3</em></span> shows an example of a linked list. The arrows represent a reference. Each element is stored in a <span class="strong"><strong class="calibre2">wrapper object</strong></span> that also holds a reference to the next element wrapper. There are<a id="id36" class="calibre1"/> two additional references to the first and last elements, which are required for any operation to start. The last reference is optional, but it improves the performance of appending to the end vastly, as we shall see.</p><p class="calibre8">To begin the discussion, let's create a linked list node in the following way:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; implements Iterable&lt;E&gt;, Visualizable { </pre></div><p class="calibre8">First, we create a <code class="email">Node</code> class inside the <code class="email">LinkedList</code> class, which will act as a wrapper for the elements and also hold the reference to the next node:</p><div class="informalexample"><pre class="programlisting">  protected static class Node&lt;E&gt; { 
    protected E value; 
    protected Node next; 

    public String toString(){ 
        return value.toString(); 
    } 
  } 

  int length = 0; 
  Node&lt;E&gt;[] lastModifiedNode;    </pre></div><p class="calibre8">Then, we must have references for the first and last elements:</p><div class="informalexample"><pre class="programlisting">    Node&lt;E&gt; first; 
    Node&lt;E&gt; last; </pre></div><p class="calibre8">Finally, we create a <a id="id37" class="calibre1"/>method called <code class="email">getNewNode()</code> that creates a new empty node. We will need this if we want to use a different class for a node in any of the subclasses:</p><div class="informalexample"><pre class="programlisting">    protected Node&lt;E&gt; getNewNode() { 
        Node&lt;E&gt; node = new Node&lt;&gt;(); 
        lastModifiedNode = new Node[]{node}; 
        return node; 
    }
}</pre></div><p class="calibre8">At this point, the unfinished class <code class="email">LinkedList</code> will not be able to store any element; let's see how to do this, though. Notice that we have implemented the <code class="email">Iterable</code> interface. This will allow us to loop through all the elements in an advanced for loop.</p></div>

<div class="book" title="Linked list">
<div class="book" title="Appending at the end"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec12" class="calibre1"/>Appending at the end</h2></div></div></div><p class="calibre8">Appending <a id="id38" class="calibre1"/>at the end is achieved by simply creating a link from the last element of the original linked list to the new element that is being appended and then reassigning the reference to the last element. The second step is required because the new element is the new last element. This is shown in the following figure:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Appending at the end" class="calibre9"/><div class="caption"><p class="calibre15">Figure 4: Appending at the end of a linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">There is a small <a id="id39" class="calibre1"/>difference when you append an element to a linked list that is empty to start with. At this point, the first and last references are null, and this case must be handled separately. The following figure explains this case:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Appending at the end" class="calibre9"/><div class="caption"><p class="calibre15">Figure 5: Appending to an empty linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">We will achieve this by using the following simple code as is. We return the node that has just been added. This is helpful to any class that is extending this class. We will do the same in all cases, and we will see the use of this while discussing doubly linked lists:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; appendLast(E value) { 
        Node node = getNewNode(); 
        node.value = value; </pre></div><p class="calibre8">We try to update the reference of the current last node only if the list is not empty:</p><div class="informalexample"><pre class="programlisting">        if (last != null) 
            last.next = node;</pre></div><p class="calibre8">Then, we must update the last reference as the new element is not going to be the last element:</p><div class="informalexample"><pre class="programlisting">        last = node;</pre></div><p class="calibre8">Finally, if the<a id="id40" class="calibre1"/> list is empty, the new element must also be the first new element and we must update the first reference accordingly, as shown in the preceding figure:</p><div class="informalexample"><pre class="programlisting">        if (first == null) { 
            first = node; 
        } 
        length++; 
        return node;
    }</pre></div><p class="calibre8">Notice that we also keep track of the current length of the list. This is not essential, but if we do this, we do not have to traverse the entire list just to count how many elements are in the list.</p><p class="calibre8">Now, of course, there is this important question: what is the time complexity of appending to a linked list? Well, if we do it the way we have done it before—that is, by having a special reference to the last element—we don't need any loop, as we can see in the code. If the program does not have any loops, all operations would be one-time operations, hence everything is completed in constant time. You can verify that a constant function has this complexity: <span class="strong"><em class="calibre12">O(1)</em></span>. Compare this with what was appended at the end of an array. It required the creation of a new array and also had <span class="strong"><em class="calibre12">O(n)</em></span> complexity, where <span class="strong"><em class="calibre12">n</em></span> was the size of the array.</p></div></div>

<div class="book" title="Linked list">
<div class="book" title="Insertion at the beginning"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec13" class="calibre1"/>Insertion at the beginning</h2></div></div></div><p class="calibre8">Inserting an element <a id="id41" class="calibre1"/>at the beginning of a list is very similar to appending it at the end. The only difference is that you need to update the first reference instead of the last reference:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; appendFirst(E value) { 
        Node node = getNewNode(); 
        node.value = value; 
        node.next = first; 
        first = node; 
        if (length == 0) 
            last = node; 
        length++; 
        return node;
    }</pre></div></div></div>

<div class="book" title="Linked list">
<div class="book" title="Insertion at an arbitrary position"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec14" class="calibre1"/>Insertion at an arbitrary position</h2></div></div></div><p class="calibre8">Insertion<a id="id42" class="calibre1"/> at an arbitrary position can be achieved in the same way we perform an insertion in the first element, except that we update the reference of the previous element instead of the first reference. There is, however, a catch; we need to find the position where we need to insert the element. There is no way to find it other than to start at the beginning and walk all the way to the correct position while counting each node we step on.</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Insertion at an arbitrary position" class="calibre9"/><div class="caption"><p class="calibre15">Figure 6: Insertion of an arbitrary element into a linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">We can implement the idea as follows:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; insert(int index, E value) { 
        Node&lt;E&gt; node = getNewNode(); </pre></div><p class="calibre8">First, we take care of the special cases:</p><div class="informalexample"><pre class="programlisting">        if (index &lt; 0 || index &gt; length) { 
            throw new IllegalArgumentException("Invalid index for insertion"); 
        } else if (index == length) { 
            return appendLast(value); 
        } else if (index == 0) { 
            return appendFirst(value); 
        } else { </pre></div><p class="calibre8">As mentioned earlier, we walk all the way to the desired position while counting the nodes, or in this case, counting the index in the opposite direction:</p><div class="informalexample"><pre class="programlisting">            Node&lt;E&gt; result = first; 
            while (index &gt; 1) { 
                index--; 
                result = result.next; 
            } </pre></div><p class="calibre8">Finally, we update the references:</p><div class="informalexample"><pre class="programlisting">            node.value = value; 
            node.next = result.next; 
            result.next = node; 
            length++; 
            return node;
        } 
    }</pre></div><p class="calibre8">What is the<a id="id43" class="calibre1"/> complexity of this algorithm? There is a loop that must run as many times as the index. This algorithm seems to have a running time that is dependent on the value of the input and not just its size. In this case, we are only interested in the worst case. What is the worst case then? It is when we need to step on all the elements of the list, that is, when we have to insert the element at the end of the list, except for the last element. In this case, we must step on <span class="strong"><em class="calibre12">n-1</em></span> elements to get there and do some constant work. The number of steps would then be <span class="strong"><em class="calibre12">T(n) = C(n-1)+K</em></span> for some constants <span class="strong"><em class="calibre12">C</em></span> and <span class="strong"><em class="calibre12">K</em></span>. So, <span class="strong"><em class="calibre12">T(n) = O(n)</em></span>.</p></div></div>

<div class="book" title="Linked list">
<div class="book" title="Looking up an arbitrary element"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec15" class="calibre1"/>Looking up an arbitrary element</h2></div></div></div><p class="calibre8">Finding the <a id="id44" class="calibre1"/>value of an arbitrary element has two different cases. For the first and last element, it is simple. Since we have direct references to the first and last element, we just have to traverse that reference and read the value inside it. I leave this for you to see how it could be done.</p><p class="calibre8">However, how do you read an arbitrary element? Since we only have forward references, we must start from the beginning and walk all the way, traversing references while counting steps until we reach the element we want.</p><p class="calibre8">Let's see how we can do this:</p><div class="informalexample"><pre class="programlisting">    public E findAtIndex(int index) { </pre></div><p class="calibre8">We start from the first element:</p><div class="informalexample"><pre class="programlisting">        Node&lt;E&gt; result = first; 
        while (index &gt;= 0) { 
            if (result == null) { 
                throw new NoSuchElementException(); 
            } else if (index == 0) { </pre></div><p class="calibre8">When the index is <code class="email">0</code>, we would have finally reached the desired position, so we return:</p><div class="informalexample"><pre class="programlisting">                return result.value; 
            } else { </pre></div><p class="calibre8">If we are not there yet, we must step onto the next element and keep counting:</p><div class="informalexample"><pre class="programlisting">                index--; 
                result = result.next; 
            } 
        } 
        return null; 
    }</pre></div><p class="calibre8">Here too, we<a id="id45" class="calibre1"/> have a loop inside that has to run an index a number of times. The worst case is when you just need to remove one element but it is not the last one; the last one can be found directly. It is easy to see that just like you insert into an arbitrary position, this algorithm also has running time complexity of <span class="strong"><em class="calibre12">O(n)</em></span>.</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Looking up an arbitrary element" class="calibre9"/><div class="caption"><p class="calibre15">Figure 7: Removing an element in the beginning</p></div></div><p class="calibre10"> </p><p class="calibre8">Removing an element in the beginning means simply updating the reference to the first element with that of the next element. Note that we do not update the reference in the element that has just been removed because the element, along with the reference, would be garbage-collected anyway:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; removeFirst() { 
        if (length == 0) { 
            throw new NoSuchElementException(); 
        } </pre></div><p class="calibre8">Assign the reference to the next element:</p><div class="informalexample"><pre class="programlisting">        Node&lt;E&gt; origFirst = first;        
        first = first.next; 
        length--; </pre></div><p class="calibre8">If there are no<a id="id46" class="calibre1"/> more elements left, we must also update the last reference:</p><div class="informalexample"><pre class="programlisting">        if (length == 0) { 
            last = null; 
        } 
        return origFirst;
    }</pre></div></div></div>

<div class="book" title="Linked list">
<div class="book" title="Removing an arbitrary element"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec16" class="calibre1"/>Removing an arbitrary element</h2></div></div></div><p class="calibre8">Removing an<a id="id47" class="calibre1"/> arbitrary element is very similar to removing an element from the beginning, except that you update the reference held by the previous element instead of the special reference named first. The following figure shows this:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Removing an arbitrary element" class="calibre9"/><div class="caption"><p class="calibre15">Figure 8: Removing an arbitrary element</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">Notice that only the link in the linked list is to be reassigned to the next element. The following code does what is shown in the preceding figure:</p><div class="informalexample"><pre class="programlisting">    protected Node&lt;E&gt; removeAtIndex(int index) { 
        if (index &gt;= length || index &lt; 0) { 
            throw new NoSuchElementException(); 
        } </pre></div><p class="calibre8">Of course, removing the first element is a special case:</p><div class="informalexample"><pre class="programlisting">        if (index == 0) { 
            Node&lt;E&gt; nodeRemoved = first; 
            removeFirst(); 
            return nodeRemoved; 
        } </pre></div><p class="calibre8">First, find out<a id="id48" class="calibre1"/> the element just before the one that needs to be removed because this element would need its reference updated:</p><div class="informalexample"><pre class="programlisting">        Node justBeforeIt = first; 
        while (--index &gt; 0) { 
            justBeforeIt = justBeforeIt.next; 
        } </pre></div><p class="calibre8">Update the last reference if the last element is the one that is being removed:</p><div class="informalexample"><pre class="programlisting">        Node&lt;E&gt; nodeRemoved = justBeforeIt.next; 
        if (justBeforeIt.next == last) { 
            last = justBeforeIt.next.next; 
        } </pre></div><p class="calibre8">Update the reference held by the previous element:</p><div class="informalexample"><pre class="programlisting">        justBeforeIt.next = justBeforeIt.next.next; 
        length--; 
        return nodeRemoved; 
    }</pre></div><p class="calibre8">It is very easy to see that the running time worst case complexity of this algorithm is <span class="strong"><em class="calibre12">O(n)</em></span>—which is similar to finding an arbitrary element—because this is what needs to be done before removing it. The operation of the actual removal process itself requires only a constant number of steps.</p></div></div>

<div class="book" title="Linked list">
<div class="book" title="Iteration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec17" class="calibre1"/>Iteration</h2></div></div></div><p class="calibre8">Since we are <a id="id49" class="calibre1"/>working in Java, we prefer to implement the <code class="email">Iterable</code> interface. It lets us loop through the list in a simplified for loop syntax. For this purpose, we first have to create an iterator that will let us fetch the elements one by one:</p><div class="informalexample"><pre class="programlisting">    protected class ListIterator implements Iterator&lt;E&gt; { 
        protected Node&lt;E&gt; nextNode = first; 

        @Override 
        public boolean hasNext() { 
            return nextNode != null; 
        } 

        @Override 
        public E next() { 
            if (!hasNext()) { 
                throw new IllegalStateException(); 
            } 
            Node&lt;E&gt; nodeToReturn = nextNode; 
            nextNode = nextNode.next; 
            return nodeToReturn.value; 
        } 
    }</pre></div><p class="calibre8">The code is self-explanatory. Every time it is invoked, we move to the next element and return the current<a id="id50" class="calibre1"/> element's value. Now we implement the <code class="email">iterator</code> method of the <code class="email">Iterable</code> interface to make our list an iterable:</p><div class="informalexample"><pre class="programlisting">    @Override 
    public Iterator&lt;E&gt; iterator() { 
        return new ListIterator(); 
    }</pre></div><p class="calibre8">This enables us to use the following code:</p><div class="informalexample"><pre class="programlisting">        for(Integer x:linkedList){ 
            System.out.println(x); 
        }</pre></div><p class="calibre8">The preceding code assumes that the variable <code class="email">linkedList</code> was <code class="email">LinkedList&lt;Integer&gt;</code>. Any list that extends this class will also get this property automatically.</p></div></div>

<div class="book" title="Doubly linked list"><div class="book" id="K0RQ2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Doubly linked list</h1></div></div></div><p class="calibre8">Did you notice<a id="id51" class="calibre1"/> that there is no quick way to remove the element from the end of a linked list? This is because even if there is a quick way to find the last element, there is no quick way to find the element before it whose reference needs to be updated. We must walk all the way from the beginning to find the previous element. Well then, why not just have another reference to store the location of the last but one element? This is because after you remove the element, how would you update the reference otherwise? There would be no reference to the element right before that. What it looks like is that to achieve this, we have to store the reference of all the previous elements up to the beginning. The best way to do this would be to store the reference of the previous element in each of the elements or nodes along with the reference to the next element. Such a linked<a id="id52" class="calibre1"/> list is called a <span class="strong"><strong class="calibre2">doubly linked list</strong></span> since the elements are linked both ways:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Doubly linked list" class="calibre9"/><div class="caption"><p class="calibre15">Figure 9: Doubly linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">We will implement a doubly linked list by extending our original linked list because a lot of the operations would be similar. We can create the barebones class in the following manner:</p><div class="informalexample"><pre class="programlisting">public class DoublyLinkedList&lt;E&gt; extends LinkedList&lt;E&gt; { </pre></div><p class="calibre8">We create a new <code class="email">Node</code> class extending the original one and adding a reference for the previous node:</p><div class="informalexample"><pre class="programlisting">    protected static class DoublyLinkedNode&lt;E&gt; extends Node&lt;E&gt; { 
        protected DoublyLinkedNode&lt;E&gt; prev; 
    }</pre></div><p class="calibre8">Of course, we need to override the <code class="email">getNode()</code> method to use this node:</p><div class="informalexample"><pre class="programlisting">    @Override 
    protected Node&lt;E&gt; getNewNode() { 
        return new DoublyLinkedNode&lt;E&gt;(); 
    } 
}</pre></div></div>

<div class="book" title="Doubly linked list">
<div class="book" title="Insertion at the beginning or at the end"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec18" class="calibre1"/>Insertion at the beginning or at the end</h2></div></div></div><p class="calibre8">Insertion at<a id="id53" class="calibre1"/> the beginning is very similar to<a id="id54" class="calibre1"/> that of a singly linked list, except that we must now update the next node's reference for its previous node. The node being inserted does not have a previous node in this case, so nothing needs to be done:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; appendFirst(E value) { 
        Node&lt;E&gt; node = super.appendFirst(value); 
        if (first.next != null) 
            ((DoublyLinkedNode&lt;E&gt;) first.next).prev = (DoublyLinkedNode&lt;E&gt;) first; 
        return node; 
    }</pre></div><p class="calibre8">Pictorially, it <a id="id55" class="calibre1"/>can be visualized as shown in<a id="id56" class="calibre1"/> the following figure:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Insertion at the beginning or at the end" class="calibre9"/><div class="caption"><p class="calibre15">Figure 10: Insertion at the beginning of a doubly linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">Appending at the end is very similar and is given as follows:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; appendLast(E value) { 
        DoublyLinkedNode&lt;E&gt; origLast = (DoublyLinkedNode&lt;E&gt;) this.last; 
        Node&lt;E&gt; node = super.appendLast(value); </pre></div><p class="calibre8">If the original list were empty, the original last reference would be null:</p><div class="informalexample"><pre class="programlisting">        if (origLast == null) { 
            origLast = (DoublyLinkedNode&lt;E&gt;) first; 
        } 
        ((DoublyLinkedNode&lt;E&gt;) this.last).prev = origLast; 
        return node; 
    }</pre></div><p class="calibre8">The complexity of the insertion is the same as that of a singly linked list. In fact, all the operations on<a id="id57" class="calibre1"/> a doubly linked list have the <a id="id58" class="calibre1"/>same running time complexity as that of a singly linked list, except the process of removing the last element. We will thus refrain from stating it again until we discuss the removal of the last element. You should verify that the complexity stays the same as with a singly linked list in all other cases.</p></div></div>

<div class="book" title="Doubly linked list">
<div class="book" title="Insertion at an arbitrary location"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec19" class="calibre1"/>Insertion at an arbitrary location</h2></div></div></div><p class="calibre8">As with <a id="id59" class="calibre1"/>everything else, this operation is very similar to the process of making an insertion at an arbitrary location of a singly linked list, except that you need to update the references for the previous node.</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Insertion at an arbitrary location" class="calibre9"/><div class="caption"><p class="calibre15">Figure 11: Insertion at an arbitrary location of a doubly linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">The following code does this for us:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; insert(int index, E value) { 
        DoublyLinkedNode&lt;E&gt; inserted = (DoublyLinkedNode&lt;E&gt;) super.insert(index, value); 
</pre></div><p class="calibre8">In the case of the first and last element, our overridden methods are invoked anyway. Therefore, there is no need to consider them again:</p><div class="informalexample"><pre class="programlisting">        if(index!=0 &amp;&amp; index!=length) { 
            if (inserted.next != null) { </pre></div><p class="calibre8">This part <a id="id60" class="calibre1"/>needs a little bit of explaining. In <span class="strong"><em class="calibre12">Figure 11</em></span>, the node being inserted is <span class="strong"><strong class="calibre2">13</strong></span>. Its previous node should be <span class="strong"><strong class="calibre2">4</strong></span>, which was originally the previous node of the next node <span class="strong"><strong class="calibre2">3</strong></span>:</p><div class="informalexample"><pre class="programlisting">                inserted.prev = ((DoublyLinkedNode&lt;E&gt;) inserted.next).prev; </pre></div><p class="calibre8">The <code class="email">prev</code> reference of the next node <span class="strong"><strong class="calibre2">3</strong></span> must now hold the newly inserted node <span class="strong"><strong class="calibre2">13</strong></span>:</p><div class="informalexample"><pre class="programlisting">                ((DoublyLinkedNode&lt;E&gt;) inserted.next).prev = inserted; 
            } 
        } 
        return inserted; 
    }</pre></div></div></div>

<div class="book" title="Doubly linked list">
<div class="book" title="Removing the first element"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec20" class="calibre1"/>Removing the first element</h2></div></div></div><p class="calibre8">Removing the<a id="id61" class="calibre1"/> first element is almost the same as that for a singly linked list. The only additional step is to set the <code class="email">prev</code> reference of the next node to <code class="email">null</code>. The following code does this:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; removeFirst() { 
        super.removeFirst(); 
        if (first != null) { 
            ((DoublyLinkedNode&lt;E&gt;) first).prev = null; 
        } 
        return first; 
    }</pre></div><p class="calibre8">The following figure shows what happens. Also, note that finding an element does not really need an update:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Removing the first element" class="calibre9"/><div class="caption"><p class="calibre15"> Figure 12: Removal of the first element from a doubly linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">There can be<a id="id62" class="calibre1"/> an optimization to traverse backward from the last element to the first in case the index we are looking for is closer toward the end; however, it does not change the asymptotic complexity of the find operation. So we leave it at this stage. If interested, you would be able to easily figure out how to do this optimization.</p></div></div>

<div class="book" title="Doubly linked list">
<div class="book" title="Removing an arbitrary element"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec21" class="calibre1"/>Removing an arbitrary element</h2></div></div></div><p class="calibre8">Just like <a id="id63" class="calibre1"/>other operations, removal is very similar to removal of elements in the case of a singly linked list, except that we need to update the <code class="email">prev</code> reference:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Removing an arbitrary element" class="calibre9"/><div class="caption"><p class="calibre15"> Figure 13: Removal of an arbitrary element from a doubly linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">The <a id="id64" class="calibre1"/>following code will help us achieve this:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; removeAtIndex(int index) { 
        if(index&lt;0||index&gt;=length){ 
            throw new NoSuchElementException(); 
        }</pre></div><p class="calibre8">This is a special case that needs extra attention. A doubly linked list really shines while removing the last element. We will discuss the <code class="email">removeLast()</code> method in the next section:</p><div class="informalexample"><pre class="programlisting">        if(index==length-1){ 
            return removeLast(); 
        } </pre></div><p class="calibre8">The rest of the code is fairly easy to figure out:</p><div class="informalexample"><pre class="programlisting">        DoublyLinkedNode&lt;E&gt; nodeRemoved 
               = (DoublyLinkedNode&lt;E&gt;) super.removeAtIndex(index); 
        if ((DoublyLinkedNode&lt;E&gt;) nodeRemoved.next != null) 
            ((DoublyLinkedNode&lt;E&gt;) nodeRemoved.next).prev 
                 = nodeRemoved.prev; 
        return nodeRemoved; 
    } </pre></div></div></div>

<div class="book" title="Doubly linked list">
<div class="book" title="Removal of the last element"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec22" class="calibre1"/>Removal of the last element</h2></div></div></div><p class="calibre8">This is <a id="id65" class="calibre1"/>where a doubly linked list really shines. This is the reason we got started with a doubly linked list. And it's not even a lot of code. Check this out:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; removeLast() { 
        Node&lt;E&gt; origLast = last; 
        if(last==null){ 
            throw new IllegalStateException
                          ("Removing element from an empty list"); 
        } </pre></div><p class="calibre8">Just use the fact that we have access to the previous node's reference and we can update the last reference very easily:</p><div class="informalexample"><pre class="programlisting">        last = ((DoublyLinkedNode&lt;E&gt;)last).prev; </pre></div><p class="calibre8">If the list is not empty after removal, set the next reference of the new last element to null. If the new list is empty instead, update the first element as well:</p><div class="informalexample"><pre class="programlisting">        if(last!=null){ 
            last.next = null; 
        } else{ 
            first = null; 
        } </pre></div><p class="calibre8">Don't forget to update the length:</p><div class="informalexample"><pre class="programlisting">        length--; 
        return origLast;
    }</pre></div><p class="calibre8">We don't need a new figure to understand the update of the references as they are really similar to the removal process of the first element. The only difference from the singly linked list is that in the case of a singly linked list, we need to walk all the way to the end of the list to find the previous element of the list. However, in the case of a doubly linked list, we can update it in one step because we always have access to the previous node's reference. This drastically reduces the running time from <span class="strong"><em class="calibre12">O(n)</em></span> in the case of a singly linked list to <span class="strong"><em class="calibre12">O(1)</em></span> in the case of a doubly linked list.</p></div></div>

<div class="book" title="Circular linked list" id="KVCC1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Circular linked list</h1></div></div></div><p class="calibre8">A circular linked list is an ordinary linked list, except that the last element holds the reference to<a id="id66" class="calibre1"/> the first element as its next element. This, of course, justifies its name. It would be useful when, for example, you are holding a list of players in a list and they play in turn in a round robin fashion. The implementation is simplified if you use a circular linked list and just keep rotating as the players complete their turn:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Circular linked list" class="calibre9"/><div class="caption"><p class="calibre15">Figure 14: A circular linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">The basic structure of a circular linked list is the same as that of a simple linked list; no more fields or methods are required:</p><div class="informalexample"><pre class="programlisting">public class CircularLinkedList&lt;E&gt; extends LinkedList&lt;E&gt;{ 
}</pre></div></div>

<div class="book" title="Circular linked list" id="KVCC1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Insertion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec23" class="calibre1"/>Insertion</h2></div></div></div><p class="calibre8">This is the <a id="id67" class="calibre1"/>same as the insertion for a simple linked list, except that you assign the last references next to the first:</p><div class="informalexample"><pre class="programlisting">    @Override 
    public Node&lt;E&gt; appendFirst(E value) { 
        Node&lt;E&gt; newNode = super.appendFirst(value); 
        last.next = first; 
        return newNode; 
    }</pre></div><p class="calibre8">From this, it is<a id="id68" class="calibre1"/> not hard to guess how it would be to append at the end:</p><div class="informalexample"><pre class="programlisting">    @Override 
    public Node&lt;E&gt; appendLast(E value) { 
        Node&lt;E&gt; newNode =  super.appendLast(value); 
        last.next = first; 
        return newNode; 
    } </pre></div><p class="calibre8">Insertion at any other index, of course, remains the same as that for a simple linked list; no more changes are required. This means the complexity of the insertion stays the same as with that for a simple linked list.</p></div></div>

<div class="book" title="Circular linked list" id="KVCC1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Removal"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec24" class="calibre1"/>Removal</h2></div></div></div><p class="calibre8">Removal also<a id="id69" class="calibre1"/> only changes when you remove the first or the last element. In any case, just updating the last element's next reference solves the purpose. The only place where we need to change this is when we remove the first element. This is because the same operation we used for a simple linked list does not update the previous element's next reference, which we need to do:</p><div class="informalexample"><pre class="programlisting">    @Override 
    public Node&lt;E&gt; removeFirst() { 
        Node&lt;E&gt; newNode =  super.removeFirst(); 
        last.next = first; 
        return newNode; 
    }</pre></div><p class="calibre8">Nothing else needs to be done in removal.</p></div></div>

<div class="book" title="Circular linked list" id="KVCC1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Rotation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec25" class="calibre1"/>Rotation</h2></div></div></div><p class="calibre8">What we are<a id="id70" class="calibre1"/> doing here is just bringing the next element of the first element to the first position. This is exactly what the name "rotation" would imply:</p><div class="informalexample"><pre class="programlisting">    public void rotate(){ 
        last = first; 
        first = first.next; 
    }</pre></div><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Rotation" class="calibre9"/><div class="caption"><p class="calibre15">Figure 15: Rotation of a circular linked list</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">Doing the same with a simple linked list would require no more than assigning one more reference. You should be able to figure out how to do this with a simple linked list. But this operation looks<a id="id71" class="calibre1"/> more natural for a circular linked list, as conceptually, there is no first element.</p><p class="calibre8">The real power of a circular linked list is the iterator, which never ends. If the list is non-empty, the iterator will have <code class="email">hasNext()</code>, which always returns true. This means you can simply keep calling the <code class="email">next()</code> method on the iterator and keep processing the elements in a round robin fashion. The following code should make it clear what I mean:</p><div class="informalexample"><pre class="programlisting">        for(int i=0;i&lt;30;i++){ 
            System.out.print(" "+ linkedList.first); 
            linkedList.rotate(); 
        }</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">Note that if you try to use the enhanced for loop with a circular linked list, you will run into an infinite loop.</p></div></div></div>
<div class="book" title="Summary" id="LTSU1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">We covered a few basic data structures and the algorithms for manipulating them. In addition to this, we also found out their running time complexities. To summarize this, an array provides you with the fastest random access there is with this time complexity: <span class="strong"><em class="calibre12">O(1)</em></span>. But arrays cannot change size; the only modification they allow is to change the value of an element. A linked list allows fast append at the end and insertion at the beginning at <span class="strong"><em class="calibre12">O(1)</em></span> time. However, <span class="strong"><em class="calibre12">O(1)</em></span> removal is only available for removing the first element. This is resolved by a doubly linked list that also allows <span class="strong"><em class="calibre12">O(1)</em></span> removal from the end. A circular linked list holds a reference to the first element in the next reference of the last element. This makes the list a circular structure that allows one to loop indefinitely.</p><p class="calibre8">In the upcoming chapters, we will discuss the abstraction of data structures called abstract data types. We will use the data structures we have seen in this chapter to implement the abstract data types, which in turn will be used in later chapters.</p></div></body></html>