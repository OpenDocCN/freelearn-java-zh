<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">RxJava on Android</h1>
                </header>
            
            <article>
                
<p>If there is one domain that reactive programming has taken by storm, it is definitely mobile apps. As discussed throughout this book, ReactiveX is highly useful for many domains. But mobile apps are becoming increasingly complex, and users have a short tolerance for apps that are unresponsive, slow, or buggy. Therefore, mobile applications were quick to be early adopters of ReactiveX to solve these problems. RxSwift has quickly become popular on iOS after RxJava got a foothold on Android. There are also RxAndroid and RxBinding libraries to integrate RxJava easily with the Android environment, which we will cover in this chapter.</p>
<p>One of the pain points that Android developers have coped with for some time is being stuck with Java 6. This means that many of the widely used versions of Android (KitKat, Lollipop, and Marshmallow) do not support Java 8 lambdas (although this changed in Android Nougat, which finally uses OpenJDK 8). At first glance, this means you are stuck using boilerplate-riddled anonymous classes to express your RxJava operators (refer to Appendix A for examples). However, by using Retrolambda, you can, in fact, use earlier versions of Android while using lambdas, which we will go through in this chapter. Another option you have is using the Kotlin language, which has become an increasingly popular platform for Android development. Kotlin is an arguably more modern and expressive language than Java and can compile to Java 6 bytecode. We will cover Kotlin with RxJava in the next chapter.</p>
<p>If you have no interest in Android development, feel free to skip this chapter. But the rest of you reading this book are most likely Android developers, so it is assumed that you have done some Android development already.</p>
<div class="packt_infobox">If you have little or no experience with Android and would like to learn, a great book to get started is <em>Android Programming: The Big Nerd Ranch Guide</em> by Bill Phillips, Chris Stewart, and Kristin Marsicano (<a href="https://www.bignerdranch.com/books/android-programming/">https://www.bignerdranch.com/books/android-programming/</a>). It is an excellent book to become thoroughly proficient in Android development quickly.</div>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating an Android project</li>
<li>Configuring RxJava for Android</li>
<li>Using RxJava and RxAndroid</li>
<li>Using RxBinding</li>
<li>Other Android Rx libraries</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Android project</h1>
                </header>
            
            <article>
                
<p>We are going to use Android Studio for the examples in this chapter, with Android 5.1 Lollipop as our platform target. Launch Android Studio and create a new project, as shown in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img height="279" width="485" class="image-border" src="assets/4d596710-1de2-42c7-bf8f-72006de4d4a2.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><strong>Figure 11.1</strong>: Creating a new Android project</div>
<p>In the next screen (shown in the following figure), name your project <kbd>RxJavaApp</kbd> with a <span class="packt_screen">Company domain</span> of <kbd>packtpub.com</kbd> or whatever you prefer. Then, click on Next:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/06bfe1a9-f210-4e34-bc1a-5e43f493a23f.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><strong>Figure 11.2</strong></div>
<p>We are going to target <span class="packt_screen">Phone and Tablet</span>. Since we may want our app to be compatible with devices running earlier versions of Android, let's select <span class="packt_screen">Android 5.1 (Lollipop)</span> as our <span class="packt_screen">Minimum SDK</span>. This will also give us an opportunity to practice using Retrolambda. After this, click on <span class="packt_screen">Next</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/35755247-1c34-4a53-ac17-52b0703e7460.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><strong>Figure 11.3</strong></div>
<p>On the next screen, choose <span class="packt_screen">Empty Activity</span> as our your template, as shown in the following figure. Then, click on <span class="packt_screen">Next</span>. As you probably know, an activity is one interactive screen containing controls. For the examples in this chapter, we will use one activity:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/c0273d2b-c1f9-40f6-9f8e-75aa208ad804.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><strong>Figure 11.4</strong></div>
<p>Finally, we come to the final screen to configure the Activity. Feel free to leave <span class="packt_screen">Activity Name</span> as <kbd>MainActivity</kbd> and its corresponding <span class="packt_screen">Layout Name</span> as <kbd>activity_main</kbd>. We will populate this Activity later. Then, click on <span class="packt_screen">Finish</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/6c67d61f-d913-4a1f-92f5-65540c7a2740.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><strong>Figure 11.5</strong></div>
<p>You should now come to a screen shortly with your entire Android project, and it should already be configured with Gradle. Open <kbd>build.gradle (Module: app)</kbd> so we can configure our required dependencies next, as shown in the following figure: </p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/f06ad898-3a2d-47ee-8724-50963125ead3.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><strong>Figure 11.6</strong></div>
<p>You will need to make a few changes to the <kbd>build.gradle</kbd> script targeting the app module so we can use RxJava and Retrolambda.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Retrolambda</h1>
                </header>
            
            <article>
                
<p>First, let's get Retrolambda set up. We will also leverage a quick unit test to see whether it works correctly. Open the <kbd>ExampleUnitTest.java</kbd> file that was created with the project template. Remove the sample unit test method inside it and declare a new one called <kbd>lambdaTest()</kbd>. Inside it, try to declare a <kbd>Callable&lt;Integer&gt;</kbd> with a lambda, as shown <span>in the following figure</span>. Note that it throws a compiler error because we are not using Java 8 to support lambdas.</p>
<div class="CDPAlignCenter CDPAlign"><img height="306" width="523" class="image-border" src="assets/d60d10f6-2e77-4130-ac3e-22a2c35bfbb9.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><strong>Figure 11.7</strong> - Lambdas are not supported with this Android and Java version</div>
<p>We cannot use Java 8 if we are targeting Android Lollipop, so we need Retrolambda to save us from creating boilerplate-riddled anonymous inner classes. It will compile our lambdas to anonymous classes at the bytecode level, so it supports Java 6.</p>
<p>To get Retrolambda set up, we are going to use the gradle-retrolambda plugin to make the configuration process as seamless as possible. Go back to your <kbd>build.gradle (Module: app)</kbd> script and modify it like this:</p>
<pre style="padding-left: 60px">buildscript {<br/>     repositories {<br/>         mavenCentral()<br/>     }<br/><br/>     dependencies {<br/>         classpath 'me.tatarka:gradle-retrolambda:3.6.1'<br/>     }<br/> }<br/><br/> apply plugin: 'com.android.application'<br/> apply plugin: 'me.tatarka.retrolambda'<br/><br/> android {<br/>     compileSdkVersion 25<br/>     buildToolsVersion "25.0.2"<br/>     defaultConfig {<br/>         applicationId "com.packtpub.rxjavademo"<br/>         minSdkVersion 22<br/>         targetSdkVersion 25<br/>         versionCode 1<br/>         versionName "1.0"<br/>         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"<br/>     }<br/>     buildTypes {<br/>         release {<br/>             minifyEnabled false<br/>             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'<br/>         }<br/>     }<br/>     compileOptions {<br/>         sourceCompatibility JavaVersion.VERSION_1_8<br/>         targetCompatibility JavaVersion.VERSION_1_8<br/>     }<br/> }<br/><br/><br/> dependencies {<br/>     compile fileTree(dir: 'libs', include: ['*.jar'])<br/>     androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {<br/>         exclude group: 'com.android.support', module: 'support-annotations'<br/>     })<br/>     compile 'com.android.support:appcompat-v7:25.3.1'<br/>     compile 'com.android.support.constraint:constraint-layout:1.0.2'<br/>     testCompile 'junit:junit:4.12'<br/> }</pre>
<p>Click on the <span class="packt_screen">Sync Now</span> prompt after you save the script to rebuild the project. The big change to note in the preceding code is that we added a buildscript <kbd>{ }</kbd> block that brings in Retrolambda 3.6.1 as a dependency from <kbd>mavenCentral()</kbd>. We can then apply the retrolambda plugin. Finally, we add a <kbd>compileOptions { }</kbd> block inside the android <kbd>{ }</kbd> one and set the source and target to be compatible with Java 8.</p>
<p>Run our unit test containing our lambda now. Score! As shown <span>in the following figure</span>, everything compiles and runs successfully, and we are now running lambdas on Java 6! Let's take a look:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border&quot;" src="assets/a1f577b0-7768-4173-b27f-9b7c15c82d54.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 11.8 - We can now use lambdas with Java 6 on Android Lollipop with Retrolambda set up</div>
<p><strong>Retrolambda</strong> is a brilliant tool for Android developers constrained to using Java 6. It cleverly compiles lambdas as traditional anonymous classes, and you can save yourself some terrible boilerplate work when using RxJava.</p>
<div class="packt_infobox">To learn more about Retrolambda and additional tweaks and configurations you can make, check out its GitHub page at <a href="https://github.com/evant/gradle-retrolambda">https://github.com/evant/gradle-retrolambda</a>. At the time of writing this, there are also upcoming lambda tools on Android Studio (<a href="https://developer.android.com/studio/preview/features/java8-support.html">https://developer.android.com/studio/preview/features/java8-support.html</a>). These features may serve as an alternative to Retrolambda.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring RxJava and friends</h1>
                </header>
            
            <article>
                
<p>Now that the hard part is over and you have Retrolambda set up, all that is left for the configuration is bringing in RxJava and RxAndroid. Another set of libraries to add to your stack is Jake Wharton's RxBinding (<a href="https://github.com/JakeWharton/RxBinding">https://github.com/JakeWharton/RxBinding</a>), which streamlines RxJava usage for Android UI controls.</p>
<p>Add these three libraries to your dependencies <kbd>{ }</kbd> block for your module (not the one inside the buildscript <kbd>{ }</kbd> block!):</p>
<pre style="padding-left: 60px"> compile 'io.reactivex.rxjava2:rxjava:2.1.0'<br/> compile 'io.reactivex.rxjava2:rxandroid:2.0.1'<br/> compile 'com.jakewharton.rxbinding2:rxbinding:2.0.0'</pre>
<p>So these should now be your full <kbd>build.gradle (Module: app)</kbd> contents:</p>
<pre style="padding-left: 60px">buildscript {<br/>     repositories {<br/>         mavenCentral()<br/>     }<br/><br/>     dependencies {<br/>         classpath 'me.tatarka:gradle-retrolambda:3.6.1'<br/>     }<br/> }<br/><br/> apply plugin: 'com.android.application'<br/> apply plugin: 'me.tatarka.retrolambda'<br/><br/> android {<br/>     compileSdkVersion 25<br/>     buildToolsVersion "25.0.2"<br/>     defaultConfig {<br/>         applicationId "com.packtpub.rxjavademo"<br/>         minSdkVersion 22<br/>         targetSdkVersion 25<br/>         versionCode 1<br/>         versionName "1.0"<br/>         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"<br/>     }<br/>     buildTypes {<br/>         release {<br/>             minifyEnabled false<br/>             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'<br/>         }<br/>     }<br/>     compileOptions {<br/>         sourceCompatibility JavaVersion.VERSION_1_8<br/>         targetCompatibility JavaVersion.VERSION_1_8<br/>     }<br/> }<br/><br/><br/> dependencies {<br/>     compile fileTree(dir: 'libs', include: ['*.jar'])<br/>     androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {<br/>         exclude group: 'com.android.support', module: 'support-annotations'<br/>     })<br/>     compile 'com.android.support:appcompat-v7:25.3.1'<br/>     compile 'com.android.support.constraint:constraint-layout:1.0.2'<br/><br/>     compile 'io.reactivex.rxjava2:rxjava:2.1.0'<br/>     compile 'io.reactivex.rxjava2:rxandroid:2.0.1'<br/>     compile 'com.jakewharton.rxbinding2:rxbinding:2.0.0'<br/><br/>     testCompile 'junit:junit:4.12'<br/> }</pre>
<p>Ensure that you click on the <span class="packt_screen">Sync Now</span> prompt to rebuild the project with these dependencies in place. For the remainder of the chapter, we will touch on a few ways in which you can use RxJava, RxAndroid, and RxBinding together in your Android application. I could easily write a small book about different reactive features, bindings, and patterns you can use with Android, but in this chapter, we will take a minimalistic approach to focus on the core Rx features. We will touch on other libraries and resources you can research at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using RxJava and RxAndroid</h1>
                </header>
            
            <article>
                
<p>The primary feature of the RxAndroid library (<a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a>) is that it has Android Schedulers to help your concurrency goals for your Android app. It has a Scheduler for the Android main thread as well as an implementation that can target any message Looper. Striving to be a core library, RxAndroid does not have many other features. You will need specialized reactive binding libraries for Android to do more than that, which we will explore later.</p>
<p>Let's start simple. We will modify <kbd>TextView</kbd> in the middle of our <kbd>MainActivity</kbd> (which already contains "<kbd>Hello World!</kbd>") to change to "<kbd>Goodbye World!</kbd>" after 3 seconds. We will do all of this reactively using <kbd>Observable.delay()</kbd>. Because this will emit on a computational Scheduler, we will need to leverage <kbd>observeOn()</kbd> to safely switch the emission to the Android main thread.</p>
<p>First, in the <kbd>res/layout/activity_main.xml</kbd> file, modify the <kbd>TextView</kbd> block to have an ID property called <kbd>my_text_view</kbd> (as shown in the following code). This way, we can refer to it from our app code in a moment:</p>
<pre style="padding-left: 60px"> &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/> &lt;android.support.constraint.ConstraintLayout<br/>     <br/>     <br/>     <br/>     android:layout_width="match_parent"<br/>     android:layout_height="match_parent"<br/>     tools:context="com.packtpub.rxjavademo.MainActivity"&gt;<br/><br/>     &lt;TextView<br/>         android:id="@+id/my_text_view"<br/>         android:layout_width="wrap_content"<br/>         android:layout_height="wrap_content"<br/>         android:text="Hello World!"<br/>         app:layout_constraintBottom_toBottomOf="parent"<br/>         app:layout_constraintLeft_toLeftOf="parent"<br/>         app:layout_constraintRight_toRightOf="parent"<br/>         app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/> &lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>Finally, rebuild your project and go to the <kbd>MainActivity.java</kbd> file. In the <kbd>onCreate()</kbd> method implementation, we are going to look up our "<kbd>my_text_view</kbd>" component and save it to a variable called <kbd>myTextView</kbd> (and cast it to <kbd>TextView</kbd>).</p>
<p>Then, immediately, we are going to create an <kbd>Observable</kbd> emitting just the string <kbd>Goodbye World!</kbd> and delay it for 3 seconds. Because <kbd>delay()</kbd> will put it on a computational Scheduler, we will use <kbd>observeOn()</kbd> to put that emission back in <kbd>AndroidSchedulers.mainThread()</kbd> once it is received. Implement all this, as shown <span>in the following code</span>:</p>
<pre style="padding-left: 60px"> package com.packtpub.rxjavademo;<br/><br/> import android.support.v7.app.AppCompatActivity;<br/> import android.os.Bundle;<br/> import android.widget.TextView;<br/> import java.util.concurrent.TimeUnit;<br/> import io.reactivex.Observable;<br/> import io.reactivex.android.schedulers.AndroidSchedulers;<br/><br/> public class MainActivity extends AppCompatActivity {<br/><br/>     @Override<br/>     protected void onCreate(Bundle savedInstanceState) {<br/>         super.onCreate(savedInstanceState);<br/>         setContentView(R.layout.activity_main);<br/><br/>         TextView myTextView = (TextView) findViewById(R.id.my_text_view);<br/><br/>         Observable.just("Goodbye World!")<br/>                     .delay(3, TimeUnit.SECONDS)<br/>                     .observeOn(AndroidSchedulers.mainThread())<br/>                     .subscribe(s -&gt; myTextView.setText(s));<br/>     }<br/> }</pre>
<p>Run this application either on an emulated virtual device or an actual connected device. Sure enough, you will get an app that shows "<kbd>Hello World!</kbd>" for 3 seconds and then changes to "<kbd>Goodbye World!</kbd>". Here, I run this app on a virtual Pixel phone, as shown <span>in the following figure:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="672" width="714" class="image-border" src="assets/b79c18f5-bc1e-4ed6-b95b-a5497be77e98.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 11.9 - An Android app that switches text from "Hello World!" to "Goodbye World!" after 3 seconds.</div>
<p class="CDPAlignLeft CDPAlign">If you do not use this <kbd>observeOn()</kbd> operation to switch back to the Android <kbd>mainThread()</kbd>, the app will likely crash. Therefore, it is important to make sure any emissions that modify the Android UI happen on the <kbd>mainThread()</kbd>. Thankfully, RxJava makes this easy to do compared to traditional concurrency tools.</p>
<p>Pretty much everything you learned earlier in this book can be applied to Android development, and you can mix RxJava and RxAndroid with your favorite Android utilities, libraries, and design patterns. However, if you want to create Observables off of Android widgets, you will need to use RxBinding and other libraries to augment your Rx capabilities on Android.</p>
<p>There is also an <kbd>AndroidSchedulers.from()</kbd> factory that accepts an event Looper and returns a Scheduler that will execute emissions on any Android Looper. This will operate the <kbd>Observable</kbd>/<kbd>Flowable</kbd> on a new thread and emit results through <kbd>onNext()</kbd> on the thread running a background operation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using RxBinding</h1>
                </header>
            
            <article>
                
<p>RxAndroid does not have any tools to create Observables off Android events, but there are many libraries that provide means to do this. The most popular library is RxBinding, which allows you to create Observables off of UI widgets and events.</p>
<p>There are many factories available in RxBinding. One static factory class you may use frequently is RxView, which allows you to create Observables off controls that extend View and broadcast different events as emissions. For instance, change your <kbd>activity_main.xml</kbd>to have a Button and TextView class, as follows:</p>
<pre style="padding-left: 60px"> &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/> &lt;android.support.constraint.ConstraintLayout<br/>     <br/>     <br/>     android:layout_width="match_parent"<br/>     android:layout_height="match_parent"<br/>     tools:context="com.packtpub.rxjavademo.MainActivity"&gt;<br/><br/>     &lt;LinearLayout <br/>         android:layout_width="wrap_content"<br/>         android:layout_height="wrap_content"<br/>         android:orientation="vertical"<br/>         tools:layout_editor_absoluteY="8dp"<br/>         tools:layout_editor_absoluteX="8dp"&gt;<br/><br/>     &lt;Button<br/>         android:id="@+id/increment_button"<br/>         android:text="Increment"<br/>         android:layout_width="wrap_content"<br/>         android:layout_height="wrap_content" /&gt;<br/>     &lt;TextView<br/>         android:id="@+id/my_text_view"<br/>         android:layout_width="wrap_content"<br/>         android:layout_height="wrap_content"<br/>         android:text="0"/&gt;<br/> &lt;/LinearLayout&gt;<br/><br/> &lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>We saved <kbd>Button</kbd> and <kbd>TextView</kbd> to <kbd>increment_button</kbd> and <kbd>my_text_view</kbd> IDs, respectively. Now let's switch over to the <kbd>MainActivity.java</kbd> class and have the <kbd>Button</kbd> broadcast the number of times it was pressed to the <kbd>TextView</kbd>. Use the <kbd>RxView.clicks()</kbd> factory to emit each <kbd>Button</kbd> click as an Object and map it to a 1. As we did in <a href="de58a40c-f55f-442f-b12e-7c022e08644e.xhtml">Chapter 3</a>, <span><em>Basic Operators</em>,</span> we can use the <kbd>scan()</kbd> operator to emit a rolling count of emissions, as shown <span>in the following code</span>:</p>
<pre style="padding-left: 60px"> package com.packtpub.rxjavademo;<br/><br/> import android.os.Bundle;<br/> import android.support.v7.app.AppCompatActivity;<br/> import android.widget.Button;<br/> import android.widget.TextView;<br/><br/> import com.jakewharton.rxbinding2.view.RxView;<br/><br/> public class MainActivity extends AppCompatActivity {<br/><br/>     @Override<br/>     protected void onCreate(Bundle savedInstanceState) {<br/>         super.onCreate(savedInstanceState);<br/>         setContentView(R.layout.activity_main);<br/><br/>         TextView myTextView = (TextView) findViewById(R.id.my_text_view);<br/>         Button incrementButton = (Button) findViewById(R.id.increment_button);<br/><br/>         //broadcast clicks into a cumulative increment, and display in TextView<br/>         RxView.clicks(incrementButton)<br/>                 .map(o -&gt; 1)<br/>                 .scan(0,(total, next) -&gt; total + next)<br/>                 .subscribe(i -&gt; myTextView.setText(i.toString()));<br/>     }<br/> }</pre>
<p>Now run this app and press the button a few times. Each press will result in the number incrementing in the <kbd>TextView</kbd>, as shown <span>in the following figure:</span></p>
<p>)</p>
<div class="CDPAlignCenter CDPAlign"><img height="539" width="282" class="image-border" src="assets/a5e5ec5b-d05a-48fb-b3ad-8947a19f7f3c.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 11.10 - Reactively turning Button clicks into a scan() emitting the number of times it was pressed.</div>
<p>Just in the RxView alone, there are dozens of factories to emit the states and events of a variety of properties on a View widget. Just to name a few, some of these other factories include <kbd>hover()</kbd>, <kbd>drag()</kbd>, and <kbd>visibility()</kbd>. There are also a large number of specialized factories for different widgets, such as <kbd>RxTextView</kbd>, <kbd>RxSearchView</kbd>, and <kbd>RxToolbar</kbd>.</p>
<p>There is so much functionality in RxBinding that it is difficult to cover all of it in this chapter. The most effective way to see what is available is to explore the RxBinding project source code on GitHub, which you can find at <a href="https://github.com/JakeWharton/RxBinding/">https://github.com/JakeWharton/RxBinding/</a>.</p>
<div class="packt_infobox">Note that RxBinding has several "support" modules you can optionally bring in, including design bindings, RecyclerView bindings, and even Kotlin extensions. You can read more about these modules on GitHub README.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other RxAndroid bindings libraries</h1>
                </header>
            
            <article>
                
<p>If you are fully embracing the reactive approach in making Android apps, there are many other specialized reactive bindings libraries you can leverage in your apps. They often deal with specific domains of Android but can be helpful nonetheless if you work with these domains. Outside of RxBinding, here are some notable bindings libraries you can use reactively with Android:</p>
<ul>
<li>SqlBrite (<a href="https://github.com/square/sqlbrite">https://github.com/square/sqlbrite</a>): A SQLite wrapper that brings reactive semantics to SQL queries.</li>
<li>RxLocation (<a href="https://github.com/patloew/RxLocation">https://github.com/patloew/RxLocation</a>): A reactive location API</li>
<li>rx-preferences (<a href="https://github.com/f2prateek/rx-preferences">https://github.com/f2prateek/rx-preferences</a>): A reactive SharedPreferences API</li>
<li>RxFit (<a href="https://github.com/patloew/RxFit">https://github.com/patloew/RxFit</a>): Reactive fitness API for Android</li>
<li>RxWear (<a href="https://github.com/patloew/RxWear">https://github.com/patloew/RxWear</a>): A reactive API for the Wearable library</li>
<li>ReactiveNetwork (<a href="https://github.com/pwittchen/ReactiveNetwork">https://github.com/pwittchen/ReactiveNetwork</a>): Reactively listens for the network connectivity state</li>
<li>ReactiveBeacons (<a href="https://github.com/pwittchen/ReactiveBeacons">https://github.com/pwittchen/ReactiveBeacons</a>): Reactively scans for <strong>BLE</strong> (<strong>Bluetooth Low Energy</strong>) beacons in proximity</li>
</ul>
<p>As you can see, there is quite an RxJava ecosystem for Android, and you can view a fuller list on the RxAndroid wiki (<a href="https://github.com/ReactiveX/RxAndroid/wiki">https://github.com/ReactiveX/RxAndroid/wiki</a>). Definitely leverage Google to see whether others exist for your specific task in mind. If you cannot find a library, there might be an OSS opportunity to start one!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Life cycles and cautions using RxJava with Android</h1>
                </header>
            
            <article>
                
<p>As always, be deliberate and careful about how you manage the life cycle of your subscriptions. Make sure you do not rely on weak references in your Android app and assume reactive streams will dispose of themselves because they will not! So always call <kbd>dispose()</kbd> on your <kbd>disposables</kbd> when a piece of your Android application is no longer being used.</p>
<p>For instance, say you create a simple app that displays the number of seconds since it was launched. For this exercise, set up your layout like this in order to have <kbd>timer_field</kbd> in the <kbd>TextView</kbd> class:</p>
<pre style="padding-left: 60px"> &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/> &lt;android.support.constraint.ConstraintLayout <br/>     <br/>     <br/>     android:layout_width="match_parent"<br/>     android:layout_height="match_parent"<br/>     tools:context="com.packtpub.rxjavaapp.MainActivity"&gt;<br/><br/>     &lt;TextView<br/>         android:id="@+id/timer_field"<br/>         android:layout_width="wrap_content"<br/>         android:layout_height="wrap_content"<br/>         android:text="0"<br/>         app:layout_constraintBottom_toBottomOf="parent"<br/>         app:layout_constraintLeft_toLeftOf="parent"<br/>         app:layout_constraintRight_toRightOf="parent"<br/>         app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/> &lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>We can use an <kbd>Observable.interval()</kbd> to emit every second to a <kbd>TextField</kbd>. But we need to decide carefully how and if this counter persists when the app is no longer active. When <kbd>onPause()</kbd> is called, we might want to dispose of this timer operation. When <kbd>onResume()</kbd> is called, we can subscribe again and create a new disposable, effectively restarting the timer. For good measure, we should dispose of it when <kbd>onDestroy()</kbd> is called as well. Here is a simple implementation that manages these life cycle rules:</p>
<pre style="padding-left: 60px"> package com.packtpub.rxjavaapp;<br/><br/> import android.support.v7.app.AppCompatActivity;<br/> import android.os.Bundle;<br/> import android.widget.TextView;<br/><br/> import java.util.concurrent.TimeUnit;<br/><br/> import io.reactivex.Observable;<br/> import io.reactivex.android.schedulers.AndroidSchedulers;<br/> import io.reactivex.disposables.Disposable;<br/><br/> public class MainActivity extends AppCompatActivity {<br/><br/>     private final Observable&lt;String&gt; timer;<br/>     private Disposable disposable;<br/><br/>     MainActivity() {<br/>         timer = Observable.interval(1, TimeUnit.SECONDS)<br/>                 .map(i -&gt; Long.toString(i))<br/>                 .observeOn(AndroidSchedulers.mainThread());<br/>     }<br/><br/>     @Override<br/>     protected void onCreate(Bundle savedInstanceState) {<br/>         super.onCreate(savedInstanceState);<br/>         setContentView(R.layout.activity_main);<br/>     }<br/><br/>     @Override<br/>     protected void onPause() {<br/>         super.onPause();<br/>         disposable.dispose();<br/>     }<br/><br/>     @Override<br/>     protected void onResume() {<br/>         super.onResume();<br/>         TextView tv = (TextView) findViewById(R.id.timer_field);<br/>         disposable = timer.subscribe(s -&gt; tv.setText(s));<br/><br/>     }<br/><br/>     @Override<br/>     protected void onDestroy() {<br/>         super.onDestroy();<br/>         if (disposable != null)<br/>             disposable.dispose();<br/>     }<br/> }</pre>
<p>If you want to persist or save the state of your app, you may have to get creative and find a way to dispose of your reactive operations when <kbd>onPause()</kbd> is called while allowing it to pick up where it left when <kbd>onResume()</kbd> happens. In the following code, I statefully hold the last value emitted from my timer an <kbd>inAtomicInteger</kbd> and use that as the starting value in the event that a pause/resume occurs with a new subscription:</p>
<pre style="padding-left: 60px"> package com.packtpub.rxjavaapp;<br/><br/> import android.support.v7.app.AppCompatActivity;<br/> import android.os.Bundle;<br/> import android.widget.TextView;<br/><br/> import java.util.concurrent.TimeUnit;<br/> import java.util.concurrent.atomic.AtomicInteger;<br/><br/> import io.reactivex.Observable;<br/> import io.reactivex.android.schedulers.AndroidSchedulers;<br/> import io.reactivex.disposables.Disposable;<br/><br/> public class MainActivity extends AppCompatActivity {<br/><br/>     private final Observable&lt;String&gt; timer;<br/>     private final AtomicInteger lastValue = new AtomicInteger(0);<br/>     private Disposable disposable;<br/><br/>     MainActivity() {<br/>         timer = Observable.interval(1, TimeUnit.SECONDS)<br/>                 .map(i -&gt; 1)<br/>                 .startWith(Observable.fromCallable(lastValue::get))<br/>                 .scan((current,next) -&gt; current + next)<br/>                 .doOnNext(lastValue::set)<br/>                 .map(i -&gt; Integer.toString(i))<br/>                 .observeOn(AndroidSchedulers.mainThread());<br/>     }<br/><br/>     @Override<br/>     protected void onCreate(Bundle savedInstanceState) {<br/>         super.onCreate(savedInstanceState);<br/>         setContentView(R.layout.activity_main);<br/>     }<br/><br/>     @Override<br/>     protected void onPause() {<br/>         super.onPause();<br/>         disposable.dispose();<br/>     }<br/><br/>     @Override<br/>     protected void onResume() {<br/>         super.onResume();<br/>         TextView tv = (TextView) findViewById(R.id.timer_field);<br/>         disposable = timer.subscribe(s -&gt; tv.setText(s));<br/><br/>     }<br/><br/>     @Override<br/>     protected void onDestroy() {<br/>         super.onDestroy();<br/><br/>         if (disposable != null)<br/>             disposable.dispose();<br/>     }<br/> }</pre>
<p>So again, make sure you manage your reactive operations carefully and dispose of them deliberately with the life cycle of your app.</p>
<p>Also, make sure that you leverage multicasting for UI events when multiple Observers/Subscribers are listening. This prevents multiple listeners from being attached to widgets, which may not always be efficient. On the other hand, do not add the overhead of multicasting when there is only one <kbd>Observer</kbd>/<kbd>Subscriber</kbd> to a widget's events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we touched on various parts of the rich RxAndroid ecosystem to build reactive Android applications. We covered Retrolambda so we can leverage lambdas with earlier versions of Android that only support Java 6. This way, we do not have to resort to anonymous inner classes to express our RxJava operators. We also touched on RxAndroid, which is the core of the reactive Android ecosystem, and it only contains Android Schedulers. To plug in your various Android widgets, controls, and domain-specific events, you will need to rely on other libraries, such as RxBinding.</p>
<p>In the next chapter, we will cover using RxJava with Kotlin. We will learn how to use this exciting new language, which has essentially become the Swift of Android, and why it works so well with RxJava.</p>


            </article>

            
        </section>
    </body></html>