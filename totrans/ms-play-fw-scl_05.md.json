["```java\ncase class User(id: Long,\n                loginId: String,\n                name: Option[String],\n                dob: Option[Long])\nobject User { def register (loginId: String,...) = {…}\n...\n}\n```", "```java\ncase class Task(id: Int, name: String)\n\nobject Task {\n\n  private var taskList: List[Task] = List()\n\n  def all: List[Task] = {\n    taskList\n  }\n\n  def add(taskName: String) = {\n    val lastId: Int = if (!taskList.isEmpty) taskList.last.id else 0\n    taskList = taskList ++ List(Task(lastId + 1, taskName))\n  }\n\n  def delete(taskId: Int) = {\n    taskList = taskList.filterNot(task => task.id == taskId)\n  }\n}  \n```", "```java\nval appDependencies = Seq(jdbc)\n```", "```java\nval appDependencies = Seq( jdbc,\n\"mysql\" % \"mysql-connector-java\" % \"5.1.18\",...)\n```", "```java\ndb.default.driver=com.mysql.jdbc.Driver\ndb.default.url=\"jdbc:mysql://localhost:3306/app\"\ndb.default.user=\"changeme\"\ndb.default.password=\"changeme\"\n```", "```java\ndb.default.url=\"mysql://user:password@localhost:3306/app\"\ndb.default.url=\"postgres://user:password@localhost:5432/app\"\n```", "```java\ndef fetchDBUser = Action { \n    var result = \"DB User:\" \n    val conn = DB.getConnection() \n    try{ \n val rs = conn.createStatement().executeQuery(\"SELECT USER()\") \n while (rs.next()) { \n result += rs.getString(1) \n } \n } finally { \n conn.close() \n } \n    Ok(result) \n  }\n```", "```java\ndef fetchDBUser = Action { \n    var result = \"DB User:\" \n    DB.withConnection { conn => \n val rs = conn.createStatement().executeQuery(\"SELECT USER()\") \n while (rs.next()) { \n result += rs.getString(1) \n } \n } \n    Ok(result) \n  }\n```", "```java\nval appDependencies = Seq(\n      jdbc,\n      anorm\n)\n```", "```java\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `login_id` varchar(45) NOT NULL,\n  `password` varchar(50) NOT NULL,\n  `name` varchar(45) DEFAULT NULL,\n  `dob` bigint(20) DEFAULT NULL,\n  `is_active` tinyint(1) NOT NULL DEFAULT '1',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `login_id_UNIQUE` (`login_id`),\n  UNIQUE KEY `id_UNIQUE` (`id`)\n) ENGINE=InnoDB\n```", "```java\nDB.withConnection {\n  implicit connection =>\n  val userId  = SQL\"\"\"INSERT INTO user(login_id,password,name,\n dob) VALUES($loginId,$password,$name,$dob)\"\"\".executeInsert()\nuserId\n}\n```", "```java\nimplicit class SqlStringInterpolation(val sc: StringContext) extends AnyVal {\n  def SQL(args: ParameterValue*) = prepare(args)\n\n  private def prepare(params: Seq[ParameterValue]) = {\n    // Generates the string query with \"%s\" for each parameter placeholder\n    val sql = sc.parts.mkString(\"%s\")\n\n    val (ns, ps): (List[String], Map[String, ParameterValue]) =\n        namedParams(params)\n\n      SimpleSql(SqlQuery(sql, ns), ps,\n        defaultParser = RowParser(row => Success(row)))\n    }\n  }\n```", "```java\ncase class SimpleSql[T](sql: SqlQuery, params: Map[String, ParameterValue], defaultParser: RowParser[T]) extends Sql { … }\n```", "```java\nDB.withConnection {\n    implicit connection =>\nSQL\"\"\"UPDATE user SET password=$password WHERE id = $userId\"\"\".executeUpdate()\n}\n```", "```java\ndef userRow:RowParser[User] = {\n    get[Long](\"id\") ~\n      get[String](\"login_id\") ~\n      get[Option[String]](\"name\") map {\n      case id ~ login_id ~ name  =>  User(id, login_id, name)\n    }\n  }\n```", "```java\nDB.withConnection {\n  implicit connection =>\n  val query = \"SELECT id,login_id,name FROM user\"\n  SQL(query).as(userRow.*)\n}\n```", "```java\nDB.withConnection {\n  implicit connection =>\nval insertQuery  = \"\"\"INSERT INTO user(login_id,password,name,\n  |dob) VALUES({loginId},{password},{name},{dob})\"\"\".stripMargin\nval userId = SQL(insertQuery).on(\n  'loginId -> loginId,\n  'password -> password,\n  'name -> name,\n  'dob -> dob).executeInsert()\nuserId\n}\n```", "```java\n def on(args: NamedParameter*): SimpleSql[T] =\n    copy(params = this.params ++ args.map(_.tupled))\n```", "```java\n\"com.typesafe.play\" %% \"play-slick\" % \"0.8.1\"\nLet's see how we can define user operations using Slick.\n```", "```java\ncase class SlickUser(id: Long, loginId: String, name: String) \n\nclass SlickUserTable(tag: Tag) extends Table[SlickUser](tag, \"user\") { \n  def id = column[Long](\"id\", O.PrimaryKey, O.AutoInc) \n\n  def loginId = column[String](\"login_id\") \n\n  def name = column[String](\"name\") \n\n  def dob = column[Long](\"dob\") \n\n  def password = column[String](\"password\") \n\n  def * = (id, loginId, name) <>(SlickUser.tupled, SlickUser.unapply) \n}\n```", "```java\nobject SlickUserHelper { \n  val users = TableQuery[SlickUserTable] \n\n  def add(loginId: String, \n          password: String, \n          name: String = \"anonymous\", \n          dateOfBirth: DateTime): Long = { \n\n    play.api.db.slick.DB.withSession { implicit session => \n      users.map(p => (p.loginId, p.name, p.dob, p.password)) \n        .returning(users.map(_.id)) \n        .insert((loginId, name, dateOfBirth.getMillis, password)) \n    } \n  } \n\n  def updatePassword(userId: Long, \n                   password: String) = { \n\n    play.api.db.slick.DB.withSession { implicit session => \n      users.filter(_.id === userId) \n        .map(u => u.password) \n        .update(password) \n    } \n  } \n\n  def getAll: Seq[SlickUser] = { \n    play.api.db.slick.DB.withSession { implicit session => \n      users.run \n    } \n  } \n}\n```", "```java\n    libraryDependencies ++= Seq(\n      \"org.reactivemongo\" %% \"play2-reactivemongo\" % \"0.10.5.0.akka23\"\n    )\n    ```", "```java\n    1100:play.modules.reactivemongo.ReactiveMongoPlugin\n    ```", "```java\n    mongodb.servers = [\"localhost:27017\"]\n    mongodb.db = \"your_db_name\"\n    mongodb.credentials.username = \"user\"\n    mongodb.credentials.password = \"pwd\"\n    ```", "```java\n    mongodb.uri = \"mongodb://user:password@localhost:27017/your_db_name\"\n    ```", "```java\n{\n\"deviceId\" : \"aghd\",\n\"ownerId\" : \"someUser@someMail.com\"\n\"config\" : { \"sensitivity\" : 4, …},\n\"info\" : {\"brand\" : \"superBrand\",\"os\" : \"xyz\",\"version\" : \"2.4\", …}\n}\n```", "```java\n    def registerDevice(deviceId: String, \n                        ownerId: String, \n                  deviceDetails: JsObject): Future[LastError] = { \n\n        var newDevice = Json.obj(\"deviceId\" -> deviceId, \"ownerId\" -> ownerId.trim) \n        val config = (deviceDetails \\ \"configuration\").asOpt[JsObject] \n        val metadata = (deviceDetails \\ \"metadata\").asOpt[JsObject] \n        if (!config.isDefined) \n          newDevice = newDevice ++ Json.obj(\"configuration\" -> Json.parse(\"{}\")) \n        if (!metadata.isDefined) \n          newDevice = newDevice ++ Json.obj(\"metadata\" -> Json.parse(\"{}\")) \n\n        collection.insert[JsValue](newDevice) \n      }\n    ```", "```java\ndef db = ReactiveMongoPlugin.db\n\ndef collection = db.collection(\"devices\")\n```", "```java\nThe db operations for fetching a device or removing it are simple,def fetchDevice(deviceId: String): Future[Option[JsObject]] = { \n    val findDevice = Json.obj(\"deviceId\" -> deviceId) \n    collection.find(findDevice).one[JsObject] \n  } \n\n  def removeDeviceById(deviceId: String): Future[LastError] = { \n    val removeDoc = Json.obj(\"deviceId\" -> deviceId) \n    collection.remove[JsValue](removeDoc) \n  }\n```", "```java\n{ \"sensitivity\": 4.5}\n```", "```java\n    def updateConfiguration(deviceId: String, \n                     ownerId: String, \n                updatedField: JsObject) = { \n    val property = updatedField.keys.head \n    val propertyValue = updatedField.values.head \n    val toUpdate = Json.obj(s\"configuration.$property\" -> propertyValue) \n    val setData = Json.obj(\"$set\" -> toUpdate) \n    val documentToUpdate = Json.obj(\"deviceId\" -> deviceId, \"ownerId\" -> ownerId) \n    collection.update[JsValue, JsValue](documentToUpdate, setData) \n  }\n```", "```java\ndb.devices.update(\n   { deviceId: \"aghd\" ,\"ownerId\" : \"someUser@someMail.com\"},\n   { $set: { \"configuration.sensitivity\": 4.5 } }\n)\n```", "```java\nlibraryDependencies ++= Seq(cache)\n```", "```java\nCache.set(\"userSession\", session)\n\nval maybeSession: Option[UserSession] = Cache.getAs[UserSession](\"userSession\")\n\nCache.remove(\"userSession\")\n```", "```java\nclass EhCacheImpl(private val cache: Ehcache) extends CacheAPI {\n\n  def set(key: String, value: Any, expiration: Int) {\n    val element = new Element(key, value)\n    if (expiration == 0) element.setEternal(true)\n    element.setTimeToLive(expiration)\n    cache.put(element)\n  }\n\n  def get(key: String): Option[Any] = {\n    Option(cache.get(key)).map(_.getObjectValue)\n  }\n\n  def remove(key: String) {\n    cache.remove(key)\n  }\n}\n```", "```java\ndef getInactiveUsers = Cached(\"inactiveUsers\") {\n  Action {\n    val users = User.getAllInactive\n    Ok(Json.toJson(users))\n  }\n}\n```", "```java\ndef getInactiveUsers = Cached(\"inactiveUsers\").default(3600) {\n  Action {\n    val users = User.getAllInactive\n    Ok(Json.toJson(users))\n  }\n}\n```", "```java\ncase class Cached(key: RequestHeader => String, caching: PartialFunction[ResponseHeader, Duration]) { … }\n```", "```java\ndef build(action: EssentialAction)(implicit app: Application) = EssentialAction { request =>\n    val resultKey = key(request)\n    val etagKey = s\"$resultKey-etag\"\n\n    // Has the client a version of the resource as fresh as the last one we served?\n    val notModified = for {\n      requestEtag <- request.headers.get(IF_NONE_MATCH)\n      etag <- Cache.getAs[String](etagKey)\n      if requestEtag == \"*\" || etag == requestEtag\n    } yield Done[Array[Byte], Result](NotModified)\n\n    notModified.orElse {\n      // Otherwise try to serve the resource from the cache, if it has not yet expired\n      Cache.getAs[Result](resultKey).map(Done[Array[Byte], Result](_))\n    }.getOrElse {\n      // The resource was not in the cache, we have to run the underlying action\n      val iterateeResult = action(request)\n\n      // Add cache information to the response, so clients can cache its content\n      iterateeResult.map(handleResult(_, etagKey, resultKey, app))\n    }\n  }\n```", "```java\nprivate def handleResult(result: Result, etagKey: String, resultKey: String, app: Application): Result = {\n  cachingWithEternity.andThen { duration =>\n    // Format expiration date according to http standard\n    val expirationDate = http.dateFormat.print(System.currentTimeMillis() + duration.toMillis)\n      // Generate a fresh ETAG for it\n      val etag = expirationDate // Use the expiration date as ETAG\n\n      val resultWithHeaders = result.withHeaders(ETAG -> etag, EXPIRES -> expirationDate)\n\n      // Cache the new ETAG of the resource\n      Cache.set(etagKey, etag, duration)(app)\n      // Cache the new Result of the resource\n      Cache.set(resultKey, resultWithHeaders, duration)(app)\n\n      resultWithHeaders\n    }.applyOrElse(result.header, (_: ResponseHeader) => result)\n  }\n```", "```java\n    DB.withConnection {\n            implicit connection => {\n\n      val updatedRows = SQL\"\"\"INSERT INTO wish_list (user_id, product_id, liked_at) VALUES ($userId,$productId,$likedAt)\n        ON DUPLICATE KEY UPDATE liked_at=$likedAt, is_deleted=false \"\"\".executeUpdate()\n\n      updatedRows == 1\n      }\n    }\n    ```"]