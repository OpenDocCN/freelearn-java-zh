<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;JSF 2.2 Resource Library Contracts &#x2013; Themes"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. JSF 2.2 Resource Library Contracts – Themes</h1></div></div></div><p>Starting with version 2.0, JSF developers exploit Facelets as the default<a id="id1374" class="indexterm"/> <span class="strong"><strong>View Declaration Language</strong></span> (<span class="strong"><strong>VDL</strong></span>). Facelets provide many advantages, but we are especially interested in using <span class="strong"><strong>Facelet templates</strong></span>, <a id="id1375" class="indexterm"/>which represent a mix of XHTML and other resources such as CSS, JS, and images. A Facelet template acts as a base (or a model) for the application pages. Practically, it represents a piece of reusable code that serves as a consistent and standard look and feel for the application pages. In the final chapter of this book, we will get more into the details of Facelets and templating, while in this chapter we will focus on the new JSF 2.2 feature<a id="id1376" class="indexterm"/> known as <span class="strong"><strong>Resource Library Contracts</strong></span>.</p><p>This new feature fortifies and simplifies the implementation of <span class="strong"><strong>themes</strong></span> (such as PrimeFaces or RichFaces) by allowing us to easily decorate and use Facelet templates over the entire application in a reusable and flexible approach.</p><p>In this chapter, you will see how to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Work with contracts</li><li class="listitem" style="list-style-type: disc">Style the JSF tables and UI components using contracts</li><li class="listitem" style="list-style-type: disc">Style contracts across different kinds of devices</li><li class="listitem" style="list-style-type: disc">Write contracts for composite components</li><li class="listitem" style="list-style-type: disc">Write a theme switcher</li><li class="listitem" style="list-style-type: disc">Configure contracts in XML</li><li class="listitem" style="list-style-type: disc">Package contracts in JARs</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note183"/>Note</h3><p>Further, keep in mind to correctly interpret the <span class="emphasis"><em>contracts</em></span> word in the current context. It can be used to define the concepts such as the <code class="literal">contracts</code> folder, the <code class="literal">contracts</code> attribute, or the <code class="literal">&lt;contracts&gt;</code> tag. Sometimes, it may get confusing.</p></div></div><div class="section" title="Working with contracts"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec89"/>Working with contracts</h1></div></div></div><p>Contracts consist of templates and CSS files that are grouped under the <code class="literal">contracts</code> folder. In order to <a id="id1377" class="indexterm"/>define contracts, we need to respect some conventions under the root directory of Web application. The most important conventions (for example, names, structure, and content) concern folders that are involved in the defining of contracts. All contracts are stored under a special folder—named <code class="literal">contracts</code>—placed directly under the Web root of the application, or under the <code class="literal">META-INF</code> folder that resides in a JAR file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note184"/>Note</h3><p>We can alter the location and the name of this folder via <code class="literal">WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME</code> context parameter. The value of this context parameter must not start with a slash (<code class="literal">/</code>), though it may contain a slash. The runtime will interpret this value as a path relative to the Web root of the application.</p></div></div><p>Commonly, under the <code class="literal">contracts</code> folder, we define a subfolder for each contract (the subfolder's name represents the contract's name), which contains the contract's artifacts such as the CSS, JS, images, and XHTML templates (you can separate resources such as CSS, JS, and images from the XHTML templates by adding them into representative subfolders).</p><p>In the following screenshot, you can see the folder structure for two contracts (<code class="literal">rafa1</code> and <code class="literal">rafa2</code>) in the same application, named <code class="literal">ch11_1</code>:</p><div class="mediaobject"><img src="graphics/6466EN_11_01.jpg" alt="Working with contracts"/></div><p>In our example, the source code for <code class="literal">rafa1/template.xhtml</code> and <code class="literal">rafa2/template.xhtml</code> is identical (of course, this is not mandatory); however, they just use different CSS files. These XHTML files serve as templates for the application pages. The listing of <code class="literal">rafa1/template.xhtml</code> is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
  
  &gt;
  &lt;h:head&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet name="styles.css"/&gt;
    &lt;div class="header"&gt;
      &lt;ui:insert name="header"/&gt;
    &lt;/div&gt;
    &lt;div class="content"&gt;
      &lt;ui:insert name="content"/&gt;
    &lt;/div&gt;
    &lt;div class="footer"&gt;
      &lt;ui:insert name="footer"/&gt;
    &lt;/div&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Further, you can<a id="id1378" class="indexterm"/> use the contracts directly in the application web pages, thanks to the new JSF 2.2 attribute of the <code class="literal">&lt;f:view&gt;</code> tag named <code class="literal">contracts</code> (this has to be placed in the template client). The value of this attribute should be the contract name that you want to use. For example, if you want to use the contract named <code class="literal">rafa2</code>, you can write this in the <code class="literal">index.xhtml</code> page as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
  
  
  &gt;
  &lt;h:head&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;f:view contracts="rafa2"&gt;&lt;!-- switch to rafa1 to see first theme --&gt;
    &lt;ui:composition template="/template.xhtml"&gt;
      &lt;ui:define name="header"&gt;
        &lt;p&gt;Rafael Nadal photos - header&lt;/p&gt;
      &lt;/ui:define&gt;
      &lt;ui:define name="content"&gt;
        &lt;h:graphicImage
          value="#{resource['default/images:RafaelNadal.jpg']}"/&gt;
      &lt;/ui:define&gt;
      &lt;ui:define name="footer"&gt;
        &lt;p&gt;Rafael Nadal photos - footer&lt;/p&gt;
      &lt;/ui:define&gt;
    &lt;/ui:composition&gt;
    &lt;/f:view&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>In order to use the <a id="id1379" class="indexterm"/>contract named <code class="literal">rafa1</code>, you just need to specify this name as the value of the <code class="literal">contracts</code> attribute.</p><p>The complete application is named <code class="literal">ch11_1</code>.</p></div></div>
<div class="section" title="Styling tables with contracts"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec90"/>Styling tables with contracts</h1></div></div></div><p>Now that you know how to write and use contracts, you can try to play around with this great feature for creating<a id="id1380" class="indexterm"/> different kinds of styles/themes for <a id="id1381" class="indexterm"/>your pages. Most of the time, creating cool themes involves two things: having a cool and flexible templating mechanism and having solid knowledge of CSS and JS.</p><p>For example, we can try to write two cool themes for the JSF tables. First, we'll define two contracts named <code class="literal">tableBlue</code> and <code class="literal">tableGreen</code>. The XHTML template, in both the cases, will have the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
  
  &gt;
  &lt;h:head&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet name="styles.css"/&gt;
    &lt;div class="content"&gt;
      &lt;ui:insert name="content"/&gt;
    &lt;/div&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Now, you<a id="id1382" class="indexterm"/> can use the <code class="literal">tableBlue</code> or <code class="literal">tableGreen</code> contract, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">...
  &lt;h:body&gt;
    &lt;f:view contracts="tableBlue"&gt;
      &lt;ui:composition template="/template.xhtml"&gt;
        &lt;ui:define name="content"&gt;
          &lt;h:dataTable value="#{playersBean.data}" var="t" border="1"&gt;
            &lt;h:column&gt;
              &lt;f:facet name="header"&gt;
                Ranking
              &lt;/f:facet&gt;
              #{t.ranking}
            &lt;/h:column&gt;
            ...
          &lt;/h:dataTable&gt;
        &lt;/ui:define&gt;
      &lt;/ui:composition&gt;
    &lt;/f:view&gt;
  &lt;/h:body&gt;
...</pre></div><p>The result<a id="id1383" class="indexterm"/> will be as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_11_02.jpg" alt="Styling tables with contracts"/></div><p>As you can see, there is no need to specify a class or a style attribute for <code class="literal">&lt;h:dataTable&gt;</code>. The idea is pretty simple; JSF renders <code class="literal">&lt;h:dataTable&gt;</code> using HTML tags such as <code class="literal">&lt;table&gt;</code>, <code class="literal">&lt;tr&gt;</code>, <code class="literal">&lt;td&gt;</code>, <code class="literal">&lt;tbody&gt;</code>, <code class="literal">&lt;thead&gt;</code>, and <code class="literal">&lt;tfoot&gt;</code>. So, if we write a CSS style sheet that customizes the aspect of these HTML tags, then we will obtain the desired results. For <code class="literal">&lt;h:dataTable&gt;</code>, a basic CSS may contain the following classes (<code class="literal">content</code> matches the value of the <code class="literal">name</code> attribute of the <code class="literal">&lt;ui:define&gt;</code> component):</p><div class="informalexample"><pre class="programlisting">.content {}
.content table {}
.content table td,.content table th {}
.content table thead th {}
.content table thead th:first-child {}
.content table tbody td {}
.content table tbody .alt td {}
.content table tbody td:first-child {}
.content table tbody tr:last-child td {}</pre></div><p>Sometimes, you may need to add pagination to your tables. JSF doesn't provide attributes for this task (unlike the <code class="literal">&lt;p:dataTable&gt;</code> tag in PrimeFaces). But, as an example, you may fix this issue if<a id="id1384" class="indexterm"/> you write a footer, like the following<a id="id1385" class="indexterm"/> code snippet—of course, the <code class="literal">&lt;div&gt;</code> content should be dynamically generated and controlled (for more details, see <a class="link" href="ch06.html" title="Chapter 6. Working with Tabular Data">Chapter 6</a>, <span class="emphasis"><em>Working with Tabular Data</em></span>):</p><div class="informalexample"><pre class="programlisting"> ...
  &lt;f:facet name="footer"&gt;
    &lt;div id="paging"&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;a href="#"&gt;
            &lt;span&gt;Previous&lt;/span&gt;
          &lt;/a&gt;
        &lt;/li&gt;
        ...
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/f:facet&gt;
&lt;/h:dataTable&gt;</pre></div><p>Now, you need to add a few CSS classes to control the pagination aspect, as follows:</p><div class="informalexample"><pre class="programlisting">.content table tfoot td div {}
.content table tfoot td {}
.content table tfoot td ul {}
.content table tfoot li {}
.content table tfoot li a {}
.content table tfoot ul.active,.content table tfoot ul a:hover {}</pre></div><p>The result is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_11_03.jpg" alt="Styling tables with contracts"/></div><p>Special thanks to Eli Geske, the author of <span class="emphasis"><em>Learning DHTMLX Suite UI</em></span> (<a class="ulink" href="http://www.packtpub.com/learning-dhtmlx-suite-ui/book">http://www.packtpub.com/learning-dhtmlx-suite-ui/book</a>). His free online CSS3 table generator (you can find HTML Table Style Generator at <a class="ulink" href="http://tablestyler.com/">http://tablestyler.com/</a>) was really<a id="id1386" class="indexterm"/> useful to accomplish the result in this section.</p><p>The complete<a id="id1387" class="indexterm"/> application is named <code class="literal">ch11_3</code>.</p></div>
<div class="section" title="Styling UI components with contracts"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec91"/>Styling UI components with contracts</h1></div></div></div><p>Based on the<a id="id1388" class="indexterm"/> preceding example, we can write styles/themes for all the JSF UI components. In this section, you can see an example that<a id="id1389" class="indexterm"/> focuses on JSF UI components that usually appear in forms such as <code class="literal">&lt;h:inputText&gt;</code>, <code class="literal">&lt;h:inputTextarea&gt;</code>, <code class="literal">&lt;h:selectOneMenu&gt;</code>, <code class="literal">&lt;h:selectManyCheckbox&gt;</code>, and so on. Practically, we want to obtain something like the following screenshot (this is just a sample form):</p><div class="mediaobject"><img src="graphics/6466EN_11_04.jpg" alt="Styling UI components with contracts"/></div><p>We start by defining <a id="id1390" class="indexterm"/>a new contract named <code class="literal">jsfui</code>. The template is pretty simple, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
  
  &gt;
  &lt;h:head&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet name="styles.css"/&gt;
    &lt;div class="content"&gt;
      &lt;ui:insert name="content"/&gt;
    &lt;/div&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Now, we just need to<a id="id1391" class="indexterm"/> write the CSS classes that correspond to the HTML elements rendered by JSF, as follows:</p><div class="informalexample"><pre class="programlisting">.content input[type=text] {}      /* &lt;h:inputText&gt; */
.content input[type=submit] {}    /* &lt;h:commandButton&gt; */
.content textarea {}              /* &lt;h:inputTextarea&gt; */
.content label {}                 /* &lt;h:outputLabel&gt; */
.content select {}                /* &lt;h:selectOneMenu&gt;, 
                                     &lt;h:selectOneListbox&gt;, 
                                     &lt;h:selectManyMenu&gt;, 
                                     &lt;h:selectManyListbox&gt; */
.content input[type=radio] {}     /* &lt;h:selectOneRadio&gt; */
.content input[type=checkbox] {}  /* &lt;h:selectManyCheckbox&gt; */</pre></div><p>You can easily<a id="id1392" class="indexterm"/> add CSS classes for the rest of UI components. Further, you can write JSF forms with a custom theme, just by specifying the<a id="id1393" class="indexterm"/> theme name as the value of the <code class="literal">contracts</code> attribute:</p><div class="informalexample"><pre class="programlisting">...
&lt;f:view contracts="jsfui"&gt;
&lt;ui:composition template="/template.xhtml"&gt;
&lt;ui:define name="content"&gt;
...</pre></div><p>The complete application is named <code class="literal">ch11_2</code>.</p></div>
<div class="section" title="Styling contracts across different devices"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec92"/>Styling contracts across different devices</h1></div></div></div><p>In the preceding examples, we saw how to write the JSF contracts and how to use them by explicitly setting them<a id="id1394" class="indexterm"/> by name in the <code class="literal">contracts</code> attribute of the <code class="literal">&lt;f:view&gt;</code> tag. Sometimes, you may need to dynamically set a contract (theme); for example, you may need to choose the right contract based on the device type that should display the application (PC, tablet, smartphone, mobile phone, and so on). In this case, you need to provide the <code class="literal">contracts</code> attribute value from a managed bean.</p><p>It is beyond the scope of this book to provide a powerful code (or algorithm) for detecting device types, resolutions, and so on. With minimum involvement in the mobile area, we will try to write a JSF application capable of choosing the right contract depending on the device type. Practically, we will define the following four contracts (do not consider the following associations between resolutions and devices as a certified or authorized decision):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">contracts/browserpc</code>: This contract applies<a id="id1395" class="indexterm"/> to PCs (it will be the default)</li><li class="listitem" style="list-style-type: disc"><code class="literal">contracts/Device640</code>: This contract applies<a id="id1396" class="indexterm"/> to tablets (we suppose that, for any kind of tablet, a resolution of 640 pixels width is a reasonable choice)</li><li class="listitem" style="list-style-type: disc"><code class="literal">contracts/Device480</code>: This<a id="id1397" class="indexterm"/> contract applies to smartphones (we suppose that, for any kind of smartphone, a resolution of 480 pixels width is a reasonable choice)</li><li class="listitem" style="list-style-type: disc"><code class="literal">contracts/Device320</code>: This contract applies<a id="id1398" class="indexterm"/> to normal mobile phones (we suppose that, for any kind of mobile phone, a resolution of 320 pixels width is a reasonable choice)</li></ul></div><p>Now, we will write a simple managed bean that will detect the device type based on the helper class named <code class="literal">UAgentInfo</code> (visit <a class="ulink" href="http://blog.mobileesp.com/">http://blog.mobileesp.com/</a>). Basically, this class detects different kinds of devices based on the HTTP request headers, <code class="literal">User-Agent</code> and <code class="literal">Accept</code>. Based on this detection, we can set a managed bean property with the name of the correct contract. The managed bean code is as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@SessionScoped
public class ThemeBean implements Serializable {

  private String theme = "browserpc";

  public String getTheme() {
    return theme;
  }

  public void setTheme(String theme) {
    this.theme = theme;
  }

  publicThemeBean() {
    Map&lt;String, String&gt;getRequestMap = FacesContext.getCurrentInstance().getExternalContext().getRequestHeaderMap();
    String userAgent = getRequestMap.get("User-Agent");
    String httpAccept = getRequestMap.get("Accept");

    UAgentInfo detector = new UAgentInfo(userAgent, httpAccept);

    if (detector.isMobilePhone) {
      if ((detector.detectSmartphone())) {
        System.out.println("SMARTPHONE THEME!");
        theme = "Device480";
      } else {
        System.out.println("SIMPLE MOBILE THEME!");
        theme = "Device320";
      }
    } else {
      if (detector.detectTierTablet()) {
        System.out.println("TABLET THEME!");
        theme = "Device640";
      } else {
        System.out.println("BROWSER THEME!");
        theme = "browserpc";
      }
    }
  }
}</pre></div><p>Each of these<a id="id1399" class="indexterm"/> contracts contains an XHTML template and a CSS file named <code class="literal">styles.css</code>. Each CSS file contains classes for styling the output for a resolution type. The template is the same for all contracts and is pretty simple, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
  
  &gt;
  &lt;h:head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt;
    &lt;meta name="HandheldFriendly" content="true"/&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"/&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet name="styles.css"/&gt;
    &lt;div class="content"&gt;
      &lt;ui:insert name="content"/&gt;
    &lt;/div&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Let's take a simple page, as shown in the following screenshot. (The JSF code is straightforward<a id="id1400" class="indexterm"/> and you can see it in the complete application named <code class="literal">ch11_4</code>.) This view is for desktop browsers.</p><div class="mediaobject"><img src="graphics/6466EN_11_05.jpg" alt="Styling contracts across different devices"/></div><p>The relevant JSF code for this page consists of adding the right contract:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;f:view contracts="#{themeBean.theme}"&gt;
  &lt;ui:composition template="/template.xhtml"&gt;
  &lt;ui:define name="content"&gt;
...</pre></div><p>Done! Now, you<a id="id1401" class="indexterm"/> can easily perform some test using a mobile emulator, such as Opera Mobile Operator. In the following screenshot, you can see the same page as that on a Samsung Galaxy Tab, at a resolution of 1024x600 (PPI: 240):</p><div class="mediaobject"><img src="graphics/6466EN_11_06.jpg" alt="Styling contracts across different devices"/></div><p>Further, the same page can be rendered for mobile phone devices: shown on the left is Motorola Atrix4G at a resolution of 540x960 (PPI: 267) and on the right is a Nokia N9 mobile phone at resolution of 320x480 (PPI: 252):</p><div class="mediaobject"><img src="graphics/6466EN_11_07.jpg" alt="Styling contracts across different devices"/></div><p>Notice that we<a id="id1402" class="indexterm"/> can reduce the preceding example to a single contract and without a managed bean, by using responsive CSS. Instead of using four contracts (<code class="literal">browserpc</code>, <code class="literal">Device640</code>, <code class="literal">Device480</code>, and <code class="literal">Device320</code>), you can use a single contract; let's name it <code class="literal">alldevices</code>. We place two CSS files under the <code class="literal">alldevices</code> contract: a general CSS file (<code class="literal">styles.css</code>) and the responsive CSS file (<code class="literal">responsive.css</code>). Further, we modify the <code class="literal">template.xhtml</code> file to load both the CSS files using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h:outputStylesheet name="styles.css"/&gt;
  &lt;h:outputStylesheet name="responsive.css"/&gt;
  ...
&lt;/h:body&gt;</pre></div><p>In the final step, we set this contract on the JSF page of the application, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;f:view contracts="alldevices"&gt;
  &lt;ui:composition template="/template.xhtml"&gt;
  &lt;ui:define name="content"&gt;
...</pre></div><p>Done! The complete application is named <code class="literal">ch11_5</code>.</p><p>Another approach consists of writing a custom <code class="literal">RenderKitFactory</code> class, a custom <code class="literal">RenderKit</code> class and a set of custom <code class="literal">Renderers</code> classes—one for each device. For example, using these artifacts, the application named <code class="literal">ch11_15</code> shows you how to render, for different devices, the Temperature custom<a id="id1403" class="indexterm"/> component developed in <a class="link" href="ch10.html" title="Chapter 10. JSF Custom Components">Chapter 10</a>, <span class="emphasis"><em>JSF Custom Components</em></span>.</p></div>
<div class="section" title="Writing contracts for composite components"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec93"/>Writing contracts for composite components</h1></div></div></div><p>In this section, you will<a id="id1404" class="indexterm"/> see how to write contracts for composite components. For this, we will use the Temperature composite<a id="id1405" class="indexterm"/> component developed in <a class="link" href="ch10.html" title="Chapter 10. JSF Custom Components">Chapter 10</a>, <span class="emphasis"><em>JSF Custom Components</em></span>. The implementation section in the code is given as follows:</p><div class="informalexample"><pre class="programlisting">&lt;cc:implementation&gt;
  &lt;div id="#{cc.clientId}:tempconv_main"&gt;
    &lt;h:outputLabel id="tempconv_smlabel" for="tempconv_selectonemenu" value="Convert to:"/&gt;
    &lt;h:selectOneMenu id="tempconv_selectonemenu" binding="#{cc.unittoI}"&gt;
      &lt;f:selectItem itemValue="fahrenheit" itemLabel="fahrenheit" /&gt;
      &lt;f:selectItem itemValue="celsius" itemLabel="celsius" /&gt;
    &lt;/h:selectOneMenu&gt;
    &lt;h:outputLabel id="tempconv_iflabel" for="tempconv_inputfield" value="Insert value:"/&gt;
    &lt;h:inputText id="tempconv_inputfield" binding="#{cc.temptI}"/&gt;
    &lt;h:commandButton id="tempconv_button" value="Convert"&gt;
      &lt;f:ajax execute="@form" render="@form"/&gt;
    &lt;/h:commandButton&gt;
    &lt;h:panelGroup id="tempconv_result" layout="block"&gt;
      &lt;h:outputText value="&amp;deg; #{cc.unittoI.valueeq 'fahrenheit' ? 'F ':   'C ' } #{cc.getTempConvert()}"/&gt;
    &lt;/h:panelGroup&gt;
  &lt;/div&gt;
&lt;/cc:implementation&gt;</pre></div><p>The IDs of subcomponents<a id="id1406" class="indexterm"/> are used to define<a id="id1407" class="indexterm"/> the CSS file used for styling the composite component. Therefore, we need to write the following CSS classes. Notice how we exploit CSS wildcards to find the subcomponents.</p><div class="informalexample"><pre class="programlisting">.content {}
.content *[id*='tempconv_main'] {}
.content *[id*='tempconv_result'] {}
.content *[id*='tempconv_inputfield'] {}
.content *[id*='tempconv_button'] {}
.content *[id*='tempconv_inputfield']:hover {}
.content *[id*='tempconv_inputfield']:active {}
.content *[id*='tempconv_smlabel'] {}
.content *[id*='tempconv_iflabel'] {}
.content *[id*='tempconv_selectonemenu'] {}</pre></div><p>Further, we place this CSS file under the same contract with the following XHTML template:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
  
  &gt;
  &lt;h:head&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet name="styles.css"/&gt;
    &lt;div class="content"&gt;
      &lt;ui:insert name="content"/&gt;
    &lt;/div&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Finally, use<a id="id1408" class="indexterm"/> the composite component<a id="id1409" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">...
&lt;f:view contracts="tempStyleGray"&gt;
  &lt;ui:composition template="/template.xhtml"&gt;
    &lt;ui:define name="content"&gt;
      &lt;h3&gt;Composite component with contract:&lt;/h3&gt;
      &lt;h:form id="tempForm"&gt;
       &lt;t:temperature id="temp" value="#{tempBean.value}" /&gt;
      &lt;/h:form&gt;
    &lt;/ui:define&gt;
  &lt;/ui:composition&gt;
&lt;/f:view&gt;
...</pre></div><p>Notice that we have defined two contracts: <code class="literal">tempStyleGray</code> (first bar in the following screenshot) and <code class="literal">tempStyleGreen</code> (second bar in the following screenshot):</p><div class="mediaobject"><img src="graphics/6466EN_11_08.jpg" alt="Writing contracts for composite components"/></div><p>The complete application is named <code class="literal">ch11_6</code>.</p></div>
<div class="section" title="Writing a theme switcher"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec94"/>Writing a theme switcher</h1></div></div></div><p>If you are a PrimeFaces fan, then I'm sure you have seen the PrimeFaces theme switcher. Basically, a theme switcher<a id="id1410" class="indexterm"/> is represented by a drop-down menu that contains themes' names and thumbnails. End users can switch between application's themes just by selecting it from the list.</p><p>In this section, you will see how to develop a theme switcher using the JSF 2.2 contracts. The goal is to obtain a theme switcher so that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It can be added as a JAR in any JSF 2.2 application</li><li class="listitem" style="list-style-type: disc">It can automatically detect and list the themes of an application</li><li class="listitem" style="list-style-type: disc">It can give a nice look and feel, as shown in the following screenshot (shown on the left-hand side is the PrimeFaces theme switcher, and on the right-hand side is our theme switcher)<div class="mediaobject"><img src="graphics/6466EN_11_09.jpg" alt="Writing a theme switcher"/></div></li></ul></div><p>Obviously, this kind of a drop-down menu cannot be generated using the built-in <code class="literal">&lt;h:selectOneMenu&gt;</code> tag. In order to customize a drop-down menu with images and description, we can write a dedicated <code class="literal">Renderer</code>, or try to use a JavaScript plugin capable of rendering it like in the preceding screenshot. Well, the second option is much easier to accomplish and doesn't require us to reinvent the wheel. Practically, we can use a free and cool jQuery plugin named<a id="id1411" class="indexterm"/> <span class="strong"><strong>ddSlick</strong></span> (<a class="ulink" href="http://designwithpc.com/Plugins/ddSlick">http://designwithpc.com/Plugins/ddSlick</a>), which is a free light-weight jQuery plugin that allows you to create a custom drop-down menu with images and description. There are many other such plugins that do the same thing.</p><p>Basically, this plugin is capable of transforming a simple drop-down menu (defined using <code class="literal">&lt;select&gt;</code> and <code class="literal">&lt;option&gt;</code>) into a fancy drop-down menu that contains images and descriptions. For this, we start with a pure HTML5 <code class="literal">&lt;select&gt;</code> tag, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;select id="demo-htmlselect"&gt;
  &lt;option value="0" data-imagesrc="http://..."
    data-description="Description ..."&gt;text&lt;/option&gt;
  &lt;option value="1" data-imagesrc="http://..."
    data-description="Description ..."&gt;text&lt;/option&gt;
  ...
&lt;/select&gt;</pre></div><p>When this <code class="literal">&lt;select&gt;</code> tag<a id="id1412" class="indexterm"/> passes through ddSlick, it will result in the desired drop-down menu. Basically, ddSlick will render the <code class="literal">&lt;select&gt;</code> tag as a <code class="literal">&lt;ul&gt;</code> tag and each <code class="literal">&lt;option&gt;</code> tag as <code class="literal">&lt;li&gt;</code>. The images and descriptions are rendered using <code class="literal">&lt;img&gt;</code> and <code class="literal">&lt;small&gt;</code>, while the option's text is <a id="id1413" class="indexterm"/>rendered using <code class="literal">&lt;label&gt;</code>. Moreover, an input hidden will be generated for each <code class="literal">&lt;option&gt;</code> value. The HTML5 attributes <code class="literal">data-imagesrc</code> and <code class="literal">data-description</code> are used to tell ddSlick what images and descriptions to use for each <code class="literal">&lt;option&gt;</code>.</p><p>It is important to understand how ddSlick works, because we will wrap it into a composite component<a id="id1414" class="indexterm"/> named <code class="literal">ThemeSwitcher</code>. The interface section is very simple and contains a single attribute named <code class="literal">theme</code>. This attribute represents the selected theme, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interfacecomponentType="book.beans.ThemeSwitcherComponent"&gt;
&lt;cc:attribute name="theme" default="" type="java.lang.String" required="true"/&gt;
&lt;/cc:interface&gt;</pre></div><p>In the implementation section, we accomplish several tasks. First, we load the JavaScript libraries needed by our component:</p><div class="informalexample"><pre class="programlisting">&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
  &lt;h:outputScript library="themeswitcher" name="js/jquery.min.js"/&gt;
  &lt;h:outputScript library="themeswitcher" name="js/modernizr-2.0.6-development-only.js"/&gt;
  &lt;h:outputScript library="themeswitcher" name="js/jquery-ui.min.js"/&gt;
  &lt;h:outputScript library="themeswitcher" name="js/prettify.js"/&gt;
  &lt;h:outputScript library="themeswitcher" name="js/ddslick.js"/&gt;
  ...</pre></div><p>Further, we define HTML's <code class="literal">&lt;select&gt;</code> component encapsulated in <code class="literal">&lt;h:form&gt;</code> (ideally, this component is not used in <code class="literal">&lt;h:form&gt;</code> with other components; therefore, we don't have to worry about the nested forms):</p><div class="informalexample"><pre class="programlisting">&lt;div id="#{cc.clientId}:themeswitcher"&gt;
  &lt;h:form id="themeswitcherForm"&gt;
    &lt;!--&lt;h:outputScript name="jsf.js" library="javax.faces" target="head"/&gt; --&gt;
    &lt;select id="#{cc.clientId}:themeswitcherForm:themeswitcher_content"&gt;
      &lt;ui:repeat value="#{cc.contracts}" var="t"&gt;
        &lt;option value="#{t}" data-imagesrc="#{request.contextPath}#{request.servletPath}/javax.faces.resource/#{t}.png?con=#{t}" data-description="Description: #{t} theme"&gt;#{t}&lt;/option&gt;
      &lt;/ui:repeat&gt;
      &lt;option selected="true" style="display:none;" data-description="Current theme: #{cc.attrs.theme}"&gt;Select theme ...&lt;/option&gt;
    &lt;/select&gt;
    &lt;h:inputHidden id="selectedTheme" value="#{cc.attrs.theme}"/&gt;
  &lt;/h:form&gt;
&lt;/div&gt;</pre></div><p>The contracts are automatically detected and added as <code class="literal">&lt;option&gt;</code> using the <code class="literal">&lt;ui:repeat&gt;</code> component. The selected theme (<code class="literal">&lt;option&gt;</code>) is submitted to a managed bean using a hidden field, <code class="literal">&lt;h:inputHidden&gt;</code>. After submission (via AJAX or non-AJAX), the entire page is loaded<a id="id1415" class="indexterm"/> and the <code class="literal">contracts</code> attribute (of <code class="literal">&lt;f:view&gt;</code>) will receive and apply the selected theme. For this, we need a little JavaScript code. First, we call the<a id="id1416" class="indexterm"/> <code class="literal">ddslick</code> method, which will do the magic of transforming the<a id="id1417" class="indexterm"/> boring drop-down menu into a cool one. Further, we indicate a JavaScript callback method, which will be automatically called when a theme is selected. In this method, we refresh the value of the hidden field, and submit the form (via AJAX or non-AJAX):</p><div class="informalexample"><pre class="programlisting">&lt;cc:implementation&gt;
...
&lt;script type="text/javascript"&gt;
  $(document).ready(function() {

    var themeForm = ("#{cc.clientId}:themeswitcherForm").replace(/:/g, "\\:");
    var themeSelectElem = ("#{cc.clientId}:themeswitcherForm:themeswitcher_content").replace(/:/g, "\\:");
    var themeHiddenElem = ("#{cc.clientId}:themeswitcherForm:selectedTheme").replace(/:/g, "\\:");

    $('#' + themeSelectElem).ddslick({
      onSelected: function(data) {
        if (data.selectedData.text !== "Select theme ...") {
          setTheme(data);
        }
      }
    });

  // callback function
    functionsetTheme(data) {
      $('#' + themeHiddenElem).val(data.selectedData.text);
      //jsf.ajax.request(this, null, {execute: '#{cc.clientId}:themeswitcherForm:selectedTheme', render: "@all"});
      $('#' + themeForm).submit(); // without AJAX
    }
  });

&lt;/script&gt;
&lt;/cc:implementation&gt;</pre></div><p>It was very handy to work with this callback method to submit the selected theme, since ddSlick provides this<a id="id1418" class="indexterm"/> feature out of the box. There are many other possibilities such as writing a value change listener, firing a custom event, and so on.</p><p>I'm sure that you notice that our composite components indicate the presence of a backing component. This<a id="id1419" class="indexterm"/> component is responsible to detect the application's contracts and add their names into <code class="literal">List</code>. This list is transformed in <code class="literal">&lt;option&gt;</code> by <code class="literal">&lt;ui:repeat&gt;</code>. Its code is pretty straightforward, which is as follows:</p><div class="informalexample"><pre class="programlisting">@FacesComponent(value = "book.beans.ThemeSwitcherComponent", createTag = false)
public class ThemeSwitcherComponent extends UIComponentBase implements NamingContainer {

    private List&lt;String&gt; contracts = new ArrayList&lt;&gt;();

    public List&lt;String&gt;getContracts() {
      return contracts;
    }

    publicThemeSwitcherComponent() throws IOException {
      FacesContextfacesContext = FacesContext.getCurrentInstance();
      ExternalContextexternalContext = facesContext.getExternalContext();
      Path path = Paths.get(((ServletContext) externalContext.getContext()).getRealPath("/contracts"));
      try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path)) {
        for (Path file : ds) {
          if (Files.readAttributes(file, BasicFileAttributes.class).isDirectory()) {
              contracts.add(file.getFileName().toString());
            }
          }
        } catch (IOException e) {
          throw e;
        }
      }

    @Override
    public String getFamily() {
      returnUINamingContainer.COMPONENT_FAMILY;
    }
  }</pre></div><p>A developer who wants to use this <code class="literal">ThemeSwitcher</code> component<a id="id1420" class="indexterm"/> must add, in each contract, a PNG image<a id="id1421" class="indexterm"/> with the same name as the contract (recommended size is 40 x 40 pixels). By convention, for each contract, the <code class="literal">ThemeSwitcher</code> component will look for such an image to display it next to the theme name and description. You can improve this backing component to ensure that such images exist. Moreover, you can extend its functionality in order to allow the user of the component to provide custom descriptions.</p><p>Done! The complete application is named <code class="literal">ch11_10</code>.</p><p>The <code class="literal">ThemeSwitcher</code> composite component was packaged as a JAR file and used as an example in the <code class="literal">ch11_7</code> application as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html ...
  &gt;
  ...
  &lt;h:body&gt;
    &lt;f:view contracts="#{themeSwitcherBean.theme}"&gt;
    &lt;t:themeswitcher theme="#{themeSwitcherBean.theme}"/&gt;
  ...</pre></div><p>The <code class="literal">ThemeSwitcherBean</code> source code is very simple, as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@RequestScoped
public class ThemeSwitcherBean {

  private String theme = "tableBlue";

  public String getTheme() {
    return theme;
  }

  public void setTheme(String theme) {
    this.theme = theme;
  }
}</pre></div><p>The output<a id="id1422" class="indexterm"/> of the <code class="literal">ch11_7</code> application is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_11_10.jpg" alt="Writing a theme switcher"/></div><p>If you decide to programmatically alter the <code class="literal">contracts</code> attribute value of <code class="literal">&lt;f:view&gt;</code>, you don't need this bean anymore. Moreover, if you consider a disadvantage in loading this jQuery plugin, you can write pure JavaScript code. Or, if you want a JavaScript code, a custom renderer can be a good choice.</p><p>A <code class="literal">ThemeSwitcher</code> component<a id="id1423" class="indexterm"/> example, based on pure JavaScript, is developed in the application named <code class="literal">ch11_11</code> and is exemplified as a JAR file in the application named <code class="literal">ch11_12</code>. The example modifies the free JavaScript UI library named <code class="literal">iconselect.js</code> (<a class="ulink" href="http://bug7a.github.io/iconselect.js/">http://bug7a.github.io/iconselect.js/</a>) and uses the complete rewritten iScroll 4 library (<a class="ulink" href="http://cubiq.org/iscroll-4">http://cubiq.org/iscroll-4</a>). Both of these libraries are pure JavaScript; they don't use additional libraries such as jQuery. Moreover, they are very small, free to be copied, modified, distributed, adapted, and commercially used.</p><p>The composite<a id="id1424" class="indexterm"/> component that wraps these libraries can be used as shown in the following code. Notice that you can customize the aspect (which is a grid) and you can optionally specify which contracts to be ignored (not listed in theme switcher).</p><div class="informalexample"><pre class="programlisting">&lt;t:themeswitcher theme="#{themeSwitcherBean.theme}" ignore="default" columns="1" rows="1"/&gt;</pre></div><p>The output is as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_11_11.jpg" alt="Writing a theme switcher"/></div><p>If you don't want any JavaScript code, you can write a custom <code class="literal">Renderer</code> code or extend the existing <code class="literal">MenuRenderer</code> code (Mojarra or MyFaces implementation) or write a composite component that uses the JSF UI components to create a nice theme switcher. Writing a custom <code class="literal">Renderer</code> code (or extending the <code class="literal">MenuRenderer</code> code) doesn't seem to be an easy job, and I don't know if it deserves the effort. But writing a composite component based on JSF UI components is pretty simple. You can see such an implementation in the application named <code class="literal">ch11_13</code> and exemplified as a JAR file in the application named <code class="literal">ch11_14</code>. In this example, the themes are listed in a <code class="literal">&lt;h:dataTable&gt;</code> component, as you can see in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_11_12.jpg" alt="Writing a theme switcher"/></div></div>
<div class="section" title="Configuring contracts in XML"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec95"/>Configuring contracts in XML</h1></div></div></div><p>Contracts can be associated with the JSF pages, as you saw in the previous sections. As an alternative, we can <a id="id1425" class="indexterm"/>accomplish the same thing by configuring <a id="id1426" class="indexterm"/>contracts in the <code class="literal">faces-config.xml</code> file. For example, let's suppose that we have three contracts: <code class="literal">default</code>, <code class="literal">tableGreen</code>, and <code class="literal">tableBlue</code>. Their association with different pages is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">default</code> contract is associated with the <code class="literal">tables/defaultTablePage.xhtml</code> page</li><li class="listitem" style="list-style-type: disc">The <code class="literal">tableGreen</code> contract is associated with the <code class="literal">greenTablePage.xhtml</code> page</li><li class="listitem" style="list-style-type: disc">The <code class="literal">tableBlue</code> contract is associated with the <code class="literal">blueTablePage.xhtml</code> page</li></ul></div><p>In <code class="literal">faces-config.xml</code>, we can do these associations using a few tags—the following example code speaks for itself:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
  &lt;resource-library-contracts&gt;
    &lt;contract-mapping&gt;
      &lt;url-pattern&gt;/blueTablePage.xhtml&lt;/url-pattern&gt;
      &lt;contracts&gt;tableBlue&lt;/contracts&gt;
    &lt;/contract-mapping&gt;
    &lt;contract-mapping&gt;
      &lt;url-pattern&gt;/greenTablePage.xhtml&lt;/url-pattern&gt;
      &lt;contracts&gt;tableGreen&lt;/contracts&gt;
    &lt;/contract-mapping&gt;
    &lt;contract-mapping&gt;
      &lt;url-pattern&gt;/tables/*&lt;/url-pattern&gt;
      &lt;contracts&gt;default&lt;/contracts&gt;
    &lt;/contract-mapping&gt;
  &lt;/resource-library-contracts&gt;
&lt;/application&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note185"/>Note</h3><p>As a note, take a quick look at the third association. Notice how you can associate a contract with all the XHTML pages from a folder using the <code class="literal">*</code> wildcard. Do not try to use EL in <code class="literal">&lt;contracts&gt;</code>. It will not work!</p></div></div><p>The complete<a id="id1427" class="indexterm"/> application<a id="id1428" class="indexterm"/> is named <code class="literal">ch11_8</code>.</p></div>
<div class="section" title="Packaging contracts in JARs"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec96"/>Packaging contracts in JARs</h1></div></div></div><p>In order to distribute<a id="id1429" class="indexterm"/> contracts, you can place them into a JAR file. This is a <a id="id1430" class="indexterm"/>very simple job that can be accomplished in just three steps, which are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Consider an empty JAR file.</li><li class="listitem">Create, in JAR, a folder named <code class="literal">META-INF</code>.</li><li class="listitem">Copy the <code class="literal">contracts</code> folder from your application into <code class="literal">META-INF</code>.</li></ol></div><p>For example, a JAR file that contains the <code class="literal">default</code>, <code class="literal">tableGreen</code>, and <code class="literal">tableBlue</code> contract folders has the structure shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_11_13.jpg" alt="Packaging contracts in JARs"/></div><p>A complete example<a id="id1431" class="indexterm"/> that uses<a id="id1432" class="indexterm"/> this JAR file is named <code class="literal">ch11_9</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec97"/>Summary</h1></div></div></div><p>I hope that you have enjoyed this penultimate chapter.</p><p>The JSF 2.2 Resource Library Contracts is one of the big ticket features. For a long time, JSF developers requested for a mechanism that allows writing and using themes in JSF, just like in other systems. As you just saw, JSF 2.2 contracts open a door in this direction and encourage developers to write and use themes. Of course, there are many other things that should be added, such as a theme repository, administration console for themes, switch between themes on the fly, and so on. But, this is a good start!</p><p>See you in the final chapter where we will discuss about Facelets.</p></div></body></html>