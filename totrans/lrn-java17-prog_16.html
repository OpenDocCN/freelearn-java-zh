<html><head></head><body>
		<div id="_idContainer161">
			<h1 id="_idParaDest-282"><em class="italic"><a id="_idTextAnchor281"/>Chapter 13</em>: Functional Programming</h1>
			<p>This chapter brings you into the world of functional programming. It explains what a functional interface is, provides an overview of the functional interfaces that come with JDK, and defines and demonstrates Lambda expressions and how to use them with functional interfaces, including using <strong class="bold">method reference</strong>.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>What is functional programming?</li>
				<li>Standard functional interfaces</li>
				<li>Functional pipelines</li>
				<li>Lambda expression limitations</li>
				<li>Method reference</li>
			</ul>
			<p>By the end of the chapter, you will be able to write functions and use them for Lambda expressions in order to pass them as method parameters.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor282"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or any code editor you prefer</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>. The files with the code examples for this chapter are available on GitHub at <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch13_functional</strong> folder.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor283"/>What is functional programming?</h1>
			<p>Before we provide the definition, let us revisit the code with elements of functional programming that <a id="_idIndexMarker1466"/>we have used already in the preceding chapters. All these examples give you a pretty good idea of how a function can be constructed and passed around as a parameter.</p>
			<p>In <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>, we talked about the <strong class="source-inline">Iterable</strong> interface and its <strong class="source-inline">default void forEach (Consumer&lt;T&gt; function)</strong> method, and provided the following example:</p>
			<pre class="source-code">Iterable&lt;String&gt; list = List.of("s1", "s2", "s3");</pre>
			<pre class="source-code">System.out.println(list);                //prints: [s1, s2, s3]</pre>
			<pre class="source-code">list.forEach(e -&gt; System.out.print(e + " "));//prints: s1 s2 s3</pre>
			<p>You can see how a <strong class="source-inline">Consumer e -&gt; System.out.print(e + " ")</strong> function is passed into the <strong class="source-inline">forEach()</strong> method and applied to each element flowing into this method from the list. We will discuss the <strong class="source-inline">Consumer</strong> function shortly.</p>
			<p>We also mentioned two methods of the <strong class="source-inline">Collection</strong> interface that accept a function as a parameter too:</p>
			<ul>
				<li>The <strong class="source-inline">default boolean remove(Predicate&lt;E&gt; filter)</strong> method attempts to remove all the elements that satisfy the given predicate from the collection; a <strong class="source-inline">Predicate</strong> function accepts an element of the collection and returns a Boolean value.</li>
				<li>The <strong class="source-inline">default T[] toArray(IntFunction&lt;T[]&gt; generator)</strong> method returns an array of all the elements of the collection, using the provided <strong class="source-inline">IntFunction</strong> generator function to allocate the returned array.</li>
			</ul>
			<p>In the same chapter, we also mentioned the following method of the <strong class="source-inline">List</strong> interface:</p>
			<ul>
				<li><strong class="source-inline">default void replaceAll(UnaryOperator&lt;E&gt; operator)</strong>: This replaces each element of the list with the result of applying the provided <strong class="source-inline">UnaryOperator</strong> to that element; <strong class="source-inline">UnaryOperator</strong> is one of the functions we are going to review in this chapter.</li>
			</ul>
			<p>We described the <strong class="source-inline">Map</strong> interface, its <strong class="source-inline">default V merge(K key, V value, BiFunction&lt;V,V,V&gt; remappingFunction)</strong> method, and how it can be used for concatenating the <strong class="source-inline">String</strong> values: <strong class="source-inline">map.merge(key, value, String::concat)</strong>. <strong class="source-inline">BiFunction&lt;V,V,V&gt;</strong> takes two parameters of the same type and returns the value of the <a id="_idIndexMarker1467"/>same type as well. The <strong class="source-inline">String::concat</strong> construct <a id="_idIndexMarker1468"/>is called a <strong class="bold">method reference</strong> and will be explained in the <em class="italic">Method references</em> section.</p>
			<p>We provided the following example of passing a <strong class="source-inline">Comparator</strong> function:</p>
			<pre class="source-code">  list.sort(Comparator.naturalOrder());</pre>
			<pre class="source-code">  Comparator&lt;String&gt; cmp = </pre>
			<pre class="source-code">               (s1, s2) -&gt; s1 == null ? -1 : s1.compareTo(s2);</pre>
			<pre class="source-code">  list.sort(cmp);</pre>
			<p>It takes two <strong class="source-inline">String</strong> parameters, then compares the first one to <strong class="source-inline">null</strong>. If the first parameter is <strong class="source-inline">null</strong>, the function returns <strong class="source-inline">-1</strong>; otherwise, it compares the first parameter and the second one using the <strong class="source-inline">compareTo()</strong> method.</p>
			<p>In <a href="B18388_11_ePub.xhtml#_idTextAnchor247"><em class="italic">Chapter 11</em></a>, <em class="italic">Network Programming</em>, we looked at the following code:</p>
			<pre class="source-code">  HttpClient httpClient = HttpClient.newBuilder().build();</pre>
			<pre class="source-code">  HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">   .uri(URI.create("http://localhost:3333/something")).build();</pre>
			<pre class="source-code">  try {</pre>
			<pre class="source-code">     HttpResponse&lt;String&gt; resp = </pre>
			<pre class="source-code">                 httpClient.send(req, BodyHandlers.ofString());</pre>
			<pre class="source-code">     System.out.println("Response: " + </pre>
			<pre class="source-code">                      resp.statusCode() + " : " + resp.body());</pre>
			<pre class="source-code">  } catch (Exception ex) {</pre>
			<pre class="source-code">     ex.printStackTrace();</pre>
			<pre class="source-code">  }</pre>
			<p>The <strong class="source-inline">BodyHandler</strong> object (a function) is generated by the <strong class="source-inline">BodyHandlers.ofString()</strong> factory method and passed into the <strong class="source-inline">send()</strong> method as a <a id="_idIndexMarker1469"/>parameter. Inside the method, the code calls its <strong class="source-inline">apply()</strong> method:</p>
			<pre class="source-code">BodySubscriber&lt;T&gt; apply(ResponseInfo responseInfo)</pre>
			<p>Finally, in <a href="B18388_12_ePub.xhtml#_idTextAnchor266"><em class="italic">Chapter 12</em></a>, <em class="italic">Java GUI Programming</em>, we used an <strong class="source-inline">EventHandler</strong> function as a parameter in the following code snippet:</p>
			<pre class="source-code">  btn.setOnAction(e -&gt; { </pre>
			<pre class="source-code">                     System.out.println("Bye! See you later!");</pre>
			<pre class="source-code">                     Platform.exit();</pre>
			<pre class="source-code">                 });</pre>
			<pre class="source-code">  primaryStage.onCloseRequestProperty()</pre>
			<pre class="source-code">     .setValue(e -&gt; System.out.println("Bye! See you later!"));</pre>
			<p>The first function is <strong class="source-inline">EventHandler&lt;ActionEvent&gt;</strong>. This prints a message and forces the application to exit. The second is the <strong class="source-inline">EventHandler&lt;WindowEvent&gt;</strong> function. This just prints the message.</p>
			<p>This ability to pass a function as a parameter constitutes functional programming. It is present in many programming languages and does not require the managing of object states. The function is stateless. Its result depends only on the input data, no matter how many times it is called. Such coding makes the outcome more predictable, which is the most attractive aspect of functional programming.</p>
			<p>The area that benefits the most from such a design is parallel data processing. Functional programming allows for shifting the responsibility for parallelism from the client code to the library. Before that, in order to process elements of Java collections, the client code had to iterate over the collection and organize the processing. In Java 8, new (default) methods <a id="_idIndexMarker1470"/>were added that accept a function as a parameter and then apply it to each element of the collection, in parallel or not, depending on the internal processing algorithm. So, it is the library’s responsibility to organize parallel processing.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor284"/>What is a functional interface?</h2>
			<p>When we define a function, we provide an implementation of an interface that has only one abstract method. That is <a id="_idIndexMarker1471"/>how the Java compiler knows where to <a id="_idIndexMarker1472"/>put the provided functionality. The compiler looks at the interface (<strong class="source-inline">Consumer</strong>, <strong class="source-inline">Predicate</strong>, <strong class="source-inline">Comparator</strong>, <strong class="source-inline">IntFunction</strong>, <strong class="source-inline">UnaryOperator</strong>, <strong class="source-inline">BiFunction</strong>, <strong class="source-inline">BodyHandler</strong>, and <strong class="source-inline">EventHandler</strong> in the preceding examples), sees only one abstract method there, and uses the passed-in functionality as the method implementation. The only requirement is that the passed-in parameters must match the method signature. Otherwise, the compile-time error is generated.</p>
			<p>That is why any interface that has only one abstract method is called a <strong class="bold">functional interface</strong>. Please note that the requirement of having <strong class="bold">only one abstract method</strong> includes the method inherited from the parent interface. For example, consider the following interfaces:</p>
			<pre class="source-code">@FunctionalInterface</pre>
			<pre class="source-code">interface A {</pre>
			<pre class="source-code">    void method1();</pre>
			<pre class="source-code">    default void method2(){}</pre>
			<pre class="source-code">    static void method3(){}</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">@FunctionalInterface</pre>
			<pre class="source-code">interface B extends A {</pre>
			<pre class="source-code">    default void method4(){}</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">@FunctionalInterface</pre>
			<pre class="source-code">interface C extends B {</pre>
			<pre class="source-code">    void method1();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">//@FunctionalInterface </pre>
			<pre class="source-code">interface D extends C {</pre>
			<pre class="source-code">    void method5();</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">A</strong> interface is a functional interface because it has only one abstract method, <strong class="source-inline">method1()</strong>. The <strong class="source-inline">B</strong> interface is a functional interface too because it has only one abstract method—the same one inherited from the <strong class="source-inline">A</strong> interface. The <strong class="source-inline">C</strong> interface is a functional <a id="_idIndexMarker1473"/>interface because it has only one abstract method, <strong class="source-inline">method1()</strong>, which <a id="_idIndexMarker1474"/>overrides the abstract method of the parent interface, <strong class="source-inline">A</strong>. The <strong class="source-inline">D</strong> interface cannot be a functional interface because it has two abstract methods—<strong class="source-inline">method1()</strong> from the parent interface, <strong class="source-inline">A</strong>, and <strong class="source-inline">method5()</strong>.</p>
			<p>To help avoid runtime errors, the <strong class="source-inline">@FunctionalInterface</strong> annotation was introduced in Java 8. It tells the compiler about the intent so the compiler can check and see whether there is truly only one abstract method in the annotated interface. This annotation also warns a programmer, who reads the code, that this interface has only one abstract method intentionally. Otherwise, a programmer may waste time adding another abstract method to the interface only to discover at runtime that it cannot be done.</p>
			<p>For the same reason, the <strong class="source-inline">Runnable</strong> and <strong class="source-inline">Callable</strong> interfaces, which have existed in Java since its early versions, were annotated in Java 8 as <strong class="source-inline">@FunctionalInterface</strong>. This distinction is made explicit and serves as a reminder to users that these interfaces can be used to create a function:</p>
			<pre class="source-code">@FunctionalInterface</pre>
			<pre class="source-code">interface Runnable {</pre>
			<pre class="source-code">    void run(); </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">@FunctionalInterface</pre>
			<pre class="source-code">interface Callable&lt;V&gt; {</pre>
			<pre class="source-code">    V call() throws Exception;</pre>
			<pre class="source-code">}</pre>
			<p>As with any other <a id="_idIndexMarker1475"/>interface, the functional interface can be implemented <a id="_idIndexMarker1476"/>using the <strong class="source-inline">anonymous</strong> class:</p>
			<pre class="source-code">Runnable runnable = new Runnable() {</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public void run() {</pre>
			<pre class="source-code">        System.out.println("Hello!");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">};</pre>
			<p>An object created this way can later be used as follows:</p>
			<pre class="source-code">runnable.run();   //prints: Hello!</pre>
			<p>If we look closely at the preceding code, we notice that there is unnecessary overhead. First, there is no need to repeat the interface name, because we declared it already as the type for the object reference. And, second, in the case of a functional interface that has only one abstract method, there is no need to specify the method name that has to be implemented. The compiler and Java runtime can figure it out. All we need is to provide the new functionality. The Lambda expressions were introduced especially for this purpose.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor285"/>What is a Lambda expression?</h2>
			<p>The term <strong class="bold">Lambda</strong> comes from <em class="italic">lambda calculus</em>—a universal model of computation that can be <a id="_idIndexMarker1477"/>used to simulate any Turing machine. It was introduced by mathematician <a id="_idIndexMarker1478"/>Alonzo Church in the 1930s. A <strong class="bold">Lambda expression</strong> is a function, implemented in Java as an anonymous method. It also allows for the <a id="_idIndexMarker1479"/>omitting of modifiers, return types, and parameter types. That makes for a very compact notation.</p>
			<p>The syntax of the Lambda expression includes the list of parameters, an arrow token (<strong class="source-inline">-&gt;</strong>), and a body. The list of parameters can be empty, such as <strong class="source-inline">()</strong>, without parentheses (if there is only one parameter), or a comma-separated list of parameters surrounded by parentheses. The body can be a single expression or a statement block inside braces (<strong class="source-inline">{}</strong>). Let’s look at a few examples:</p>
			<ul>
				<li><strong class="source-inline">() -&gt; 42;</strong> always returns <strong class="source-inline">42</strong>.</li>
				<li><strong class="source-inline">x -&gt; x*42 + 42;</strong> multiplies the <strong class="source-inline">x</strong> value by <strong class="source-inline">42</strong>, then adds <strong class="source-inline">42</strong> to the result and returns it.</li>
				<li><strong class="source-inline">(x, y) -&gt; x * y;</strong> multiplies the passed-in parameters and returns the result.</li>
				<li><strong class="source-inline">s -&gt; "abc".equals(s);</strong> compares the value of the <strong class="source-inline">s</strong> variable and literal <strong class="source-inline">"abc"</strong>; it returns a Boolean result value.</li>
				<li><strong class="source-inline">s -&gt; System.out.println("x=" + s);</strong> prints the <strong class="source-inline">s</strong> value with the prefix <strong class="source-inline">"x="</strong>.</li>
				<li><strong class="source-inline">(i, s) -&gt; { i++; System.out.println(s + "=" + i); };</strong> increments the input integer and prints the new value with the prefix <strong class="source-inline">s + "="</strong>, with <strong class="source-inline">s</strong> being the value of the second parameter.</li>
			</ul>
			<p>Without functional programming, the only way to pass some functionality as a parameter in Java would be by writing a class that implements an interface, creating its object, and then passing it as a parameter. But even the least-involved style using an <strong class="source-inline">anonymous</strong> class requires writing too much boilerplate code. Using functional interfaces and Lambda expressions makes the code shorter, clearer, and more expressive.</p>
			<p>For example, Lambda expressions allow us to reimplement our preceding example with the <strong class="source-inline">Runnable</strong> interface, as follows:</p>
			<pre class="source-code">Runnable runnable = () -&gt; System.out.println("Hello!");</pre>
			<p>As you can see, creating <a id="_idIndexMarker1480"/>a functional interface is easy, especially <a id="_idIndexMarker1481"/>with Lambda expressions. But before doing that, consider using one of the 43 functional interfaces provided in the <strong class="source-inline">java.util.function</strong> package. This will not only allow you to write less code but will also help other programmers who are familiar with the standard interfaces to understand your code better.</p>
			<h3>The local variable syntax for Lambda parameters</h3>
			<p>Until the release <a id="_idIndexMarker1482"/>of Java 11, there were two ways to declare parameter types—explicitly and implicitly. Here is an explicit version:</p>
			<pre class="source-code">  BiFunction&lt;Double, Integer, Double&gt; f = </pre>
			<pre class="source-code">                           (Double x, Integer y) -&gt; x / y;</pre>
			<pre class="source-code">  System.out.println(f.apply(3., 2)); //prints: 1.5</pre>
			<p>The following is an implicit parameter type definition:</p>
			<pre class="source-code">  BiFunction&lt;Double, Integer, Double&gt; f = (x, y) -&gt; x / y;</pre>
			<pre class="source-code">  System.out.println(f.apply(3., 2));   //prints: 1.5</pre>
			<p>In the preceding code, the compiler infers the type of the parameters from the interface definition.</p>
			<p>In Java 11, another method of parameter type declaration was introduced using the <strong class="source-inline">var</strong> type holder, which is similar to the <strong class="source-inline">var</strong> local variable type holder introduced in Java 10 (see <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>).</p>
			<p>The following parameter declaration is syntactically exactly the same as the implicit one before Java 11:</p>
			<pre class="source-code">  BiFunction&lt;Double, Integer, Double&gt; f = </pre>
			<pre class="source-code">                                       (var x, var y) -&gt; x / y;</pre>
			<pre class="source-code">  System.out.println(f.apply(3., 2));    //prints: 1.5</pre>
			<p>The new local variable-style syntax allows us to add annotations without defining the parameter type explicitly. Let’s add the following dependency to the <strong class="source-inline">pom.xml</strong> file:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">    &lt;groupId&gt;org.jetbrains&lt;/groupId&gt;</pre>
			<pre class="source-code">    &lt;artifactId&gt;annotations&lt;/artifactId&gt;</pre>
			<pre class="source-code">    &lt;version&gt;22.0.0&lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>It allows us to <a id="_idIndexMarker1483"/>define passed-in variables as non-null:</p>
			<pre class="source-code">import javax.validation.constraints.NotNull;</pre>
			<pre class="source-code">import java.util.function.BiFunction;</pre>
			<pre class="source-code">import java.util.function.Consumer;</pre>
			<pre class="source-code">BiFunction&lt;Double, Integer, Double&gt; f =</pre>
			<pre class="source-code">                     (@NotNull var x, @NotNull var y) -&gt; x / y;</pre>
			<pre class="source-code">System.out.println(f.apply(3., 2));    //prints: 1.5</pre>
			<p>An annotation communicates to the compiler the programmer’s intent, so it can warn the programmer during compilation or execution if the declared intent is violated. For example, we have tried to run the following code:</p>
			<pre class="source-code">BiFunction&lt;Double, Integer, Double&gt; f = (x, y) -&gt; x / y;</pre>
			<pre class="source-code">System.out.println(f.apply(null, 2));</pre>
			<p>It failed with <strong class="source-inline">NullPointerException</strong> at runtime. Then, we have added the annotation as follows:</p>
			<pre class="source-code">BiFunction&lt;Double, Integer, Double&gt; f =</pre>
			<pre class="source-code">        (@NotNull var x, @NotNull var y) -&gt; x / y;</pre>
			<pre class="source-code">System.out.println(f.apply(null, 2));</pre>
			<p>The result of running the preceding code looks like this:</p>
			<pre class="source-code">Exception in thread "main" java.lang.IllegalArgumentException: </pre>
			<pre class="source-code">Argument for @NotNull parameter 'x' of </pre>
			<pre class="source-code">com/packt/learnjava/ch13_functional/LambdaExpressions</pre>
			<pre class="source-code">.lambda$localVariableSyntax$1 must not be null</pre>
			<pre class="source-code">at com.packt.learnjava.ch13_functional.LambdaExpressions</pre>
			<pre class="source-code">.$$$reportNull$$$0(LambdaExpressions.java)</pre>
			<pre class="source-code">at com.packt.learnjava.ch13_functional.LambdaExpressions</pre>
			<pre class="source-code">.lambda$localVariableSyntax$1(LambdaExpressions.java)</pre>
			<pre class="source-code">at com.packt.learnjava.ch13_functional.LambdaExpressions</pre>
			<pre class="source-code">.localVariableSyntax(LambdaExpressions.java:59)</pre>
			<pre class="source-code">at com.packt.learnjava.ch13_functional.LambdaExpressions</pre>
			<pre class="source-code">.main(LambdaExpressions.java:12)</pre>
			<p>The Lambda expression was not even executed.</p>
			<p>The advantage of the local variable syntax in the case of Lambda parameters becomes clear if we need to use <a id="_idIndexMarker1484"/>annotations when the parameters are the objects of a class with a really long name. Before Java 11, the code might have looked like the following:</p>
			<pre class="source-code">BiFunction&lt;SomeReallyLongClassName,</pre>
			<pre class="source-code">AnotherReallyLongClassName, Double&gt; f =</pre>
			<pre class="source-code">      (@NotNull SomeReallyLongClassName x,</pre>
			<pre class="source-code">    @NotNull AnotherReallyLongClassName y) -&gt; x.doSomething(y);</pre>
			<p>We had to declare the type of the variable explicitly because we wanted to add annotations, and the following implicit version would not even compile:</p>
			<pre class="source-code">BiFunction&lt;SomeReallyLongClassName,</pre>
			<pre class="source-code">AnotherReallyLongClassName, Double&gt; f =</pre>
			<pre class="source-code">           (@NotNull x, @NotNull y) -&gt; x.doSomething(y);</pre>
			<p>With Java 11, the new <a id="_idIndexMarker1485"/>syntax allows us to use the implicit parameter type inference using the <strong class="source-inline">var</strong> type holder:</p>
			<pre class="source-code">BiFunction&lt;SomeReallyLongClassName,</pre>
			<pre class="source-code">AnotherReallyLongClassName, Double&gt; f =</pre>
			<pre class="source-code">          (@NotNull var x, @NotNull var y) -&gt; x.doSomething(y);</pre>
			<p>That is the advantage of and the motivation behind introducing the local variable syntax for the Lambda parameter’s declaration. Otherwise, consider staying away from using <strong class="source-inline">var</strong>. If the type of the variable is short, using its actual type makes the code easier to understand.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor286"/>Standard functional interfaces</h1>
			<p>Most of the interfaces provided in the <strong class="source-inline">java.util.function</strong> package are specializations <a id="_idIndexMarker1486"/>of the following four interfaces: <strong class="source-inline">Consumer&lt;T&gt;</strong>, <strong class="source-inline">Predicate&lt;T&gt;</strong>, <strong class="source-inline">Supplier&lt;T&gt;</strong>, and <strong class="source-inline">Function&lt;T,R&gt;</strong>. Let’s review them and then look at a short overview of the other 39 standard functional interfaces.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor287"/>Consumer&lt;T&gt;</h2>
			<p>By looking at the <strong class="source-inline">Consumer&lt;T&gt;</strong> interface definition, <strong class="source-inline">&lt;indexentry content="standard functional interfaces:Consumer"&gt;</strong>, you can already guess that <a id="_idIndexMarker1487"/>this interface has an <a id="_idIndexMarker1488"/>abstract method that accepts a parameter of type <strong class="source-inline">T</strong> and does not return anything. Well, when only one type is listed, it may define the type of the return value, as in the case of the <strong class="source-inline">Supplier&lt;T&gt;</strong> interface. But the interface name serves as a clue: the <strong class="source-inline">consumer</strong> name indicates that the method of this interface just takes the value and returns nothing, while <strong class="source-inline">supplier</strong> returns the value. This clue is not precise but helps to jog the memory.</p>
			<p>The best source of information about any functional interface is the <strong class="source-inline">java.util.function</strong> package API documentation (<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html">https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html</a>). If we <a id="_idIndexMarker1489"/>read it, we learn that the <strong class="source-inline">Consumer&lt;T&gt;</strong> interface has one abstract and one default method:</p>
			<ul>
				<li><strong class="source-inline">void accept(T t)</strong>: Applies the operation to the given argument</li>
				<li><strong class="source-inline">default Consumer&lt;T&gt; andThen(Consumer&lt;T&gt; after)</strong>: Returns a composed <strong class="source-inline">Consumer</strong> function that performs, in sequence, the current operation followed by the <strong class="source-inline">after</strong> operation</li>
			</ul>
			<p>It means that, for <a id="_idIndexMarker1490"/>example, we can <a id="_idIndexMarker1491"/>implement and then execute it as follows:</p>
			<pre class="source-code">  Consumer&lt;String&gt; printResult = </pre>
			<pre class="source-code">                       s -&gt; System.out.println("Result: " + s);</pre>
			<pre class="source-code">  printResult.accept("10.0");   //prints: Result: 10.0</pre>
			<p>We can also have a factory method that creates the function, for example:</p>
			<pre class="source-code">Consumer&lt;String&gt; printWithPrefixAndPostfix(String pref, String postf){</pre>
			<pre class="source-code">    return s -&gt; System.out.println(pref + s + postf);</pre>
			<pre class="source-code">}</pre>
			<p>Now, we can use it as follows:</p>
			<pre class="source-code">printWithPrefixAndPostfix("Result: ", </pre>
			<pre class="source-code">                          " Great!").accept("10.0");            </pre>
			<pre class="source-code">                                  //prints: Result: 10.0 Great!</pre>
			<p>To demonstrate the <strong class="source-inline">andThen()</strong> method, let’s create the <strong class="source-inline">Person</strong> class:</p>
			<pre class="source-code">public class Person {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String firstName, lastName, record;</pre>
			<pre class="source-code">    public Person(int age, String firstName, String lastName) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.lastName = lastName;</pre>
			<pre class="source-code">        this.firstName = firstName;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getAge() { return age; }</pre>
			<pre class="source-code">    public String getFirstName() { return firstName; }</pre>
			<pre class="source-code">    public String getLastName() { return lastName; }</pre>
			<pre class="source-code">    public String getRecord() { return record; }</pre>
			<pre class="source-code">    public void setRecord(String fullId) { </pre>
			<pre class="source-code">                                        this.record = record; }</pre>
			<pre class="source-code">}</pre>
			<p>You may have <a id="_idIndexMarker1492"/>noticed that <strong class="source-inline">record</strong> is the <a id="_idIndexMarker1493"/>only property that has a setting. We will use it to set a personal record in a consumer function:</p>
			<pre class="source-code">String externalData = "external data";</pre>
			<pre class="source-code">Consumer&lt;Person&gt; setRecord =</pre>
			<pre class="source-code">    p -&gt; p.setFullId(p.getFirstName() + " " +</pre>
			<pre class="source-code">    p.getLastName() + ", " + p.getAge() + ", " + externalData);</pre>
			<p>The <strong class="source-inline">setRecord</strong> function takes the values of the <strong class="source-inline">Person</strong> object properties and some data from an external source and sets the resulting value as the <strong class="source-inline">record</strong> property value. Obviously, it could be done in several other ways, but we do it for demo purposes. Let’s also create a function that prints the <strong class="source-inline">record</strong> property:</p>
			<pre class="source-code">Consumer&lt;Person&gt; printRecord = p -&gt; System.out.println(</pre>
			<pre class="source-code">                                                p.getRecord());</pre>
			<p>The composition of these two functions can be created and executed as follows:</p>
			<pre class="source-code">Consumer&lt;Person&gt; setRecordThenPrint = setRecord.</pre>
			<pre class="source-code">                                        andThen(printPersonId);</pre>
			<pre class="source-code">setRecordThenPrint.accept(new Person(42, "Nick", "Samoylov")); </pre>
			<pre class="source-code">                 //prints: Nick Samoylov, age 42, external data</pre>
			<p>This way, it is possible <a id="_idIndexMarker1494"/>to create a whole processing <a id="_idIndexMarker1495"/>pipe of the operations that transform the properties of an object that is passed through the pipe. </p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor288"/>Predicate&lt;T&gt;</h2>
			<p>This functional <a id="_idIndexMarker1496"/>interface, <strong class="source-inline">Predicate&lt;T&gt;</strong>, has one abstract method, five <a id="_idIndexMarker1497"/>defaults, and a static method that allows predicates chaining: </p>
			<ul>
				<li><strong class="source-inline">boolean test(T t)</strong>: Evaluates the provided parameter to see whether it meets the criteria or not</li>
				<li><strong class="source-inline">default Predicate&lt;T&gt; negate()</strong>: Returns the negation of the current predicate</li>
				<li><strong class="source-inline">static &lt;T&gt; Predicate&lt;T&gt; not(Predicate&lt;T&gt; target)</strong>: Returns the negation of the provided predicate</li>
				<li><strong class="source-inline">default Predicate&lt;T&gt; or(Predicate&lt;T&gt; other)</strong>: Constructs a logical <strong class="source-inline">OR</strong> from this predicate and the provided one</li>
				<li><strong class="source-inline">default Predicate&lt;T&gt; and(Predicate&lt;T&gt; other)</strong>: Constructs a logical <strong class="source-inline">AND</strong> from this predicate and the provided one</li>
				<li><strong class="source-inline">static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef)</strong>: Constructs a predicate that evaluates whether or not two arguments are equal according to <strong class="source-inline">Objects.equals(Object, Object)</strong></li>
			</ul>
			<p>The basic use of this interface is pretty straightforward:</p>
			<pre class="source-code">Predicate&lt;Integer&gt; isLessThan10 = i -&gt; i &lt; 10;</pre>
			<pre class="source-code">System.out.println(isLessThan10.test(7));      //prints: true</pre>
			<pre class="source-code">System.out.println(isLessThan10.test(12));     //prints: false</pre>
			<p>We can <a id="_idIndexMarker1498"/>also combine <a id="_idIndexMarker1499"/>it with the previously created <strong class="source-inline">printWithPrefixAndPostfix(String pref, String postf)</strong> function:</p>
			<pre class="source-code">int val = 7;</pre>
			<pre class="source-code">Consumer&lt;String&gt; printIsSmallerThan10 = </pre>
			<pre class="source-code">printWithPrefixAndPostfix("Is " + val + " smaller than 10? ", </pre>
			<pre class="source-code">                                                  "  Great!");</pre>
			<pre class="source-code">printIsSmallerThan10.accept(String.valueOf(isLessThan10.</pre>
			<pre class="source-code">                                                   test(val))); </pre>
			<pre class="source-code">                    //prints: Is 7 smaller than 10? true Great!</pre>
			<p>The other methods (also called <strong class="bold">operations</strong>) can be used for creating operational chains (also called <strong class="bold">pipelines</strong>), and <a id="_idIndexMarker1500"/>can be seen in <a id="_idIndexMarker1501"/>the following examples:</p>
			<pre class="source-code">Predicate&lt;Integer&gt; isEqualOrGreaterThan10 = isLessThan10.</pre>
			<pre class="source-code">                                                      negate();</pre>
			<pre class="source-code">System.out.println(isEqualOrGreaterThan10.test(7));  </pre>
			<pre class="source-code">                                                //prints: false</pre>
			<pre class="source-code">System.out.println(isEqualOrGreaterThan10.test(12)); </pre>
			<pre class="source-code">                                                 //prints: true</pre>
			<pre class="source-code">isEqualOrGreaterThan10 = Predicate.not(isLessThan10);</pre>
			<pre class="source-code">System.out.println(isEqualOrGreaterThan10.test(7));  </pre>
			<pre class="source-code">                                                //prints: false</pre>
			<pre class="source-code">System.out.println(isEqualOrGreaterThan10.test(12)); </pre>
			<pre class="source-code">                                                 //prints: true</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; isGreaterThan10 = i -&gt; i &gt; 10;</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; is_lessThan10_OR_greaterThan10 = </pre>
			<pre class="source-code">                              isLessThan10.or(isGreaterThan10);</pre>
			<pre class="source-code">System.out.println(is_lessThan10_OR_greaterThan10.test(20)); </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(is_lessThan10_OR_greaterThan10.test(10)); </pre>
			<pre class="source-code">                                                       // false</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; isGreaterThan5 = i -&gt; i &gt; 5;</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; is_lessThan10_AND_greaterThan5 = </pre>
			<pre class="source-code">                   isLessThan10.and(isGreaterThan5);</pre>
			<pre class="source-code">System.out.println(is_lessThan10_AND_greaterThan5.test(3));  </pre>
			<pre class="source-code">                                                       // false</pre>
			<pre class="source-code">System.out.println(is_lessThan10_AND_greaterThan5.test(7));  </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">Person nick = new Person(42, "Nick", "Samoylov");</pre>
			<pre class="source-code">Predicate&lt;Person&gt; isItNick = Predicate.isEqual(nick);</pre>
			<pre class="source-code">Person john = new Person(42, "John", "Smith");</pre>
			<pre class="source-code">Person person = new Person(42, "Nick", "Samoylov");</pre>
			<pre class="source-code">System.out.println(isItNick.test(john));        </pre>
			<pre class="source-code">                                                //prints: false</pre>
			<pre class="source-code">System.out.println(isItNick.test(person));            </pre>
			<pre class="source-code">                                                 //prints: true</pre>
			<p>The <strong class="source-inline">predicate</strong> objects <a id="_idIndexMarker1502"/>can be chained into <a id="_idIndexMarker1503"/>more complex logical statements and include all necessary external data, as was demonstrated before.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/>Supplier&lt;T&gt;</h2>
			<p>This functional <a id="_idIndexMarker1504"/>interface, <strong class="source-inline">Supplier&lt;T&gt;</strong>, has only one abstract method, <strong class="source-inline">T get()</strong>, which <a id="_idIndexMarker1505"/>returns a value. The basic usage can be seen as follows:</p>
			<pre class="source-code">Supplier&lt;Integer&gt; supply42 = () -&gt; 42;</pre>
			<pre class="source-code">System.out.println(supply42.get());  //prints: 42</pre>
			<p>It can be chained with the functions discussed in the preceding sections:</p>
			<pre class="source-code">int input = 7;</pre>
			<pre class="source-code">int limit = 10;</pre>
			<pre class="source-code">Supplier&lt;Integer&gt; supply7 = () -&gt; input;</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; isLessThan10 = i -&gt; i &lt; limit;</pre>
			<pre class="source-code">Consumer&lt;String&gt; printResult = printWithPrefixAndPostfix("Is "</pre>
			<pre class="source-code">         + input + " smaller than " + limit + "? ", " Great!");</pre>
			<pre class="source-code">printResult.accept(String.valueOf(isLessThan10.test(</pre>
			<pre class="source-code">                                              supply7.get())));</pre>
			<pre class="source-code">                    //prints: Is 7 smaller than 10? true Great!</pre>
			<p>The <strong class="source-inline">Supplier&lt;T&gt;</strong> function is typically used as an entry point of data going into a processing pipeline.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/>Function&lt;T, R&gt;</h2>
			<p>The notation of this and other functional interfaces that return values includes the listing of the return <a id="_idIndexMarker1506"/>type as the last in the list <a id="_idIndexMarker1507"/>of generics (<strong class="source-inline">R</strong> in this case) and the type of the input data in front of it (an input parameter of type <strong class="source-inline">T</strong> in this case). So, the <strong class="source-inline">Function&lt;T, R&gt;</strong> notation means that the only abstract method of this interface accepts an argument of type <strong class="source-inline">T</strong> and produces a result of type <strong class="source-inline">R</strong>. Let’s look at the online <a id="_idIndexMarker1508"/>documentation (<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html">https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html</a>).</p>
			<p>The <strong class="source-inline">Function&lt;T, R&gt;</strong> interface has <a id="_idIndexMarker1509"/>one abstract method, <strong class="source-inline">R apply(T)</strong>, and two methods for operations chaining:</p>
			<ul>
				<li><strong class="source-inline">default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;R, V&gt; after)</strong>: Returns a composed function that first applies the current function to its input, and then applies the <strong class="source-inline">after</strong> function to the result</li>
				<li><strong class="source-inline">default &lt;V&gt; Function&lt;V,R&gt; compose(Function&lt;V, T&gt; before)</strong>: Returns a composed function that first applies the <strong class="source-inline">before</strong> function to its input, and then applies the current function to the result</li>
			</ul>
			<p>There is also an <strong class="source-inline">identity()</strong> method:</p>
			<ul>
				<li><strong class="source-inline">static &lt;T&gt; Function&lt;T,T&gt; identity()</strong>: Returns a function that always returns its input argument</li>
			</ul>
			<p>Let’s review all these methods and how they can be used. Here is an example of the basic usage of the <strong class="source-inline">Function&lt;T,R&gt;</strong> interface:</p>
			<pre class="source-code">Function&lt;Integer, Double&gt; multiplyByTen = i -&gt; i * 10.0;</pre>
			<pre class="source-code">System.out.println(multiplyByTen.apply(1));    //prints: 10.0</pre>
			<p>We can also chain it with all the functions we have discussed in the preceding sections:</p>
			<pre class="source-code">Supplier&lt;Integer&gt; supply7 = () -&gt; 7;</pre>
			<pre class="source-code">Function&lt;Integer, Double&gt; multiplyByFive = i -&gt; i * 5.0;</pre>
			<pre class="source-code">Consumer&lt;String&gt; printResult = </pre>
			<pre class="source-code">              printWithPrefixAndPostfix("Result: ", " Great!");</pre>
			<pre class="source-code">printResult.accept(multiplyByFive.</pre>
			<pre class="source-code">     apply(supply7.get()).toString()); </pre>
			<pre class="source-code">                                  //prints: Result: 35.0 Great!</pre>
			<p>The <strong class="source-inline">andThen()</strong> method allows constructing a complex function from simpler ones. Notice <a id="_idIndexMarker1510"/>the <strong class="source-inline">divideByTwo.andThen()</strong> line in <a id="_idIndexMarker1511"/>the following code:</p>
			<pre class="source-code">Function&lt;Double, Long&gt; divideByTwo = </pre>
			<pre class="source-code">                       d -&gt; Double.valueOf(d / 2.).longValue();</pre>
			<pre class="source-code">Function&lt;Long, String&gt; incrementAndCreateString = </pre>
			<pre class="source-code">                                    l -&gt; String.valueOf(l + 1);</pre>
			<pre class="source-code">Function&lt;Double, String&gt; divideByTwoIncrementAndCreateString = </pre>
			<pre class="source-code">                 divideByTwo.andThen(incrementAndCreateString);</pre>
			<pre class="source-code">printResult.accept(divideByTwoIncrementAndCreateString.</pre>
			<pre class="source-code">                                                    apply(4.));</pre>
			<pre class="source-code">                                     //prints: Result: 3 Great!</pre>
			<p>It describes the sequence of the operations applied to the input value. Notice how the return type of the <strong class="source-inline">divideByTwo()</strong> function (<strong class="source-inline">Long</strong>) matches the input type of the <strong class="source-inline">incrementAndCreateString()</strong> function.</p>
			<p>The <strong class="source-inline">compose()</strong> method accomplishes the same result, but in reverse order:</p>
			<pre class="source-code">Function&lt;Double, String&gt; divideByTwoIncrementAndCreateString =  </pre>
			<pre class="source-code">                 incrementAndCreateString.compose(divideByTwo);</pre>
			<pre class="source-code">printResult.accept(divideByTwoIncrementAndCreateString.</pre>
			<pre class="source-code">                                                    apply(4.)); </pre>
			<pre class="source-code">                                     //prints: Result: 3 Great!</pre>
			<p>Now, the sequence <a id="_idIndexMarker1512"/>of composition of the <a id="_idIndexMarker1513"/>complex function does not match the sequence of the execution. It may be very convenient in the case where the <strong class="source-inline">divideByTwo()</strong> function is not created yet and you would like to create it in-line. Then, the following construct will not compile:</p>
			<pre class="source-code">Function&lt;Double, String&gt; divideByTwoIncrementAndCreateString =</pre>
			<pre class="source-code">       (<strong class="bold">d -&gt; Double.valueOf(d / 2.).longValue()</strong>)</pre>
			<pre class="source-code">                   .andThen(incrementAndCreateString); </pre>
			<p>The following line will compile just fine:</p>
			<pre class="source-code">Function&lt;Double, String&gt; divideByTwoIncrementAndCreateString =</pre>
			<pre class="source-code">      incrementAndCreateString</pre>
			<pre class="source-code">      .compose(<strong class="bold">d -&gt; Double.valueOf(d / 2.).longValue()</strong>);</pre>
			<p>It allows for more flexibility while constructing a functional pipeline, so you can build it in a fluent style without breaking the continuous line when creating the next operations.</p>
			<p>The <strong class="source-inline">identity()</strong> method is useful when you need to pass in a function that matches the required function signature but does nothing. But, it can substitute only a function that returns the same type as the input type, as shown in this example:</p>
			<pre class="source-code">Function&lt;Double, Double&gt; multiplyByTwo = d -&gt; d * 2.0; </pre>
			<pre class="source-code">System.out.println(multiplyByTwo.apply(2.));  //prints: 4.0</pre>
			<pre class="source-code">multiplyByTwo = Function.identity();</pre>
			<pre class="source-code">System.out.println(multiplyByTwo.apply(2.));  //prints: 2.0</pre>
			<p>To demonstrate its usability, let’s assume we have the following processing pipeline:</p>
			<pre class="source-code">Function&lt;Double, Double&gt; multiplyByTwo = d -&gt; d * 2.0;</pre>
			<pre class="source-code">System.out.println(multiplyByTwo.apply(2.));  //prints: 4.0</pre>
			<pre class="source-code">Function&lt;Double, Long&gt; subtract7 = d -&gt; Math.round(d - 7);</pre>
			<pre class="source-code">System.out.println(subtract7.apply(11.0));   //prints: 4</pre>
			<pre class="source-code">long r = multiplyByTwo.andThen(subtract7).apply(2.);</pre>
			<pre class="source-code">System.out.println(r);                       //prints: -3</pre>
			<p>Then, we decide that, under <a id="_idIndexMarker1514"/>certain circumstances, the <strong class="source-inline">multiplyByTwo()</strong> function should do nothing. We could add to it a conditional <a id="_idIndexMarker1515"/>close that turns it on/off. But, if we want to keep the function intact or if this function is passed to us from third-party code, we can just do the following:</p>
			<pre class="source-code">Function&lt;Double, Double&gt; multiplyByTwo = d -&gt; d * 2.0;</pre>
			<pre class="source-code">System.out.println(multiplyByTwo.apply(2.));  //prints: 4.0</pre>
			<pre class="source-code">Function&lt;Double, Long&gt; subtract7 = d -&gt; Math.round(d - 7);</pre>
			<pre class="source-code">System.out.println(subtract7.apply(11.0));   //prints: 4</pre>
			<pre class="source-code">long r = multiplyByTwo.andThen(subtract7).apply(2.);</pre>
			<pre class="source-code">System.out.println(r);                       //prints: -3 </pre>
			<pre class="source-code">multiplyByTwo = Function.identity();</pre>
			<pre class="source-code">System.out.println(multiplyByTwo.apply(2.)); //prints: 2.0<strong class="bold">;</strong></pre>
			<pre class="source-code">r = multiplyByTwo.andThen(subtract7).apply(2.);</pre>
			<pre class="source-code">System.out.println(r);                      //prints: -5</pre>
			<p>As you can see, the <strong class="source-inline">multiplyByTwo()</strong> function now does nothing, and the final result is different.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor291"/>Other standard functional interfaces</h2>
			<p>The other 39 functional interfaces in the <strong class="source-inline">java.util.function</strong> package are variations of the <a id="_idIndexMarker1516"/>four interfaces we have just reviewed. These variations are created in order to achieve one or any combination of the following:</p>
			<ul>
				<li>Better performance by avoiding autoboxing and unboxing via the explicit usage of <strong class="source-inline">int</strong>, <strong class="source-inline">double</strong>, or <strong class="source-inline">long</strong> primitives</li>
				<li>Allowing two input parameters and/or a shorter notation</li>
			</ul>
			<p>Here are <a id="_idIndexMarker1517"/>just a few examples:</p>
			<ul>
				<li><strong class="source-inline">IntFunction&lt;R&gt;</strong> with the <strong class="source-inline">R apply(int)</strong> method provides a shorter notation (without generics for the input parameter type) and avoids autoboxing by requiring the primitive <strong class="source-inline">int</strong> as a parameter.</li>
				<li><strong class="source-inline">BiFunction&lt;T,U,R&gt;</strong> with the <strong class="source-inline">R apply(T,U)</strong> method allows two input parameters; <strong class="source-inline">BinaryOperator&lt;T&gt;</strong> with the <strong class="source-inline">T apply(T,T)</strong> method allows two input parameters of type <strong class="source-inline">T</strong> and returns a value of the same type, <strong class="source-inline">T</strong>.</li>
				<li><strong class="source-inline">IntBinaryOperator</strong> with the <strong class="source-inline">int applAsInt(int,int)</strong> method accepts two parameters of the <strong class="source-inline">int</strong> type and returns the value of the <strong class="source-inline">int</strong> type, too.</li>
			</ul>
			<p>If you are going to use functional interfaces, we encourage you to study the API of the interfaces of the <strong class="source-inline">java.util.functional</strong> package (<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html">https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html</a>).</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor292"/>Lambda expression limitations</h1>
			<p>There are two aspects <a id="_idIndexMarker1518"/>of a Lambda expression that we would like to point out and clarify:</p>
			<ul>
				<li>If a Lambda expression uses a local variable created outside it, this local variable has to be final or effectively final (not reassigned in the same context).</li>
				<li>The <strong class="source-inline">this</strong> keyword in a Lambda expression refers to the enclosing context, not the Lambda expression itself.</li>
			</ul>
			<p>As in an <strong class="source-inline">anonymous</strong> class, the variable created outside and used inside a Lambda expression becomes <a id="_idIndexMarker1519"/>effectively final and cannot be modified. The following is an example of an error caused by the attempt to change the value of an initialized variable:</p>
			<pre class="source-code">int x = 7;</pre>
			<pre class="source-code">//x = 3; //compilation error</pre>
			<pre class="source-code">Function&lt;Integer, Integer&gt; multiply = i -&gt; i * x;</pre>
			<p>The reason for this restriction is that a function can be passed around and executed in different contexts (different threads, for example), and an attempt to synchronize these contexts would defeat the original idea of the stateless function and the evaluation of the expression, depending only on the input parameters, not on the context variables. That is why all the local variables used in the Lambda expression have to be effectively final, meaning that they can either be <em class="italic">declared</em> final explicitly or <em class="italic">become</em> final by virtue of not changing the value.</p>
			<p>There is one possible workaround for this limitation though. If the local variable is of a reference type (but not a <strong class="source-inline">String</strong> or primitive wrapping type), it is possible to change its state, even if this local variable is used in the Lambda expression:</p>
			<pre class="source-code">List&lt;Integer&gt; list = new ArrayList();</pre>
			<pre class="source-code">list.add(7);</pre>
			<pre class="source-code">int x = list.get(0);</pre>
			<pre class="source-code">System.out.println(x);  // prints: 7</pre>
			<pre class="source-code">list.set(0, 3);</pre>
			<pre class="source-code">x = list.get(0);</pre>
			<pre class="source-code">System.out.println(x);  // prints: 3</pre>
			<pre class="source-code">Function&lt;Integer, Integer&gt; multiply = i -&gt; i * list.get(0);</pre>
			<p>This workaround should be used with care because of the danger of unexpected side effects if this Lambda is executed in a different context.</p>
			<p>The <strong class="source-inline">this</strong> keyword inside an <strong class="source-inline">anonymous</strong> class refers to the instance of the <strong class="source-inline">anonymous</strong> class. By <a id="_idIndexMarker1520"/>contrast, inside the Lambda <a id="_idIndexMarker1521"/>expression, the <strong class="source-inline">this</strong> keyword refers to the instance of the class <a id="_idIndexMarker1522"/>that surrounds the <a id="_idIndexMarker1523"/>expression, also called an <strong class="bold">enclosing instance</strong>, <strong class="bold">enclosing context</strong>, or <strong class="bold">enclosing scope</strong>.</p>
			<p>Let’s create a <strong class="source-inline">ThisDemo</strong> class that illustrates the difference:</p>
			<pre class="source-code">class ThisDemo {</pre>
			<pre class="source-code">    private String field = "ThisDemo.field";</pre>
			<pre class="source-code">    public void useAnonymousClass() {</pre>
			<pre class="source-code">        Consumer&lt;String&gt; consumer = new Consumer&lt;&gt;() {</pre>
			<pre class="source-code">            private String field = "Consumer.field";</pre>
			<pre class="source-code">            public void accept(String s) {</pre>
			<pre class="source-code">                System.out.println(this.field);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        };</pre>
			<pre class="source-code">        consumer.accept(this.field);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void useLambdaExpression() {</pre>
			<pre class="source-code">        Consumer&lt;String&gt; consumer = consumer = s -&gt; {</pre>
			<pre class="source-code">            System.out.println(this.field);</pre>
			<pre class="source-code">        };</pre>
			<pre class="source-code">        consumer.accept(this.field);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If we execute the preceding methods, the output will be as shown in the following code comments:</p>
			<pre class="source-code">ThisDemo d = new ThisDemo();</pre>
			<pre class="source-code">d.useAnonymousClass();      //prints: Consumer.field</pre>
			<pre class="source-code">d.useLambdaExpression();    //prints: ThisDemo.field</pre>
			<p>As you can see, the <strong class="source-inline">this</strong> keyword inside the <strong class="source-inline">anonymous</strong> class refers to the <strong class="source-inline">anonymous</strong> class <a id="_idIndexMarker1524"/>instance, while <strong class="source-inline">this</strong> in a Lambda expression refers to the enclosing class instance. A Lambda expression just does not (and cannot) have a field. A Lambda expression is not a class instance and cannot be referred to by <strong class="source-inline">this</strong>. According to Java’s specifications, such an approach <em class="italic">allows more flexibility for implementations</em> by treating <strong class="source-inline">this</strong> the same as the surrounding context.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor293"/>Method references</h1>
			<p>So far, all our functions were <a id="_idIndexMarker1525"/>short one-liners. Here is another example:</p>
			<pre class="source-code">Supplier&lt;Integer&gt; input = () -&gt; 3;</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; checkValue = d -&gt; d &lt; 5;</pre>
			<pre class="source-code">Function&lt;Integer, Double&gt; calculate = i -&gt; i * 5.0;</pre>
			<pre class="source-code">Consumer&lt;Double&gt; printResult = d -&gt; System.out.println(</pre>
			<pre class="source-code">                                               "Result: " + d);</pre>
			<pre class="source-code">if(checkValue.test(input.get())){</pre>
			<pre class="source-code">    printResult.accept(calculate.apply(input.get()));</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    System.out.println("Input " + input.get() + </pre>
			<pre class="source-code">                                             " is too small.");</pre>
			<pre class="source-code">} </pre>
			<p>If the function consists of two or more lines, we could implement them as follows:</p>
			<pre class="source-code">Supplier&lt;Integer&gt; input = () -&gt; {</pre>
			<pre class="source-code">     // as many line of code here as necessary</pre>
			<pre class="source-code">     return 3;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; checkValue = d -&gt; {</pre>
			<pre class="source-code">    // as many line of code here as necessary</pre>
			<pre class="source-code">    return d &lt; 5;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">Function&lt;Integer, Double&gt; calculate = i -&gt; {</pre>
			<pre class="source-code">    // as many lines of code here as necessary</pre>
			<pre class="source-code">    return i * 5.0;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">Consumer&lt;Double&gt; printResult = d -&gt; {</pre>
			<pre class="source-code">    // as many lines of code here as necessary</pre>
			<pre class="source-code">    System.out.println("Result: " + d);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">if(checkValue.test(input.get())){</pre>
			<pre class="source-code">    printResult.accept(calculate.apply(input.get()));</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    System.out.println("Input " + input.get() + </pre>
			<pre class="source-code">                                             " is too small.");</pre>
			<pre class="source-code">}</pre>
			<p>When the size of a function implementation grows beyond several lines of code, such a code layout may not <a id="_idIndexMarker1526"/>be easy to read. It may obscure the overall code structure. To avoid this issue, it is possible to move the function implementation into a method and then refer to this method in the Lambda expression. For example, let’s add one static and one instance method to the class where the Lambda expression is used:</p>
			<pre class="source-code">private int generateInput(){</pre>
			<pre class="source-code">    // Maybe many lines of code here</pre>
			<pre class="source-code">    return 3;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">private static boolean checkValue(double d){</pre>
			<pre class="source-code">    // Maybe many lines of code here</pre>
			<pre class="source-code">    return d &lt; 5;</pre>
			<pre class="source-code">}</pre>
			<p>Also, to demonstrate <a id="_idIndexMarker1527"/>the variety of possibilities, let’s create another class, with one static method and one instance method:</p>
			<pre class="source-code">class Helper {</pre>
			<pre class="source-code">    public double calculate(int i){</pre>
			<pre class="source-code">        // Maybe many lines of code here</pre>
			<pre class="source-code">        return i* 5; </pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public static void printResult(double d){</pre>
			<pre class="source-code">        // Maybe many lines of code here</pre>
			<pre class="source-code">        System.out.println("Result: " + d);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Now, we can rewrite our last example as follows:</p>
			<pre class="source-code">Supplier&lt;Integer&gt; input = () -&gt; generateInput();</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; checkValue = d -&gt; checkValue(d);</pre>
			<pre class="source-code">Function&lt;Integer, Double&gt; calculate = i -&gt; new Helper().calculate(i);</pre>
			<pre class="source-code">Consumer&lt;Double&gt; printResult = d -&gt; Helper.printResult(d);</pre>
			<pre class="source-code">if(checkValue.test(input.get())){</pre>
			<pre class="source-code">    printResult.accept(calculate.apply(input.get()));</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    System.out.println("Input " + input.get() + </pre>
			<pre class="source-code">                                             " is too small.");</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, even if each function consists of many lines of code, such a structure keeps the code easy to read. Yet, when a one-line Lambda expression consists of a reference to an existing method, it is possible to further simplify the notation by using a method reference without listing the parameters.</p>
			<p>The syntax of the method reference is <strong class="source-inline">Location::methodName</strong>, where <strong class="source-inline">Location</strong> indicates in which object or class the <strong class="source-inline">methodName</strong> method belongs, and the two colons (<strong class="source-inline">::</strong>) serve as a separator between the location <a id="_idIndexMarker1528"/>and the method name. Using method reference notation, the preceding example can be rewritten as follows:</p>
			<pre class="source-code">Supplier&lt;Integer&gt; input = this::generateInput;</pre>
			<pre class="source-code">Predicate&lt;Integer&gt; checkValue = MethodReferenceDemo::checkValue;</pre>
			<pre class="source-code">Function&lt;Integer, Double&gt; calculate = new Helper()::calculate;</pre>
			<pre class="source-code">Consumer&lt;Double&gt; printResult = Helper::printResult;</pre>
			<pre class="source-code">if(checkValue.test(input.get())){</pre>
			<pre class="source-code">    printResult.accept(calculate.apply(input.get()));</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    System.out.println("Input " + input.get() + </pre>
			<pre class="source-code">                                             " is too small.");</pre>
			<pre class="source-code">}</pre>
			<p>You have probably noticed that we have intentionally used different locations, two instance methods, and <a id="_idIndexMarker1529"/>two static methods in order to demonstrate the variety of possibilities. If it feels like too much to remember, the good news is that a modern IDE (IntelliJ IDEA is one example) can do it for you and convert the code you are writing to the most compact form. You just have to accept the IDE’s suggestion.</p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor294"/>Summary</h1>
			<p>This chapter introduced you to functional programming by explaining and demonstrating the concept of functional interfaces and Lambda expressions. The overview of standard functional interfaces that comes with JDK helps you to avoid writing custom code, while the method reference notation allows you to write well-structured code that is easy to understand and maintain.</p>
			<p>Now, you are able to write functions and use them for Lambda expressions in order to pass them as a method parameter.</p>
			<p>In the next chapter, we will talk about data stream processing. We will define what data streams are, and look at how to process their data and how to chain stream operations in a pipeline. Specifically, we will discuss the streams’ initialization and operations (methods), how to connect them in a fluent style, and how to create parallel streams.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor295"/>Quiz</h1>
			<ol>
				<li>What is a functional interface? Select all that apply:<ol><li>A collection of functions</li><li>An interface that has only one method</li><li>Any interface that has only one abstract method</li><li>Any library written in Java</li></ol></li>
				<li>What is a Lambda expression? Select all that apply:<ol><li>A function, implemented as an anonymous method without modifiers, return types, and parameter types</li><li>A functional interface implementation</li><li>Any implementation in a Lambda calculus style</li><li>A notation that includes the list of parameters, an arrow token (-&gt;), and a body that consists of a single statement or a block of statements</li></ol></li>
				<li>How many input parameters does the implementation of the <strong class="source-inline">Consumer&lt;T&gt;</strong> interface have?</li>
				<li>What is the type of the return value in the implementation of the <strong class="source-inline">Consumer&lt;T&gt;</strong> interface?</li>
				<li>How many input parameters does the implementation of the <strong class="source-inline">Predicate&lt;T&gt;</strong> interface have?</li>
				<li>What is the type of the return value in the implementation of the <strong class="source-inline">Predicate&lt;T&gt;</strong> interface?</li>
				<li>How many input parameters does the implementation of the <strong class="source-inline">Supplier&lt;T&gt;</strong> interface have?</li>
				<li>What is the type of the return value in the implementation of the <strong class="source-inline">Supplier&lt;T&gt;</strong> interface?</li>
				<li>How many input parameters does the implementation of the <strong class="source-inline">Function&lt;T,R&gt;</strong> interface have?</li>
				<li>What is the type of the return value in the implementation of the <strong class="source-inline">Function&lt;T,R&gt;</strong> interface?</li>
				<li>In a Lambda expression, what does the <strong class="source-inline">this</strong> keyword refer to?</li>
				<li>What is method reference syntax?</li>
			</ol>
		</div>
	</body></html>