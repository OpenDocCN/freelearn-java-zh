- en: Chapter 8. AngularJS and Java RESTful Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Slow – Anything faster than 50ms is imperceptible to humans and thus
    can be considered ''instant''.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Misko Hevery, co-creator of AngularJS* |'
  prefs: []
  type: TYPE_TB
- en: 'For this chapter, we shall move out of the comfort zone of JSF and explore
    a different mode of web application. Most of you will be familiar with popular
    social media like Google Mail, Facebook, and Twitter and their web-user interfaces.
    These web applications have a special user experience and information architecture
    that gives the illusion of the interaction taking place on one single web page.
    However, behind the scenes, these applications depend on standard technologies:
    HTML5, CSS, and client-side JavaScript. They all use AJAX calls to communicate
    over HTTP to a back-end server. When the server side application sends data to
    the web client, only a partial part of the page is updated. In contemporary use,
    many digital sites take advantage of the RESTful service endpoints on the application
    backend. Some sophisticated enterprise applications may deliver notices to the
    working multiple users using **Server Sent Events** (**SSE**), and the more leading-edge
    ones lean on the newly minted HTML5 WebSocket specification to deliver a full-duplex
    communication between the client and the server. Incidentally, the full Java EE
    7 specification from the Java Community Process supports JAX-RS, SSE, and WebSocket.'
  prefs: []
  type: TYPE_NORMAL
- en: Single-page applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design philosophy behind building an application on a single page such that
    it resembles a desktop application is in marked contrast to the JavaServer Faces'
    original design of navigation links between pages. JSF 1.0 was created in the
    early noughties, long before the rediscovery of the `XMLHttpRequest` JavaScript
    object and Google Maps in 2005, so that historical note should not be a surprise
    ([http://en.wikipedia.org/wiki/JavaServer_Faces](http://en.wikipedia.org/wiki/JavaServer_Faces)).
    It is entirely possible to write JSF as a single-page application, but I would
    not recommend the effort of forcing a square peg into a round hole! JSF lends
    itself to applications that are extremely stateful in nature and design, where
    the customer journey is based on page-to-page navigation. In the previous chapters,
    we have already covered a great deal about stateful web applications with JSF,
    flow scopes, conversations, and view-scoped beans. If you are not thorough with
    those concepts, then I strongly recommend you revise the material again. We shall
    press on now with the alternate design mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list the beneficial characteristics of single-page applications:'
  prefs: []
  type: TYPE_NORMAL
- en: SPAs often feature a website or web application that fits on a single page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They rely on the modern digital JavaScript techniques including AJAX, HTML5,
    and CSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of loading whole pages during navigation, this type of application manipulates
    the **Document Object Model** (**DOM**) in order to provide page updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These applications typically employ an HTML-templating engine to render the
    content locally on the client side. There is a separation of concerns between
    the presentation logic on the client and the business logic on the server side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPAs communicate dynamically with a web server, usually with RESTful services,
    with JSON as a popular payload type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some drawbacks for single-page applications that the content strategists,
    technical lead developers, and, obviously, the stakeholder businessperson should
    be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: It may be hard to apply Search Engine Optimization to an SPA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the back button in the browser may cause lost data entries; SPAs do not
    play well with web browser history.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPA requires a higher degree of application development knowledge to deal with
    reactive programming and concepts. Notably, engineers should be aware of factors
    concerning trade-off round scalability, resilience, event-driven handling, and
    notifications, and be responsive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, allow me to offer you a word of advice. Digital interface developers
    in the industry have JavaScript, HTML5, and CSS skills. In this chapter, you will
    learn to acknowledge that the JavaScript programming capability is equally as
    important as the Java server-side requirement. In other words, working with AngularJS
    and similar client-side frameworks tends to be a full-stack engagement.
  prefs: []
  type: TYPE_NORMAL
- en: The caseworker application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we are going to look at one particular type of single-page
    application for international governments called a caseworker system. The business
    users of the caseworkers will sit on desks, and for the majority of their day,
    process applicants through stages of applying for a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The caseworker application](img/image00418.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the caseworker application, xen national force
  prefs: []
  type: TYPE_NORMAL
- en: The application is called **xen-national-force**, and it is designed to process
    passports through a miniature workflow. It is far from serving the requirements
    of a true business application. For example, there is no user input security implemented
    in order to keep things as simple as possible. It works very well for only one
    caseworker and there is a very obvious design flaw from the user-experience side.
    However, the xen-national-force application demonstrates how to build a system
    having master-detail records with CRUD operations using AngularJS, and it features
    a basic Finite State Machine implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We shall now move on to learning about the popular AngularJS framework.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How would we wire up the text input with the message area in the `div` element
    with jQuery? One plausible approach would be to write event handlers and callback
    functions like the following fragment of a JavaScript module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The designers of AngularJS realized that there was an opportunity for improvement.
    The same example can be re-written using AngularJS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding fragment is entirely in HTML. It includes the AngularJS framework
    from a remote server, **Content Delivery Network** (**CDN**). The body HTML element
    is annotated with a non-standard attribute, `ng-app`, in order to declare that
    this DOM node is part of the overall template. The other attribute, `ng-init`,
    declares a data model before the template is rendered on the client side. AngularJS
    needs to know where to start templating or modifying the DOM dynamically; therefore,
    every page starts with the `ng-app` attribute. Usually, the `ng-app` attribute
    is applied to the HTML `body` element. An AngularJS template would be useless
    without access to a data model, and this is the purpose of the `ng-init` attribute.
    It sets up a scoped variable called `greeting-name` and assigns it the String
    literal value, `Mr. Anderson`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the additional attribute type `ng-model` and the special, double curly
    bracket syntax: `{{customer-name}}`. The attribute is a special extension provided
    by the AngularJS framework that identifies the data model inline, and the curly
    brackets represent a special HTML templating syntax called directive. Here we
    applied the `ng-model` attribute to the input field element. When the page is
    loaded, the input text field is shown with the text `Mr Anderson`. The code also
    allows the user to enter text in the input field and simultaneously updates the
    message area. There is no programming required for this simple case; in fact it
    is declarative. So what is the secret sauce? The following code shows one form
    of two-way binding. Let''s extend it to demonstrate the complete two-way binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We introduced the HTML `button` elements with a new attribute, `ng-click`. The
    value of the attribute is an AngularJS JavaScript expression. Each button updates
    the data model with a new name. Effectively, they reset the name in the input
    field and the message area. How cool is that? There is no jQuery programming in
    there at all. AngularJS has many special custom attributes such as `ng-repeat`,
    `ng-switch`, and `ng-option`, which we will encounter later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering about these bindings and templates being very clever;
    so how does it work on the client side?
  prefs: []
  type: TYPE_NORMAL
- en: How does AngularJS work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS is loaded in a web browser as part of the HTML page content. The strongest
    part of the framework is that it encourages the separation of concerns. The presentation
    view should be mixed deliberately with business logic and the data model. There
    are a couple of reasons for this. When the Angular JS framework is loaded a page
    is triggered, the framework marches up and down the DOM and looks for certain
    non-standard attributes called directives. It parses and processes this markup
    with the compiler. Effectively, AngularJS transforms the statically loaded DOM
    and produces a rendered view. The framework takes these directives and creates
    associations, binding, and extra behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The `ng-app` attribute is linked to a directive that initializes the application.
    The `ng-init` is linked to a directive that allows the programmer to set up a
    data model. It can be used to assign values to the variables. The `ng-model` is
    associated with directive access or stores the value that is associated with an
    HTML Input element. AngularJS allows the developers to write custom directives.
    You may want to write one in the future to get access to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS works on the idea of nested scopes within a template view. A scope
    is an execution context for expressions. Scopes can be organized in an hierarchical
    fashion such that they mimic the DOM model.
  prefs: []
  type: TYPE_NORMAL
- en: '![How does AngularJS work?](img/image00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How AngularJS works in principle
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS relies on the JavaScript modules that define controllers and other
    logic. Modules can be dependent on other modules; however, unlike RequireJS, modules
    that are a part of disparate JavaScript files are not automatically loaded in
    the application. A scope is the glue that binds the presentation and the data
    model. A scope is the place in the AngularJS where watchers and listeners are
    defined. Most of the time, the framework will automatically handle expression
    handling and data binding, and handle the notifications between JavaScript modules
    and DOM element components. After the compilation phase, AngularJS moves on to
    the linking phase and associates expressions to the module controller methods
    and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS framework bootstraps itself. In particular, it searches the DOM for
    an HTML element with the `ng-app` attribute. This is the trigger point for the
    framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `ng-app` element is found, AngularJS creates a dependency injector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then compiles the static DOM into rendering an intermediate view, collecting
    directives as it goes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AngularJS then starts to link and compose the directives with their associated
    scope. This is an algorithmic and hierarchical operation. The framework creates
    an initial scope called the root scope before executing the linking phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, AngularJS invokes an apply call using the root scope, and during this
    stage, the view is rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the view of the caseworker. In the book''s source code, you
    will find the Gradle project called **xen-force-angularjs**. It follows the Maven
    convention for Java EE projects. Our discussion will be split into two sections.
    We will look at the frontend code that consists of HTML5, JavaScript, and some
    CSS. Afterwards, we will delve into the Java server-side backend. Let''s have
    a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How does AngularJS work?](img/image00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Th relationship of directives to business logic in AngularJS
  prefs: []
  type: TYPE_NORMAL
- en: Caseworker overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The caseworker project shows a master-detail application. Our worker starts
    the application and sees a list of case records, which contains the names and
    the passport details for each applicant. This is the master record. Each case
    record may have a zero or more task records attached. Those are the details records
    of the master. Each master record also contains a state property that shows where
    each applicant is in the process. Our user is permitted to access all of the case
    records and move the current state from start to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Caseworker main view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is only one HTML file in the caseworker example, and it serves as the
    template in the `src/main/webapp/index.xhtml` file. Remember, this is meant to
    be a single-page application!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The HTML tag element is attributed with an AngularJS directive, `ng-app`, which
    specifies the name of the scoped value that serves as the application. We have
    the usual `head` and `body` elements. We include the CSS files Bootstrap (`bootstrap.css`)
    and the application's style file, `main.css`. There is not much difference until
    we arrive at the `Body` tag, which is declared with the `ng-controller` attribute.
    The `ng-controller` directive attaches a controller to the view. The controller
    is the JavaScript object that is part of the MVC pattern. So the entire `body`
    tag element in the DOM is bound to the JavaScript object called `CaseRecordController`.
    We will see the code for it later, but first, let's dive just a little bit deeper.
  prefs: []
  type: TYPE_NORMAL
- en: As you examine the code further, you will notice another controller directive
    on the `div` element with the CSS selector named `action-bar`. This element is
    associated with a different controller called `NewCaseRecordModalController`.
    Every time an `ng-controller` directive is attributed, AngularJS creates a brand
    new scope. So scopes can be nested with one another. This is the key concept in
    the AngularJS framework. The scope exists on the element that is associated with
    and enclosing other nested scopes, should they exist.
  prefs: []
  type: TYPE_NORMAL
- en: The main view renders a table of the case records. The preceding code renders
    the first and last names of the applicant, their sex, their date of birth, their
    ISO country code, their passport number, and their passport's expiration date.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the next part of the content that renders the master table
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are several parts to this code content. The `ng-repeat-start` is a special
    directive that allows the content to be iterated using an expression. The expression
    is a form selection query that AngularJS evaluates dynamically. So, the `<"caseRecord
    in caseRecords">` expression means an overall iteration of the objects in the
    scope named `caseRecords`, and assigning each element as an object called `caseRecord`.
    We use the AngularJS binding directive expressions to render the information for
    each case record in the appropriate table cell element. We do this for the cell
    `{{caseRecord.lastName}}`, then rinse and repeat.
  prefs: []
  type: TYPE_NORMAL
- en: The first data cell is special, because it renders an embedded `div` element.
    It illustrates how to associate a Boolean value and provides an expanding and
    collapsing association to the case record. We must create a scope on the `div`
    and associate the appropriate controller `NewCaseRecordModalController` with the
    `ng-controller` attribute. We take advantage of the `ng-click` directive to invoke
    a method on the controller called `showOrHideTasks()`. Notice that we pass the
    parent of the scope, which contains the current `CaseRecord` as the table is being
    rendered. There is another directive, `ng-class`, that associates the icon element
    with the appropriate glyph icon from Bootstrap by setting the CSS selector. This
    code opens and closes a secondary row in the table view, which renders a task
    view. It also updates the glyph icon correctly based on whether the task view
    is open or closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of this table view content now follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The secondary row in the master table has an `ng-repeat-end` directive, which
    informs AngularJS which DOM element finishes the loop iteration for each `CaseRecord`
    element. There is actually another directive called `ng-repeat` that combines
    `ng-repeat-start` and `ng-repeat-end` for a single DOM element. That directive
    is usually for rendering the simple rows in a table.
  prefs: []
  type: TYPE_NORMAL
- en: The `ng-if` directive conditionally adds or removes content from the DOM. We
    use this `ng-if` to show and hide the task view area for each case record element.
    AngularJS provides other similar directives called `ng-show` and `ng-hide`, but
    those do not dynamically add or remove content from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why would we choose `ng-if` over `ng-show`? Suppose you have hundreds of case
    record elements in your database, would we want to render all of those cases and
    their task history on the web frontend?
  prefs: []
  type: TYPE_NORMAL
- en: We have a `div-layer` element dedicated for showing the tasks associated with
    a case record. Look at the CSS selector, `case-record-task-view`. We add content
    to display each `task` element as a table. There is an example for using the `ng-repeat`
    that has an expression task, in `caseRecord.tasks`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other inner `div` layers. The first element is bound to the logic
    to edit the current case record and references the controller called `NewCaseRecordModalController`.
    The second element allows the user to create a new task, and it references a new
    controller called `NewTaskModalController`. We will see the JavaScript code for
    these controllers later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the expansion and contraction for show
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Caseworker main view](img/image00421.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot depicts the expansion and contraction of the secondary row element
    with `ng-if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the content for the table view, we write table data rows to show
    the properties of the `task` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fourth part of the view, we take full advantage of the AngularJS two-way
    binding to render an HTML `checkbox` element and associate it with the Boolean
    property, `caseRecord.completed`. Using the CSS selector, we dynamically change
    the text of the task name with the class selector expression, `class="done-{{task.completed}}"`.
    When the user changes the checkbox, the following CSS is chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the task is completed, the text is struck through! We added an `ng-change`
    directive to the checkbox element, which AngularJS associates with a change event.
    AngularJS invokes the method, `updateProjectTaskCompleted()` on the controller
    `NewTaskModalController`. This method invokes a `WebSocket` call. We will explain
    the code behind it soon! Notice that the method call passes the current `task`
    element, because we are still in the rendering scope.
  prefs: []
  type: TYPE_NORMAL
- en: In order to complete the task view, we have a `div` layer associated with the
    controller `NewTaskModalController` with glyph icon buttons to edit and remove
    a task. As you can see, we need to pass in `$parent.task` in order to reference
    the element loop variable.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to look at the project organization and then the individual JavaScript
    modules, controllers, and factories.
  prefs: []
  type: TYPE_NORMAL
- en: Project organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project is organized into a Java EE web application. We put all our JavaScript
    code into the folders that follow the convention for AngularJS, because it is
    likely that we are professionally working in a full-stack environment and sharing
    the code base with mixed skills. The AngularJS controllers are placed under `app/controllers`,
    while the factories and services are placed under `app/service`, as shown in the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/app/controllers`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/app/controllers/main.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/app/controllers/newcaserecord-modal.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/app/controllers/newtask-modal.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/app/services`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/app/services/iso-countries.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/app/services/shared-services.js`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we put the third-party JavaScript libraries into their designated area:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/javascripts`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/javascripts/angular.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/javascripts/bootstrap.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/javascripts/jquery-2.1.3.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/javascripts/ui-bootstrap-0.12.1.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/javascripts/ui-bootstrap-tpl-0.12.1.js`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that our caseworker application also depends on Bootstrap, jQuery, and
    the extension library, Bootstrap UI for AngularJS. We include all these libraries
    explicitly in the last part of the content for the main view `index.html`, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As I said earlier, we've kept the code base simpler for the purpose of demonstration,
    but we could have used RequireJS to handle the dependency loading.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't explicitly load jQuery before AngularJS, then it will load its
    own smaller version of jQuery called **jq-lite**. So if your application depends
    on the full version of the jQuery library, please ensure it is loaded before AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to put the CSS in their own special area:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/styles`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/styles/bootstrap.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/styles/bootstrap-theme.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/styles/main.css`'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding files are loaded at the top of the main view, inside the usual
    `head` HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: Application main controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first module in our AngularJS application declares the name of the application.
    The following is the declaration in the file: `src/main/webapp/app/controllers/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The framework exports a function object called `angular`, and it has a method
    called `module` that defines a module. The first argument is the name of the module
    and the second argument is an array of the dependent module names. The `module()`
    method returns an AngularJS module object to the caller. From there, we declare
    the initial controller.
  prefs: []
  type: TYPE_NORMAL
- en: The module `ui.bootstrap` contains AngularJS and Bootstrap integrations. The
    module `newcaserecord` is part of the caseworker application and defines a controller,
    which inserts and amends the master records. The module `newtask` defines a controller,
    which inserts, amends, and removes the details records. The `sharedService` defines
    a factory provider that performs utility functions for the application, and, finally,
    `isoCountries` defines another provider that holds a list of the ISO passport
    countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'AngularJS framework has a fluent API for defining modules, controllers, and
    providers; therefore, we could write an almost declarative JavaScript like the
    following code extract shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding coding style is a matter of taste and the disadvantage is that
    all your modules are lumped together. A lot of professional developers prefer
    to assign the actual Angular module objects to global module variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body tag element in the view defines a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following extract shows the controller `CaseRecordController` that binds
    the user interface to a client-side data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The controller method in the AngularJS object accepts the first parameter as
    the name. The second argument is the function object and as conventional wisdom,
    we pass in an anonymous JavaScript function with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The parameters are all object modules that AngularJS injects to the controller.
    AngularJS defines standard modules beginning with the dollar character (`$`).
    The module `$scope` is a special parameter that denotes the current scope. The
    module `$http` represents a core AngularJS service with methods that communicate
    with a remote HTTP server. The module `$log` is another core service for logging
    to the console. The other parameters `UpdateTaskStatusFactory`, `sharedService`,
    and `isoCountries` are factories and services that our application provides. AngularJS,
    like many JavaScript modern digital frameworks, encourages modular programming
    and avoids polluting the global scope as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: So what does this controller do? First, for demonstration purposes, the controller
    initializes a dummy JSON record, `$scope.caseRecord`, just in case the server
    is not available by the time the page view loads. Next, we define a property for
    the list of records, `$scope.caseRecords`. Yes, adding custom properties to the
    AngularJS `$scope` is the way to communicate from the data model to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: We define properties for the controller, `$scope.isoCountries`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define our first function, `getCaseRecords()`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function makes a RESTful GET request to the remote server from the same
    host that serves the page view. The URL would be something like this: `http://localhost:8080/xen-national-force/rest/caseworker/list`.'
  prefs: []
  type: TYPE_NORMAL
- en: We leverage the fluent API to perform an action once the server returns a JSON
    result. The anonymous function overwrites the `$scope.caseRecords` property with
    the latest data.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, as we construct the function object `CaseRecordController`, we
    invoke the method `getCaseRecords()` in order to kick start the application.
  prefs: []
  type: TYPE_NORMAL
- en: In AngularJS, we can pass information from one controller to another using a
    factory service that our application creates or by making an HTTP request to the
    server. It is also possible to listen to the events that AngularJS publishes on
    a broadcast channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code in `CaseRecordController` demonstrates how to update the
    user interface on all messages but one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we register an event handler on the AngularJS scope in order to retrieve
    a notification from our `SharedService` provider. The `$on()` method registers
    a listener on a specific event type. The first parameter is the message type,
    and the second parameter is the callback. Inside the function callback, we make
    an HTTP request to retrieve the entire set of case records from the server side
    if the message, and therefore the custom event, is not `showTasksCaseRecord`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside the handler callback, we read the entire the dataset, which could be
    thousands of case records in a real enterprise application. Therefore, we can
    improve the performance of the REST call-and-response code. We should, however,
    resist the urge to descend down the path of too early optimization. You should
    prefer to just get the user story working.
  prefs: []
  type: TYPE_NORMAL
- en: The other methods in the controller, `connect()` and `send()`, establish a WebSocket
    channel to the server and send a JSON message down to the server respectively.
    We will examine the `UpdateTaskStatusFactory` module, and the final method, `updateProjectTaskCompleted()`,
    in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: If you've never developed, professionally, any JavaScript before, then this
    chapter might appear very daunting initially. However, please persevere as it
    is really only about having enough patience to succeed. In this regard, I have
    prepared a simplistic diagram of the AngularJS scopes as they appear in our caseworker
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application main controller](img/image00422.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: AngularJS scopes in the caseworker application
  prefs: []
  type: TYPE_NORMAL
- en: This preceding diagram charts the journey of the progress and helps us understand
    where we are going. It also establishes the concept of how AngularJS binds scopes
    in an hierarchical fashion resembling the DOM itself. Behind the scenes, AngularJS
    creates internal scopes to handle the repeatable DOM elements that render the
    HTML `table` element, which is the list of the case records. Developers cannot
    access these internal data except by programming with expressions, and we should
    treat them as opaque objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, there is a Google Chrome plugin called Batarang ([https://chrome.google.com/webstore/detail/angularjs-batarang-stable/](https://chrome.google.com/webstore/detail/angularjs-batarang-stable/)),
    which I would have strongly recommended to examine the AngularJS scope inside
    the browser. Sadly, it seems that the tool is no longer maintained. It is still
    worth checking if someone has adopted it.
  prefs: []
  type: TYPE_NORMAL
- en: New case record controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have placed the code to create and edit the case records in a separate file
    called `newcaserecord-modal.js`, which contains the user-defined AngularJS module
    `newcaserecord`. This module has dependencies on other modules, some of them mentioned
    before. The `ui.bootstrap.modal` is a special module from the AngularJS UI Bootstrap
    third-party framework. The module defines the Bootstrap components written by
    the AngularJS team. In particular, it has a helpful modal dialog extension, which
    we use throughout the caseworker application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the shortened code for the `newcaserecord` module and the
    `NewCaseRecordModalController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The controller function object accepts injected parameters such as `$http`,
    `$log`, and `sharedService`. We also inject the `$modal` instance, which allows
    us to open modal dialogs in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Since each controller has its own scope injected into it, we need to provide
    elements of the data model in order to be accessible to the view. So we create
    an empty case record in the scope as `$scope.caseRecord`. We also set up return
    data and the ISO countries list.
  prefs: []
  type: TYPE_NORMAL
- en: The function `$scope.openCreateCaseRecordDialog()` generates a modal dialog,
    so the user is allowed to enter a master case record.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Allowing a user to create arbitrary application passport records would be probably
    forbidden and restricted to any employee except to the administrators and managers.
    Our demonstration application has no concept of roles and permissions at all.
    Developers should be careful to avoid introducing zero-day exploits into their
    digital applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI Bootstrap extension accepts several parameters. The first parameter
    is a reference to the HTML template directive. The second parameter refers to
    another controller called `newCaseRecordModalInstanceController`, which is responsible
    for handling the interaction with the dialog. The third argument is a resolver
    and it permits the library code to find the reference data in the user''s modal
    inside the enclosing scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The next part of the controller, `NewCaseRecordModalController` handles the
    callback after the modal dialog completes successfully, because the user entered
    the data and pressed the confirm button. We register two function objects as parameters
    on the object called `then`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first function is the callback handler that contains the code to make a
    REST POST request to the server with the case record data. The second function
    is reserved for when the dialog is dismissed. You will notice that AngularJS employs
    fluent interfaces. The code should be fairly understandable even if you don't
    happen to know everything about JavaScript and the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s look at the code for the modal dialog instance, namely the object
    `newCaseRecordModalInstanceController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, this variable is not quite an encapsulated module in JavaScript;
    rather, the `newCaseRecordModalInstanceController` function is declared in the
    global scope. I suppose there are always exceptions to the rule. The UI Bootstrap
    code invokes this controller function through the `$modalInstance.open()` call.
    The framework supplies the three arguments, the scope `$scope`, the modal instance
    `$modalInstance`, and the case record `caseRecord` to the function. We assign
    the case record to the supplied scope in order to write-back the data from the
    modal dialog. There, the function object implements two methods, `ok()` and `cancel()`,
    that handle the confirmation and cancellation of the dialog respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We only need to write the HTML directive for the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The case record modal view template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, all the content for the site is inside a single page application.
    HTML directives are also found in the view, `index.html`. How do you write a directive
    into the page content without it appearing in the view? Is the secret sauce something
    to do with CSS?
  prefs: []
  type: TYPE_NORMAL
- en: Although styling is a good idea, it is not the correct answer. The AngularJS
    designers take advantage of the formal definition for the HTML Script tag, which
    is the element that embeds or references the executable script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the HTML directive for inserting a new case record into the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding HTML directive defines a UI Bootstrap modal dialog, because the
    HTML `script` tag is denoted with the type attribute of `text/ng-template`. All
    AngularJS directives require an identifier. This directive contains a header,
    footer, and main as we can see from the CSS. The main `div` layer is an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: Each input field in the form is bound to the data model in the instance of `newCaseRecordModalInstanceController`.
    The case record was assigned to the scope as soon as the UI Bootstrap invoked
    the function object. Hence, the `ng-model` data model, `$scope.caseRecord.firstName`
    is available to the HTML text input element reserved for first names.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS has an elegant additional markup for validating the form input elements.
    You can see the additional required attribute on almost all of the inputs. Unfortunately,
    as this book cannot delve into deeper details of validation checking, I want to
    draw your attention to two subtle validation checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data input exploits the UI Bootstrap date picker component to allow the
    case worker to easily enter dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The format of the date is defined by the attribute, `datepicker-popup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we display a drop-down list of the ISO passport country names in an
    HTML `select` element. The code for this part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `isoCountries` is a service instance, which we will see later. Since that
    module was injected into the `NewCaseRecordModalController` module and the scope
    of the latter happens to enclose the modal instance scope, AngularJS allow us
    to access the service. The `isoCountries` instance contains a list of the passport
    countries in a key and value dictionary. The code allows us to associate the ISO
    code `AUS` with the country name Australia. The `ng-option` attribute accepts
    an expression, which resembles an SQL query. We declaratively inform AngularJS
    how to derive the display name (`item.country`) and the input form value (`item.code`)
    for each HTML `option` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the create case record modal dialog with the
    date picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The case record modal view template](img/image00423.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the create case record modal dialog with date picker in full
    effect
  prefs: []
  type: TYPE_NORMAL
- en: Let's move onto the task record controller that is similar to the case record
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: New task record controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a caseworker uses the system, he or she is able to expand and collapse the
    task record associated with the case record. The user can create, edit, and amend
    tasks, and can also change the state of the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AngularJS module `newtask` is defined thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a configuration change to AngularJS around the HTTP remoting. There
    is a subtle bug with the HTTP DELETE request. The JAX-RS reference implementation,
    Jersey, which is present in the GlassFish and Payara application server, raises
    an HTTP error with a response code 415: `Unsupported Media Type`. This forces
    AngularJS to send the MIME type, as JSON on the DELETE requests solves the issue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the code for the task controller is so similar, only the create part
    of CRUD will be revealed in this book. Refer to the source for the other methods.
    The following is the source code for `NewTaskModalController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this controller, instead of `$scope.caseRecord`, we have an empty, default
    `$scope.task` object. Every `Task` object has a reference to the parent through
    the property, `caseRecordId`.
  prefs: []
  type: TYPE_NORMAL
- en: The function, `openNewTaskDialog()` opens a UI Bootstrap modal dialog that allows
    the user to enter a brand task. The method wires up the modal dialog with the
    AngularJS scope of the current `Task` object. The big difference is the REST URL
    endpoint, which is in the form of `rest/caseworker/item/'+caseRecordId+'/task`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the UI Bootstrap `$modal` object and create a modal dialog instance as
    before, except that we now pass different arguments. The arguments are the HTML
    directive ID, which is `newTaskContent.html`; the controller is called `newTaskModalInstanceController`,and
    the resolver function. AngularJS invokes the resolver function, which is defined
    as an anonymous function, in order to reference the enclosing `Task` object.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback function for the `modalInstance` object, we conveniently reset
    the `Task` object so that the user is not surprised by stale form data when the
    dialog is raised again. We set the broadcast message in `sharedService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to handle the modal instance in the task dialog is almost the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `newTaskModalInstanceController` accepts three arguments: the
    `$scope` that binds the modal instance dialog, `$modalInstance` itself, and the
    `Task` object. The last argument, the `Task` object, is resolved and we set it
    as a property on the scope in order to easily render the view in the template.'
  prefs: []
  type: TYPE_NORMAL
- en: The task modal view template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AngularJS directive `newTaskContent.html` renders the view for the modal
    dialog that lets the user enter a new task. There are only four properties, so
    this view is shorter than the case record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition for this view is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This view also follows the UI Bootstrap CSS style for modal dialogs. We demonstrate
    an HTML `text area` element associated with a data model, which is the `Task`
    object. Each form field has an `ng-model` association. For the target date, we
    reuse the date picker and we illustrate how to use the HTML `checkbox` element.
  prefs: []
  type: TYPE_NORMAL
- en: The code for editing and deleting task records looks roughly the same. However,
    for editing, we don't reset the task record after the user confirms the modal
    dialog, and for deletion, we show only a read-only view of the task record; the
    modal dialog is simply a confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we handle the change of state.
  prefs: []
  type: TYPE_NORMAL
- en: State change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A case record exists in the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: '| State | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Start | Every new applicant in the system begins at this initial state |'
  prefs: []
  type: TYPE_TB
- en: '| End | At the end of the process, the applicant''s case finishes in this end
    state |'
  prefs: []
  type: TYPE_TB
- en: '| Reviewing | The case worker is reviewing the applicant''s record |'
  prefs: []
  type: TYPE_TB
- en: '| Decision | The case has been reviewed and the business is taking a decision
    |'
  prefs: []
  type: TYPE_TB
- en: '| Accepted | The case has been accepted and the applicant is being notified
    |'
  prefs: []
  type: TYPE_TB
- en: '| Rejected | The case has been rejected and the applicant is being rejected
    |'
  prefs: []
  type: TYPE_TB
- en: All these business requirements are captured in Finite State Machine.
  prefs: []
  type: TYPE_NORMAL
- en: Controller code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now the code should be familiar to you. The controller method `changeStateCaseRecordDialog()`
    in `NewTaskModalController` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since we are just editing an existing case record, we copy the properties of
    `CaseRecord` from the enclosing scope into the controller scope. Remember, the
    outside scope is the main module.
  prefs: []
  type: TYPE_NORMAL
- en: Every JSON case record sent by the server (as we will see later) has a property
    called `nextStates`, which is a list of the next possible states that the user
    can move a record to. To take an example, the `Start` state has only one possible
    next state, which is called `Reviewing`.
  prefs: []
  type: TYPE_NORMAL
- en: Each case record object has a `currentState` property. We push the current state
    on to the list of subsequent states stored in the current scope. This array `$scope.nextStates`
    allows the dialog HTML directive to render a drop-down menu in the view.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this function, `changeStateCaseRecordDialog()`, opens a UI
    Bootstrap modal dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The template view code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So let''s inspect the HTML directive for the state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding directive, identified as `changeStateCaseRecordContent.html`,
    is essentially a read-only view of the entire case record. The only modifiable
    part is the HTML `select` element that displays the next possible states for the
    case record. In order to generate the HTML `option` element, there is a different
    form of expression for the attribute `ng-options`, which is declared as `state
    for state in caseRecord.nextStates`. This expression implies that the option name
    and the value are the same for the array String, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The template view code](img/image00424.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Change state for a case record
  prefs: []
  type: TYPE_NORMAL
- en: The modal instance code is essentially the same. The corresponding function
    associated with the dialog is called `moveStateRecordModalInstanceController()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Before we finish off this long example of AngularJS and the client side, we
    shall cover a couple of more functions. These functions are part of the module
    that defines `NewCaseRecordModalController`.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling the task display state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first function `showOrHideTasks()`, toggles the display property `showTasks`
    in the case record. It also invokes an HTTP PUT request with the case record JSON
    data to the server. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The second function `getIconClass()` is a bit of cheat mode. It returns the
    Bootstrap CSS glyph selector depending on the display state. AngularJS does have
    a conditional expression for `ng-class`; however, at the time of writing, the
    author could not get it to work for the array of case record elements. Therefore,
    this function exists in the code base as a work around.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are interested, the correct code for the client-side that should work
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We will jump over to the server-side now.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Java EE application for the caseworker system is built around RESTful services,
    Java WebSocket, JSON-P, and Java Persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section of the book relies on a prior understanding of Java EE development
    from the elementary level. I recommend that you read the sister book *Java EE
    7 Development Handbook*, especially if you find some of these topics difficult
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Entity objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server-side would be nothing without a couple of domain objects. It should
    not be surprising that these are called `CaseRecord` and `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the extracted `CaseRecord` entity object with full annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For these entities, we leverage the popular Hibernate Validator annotations
    to ensure that the information is correctly saved into the database. The detailed
    entity `Task` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The entities map very closely to the JavaScript objects that we have seen on
    the client side. In practice, a business application in a different domain might
    choose an alternative design such as a facade, aggregation, or projection of the
    data model.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these entities have a persistence layer in order to retrieve and
    store information into the database. In the source code, there is a `CaseRecordTaskService`
    that has the responsibility to persist the `CaseRecord` and `Task` records.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The stateless session EJB class `CaseWorkerRESTServerEndpoint` serves as our
    RESTful endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This class is annotated with `@Path` with the initial URI for this endpoint.
    This relative URI `/caseworker/` matches the AngularJS client side. We inject
    the persistent stateful session EJB `CaseRecordTaskService` into this endpoint,
    and we also set up a JSON generator factory that will print the JSON output. We
    use the standard Java EE 7 JSON generator factory throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieval of case records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To handle the retrieval of caseworker records, I shall demonstrate how to handle
    an asynchronous operation with JAX-RS. We need a managed executor from the application
    server and also to ensure that the web application supports the `async` operations
    after deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Java EE 7, it is crucially important to enable the asynchronous support
    in the Web XML deployment descriptor (`src/main/web-app/WEB/web.xml`). This file
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The important XML element is `<async-supported>` and we set its body content
    to true. We also set the URI for receiving the REST queries for the entire application,
    as `/rest`. So taking the class `CaseWorkerRESTServerEndpoint` together, the full
    relative URI, so far, is `/rest/caseworker`. Finally, we declare to the Java EE
    7 application server that our application requires a managed executor with the
    addition of XML elements around `<resource-env-ref>`. This managed executor is
    referred to by the name, `concurrent/LongRunningTasksExecutor` (the JNDI lookup
    name).
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall use it now in the first REST query method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We annotate the method `getCaseRecordList()` with `@GET` to handle the HTTP
    GET request from the full relative URI, `/rest/caseworker/list`. This method works
    asynchronously. It relies on the injected `ManagedExecutorService` instance, which
    is a thread pool executor that Java EE 7 manages. In order to participate in the
    service, we supplied a method argument, the `AsyncResponse` object, that is annotated
    with `@Suspended`.
  prefs: []
  type: TYPE_NORMAL
- en: The body of our `getCaseRecordList()` method submits a worker instance (`java.lang.Runnable`)
    to the managed executor service. The worker retrieves a list of case records from
    the persistence service and turns them into a JSON output. The output is converted
    into a String and we ask the `AsyncResponse` instance, through its `resume()`
    method, to start sending data down the output channel to the client. We annotate
    the method `getCaseRecordList()` with the JAX RS `@Produces` to declare the MIME
    type `application.json` of the output content.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Incidentally, there are two `@Produces` annotations in Java EE 7\. One is a
    part of JAX-RS and the other is a CDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a REST endpoint for the retrieval of a specific case record by
    its ID. Let''s take a look at how we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `retrieveCase()` is annotated with `@GET` for an HTTP GET request.
    It has the relative URI of `/rest/caseworker/item/{id}`. The method searches for
    the case record by ID and creates a JSON representation of it. It sends the output
    to the client synchronously. Just a quick note: we removed the sanity checking
    code in these extracts in order to save space.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a case record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've covered the retrieval side and now we move onto creational REST endpoints.
    In our system, a web client may create a case record using REST calls. The following
    code inserts a new case record into the application. The relative URI for creating
    a new case record is `/rest/caseworker/item`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The method `createCase()` is longer, because it transfers the data inside the
    JSON-P object instance to a `CaseRecord` entity. We annotate the method with `@POST`
    to denote that this endpoint handles HTTP POST requests. This is a long-winded
    boilerplate, which is solved through data-type binding on other non-Java EE 7
    frameworks like GSON ([https://code.google.com/p/google-gson/](https://code.google.com/p/google-gson/))
    or Faster Jackson Processing API for JSON ([http://wiki.fasterxml.com/JacksonInFiveMinutes](http://wiki.fasterxml.com/JacksonInFiveMinutes)),
    but I must demonstrate the standard approach here. We will have to wait until
    the specification body delivers JSON-B (Java JSON Binding API) before we can streamline
    this code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a case record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Updating a case record, is very similar to creating a new record, except that
    we first search for a record by its ID and then update the record field by field
    from the JSON input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `updateCase()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This RESTful endpoint is annotated with `@PUT` in order to handle an HTTP PUT
    request. This time, the relative URI is `/rest/caseworker/item/{id}` that denotes
    that the client must supply a case record ID. Again, we copy the values from the
    JSON object and overwrite the properties in the `CaseRecord` that was retrieved
    from persistence; then we save the record. We generate a JSON representation of
    the record and set that as a response that JAX-RS will send back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The static instance FMT2 is a `java.text.SimpleDateFormat`, which translates
    between the expiration date and date-of-birth String and the `java.util.Date`
    instances. The pattern format is yyyy-MM-dd. The `BasicStateMachine` instance
    is the implementation of the finite state machine. The `FSM_START` is a singleton
    instance of one of the possible states. Refer to the book's source code in order
    to see how it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We shall now examine the create, update, and delete endpoints for the task record
    in quick succession. Retrieval has already been settled because every `CaseRecord`
    instance has a collection of zero or more `Task` entities, which fulfilled the
    master detail arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating and updating a task record are very similar operations. So let''s
    study the create method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We annotate the method `createNewTaskOnCase()` with `@POST`. The relative URI
    is `/rest/caseworker/item/{caseId}/task`. The client submits the parent case record
    and the method uses this ID to retrieve the appropriate `CaseRecord`. It's probably
    a good idea to cross-reference with the AngularJS client side from the new task
    record controller. Inside the `createNewTaskOnCase()`, we removed the sanity checking
    code again in order to concentrate on the substance. The next part of the code
    is mapping JSON to the Java entity. Afterwards, we add the `Task` entity to `CaseRecord`
    and then persist the master record. The method is complete once we write the response.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a task record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The method `updateTaskOnCase()` performs an update of the task. We annotate
    this method with `@PUT` and with two RESTful arguments. The relative URI is `/rest/caseworker/item/{caseId}/task/{taskId}`.
    The code for updating a task record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With our two coordinates `caseRecordId` and `TaskId`, we locate the appropriate
    `Task` entity and then update the properties from the JSON input. Here, we take
    advantage of the Java 8 Lambdas and Stream API for a functional approach. We save
    the entity and render the JSON response from the current `CaseRecord` entity.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a task record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Last, but not the least, we provide the client side frontend a means to removing
    the task records from the case records. The code it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For an HTTP DELETE request, we annotate the method `deleteTaskFromCase()` with
    `@DELETE`. The relative URI for this method is the strictly RESTful service endpoint
    of `/rest/caseworker/item/{caseId}/task/{taskId}`.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, the tricky part is to search for the actual `Task` record. Here,
    Java 8 Lambda and the stream functions make this a very comprehensive and pleasant
    task. With the `Task` entity correctly identified, we remove it from the parent
    `CaseRecord` and then save the master record with persistence. At the end of the
    message, we send a JSON response of `CaseRecord`.
  prefs: []
  type: TYPE_NORMAL
- en: This covers the JAX-RS side of the application; we shall now move on to the
    Java EE WebSocket support.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSocket is an HTML protocol extension that allows a client and server to participate
    in full duplex asynchronous communication across a network. It works by an initial
    handshake between two endpoints across backwards-compatible HTTP before switching
    to the faster TCP/IP streams. The WebSocket specification (RFC 6455) is part of
    the conglomerate of the HTML5 technologies driven by **Web Hypertext Application
    Technology Working Group** (**WHATWG**) ([https://whatwg.org](https://whatwg.org))
    and **Internet Engineering Task Force** (**IETF**) ([https://www.ietf.org](https://www.ietf.org)).
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket support has been available since the Java EE 7 release, and the related
    JSCP specification is JSR 356 ([https://jcp.org/en/jsr/detail?id=356](https://jcp.org/en/jsr/detail?id=356)).
    We can develop JavaEE WebSocket with either annotations or directly against the
    API. It is easier to write with annotations, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS client side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is helpful to review again the AngularJS client side around the new task
    record controller and the application main controller. Let''s examine the method
    `updateProjectTaskCompleted()` in the controller `CaseRecordController`. Whenever
    the user decides the task is complete by selecting or deselecting the HTML `checkbox`
    element, we wire up the frontend to send a WebSocket message via the `send()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The entire local JavaScript task record is sent over as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide the WebSocket communication generally across to other modules
    on the client side, AngularJS recommends that we define a factory or service.
    A factory is usually initialized only once. A service, on the other hand, adds
    functionality and returns different instances depending on the calling context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the missing factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The idiom for defining an AngularJS factory resembles the defining of a controller
    or a module, strongly. With the main module `myApp`, we invoke the library `factory()`
    method with two arguments: the name of the factory and the function callback that
    defines the service. The factory has only one dependency on the default logging
    module, `$log`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `connect()` method initializes an HTML5 WebSocket with the URL by instantiating
    a WebSocket instance. With the handle, we register optional callbacks to deal
    with events: when the WebSocket is opened, closed, receives a message, or there
    is an error. Each callback dumps a message to the web browser''s console log.'
  prefs: []
  type: TYPE_NORMAL
- en: We define a couple of `send()` methods that send the message body content down
    the WebSocket to the peer. In WebSocket parlance, the remote endpoint is known
    as the peer, because there is no distinction between the client and server endpoints.
    Both sides can start a connection to the other and begin communicating; hence
    the term full duplex.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side WebSocket endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, in Java EE 7 we can quickly develop WebSocket endpoints
    using the standard annotations. The Java WebSocket API closely follows the IETF
    specification, and you will recognize the similarities with the many JavaScript
    implementations inside a web browser. There is far too much to the configuration
    and to the different approaches of annotation and programming directly to the
    library that can be reasonably squeezed in this digital Java EE book.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the essential Java class is actually annotated as a stateless
    session EJB as well as a WebSocket. This should not be surprising, because the
    Java EE specification allows this mixture of annotations in certain cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the endpoint in `CaseRecordUpdateTaskWebSocketEndpoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We annotate the bean with `@ServerEndpoint` to denote a server-side endpoint.
    The notion of *server-side* is essentially a Java EE nomenclature to declare an
    intention that this endpoint lives on an application server. There are also such
    things as `@ClientEndpoint` connections.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of callbacks, Java EE uses annotated methods to handle the opening,
    closing, and failure events around the WebSocket with `@OnOpen`, `@OnClose`, and
    `@OnError` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To handle the receiving of a message on WebSocket correctly, a POJO or bean
    must only have one method annotated with `@Message`. Behind the scenes, the library
    framework transforms the message into a String for the simplest case as we have
    here. It is possible to send binary and complex data types down and across the
    wire.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `updateTaskStatus()` method, we leverage the JSON-P API to parse
    the text into the salient properties of a task. From the input text message, we
    require the case record ID, the task ID and the completion properties of the task.
    We retrieve the matching `CaseRecord` entity from persistence and filter the collection
    of the `Task` objects for the correct item. Once we have it, we set the completed
    property and persist the entire record back to persistence.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets are permitted to return a response back to the peer. We send the
    response synchronously, as we do here, with a text message like `OK` or `NOT FOUND`.
    Readers should be aware that it also possible to send responses asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of the server-side discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Consider your design requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS is a powerful JavaScript MVC framework for the client side. Developers,
    designers, and digital managers are always looking at the next exciting technology.
    People often tend to gauge the impact of a new framework. It is fair to say that
    AngularJS is a game changer because of the ease of the developing components that
    are bound to the model. The effort for not implementing such potential error-prone
    code with jQuery, by default, is huge!
  prefs: []
  type: TYPE_NORMAL
- en: We know that AngularJS is suited for single-page applications. Does that mean
    that your next enterprise application must be a SPA? Well, the practicing consultant's
    answer is that it always depends on your goals. SPA is suited to limited customer
    journeys and in cases where the experience happens mostly in one place. The caseworker
    application is of this type, because the person is assessing the passport applicants
    on a case-by-case basis, and therefore, they stay in and work on one web page
    most of the time during their working day.
  prefs: []
  type: TYPE_NORMAL
- en: The caseworker application demonstrates a master-detail relationship. Your next
    enterprise application may probably require the involvement of a more complicated
    set of use stories. Your domain might require an extensive set of entities. A
    single SPA might not cover all the areas. For one thing, you will need many more
    JavaScript modules, controllers and factories, and HTML directives to fully surround
    the bounded context of the system.
  prefs: []
  type: TYPE_NORMAL
- en: So what to do with these complicated requirements? One approach is to bundle
    all of the JavaScript logic on the client script into one download. Tools for
    this such as GruntJS, which we briefly covered in the last chapter, can then merge,
    compress, and optimize files. We can take advantage of the Java EE strengths with
    more than one web page and navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Array collection of single-page applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can structure an SPA into a linear sequence so that the customer journey
    of the system almost follows a workflow. There are domains such as warehouse order
    management, engineering, and financial trading where such an approach might make
    sense. In such domains, the business user works in a series of complex steps in
    order to process bulk units of work from A to B. The advantages of an array of
    SPAs are won if they have a short linear sequence consisting of, perhaps, three
    or four steps, but will be lost if the length of the chain is greater than or
    equal to seven.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical collection of single-page applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other approach is to descend fully from a linear sequence into the hierarchical
    tree structure of SPA. This approach is extremely specialized, and it is advisable
    to seek some architectural assurance that this path is sustainable for your business.
    Why would a business want to organize SPA in this fashion? Your stakeholder may
    want to sustain the organizational function in a way that mirrors the domain exactly.
    The design approach is a risky procedure because it introduces inflexibility in
    the overall model, and in my humble opinion, appears to be authority power led
    by the management rather than being organic. If the hierarchy tree is organized
    in a length by breadth manner rather than length by depth, ask yourself why?
  prefs: []
  type: TYPE_NORMAL
- en: In these times, where engineers and architects are looking at micro-services
    in order to scale and have a single business function in an elegant box, an HSPA
    might indeed be useful. The tree structure size should be around 10 nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this long chapter, we covered client-side AngularJS development with a caseworker
    application. We learned how the AngularJS framework manipulates the DOM and how
    it provides the binding between the data and the rendering of the elements using
    the MVC. We also learned some AngularJS concepts like scopes, modules, controllers,
    and factories.
  prefs: []
  type: TYPE_NORMAL
- en: Using the study example, we illustrated how AngularJS communicates to a remote
    server using RESTful service invocations from the client side. We also studied
    the WebSocket interaction briefly. On the client side of JavaScript, we went through
    the entire CRUD idiom in the caseworker application.
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, we saw the implementation of the RESTful services with JAX-RS,
    which covered the four standard HTTP method requests. We also learnt about the
    Java WebSocket implementation.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS fits the mode of applications that single page applications need.
    However, this may or may not be appropriate to your business requirements. Adopting
    AngularJS requires full stack knowledge of both JavaScript programming and Java
    EE development. Moving to a framework like AngularJS exposes your business to
    the risk of hiring, retaining, and learning more technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another side of the triangle to consider: organizational dynamics.
    Apple Inc., USA famously divided their then agile teams that worked on the online
    shopping store into a pure server and client division. The only communication
    allowed between them was an agreed upon programming interface. This division happened
    when the iPhone was being developed (circa 2005-2007), which obviously predates
    AngularJS. Your team might operate differently, but the concept of design-by-contract
    is still relevant, because it showed what can be achieved, especially in terms
    of RESTful services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I will leave you with a second quote from Misko Hevery, co-creator of AngularJS.
    He said:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Limited – You can''t really show more than 2000 pieces of information to
    a human on a single page. Anything more than that is really bad UI, and humans
    can''t process this anyway."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the source code for the xen-national-force caseworker application and
    study the implementation for a few hours. What do you notice? Compile the code
    and deploy the resultant WAR to your application server of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the material from this chapter, create your CRUD AngularJS application
    with just one simple entity, `EMPLOYEE`. This entity should have an employee ID,
    name, and social security number. Build the client side with AngularJS and the
    server side with JAX-RS. (In the book's source code, there is a blank project
    that will help you get started.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While building the EMPLOYEE CRUD from the previous question in AngularJS and
    JavaEE, did you use the modal dialog from UI Bootstrap? If not, investigate other
    means of rendering the view to insert, update, and delete records. (Hint: One
    possible way is dynamically showing and hiding different `DIV` elements.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is an obvious design flaw with the caseworker application. Did you find
    it? When the caseworker shows and hides a task view, it updates the persistence
    database; explain why is this a problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine that from today, you have become the project lead for the entire xen-national-force
    team, and suddenly, the business decides that they want instant notifications
    to be broadcast to other caseworkers once a state has been changed. Explain at
    a technical level how this user story might be achieved. Think about the challenges
    on the AngularJS client side. How might you build the Java EE server side?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Study the factory module (`iso-countries.js`) in xen-national-force that is
    responsible for the maintaining a collection of the ISO passport country names
    and their codes. How is this module used in the frontend? Where does it get used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of using a dedicated Boolean property in the `CaseRecord` JPA entity
    to denote if the task view is shown or not, write an AngularJS factory module
    that stores this information for all the case records locally on the client side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sample caseworker application retrieves every record in the database and
    returns it to the user. Suppose the real system had 1,000 case records. What could
    be an issue with this functionality? How would you solve it? If the caseworker
    is not able to see all the records, explain how do you ensure that they get to
    see relevant cases? What do you need to implement on both the AngularJS client
    and the Java EE server side?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
