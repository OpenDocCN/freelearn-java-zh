- en: Programming with Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We cannot solve our problems with the same thinking we used when we created
    them."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Albert Einstein'
  prefs: []
  type: TYPE_NORMAL
- en: It's beautiful when we give a new dimension to thinking while solving a problem.
    In programming, our approaches to solving problems may differ from each other.
    Most of the time, there's an interaction between the user and programs. GUI-based
    and web applications are a few examples of these applications. We can think of
    ways in which our application gets notified whenever the user tries to interact
    with it. It may be possible that our program awaits user's interactions or vice
    versa. In the opposite case, the user's interaction, at times, notifies the application
    of some kind of event. Let's say we write our programs to react to a user's interactions.
    This is the essence of being reactive as an application program. We write a program
    that acts as a system to the surrounding environment, and the environment itself
    pushes events to our programs. These events drive the whole system, hence they
    become the core of a reactive programming model. And that's just the beginning
    of being reactive, there are more concepts that emerge from this kind of model.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous chapter, we have got the essence of asynchronous computations.
    Async computations include some kind of computation that will be performed in
    the near future and its callback, which gets executed when the computation gets
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, in this chapter, we''ll continue with our understanding of asynchronous
    computations to understand reactive extensions, which are nothing but an API created
    while keeping the reactive programming model in mind. Here''s what we''ll be discussing:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reacting to RxScala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming, in one line, is the process of programming with asynchronous
    data streams. If that's not the definition you expect, let's try to get an idea
    about it. Let's think of it as a journey. We'll start from zero, with no understanding
    of what being reactive in programming terminologies is. As we proceed, we'll have
    interactions with a few concepts and mechanisms that form the reactive ecosystem.
    The final goal is to be able to think in Reactive. So let's start it.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to understand any new paradigm or concept is to reason about its
    existence. For this let''s think of a very common and simple scenario, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You might have come across the form behavior shown in the preceding figure.
    There''s an agreement to read and then we click on the checkbox to agree to it
    so that we can proceed further. On the left-hand side, the checkbox is unchecked.
    Hence, based on its value, we have set the visibility of the **Continue** button
    (currently for the unchecked box) to false. Once we click and set the checkbox
    value to true, the visibility of the **Continue** button also becomes true. What
    is happening is when we click on checkbox, it emits an event with its value, that
    is, true/false. Now, based on its value, we can set the button''s visibility to
    true/false. This is an example of observing events of a simple checkbox and making
    use of the event''s value. If you picture this, it might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the **Checkbox** state and button''s visibility.
    We need not care about the code syntax because we''re not talking about any language
    or frameworks for now. In this example, we only cared about a single event getting
    triggered by the checkbox. It was simple to understand. Now let''s think of a
    computation that''s reactive. Think of the following computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The computation says **A** is going to have a value, **B** and **C** are going
    to have the same value as A, and, finally, **D** is going to be the result of
    the addition of **B** and **C**. So in normal programs, once you execute the statement,
    you get the values for **A**, **B**, **C**, and **D**. Now, let''s think what
    happens when we consider time and also let the value flow in our system. What
    do we mean by that? Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the left-hand side, we have pictured the scenario which states the same
    as we mentioned previously. On the right-hand side, we have a table that consists
    of values of our variables at some instants of time. So let''s say we update the
    value of **A** to 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this statement should increment the value of **B** and **C** because it''s
    now in the reactive world. So when data is changes, it flows and changes all the
    dependent variables. Hence, **B** and **C** get updated to **6**, and finally
    because of the change in its dependents, the value of D also changes and becomes
    12\. Taking a look at the table, we can see that the values of B, C, and D get
    updated each time they observe a change in the value of **A**. Till now, we have
    not dealt with any particular terminology. But we''ve seen two examples: the first
    one gave the essence of *emitting events* and the second one gave the essence
    of *data flow* in the system containing variables. These are two important concepts
    of *reactive* programming. But wait, we also mentioned *reactive programming*
    is programming with asynchronous data streams. To understand this notion, think
    of the values of the **A** variable as values in a data stream. Now, at a particular
    instant in time, if we try to access the values of **A**, there are three possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: You get a value back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get an error when you try to fetch a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get a message that the stream is completed and contains no more values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Picturing this, we''ll get something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous diagram demonstrates the possible outcomes of a data stream. The
    following are a few important points to take away from the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: All values are events occurring in time. So the order of these values will be
    maintained. After the stream completes, there's no possibility of any value getting
    emitted from the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time plays an important role; that's to preserve event order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be a possibility of an error occurring while accessing the values
    from the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as these events are occurring with respect to time, we can make these
    computations asynchronous in nature and bind a few callbacks to some particular
    event. We can also filter out a few events based on the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These kinds of reactive systems react with respect to time and events. And we
    can also compare these streams to promises, which we discussed in the previous
    chapter. Promises are responsible for one value that's going to be available in
    future. Whereas, streams contain multiple returned values evaluated asynchronously.
    These are the building blocks of *reactive programming.* The paradigm has its
    own terminologies for such streams and these are called **Observables***.* There
    are various APIs available that let you create such *observable streams* and allow
    us to transform, filter, and merge these observable streams to create a reactive
    system in which data flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'These APIs are a part of ReactiveX and called reactive extensions. There are
    asynchronous stream APIs available for a number of languages, some of which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: RxJava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rx.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxScala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxLua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxGo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxDart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these APIs serve the same purpose, that is to provide asynchronous Observable
    streams in their respective platforms. These APIs revolve around the principle
    of events and streams. Let's check out what these reactive extensions provide.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All these APIs serve the same purpose, that is, to provide asynchronous Observable
    streams in their respective platforms. These APIs revolve around the principle
    of events and streams. Let's check out what these reactive extensions provide.
    It's time to see the term we just introduced ourselves to, that is, Observables*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Observables are the entities that emit a stream of events. Events can be a
    button click or checking a checkbox, or some other event like providing input
    to some device via the interface exposed. There has to be an *observer* that reacts
    to whatever value or sequence of values the Observable is emitting. The way *observers*
    react to events is by *subscribing* to the Observable*.* So these *observers*
    subscribing to Observables to react to events is the main theme of ReactiveX.
    The process in any of the libraries available for different platforms is somewhat
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the Observable, which does the job of emitting events. This will be
    in an asynchronous fashion, as events can be dependent on some environment/surrounding,
    for example, user's interaction or some condition being successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define a method, which does some manipulation with the return value from
    an asynchronous computation. This method is part of *observers.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We attach the *observer* to the *Observable* by *subscribing* to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By subscribing the `Observer` to Observable, we specify that now the mechanism
    is in place and our observers are ready to react to events. Based on this phenomena,
    Observables are categorized as hot and cold Observables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hot Observables**: These start emitting events as soon as they are created,
    hence if in a later point in time we attach/subscribe an observer to it, the observer
    continues to react to events from the current point of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cold Observables**: These, on the other hand start emitting events when they''re
    subscribed by an observer. In this way, our observers react to events from the
    beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, we have seen while observing events from a stream that there are possibilities
    of an error or the stream to be completed. So for Observer[T], we provide following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onNext(T)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError(Exception)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each call to the observer's `onNext` method comes with a value from an event.
    In case you create an observer of the `String` type, then the `onNext` method
    will give you a string value. In a typical reactive programming scenario, a call
    to the `onNext` method is made until the event stream gets completed or some error
    occurs; in these cases, `onComplete` or `onError` gets called. After these methods,
    we don't get any values from that subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, the iterables we discussed while taking about collections,
    these iterables work in a somewhat similar fashion, with the only difference being
    that the Observables are asynchronous in nature. Iterables contain data in sequence,
    from which we can obtain a value at a time and perform some operation on them.
    To obtain data from such iterables, we create an iterator. Calling `iterator.next()`
    lets us access the value in an iterable. An iterable lets you access a sequence
    of values in a synchronous fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The difference lies in the nature of these two: Observables are asynchronous
    in nature, while Iterables are not. Taking a look at these two interfaces, we
    can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We know about *Observables,* but what makes them powerful is a set of *utility*
    methods, described as *operators.* These operators allow us to *create, combine,
    transform, filter*, and *convert* Observable*s.* We can chain these operators
    to perform these operations in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're sure about the theoretical stuff, it's time to try out what you
    learned using Scala's offering in the reactive world, that is, *RxScala.* Let's
    look at the RxScala API to represent the Observables.
  prefs: []
  type: TYPE_NORMAL
- en: React to RxScala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxScala is a reactive asynchronous streams API provided in Scala. It lets us
    perform all those concepts we talked about, such as creating *Observables, observers,*
    and *subscribing* to them. There's a variety of operators available for us to
    manipulate these *Observables.* Most of the operators return *Observables,* hence
    chaining of *Observables* is also possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start writing some *Observables,* we''ll start by setting up space so that
    the library becomes available to us. For that, let''s follow some steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On your favorite internet browser, open [https://developer.lightbend.com](https://developer.lightbend.com)
    and click on the START A PROJECT button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll get a few options; just choose Scala and click on CREATE A PROJECT
    FOR ME!. It''ll download the source in a compressed format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can extract that and open it in IntelliJ IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once it''s opened in IntelliJ, we can add the library dependency for RxScala in
    the build file. This can be done by specifying the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After specifying dependency, we can perform the `sbt update` command from the
    command line*,* which will download the dependency files. We should do this update
    from the directory where `build.sbt` is specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we are ready to write Observables. So why wait? Let's write some.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For creating Observables, there are a bunch of operators such as `just`, `empty`,
    `interval`, `from`, and `defer`. Let''s first write some code to create Observables
    in some of the ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we have only created Observables and there''s
    no subscription to them. Hence, even if they emit some values, we have no mechanism
    to react to those values. First let''s check out the code written:'
  prefs: []
  type: TYPE_NORMAL
- en: The first statement creates an empty Observable, which means it has no values
    in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second statement calls an operator named `just`*,* which takes a value and
    wraps that in the Observable context. Hence, when this observable emits, it'll
    emit only the value we specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we provided a sequence of values to our observable with the method named
    `from`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `from` method can also take a future value and create an Observable. This
    Observable emits values that result from async computations specified in Future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then there's the `interval` method, which expects us to provide the interval
    in which we emit values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, there are two more ways we specified. First, we used the operator
    named `defer`*,* which takes the `byname` parameter as another Observable and
    only starts the emission of events once an observer subscribes to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With these operators, we were able to create Observables*.* Now let''s attach
    subscriptions to these Observables by calling the `subscribe` method. For that,
    we can add the following snippet to our Scala file. First, let''s add some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add this snippet following the Observables creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The method takes the value and performs, or let's say reacts, to the value.
    It returns a `Subscription` instance. The advantage of this `Subscription` parameter
    is that we can cancel the subscription by calling a method named `unsubscribe`*.*
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `intervalObservables`*,* we had to provide `Thread.sleep(1000)`
    too so that our `intervalObservables` type gets some time to emit values. If we
    don't use some mechanism to wait for these emissions, the thread will be killed
    and we won't get to see the emitted values.
  prefs: []
  type: TYPE_NORMAL
- en: These are a few ways in which we can create Observables and subscribe to them.
    But that's more of getting used to APIs. We may want to see some examples which
    can demonstrate the use of this reactive pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think of a scenario. Suppose a user has to fill a form with information
    about a football player. He has to provide the player''s name, age, nationality,
    and the league. After filling the information, the user will press **Submit**
    and that form data comes to us for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now it's up to us to provide a data flow for the player's information. By this,
    we mean that with the specific information, we can create a player's instance,
    validate the information, show the information in some particular format, or any
    other thing you can come up with. The flow is going to be the same for every form
    submission. In that case, we can create an Observable to the event, let's call
    it, the form submit event. Subscribed observer for the same will get data from
    each form submission. And then we can define `onNext` to manipulate the form data
    whichever way we want. Regardless of the user's speed of entering information
    and pressing the **Submit** button, we have the system in place with the Observable,
    which gets notified by the event's occurrence. And the process starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to see this in practice, let''s think that the data source is our favorite
    CSV file, instead of someone filling out the form for us, and see how the code
    might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, think of the `playerObservable` type being created from
    some event source. It's type is `String`, in our case it's supposed to contain
    the player information in string format. Now what we are supposed to do with the
    string is to parse this string information to a Player instance. The methods `readPlayerDateFromSource`*,*
    `parseToPlayer`, and `showPlayerInformation` are part of another object named
    `PlayerService`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the magic of operators in our case. The first one is the map itself,
    which takes a player string as expected and makes a call to `parseToPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to infer its result type, it''s nothing but `Observable[Option[Player]]`,
    so nothing has changed; it''s still an Observable. We''ve just made a transformation
    in the Observable world and got a result. After that, we subscribed to the Observables
    and called our desired `showPlayerInformation(player)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This itself is pretty amazing because the system is set up for a particular
    event, in our case the *form submit* event that gives us `Observable[String]`*.*
    Thanks to our hypothetical user, who enters the information and submits it so
    that the system gets a String to operate upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to clear the picture again, we''ll get the help of the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, currently, there's only one source of player
    information attached and the whole pipeline works well. Now think of another scenario
    where our hypothetical user can also select a player from some suggested input.
    What will that look like?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we might get the whole player information as `Option[Player]`
    instead of string. Hence, the observable working in this case will be of the type
    `Observable[Option[Player]]`*.* Now if we want to execute the same logic as we
    did in the case of form submission, all we have to do is use the merge operator.
    This will combine the Observables, hence we''ll be able to achieve what we desire.
    The important thing is to merge our new Observable at the right place. From the
    diagram, we get a hint that it''ll be better if we merge Observable when we have
    `observable[Option[Player]]` as shown in following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the preceding diagram. As you can see on the left-most side,
    the suggestion input form gives us `Observable[Option[Player]]`*,* which we merge
    with our transformed Observable of the same type. We can do the same in our code.
    Let's create an Observable from a custom optional player and then merge that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll just refactor our code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we merged the `observable.just(somePlayer)` type with the Observable
    of the type `Observable[Option[Player]]`*.* This call to merge combines these
    two Observables, and hence the values from these combined sources go through the
    pipeline. We can try this out by running the application. We'll get to see values
    from our CSV file as well as the `somePlayer` Observable we created if the CSV
    file is in the correct place. This way, we can use operators to make our system
    work with several event sources. This is just the tip of the iceberg. There's
    a lot we can achieve with these operators available. I strongly recommend that
    you go through the documentation ([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html))
    from ReactiveX*.* Their marble diagrams explain each of these operators, and you
    can use them according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: With this recommendation, we would want to summarize what we've covered in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to the notion of reactive programming. We understood
    the concept of Observable events and reacting to them. This gave us an essence
    of what reactive programming is. After that, we went through reactive extensions
    and explored the API a bit. We saw how we can create Observables and subscribe
    to them. Finally, we looked at   an example that explained the way we can compose
    Observables using some operators available to us.
  prefs: []
  type: TYPE_NORMAL
- en: In next chapter, we'll cover one of the most important topics, that is, testing
    our programs. We'll go through the much talked about nowadays development model,
    that is, **test-driven development** (**TDD**). We'll start by answering the why
    and what of TDD and then understand the toolkits available in Scala for testing.
  prefs: []
  type: TYPE_NORMAL
