- en: Programming with Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式扩展进行编程
- en: '"We cannot solve our problems with the same thinking we used when we created
    them."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我们不能用创造它们时使用的相同思维方式来解决我们的问题。”
- en: '- Albert Einstein'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 阿尔伯特·爱因斯坦'
- en: It's beautiful when we give a new dimension to thinking while solving a problem.
    In programming, our approaches to solving problems may differ from each other.
    Most of the time, there's an interaction between the user and programs. GUI-based
    and web applications are a few examples of these applications. We can think of
    ways in which our application gets notified whenever the user tries to interact
    with it. It may be possible that our program awaits user's interactions or vice
    versa. In the opposite case, the user's interaction, at times, notifies the application
    of some kind of event. Let's say we write our programs to react to a user's interactions.
    This is the essence of being reactive as an application program. We write a program
    that acts as a system to the surrounding environment, and the environment itself
    pushes events to our programs. These events drive the whole system, hence they
    become the core of a reactive programming model. And that's just the beginning
    of being reactive, there are more concepts that emerge from this kind of model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在解决问题时赋予思考新的维度时，这是美丽的。在编程中，我们解决问题的方法可能各不相同。大多数时候，用户和程序之间存在交互。基于GUI和Web应用程序是这些应用程序的几个例子。我们可以思考我们的应用程序在用户尝试与之交互时如何被通知。可能我们的程序等待用户的交互，反之亦然。在相反的情况下，用户的交互有时会通知应用程序某种事件。让我们假设我们编写程序以对用户的交互做出反应。这就是作为应用程序程序响应式的本质。我们编写一个作为周围环境系统的程序，环境本身将事件推送到我们的程序。这些事件驱动整个系统，因此它们成为响应式编程模型的核心。而这只是响应式开始的起点，还有更多从这种模型中产生的概念。
- en: From the previous chapter, we have got the essence of asynchronous computations.
    Async computations include some kind of computation that will be performed in
    the near future and its callback, which gets executed when the computation gets
    completed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们已经得到了异步计算的核心。异步计算包括某种将在不久的将来执行的计算及其回调，该回调在计算完成时执行。
- en: 'Well, in this chapter, we''ll continue with our understanding of asynchronous
    computations to understand reactive extensions, which are nothing but an API created
    while keeping the reactive programming model in mind. Here''s what we''ll be discussing:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在本章中，我们将继续理解异步计算，以了解响应式扩展，这实际上是在考虑到响应式编程模型时创建的一个API。以下是我们将讨论的内容：
- en: Reactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Reactive extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式扩展
- en: Reacting to RxScala
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对RxScala的反应
- en: Reactive programming, in one line, is the process of programming with asynchronous
    data streams. If that's not the definition you expect, let's try to get an idea
    about it. Let's think of it as a journey. We'll start from zero, with no understanding
    of what being reactive in programming terminologies is. As we proceed, we'll have
    interactions with a few concepts and mechanisms that form the reactive ecosystem.
    The final goal is to be able to think in Reactive. So let's start it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程，一句话概括，就是使用异步数据流进行编程的过程。如果这不是你预期的定义，让我们试着了解一下它。让我们把它想象成一段旅程。我们将从零开始，对编程术语中的响应式一无所知。随着我们的前进，我们将与一些形成响应式生态系统的概念和机制进行互动。最终目标是能够以响应式的方式思考。那么，让我们开始吧。
- en: Reactive programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: 'The best way to understand any new paradigm or concept is to reason about its
    existence. For this let''s think of a very common and simple scenario, as shown
    here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 理解任何新的范式或概念的最佳方式是推理其存在。为此，让我们考虑一个非常常见且简单的场景，如下所示：
- en: '![](img/00065.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: 'You might have come across the form behavior shown in the preceding figure.
    There''s an agreement to read and then we click on the checkbox to agree to it
    so that we can proceed further. On the left-hand side, the checkbox is unchecked.
    Hence, based on its value, we have set the visibility of the **Continue** button
    (currently for the unchecked box) to false. Once we click and set the checkbox
    value to true, the visibility of the **Continue** button also becomes true. What
    is happening is when we click on checkbox, it emits an event with its value, that
    is, true/false. Now, based on its value, we can set the button''s visibility to
    true/false. This is an example of observing events of a simple checkbox and making
    use of the event''s value. If you picture this, it might look as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the **Checkbox** state and button''s visibility.
    We need not care about the code syntax because we''re not talking about any language
    or frameworks for now. In this example, we only cared about a single event getting
    triggered by the checkbox. It was simple to understand. Now let''s think of a
    computation that''s reactive. Think of the following computation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The computation says **A** is going to have a value, **B** and **C** are going
    to have the same value as A, and, finally, **D** is going to be the result of
    the addition of **B** and **C**. So in normal programs, once you execute the statement,
    you get the values for **A**, **B**, **C**, and **D**. Now, let''s think what
    happens when we consider time and also let the value flow in our system. What
    do we mean by that? Take a look at the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'On the left-hand side, we have pictured the scenario which states the same
    as we mentioned previously. On the right-hand side, we have a table that consists
    of values of our variables at some instants of time. So let''s say we update the
    value of **A** to 6:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, this statement should increment the value of **B** and **C** because it''s
    now in the reactive world. So when data is changes, it flows and changes all the
    dependent variables. Hence, **B** and **C** get updated to **6**, and finally
    because of the change in its dependents, the value of D also changes and becomes
    12\. Taking a look at the table, we can see that the values of B, C, and D get
    updated each time they observe a change in the value of **A**. Till now, we have
    not dealt with any particular terminology. But we''ve seen two examples: the first
    one gave the essence of *emitting events* and the second one gave the essence
    of *data flow* in the system containing variables. These are two important concepts
    of *reactive* programming. But wait, we also mentioned *reactive programming*
    is programming with asynchronous data streams. To understand this notion, think
    of the values of the **A** variable as values in a data stream. Now, at a particular
    instant in time, if we try to access the values of **A**, there are three possibilities:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: You get a value back
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会得到一个返回值
- en: You get an error when you try to fetch a value
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你尝试获取值时会出现错误
- en: You get a message that the stream is completed and contains no more values
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会收到一个消息，表明流已完成且不再包含更多值
- en: 'Picturing this, we''ll get something similar to the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们会得到以下类似的内容：
- en: '![](img/00068.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: 'The previous diagram demonstrates the possible outcomes of a data stream. The
    following are a few important points to take away from the preceding diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图展示了数据流的可能结果。以下是从前面的图中可以提取的一些重要点：
- en: All values are events occurring in time. So the order of these values will be
    maintained. After the stream completes, there's no possibility of any value getting
    emitted from the stream.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有值都是时间中发生的事件。因此，这些值的顺序将得到保持。在流完成后，没有可能从流中发出任何值。
- en: Time plays an important role; that's to preserve event order.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间扮演着重要的角色；这是为了保持事件顺序。
- en: There might be a possibility of an error occurring while accessing the values
    from the stream.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从流中访问值时可能会发生错误。
- en: Also, as these events are occurring with respect to time, we can make these
    computations asynchronous in nature and bind a few callbacks to some particular
    event. We can also filter out a few events based on the values.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，由于这些事件是相对于时间发生的，我们可以将这些计算异步化，并将一些回调绑定到某些特定事件上。我们还可以根据值过滤掉一些事件。
- en: These kinds of reactive systems react with respect to time and events. And we
    can also compare these streams to promises, which we discussed in the previous
    chapter. Promises are responsible for one value that's going to be available in
    future. Whereas, streams contain multiple returned values evaluated asynchronously.
    These are the building blocks of *reactive programming.* The paradigm has its
    own terminologies for such streams and these are called **Observables***.* There
    are various APIs available that let you create such *observable streams* and allow
    us to transform, filter, and merge these observable streams to create a reactive
    system in which data flows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这类反应式系统根据时间和事件进行反应。我们还可以将这些流与我们在上一章中讨论的承诺进行比较。承诺负责一个将在未来可用的值。而流包含多个异步评估的返回值。这些都是*反应式编程*的构建块。这个范式为这样的流有自己的术语，这些术语被称为**Observables***.* 有各种API可供创建这样的*可观察流*，并允许我们转换、过滤和合并这些可观察流，以创建一个数据流动的反应式系统。
- en: 'These APIs are a part of ReactiveX and called reactive extensions. There are
    asynchronous stream APIs available for a number of languages, some of which are
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API是ReactiveX的一部分，被称为反应式扩展。对于多种语言，都有可用的异步流API，以下是一些例子：
- en: RxJava
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava
- en: RxJS
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS
- en: Rx.NET
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rx.NET
- en: RxScala
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxScala
- en: RxLua
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxLua
- en: RxGo
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxGo
- en: RxDart
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxDart
- en: All these APIs serve the same purpose, that is to provide asynchronous Observable
    streams in their respective platforms. These APIs revolve around the principle
    of events and streams. Let's check out what these reactive extensions provide.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些API都服务于相同的目的，即在其各自平台上提供异步的Observable流。这些API围绕事件和流的原理展开。让我们来看看这些反应式扩展提供了什么。
- en: Reactive extensions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式扩展
- en: All these APIs serve the same purpose, that is, to provide asynchronous Observable
    streams in their respective platforms. These APIs revolve around the principle
    of events and streams. Let's check out what these reactive extensions provide.
    It's time to see the term we just introduced ourselves to, that is, Observables*.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些API都服务于相同的目的，即在其各自平台上提供异步的Observable流。这些API围绕事件和流的原理展开。让我们来看看这些反应式扩展提供了什么。是时候看看我们刚刚介绍给自己的术语了，那就是Observables*.*
- en: 'Observables are the entities that emit a stream of events. Events can be a
    button click or checking a checkbox, or some other event like providing input
    to some device via the interface exposed. There has to be an *observer* that reacts
    to whatever value or sequence of values the Observable is emitting. The way *observers*
    react to events is by *subscribing* to the Observable*.* So these *observers*
    subscribing to Observables to react to events is the main theme of ReactiveX.
    The process in any of the libraries available for different platforms is somewhat
    similar to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是发出事件流的实体。事件可以是按钮点击或检查复选框，或者通过接口提供的其他事件，例如向设备提供输入。必须有一个**观察者**来对可观察对象发出的任何值或值的序列做出反应。**观察者**通过**订阅**可观察对象来对事件做出反应。因此，这些观察者订阅可观察对象以对事件做出反应是ReactiveX的主要主题。在为不同平台提供的任何库中，这个过程在某种程度上与以下类似：
- en: We define the Observable, which does the job of emitting events. This will be
    in an asynchronous fashion, as events can be dependent on some environment/surrounding,
    for example, user's interaction or some condition being successful.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了Observable，它负责发出事件。这将以异步方式进行，因为事件可能依赖于某些环境/周围环境，例如用户的交互或某些条件成功。
- en: We define a method, which does some manipulation with the return value from
    an asynchronous computation. This method is part of *observers.*
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个方法，它使用异步计算返回的值进行一些操作。这个方法是**观察者**的一部分。
- en: We attach the *observer* to the *Observable* by *subscribing* to it.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过**订阅**将**观察者**附加到**可观察对象**上。
- en: By subscribing the `Observer` to Observable, we specify that now the mechanism
    is in place and our observers are ready to react to events. Based on this phenomena,
    Observables are categorized as hot and cold Observables.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Observer`订阅到Observable，我们指定现在机制已经到位，我们的观察者已经准备好对事件做出反应。基于这种现象，可观察对象被分为热和冷可观察对象。
- en: '**Hot Observables**: These start emitting events as soon as they are created,
    hence if in a later point in time we attach/subscribe an observer to it, the observer
    continues to react to events from the current point of time.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热可观察对象**：这些在创建时立即开始发出事件，因此如果在稍后的某个时间点我们将观察者附加/订阅到它，观察者将继续从当前时间点对事件做出反应。'
- en: '**Cold Observables**: These, on the other hand start emitting events when they''re
    subscribed by an observer. In this way, our observers react to events from the
    beginning.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷可观察对象**：另一方面，这些在观察者订阅它们时开始发出事件。通过这种方式，我们的观察者从事件开始就做出反应。'
- en: 'Also, we have seen while observing events from a stream that there are possibilities
    of an error or the stream to be completed. So for Observer[T], we provide following
    methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们从流中观察事件时，我们已经看到可能存在错误或流完成的可能。因此，对于Observer[T]，我们提供了以下方法：
- en: '`onNext(T)`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext(T)`'
- en: '`onError(Exception)`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError(Exception)`'
- en: '`onComplete()`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete()`'
- en: Each call to the observer's `onNext` method comes with a value from an event.
    In case you create an observer of the `String` type, then the `onNext` method
    will give you a string value. In a typical reactive programming scenario, a call
    to the `onNext` method is made until the event stream gets completed or some error
    occurs; in these cases, `onComplete` or `onError` gets called. After these methods,
    we don't get any values from that subscription.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者`onNext`方法的每次调用都伴随着来自事件的值。如果你创建了一个`String`类型的观察者，那么`onNext`方法将给你一个字符串值。在典型的响应式编程场景中，对`onNext`方法的调用会一直持续到事件流完成或发生某些错误；在这些情况下，会调用`onComplete`或`onError`。在这些方法之后，我们不会从该订阅中获得任何值。
- en: 'If you remember, the iterables we discussed while taking about collections,
    these iterables work in a somewhat similar fashion, with the only difference being
    that the Observables are asynchronous in nature. Iterables contain data in sequence,
    from which we can obtain a value at a time and perform some operation on them.
    To obtain data from such iterables, we create an iterator. Calling `iterator.next()`
    lets us access the value in an iterable. An iterable lets you access a sequence
    of values in a synchronous fashion:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，当我们讨论集合时提到的可迭代对象，这些可迭代对象的工作方式在某种程度上是相似的，唯一的区别在于可观察对象在本质上是异步的。可迭代对象按顺序包含数据，我们可以一次获取一个值并对它们执行一些操作。要从这样的可迭代对象中获取数据，我们创建一个迭代器。调用`iterator.next()`让我们可以访问可迭代对象中的值。可迭代对象允许你以同步方式访问一系列值：
- en: '![](img/00069.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00069.jpeg)'
- en: 'The difference lies in the nature of these two: Observables are asynchronous
    in nature, while Iterables are not. Taking a look at these two interfaces, we
    can see the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种之间的区别在于它们的本质：Observables 是异步的，而 Iterables 则不是。看一下这两个接口，我们可以看到以下内容：
- en: '![](img/00070.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: We know about *Observables,* but what makes them powerful is a set of *utility*
    methods, described as *operators.* These operators allow us to *create, combine,
    transform, filter*, and *convert* Observable*s.* We can chain these operators
    to perform these operations in a specific order.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 *Observables*，但使它们强大的是一系列 *实用* 方法，这些方法被称为 *算子*。这些算子允许我们 *创建、组合、转换、过滤* 和
    *转换* Observable*s。我们可以将这些算子链接起来，以特定的顺序执行这些操作。
- en: Now that we're sure about the theoretical stuff, it's time to try out what you
    learned using Scala's offering in the reactive world, that is, *RxScala.* Let's
    look at the RxScala API to represent the Observables.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了理论上的东西，现在是时候尝试使用 Scala 在反应式世界中的提供，即 *RxScala* 来应用你所学的知识了。让我们看看 RxScala
    API 如何表示 Observables。
- en: React to RxScala
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式地使用 RxScala
- en: RxScala is a reactive asynchronous streams API provided in Scala. It lets us
    perform all those concepts we talked about, such as creating *Observables, observers,*
    and *subscribing* to them. There's a variety of operators available for us to
    manipulate these *Observables.* Most of the operators return *Observables,* hence
    chaining of *Observables* is also possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: RxScala 是 Scala 中提供的一个反应式异步流 API。它让我们执行我们讨论的所有概念，例如创建 *Observables*、观察者以及 *订阅*。我们有各种各样的算子可供我们操作这些
    *Observables*。大多数算子返回 *Observables*，因此 *Observables* 的链式操作也是可能的。
- en: 'To start writing some *Observables,* we''ll start by setting up space so that
    the library becomes available to us. For that, let''s follow some steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写一些 *Observables*，我们首先需要设置空间，以便库对我们可用。为此，让我们遵循以下步骤：
- en: On your favorite internet browser, open [https://developer.lightbend.com](https://developer.lightbend.com)
    and click on the START A PROJECT button.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你最喜欢的互联网浏览器中，打开 [https://developer.lightbend.com](https://developer.lightbend.com)
    并点击 START A PROJECT 按钮。
- en: 'You''ll get a few options; just choose Scala and click on CREATE A PROJECT
    FOR ME!. It''ll download the source in a compressed format:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将得到一些选项；只需选择 Scala 并点击 CREATE A PROJECT FOR ME! 按钮。它将以压缩格式下载源代码：
- en: '![](img/00071.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: We can extract that and open it in IntelliJ IDE.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以提取它并在 IntelliJ IDE 中打开。
- en: 'Once it''s opened in IntelliJ, we can add the library dependency for RxScala in
    the build file. This can be done by specifying the following:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在 IntelliJ 中打开，我们就可以在构建文件中添加 RxScala 的库依赖项。这可以通过指定以下内容来完成：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After specifying dependency, we can perform the `sbt update` command from the
    command line*,* which will download the dependency files. We should do this update
    from the directory where `build.sbt` is specified.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定依赖项后，我们可以从命令行执行 `sbt update` 命令*，*这将下载依赖文件。我们应该从这个指定 `build.sbt` 的目录中进行此更新。
- en: Now, we are ready to write Observables. So why wait? Let's write some.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写 Observables 了。那么，还等什么呢？让我们开始编写一些。
- en: Creating Observables
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Observables
- en: 'For creating Observables, there are a bunch of operators such as `just`, `empty`,
    `interval`, `from`, and `defer`. Let''s first write some code to create Observables
    in some of the ways:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建 Observables，有如 `just`、`empty`、`interval`、`from` 和 `defer` 等一系列算子。让我们首先编写一些代码来以不同的方式创建
    Observables：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code snippet, we have only created Observables and there''s
    no subscription to them. Hence, even if they emit some values, we have no mechanism
    to react to those values. First let''s check out the code written:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们只创建了 Observables，并且没有对它们进行订阅。因此，即使它们发出一些值，我们也没有机制来对这些值做出反应。首先让我们看看所写的代码：
- en: The first statement creates an empty Observable, which means it has no values
    in it.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一条语句创建了一个空的 Observable，这意味着它里面没有任何值。
- en: The second statement calls an operator named `just`*,* which takes a value and
    wraps that in the Observable context. Hence, when this observable emits, it'll
    emit only the value we specified.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二条语句调用了一个名为 `just`* 的算子，它接受一个值并将其包装在 Observable 上下文中。因此，当这个 observable 发出时，它只会发出我们指定的值。
- en: Next, we provided a sequence of values to our observable with the method named
    `from`*.*
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用名为 `from`*.* 的方法向我们的可观察对象提供了一系列值。
- en: The `from` method can also take a future value and create an Observable. This
    Observable emits values that result from async computations specified in Future.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`from` 方法还可以接受一个未来值并创建一个 Observable。这个 Observable 会发出 Future 中指定的异步计算的结果。'
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then there's the `interval` method, which expects us to provide the interval
    in which we emit values.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是`interval`方法，它期望我们提供发射值的间隔。
- en: 'Finally, there are two more ways we specified. First, we used the operator
    named `defer`*,* which takes the `byname` parameter as another Observable and
    only starts the emission of events once an observer subscribes to it:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还有两种指定的方式。首先，我们使用了名为`defer`的算子，它将`byname`参数作为另一个可观察者，并且只有在观察者订阅它之后才开始发射事件：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With these operators, we were able to create Observables*.* Now let''s attach
    subscriptions to these Observables by calling the `subscribe` method. For that,
    we can add the following snippet to our Scala file. First, let''s add some imports:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些算子，我们能够创建可观察者*。现在让我们通过调用`subscribe`方法将这些可观察者附加到订阅上。为此，我们可以在我们的Scala文件中添加以下片段。首先，让我们添加一些导入：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we add this snippet following the Observables creation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在创建可观察者之后添加以下片段：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method takes the value and performs, or let's say reacts, to the value.
    It returns a `Subscription` instance. The advantage of this `Subscription` parameter
    is that we can cancel the subscription by calling a method named `unsubscribe`*.*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受值并对其执行操作，或者说对其做出反应。它返回一个`Subscription`实例。这个`Subscription`参数的优势在于我们可以通过调用名为`unsubscribe`的方法来取消订阅*。
- en: In the case of `intervalObservables`*,* we had to provide `Thread.sleep(1000)`
    too so that our `intervalObservables` type gets some time to emit values. If we
    don't use some mechanism to wait for these emissions, the thread will be killed
    and we won't get to see the emitted values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`intervalObservables`的情况下，我们还需要提供`Thread.sleep(1000)`，这样我们的`intervalObservables`类型就有时间发射值。如果我们不使用某种机制等待这些发射，线程将被杀死，我们就看不到发射的值。
- en: These are a few ways in which we can create Observables and subscribe to them.
    But that's more of getting used to APIs. We may want to see some examples which
    can demonstrate the use of this reactive pattern.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们创建可观察者并订阅它们的一些方法。但这更多的是熟悉API。我们可能想看看一些示例，以展示这种响应式模式的使用。
- en: 'Let''s think of a scenario. Suppose a user has to fill a form with information
    about a football player. He has to provide the player''s name, age, nationality,
    and the league. After filling the information, the user will press **Submit**
    and that form data comes to us for processing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景。假设用户必须填写一个包含关于足球运动员信息的表单。他必须提供球员的名字、年龄、国籍和联赛。填写完信息后，用户将按下**提交**，然后表单数据就会交给我们处理：
- en: '![](img/00072.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00072.jpeg)'
- en: Now it's up to us to provide a data flow for the player's information. By this,
    we mean that with the specific information, we can create a player's instance,
    validate the information, show the information in some particular format, or any
    other thing you can come up with. The flow is going to be the same for every form
    submission. In that case, we can create an Observable to the event, let's call
    it, the form submit event. Subscribed observer for the same will get data from
    each form submission. And then we can define `onNext` to manipulate the form data
    whichever way we want. Regardless of the user's speed of entering information
    and pressing the **Submit** button, we have the system in place with the Observable,
    which gets notified by the event's occurrence. And the process starts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到我们为玩家的信息提供数据流。通过这种方式，我们指的是，有了具体的信息，我们可以创建一个玩家的实例，验证信息，以某种特定的格式显示信息，或者做任何你能想到的事情。对于每个表单提交，流程都是一样的。在这种情况下，我们可以为事件创建一个可观察者，让我们称它为表单提交事件。订阅此事件的观察者将获取每个表单提交的数据。然后我们可以定义`onNext`来以我们想要的方式操作表单数据。无论用户输入信息或按下**提交**按钮的速度有多快，我们都有Observable系统在位，它会通过事件的触发来接收通知。然后这个过程就开始了。
- en: 'Now, to see this in practice, let''s think that the data source is our favorite
    CSV file, instead of someone filling out the form for us, and see how the code
    might look:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在实际情况中看到这一点，让我们假设数据源是我们最喜欢的CSV文件，而不是有人为我们填写表单，看看代码可能是什么样子：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, think of the `playerObservable` type being created from
    some event source. It's type is `String`, in our case it's supposed to contain
    the player information in string format. Now what we are supposed to do with the
    string is to parse this string information to a Player instance. The methods `readPlayerDateFromSource`*,*
    `parseToPlayer`, and `showPlayerInformation` are part of another object named
    `PlayerService`*:*
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，将 `playerObservable` 类型视为从某些事件源创建。它的类型是 `String`，在我们的例子中，它应该包含以字符串格式表示的玩家信息。现在我们应该对字符串做什么，就是将这个字符串信息解析为
    Player 实例。`readPlayerDateFromSource`、`parseToPlayer` 和 `showPlayerInformation`
    方法是另一个名为 `PlayerService` 的对象的一部分：*
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s see the magic of operators in our case. The first one is the map itself,
    which takes a player string as expected and makes a call to `parseToPlayer`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们案例中操作符的魔力。第一个是 map 本身，它接受一个玩家字符串，并调用 `parseToPlayer`：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you try to infer its result type, it''s nothing but `Observable[Option[Player]]`,
    so nothing has changed; it''s still an Observable. We''ve just made a transformation
    in the Observable world and got a result. After that, we subscribed to the Observables
    and called our desired `showPlayerInformation(player)` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试推断其结果类型，它只是 `Observable[Option[Player]]`，所以没有变化；它仍然是一个可观察对象。我们只是在可观察对象世界中进行了一次转换并得到了一个结果。之后，我们订阅了可观察对象并调用了我们想要的
    `showPlayerInformation(player)` 方法：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This itself is pretty amazing because the system is set up for a particular
    event, in our case the *form submit* event that gives us `Observable[String]`*.*
    Thanks to our hypothetical user, who enters the information and submits it so
    that the system gets a String to operate upon.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身就很令人惊讶，因为系统是为特定事件设置的，在我们的例子中是 *表单提交* 事件，它给我们 `Observable[String]`。多亏了我们假设的用户，他输入信息并提交，这样系统就能得到一个字符串来操作。
- en: 'Now to clear the picture again, we''ll get the help of the following diagram:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了再次澄清画面，我们将借助以下图：
- en: '![](img/00073.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: As shown in the preceding diagram, currently, there's only one source of player
    information attached and the whole pipeline works well. Now think of another scenario
    where our hypothetical user can also select a player from some suggested input.
    What will that look like?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，目前，只有一个玩家信息源附加，整个管道工作良好。现在考虑另一个场景，我们的假设用户也可以从一些建议输入中选择一个玩家。那会是什么样子？
- en: '![](img/00074.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: 'In this case, we might get the whole player information as `Option[Player]`
    instead of string. Hence, the observable working in this case will be of the type
    `Observable[Option[Player]]`*.* Now if we want to execute the same logic as we
    did in the case of form submission, all we have to do is use the merge operator.
    This will combine the Observables, hence we''ll be able to achieve what we desire.
    The important thing is to merge our new Observable at the right place. From the
    diagram, we get a hint that it''ll be better if we merge Observable when we have
    `observable[Option[Player]]` as shown in following diagram:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会得到整个玩家信息作为 `Option[Player]` 而不是字符串。因此，在这种情况下工作的可观察对象将是 `Observable[Option[Player]]`
    类型。现在，如果我们想执行与表单提交情况相同的逻辑，我们只需要使用合并操作符。这将合并可观察对象，因此我们将能够实现我们想要的结果。重要的是要在正确的位置合并我们的新可观察对象。从图中，我们得到一个提示，如果我们像以下图所示合并
    `observable[Option[Player]]`，将会更好：
- en: '![](img/00075.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: Take a look at the preceding diagram. As you can see on the left-most side,
    the suggestion input form gives us `Observable[Option[Player]]`*,* which we merge
    with our transformed Observable of the same type. We can do the same in our code.
    Let's create an Observable from a custom optional player and then merge that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的图。正如你所见，在最左侧，建议输入表单给我们 `Observable[Option[Player]]`，我们将其与我们的转换后的相同类型的可观察对象合并。我们可以在我们的代码中做同样的事情。让我们从一个自定义可选玩家创建一个可观察对象，然后合并它。
- en: 'We''ll just refactor our code to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的代码如下：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that we merged the `observable.just(somePlayer)` type with the Observable
    of the type `Observable[Option[Player]]`*.* This call to merge combines these
    two Observables, and hence the values from these combined sources go through the
    pipeline. We can try this out by running the application. We'll get to see values
    from our CSV file as well as the `somePlayer` Observable we created if the CSV
    file is in the correct place. This way, we can use operators to make our system
    work with several event sources. This is just the tip of the iceberg. There's
    a lot we can achieve with these operators available. I strongly recommend that
    you go through the documentation ([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html))
    from ReactiveX*.* Their marble diagrams explain each of these operators, and you
    can use them according to your needs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们将`observable.just(somePlayer)`类型与类型为`Observable[Option[Player]]`的Observable合并了*.*
    这个合并调用将这两个Observable合并在一起，因此这些合并来源的值将通过管道传输。我们可以通过运行应用程序来尝试这一点。如果CSV文件位于正确的位置，我们将看到来自我们的CSV文件以及我们创建的`somePlayer`Observable的值。这样，我们可以使用操作符使我们的系统与多个事件源一起工作。这只是冰山一角。我们可以用这些操作符实现很多功能。我强烈建议您阅读ReactiveX*.*的文档([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html))。它们的宝石图解释了每个操作符，您可以根据需要使用它们。
- en: With this recommendation, we would want to summarize what we've covered in this
    chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个推荐，我们希望总结本章所涵盖的内容。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced us to the notion of reactive programming. We understood
    the concept of Observable events and reacting to them. This gave us an essence
    of what reactive programming is. After that, we went through reactive extensions
    and explored the API a bit. We saw how we can create Observables and subscribe
    to them. Finally, we looked at   an example that explained the way we can compose
    Observables using some operators available to us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了反应式编程的概念。我们理解了可观察事件的概念以及如何对它们做出反应。这让我们对反应式编程有了本质的理解。之后，我们了解了反应式扩展并探索了API。我们看到了如何创建Observables并订阅它们。最后，我们查看了一个示例，解释了我们可以如何使用可用的某些操作符来组合Observables。
- en: In next chapter, we'll cover one of the most important topics, that is, testing
    our programs. We'll go through the much talked about nowadays development model,
    that is, **test-driven development** (**TDD**). We'll start by answering the why
    and what of TDD and then understand the toolkits available in Scala for testing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一个最重要的主题，那就是测试我们的程序。我们将探讨目前讨论得很多的开发模型，即**测试驱动开发**（**TDD**）。我们将从回答TDD的为什么和是什么开始，然后了解Scala中可用的测试工具包。
