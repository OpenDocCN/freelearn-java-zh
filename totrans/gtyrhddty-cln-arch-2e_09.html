<html><head></head><body>
<div id="_idContainer073">
<h1 class="hapter-number" id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-82"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.2.1">Mapping between Boundaries</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we’ve discussed the web, application, domain, and persistence layers and what each of those layers contributes to implementing a </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We have, however, barely touched on the dreaded and omnipresent topic of mapping between the models of each layer. </span><span class="koboSpan" id="kobo.5.2">I bet you’ve had a discussion at some point about whether to use the same model in two layers in order to avoid implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">a mapper.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">The argument might have gone something </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">like this:</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Pro-mapping developer:</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">“</span><em class="itali"><span class="koboSpan" id="kobo.11.1">If we don’t map between layers, we have to use the same model in both layers, which means that the layers will be </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.12.1">tightly coupled!</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">”</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Contra-mapping developer:</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">“</span><em class="itali"><span class="koboSpan" id="kobo.16.1">But if we do map between layers, we produce a lot of boilerplate code, which is overkill for many use cases since they’re only doing CRUD and have the same model across </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.17.1">layers anyways!</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">As is often the case in discussions such as this, there’s truth to both sides of the argument. </span><span class="koboSpan" id="kobo.19.2">Let’s discuss some mapping strategies with their pros and cons and see whether we can help these developers make </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">a decision.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.21.1">The “No Mapping” strategy</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The first strategy is actually not</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.23.1"> mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">at all.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.25.1"><img alt="Figure 9.1 – If the port interfaces use the domain model as the input and output model, we can choose not to map between layers" src="image/Figure_09.1._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.26.1">Figure 9.1 – If the port interfaces use the domain model as the input and output model, we can choose not to map between layers</span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.27.1">Figure 9</span></em></span><em class="itali"><span class="koboSpan" id="kobo.28.1">.1</span></em><span class="koboSpan" id="kobo.29.1"> shows the components that are relevant for the </span><em class="itali"><span class="koboSpan" id="kobo.30.1">Send Money</span></em><span class="koboSpan" id="kobo.31.1"> use case from our BuckPal </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">example application.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">In the web layer, the web controller calls the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.34.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.35.1"> interface to execute the use case. </span><span class="koboSpan" id="kobo.35.2">This interface takes an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.36.1">Account</span></strong><span class="koboSpan" id="kobo.37.1"> object as an argument. </span><span class="koboSpan" id="kobo.37.2">This means that both the web and </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.38.1">application layers need access to the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.39.1">Account</span></strong><span class="koboSpan" id="kobo.40.1"> class – both are using the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">same model.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">On the other side of the application, we have the same relationship between the persistence and </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">application layer.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Since all layers use the same model, we don’t need to implement mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">But what are the consequences of </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">this design?</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">The web and persistence layers may have special requirements for their models. </span><span class="koboSpan" id="kobo.48.2">If our web layer exposes its model via REST, for instance, the model classes might need some annotations that define how to serialize certain fields into JSON. </span><span class="koboSpan" id="kobo.48.3">The same is true for the persistence layer if we’re using an </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.50.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.51.1">ORM</span></strong><span class="koboSpan" id="kobo.52.1">) framework, which might require some annotations that define the database mapping. </span><span class="koboSpan" id="kobo.52.2">The framework might also require the class to follow a </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">certain contract.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">In the example, all of those special requirements have to be dealt with in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.55.1">Account</span></strong><span class="koboSpan" id="kobo.56.1"> domain model class, even though the domain and application layers are not interested in them. </span><span class="koboSpan" id="kobo.56.2">This violates the Single Responsibility Principle since the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.57.1">Account</span></strong><span class="koboSpan" id="kobo.58.1"> class has to be changed for reasons related to the web, application, and </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">persistence layers.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Aside from the technical requirements, each layer might require certain custom fields on the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.61.1">Account</span></strong><span class="koboSpan" id="kobo.62.1"> class. </span><span class="koboSpan" id="kobo.62.2">This might lead to a fragmented domain model with certain fields only relevant in </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">one layer.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Does this mean, though, that we should never, ever implement a “no mapping” strategy? </span><span class="koboSpan" id="kobo.64.2">Certainly not. </span><span class="koboSpan" id="kobo.64.3">Even though it might feel dirty, a “no mapping” strategy can be </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">perfectly valid.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">Consider a simple CRUD use case. </span><span class="koboSpan" id="kobo.66.2">Do we really need to map the same fields from the web model into the domain model and from the domain model into the persistence model? </span><span class="koboSpan" id="kobo.66.3">I’d say </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">we don’t.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">And what about those JSON or ORM annotations on the domain model? </span><span class="koboSpan" id="kobo.68.2">Do they really bother us? </span><span class="koboSpan" id="kobo.68.3">Even if we have to change</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.69.1"> an annotation or two in the domain model if something changes in the persistence layer, </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">so what?</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">As long as all layers need exactly the same information in exactly the same structure, a “no mapping” strategy is a perfectly </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">valid option.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">As soon as we’re dealing with web or persistence issues in the application or domain layer (aside from annotations, perhaps), however, we should move to another </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">mapping strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">There is a lesson for the two developers from the introduction here: even though we have decided on a certain mapping strategy in the past, we can change </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">it later.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">In my experience, many use cases start their life as simple CRUD use cases. </span><span class="koboSpan" id="kobo.77.2">Later, they might grow into a full-fledged business use case with rich behavior and validations that justify a more expensive mapping strategy. </span><span class="koboSpan" id="kobo.77.3">Or they might forever keep their CRUD status, in which case, we’re glad that we haven’t invested in a different </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">mapping strategy.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.79.1">The “Two-Way” mapping strategy</span></h1>
<p><span class="koboSpan" id="kobo.80.1">A mapping strategy</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.81.1"> where each layer has its own model is what I call the “Two-Way” mapping strategy, as outlined in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.82.1">Figure 9</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.83.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 9.2 – With each adapter having its own model, the adapters are responsible for mapping their model into the domain model and back" src="image/Figure_09.2._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 9.2 – With each adapter having its own model, the adapters are responsible for mapping their model into the domain model and back</span></p>
<p><span class="koboSpan" id="kobo.87.1">Each layer has its own model, which may have a structure that is completely different from the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">The web layer maps the web model into the input model that is expected by the incoming ports. </span><span class="koboSpan" id="kobo.89.2">It also maps domain objects returned by the incoming ports back into the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">web model.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The persistence layer is responsible for a similar mapping between the domain model, which is used by the outgoing ports, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">persistence model.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Both layers map in two directions, hence the name “</span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">Two-Way” mapping.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">With each layer having its own model, it can modify its own model without affecting the other layers (as long as the contents are unchanged). </span><span class="koboSpan" id="kobo.95.2">The web model can have a structure that allows for optimal presentation of the data. </span><span class="koboSpan" id="kobo.95.3">The domain model can have a structure that best allows</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.96.1"> for implementing the use cases. </span><span class="koboSpan" id="kobo.96.2">And the persistence model can have the structure needed by an OR-mapper for persisting objects to </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">a database.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">This mapping strategy also leads to a clean domain model that is not dirtied by web or persistence concerns. </span><span class="koboSpan" id="kobo.98.2">It does not contain JSON or ORM mapping annotations. </span><span class="koboSpan" id="kobo.98.3">The Single Responsibility Principle </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">is satisfied.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Another bonus of “Two-Way” mapping is that, after the “No Mapping” strategy, it’s conceptually the simplest mapping strategy. </span><span class="koboSpan" id="kobo.100.2">The mapping responsibilities are clear: the outer layers/adapters map into the model of the inner layers and back. </span><span class="koboSpan" id="kobo.100.3">The inner layers only know their own model and can concentrate on the domain logic instead </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">of mapping.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">As with every mapping strategy, the “Two-Way” mapping also has </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">its drawbacks.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">First of all, it usually ends up in a lot of boilerplate code. </span><span class="koboSpan" id="kobo.104.2">Even if we use one of the many mapping frameworks out there to reduce the amount of code, implementing the mapping between models usually takes up a good portion of our time. </span><span class="koboSpan" id="kobo.104.3">This is partly due to the fact that debugging mapping logic is a pain – especially when using a mapping framework that hides its inner workings behind a layer of generic code </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">and reflection.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">Another potential drawback is that the incoming and outgoing ports use domain objects as input parameters and return values. </span><span class="koboSpan" id="kobo.106.2">The adapters map these into their own model, but this still creates more coupling between the layers than if we introduce a dedicated “transport model” as in the “full” mapping strategy we’re going to </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">discuss next.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Just like the “No Mapping” strategy, the “Two-Way” mapping strategy is not a silver bullet. </span><span class="koboSpan" id="kobo.108.2">In many projects, however, this kind of mapping is considered a holy law that we have to comply with throughout the whole code base, even for the simplest CRUD use cases. </span><span class="koboSpan" id="kobo.108.3">This unnecessarily slows </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">down development.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">No single mapping strategy</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.111.1"> should be considered an iron law. </span><span class="koboSpan" id="kobo.111.2">Instead, we should decide for each </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">use case.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.113.1">The “Full” mapping strategy</span></h1>
<p><span class="koboSpan" id="kobo.114.1">Another mapping strategy is </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.115.1">what I call the “Full” mapping strategy, as outlined in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.116.1">Figure 9</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.117.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.119.1"><img alt="Figure 9.3 – With each operation requiring its own model, the web adapter and application layer each map their model into the model expected by the operation they want to execute" src="image/Figure_09.3._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.120.1">Figure 9.3 – With each operation requiring its own model, the web adapter and application layer each map their model into the model expected by the operation they want to execute</span></p>
<p><span class="koboSpan" id="kobo.121.1">This mapping strategy introduces a separate input and output model per operation. </span><span class="koboSpan" id="kobo.121.2">Instead of using the domain model to communicate across layer boundaries, we use a model specific to each operation, such as </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.122.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.123.1">, which acts as an input model to the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.124.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.125.1"> port in the figure. </span><span class="koboSpan" id="kobo.125.2">We can call those models “commands,” “requests,” </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">or similar.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">The web layer is responsible for mapping its input into the command object of the application layer. </span><span class="koboSpan" id="kobo.127.2">Such a command makes the interface to the application layer very explicit, with little room for interpretation. </span><span class="koboSpan" id="kobo.127.3">Each use case has its own command with its own fields and validations. </span><span class="koboSpan" id="kobo.127.4">There’s no guessing involved as to which fields should be filled and which fields would be better left empty since they would otherwise trigger a validation we don’t want for our current </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">The application layer is then responsible for mapping the command object into whatever it needs to modify the domain model according to the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Naturally, mapping from one layer into many different commands requires even more mapping code than mapping between a single web model and a domain model. </span><span class="koboSpan" id="kobo.131.2">This mapping, however, is significantly easier to implement and maintain than a mapping that has to handle the needs of many use cases instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">only one.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">I don’t advocate this mapping strategy as a global pattern. </span><span class="koboSpan" id="kobo.133.2">It plays out its advantages best between the web layer (or any other incoming adapter) and the application layer to clearly demarcate the state-modifying use cases of the application. </span><span class="koboSpan" id="kobo.133.3">I would not use it between the application and persistence layers due to the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">mapping overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Usually, I would restrict this kind of mapping to the input model of operations and simply use a domain object as the output model. </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.136.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.137.1"> might then return an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.138.1">Account</span></strong><span class="koboSpan" id="kobo.139.1"> object</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.140.1"> with the updated balance, </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">for instance.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">This shows that the mapping strategies can and should be mixed. </span><span class="koboSpan" id="kobo.142.2">No single mapping strategy needs to be a global rule across </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">all layers.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.144.1">The “One-Way” mapping strategy</span></h1>
<p><span class="koboSpan" id="kobo.145.1">There is yet another mapping strategy </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.146.1">with another set of pros and cons: the “One-Way” strategy visualized in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.147.1">Figure 9</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.148.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.150.1"><img alt="Figure 9.4 – With the domain model and the adapter models implementing the same “state” interface, each layer only needs to map objects it receives from other layers one way" src="image/Figure_09.4._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.151.1">Figure 9.4 – With the domain model and the adapter models implementing the same “state” interface, each layer only needs to map objects it receives from other layers one way</span></p>
<p><span class="koboSpan" id="kobo.152.1">In this strategy, the models in all layers implement the same interface, which encapsulates the state of the domain model by providing getter methods on the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">relevant attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">The domain model itself can implement a rich behavior, which we can access from our services within the application layer. </span><span class="koboSpan" id="kobo.154.2">If we want to pass a domain object to the outer layers, we can do so without mapping since the domain object implements the state interface expected by the incoming and </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">outgoing ports.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">The outer layers can then decide whether they can work with the interface or whether they need to map it into their own model. </span><span class="koboSpan" id="kobo.156.2">They cannot inadvertently modify the state of the domain object since the modifying behavior is not exposed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">state interface.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Objects we pass from an outer layer into the application layer also implement this state interface. </span><span class="koboSpan" id="kobo.158.2">The application layer then</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.159.1"> has to map it into the real domain model in order to get access to its behavior. </span><span class="koboSpan" id="kobo.159.2">This mapping plays well with the </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.161.1"> concept of a factory. </span><span class="koboSpan" id="kobo.161.2">A factory in terms of DDD is responsible for reconstituting a domain object from a certain state, which is exactly what </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">we’re doing.</span></span><span class="No-Break"><span id="footnote-032-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-032"><span class="koboSpan" id="kobo.163.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-032">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-032-backlink"><span class="koboSpan" id="kobo.164.1">1</span></a><span class="koboSpan" id="kobo.165.1">	Factory</span><em class="itali"><span class="koboSpan" id="kobo.166.1">: Domain Driven Design</span></em><span class="koboSpan" id="kobo.167.1"> by Eric Evans, Addison-Wesley, 2004, </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">p. </span><span class="koboSpan" id="kobo.168.2">158</span></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.170.1">The mapping responsibility is clear: if a layer receives an object from another layer, we map it into something the layer can work with. </span><span class="koboSpan" id="kobo.170.2">Thus, each layer only maps one way, making this a “One-Way” </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">mapping strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">With the mapping distributed across layers, however, this strategy is conceptually more difficult than the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">other strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">This strategy plays out its strength best if the models across the layers are similar. </span><span class="koboSpan" id="kobo.174.2">For read-only operations, for instance, the web layer then might not need to map into its own model at all since the state interface provides all the information </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">it needs.</span></span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.176.1">When to use which mapping strategy?</span></h1>
<p><span class="koboSpan" id="kobo.177.1">This is the million-dollar </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.178.1">question, </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">isn’t it?</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">The answer is the usual, dissatisfying </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.181.1">it depends</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Since each mapping strategy has different advantages and disadvantages, we should resist the urge to define a single strategy as a hard-and-fast global rule for the whole code base. </span><span class="koboSpan" id="kobo.183.2">This goes against our instincts, as it feels untidy to mix patterns within the same code base. </span><span class="koboSpan" id="kobo.183.3">But knowingly choosing a pattern that is not the best pattern for a certain job, just to serve our sense of tidiness, is irresponsible, plain </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">and simple.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Also, as software evolves over time, the strategy that was the best for the job yesterday might not still be the best for the job today. </span><span class="koboSpan" id="kobo.185.2">Instead of starting with a fixed mapping strategy and keeping it over time – no matter what – we might start with a simple strategy that allows us to quickly evolve the code and later move to a more complex one that helps us to better decouple </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">the layers.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">In order to decide which strategy to use when, we need to agree upon a set of guidelines within the team. </span><span class="koboSpan" id="kobo.187.2">These guidelines should answer the question of which mapping strategy should be the first choice in which situation. </span><span class="koboSpan" id="kobo.187.3">They should also answer </span><em class="itali"><span class="koboSpan" id="kobo.188.1">why</span></em><span class="koboSpan" id="kobo.189.1"> they are the first choice so that we’re able to evaluate whether those reasons still apply after </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">some time.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">We might, for example, define </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.192.1">different mapping guidelines to modifying use cases than we do to queries. </span><span class="koboSpan" id="kobo.192.2">Also, we might want to use different mapping strategies between the web and application layers and between the application and </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">persistence layers.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Guidelines for these situations might look </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">like this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.196.1">If we’re working on a</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.197.1"> modifying use case, the “Full” mapping strategy is the first choice between the web and application layer, in order to decouple the use cases from one another. </span><span class="koboSpan" id="kobo.197.2">This gives us clear per-use-case validation rules and we don’t have to deal with fields we don’t need in a certain </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">use case.</span></span></li>
<li><span class="koboSpan" id="kobo.199.1">If we’re working on a modifying use case, the “No Mapping” strategy is the first choice between the application and persistence layer in order to be able to quickly evolve the code without mapping overhead. </span><span class="koboSpan" id="kobo.199.2">As soon as we have to deal with persistence issues in the application layer, however, we move to a “Two-Way” mapping strategy to keep persistence issues in the </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">persistence layer.</span></span></li>
<li><span class="koboSpan" id="kobo.201.1">If we’re working on a query, the “No Mapping” strategy is the first choice between the web and application layer and between the application and persistence layer in order to be able to quickly evolve the code without mapping overhead. </span><span class="koboSpan" id="kobo.201.2">As soon as we have to deal with web or persistence issues in the application layer, however, we move to a “Two-Way” mapping strategy between the web and application layer or the application layer and persistence </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">layer, respectively.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.203.1">In order to successfully apply guidelines like these, they must be present in the minds of the developers. </span><span class="koboSpan" id="kobo.203.2">So, the guidelines</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.204.1"> should be discussed and revised continuously as a </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">team effort.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.206.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.207.1">Incoming and outgoing ports act as gatekeepers between the layers of our application. </span><span class="koboSpan" id="kobo.207.2">They define how the layers communicate with each other, and how we map models </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">across layers.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">With narrow ports in place for each use case, we can choose different mapping strategies for different use cases, and even evolve them over time without affecting other use cases, thus selecting the best strategy for a certain situation at a </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">certain time.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Selecting a different mapping strategy for each use case is harder and requires more communication than simply using the same mapping strategy for all situations, but it will reward the team with a code base that does just what it needs to do and is easier to maintain, as long as the mapping guidelines are known. </span></p>
<p><span class="koboSpan" id="kobo.212.1">Now that we know which components make up our application and how they communicate, we can explore how to assemble a working application out of the </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">different components.</span></span></p>
</div>
</body></html>