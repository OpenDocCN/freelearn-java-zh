<html><head></head><body>
<div class="book" title="Chapter&#xA0;4.&#xA0;Detour &#x2013; Functional Programming"><div class="book" id="QMFO2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Detour – Functional Programming</h1></div></div></div><p class="calibre8">In the beginning of this book, we saw that an algorithm is a sequence of steps to achieve a result. This way of solving a problem by following a sequence of instructions is called imperative programming. Each statement in the program can be thought of as an imperative <a id="id125" class="calibre1"/>sentence asking the computer to do something. However, this is not the only way of looking at it. Functional programming sees an algorithm<a id="id126" class="calibre1"/> as a composition of components rather than as a sequence of steps. A problem to solve is seen as a composition of smaller-sized problems. Instead of using a loop, we combine smaller versions of the same problem. Functional programming uses recursion as a basic component. A recursion is nothing but solving the same problem for a smaller size and then composing <a id="id127" class="calibre1"/>the result with something else to get the solution for the given size of the problem. This has a far-reaching implication in how easy it is to read and understand a program. This makes it very important to study.</p><p class="calibre8">There are really two worlds in the programming paradigm. The imperative style of programming is favored by C-like languages, such as C, C++, and Java. On the purely functional side, there are languages such as Lisp, Haskell, and Scheme. Apart from these, some languages try to have the best of both worlds, such as Python or Scala. This is easier said than done; trying to mix both ideas in a language means you have features to support both, but to use them effectively is truly an art.</p><p class="calibre8">So, if Java is imperative in nature, why are we talking about functional programming in this book? Well, as I pointed out, sometimes, it is better to mix both concepts and get the best of both worlds. Recently, the Java community has taken note of this fact and has introduced a feature lambda from Java version 8 to provide some level of functional programming support. So, our intention is not to program completely in functional style, as that is not the preferred programming style of Java, but we will do it just enough to make our programs more beautiful and to aid our understanding of algorithms.</p><p class="calibre8">This chapter will introduce this rather foreign concept to you and provide some basic tools that are commonly used in functional programming. You will learn the following concepts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Recursive algorithms and the immutability of variables</li><li class="listitem">Monads</li><li class="listitem">Aggregations on monads</li><li class="listitem">Java's support for functional programming, that is, lambda.</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Detour &#x2013; Functional Programming">
<div class="book" title="Recursive algorithms"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec21" class="calibre1"/>Recursive algorithms</h1></div></div></div><p class="calibre8">As I have already pointed out, recursive algorithms are a different way of thinking about solving a<a id="id128" class="calibre1"/> problem. For example, say our problem is to write a program that, given a positive integer <code class="email">n</code>, returns the sum of numbers from zero to <code class="email">n</code>. The known imperative way of writing it is simple:</p><div class="informalexample"><pre class="programlisting">public int sum_upto(int n){
  int sum=0;
  for(int i=0;i&lt;=n;i++){
    sum+=i;
  }
  return sum;
}</pre></div><p class="calibre8">The following would be the functional version of the problem:</p><div class="informalexample"><pre class="programlisting">public int sum_upto_functional(int n){
  return n==0?0:n+sum_upto_functional(n-1);
}</pre></div><p class="calibre8">That's it–just a one-liner! This is probably nothing new to Java programmers, as they do understand recursive functions. However, an imperative programmer would use recursion only when nothing else worked. But this is a different way of thinking. How do we justify that it is equivalent to solving the problem for a smaller input and then composing it with something else? Well, we are certainly first computing the same function for an input that is smaller by one and then just adding <span class="strong"><em class="calibre12">n</em></span> to it. There is one more thing to note here: in the imperative version, we are updating the variable called <code class="email">sum</code> for each value of the loop variable <code class="email">i</code>. However, in the functional version, we are not updating any variable. What do we achieve by that? When a variable is updated multiple times in a program, it is hard to understand or debug it because you need to keep track of the latest value. When this does not happen, it is far easier to understand what is happening. In fact, it makes it simpler in such a way that we can even prove the correctness of the program completely formally, which is rather hard to do for imperative programs where variables change values.</p><p class="calibre8">Let's check out<a id="id129" class="calibre1"/> another example. This one is about choosing <span class="strong"><em class="calibre12">r</em></span> objects from <span class="strong"><em class="calibre12">n</em></span> objects, where the order does not matter. Let's have a set <span class="strong"><em class="calibre12">A</em></span> of a finite amount of objects. Let the number of objects in this set be <span class="strong"><em class="calibre12">n</em></span>. How many subsets <span class="strong"><em class="calibre12">B</em></span> of this set <span class="strong"><em class="calibre12">A</em></span> have exactly <span class="strong"><em class="calibre12">r</em></span> elements? Of course, the maximum number of elements any subset of <span class="strong"><em class="calibre12">A</em></span> can have is <span class="strong"><em class="calibre12">n</em></span>; hence <span class="strong"><em class="calibre12">r ≤ n</em></span>. We will call this function <code class="email">choose</code>. So, we write this as <code class="email">choose(n,r)</code>. Now, the only subset that has an equal number of elements as <span class="strong"><em class="calibre12">A</em></span> is <span class="strong"><em class="calibre12">A</em></span> itself. So, <code class="email">choose(n,n)</code> equals 1.</p><p class="calibre8">How do we break this problem into subproblems of a similar nature but with smaller input? To find out how many subsets <span class="strong"><em class="calibre12">B</em></span> have <span class="strong"><em class="calibre12">r</em></span> elements, we first think of the set <span class="strong"><em class="calibre12">A</em></span> as a combination of a subset <span class="strong"><em class="calibre12">C</em></span> with <code class="email">n-1</code> elements and one particular element <span class="strong"><em class="calibre12">a</em></span>. So, we can say <span class="strong"><em class="calibre12">A = C </em></span>
<span class="strong"><em class="calibre12">⋃</em></span>
<span class="strong"><em class="calibre12"> {a}</em></span>. Now, we consider two disjoint cases: the element <span class="strong"><em class="calibre12">a</em></span> is a member of the subset <span class="strong"><em class="calibre12">B</em></span> and when it is not a member of the subset <span class="strong"><em class="calibre12">B</em></span>. When <span class="strong"><em class="calibre12">a</em></span> is not a member of the subset <span class="strong"><em class="calibre12">B</em></span>, <span class="strong"><em class="calibre12">B</em></span> is also a subset of <span class="strong"><em class="calibre12">C</em></span>. The number of such subsets <span class="strong"><em class="calibre12">B</em></span> with exactly <code class="email">r</code> elements is <code class="email">choose(n-1,r)</code>, since <span class="strong"><em class="calibre12">C</em></span> has <code class="email">n-1</code> elements. On the other hand, when <span class="strong"><em class="calibre12">a</em></span> is a member of the set <span class="strong"><em class="calibre12">B</em></span>, then <span class="strong"><em class="calibre12">B</em></span> can be thought of as a union of two sets – a set <span class="strong"><em class="calibre12">D</em></span> that has all the elements of <span class="strong"><em class="calibre12">B</em></span> except <span class="strong"><em class="calibre12">a</em></span>, and the other is just <span class="strong"><em class="calibre12">{a}</em></span>. So, <span class="strong"><em class="calibre12">B = D </em></span>
<span class="strong"><em class="calibre12">⋃</em></span>
<span class="strong"><em class="calibre12"> {a}</em></span>. Now, you can see that <span class="strong"><em class="calibre12">D</em></span> is a subset of <span class="strong"><em class="calibre12">C</em></span> that we defined. How many such subsets <span class="strong"><em class="calibre12">D</em></span> are there of <span class="strong"><em class="calibre12">C</em></span>? There are <code class="email">choose(n-1,r-1)</code> subsets, since <span class="strong"><em class="calibre12">C</em></span> has <code class="email">n-1</code> elements and <span class="strong"><em class="calibre12">D</em></span> has <code class="email">r-1</code> elements. So, the number of such subsets <span class="strong"><em class="calibre12">B</em></span> is <code class="email">choose(n-1,r-1)</code>. This means that the total number of sets <span class="strong"><em class="calibre12">B</em></span> with or without <span class="strong"><em class="calibre12">a</em></span> as an element is <code class="email">choose(n-1,r) + choose(n-1,r-1)</code>. If we put this in recursive calls, the <code class="email">r</code> and <code class="email">n</code> will get reduced until <code class="email">r</code> equals zero or <code class="email">n</code> equals <code class="email">r</code>. We have already considered the case when <code class="email">n</code> equals <code class="email">r</code>, that is, <code class="email">choose(n,n)</code>. When <code class="email">r</code> equals zero, it means <span class="strong"><em class="calibre12">B</em></span> is the null set. Since there is only one null set, <code class="email">choose(n,0)</code> equals <code class="email">1</code>. Now, we put this in code:</p><div class="informalexample"><pre class="programlisting">public long choose(long n, long r){
  if(n&lt;r){
    return 0;
  }else if(r==0){
    return 1;
  }else if(n==r){
    return 1;
  }else{
    return choose(n-1,r) + choose(n-1,r-1);
  }
}</pre></div><p class="calibre8">That was a little complex, but note that not only did we compute the value of the <code class="email">choose</code> function, we also sort of proved that it will work. The <code class="email">choose</code> function is the binomial coefficient function for integral exponents.</p><p class="calibre8">The aforementioned implementation is not efficient. To see why, just consider what each recursive call of the <code class="email">choose</code> function will evaluate to when they both fall in the final else case: <code class="email">choose(n-1,r) = choose(n-2,r)  + choose(n-2,r-1)</code> and <code class="email"> choose(n-1,r-1) = choose(n-2,r-1) + choose(n-2,r-2)</code>. Now note that <code class="email">choose(n-2,r-1)</code> is being <a id="id130" class="calibre1"/>evaluated in both cases, which then would have its own recursive calls. This actually significantly increases the asymptotic complexity. We'll defer the analysis of this complexity to the end of this chapter.</p></div></div>

<div class="book" title="Lambda expressions in Java" id="RL0A1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec22" class="calibre1"/>Lambda expressions in Java</h1></div></div></div><p class="calibre8">Before moving <a id="id131" class="calibre1"/>on, we need to learn about a feature in Java called <span class="strong"><strong class="calibre2">Lambda</strong></span>. Many<a id="id132" class="calibre1"/> of you may already know about it. However, since the feature was only introduced <a id="id133" class="calibre1"/>in version 8, it is better to get familiar with it if you aren't already. It lets you pass a block of code, called a lambda expression, as an argument to another function. To talk about lambda, we must first see what a functional interface is.</p></div>

<div class="book" title="Lambda expressions in Java" id="RL0A1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Functional interface"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec32" class="calibre1"/>Functional interface</h2></div></div></div><p class="calibre8">A functional interface is an interface that has only one unimplemented method, that is to say, a <a id="id134" class="calibre1"/>class that implements it needs to implement<a id="id135" class="calibre1"/> exactly one method. The functional interface may have more than one method declared or inherited, but as long as we can implement it by implementing exactly one method, it is a functional interface. The following example shows one such interface:</p><div class="informalexample"><pre class="programlisting">@FunctionalInterface
public interface SampleFunctionalInterface {
  int modify(int x);
}</pre></div><p class="calibre8">Note that we also marked it as a functional interface with an annotation, but it is not necessary. Marking it ensures that Java will show a compile-time error if the interface does not have exactly one method that needs to be implemented. The following example shows another valid functional interface:</p><div class="informalexample"><pre class="programlisting">public interface AnotherFunctionalInterface{
  public void doSomething(int x);
  public String toString();
}</pre></div><p class="calibre8">There are two methods in it. However, since the <code class="email">toString()</code> method is already implemented in the object class, you need to implement only one method.</p><p class="calibre8">Similarly, an interface with more than one method can be a functional interface if all but one has a default implementation. For example, look at the following interface.</p><div class="informalexample"><pre class="programlisting">@FunctionalInterface
public interface FunctionalInterfaceWithDefaultMethod {
    int modify(int x);
    default int modifyTwice(int x){return modify(modify(x));}
}</pre></div><p class="calibre8">Even though this<a id="id136" class="calibre1"/> interface has two methods, only one<a id="id137" class="calibre1"/> needs to be implemented by any implementation. This makes it a functional interface.</p></div></div>

<div class="book" title="Lambda expressions in Java" id="RL0A1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Implementing a functional interface with lambda"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec33" class="calibre1"/>Implementing a functional interface with lambda</h2></div></div></div><p class="calibre8">So, what<a id="id138" class="calibre1"/> happens if we have a <a id="id139" class="calibre1"/>functional interface? We can provide an inline implementation of it using a cool syntax called lambda, as follows:</p><div class="informalexample"><pre class="programlisting">SampleFunctionalInterface sfi = (x)-&gt;x+1;
int y = sfi.modify(1);</pre></div><p class="calibre8">Take note of the parentheses and the arrow sign. The parentheses contain all the parameters. The types of parameters are not specified because they are already specified in the interface method. There can be zero or more parameters.</p><p class="calibre8">There are two kinds of lambda syntax–one that has an expression as the body and one that has one or more steps as the body. These lambdas look a bit different from each other. A lambda that is implemented as a one liner looks like the one we just saw. This is called an <span class="strong"><strong class="calibre2">expression</strong></span> syntax. The expression syntax can be used if the lambda expression is a one<a id="id140" class="calibre1"/> liner. For multi-line code, we use the block syntax as shown below:</p><div class="informalexample"><pre class="programlisting">Thread t = new Thread(()-&gt;{for(int i=0;i&lt;500;i++) System.out.println(i);});</pre></div><p class="calibre8">One can use block syntax for functions that return a value as well, especially when using multiple lines of code. In that case, one just needs to use a return statement to return a value.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">Since in a functional program all variables must not ever be reassigned, we should declare them final to avoid accidentally modifying them. However, since typing <code class="email">final</code> for<a id="id141" class="calibre1"/> every variable clutters the code a bit, we avoid doing so. In a purely functional language, the variables are immutable by default. Even in a semifunctional language, such as Scala, it is so if it generally encourages the functional style. However, since Java mostly prefers an imperative style, the <code class="email">final</code> keyword is necessary, causing a little clutter.</p></div><p class="calibre8">Now that we know about lambda, we can start learning about functional data structures.</p></div></div>

<div class="book" title="Functional data structures and monads"><div class="book" id="SJGS2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>Functional data structures and monads</h1></div></div></div><p class="calibre8">Functional data structures are data structures that follow the principle of immutability and inductive (or recursive) definition. Immutability means that any modification of the data structure <a id="id142" class="calibre1"/>would result in a new data structure, and any <a id="id143" class="calibre1"/>old reference to the original version would still have access to the original version. Inductive definition means that the definition of the structure is defined as a composition of smaller versions of the same data structure. Take, for example, our linked list. When we add an element to or remove an element from the beginning of the list, it will modify the linked list. That means any reference to the linked list will now hold a reference to the modified linked list. This doesn't conform to the principle of immutability. A functional linked list would make sure that the older references still held reference to an unmodified version. We will discuss how to do it in the next section.</p></div>

<div class="book" title="Functional data structures and monads">
<div class="book" title="Functional linked lists"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec34" class="calibre1"/>Functional linked lists</h2></div></div></div><p class="calibre8">To make<a id="id144" class="calibre1"/> a linked list that is immutable, we <a id="id145" class="calibre1"/>consider a linked list to be made of two parts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A head containing the first element of the list</li><li class="listitem">A tail containing another linked list containing the rest of the elements</li></ul></div><p class="calibre8">Note that we have now defined the linked list recursively, being true to our functional design. This recursion says that a linked list is:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Either an empty list</li><li class="listitem">Or a set of two objects, as follows:<div class="book"><ul class="itemizedlist1"><li class="listitem">A head containing one element of its element type</li><li class="listitem">A tail containing another linked list of the same type</li></ul></div></li></ul></div><p class="calibre8">This version of the definition is the same as the previous simplified one, except that we have now specified how we represent where the list terminates. The list terminates where there are no more elements, that is, when the tail is an empty list. Let's put all these in code.</p><p class="calibre8">First, we define a version according to the simplified definition:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; {
  private E head;
  private LinkedList&lt;E&gt; tail;

  private LinkedList(){

}

  private LinkedList(E head, LinkedList&lt;E&gt; tail){
    this.head = head;
    this.tail = tail;
  }


  public E head(){
    return head;
  }
  public LinkedList&lt;E&gt; tail(){
    return tail;
  }</pre></div><p class="calibre8">This is <a id="id146" class="calibre1"/>the core of immutability for our linked list. Note<a id="id147" class="calibre1"/> that every time we add a new value to our linked list, we create a new linked list so that the old references still hold references to the unmodified list:</p><div class="informalexample"><pre class="programlisting">  public LinkedList&lt;E&gt; add(E value){
    return new LinkedList&lt;E&gt;(value,this);
  }
}</pre></div><p class="calibre8">The code is self-explanatory, now that we already know how we think about our linked list. But note that we have made the constructors private. We don't want people to create inconsistent versions of our linked lists, such as a null <code class="email">tail</code> or something. We insist that everyone creates our linked list by first creating an empty linked list and then adding elements to it. So, we add the following <code class="email">EmptyList</code> class and <code class="email">add()</code> method:</p><div class="informalexample"><pre class="programlisting">public static final class EmptyList&lt;E&gt; extends LinkedList&lt;E&gt;{
  @Override
  public E head() {
    throw new NoValueException("head() invoked on empty list"); 
  }

  @Override
  public LinkedList&lt;E&gt; tail() { 
    throw new NoValueException("tail() invoked on empty list"); 
  }
}

public static &lt;E&gt; LinkedList&lt;E&gt; emptyList(){
  return new EmptyList&lt;&gt;();
}</pre></div><p class="calibre8">Now we can use the linked list as follows:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; linkedList = LinkedList.&lt;Integer&gt;emptyList()
.add(5).add(3).add(0);
while(!(linkedList instanceof LinkedList.EmptyList)){
  System.out.println(linkedList.head());
  linkedList = linkedList.tail();
}</pre></div><p class="calibre8">But wait, did <a id="id148" class="calibre1"/>we just modify the <code class="email">linkedList</code> variable in the <code class="email">while</code> loop? Yes, but that does not comply with the principle of immutability. To<a id="id149" class="calibre1"/> solve this, let's see what we would mostly want to do with a list. In general, we would want to perform the following operations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Do something for each element of the list. For example, print all the elements to the console.</li><li class="listitem">Get a new list where each element is transformed using a function that is provided.</li><li class="listitem">Compute a function of all the elements in the list. This is an aggregation of the elements. For example, find the sum of all the elements.</li><li class="listitem">Create a new<a id="id150" class="calibre1"/> list containing only selected elements of the list. This is called <span class="strong"><strong class="calibre2">filtering</strong></span>.</li></ul></div><p class="calibre8">We will deal with them one by one. At the end of the next section, you will be prepared to learn about monads as well.</p><div class="book" title="The forEach method for a linked list"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec05" class="calibre1"/>The forEach method for a linked list</h3></div></div></div><p class="calibre8">The <code class="email">forEach()</code> method <a id="id151" class="calibre1"/>on a linked list would do <a id="id152" class="calibre1"/>something for each element of the list. This something would be passed as a lambda. For this purpose, we will first create a functional interface that consumes one parameter but does not return anything:</p><div class="informalexample"><pre class="programlisting">@FunctionalInterface
public interface OneArgumentStatement&lt;E&gt; {
  void doSomething(E argument);
}</pre></div><p class="calibre8">With this interface available, we will define the <code class="email">forEach()</code> method for a list, as follows:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; {
…

  public static class EmptyList&lt;E&gt; extends LinkedList&lt;E&gt;{
  …

  @Override
  public void forEach(OneArgumentStatement&lt;E&gt; processor) {}
  }

  …

  public void forEach(OneArgumentStatement&lt;E&gt; processor){
    processor.doSomething(head());
    tail().forEach(processor);
  }
}</pre></div><p class="calibre8">The ellipsis<a id="id153" class="calibre1"/> represent more code that we have already <a id="id154" class="calibre1"/>discussed and need not be repeated. The <code class="email">forEach()</code> method simply processes the head and then recursively calls itself on the tail. Note again that, true to our philosophy of recursion, we have implemented the <code class="email">forEach()</code> method using recursion. Of course, this will not work on an empty list because the head and tail are null. The empty list represents when the method needs to stop calling itself. We achieve this by overriding the <code class="email">forEach()</code> method in the <code class="email">EmptyList</code> class to not do anything.</p><p class="calibre8">Now we can print all the elements using the following code:</p><div class="informalexample"><pre class="programlisting">linkedList.forEach((x) -&gt; {System.out.println(x);});</pre></div><p class="calibre8">We pass a lambda that, given any element <code class="email">x</code>, calls <code class="email">System.out.println</code> on <code class="email">x</code>. But, if you see, this lambda just works as a delegation to the <code class="email">System.out.println</code> method that already has the required form of the lambda. Java allows you to use a method as a lambda with the following syntax. The <code class="email">::</code> operator is used to tell the compiler that you are not looking for a field with that name; instead you are looking for a method with that name:</p><div class="informalexample"><pre class="programlisting">linkedList.forEach(System.out::println);</pre></div><p class="calibre8">Note that this time we did not even modify the list while printing the elements, unlike last time, when we did it using a loop.</p></div><div class="book" title="Map for a linked list"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec06" class="calibre1"/>Map for a linked list</h3></div></div></div><p class="calibre8">Now we move<a id="id155" class="calibre1"/> on to the next thing we want to do with a <a id="id156" class="calibre1"/>list, which is to create a new list where all the elements are transformed according to a lambda that is provided. What I mean is that we want to do the following:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; tranformedList = linkedList.map((x)-&gt;x*2);</pre></div><p class="calibre8">We need to implement the <code class="email">map()</code> method in a way that <code class="email">transformedList</code> holds all the elements of <code class="email">linkedList</code> multiplied by <code class="email">2</code>, in the same order. The following is the implementation<a id="id157" class="calibre1"/> of the <code class="email">map()</code> method:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; {
…
  public static class EmptyList&lt;E&gt; extends LinkedList&lt;E&gt;{
  …

  @Override
  public &lt;R&gt; LinkedList&lt;R&gt; map(OneArgumentExpression&lt;E, R&gt; transformer) {

  return LinkedList.emptyList();
  }
}
…

  public &lt;R&gt; LinkedList&lt;R&gt; map(OneArgumentExpression&lt;E,R&gt; transformer){
    return new LinkedList&lt;&gt;(transformer.compute(head()),
    tail.map(transformer));
  }
}</pre></div><p class="calibre8">As usual, the <a id="id158" class="calibre1"/>method is defined recursively. The transformed list is just the head transformed followed by the tail transformed. We have also overridden the method in the <code class="email">EmptyList</code> class to return an empty list because an empty list transformed is just another empty list of a possibly different type. With this implementation in place, we can do the following:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; tranformedList = linkedList.map((x)-&gt;x*2);
tranformedList.forEach(System.out::println);</pre></div><p class="calibre8">This should print a list with all the values multiplied by <code class="email">2</code>. You can even change the type of the elements by transformation, such as the following:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;String&gt; tranformedListString
 = linkedList.map((x)-&gt;"x*2 = "+(x*2));
tranformedListString.forEach(System.out::println);</pre></div><p class="calibre8">The <code class="email">tranformedListString</code> list is a list of strings, and printing each element on the next line shows the strings obtained.</p><p class="calibre8">Now we <a id="id159" class="calibre1"/>move on to the next thing we want to do with a<a id="id160" class="calibre1"/> list, which is to compute some function that uses all the values in the list. This is called an <span class="strong"><strong class="calibre2">aggregation</strong></span> operation. But<a id="id161" class="calibre1"/> before looking at a general case, we will concentrate on a specific one, called a <span class="strong"><strong class="calibre2">fold</strong></span> operation.</p></div><div class="book" title="Fold operation on a list"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec07" class="calibre1"/>Fold operation on a list</h3></div></div></div><p class="calibre8">A fold operation <a id="id162" class="calibre1"/>on a list is an aggregation operation<a id="id163" class="calibre1"/> that can be done element by element. For example, if we want to compute the sum of all the elements of a list, we can do it by taking each element of the list and adding it to a moving sum, so when we are done with processing all the elements, we will have the sum of all elements.</p><p class="calibre8">There are two operations that suit this purpose: <code class="email">foldLeft</code> and <code class="email">foldRight</code>. The <code class="email">foldLeft</code> operation aggregates the head first and moves on to the tail. The <code class="email">foldRight</code> method aggregates the tail first and then moves on to the head. Let's start with <code class="email">foldLeft</code>. But before doing anything, we need a functional interface that represents an expression of two parameters:</p><div class="informalexample"><pre class="programlisting">@FunctionalInterface
public interface TwoArgumentExpression&lt;A,B,R&gt; {
  R compute(A lhs, B rhs);
}</pre></div><p class="calibre8">With this interface available, we define the <code class="email">foldLeft</code> method in the following way:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; {
  …
  …

  public static class EmptyList&lt;E&gt; extends LinkedList&lt;E&gt;{

    …

    @Override
    public &lt;R&gt; R foldLeft(R initialValue, TwoArgumentExpression&lt;R, E, R&gt; computer) {
      return initialValue; 
    }
  }

  …

  public &lt;R&gt; R foldLeft(R initialValue, TwoArgumentExpression&lt;R,E,R&gt; computer){
    R newInitialValue = computer.compute(initialValue, head());
    return tail().foldLeft(newInitialValue, computer);
  }
}</pre></div><p class="calibre8">We compute a new value from <code class="email">initialValue</code> and the head using the lambda passed, and then we use this updated value to compute <code class="email">foldLeft</code> on the tail. The empty list overrides this method to just return the <code class="email">initialValue</code> itself because it just marks the end of the list. Now we can compute the sum of all elements as follows:</p><div class="informalexample"><pre class="programlisting">int sum = linkedList.foldLeft(0,(a,b)-&gt;a+b);
System.out.println(sum);</pre></div><p class="calibre8">We have <a id="id164" class="calibre1"/>passed <code class="email">0</code> as the initial value and the lambda <a id="id165" class="calibre1"/>that sums up the values passed. This looks complicated until you get used to this idea, but once you get used to it, it is very simple. Let's see what is happening step by step; the list from <code class="email">head</code> to <code class="email">tail</code> is <code class="email">{0,3,5}</code>:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In the first invocation, we pass the initial value <code class="email">0</code>. The computed <code class="email">newInitialValue</code> is <code class="email">0+0 = 0</code>. Now, we pass this <code class="email">newInitialValue</code> to the tail to <code class="email">foldLeft</code>, which is <code class="email">{3,5}</code>.</li><li class="listitem" value="2">The <code class="email">{3,5}</code> has a <code class="email">head 3</code> and <code class="email">tail {5}</code>. <code class="email">3</code> is added to the <code class="email">initialValue</code> <code class="email">0</code> to give a <code class="email">newInitialValue 0+3=3</code>. Now, this new value <code class="email">3</code> is passed to the tail <code class="email">{5}</code> to <code class="email">foldLeft</code>.</li><li class="listitem" value="3">The <code class="email">{5}</code> has a <code class="email">head 5</code> and <code class="email">tail</code> and empty list. <code class="email">5</code> is added to the <code class="email">initialValue 3</code> to get <code class="email">8</code>. Now this <code class="email">8</code> is passed as <code class="email">initialValue</code> to the <code class="email">tail</code>, which is an empty list.</li><li class="listitem" value="4">The empty list, of course, just returns the initial value for a <code class="email">foldLeft</code> operation. So it returns <code class="email">8</code>, and we get the <code class="email">sum</code>.</li></ol><div class="calibre13"/></div><p class="calibre8">Instead of computing one value, we can even compute a list as a result. The following code reverses a list:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; reversedList = linkedList.foldLeft(LinkedList.emptyList(),(l,b)-&gt;l.add(b) );
reversedList.forEach(System.out::println);</pre></div><p class="calibre8">We have simply passed an empty list as an initial operation, and then our operation simply adds a new element to the list. In the case of <code class="email">foldLeft</code>, the head will be added before the tail, causing it to be placed more in the tail side in the newly constructed list.</p><p class="calibre8">What if we want to process the right-most end (or away from the head) first and move to the left? This operation is called <code class="email">foldRight</code>. This can be implemented in a very similar manner, as follows:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; {
  …

  public static class EmptyList&lt;E&gt; extends LinkedList&lt;E&gt;{
    …

    @Override
    public &lt;R&gt; R foldRight(TwoArgumentExpression&lt;E, R, R&gt; computer, R initialValue) {
      return initialValue;
    }
  }

  …

  public &lt;R&gt; R foldRight(TwoArgumentExpression&lt;E,R,R&gt; computer, R initialValue){
    R computedValue = tail().foldRight(computer, initialValue);
    return computer.compute(head(), computedValue);
  }
}</pre></div><p class="calibre8">We have <a id="id166" class="calibre1"/>switched the order of the arguments to <a id="id167" class="calibre1"/>make it intuitive that the <code class="email">initialValue</code> is being combined from the right end of the list. The difference from <code class="email">foldLeft</code> is that we compute the value on the tail first, calling a <code class="email">foldRight</code> on it. Then we return the result of the computed value from the tail being combined with the head to get the result. In the case of computing a sum, it does not make any difference which fold you invoke because sum is commutative, that is, <code class="email">a+b</code> always equals <code class="email">b+a</code>. We can call the <code class="email">foldRight</code> operation for the computation of sum in the following way, which will give the same sum:</p><div class="informalexample"><pre class="programlisting">int sum2 = linkedList.foldRight((a,b)-&gt;a+b, 0);
System.out.println(sum2);</pre></div><p class="calibre8">However, if we use an operator that is not commutative, we will get a different result. For example, if we try reversing the list with the <code class="email">foldRight</code> method, it will give the same list instead of being reversed:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; sameList = linkedList.foldRight((b,l)-&gt;l.add(b), LinkedList.emptyList());
sameList.forEach(System.out::println);</pre></div><p class="calibre8">The final thing we wanted to do with a list was filtering. You will learn it in the next subsection.</p></div><div class="book" title="Filter operation for a linked list"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec08" class="calibre1"/>Filter operation for a linked list</h3></div></div></div><p class="calibre8">Filter is an <a id="id168" class="calibre1"/>operation that takes a lambda as a condition <a id="id169" class="calibre1"/>and creates a new list that has only those elements that satisfy the condition. To demonstrate this, we will create a utility method that creates a list of a range of elements.</p><p class="calibre8">First, we create a helper method that appends a range of numbers to the head of an existing list. This method can call itself recursively:</p><div class="informalexample"><pre class="programlisting">private static LinkedList&lt;Integer&gt; ofRange(int start, int end, LinkedList&lt;Integer&gt; tailList){
  if(start&gt;=end){
    return tailList;
  }else{
    return ofRange(start+1, end, tailList).add(start);
  }
}</pre></div><p class="calibre8">Then we use the helper method to generate a list of a range of numbers:</p><div class="informalexample"><pre class="programlisting">public static LinkedList&lt;Integer&gt; ofRange(int start, int end){
  return ofRange(start,end, LinkedList.emptyList());
}</pre></div><p class="calibre8">This will let us create a list of a range of integers. The range includes the start and excludes the end. For example, the following code will create a list of numbers from 1 to 99 and then print the list:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; rangeList = LinkedList.ofRange(1,100);
rangeList.forEach(System.out::println);</pre></div><p class="calibre8">We now want to create a list of all even numbers, say. For that, we create a <code class="email">filter</code> method in the <code class="email">LinkedList</code> class:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; {

  …

    public static class EmptyList&lt;E&gt; extends LinkedList&lt;E&gt;{

    …

    @Override
    public LinkedList&lt;E&gt; filter(OneArgumentExpression&lt;E, Boolean&gt; selector) {
      return this;
    }
  }

  …

  public LinkedList&lt;E&gt; filter(OneArgumentExpression&lt;E, Boolean&gt; selector){
    if(selector.compute(head())){
      return new LinkedList&lt;E&gt;(head(), tail().filter(selector));
    }else{
      return tail().filter(selector);
    }
  }
}</pre></div><p class="calibre8">The <code class="email">filter()</code> method <a id="id170" class="calibre1"/>checks whether the the condition is<a id="id171" class="calibre1"/> met. If yes, then it includes the <code class="email">head</code> and calls the <code class="email">filter()</code> method on the <code class="email">tail</code>. If not, then it just calls the <code class="email">filter()</code> method on the <code class="email">tail</code>. The <code class="email">EmptyList</code> of course needs to override this method to just return itself because all we need is an empty list. Now, we can do the following:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; evenList = LinkedList.ofRange(1,100).filter((a)-&gt;a%2==0);
evenList.forEach(System.out::println);</pre></div><p class="calibre8">This will print all the even numbers between 1 and 99. Let's go through some more examples in order to get used to all this stuff. How do we add all numbers from 1 to 100? The following code will do that:</p><div class="informalexample"><pre class="programlisting">int sumOfRange = LinkedList.ofRange(1,101).foldLeft(0, (a,b)-&gt;a+b);
System.out.println(sumOfRange);</pre></div><p class="calibre8">Note that we have used the range of <code class="email">(1,101)</code> because the end number is not included in the generated linked list.</p><p class="calibre8">How do we compute the factorial of a number using this? We define a <code class="email">factorial</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public static BigInteger factorial(int x){
  return LinkedList.ofRange(1,x+1)
  .map((a)-&gt;BigInteger.valueOf(a))
  .foldLeft(BigInteger.valueOf(1),(a,b)-&gt;a.multiply(b));
}</pre></div><p class="calibre8">We have used Java's <code class="email">BigInteger</code> class because factorials grow too fast and an <code class="email">int</code> or a <code class="email">long</code> cannot hold much. This code demonstrates how we converted the list of integers to a list of <code class="email">BigIntegers</code> using the <code class="email">map</code> method before multiplying them with the <code class="email">foldLeft</code> method. We can now compute the <code class="email">factorial</code> of <code class="email">100</code> with the following code:</p><div class="informalexample"><pre class="programlisting">System.out.println(factorial(100));</pre></div><p class="calibre8">This example also demonstrates the idea that we can combine the methods we developed to solve more complicated problems. Once you get used to this, reading a functional program and understanding what it does is a lot simpler than doing the same for their imperative versions. We have even used one-character variable names. Actually, we could use meaningful names, and in some cases, we should. But here the program is so simple and the variables used are so close to where they are defined that it's not even necessary to<a id="id172" class="calibre1"/> name them descriptively.</p><p class="calibre8">Let's say we <a id="id173" class="calibre1"/>want to repeat a string. Given an integer, <code class="email">n</code>, and a string, we want the resultant string to be a repetition of the original string <code class="email">n</code> number of times. For example, given an integer <code class="email">5</code> and a string <code class="email">Hello</code>, we want the output to be <code class="email">HelloHello HelloHello Hello</code>. We can do this with the following function:</p><div class="informalexample"><pre class="programlisting">public static String repeatString(final String seed, int count){
  return LinkedList.ofRange(1,count+1)
  .map((a)-&gt;seed)
  .foldLeft("",(a,b)-&gt;a+b);
}</pre></div><p class="calibre8">What we are doing here is first creating a list of length <code class="email">count</code> and then replacing all its elements with the <code class="email">seed</code>. This gives us a new list with all the elements equal to the <code class="email">seed</code>. This can be folded to get the desired repeated string. This is easy to understand because it is very much like the <code class="email">sum</code> method, except we are adding strings instead of integers, which causes repetition of the string. But we don't even need to do this. We can do this even without creating a new list with all the elements replaced. The following will do it:</p><div class="informalexample"><pre class="programlisting">public static String repeatString2(final String seed, int count){
  return LinkedList.ofRange(1,count+1)
  .foldLeft("",(a,b)-&gt;a+seed);
}</pre></div><p class="calibre8">Here, we just ignore the integer in the list and add the <code class="email">seed</code> instead. In the first iteration, <code class="email">a</code> would be set to the initial value, which is an empty string. Every time, we just ignore the content and instead add the <code class="email">seed</code> to this string. Note that in this case, variable <code class="email">a</code> is of the <code class="email">String</code> type and variable <code class="email">b</code> is of the <code class="email">Integer</code> type.</p><p class="calibre8">So, we can do a lot of things using a linked list, using its special methods with lambda parameters. This is the power of functional programming. What we are doing with lambda, though, is that we are passing the implementation of interfaces as pluggable code. This is not a new concept in an object-oriented language. However, without the lambda syntax, it would take a lot of code to define an anonymous class to do the equivalent, which would clutter the code a lot, thus undermining the simplicity. What has changed though is the immutability, leading to chaining of methods and other concepts. We are not thinking about state while analyzing the programs; we are simply thinking of it as a chain of transformations. The variables are more like variables in algebra, where the<a id="id174" class="calibre1"/> value <a id="id175" class="calibre1"/>of <code class="email">x</code> stays the same throughout a formula.</p></div><div class="book" title="Append on a linked list"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec09" class="calibre1"/>Append on a linked list</h3></div></div></div><p class="calibre8">We have <a id="id176" class="calibre1"/>completed all the things that were in <a id="id177" class="calibre1"/>the list of the things we wanted to do. There may be a few more. One important thing, for example, is <code class="email">append</code>. This operation sticks one list to another. This can be done using the <code class="email">foldRight</code> method that we have already defined:</p><div class="informalexample"><pre class="programlisting">public LinkedList&lt;E&gt; append(LinkedList&lt;E&gt; rhs){
  return this.foldRight((x,l)-&gt;l.add(x),rhs);
}</pre></div><p class="calibre8">Now, we perform the following:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; linkedList = 
LinkedList.&lt;Integer&gt;emptyList().add(5).add(3).add(0);
LinkedList&lt;Integer&gt; linkedList2 =
 LinkedList.&lt;Integer&gt;emptyList().add(6).add(8).add(9);
linkedList.append(linkedList2).forEach(System.out::print);</pre></div><p class="calibre8">This will output <code class="email">035986</code>, which is the first list stuck in front of the second list.</p><p class="calibre8">To understand how it works, first remember what a <code class="email">foldRight</code> operation does. It starts with an initial value–in this case, the <span class="strong"><strong class="calibre2">right hand side</strong></span> (<span class="strong"><strong class="calibre2">RHS</strong></span>). Then it takes one element at a time from the tail <a id="id178" class="calibre1"/>end of the list and operates on that with the initial list using the provided operation. In our case, the operation simply adds an element to the head of the initial list. So, in the end, we get the entire list appended to the beginning of the RHS.</p><p class="calibre8">There is one more thing that we want to do with a list, but we have not talked about it until now. This concept requires an understanding of the earlier concepts. This is called a <code class="email">flatMap</code> operation, and we will explore it in the next subsection.</p></div><div class="book" title="The flatMap method on a linked list"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec10" class="calibre1"/>The flatMap method on a linked list</h3></div></div></div><p class="calibre8">The <code class="email">flatMap</code> operation is just like the <code class="email">map</code> operation, except we expect the operation passed to <a id="id179" class="calibre1"/>return a list itself instead of a value. The<a id="id180" class="calibre1"/> job of the <code class="email">flatMap</code> operation is to flatten the lists thus obtained and append them one after another. Take for example the following code:</p><div class="informalexample"><pre class="programlisting">LinkedList&lt;Integer&gt; funnyList 
=LinkedList.ofRange(1,10)
.flatMap((x)-&gt;LinkedList.ofRange(0,x));</pre></div><p class="calibre8">The operation passed returns a range of numbers starting from <code class="email">0</code> to <code class="email">x-1</code>. Since we started the <code class="email">flatMap</code> on a list of numbers from 1 to 9, <code class="email">x</code> will get values from 1 to 9. Our operation will then return a list containing 0,x-1 for each value of <code class="email">x</code>. The job of the <code class="email">flatMap</code> operation is to then flatten all these lists and stick them one after another. Take a look at the following line of code, where we print <code class="email">funnyList</code>:</p><div class="informalexample"><pre class="programlisting">funnyList.forEach(System.out::print);</pre></div><p class="calibre8">It will print <code class="email">001012012301234012345012345601234567012345678</code> on the output.</p><p class="calibre8">So, how do we implement the <code class="email">flatMap</code> operation? Let's have a look:</p><div class="informalexample"><pre class="programlisting">public class LinkedList&lt;E&gt; {

  public static class EmptyList&lt;E&gt; extends LinkedList&lt;E&gt;{

    …

    @Override
    public &lt;R&gt; LinkedList&lt;R&gt; flatMap(OneArgumentExpression&lt;E, LinkedList&lt;R&gt;&gt; transformer) {
      return LinkedList.emptyList();
    }
  }

  …

  public &lt;R&gt; LinkedList&lt;R&gt; flatMap(OneArgumentExpression&lt;E, LinkedList&lt;R&gt;&gt; transformer){
    return transformer.compute(head())
    append(tail().flatMap(transformer));
  }
}</pre></div><p class="calibre8">So what is happening here? First, we compute the list obtained by the <code class="email">head</code> and the result of the <code class="email">flatMap</code> operation on the <code class="email">tail</code>. Then we <code class="email">append</code> the result of the operation on the <code class="email">head</code> of the <a id="id181" class="calibre1"/>list in front of the list obtained<a id="id182" class="calibre1"/> by <code class="email">flatMap</code> on the tail. In case of an empty list, the <code class="email">flatMap</code> operation just returns an empty list because there is nothing for the transformation to be called on.</p></div></div></div>

<div class="book" title="The concept of a monad"><div class="book" id="TI1E2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>The concept of a monad</h1></div></div></div><p class="calibre8">In the previous <a id="id183" class="calibre1"/>section, we saw quite a few operations for a linked list. A few of them, namely <code class="email">map</code> and <code class="email">flatMap</code>, are a common theme in many objects in functional programming. They have a meaning outside of the list. The <code class="email">map</code> and <code class="email">flatMap</code> methods, and a method to construct a monad from a value are what make such a wrapper object a monad. A monad is a common design pattern that is followed in functional programming. It is a sort of container, something that stores objects of some other class. It can contain one object directly as we will see; it can contain multiple objects as we have seen in the case of a linked list, it can contain objects that are only going to be available in the future after calling some function, and so on. There is a formal definition of monad, and different languages name its methods differently. We will only consider the way Java defines the methods. A monad must have two methods, called <code class="email">map()</code> and <code class="email">flatMap()</code>. The <code class="email">map()</code> method accepts a lambda that works as a transformation for all the contents of the monad. The <code class="email">flatMap</code> method also takes a method, but instead of returning the transformed value, it returns another monad. The <code class="email">flatMap()</code> method then extracts the output from the monad and creates a transformed monad. We have already seen an example of a monad in the form of a linked list. But the general theme does not become clear until you have seen a few examples instead of just one. In the next section, we will see another kind of monad: an option monad.</p></div>

<div class="book" title="The concept of a monad">
<div class="book" title="Option monad"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec35" class="calibre1"/>Option monad</h2></div></div></div><p class="calibre8">An<a id="id184" class="calibre1"/> option monad is a monad containing a single value. The whole<a id="id185" class="calibre1"/> point of this is to avoid handling null pointers in our code, which sort of masks the actual logic. The point of an option monad is to be able to hold a null value in a way that null checks are not required in every step. In some way, an option monad can be thought of as a list of zero or one objects. If it contains just zero objects, then it represents a null value. If it contains one object, then it works as the wrapper of that object. The <code class="email">map</code> and <code class="email">flatMap</code> methods then behave exactly like they would behave in the case of a one-argument list. The class that represents an empty option is called <code class="email">None</code>. First, we create an abstract class for an option monad. Then, we create two inner classes called <code class="email">Some</code> and <code class="email">None</code> to represent an <code class="email">Option</code> containing a value and one without a value, respectively. This is a more general pattern for developing a monad and can cater to the fact that the non-empty <code class="email">Option</code> has to store a value. We could do this with a list as well. Let's first<a id="id186" class="calibre1"/> see our abstract class:</p><div class="informalexample"><pre class="programlisting">public abstract class Option&lt;E&gt; {
  public abstract E get();
  public abstract &lt;R&gt; Option&lt;R&gt; map(OneArgumentExpression&lt;E,R&gt; transformer);
  public abstract &lt;R&gt; Option&lt;R&gt; flatMap(OneArgumentExpression&lt;E,Option&lt;R&gt;&gt; transformer);
  public abstract void forEach(OneArgumentStatement&lt;E&gt; statement);

  …
}</pre></div><p class="calibre8">A static<a id="id187" class="calibre1"/> method <code class="email">optionOf</code> returns the appropriate instance of the <code class="email">Option</code> class:</p><div class="informalexample"><pre class="programlisting">public static &lt;X&gt; Option&lt;X&gt;  optionOf(X value){
  if(value == null){
    return new None&lt;&gt;();
  }else{
    return new Some&lt;&gt;(value);
  }
}</pre></div><p class="calibre8">We now define the inner class, called <code class="email">None</code>:</p><div class="informalexample"><pre class="programlisting">public static class None&lt;E&gt; extends Option&lt;E&gt;{

  @Override
  public &lt;R&gt; Option&lt;R&gt; flatMap(OneArgumentExpression&lt;E, Option&lt;R&gt;&gt; transformer) {
    return new None&lt;&gt;();
  }

  @Override
  public E get() {
    throw new NoValueException("get() invoked on None");
  }

  @Override
  public &lt;R&gt; Option&lt;R&gt; map(OneArgumentExpression&lt;E, R&gt; transformer) {
    return new None&lt;&gt;();
  }

  @Override
  public void forEach(OneArgumentStatement&lt;E&gt; statement) {
  }
}</pre></div><p class="calibre8">We create<a id="id188" class="calibre1"/> another class, <code class="email">Some</code>, to represent a non-empty list. We store the <a id="id189" class="calibre1"/>value as a single object in the class <code class="email">Some</code>, and there is no recursive tail:</p><div class="informalexample"><pre class="programlisting">public static class Some&lt;E&gt; extends Option&lt;E&gt;{
  E value;
  public Some(E value){
    this.value = value;
  }
  public E get(){
    return value;
  }
  …
}</pre></div><p class="calibre8">The <code class="email">map</code> and <code class="email">flatMap</code> methods are pretty intuitive. The <code class="email">map</code> method accepts a transformer and returns a new <code class="email">Option</code> where the value is transformed. The <code class="email">flatMap</code> method does the same, except it expects the transformer to wrap the returned value inside another <code class="email">Option</code>. This is useful when the transformer can sometimes return a null value, in which case the <code class="email">map</code> method will return an inconsistent <code class="email">Option</code>. Instead, the transformer should wrap it in an <code class="email">Option</code>, for which we need to use a <code class="email">flatMap</code> operation. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">public static class Some&lt;E&gt; extends Option&lt;E&gt;{
  …

  public &lt;R&gt; Option&lt;R&gt; map(OneArgumentExpression&lt;E,R&gt; transformer){
    return Option.optionOf(transformer.compute(value));
  }
  public &lt;R&gt; Option&lt;R&gt; flatMap(OneArgumentExpression&lt;E,Option&lt;R&gt;&gt; transformer){
    return transformer.compute(value);
  }
  public void forEach(OneArgumentStatement&lt;E&gt; statement){
    statement.doSomething(value);
  }
}</pre></div><p class="calibre8">To understand the usage <a id="id190" class="calibre1"/>of an <code class="email">Option</code> monad, we will first create a <span class="strong"><strong class="calibre2">JavaBean</strong></span>. A JavaBean is an object exclusively intended to store data. It is the equivalent of a structure in C. However, since encapsulation is a defining principle of Java, the members of the JavaBean are not accessed directly. They are instead accessed through special methods called getters and setters. However, our functional style dictates that the beans be immutable, so <a id="id191" class="calibre1"/>there won't be any setter methods. The following set of<a id="id192" class="calibre1"/> classes gives a few examples of JavaBeans:</p><div class="informalexample"><pre class="programlisting">public class Country {
  private String name;
  private String countryCode;

  public Country(String countryCode, String name) {
    this.countryCode = countryCode;
    this.name = name;
  }

  public String getCountryCode() {
    return countryCode;
  }

  public String getName() {
    return name;
  }
}
public class City {
  private String name;
  private Country country;

  public City(Country country, String name) {
    this.country = country;
    this.name = name;
  }

  public Country getCountry() {
    return country;
  }

  public String getName() {
    return name;
  }

}
public class Address {
  private String street;
  private City city;

  public Address(City city, String street) {
    this.city = city;
    this.street = street;
  }

  public City getCity() {
    return city;
  }

  public String getStreet() {
    return street;
  }
}
public class Person {
  private String name;
  private Address address;

  public Person(Address address, String name) {
    this.address = address;
    this.name = name;
  }

  public Address getAddress() {
    return address;
  }

  public String getName() {
    return name;
  }
}</pre></div><p class="calibre8">There is not <a id="id193" class="calibre1"/>much to understand in these four classes. They are there to<a id="id194" class="calibre1"/> store a person's data. In Java, it is not very uncommon to hit a case where you will hit a very similar kind of object.</p><p class="calibre8">Now, let's say, given a variable <code class="email">person</code> of type <code class="email">Person</code>, we want to print the name of the country he/she lives in. If the case is that any of the state variables can be null, the correct way to do it with all null checks would look like the following:</p><div class="informalexample"><pre class="programlisting">if(person!=null
 &amp;&amp; person.getAddress()!=null
 &amp;&amp; person.getAddress().getCity()!=null
 &amp;&amp; person.getAddress().getCity().getCountry()!=null){
  System.out.println(person.getAddress().getCity().getCountry());
}</pre></div><p class="calibre8">This code would work, but let's face it–it's a whole bunch of null checks. We can get a hold of the address simply by using our <code class="email">Options</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">String countryName = Option.optionOf(person)
.map(Person::getAddress)
.map(Address::getCity)
.map(City::getCountry)
.map(Country::getName).get();</pre></div><p class="calibre8">Note that if<a id="id195" class="calibre1"/> we just print this address, there is a chance that we will print<a id="id196" class="calibre1"/> null. But it would not result in a null-pointer exception. If we don't want to print null, we need a <code class="email">forEach</code> method just like the one in our linked list:</p><div class="informalexample"><pre class="programlisting">public class Option&lt;E&gt; {
  public static class None&lt;E&gt; extends Option&lt;E&gt;{
  
  …

    @Override
    public void forEach(OneArgumentStatement&lt;E&gt; statement) {
    }
  }

…

  public void forEach(OneArgumentStatement&lt;E&gt; statement){
    statement.doSomething(value);
  }
}</pre></div><p class="calibre8">The <code class="email">forEach</code> method just calls the lambda passed on the value it contains, and the <code class="email">None</code> class overrides it to do nothing. Now, we can do the following:</p><div class="informalexample"><pre class="programlisting">Option.optionOf(person)
.map(Person::getAddress)
.map(Address::getCity)
.map(City::getCountry)
.map(Country::getName)
.forEach(System.out::println);</pre></div><p class="calibre8">This code will now not print anything in case of a null name in <code class="email">country</code>.</p><p class="calibre8">Now, what happens if the <code class="email">Person</code> class itself is functionally aware and returns <code class="email">Options</code> to avoid returning null values? This is where we need a <code class="email">flatMap</code>. Let's make a new version of all the classes that were a part of the <code class="email">Person</code> class. For brevity, I will only show the modifications in the <code class="email">Person</code> class and show how it works. You can then check the modifications<a id="id197" class="calibre1"/> on<a id="id198" class="calibre1"/> the other classes. Here's the code:</p><div class="informalexample"><pre class="programlisting">public class Person {
  private String name;
  private Address address;

  public Person(Address address, String name) {
    this.address = address;
    this.name = name;
  }

  public Option&lt;Address&gt; getAddress() {
    return Option.optionOf(address);
  }

  public Option&lt;String&gt; getName() {
    return Option.optionOf(name);
  }
}</pre></div><p class="calibre8">Now, the code will be modified to use <code class="email">flatMap</code> instead of <code class="email">map</code>:</p><div class="informalexample"><pre class="programlisting">Option.optionOf(person)
.flatMap(Person::getAddress)
.flatMap(Address::getCity)
.flatMap(City::getCountry)
.flatMap(Country::getName)
.forEach(System.out::println);</pre></div><p class="calibre8">The code now fully uses the <code class="email">Option</code> monad.</p></div></div>

<div class="book" title="The concept of a monad">
<div class="book" title="Try monad"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec36" class="calibre1"/>Try monad</h2></div></div></div><p class="calibre8">Another monad <a id="id199" class="calibre1"/>we can discuss is the <code class="email">Try</code> monad. The point of this monad is to <a id="id200" class="calibre1"/>make exception handing a lot more compact and avoid hiding the details of the actual program logic. The semantics of the <code class="email">map</code> and <code class="email">flatMap</code> methods are self-evident. Again, we create two subclasses, one for success and one for failure. The <code class="email">Success</code> class holds the value that was computed, and the <code class="email">Failure</code> class holds the exception that was thrown. As usual, <code class="email">Try</code> is an abstract class here, containing one static method to return the appropriate subclass:</p><div class="informalexample"><pre class="programlisting">public abstract class Try&lt;E&gt; {
  public abstract &lt;R&gt; Try&lt;R&gt; map(
OneArgumentExpressionWithException&lt;E, R&gt; expression);

  public abstract &lt;R&gt; Try&lt;R&gt; flatMap(
OneArgumentExpression&lt;E, Try&lt;R&gt;&gt; expression);

  public abstract E get();

  public abstract void forEach(
OneArgumentStatement&lt;E&gt; statement);

  public abstract Try&lt;E&gt; processException(
OneArgumentStatement&lt;Exception&gt; statement);
  …
  public static &lt;E&gt; Try&lt;E&gt; of(
NoArgumentExpressionWithException&lt;E&gt; expression) {
    try {
      return new Success&lt;&gt;(expression.evaluate());
    } catch (Exception ex) {
      return new Failure&lt;&gt;(ex);
    }
  }
  …
}</pre></div><p class="calibre8">We need a <a id="id201" class="calibre1"/>new <code class="email">NoArgumentExpressionWithException</code> class and <a id="id202" class="calibre1"/>a <code class="email">OneArgumentExpressionWithException</code> class that allows exceptions in its body. They are as follows:</p><div class="informalexample"><pre class="programlisting">@FunctionalInterface
public interface NoArgumentExpressionWithException&lt;R&gt; {
  R evaluate() throws Exception;
}

@FunctionalInterface
public interface OneArgumentExpressionWithException&lt;A,R&gt; {
  R compute(A a) throws Exception;
}</pre></div><p class="calibre8">The <code class="email">Success</code> class stores the value of the expression passed to the <code class="email">of()</code> method. Note that the <code class="email">of()</code> method already executes the expression to extract the value.</p><div class="informalexample"><pre class="programlisting">protected static class Success&lt;E&gt; extends Try&lt;E&gt; {
  protected E value;

  public Success(E value) {
    this.value = value;
  }</pre></div><p class="calibre8">The fact is that this is a class that represents the success of the earlier expression; the <code class="email">flatMap</code> has to only handle exceptions in the following expression, which the following <code class="email">Try</code> passed to<a id="id203" class="calibre1"/> it handles itself, so we can just return that <code class="email">Try</code> instance<a id="id204" class="calibre1"/> itself:</p><div class="informalexample"><pre class="programlisting">  @Override
  public &lt;R&gt; Try&lt;R&gt; flatMap(
    OneArgumentExpression&lt;E, Try&lt;R&gt;&gt; expression) {
      return expression.compute(value);
  }</pre></div><p class="calibre8">The <code class="email">map()</code> method, however, has to execute the expression passed. If there is an exception, it returns a <code class="email">Failure</code>; otherwise it returns a <code class="email">Success</code>:</p><div class="informalexample"><pre class="programlisting">  @Override
  public &lt;R&gt; Try&lt;R&gt; map(
    OneArgumentExpressionWithException&lt;E, R&gt; expression) {
    try {
      return new Success&lt;&gt;(
        expression.compute(value));
    } catch (Exception ex) {
      return new Failure&lt;&gt;(ex); 
    }
  }</pre></div><p class="calibre8">The <code class="email">get()</code> method returns the value as expected:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E get() {
    return value;
  }</pre></div><p class="calibre8">The <code class="email">forEach()</code> method lets you run another piece of code on the value without returning anything:</p><div class="informalexample"><pre class="programlisting">  @Override 
  public void forEach(
    OneArgumentStatement&lt;E&gt; statement) {
      statement.doSomething(value);
  }</pre></div><p class="calibre8">This method does not do anything. The same method on the <code class="email">Failure</code> class runs some code on the exception:</p><div class="informalexample"><pre class="programlisting">  @Override
  public Try&lt;E&gt; processException(
    OneArgumentStatement&lt;Exception&gt; statement) {
      return this;
  }
}</pre></div><p class="calibre8">Now, let's<a id="id205" class="calibre1"/> look at the <code class="email">Failure</code> class:</p><div class="informalexample"><pre class="programlisting">protected static class Failure&lt;E&gt; extends Try&lt;E&gt; {
  protected Exception exception;

  public Failure(Exception exception) {
    this.exception = exception;
  }</pre></div><p class="calibre8">Here, in both<a id="id206" class="calibre1"/> the <code class="email">flatMap()</code> and <code class="email">map()</code> methods, we just change the type of <code class="email">Failure</code>, but return one with the same exception:</p><div class="informalexample"><pre class="programlisting">  @Override
  public &lt;R&gt; Try&lt;R&gt; flatMap(
    OneArgumentExpression&lt;E, Try&lt;R&gt;&gt; expression) {
      return new Failure&lt;&gt;(exception);
  }

  @Override
  public &lt;R&gt; Try&lt;R&gt; map(
    OneArgumentExpressionWithException&lt;E, R&gt; expression) {
      return new Failure&lt;&gt;(exception);
  }</pre></div><p class="calibre8">There is no value to be returned in the case of a <code class="email">Failure</code>:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E get() {
    throw new NoValueException("get method invoked on Failure");
  }</pre></div><p class="calibre8">We don't do anything in the <code class="email">forEach()</code> method because there is no value to be worked on, as follows:</p><div class="informalexample"><pre class="programlisting">  @Override
  public void forEach(
    OneArgumentStatement&lt;E&gt; statement) {
    …
  }</pre></div><p class="calibre8">The following method runs some code on the exception contained in the <code class="email">Failure</code> instance:</p><div class="informalexample"><pre class="programlisting">  @Override
  public Try&lt;E&gt; processException(
    OneArgumentStatement&lt;Exception&gt; statement) {
      statement.doSomething(exception);
      return this;
  }
}</pre></div><p class="calibre8">With this<a id="id207" class="calibre1"/> implementation of the <code class="email">Try</code> monad, we can now go ahead and write <a id="id208" class="calibre1"/>some code that involves handing exceptions. The following code will print the first line of the file demo if it exists. Otherwise, it will print the exception. It will print any other exception as well:</p><div class="informalexample"><pre class="programlisting">Try.of(() -&gt; new FileInputStream("demo"))
.map((in)-&gt;new InputStreamReader(in))
.map((in)-&gt;new BufferedReader(in))
.map((in)-&gt;in.readLine())
.processException(System.err::println)
.forEach(System.out::println);</pre></div><p class="calibre8">Note how it removes the clutter in handling exceptions. You should, at this stage, be able to see what is going on. Each <code class="email">map()</code> method, as usual, transforms a value obtained earlier, only, in this case, the code in the <code class="email">map()</code> method may throw an exception and that would be gracefully contained. The first two <code class="email">map()</code> methods create a <code class="email">BufferedReader</code> in from a <code class="email">FileInputStream</code>, while the final <code class="email">map()</code> method reads a line from the <code class="email">Reader</code>.</p><p class="calibre8">With this example, I am concluding the monad section. The monadic design pattern is ubiquitous in functional programming and it's important to understand this concept. We will see a few more monads and some related ideas in the next chapter.</p></div></div>
<div class="book" title="Analysis of the complexity of a recursive algorithm"><div class="book" id="UGI02-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec25" class="calibre1"/>Analysis of the complexity of a recursive algorithm</h1></div></div></div><p class="calibre8">Throughout the chapter, I have conveniently skipped over the complexity analysis of the algorithms I have<a id="id209" class="calibre1"/> discussed. This was to ensure that you grasp the concepts of functional programming before being distracted by something else. Now is the time to get back to it.</p><p class="calibre8">Analyzing the complexity of a recursive algorithm involves first creating an equation. This is naturally the case because the function is defined in terms of itself for a smaller input, and the complexity is also expressed as a function of itself being calculated for a smaller input.</p><p class="calibre8">For example, let's<a id="id210" class="calibre1"/> say we are trying to find the complexity of the <code class="email">foldLeft</code> operation. The <code class="email">foldLeft</code> operation is actually two operations, the first one being a fixed operation on the current initial value and the head of the list, and then a <code class="email">foldLeft</code> operation on the tail. Suppose <span class="strong"><em class="calibre12">T(n)</em></span> represents the time taken to run a <code class="email">foldLeft</code> operation on a list of length <span class="strong"><em class="calibre12">n</em></span>. Now, let's assume that the fixed operation takes a time <span class="strong"><em class="calibre12">A</em></span>. Then, the definition of the <code class="email">foldLeft</code> operation suggests that <span class="strong"><em class="calibre12">T(n) = A + T(n-1)</em></span>. Now, we would try to find a function that solves this equation. In this case, it is very simple:</p><p class="calibre8">
<span class="strong"><em class="calibre12">T(n) = A + T(n-1)</em></span>
</p><p class="calibre8">
<span class="strong"><em class="calibre12">=&gt; T(n) – T(n-1) = A</em></span>
</p><p class="calibre8">This means <span class="strong"><em class="calibre12">T(n)</em></span> is an arithmetic progression and thus can be represented as <span class="strong"><em class="calibre12">T(n) = An + C</em></span>, where <span class="strong"><em class="calibre12">C</em></span> is the initial starting point, or <span class="strong"><em class="calibre12">T(0)</em></span>.</p><p class="calibre8">This means <span class="strong"><em class="calibre12">T(n) = O(n)</em></span>. We have already seen how the <code class="email">foldLeft</code> operation works in linear time. Of course, we have assumed that the the operation involved is constant with time. A more complex operation will result in a different complexity.</p><p class="calibre8">You are advised to try to compute the complexity of the other algorithms, which are not very different from this one. However, I will provide a few more of these.</p><p class="calibre8">Earlier in this chapter, we implemented the <code class="email">choose</code> function as follows:</p><div class="informalexample"><pre class="programlisting">choose(n,r) = choose(n-1,r) + choose(n-1, r-1)</pre></div><p class="calibre8">If we assume that the time taken is given by the function <code class="email">T(n,r)</code>, then <code class="email">T(n,r) = T(n-1,r) + T(n-1,r-1) + C</code>, where <code class="email">C</code> is a constant. Now we can do the following:</p><div class="informalexample"><pre class="programlisting"> T(n,r) = T(n-1,r) + T(n-1,r-1) + C
=&gt;T(n,r) -  T(n-1,r) = T(n-1,r-1) + C</pre></div><p class="calibre8">Similarly, <code class="email">T(n-1,r) - T(n-2,r) = T(n-2,r-1) + C</code>, by simply having <code class="email">n-1</code> in place of <span class="strong"><em class="calibre12">n</em></span>. By stacking such values, we have the following:</p><div class="informalexample"><pre class="programlisting">T(n,r) -  T(n-1,r) = T(n-1,r-1) + C
T(n-1,r) -  T(n-2,r) = T(n-2,r-1) + C
T(n-2,r) -  T(n-3,r) = T(n-3,r-1) + C
…
T(r+1,r) -  T(r,r) = T(r,r-1) + C</pre></div><p class="calibre8">The preceding equation considers <span class="strong"><em class="calibre12">n-r</em></span> such steps in total. If we sum both sides of the stack, we have the following:</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Analysis of the complexity of a recursive algorithm" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Of course, <span class="strong"><em class="calibre12">T(r,r)</em></span> is constant time. Let's call it <span class="strong"><em class="calibre12">B</em></span>. Hence, we have the following:</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Analysis of the complexity of a recursive algorithm" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Note that we can <a id="id211" class="calibre1"/>apply the same formula to <span class="strong"><em class="calibre12">T(i,r-1)</em></span> too. This will give us the following:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="Analysis of the complexity of a recursive algorithm" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">This gives the the following after simplification:</p><div class="mediaobject"><img src="../images/00025.jpeg" alt="Analysis of the complexity of a recursive algorithm" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">We can continue this way and we will eventually get an expression with multiple nested summations, as follows:</p><div class="mediaobject"><img src="../images/00026.jpeg" alt="Analysis of the complexity of a recursive algorithm" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Here A's and D's are also constants. When we are talking about asymptotic complexity, we need to assume that a variable is sufficiently large. In this case, there are two variables, with the condition that <span class="strong"><em class="calibre12">r</em></span> is always less than or equal to <span class="strong"><em class="calibre12">n</em></span>. So, first we consider the case <a id="id212" class="calibre1"/>where <span class="strong"><em class="calibre12">r</em></span> is fixed and <span class="strong"><em class="calibre12">n</em></span> is being increased and being made sufficiently large. In this case, there would be a total of <span class="strong"><em class="calibre12">r</em></span> summations nested in one another. <span class="strong"><em class="calibre12">T(t,0)</em></span> is a constant time. The summation has <span class="strong"><em class="calibre12">r</em></span> depth, each having a maximum of <span class="strong"><em class="calibre12">(n-r)</em></span> elements, so it is <span class="strong"><em class="calibre12">O((n-r)r)</em></span>. The other terms are <span class="strong"><em class="calibre12">O((n-r)r)</em></span>. Hence we can say the following:</p><div class="informalexample"><pre class="programlisting">T(n,r) = O((n-r)r) = O(nr)</pre></div><p class="calibre8">The size of the input is of course not <span class="strong"><em class="calibre12">n</em></span>; it is <span class="strong"><em class="calibre12">log n = u (say)</em></span>. Then, we have the complexity of computation of <span class="strong"><em class="calibre12">T(n,r) = O(2sr)</em></span>.</p><p class="calibre8">Another interesting case would be when we increase both <span class="strong"><em class="calibre12">r</em></span> and <span class="strong"><em class="calibre12">n</em></span> while also increasing the difference between them. To do that, we may want a particular ratio between the two, we assume <span class="strong"><em class="calibre12">r/n= k, k&lt;1</em></span> always. Then we can see the asymptotic growth of the function <span class="strong"><em class="calibre12">T(n, kn)</em></span>. But computing this requires calculus and is outside the scope of this book.</p><p class="calibre8">This shows that even though the analysis of algorithms in functional form can be easier, the analysis of the time complexity can be fairly difficult. It is easy to understand why it is more difficult to compute the complexity of a functional algorithm. At the end of the day, computing complexity involves counting the number of steps required to do the computation. In the imperative style, steps of computation are direct, so it is easy to count them. On the other hand, a recursive style is a higher level of abstraction, and hence, counting the number of steps is harder. In the succeeding chapters, we will see more of these analyses.</p></div>
<div class="book" title="Performance of functional programming" id="VF2I1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec26" class="calibre1"/>Performance of functional programming</h1></div></div></div><p class="calibre8">If we think<a id="id213" class="calibre1"/> about it, the whole point of functional programming is to have immutability and recursive definitions (or inductive definitions) of programs so that they can be analyzed easily. In general, adding additional constraints on your program would make it simpler to analyze but would reduce what you can do with it. Functional programming, of course, adds additional constraints on imperative programming in the form of immutability, that is, you are no longer allowed to reassign a variable. This is done so that the analysis of the program, that is, understanding how the program works, is now simpler. It is also simpler to prove theorems about the programs. However, we also lose some of the things that we could do without such restrictions. It turns out that any program can be rewritten in a functional style in a way to<a id="id214" class="calibre1"/> produce the same results. However, no guarantees are made about their performance or complexity in general. So, a functional version of a program can be a lot less efficient than its imperative counterpart. And indeed, in real life, we face many such scenarios. So, it is really a tradeoff between performance and simplicity. The general direction should then be that when working with a large input size, it is better to do away with restrictions in order to be able to optimize more. On the other hand, when the input sizes are small, it makes sense to stick to a functional style because the performance is probably not affected much by it.</p><p class="calibre8">There are some cases, though, where the functional version has the same running time complexity as the imperative version. In such a case, a functional version might be preferred because of its simplicity. It should be noted that since Java does not provide any explicit way of garbage collection and really, it happens by chance or outside the control of the programmer, a functional programming style will fill up the heap very quickly because of being immutable and thus being thrown away right after being created. So, it will not be advisable to use them where performance is really a problem.</p><p class="calibre8">This would seem really contrary to the fact that many large data processing systems, such as Spark, use a functional programming style. However, these systems only have a specialized language that gives an appearance of a functional programming style; they get translated to an almost non-functional form before they are even executed. To elaborate a little more, a map method in a monad may not evaluate anything at all; instead, it may just create a new object that contains this operator. A general program can then analyze these structures and construct an imperative program that does the same work. This provides a simple interface to the person using the framework as well as keeping the resource usage under control. In the next chapter, we will explore some of these ideas.</p></div>
<div class="book" title="Summary" id="10DJ41-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec27" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we learned a new way of looking at algorithms. The functional style of writing a program can simplify the analysis of its correctness, that is, you can easily understand why the program produces correct output. We saw a few patterns in functional programming, especially monads. We also saw how Java provides support for the functional style of programming through the syntax called lambda, which has existed from version 9 of Java. Finally, we saw how to use lambda effectively for functional programming.</p><p class="calibre8">Functional programs are, in general, easier to verify for correctness, but it is harder to compute their complexity. They generally perform either at the same speed as or slower than their imperative counterparts. It is a trade-off between development effort and computational efficiency. For smaller inputs, it is thus desirable to have a functional style of programming, whereas for processing large inputs, imperative style may be preferred.</p></div></body></html>