<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;13.&#xA0;Testing Your Applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13" class="calibre1"/>Chapter 13. Testing Your Applications</h1></div></div></div><p class="calibre8">In previous chapters, we covered the most important technologies of the Java EE platform. However, every professional developer knows that software development should begin from writing tests. At first, it does not sound easy to be able to verify the correctness of the execution of EJBs, database-related code, or, for example, REST services but it appears really straightforward when using the right tools! In this chapter, we will present the fundamental testing framework used for Java EE applications testing: the Arquillian. Additionally, we will take a look at its extensions and related libraries.</p><p class="calibre8">In this chapter, we will focus on the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An introduction to enterprise testing, from mock objects to the Arquillian framework</li><li class="listitem">How to integrate an Arquillian test case for our ticket machine application</li><li class="listitem">How to use the Eclipse IDE and Maven shell to run Arquillian tests</li><li class="listitem">The most important Arquillian extensions and how to use them</li></ul></div></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Testing Your Applications">
<div class="book" title="Test types"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch13lvl1sec59" class="calibre1"/>Test types</h1></div></div></div><p class="calibre8">The <a id="id1317" class="calibre1"/>word <span class="strong"><em class="calibre10">tests</em></span> can be interpreted in multiple ways. Most often, tests perform the validation and verification of the application requirements. Tests can be performed on multiple levels, covering single methods to whole business features. Tests can also cover nonfunctional aspects such as security or performance.</p><p class="calibre8">First, let's introduce categories of tests that validate the functional requirements. Mike Cohn has introduced a concept of the test pyramid, which is shown here:</p><div class="mediaobject"><img src="../images/00102.jpeg" alt="Test types" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">As you <a id="id1318" class="calibre1"/>can see, the majority of tests in an application are usually tests that cover units of code. A unit can be a single method, the most basic feature. Because of this<a id="id1319" class="calibre1"/> scope, these type of tests are called <span class="strong"><strong class="calibre9">unit tests</strong></span>. They can be defined as tests written by a programmer to verify that a relatively small piece of functionality is doing what it is intended to do. Because the unit is rather small, the number of these tests increases rapidly, so they become the fundament of application testing appearing on the lowest level of the pyramid.</p><p class="calibre8">The next type of tests concerns bigger areas of code. They cover whole services or business features. This means they cover multiple units of code and concern different modules and libraries. The number of such tests would be lower than the number of unit tests. This type <a id="id1320" class="calibre1"/>of test is often called an <span class="strong"><strong class="calibre9">integration test</strong></span>. Integration tests are done to demonstrate that different pieces of the system work together; since they cover entire applications, they require much more effort to be put together. For example, they usually require resources such as database instances and hardware to be allocated for them. Integration tests do a more convincing job of demonstrating how the system works (especially to nonprogrammers); at least to the extent that the integration test environment resembles the production environment.</p><p class="calibre8">The last<a id="id1321" class="calibre1"/> type of tests are UI tests, which can also be called acceptance tests. Their number is the smallest in the project; they are usually the most troublesome to write to simulate the user interacting with the application. They cover whole requirements and features.</p><p class="calibre8">Let's leave the topic of nonfunctional tests. For now, you have to only remember that they can cover topics related to performance, security, and so on.</p></div></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Testing Your Applications">
<div class="book" title="Test types">
<div class="book" title="Instruments used for testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch13lvl2sec82" class="calibre1"/>Instruments used for testing</h2></div></div></div><p class="calibre8">As you <a id="id1322" class="calibre1"/>can imagine, each kind of testing uses a<a id="id1323" class="calibre1"/> different approach and often requires different <a id="id1324" class="calibre1"/>testing libraries.</p><p class="calibre8">When you're writing unit tests, you have to just provide some method input parameters, and validate if their outcome covers the expectations. To do this in Java, you probably already use <span class="strong"><strong class="calibre9">JUnit</strong></span>, <span class="strong"><strong class="calibre9">TestNG</strong></span>, or <span class="strong"><strong class="calibre9">Spock</strong></span>. When you're moving from bigger parts of code to testing whole services, some problems may appear. It's often hard to separate the code you'd like to test, to make it testable without running all the other services. You usually create some mock objects that simulate behavior of modules you don't want to include in your test. If you have an object whose methods you want to test, and if these methods depend on another object, you can create a mock of the dependency rather than an actual instance of that dependency. This allows you to test your object in isolation.</p><p class="calibre8">As an example, one common use case might be in database applications, where you would like to test, for example, the user registration process but you don't want to run the whole database (which means that you will set its schema, some initial data, and finally clean its state manually after the test is complete). You can mock just the database interaction and define the behavior of some methods execution, for example, your stub will always return four users, which will be hardcoded in your test code.</p><p class="calibre8">This kind of approach, although very immediate to understand and put into practice, has several limitations. Firstly, it relegates you into an artificial environment, where you will often make invalid assumptions about the behavior and stability of that environment.</p><p class="calibre8">Secondly, you will end up with a hard-to-maintain mock code, which will allow your tests to pass and give you the warm feeling of having done a great job.</p><p class="calibre8">Thirdly, sometimes it's very hard to isolate a service you'd like to test, and code mocking all its interactions can be larger than the code of the meaningful tests.</p><p class="calibre8">So, even if mock objects may still provide some benefits to start systems, where you don't have full implementations of a particular subsystem, it might be good to stay as close as possible to the target environment that the code is supposed to run in. At some point, The No <a id="id1325" class="calibre1"/>Mock Movement (<span class="strong"><strong class="calibre9">Not Only Mocks Movement</strong></span>) was<a id="id1326" class="calibre1"/> launched pointing out that mocking <a id="id1327" class="calibre1"/>often takes too much time, and makes you focus on writing mocks instead of writing tests.</p><p class="calibre8"><span class="strong"><strong class="calibre9">Arquillian</strong></span><a id="id1328" class="calibre1"/> tries to solve these problems. It is a platform that simplifies integration testing for Java middleware. It deals with all the plumbing of container management, deployment, and framework initialization so that you can focus on the task of writing your tests—real tests. Arquillian minimizes the burden on you—for the developer—by covering aspects surrounding test execution; some of these aspects are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Managing the life cycle of the container (start/stop)</li><li class="listitem">Bundling the test class with the dependent classes and resources into a deployable archive</li><li class="listitem">Enhancing the test class (for example, resolving the <code class="email">@Inject</code>, <code class="email">@EJB</code>, and <code class="email">@Resource</code> injections)</li><li class="listitem">Deploying the archive to test applications (deploy/undeploy), and capturing results and failures</li></ul></div><p class="calibre8">Arquillian also has extensions that enhance its features, for example, allowing it to perform UI tests or some nonfunctional tests.</p><p class="calibre8">In the next section, we will discuss which instruments are required to run your integration tests using Arquillian.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Getting started with Arquillian"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec60" class="calibre1"/>Getting started with Arquillian</h1></div></div></div><p class="calibre8">Although<a id="id1329" class="calibre1"/> Arquillian does not depend on a specific build tool, it is commonly used with Maven; it offers dependency management and thus simplifies the task of including the Arquillian libraries in the application since they are distributed in the Central Maven repository.</p><p class="calibre8">Depending on the type of archetype you used for generation, you might have a different folder structure in your project; this is not an issue. What is really important is that you provide the following structure under your <code class="email">src</code> folder:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">main/java/</code>: Place <a id="id1330" class="calibre1"/>all application Java source files here (under the Java package)</li><li class="listitem"><code class="email">main/resources/</code>: Place<a id="id1331" class="calibre1"/> all application configuration files here</li><li class="listitem"><code class="email">test/java/</code>: Place<a id="id1332" class="calibre1"/> all test Java source files here (under the Java package)</li><li class="listitem"><code class="email">test/resources/</code>: Place <a id="id1333" class="calibre1"/>all test configuration files here (for example, <code class="email">persistence.xml</code>)</li></ul></div><p class="calibre8">So by now, we will be working under <code class="email">test/java</code>, which is where we will place our first Arquillian test class.</p></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Writing an Arquillian test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch13lvl2sec83" class="calibre1"/>Writing an Arquillian test</h2></div></div></div><p class="calibre8">If you<a id="id1334" class="calibre1"/> have been working with JUnit (<a class="calibre1" href="http://www.junit.org">http://www.junit.org</a>), you<a id="id1335" class="calibre1"/> will find a similar Arquillian test, with some extra spice in it.</p><p class="calibre8">In order to<a id="id1336" class="calibre1"/> do this, we will use Eclipse and Maven, just as we have done so far. If you are about to add test classes to your project, there is obviously no need to create a new project for this purpose. However, for learning purposes, we delivered this example in a separate project so that you can see exactly what to add in order to run Arquillian tests.</p><p class="calibre8">In order to avoid recreating the whole project from scratch, you could simply clone the <code class="email">ticket-agency-jpa</code> project and name it <code class="email">ticket-agency-test</code>, moving the root package from <code class="email">com.packtpub.wflydevelopment.chapter5</code> to <code class="email">com.packtpub.wflydevelopment.chapter13</code>. If this still seems like too much work, you could simply import the <code class="email">Chapter13</code> project from the book sample.</p></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Configuring the pom.xml file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch13lvl2sec84" class="calibre1"/>Configuring the pom.xml file</h2></div></div></div><p class="calibre8">The <a id="id1337" class="calibre1"/>first thing that is necessary to include in order to<a id="id1338" class="calibre1"/> run an Arquillian test is the <code class="email">junit</code> dependency, which is required to run our unit tests:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;version&gt;4.11&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">In earlier chapters, we introduced the term <span class="strong"><strong class="calibre9">Bill of Materials</strong></span> (<span class="strong"><strong class="calibre9">BOM</strong></span>). Now, we will use the Arquillian BOM in order to import versions of all Arquillian-related dependencies:</p><div class="informalexample"><pre class="programlisting">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.arquillian&lt;/groupId&gt;
            &lt;artifactId&gt;arquillian-bom&lt;/artifactId&gt;
            &lt;version&gt;1.1.5.Final&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</pre></div><p class="calibre8">We're using Arquillian with JUnit (like mentioned before other possibilities are <code class="email">TestNG</code>, <code class="email">Spock</code>, <code class="email">JBehave</code>, and <code class="email">Cucumber</code>) so we need to include the appropriate dependency:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.junit&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-junit-container&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">After being<a id="id1339" class="calibre1"/> done with the basic dependencies, we<a id="id1340" class="calibre1"/> now have to specify the container against which the tests will be run. Container adapters are available for the more important Java EE Application Servers (WildFly, Glassfish, WebLogic, and WebSphere), as well as for some servlet containers such as Tomcat or Jetty. Here, we want to use WildFly so we will use an appropriate container adapter. However, we have a few possible choices. Container adapters can be divided into three basic groups:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Embedded</strong></span>: This<a id="id1341" class="calibre1"/> is the mode in which a container is run on the same JVM instance the tests are running. Often, a container run in this mode is not an original one, but packed to a single JAR limited version.</li><li class="listitem"><span class="strong"><strong class="calibre9">Managed</strong></span>: In <a id="id1342" class="calibre1"/>this mode, the real application server is run on a separate JVM. As the name implies, it's possible to manage the state of the container, run it, stop it, and so on. By default, when you run the test, the server is started, tests are run against it, and then it is stopped. However, it is possible to configure Arquillian to run tests on the already running instance.</li><li class="listitem"><span class="strong"><strong class="calibre9">Remote</strong></span>: In <a id="id1343" class="calibre1"/>this mode, we just connect to some existing server instance and run tests against it.</li></ul></div><p class="calibre8">The most universal choice to run tests is the managed container. Tests are run on the real server, same as on the production environment, and additionally, it is possible to manage its state, allowing for some more advanced tests such as testing features related to high-availability or communication between two applications that run on different instances. Now, we need to add the appropriate container adapter to our <code class="email">pom.xml</code> file. To do this, we will create a Maven profile:</p><div class="informalexample"><pre class="programlisting">&lt;profile&gt;
    &lt;id&gt;arq-wildfly-managed&lt;/id&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.wildfly&lt;/groupId&gt;
            &lt;artifactId&gt;wildfly-arquillian-container-managed&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/profile&gt;</pre></div><p class="calibre8">There might<a id="id1344" class="calibre1"/> be situations in which you'd like to run<a id="id1345" class="calibre1"/> tests against different application servers. It's possible to just define a few Maven profiles and run tests a few times, each time activating other profiles. Keep in mind that some application servers don't provide all types of the adapters.</p><p class="calibre8">There is one more container-related topic. Our Arquillian tests use a protocol to communicate with the micro deployment on the application server. If we don't specify the protocol, the container will choose the default one. In order to specify it manually, we will need to add the <code class="email">org.jboss.arquillian.protocol</code> dependency (named so as it's compatible with Servlet 3.0 specifications):</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-protocol-servlet&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Writing your first Arquillian test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch13lvl2sec85" class="calibre1"/>Writing your first Arquillian test</h2></div></div></div><p class="calibre8">Once <a id="id1346" class="calibre1"/>the configuration is complete, we will finally <a id="id1347" class="calibre1"/>code our test. So, create a Java class named <code class="email">TicketTest</code> under the package <code class="email">com.packtpub.wflydevelopment.chapter13.test</code>. The first thing that you will add to this class is the following annotation that tells JUnit to use Arquillian as the test controller:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@RunWith(Arquillian.class)</strong></span>
public class TicketServiceTest {

}</pre></div><p class="calibre8">Arquillian then looks for a static method with the <code class="email">@Deployment</code> annotation; it creates a micro deployment including all the specified classes and resources (instead of deploying the whole application), allowing to test only part of the system:</p><div class="informalexample"><pre class="programlisting">@Deployment
public static Archive&lt;?&gt; createTestArchive() {
    return ShrinkWrap.create(WebArchive.class)
         addPackage(SeatType.class.getPackage())
        .addPackage(TicketService.class.getPackage())
        .addPackage(LoggerProducer.class.getPackage())
        .addAsResource("META-INF/persistence.xml")
        .addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml");
}</pre></div><p class="calibre8">The fluent <a id="id1348" class="calibre1"/>API provided by the <span class="strong"><strong class="calibre9">ShrinkWrap</strong></span> project (<a class="calibre1" href="http://www.jboss.org/shrinkwrap">http://www.jboss.org/shrinkwrap</a>) makes this technique possible using the <code class="email">create</code> method, which accepts the type of deployment unit (<code class="email">WebArchive</code>) as the argument <a id="id1349" class="calibre1"/>and all the resources are included<a id="id1350" class="calibre1"/> in this archive. In our case, instead of including all the single classes, we use the <code class="email">addPackage</code> utility method that adds all the classes that are contained in a class package (for example, by adding the <code class="email">SeatType.class.getPackage()</code> method, we will include all the classes that are in the same package as the <code class="email">SeatType</code> class). Our project uses the JPA, so we also add persistence configuration; here, we specify a path to the <code class="email">.xml</code> file, so we can point, for example, to some other test configuration using some other non-production database. And, of course, we also have to add the empty <code class="email">beans.xml</code> file in order to enable the CDI.</p><p class="calibre8">Finally, we inject the service we would like to test (yes, it's possible to inject services to test classes) and add one test method:</p><div class="informalexample"><pre class="programlisting">@Inject
TicketService ticketService;

@Test
public void shouldCreateSeatType() throws Exception {
    // given
    final SeatType seatType = new SeatType();
    seatType.setDescription("Balcony");
    seatType.setPrice(11);
    seatType.setQuantity(5);

    // when
    ticketService.createSeatType(seatType);

    // then
    assertNotNull(seatType.getId());
}</pre></div><p class="calibre8">Here, the <code class="email">shouldCreateSeatType</code> method will create a new <code class="email">SeatType</code> attribute using the <code class="email">createSeatType</code> method from the <code class="email">TicketService</code> class. Note how we inject <code class="email">TicketService</code> just as we would if we were running this code on the server side.</p><p class="calibre8">Our first test case is now ready. We will just need to add an Arquillian configuration file named <code class="email">arquillian.xml</code> in our project, under <code class="email">src/test/resources</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;arquillian 
            
            xsi:schemaLocation="http://jboss.org/schema/arquillian
        http://jboss.org/schema/arquillian/arquillian_1_0.xsd"&gt;

    &lt;container qualifier="jboss-managed" default="true"&gt;
        &lt;!-- Additional configuration --&gt;
    &lt;/container&gt;

&lt;/arquillian&gt;</pre></div><p class="calibre8">You <a id="id1351" class="calibre1"/>have to configure the container adapter. In<a id="id1352" class="calibre1"/> this example, we assume that you have set the <code class="email">JBOSS_HOME</code> environment variable to the WildFly main directory. In this case, no more configurations are required. However, if you want to run something non-standard, for example, connect to a remote container with altered management ports, then this file is the appropriate place to modify this. When you don't specify <code class="email">JBOSS_HOME</code>, you can set the WildFly location using <code class="email">property</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;container qualifier="jboss-managed" default="true"&gt;
    &lt;configuration&gt;
        &lt;property name="jbossHome"&gt;C:\wildfly&lt;/property&gt;
    &lt;/configuration&gt;
&lt;/container&gt;</pre></div><p class="calibre8">However, this method may be hard to maintain when more than one person is working on the project. In order to avoid problems, you can use the system property resolution, for instance, <code class="email">${jbossHome}</code>.</p><p class="calibre8">If you configure the remote container, the configuration would look just like this:</p><div class="informalexample"><pre class="programlisting">&lt;container qualifier="jboss-remote" default="true"&gt;
    &lt;configuration&gt;
        &lt;property name="managementAddress"&gt;localhost&lt;/property&gt;
        &lt;property name="managementPort"&gt;9999&lt;/property&gt;
    &lt;/configuration&gt;
&lt;/container&gt;</pre></div></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Running Arquillian TicketTest"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch13lvl2sec86" class="calibre1"/>Running Arquillian TicketTest</h2></div></div></div><p class="calibre8">It's <a id="id1353" class="calibre1"/>possible to<a id="id1354" class="calibre1"/> run Arquillian tests both from Maven and your IDE. You have to remember that we declared the container adapter in the Maven profile, so in order to run the full build, you have to run the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn clean package –Parquillian-wildfly-managed</strong></span>
</pre></div><p class="calibre8">If you want to run the test from Eclipse, you have to navigate to the project properties and select the <span class="strong"><strong class="calibre9">Maven</strong></span> property. In the <span class="strong"><strong class="calibre9">Active Maven Profiles</strong></span> field, enter <code class="email">arquillian-wildfly-managed</code> (as shown in the following screenshot), which we declared earlier in the <code class="email">pom.xml</code> file:</p><div class="mediaobject"><img src="../images/00103.jpeg" alt="Running Arquillian TicketTest" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Now all you have to do is right-click on your <code class="email">TicketServiceTest</code> class and select <span class="strong"><strong class="calibre9">Run As JUnit Test</strong></span>. The Arquillian engine will start, producing the outcome of the test in the JUnit view (you can make it visible by navigating to <span class="strong"><strong class="calibre9">Menu</strong></span> | <span class="strong"><strong class="calibre9">Window</strong></span> | <span class="strong"><strong class="calibre9">Show View</strong></span> | <span class="strong"><strong class="calibre9">JUnit</strong></span>).</p><p class="calibre8">Congratulations! The JUnit console accounts for the first test that was run successfully.</p><p class="calibre8">If you <a id="id1355" class="calibre1"/>want to use only one container in your test, then a good idea would be to set the default Maven profile, by adding the following lines to it in the <code class="email">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;activation&gt;
    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
&lt;/activation&gt;</pre></div></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Running Arquillian tests using Spock"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch13lvl2sec87" class="calibre1"/>Running Arquillian tests using Spock</h2></div></div></div><p class="calibre8">Arquillian<a id="id1356" class="calibre1"/> is not limited to only JUnit. As<a id="id1357" class="calibre1"/> we mentioned earlier, there are already<a id="id1358" class="calibre1"/> containers, for example, TestNG and Spock; let's focus on the second one.</p><p class="calibre8"><span class="strong"><strong class="calibre9">Spock</strong></span> is <a id="id1359" class="calibre1"/>a modern testing framework written in Groovy and uses some of the Groovy language features to make your tests more readable and easier to write. Spock's primary goal is to test the Groovy code but it is perfect to write all kinds of tests for the Java code. Spock introduces a few additional semantics with its <span class="strong"><strong class="calibre9">Domain Specific Language</strong></span> (<span class="strong"><strong class="calibre9">DSL</strong></span>) in<a id="id1360" class="calibre1"/> order to make testing even more easier and developer friendly.</p><p class="calibre8">Let's rewrite our previous test example using Spock:</p><div class="informalexample"><pre class="programlisting">@RunWith(ArquillianSputnik.class)
class TicketServiceTest extends Specification {

    @Deployment
    def static WebArchive createTestArchive() {
        return ShrinkWrap.create(WebArchive.class)
               .addPackage(SeatType.class.getPackage())
               .addPackage(TicketService.class.getPackage())
               .addPackage(LoggerProducer.class.getPackage())
               .addAsResource('META-INF/persistence.xml')
               .addAsWebInfResource(EmptyAsset.INSTANCE, 'beans.xml');
    }

    @Inject
    TicketService ticketService;


    def "should create SeatType"() {
        given:
        def seatType = new SeatType(description: "Balcony", 
                                    price: 11, quantity: 6)

        when:
        ticketService.createSeatType(seatType);

        then:
        seatType.getId() != null
    }
}</pre></div><p class="calibre8">You can notice a few differences. First of all, it's really Groovy! Secondly, the test uses a different<a id="id1361" class="calibre1"/> runner, <code class="email">ArquillianSputnik</code>. What's <a id="id1362" class="calibre1"/>more, you can <a id="id1363" class="calibre1"/>already notice some Spock DSL here, such as <a id="id1364" class="calibre1"/>the <span class="strong"><strong class="calibre9">given</strong></span>, <span class="strong"><strong class="calibre9">when</strong></span>, and <span class="strong"><strong class="calibre9">then</strong></span> constructions, which come from <span class="strong"><strong class="calibre9">behavior-driven development</strong></span> (<span class="strong"><strong class="calibre9">BDD</strong></span>). The <span class="strong"><strong class="calibre9">given</strong></span> construction<a id="id1365" class="calibre1"/> is expected to put the system in a specific state, <span class="strong"><strong class="calibre9">when</strong></span><a id="id1366" class="calibre1"/> describes an action, and <span class="strong"><strong class="calibre9">then</strong></span> contains assertions that verify <a id="id1367" class="calibre1"/>the outcome of an action performed.</p><p class="calibre8">This fully working Spock example with the complete <code class="email">pom.xml</code> configuration can be found in this chapter's example project <code class="email">named ticket-agency-spock</code>. More information <a id="id1368" class="calibre1"/>concerning the Arquillian Spock test runner, its features, and usage instructions can be found on GitHub at <a class="calibre1" href="https://github.com/arquillian/arquillian-testrunner-spock">https://github.com/arquillian/arquillian-testrunner-spock</a>. More information concerning Spock <a id="id1369" class="calibre1"/>can also be found on GitHub at <a class="calibre1" href="https://github.com/spockframework/spock">https://github.com/spockframework/spock</a>.</p></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="ShrinkWrap Resolver"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch13lvl2sec88" class="calibre1"/>ShrinkWrap Resolver</h2></div></div></div><p class="calibre8">In <a id="id1370" class="calibre1"/>almost every Arquillian test, you will probably <a id="id1371" class="calibre1"/>use ShrinkWrap to create micro deployments. After working with it for a bit, you will probably notice some shortcomings. You might be wondering what happens when you've got a test that relies on some external library; do you need to add all packages from that library? The answer is no. <span class="strong"><strong class="calibre9">ShrinkWrap Resolver</strong></span> offers integration with Maven and basic Gradle support is also available. You can just write in your test what dependency you'd like to include in the archive and it will be deployed with the micro deployment.</p><p class="calibre8">Let's look at the basic example of the ShrinkWrap Resolver Maven integration:</p><div class="informalexample"><pre class="programlisting">Maven.resolver().resolve("G:A:V").withTransitivity().asFile();</pre></div><p class="calibre8">The preceding line means that we want to resolve an artifact with the given group ID, artifact ID, and version (Maven coordinates in canonical form) from Maven's central repository with all its dependencies, and convert it to a list of files.</p><p class="calibre8">However, with this example, you have to maintain the artifact version both in the test code and build file. You can improve this! Just import some dependencies data from your <code class="email">pom.xml</code> file, so that ShrinkWrap Resolver resolves artifacts of the same versions the main project is using:</p><div class="informalexample"><pre class="programlisting">Maven.resolver().loadPomFromFile("/path/to/pom.xml").
resolve("G:A").withTransitivity().asFile();</pre></div><p class="calibre8">So now, first of all, the <code class="email">pom.xml</code> data is loaded, including all depending management sections and artifacts versions. Also, the artifact coordinates do not have to include the version.</p><p class="calibre8">These are<a id="id1372" class="calibre1"/> the most basic features. You can fully configure <a id="id1373" class="calibre1"/>the resolver manually, the repositories you want to use, Maven profiles to be applied, and much more. Let's now grab an example.</p><p class="calibre8">Let's say you're testing your project using JUnit and some fancy assertion library. <span class="strong"><strong class="calibre9">AssertJ</strong></span> (successor of <span class="strong"><strong class="calibre9">FEST</strong></span> assertions) is a fluent assertions library that allows you to write your<a id="id1374" class="calibre1"/> project in a more human-readable form:</p><div class="informalexample"><pre class="programlisting">assertThat(frodo.getName()).isEqualTo("Frodo");</pre></div><p class="calibre8">Using such a library in every test means you have to include it in every micro deployment. There is another thing you will always need: the <code class="email">beans.xml</code> file. So let's create some utility classes:</p><div class="informalexample"><pre class="programlisting">public class ArquillianWarUtils {

    private static final String BEANS_XML = "beans.xml";
    private static final String ASSERTJ_COORDINATE =
                                  "org.assertj:assertj-core";

    private static File[] ASSERTJ_ARTIFACT = Maven.resolver()
     .loadPomFromFile("pom.xml").resolve(ASSERTJ_COORDINATE)
     .withTransitivity().asFile();

    public static WebArchive getBasicWebArchive() {
        return ShrinkWrap.create(WebArchive.class)
            .addAsLibraries(ASSERTJ_ARTIFACT)
            .addAsWebInfResource(EmptyAsset.INSTANCE, BEANS_XML);
    }
}</pre></div><p class="calibre8">Also, now in each test case, you'd have just to write the following code:</p><div class="informalexample"><pre class="programlisting">    @Deployment
    public static WebArchive createDeployment() {
        return ArquillianWarUtils.getBasicWebArchive()
                    .addPackage(SomePackage.class.getPackage();
    }</pre></div><p class="calibre8">At some point, you might want to do one more thing; instead of adding all your libraries manually, you can import them on runtime dependencies:</p><div class="informalexample"><pre class="programlisting">Maven.resolver().loadPomFromFile("pom.xml")
               .importRuntimeDependencies().resolve()
               .withTransitivity().asFile();</pre></div><p class="calibre8">There are some unfortunate cases in which isolation of a part of the project for the micro deployment is not possible. You just add more and more classes to it and there is no end. This means that your project might have a poor design, but let's say you want to introduce Arquillian<a id="id1375" class="calibre1"/> in some existing legacy project and you had no<a id="id1376" class="calibre1"/> influence on its structure. In that case, you might want to import not just some classes or packages, but the whole project to your integration test. Some people do tricks; they just use the basic ShrinkWrap and import a <code class="email">.jar</code> or <code class="email">.war</code> file using the <code class="email">ZipImporter</code> ShrinkWrap:</p><div class="informalexample"><pre class="programlisting">ShrinkWrap
    .create(ZipImporter.class)
    .importFrom(new File("/target/myPackage.war"))
    .as(WebArchive.class);</pre></div><p class="calibre8">The problem is what is really in this archive? You probably import an archive created during the previous build since it is created after finishing the tests! What's more, it cannot even exist when you're just working from the IDE and not running the full Maven build! It's the place where you can use the <code class="email">MavenImporter</code> class. Refer to the following code:</p><div class="informalexample"><pre class="programlisting">ShrinkWrap.create(MavenImporter.class)
    .loadPomFromFile("/path/to/pom.xml")
    .importBuildOutput()
    .as(WebArchive.class);</pre></div><p class="calibre8">That's it! Internally, it runs the simplified build, gathering compiled classes and resources and packing it to the archive. It does not run inside the complete Maven build using some embedded instance, since that would be much too slow. You might want to add such a method to your test utilities:</p><div class="informalexample"><pre class="programlisting">public class ArquillianWarUtils {

    // already presented code

    public static WebArchive getBasicWebArchive() { . . . }
    
    public static WebArchive importBuildOutput() {
        return ShrinkWrap.create(MavenImporter.class)
                  .loadPomFromFile("pom.xml")
                  .importBuildOutput()
                  .as(WebArchive.class);
    }
}</pre></div><p class="calibre8">There exists a similar feature for the Gradle project included since ShrinkWrap Resolver 2.2.0-alpha-1. However, it uses the Gradle Tooling API internally:</p><div class="informalexample"><pre class="programlisting">ShrinkWrap.create(EmbeddedGradleImporter.class)
    .forProjectDirectory("/path/to/dir")
    .importBuildOutput()
    .as(WebArchive.class);</pre></div><p class="calibre8">At some <a id="id1377" class="calibre1"/>point, you might be surprised that this last example <a id="id1378" class="calibre1"/>did not work. The reason might be that <code class="email">arquillian-bom</code> does not include this ShrinkWrap Resolver version. However, it is possible to override the BOM imported versions with another BOM. It's pretty easy; just insert the more important BOM first:</p><div class="informalexample"><pre class="programlisting">&lt;dependencyManagement&gt;
     &lt;!-- shrinkwrap resolvers import must be before arquillian bom! --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.shrinkwrap.resolver&lt;/groupId&gt;
        &lt;artifactId&gt;shrinkwrap-resolver-bom&lt;/artifactId&gt;
        &lt;version&gt;${version.shrinkwrap-resolver}&lt;/version&gt;
        &lt;scope&gt;import&lt;/scope&gt;
        &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.shrinkwrap&lt;/groupId&gt;
        &lt;artifactId&gt;shrinkwrap-bom&lt;/artifactId&gt;
        &lt;version&gt;${version.shrinkwrap}&lt;/version&gt;
        &lt;scope&gt;import&lt;/scope&gt;
        &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
&lt;/dependencyManagement&gt;</pre></div><p class="calibre8">More info<a id="id1379" class="calibre1"/> about ShinkWrap Resolver can be found on its GitHub repository at <a class="calibre1" href="https://github.com/shrinkwrap/resolver">https://github.com/shrinkwrap/resolver</a>.</p></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="ShrinkWrap Descriptors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch13lvl2sec89" class="calibre1"/>ShrinkWrap Descriptors</h2></div></div></div><p class="calibre8">There<a id="id1380" class="calibre1"/> is one more ShrinkWrap family project. A<a id="id1381" class="calibre1"/> little less popular and not known by many people, it is called <span class="strong"><strong class="calibre9">ShrinkWrap Descriptors</strong></span>. Its goal is to provide a fluent API for the creation of descriptor resources you usually create and insert inside your micro deployments.</p><p class="calibre8">Let's start with an example. Let's say you're writing a persistence framework extension. While doing this, you use an incredible amount of <code class="email">persistence.xml</code> files such as the following code:</p><div class="informalexample"><pre class="programlisting">&lt;persistence&gt;
   &lt;persistence-unit name="myapp"&gt;
      &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" 
                  value="org.hibernate.dialect.HSQLDialect"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre></div><p class="calibre8">With ShrinkWrap Descriptors, instead of putting all these files in <code class="email">src/test/resources</code> and then referencing them from particular tests, you can just put some code in the test itself:</p><div class="informalexample"><pre class="programlisting">final PersistenceDescriptor persistence = Descriptors
  .create(PersistenceDescriptor.class)
            .createPersistenceUnit()
               .name("myapp")
               .provider("org.hibernate.ejb.HibernatePersistence")
               .jtaDataSource("java:/DefaultDS")
               .getOrCreateProperties()
                  .createProperty().name("hibernate.dialect")
                     .value("org.hibernate.dialect.HSQLDialect").up()
                  .createProperty().name("hibernate.hbm2ddl.auto")
                     .value("create-drop").up()
               .up().up()</pre></div><p class="calibre8">Such a <code class="email">PersistenceDescriptor</code> class can be exported as <code class="email">String</code> or just be added to the <code class="email">ShrinkWrap</code> archive.</p><p class="calibre8">By default, the project contains descriptors ready for all the most important <code class="email">.xml</code> of Java EE platform. However, it also allows for code generation using XSD and DTD files. Be cautious, it's still in alpha stage. It is stable, but the API might already be changed.</p></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Persistence testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch13lvl2sec90" class="calibre1"/>Persistence testing</h2></div></div></div><p class="calibre8">Real <a id="id1382" class="calibre1"/>challenges start when you have to include <a id="id1383" class="calibre1"/>other systems in your testing process. Troubles might be caused even by the necessity of testing interactions with a relational database. In <a class="calibre1" title="Chapter 5. Combining Persistence with CDI" href="part0030_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre10">Combining Persistence with CDI</em></span>, we introduced the JPA. Now it's time to describe how you can test your interactions with it.</p><p class="calibre8">There are a few issues that have to be considered when testing database-related code:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How to verify that data was really inserted to the database?</li><li class="listitem">How to maintain the database state between tests and how to automatically clean it?</li></ul></div><p class="calibre8">Arquillian persistence extension allows you to test both these things. Before running a test, you can seed your database from <code class="email">.xml</code>, <code class="email">.xls</code>, <code class="email">.yaml</code>, <code class="email">.json</code>, or custom SQL scripts. It's done by just annotating the test case using the <code class="email">@UsingDataSet("path-to-seeding-file")</code> annotation. After the test execution, you can compare the database state against another file, this time using the <code class="email">@ShouldMatchDataSet("path-to-dataset")</code> annotation. Let's look at an example:</p><div class="informalexample"><pre class="programlisting">@Test
@UsingDataSet("datasets/seats.yml")
@ShouldMatchDataSet("datasets/expected-seats.yml")
public void shouldMakeACleanup() throws Exception {
    // given
    // from annotation

    // when
    ticketService.doCleanUp();

    // then
    // from annotation
}</pre></div><p class="calibre8">The <code class="email">seats.yml</code> and <code class="email">expected-seats.xml</code> files are just simple YAMLs placed in <code class="email">/src/test/resources/datasets</code>. The first file contains <code class="email">SeatType</code>:</p><div class="informalexample"><pre class="programlisting">Seat_Type:
  - description: test
    position: "box"
    price: 10
    quantity: 10</pre></div><p class="calibre8">The second file contains:</p><div class="informalexample"><pre class="programlisting">Seat_Type:</pre></div><p class="calibre8">Since we're executing a cleanup. Note that the names and values used here are the SQL names, not the JPA names.</p><p class="calibre8">JPA allows you to use a second-level cache in order to improve the operations performance. With this, not all of the operations are instantly reflected on the database state. During the tests running, you might be interested in the <code class="email">@JpaCacheEviction</code> annotation, which makes a cache to evict after every test run. Each test is also wrapped in a separate transaction so that it won't influence the execution of other tests</p><p class="calibre8">Of course, there are some dependencies you need to make this extension work. There are exactly three of them as follows:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.extension&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-persistence-dbunit&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.Alpha7&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">Arquillian <a id="id1384" class="calibre1"/>in 1.1.4.Final version has a bug that passes all <a id="id1385" class="calibre1"/>persistence tests even when they should not. The 1.1.5.Final version works correctly.</p><p class="calibre8">A fully configured example project for this chapter is named <code class="email">ticket-agency-test-ape</code>.</p><p class="calibre8">The <a id="id1386" class="calibre1"/>Arquillian Persistence Extension manual is available on GitHub at <a class="calibre1" href="https://github.com/arquillian/arquillian-extension-persistence">https://github.com/arquillian/arquillian-extension-persistence</a>.</p></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Arquillian Warp"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch13lvl2sec91" class="calibre1"/>Arquillian Warp</h2></div></div></div><p class="calibre8">The last<a id="id1387" class="calibre1"/> Arquillian extension that we will discuss here is <span class="strong"><strong class="calibre9">Warp</strong></span>. Authors say that it allows you to write client-side tests that assert server-side logic. To be more descriptive, it allows for execution of client side requests, and then to execute server side tests. This fills the gap between client-side and server-side testing.</p><p class="calibre8">In order to fully understand the Warp, we have to introduce the <code class="email">@RunAsClient</code> annotation. It can be placed on a test class or test method and it mentions that tests will be executed on the client side and not on the server side. The second important annotation is <code class="email">@Deployment</code>, which you have already met on method creating the archives. However, it can take some parameters that are Boolean value testable. If a testable is <code class="email">false</code>, it is also executes on the client side, not repacking the deployment and so on. However, Warp mixes these two modes and requires <code class="email">@Deployment(testable=true)</code> and <code class="email">@RunAsClient</code> annotations. The test class has to be annotated additionally with <code class="email">@WarpTest</code>:</p><div class="informalexample"><pre class="programlisting">@RunWith(Arquillian.class)
@WarpTest
@RunAsClient
public class BasicWarpTest {

    @Deployment(testable = true)
    public static WebArchive createDeployment() {
       ...
    }

    @Test
    public void test() {
        // Warp test
    }
}</pre></div><p class="calibre8">Every <a id="id1388" class="calibre1"/>Warp test uses the following construction:</p><div class="informalexample"><pre class="programlisting">Warp
    .initiate(Activity)
    .inspect(Inspection);</pre></div><p class="calibre8">An activity is the client part that makes the requests. Inspection is a server-side assertion. It's also possible to filter some requests by additional specification of the Observer:</p><div class="informalexample"><pre class="programlisting">Warp
    .initiate(Activity)
    .observer(Observer)
    .inspect(Inspection);</pre></div><p class="calibre8">An Observer can, for example, filter HTTP addresses.</p><p class="calibre8">Let's take a look at something more concrete. Arquillian Warp also has some extensions. Currently, all of them are HTTP oriented; however, it is possible to extend Warp to cover non-HTTP use cases. The extensions add some special classes for testing:</p><div class="book"><ul class="itemizedlist"><li class="listitem">JSF</li><li class="listitem">JAX-RS</li><li class="listitem">Spring MVC</li></ul></div><p class="calibre8">Now we're going to look at the JAX-RS part. To do this, we will use the code from <a class="calibre1" title="Chapter 7. Adding Web Services to Your Applications" href="part0038_split_000.html#page">Chapter 7</a>, <span class="strong"><em class="calibre10">Adding Web Services to Your Applications</em></span>. We want to test our REST service. First of all, we need to add all the standard Arquillian-related dependencies and the <code class="email">arquillian.xml</code> file. For the Warp itself, we will need the following dependency:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.extension&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-warp&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.Alpha7&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">For the JAX-RS extension, we will need the following dependency:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.arquillian.extension&lt;/groupId&gt;
    &lt;artifactId&gt;arquillian-rest-warp-impl-jaxrs-2.0&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.Alpha2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">Additionally, we<a id="id1389" class="calibre1"/> will use the JAX-RS client:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
    &lt;version&gt;3.0.9.Final&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">Our test will look like this:</p><div class="informalexample"><pre class="programlisting">@RunWith(Arquillian.class)
@WarpTest
@RunAsClient
public class SeatsResourceTest {

    @Deployment(testable = true)
    public static WebArchive deployment() {
        return ShrinkWrap.create(MavenImporter.class)
                         .loadPomFromFile("pom.xml")
                         .importBuildOutput()
                         .as(WebArchive.class);
    }

    @ArquillianResource
<span class="strong"><strong class="calibre9">    private URL contextPath;            // [1]</strong></span>

    private ResteasyWebTarget target;

    @Before
    public void setUp() {
        final ResteasyClient client = 
                   new ResteasyClientBuilder().build();
        this.target = client.target(contextPath + "rest/seat");
    }

    @Test
    public void testasd() {
        Warp.initiate(new Activity() {
            @Override
            public void perform() {
                final String response = target
                 .request(MediaType.APPLICATION_JSON_TYPE)
<span class="strong"><strong class="calibre9">                 .get(String.class);  // [2]</strong></span>
<span class="strong"><strong class="calibre9">                assertNotNull(response);              // [3]</strong></span>
            }
        }).inspect(new Inspection() {

            private static final long serialVersionUID = 1L;

            @ArquillianResource
            private RestContext restContext;

            @AfterServlet
            public void testGetSeats() {
                assertEquals(200, restContext.getHttpResponse().getStatusCode());
                assertEquals(MediaType.APPLICATION_JSON, restContext.getHttpResponse().getContentType());
<span class="strong"><strong class="calibre9">                assertNotNull(restContext.getHttpResponse().getEntity());  // [4]</strong></span>
            }
        });
    }
}</pre></div><p class="calibre8">First of all, you<a id="id1390" class="calibre1"/> can see all the annotations mentioned earlier. We use the <code class="email">ShrinkWrap Resolver MavenImporter</code> class here to get the whole project in the deployment. The <code class="email">[1]</code> object is the injection of the application URL. In <code class="email">[2]</code>, we execute a client request to get the seats and in <code class="email">[3]</code>, we do some basic client-side assertion. In <code class="email">[4]</code>, we test the server side, to check if the appropriate HTTP code was returned and so on. In more complex scenarios, we can execute some beans logic to confirm that the appropriate state change was performed on the server side. This last thing distinguishes the Arquillian Warp from running tests in the client mode (a <code class="email">@RunAsClient</code> annotation) and <a id="id1391" class="calibre1"/>doing assertions with <code class="email">ResteasyWebTarget</code>.</p><p class="calibre8">Some <a id="id1392" class="calibre1"/>more information concerning this extension can be found at <a class="calibre1" href="https://github.com/arquillian/arquillian-extension-warp">https://github.com/arquillian/arquillian-extension-warp</a>.</p></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="WebSockets testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_10"><a id="ch13lvl2sec92" class="calibre1"/>WebSockets testing</h2></div></div></div><p class="calibre8">We <a id="id1393" class="calibre1"/>introduced the topic of WebSockets in the earlier <a id="id1394" class="calibre1"/>chapters. Now let's see how we can test them. To do this in plain Java, we <a id="id1395" class="calibre1"/>will need a WebSocket client implementation; be sure to add <span class="strong"><strong class="calibre9">Tyrus</strong></span> to your <code class="email">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.tyrus.bundles&lt;/groupId&gt;
    &lt;artifactId&gt;tyrus-standalone-client&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;version&gt;1.8.3&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">For this example, we will use Tyrus as a base code from <a class="calibre1" title="Chapter 8. Adding WebSockets" href="part0042_split_000.html#page">Chapter 8</a>, <span class="strong"><em class="calibre10">Adding WebSockets</em></span>. Our test realizes a simple scenario. Using the REST API, we reserve a seat, and as a WebSocket client, we wait for a message broadcasting information concerning new reservations. Let's look at the code:</p><div class="informalexample"><pre class="programlisting">@RunAsClient
@RunWith(Arquillian.class)
public class TicketServiceTest {

    private static final String WEBSOCKET_URL = "ws://localhost:8080/ticket-agency-test-websockets/tickets";
    private static final String SEAT_RESOURCE_URL = "http://localhost:8080/ticket-agency-test-websockets/rest/seat";

    @Deployment
<span class="strong"><strong class="calibre9">    public static Archive&lt;?&gt; createTestArchive() { // [1]</strong></span>
        return ShrinkWrap.create(MavenImporter.class).loadPomFromFile("pom.xml").importBuildOutput()
            .as(WebArchive.class);
    }

    @Test
    public void shouldReceiveMessageOnBooking() throws Exception {
        // given
        final int seatNumber = 4;
<span class="strong"><strong class="calibre9">        final Deque&lt;JsonObject&gt; messages = new ConcurrentLinkedDeque&lt;&gt;(); // [2]</strong></span>
<span class="strong"><strong class="calibre9">        final CountDownLatch messageLatch =new CountDownLatch(1); // [3]</strong></span>
<span class="strong"><strong class="calibre9">        final MessageHandler.Whole&lt;String&gt; handler = // [4]</strong></span>
          new MessageHandler.Whole&lt;String&gt;() {
            @Override
<span class="strong"><strong class="calibre9">            public void onMessage(String message) {</strong></span>
                messages.add(Json
                 .createReader(new StringReader(message))
                 .readObject());
                messageLatch.countDown();
            }
        };

<span class="strong"><strong class="calibre9">        ContainerProvider.getWebSocketContainer()  // [5]</strong></span>
                         .connectToServer(new Endpoint() {
            @Override
<span class="strong"><strong class="calibre9">            public void onOpen(Session session, </strong></span>
<span class="strong"><strong class="calibre9">                               EndpointConfig endpointConfig) {</strong></span>
                session.addMessageHandler(handler);
            }
        }, new URI(WEBSOCKET_URL));

        // when
<span class="strong"><strong class="calibre9">        RestAssured.when()</strong></span>
<span class="strong"><strong class="calibre9">                  .post(SEAT_RESOURCE_URL + "/" + seatNumber)</strong></span>
<span class="strong"><strong class="calibre9">                  .then().statusCode(200); // [6]</strong></span>
<span class="strong"><strong class="calibre9">        messageLatch.await(10, TimeUnit.SECONDS); // [7]</strong></span>

<span class="strong"><strong class="calibre9">        // then [8]</strong></span>
        assertThat(messages.size(), equalTo(1));
        final JsonObject message = messages.poll();
        assertThat(message.getInt("id"), equalTo(seatNumber));
    }
}</pre></div><p class="calibre8">The test is<a id="id1396" class="calibre1"/> run as described in this chapter's client mode and <a id="id1397" class="calibre1"/>uses Tyrus: the WebSocket client reference implementation under the hood. The perfect deployment for this test is our whole application, so we are going to use <code class="email">MavenImporter [1]</code>. In the test, we declared a concurrent deque to gather a received messaged <code class="email">[2]</code> and a latch <code class="email">[3]</code>, which we will use to wait in <code class="email">[7]</code>. In order to handle WebSockets on the client side, we have to declare a handler <code class="email">[4]</code>, which specifies the behavior on receiving the message. Here, we just add a message to our deque and perform a latch countdown. In <code class="email">[5]</code>, we have to register the handler so that it will be used for an open session. The REST call is executed using a rest-assured library, which provides a fluent API to test REST APIs. Finally, in <code class="email">[8]</code>, we perform some basic assertions concerning the received messages.</p><p class="calibre8">The fully configured <code class="email">pom.xml</code> file and a whole working project can be found under <code class="email">ticket-agency-test-websockets</code>.</p></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Enhancing your Arquillian test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_11"><a id="ch13lvl2sec93" class="calibre1"/>Enhancing your Arquillian test</h2></div></div></div><p class="calibre8">You <a id="id1398" class="calibre1"/>might have noticed that we, on purpose, created just a part <a id="id1399" class="calibre1"/>of the integration tests we needed. We did not reach the last mile, that is, creating seats and reserving one. As a matter of fact, if you remember, our ticket application uses <code class="email">ConversationScope</code> to track the user's navigation. Thus, we need to bind <code class="email">ConversationScope</code> into our test as well.</p><p class="calibre8">Luckily, the <code class="email">Weld</code> container provides all that you need with <code class="email">org.jboss.weld.context.bound.BoundConversationContext</code>, which needs to be injected into your test class:</p><div class="informalexample"><pre class="programlisting">@Inject BoundConversationContext conversationContext;
  
@Before
public void init() {
      conversationContext.associate(
      new MutableBoundRequest(new HashMap&lt;String, Object&gt;(),
                              new HashMap&lt;String, Object&gt;()));
      conversationContext.activate();
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note74" class="calibre1"/>Note</h3><p class="calibre8">Note that the <code class="email">@Before</code> annotation is invoked before each test method and after injections have occurred. In our case, it is used to associate <code class="email">conversationContext</code> with <code class="email">MutableBoundRequest</code> before being activated by <code class="email">conversationContext.activate</code>. This is needed to mimic the conversation behavior from within the Arquillian test bed.</p><p class="calibre8">Just for completeness, you must be aware that <code class="email">BoundRequest</code> interfaces are defined in the Weld API to hold a conversation that spans multiple requests, but are shorter than a session.</p></div><p class="calibre8">So here's the full <code class="email">TicketTest</code> class, which contains a theatre creation and booking seat reservation in the <code class="email">testTicketAgency</code> method:</p><div class="informalexample"><pre class="programlisting">@RunWith(Arquillian.class)
public class TicketTest {

    @Inject BoundConversationContext conversationContext;

    @Before
    public void init() {
        conversationContext.associate(
        new MutableBoundRequest(new HashMap&lt;String, Object&gt;(),
            new HashMap&lt;String, Object&gt;()));
        conversationContext.activate();
    }

    @Deployment
    public static Archive&lt;?&gt; createTestArchive() {
        return ShrinkWrap.create(WebArchive.class, "ticket.war")
           .addPackage(SeatProducer.class.getPackage())
           .addPackage(Seat.class.getPackage())
           .addPackage(TicketService.class.getPackage())
           .addPackage(DataManager.class.getPackage())
           .addAsResource("META-INF/persistence.xml")
           .addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject
    TicketService ticketService;

    @Inject
    BookerService bookerService;

    @Inject
    Logger log;

    @Test
    public void testTicketAgency () throws Exception {

        SeatType seatType = new SeatType();
        seatType.setDescription("Balcony");
        seatType.setPrice(20);
        seatType.setQuantity(5);

        ticketService.createSeatType(seatType);
        log.info("Created Seat Type");
        assertNotNull(seatType.getId());

        List&lt;SeatType&gt; listSeats = new ArrayList();
        listSeats.add(seatType);
        ticketService.createTheatre(listSeats);

        log.info("Created Theatre");
        log.info(seatType.getDescription() + " was persisted with id " + seatType.getId());

        bookerService.bookSeat(new Long(seatType.getId()), seatType.getPrice());
        log.info("Created Theatre");
        log.info("Money left: " +bookerService.getMoney());
        assertTrue(bookerService.getMoney() &lt;100); 
    }
}</pre></div></div></div>

<div class="book" title="Getting started with Arquillian">
<div class="book" title="Additional information"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_12"><a id="ch13lvl2sec94" class="calibre1"/>Additional information</h2></div></div></div><p class="calibre8">The Arquillian project is an evolving framework with many other interesting topics. Describing all its extensions, however, is out of the scope of this book. However, the other interesting<a id="id1400" class="calibre1"/> areas to look into are <span class="strong"><strong class="calibre9">Drone</strong></span> and <span class="strong"><strong class="calibre9">Graphene</strong></span>, which bring<a id="id1401" class="calibre1"/> the <a id="id1402" class="calibre1"/>
<span class="strong"><strong class="calibre9">WebDriver</strong></span> and <span class="strong"><strong class="calibre9">Page Object</strong></span> patterns<a id="id1403" class="calibre1"/> to Arquillian testing.</p><p class="calibre8">At some point, you may find yourself creating separate deployment methods in each test case. You<a id="id1404" class="calibre1"/> can change this behavior by the usage of <span class="strong"><strong class="calibre9">Arquillian Suite Extension</strong></span>, which allows specifying a deployment for a set of test cases.</p><p class="calibre8">Arquillian is <a id="id1405" class="calibre1"/>fully open source, so you can learn more about it from the online documentation that is available at <a class="calibre1" href="http://arquillian.org/">http://arquillian.org/</a>. When you need some help, or you have an awesome idea for a new feature, you can contact the Arquillian <a id="id1406" class="calibre1"/>community on forums or IRC (<a class="calibre1" href="http://arquillian.org/community/">http://arquillian.org/community/</a>). Remember that if you find a bug, don't complain; just <a id="id1407" class="calibre1"/>file an issue on JBoss JIRA at <a class="calibre1" href="https://issues.jboss.org">https://issues.jboss.org</a>.</p><p class="calibre8">One of the Arquillian contributors John D. Ament has already published a book on this topic called <span class="strong"><em class="calibre10">Arquillian Testing Guide</em></span>, <span class="strong"><em class="calibre10">Packt Publishing</em></span>.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec61" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we went through a critical part of enterprise systems: integration testing. Historically, one main downside of Java EE is its testability, but Arquillian has really solved this issue to a great extent.</p><p class="calibre8">Used as an extension to the JUnit framework, Arquillian excels in checking the integration layer that exposes the business logic in an enterprise Java application.</p><p class="calibre8">Arquillian hooks into your testing framework to manage the container's life cycle. It also bundles the <code class="email">test</code> class into a deployable archive with dependent classes and resources.</p><p class="calibre8">This is the last chapter covering basic Java EE and WildFly features. We started with a few session beans, and ended up with web sockets, an asynchronous messaging system, RESTful API, and even a little bit of JavaScript. During the course of this book, we saw how the newest edition of Java EE provided us with tools to create modern and scalable applications. The platform's goal is to help the developer to focus on the business logic. This means removing the boilerplate code through the whole application stack from the backend to the view layer. In most areas, we only covered the most important features of the multiple technologies provided by Java EE. There is still plenty to explore!</p><p class="calibre8">In the appendix, we will learn a few things about the JBoss Forge tool, which can greatly increase the productivity when working with Java EE.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Appendix&#xA0;A.&#xA0;Rapid Development Using JBoss Forge"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="appA" class="calibre1"/>Appendix A. Rapid Development Using JBoss Forge</h1></div></div></div><p class="calibre8">In the appendix of this book, we will give you an overview of JBoss Forge, which is a powerful, rapid application development (aimed at Java EE ) and project comprehension tool. With Forge, you can start a new project from scratch and generate the skeleton for your application just with a few commands. However, it can also be used for incremental enhancements for your existing projects using extra plugins.</p></div>

<div class="book" title="Appendix&#xA0;A.&#xA0;Rapid Development Using JBoss Forge">
<div class="book" title="Installing Forge"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch13lvl1sec62" class="calibre1"/>Installing Forge</h1></div></div></div><p class="calibre8">In order to install Forge, you<a id="id1408" class="calibre1"/> need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Download and unzip <a id="id1409" class="calibre1"/>Forge from <a class="calibre1" href="http://forge.jboss.org/">http://forge.jboss.org/</a> into a folder on your hard disk; this folder will be your <code class="email">FORGE_HOME</code>.</li><li class="listitem" value="2">Add <code class="email">FORGE_HOME/bin</code> to your path (Windows, Linux, and Mac OS X).</li></ol><div class="calibre16"/></div><p class="calibre8">In Unix-based operating systems, this typically means editing your <code class="email">~/.bashrc</code> or <code class="email">~/</code>.profile; you will need to enter the following code snippet:</p><div class="informalexample"><pre class="programlisting">export FORGE_HOME=~/forge/
export PATH=$PATH:$FORGE_HOME/bin</pre></div><p class="calibre8">In Windows systems, you will need to open the <span class="strong"><strong class="calibre9">Control Panel</strong></span> window, then navigate to <span class="strong"><strong class="calibre9">System Properties</strong></span> | <span class="strong"><strong class="calibre9">Advanced</strong></span> | <span class="strong"><strong class="calibre9">Environment Variables</strong></span>, and add these two entries visually. It is recommended to set user variables for Forge, unless you have placed the unzipped distribution in a folder where all users can access it.</p><p class="calibre8">In case of any problem, check out the online installation guide available at <a class="calibre1" href="http://forge.jboss.org/document/installation">http://forge.jboss.org/document/installation</a>.</p></div></div>
<div class="book" title="Starting Forge"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec63" class="calibre1"/>Starting Forge</h1></div></div></div><p class="calibre8">In order to<a id="id1410" class="calibre1"/> start Forge, there is a script named <code class="email">forge.bat</code> (or the equivalent Forge for Unix). Run the following script:</p><div class="informalexample"><pre class="programlisting">forge.bat</pre></div><p class="calibre8">This will launch the Forge console, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00104.jpeg" alt="Starting Forge" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The console accepts<a id="id1411" class="calibre1"/> a large set of commands, such as commands to navigate and manipulate the filesystems, to create new projects, to operate on the Forge environment and UI generation, and scaffolding commands. It also offers the autocomplete feature.</p><p class="calibre8">In order to learn the following available commands in current context, press the <span class="strong"><em class="calibre10">Tab</em></span> key twice:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[bin]$</strong></span>
<span class="strong"><strong class="calibre9">alias                                   echo</strong></span>
<span class="strong"><strong class="calibre9">unalias                                 edit</strong></span>
<span class="strong"><strong class="calibre9">export                                  exit</strong></span>
<span class="strong"><strong class="calibre9">about                                   git-clone</strong></span>
<span class="strong"><strong class="calibre9">addon-build-and-install                 grep</strong></span>
<span class="strong"><strong class="calibre9">addon-install                           less</strong></span>
<span class="strong"><strong class="calibre9">addon-install-from-git                  ls</strong></span>
<span class="strong"><strong class="calibre9">addon-list                              man</strong></span>
<span class="strong"><strong class="calibre9">addon-remove                            mkdir</strong></span>
<span class="strong"><strong class="calibre9">archetype-add                           more</strong></span>
<span class="strong"><strong class="calibre9">archetype-list                          open</strong></span>
<span class="strong"><strong class="calibre9">archetype-remove                        pl-cmil-forge-ecore-ui</strong></span>
<span class="strong"><strong class="calibre9">cat                                     project-new</strong></span>
<span class="strong"><strong class="calibre9">cd                                      pwd</strong></span>
<span class="strong"><strong class="calibre9">clear                                   rm</strong></span>
<span class="strong"><strong class="calibre9">command-list                            run</strong></span>
<span class="strong"><strong class="calibre9">config-clear                            system-property-get</strong></span>
<span class="strong"><strong class="calibre9">config-list                             system-property-set</strong></span>
<span class="strong"><strong class="calibre9">config-set                              touch</strong></span>
<span class="strong"><strong class="calibre9">connection-create-profile               track-changes</strong></span>
<span class="strong"><strong class="calibre9">connection-remove-profile               transaction-start</strong></span>
<span class="strong"><strong class="calibre9">cp                                      version</strong></span>
<span class="strong"><strong class="calibre9">date                                    wait</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note75" class="calibre1"/>Note</h3><p class="calibre8">Besides the standard commands, it is possible to enrich the syntax of the Forge command line with add-ons, which adds superior capabilities to your project creation. On <a class="calibre1" href="http://forge.jboss.org/addons">http://forge.jboss.org/addons</a>, you can find a list of available plugins. For example, we are<a id="id1412" class="calibre1"/> going to use the <code class="email">angular-js</code> plugin<a id="id1413" class="calibre1"/> in order to create a GUI for our application.</p></div><p class="calibre8">In the following section, we<a id="id1414" class="calibre1"/> will demonstrate how to use some of the available commands in order to create a Java EE 7 application.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating your first Java EE 7 application with JBoss Forge"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec64" class="calibre1"/>Creating your first Java EE 7 application with JBoss Forge</h1></div></div></div><p class="calibre8">So, Forge installation is<a id="id1415" class="calibre1"/> quite easy; however, creating your first Java EE 7 application will be even faster! Although, we can create rather advanced applications with Forge, for the purpose of learning, we<a id="id1416" class="calibre1"/> will just use a simple schema that contains a user table, which can be built using the following command:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE users (
  id serial PRIMARY KEY,
  name varchar(50),
  surname varchar(50),
  email varchar(50)
);</pre></div><p class="calibre8">The first thing that we need to do is to create a new project using the <code class="email">project-new</code> command. Execute the following commands from within the <code class="email">Forge</code> shell:</p><div class="informalexample"><pre class="programlisting">[bin]$ project-new --named forge-demo --topLevelPackage com.packtpub.wflydevelopment.appendix –projectFolder forge-demo</pre></div><p class="calibre8">Now, you have a new Forge project, which is based on a Maven project structure. Arguably, generating a new project isn't Forge's greatest value—the same can be achieved with Maven archetypes. The sweet part of Forge is that now you have the luxury of defining your own application skeleton interactively after it has already been generated. This means that you can create the project using the Maven archetype first and then extend it using Forge's intuitive suggestions.</p><p class="calibre8">When the project is created, you can then enter command-list from the shell, as shown in the following screenshot, which enlists all the basic commands that you can use in Forge 2.12.1 Final:</p><div class="mediaobject"><img src="../images/00105.jpeg" alt="Creating your first Java EE 7 application with JBoss Forge" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If you want to learn <a id="id1417" class="calibre1"/>more about the single commands, you <a id="id1418" class="calibre1"/>can use <code class="email">man</code> followed by the command name, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00106.jpeg" alt="Creating your first Java EE 7 application with JBoss Forge" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">When you have learned how to get help using Forge, let's get back to our application.</p><p class="calibre8">In the first step, we need to specify what Java and Java EE version we want to use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[forge-demo]$ project-set-compiler-version --sourceVersion 1.8 --targetVersion 1.8</strong></span>
<span class="strong"><strong class="calibre9">[forge-demo]$ javaee-setup --javaEEVersion 7</strong></span>
<span class="strong"><strong class="calibre9">***SUCCESS*** JavaEE 7 has been installed.</strong></span>
</pre></div><p class="calibre8">At this point, our <a id="id1419" class="calibre1"/>project already contains Java EE 7 API dependency. Now, since we will need to reverse-engineer our database table into Java entities, the next <a id="id1420" class="calibre1"/>step will be to configure the <a id="id1421" class="calibre1"/>
<span class="strong"><strong class="calibre9">Java Persistence API</strong></span> (<span class="strong"><strong class="calibre9">JPA</strong></span>) layer for your application. This application will be based on WildFly JPA implementation, which is based on the Hibernate provider, referencing a database named Forge. This database is reachable at the<a id="id1422" class="calibre1"/> <span class="strong"><strong class="calibre9">Java Naming and Directory Interface</strong></span> (<span class="strong"><strong class="calibre9">JNDI</strong></span>) named <code class="email">java:jboss/datasources/PostgreSqlDS</code>. This is shown in the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[forge-demo]$ jpa-setup --jpaVersion 2.1 --provider HIBERNATE --container WILDFLY --dbType POSTGRES  --dataSourceName java:jboss/datasources/PostgreSqlDS</strong></span>
</pre></div><p class="calibre8">The <code class="email">persistence.xml</code> file was generated, and currently the console indicates that we are editing it. We can check its content by using the <code class="email">cat</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[persistence.xml]$ cat .</strong></span>
<span class="strong"><strong class="calibre9">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</strong></span>
<span class="strong"><strong class="calibre9">&lt;persistence  xmlns:xsi="http://w</strong></span>
<span class="strong"><strong class="calibre9">ww.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemaLocation="http://xmln</strong></span>
<span class="strong"><strong class="calibre9">s.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence</strong></span>
<span class="strong"><strong class="calibre9">_2_1.xsd"&gt;</strong></span>
<span class="strong"><strong class="calibre9">  &lt;persistence-unit name="forge-demo-persistence-unit" transaction-type="JTA"&gt;</strong></span>
<span class="strong"><strong class="calibre9">    &lt;description&gt;Forge Persistence Unit&lt;/description&gt;</strong></span>
<span class="strong"><strong class="calibre9">    &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;</strong></span>
<span class="strong"><strong class="calibre9">    &lt;jta-data-source&gt;java:jboss/datasources/PostgreSqlDS&lt;/jta-data-source&gt;</strong></span>
<span class="strong"><strong class="calibre9">    &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;</strong></span>
<span class="strong"><strong class="calibre9">    &lt;properties&gt;</strong></span>
<span class="strong"><strong class="calibre9">      &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">      &lt;property name="hibernate.show_sql" value="true"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">      &lt;property name="hibernate.format_sql" value="true"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">      &lt;property name="hibernate.transaction.flush_before_completion" value="true</strong></span>
<span class="strong"><strong class="calibre9">"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">      &lt;property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQL</strong></span>
<span class="strong"><strong class="calibre9">Dialect"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">    &lt;/properties&gt;</strong></span>
<span class="strong"><strong class="calibre9">  &lt;/persistence-unit&gt;</strong></span>
<span class="strong"><strong class="calibre9">&lt;/persistence&gt;</strong></span>
</pre></div><p class="calibre8">Next, we will use the <code class="email">jpa-generate-entities-from-tables</code> command in order to generate your <code class="email">Entity</code> class. You will need to provide the<a id="id1423" class="calibre1"/> following <span class="strong"><strong class="calibre9">Java Database Connectivity</strong></span> (<span class="strong"><strong class="calibre9">JDBC)</strong></span> connection information:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The JDBC URL</li><li class="listitem">The username and password</li><li class="listitem">The SQL dialect</li><li class="listitem">The JDBC driver class name</li><li class="listitem">The path in the filesystem where the JDBC driver is located</li><li class="listitem">The package where the entities will be generated</li></ul></div><p class="calibre8">You can specify all the parameters<a id="id1424" class="calibre1"/> in a one-line command or<a id="id1425" class="calibre1"/> complete it interactively. The final command would look like this (line breaks added for readability):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[persistence.xml]$ jpa-generate-entities-from-tables  \</strong></span>
<span class="strong"><strong class="calibre9">--jdbcUrl jdbc:postgresql://localhost:5432/forge \</strong></span>
<span class="strong"><strong class="calibre9">--hibernateDialect org.hibernate.dialect.PostgreSQLDialect \</strong></span>
<span class="strong"><strong class="calibre9">--userName jboss \</strong></span>
<span class="strong"><strong class="calibre9">--userPassword jboss \</strong></span>
<span class="strong"><strong class="calibre9">--driverLocation c:\\forge\\postgresql-9.3-1101.jdbc41.jar \</strong></span>
<span class="strong"><strong class="calibre9">--driverClass org.postgresql.Driver \</strong></span>
<span class="strong"><strong class="calibre9">--databaseTables users </strong></span>
</pre></div><p class="calibre8">After completing the persistence layer, we will now create the GUI application using the <code class="email">scaffold</code> command, which can be associated with several providers such as the AngularJS one. First, let's install the add-on using the following shell command (note that it should be executed in your system's shell, not in the Forge CLI):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">forge --install org.jboss.forge.addon:angularjs</strong></span>
</pre></div><p class="calibre8">After the installation is complete, we need to issue three more commands. First, we will prepare the scaffolding framework:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[forge-demo]$ scaffold-setup --provider AngularJS</strong></span>
</pre></div><p class="calibre8">Our application now is a web app with AngularJS libraries. Next, we will define that we would like to generate a UI for the <code class="email">Users</code> entity:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[forge-demo]$ scaffold-generate --provider AngularJS --targets com.packtpub.wflydevelopment.appendix.model.Users</strong></span>
</pre></div><p class="calibre8">Finally, we create an <code class="email">JAX-RS</code> endpoint:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">[forge-demo]$ rest-generate-endpoints-from-entities --targets com.packtpub.wflydevelopment.appendix.model.Users</strong></span>
</pre></div><p class="calibre8">And we are done! The application<a id="id1426" class="calibre1"/> is now a complete Java EE <a id="id1427" class="calibre1"/>application with REST endpoints, JPA, and an AngularJS UI.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note76" class="calibre1"/>Note</h3><p class="calibre8">When these samples were written, JBoss Forge did not fully support all Java EE 7 dependencies. This can be fixed by manually modifying the <code class="email">pom.xml</code> file of the generated project. You should just remove all the dependencies besides the one shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;javax&lt;/groupId&gt;
    &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
    &lt;version&gt;7.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">Additionally, if your <code class="email">Users</code> entity doesn't have an <code class="email">@javax.persistence.GeneratedValue</code> annotation in its ID field, make sure you add it manually (there is currently a bug in the JPA add-on):</p><div class="informalexample"><pre class="programlisting">   @Id
   @Column(name = "id", unique = true, nullable = false)
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   public int getId() {
      return this.id;
   }</pre></div></div></div>

<div class="book" title="Creating your first Java EE 7 application with JBoss Forge">
<div class="book" title="Building and deploying the application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch13lvl2sec95" class="calibre1"/>Building and deploying the application</h2></div></div></div><p class="calibre8">Now, it is time to build your<a id="id1428" class="calibre1"/> application using the <code class="email">build</code> command, which<a id="id1429" class="calibre1"/> will compile and package your application in a web application archive (<code class="email">forge-demo.war</code>):</p><div class="informalexample"><pre class="programlisting">[forge-demo]$ build
***SUCCESS*** Build Success </pre></div><p class="calibre8">The <code class="email">Maven build</code> command has<a id="id1430" class="calibre1"/> created an artifact <code class="email">forge-demo-1.0.0-SNAPSHOT.war</code> in the <code class="email">target</code> folder of your project. You can now either manually copy the archive into the <code class="email">deployments</code> folder of your application <a id="id1431" class="calibre1"/>server or use the <code class="email">management</code> interfaces.</p><p class="calibre8">Remember that the server <a id="id1432" class="calibre1"/>should have the <code class="email">java:jboss/datasources/PostgreSqlDS</code> data source defined!</p></div></div>
<div class="book" title="Your Forge-demo application in action"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec65" class="calibre1"/>Your Forge-demo application in action</h1></div></div></div><p class="calibre8">You can access your application at the default URL, <code class="email">http://localhost:8080/ forge-demo-1.0.0-SNAPSHOT/</code>.</p><p class="calibre8">The main application screen will <a id="id1433" class="calibre1"/>contain the list of entities on the left menu. If you choose the <span class="strong"><strong class="calibre9">Users</strong></span> position, then you should see a list of users that have been added, a <span class="strong"><strong class="calibre9">Search</strong></span> button<a id="id1434" class="calibre1"/> which can be used to filter across the users, and a <span class="strong"><strong class="calibre9">Create</strong></span> button, which obviously will insert some data. This is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00107.jpeg" alt="Your Forge-demo application in action" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">By clicking on the <span class="strong"><strong class="calibre9">Create</strong></span> button, you will be taken to the screen that allows the insertion of a new user to the database (remember that we have<a id="id1435" class="calibre1"/> configured this application to run against a <code class="email">PostgreSQL</code> database). This is<a id="id1436" class="calibre1"/> shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00108.jpeg" alt="Your Forge-demo application in action" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">In this way, we have created a basic AngularJS app based on Java EE. It can be used as a foundation for your project or just a sandbox in which you can try out new ideas. Be sure to check out other available add-ons, and remember that you will always have the possibility to create your own ones!</p></div></body></html>