- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Using Threads in Java
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中使用线程
- en: One of the first software development contracts I had was to develop software
    for an invisible fence security system at thoroughbred horse farms in Kentucky,
    USA. The computer we used was an Apple II plus. There was no such thing as threads
    in the 6502 CPU or the OS, ProDOS. What we did was write all the code in assembly
    language in small units that were measured by the number of cycles each unit took.
    Once we finished our allotted cycles, we would save our state in a defined region
    of memory and turn over control to the next unit. It worked quite well, and if
    a horse wandered off, alarms would be sounded. The monitoring of the fence, just
    a buried cable that could detect a horse walking over it, continued even while
    the alarm sounded. This was my introduction to threaded programming. This was
    in 1982.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我最早的一个软件开发合同是为美国肯塔基州纯血马场开发隐形围栏安全系统软件。我们使用的计算机是Apple II plus。在6502 CPU或ProDOS操作系统中没有线程的概念。我们所做的是用汇编语言编写所有代码，这些代码是以每个单元所需的周期数来衡量的。一旦我们完成了分配的周期，我们就会在内存的一个定义区域中保存我们的状态，并将控制权交给下一个单元。这工作得相当好，如果马走失了，就会响起警报。即使在警报响起的同时，围栏的监控，也就是可以检测到马走过它的地下电缆，也会继续进行。这是我接触到的线程编程。这是在1982年。
- en: I did not work with threads again until 1999 when I moved from C++ to Java.
    One of the features that made Java stand out and why I abandoned C++ was Java’s
    standardized support for threading in the language. This, along with support for
    GUI applications with Swing, made it clear to me that Java was the language that
    students in my program needed to learn. In 2002, Dawson College’s Computer Science
    Technology program, of which I was the chairperson, abandoned COBOL as the primary
    teaching language in favor of Java.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我直到1999年从C++迁移到Java后，才再次与线程打交道。使Java脱颖而出的一个特性，以及我放弃C++的原因，是Java语言对线程的标准支持。此外，Swing对GUI应用程序的支持也让我清楚地认识到，Java是我项目中的学生需要学习的语言。2002年，多伦多道格森学院的计算机科学技术专业，我是该专业的负责人，放弃了COBOL作为主要教学语言，转而使用Java。
- en: 'Today, many languages, including C++, have native support for multithreaded
    programming. In this chapter, we will examine how you can write threaded code
    in Java that depends on the Java virtual machine working with the computer’s OS.
    There are issues to deal with when threads share a resource. Using synchronization
    to deal with these issues will be examined. In this chapter, we will look at the
    following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，包括C++在内的许多语言都原生支持多线程编程。在本章中，我们将探讨如何在Java中编写依赖于Java虚拟机与计算机操作系统协同工作的线程代码。当线程共享资源时，需要处理一些问题。我们将探讨使用同步来处理这些问题。在本章中，我们将探讨以下内容：
- en: Creating Java native OS threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Java本地操作系统线程
- en: Preventing race and deadlock conditions in threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止线程中的竞争和死锁条件
- en: Creating new virtual threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的虚拟线程
- en: Let us begin by looking at how we write threaded code using native threads.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨如何使用本地线程编写线程代码开始。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行本章示例所需的工具：
- en: Java 17 installed to work with native threads only
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Java 17以仅使用本地线程
- en: A text editor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Maven 3.8.6或更高版本
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09)找到。
- en: Creating Java native OS threads
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Java本地操作系统线程
- en: The term *native thread* refers to threads managed by the computer’s OS. When
    we create a Java native thread, we are referring to threads that the JVM manages
    using the underlying OS’s threads library API. This also means that the JVM deals
    with the different threads libraries on different OSs, while we use the Java API
    to create threads. A program that employs threads written on an Apple Mac will
    work on a Windows machine as the JVM handles the lowest levels of threads.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “本地线程”一词指的是由计算机操作系统管理的线程。当我们创建Java本地线程时，我们指的是JVM使用底层操作系统的线程库API管理的线程。这也意味着JVM处理不同操作系统上的不同线程库，而我们使用Java
    API来创建线程。在苹果Mac上编写的使用线程的程序可以在Windows机器上运行，因为JVM处理线程的最低级别。
- en: 'We will look at three different ways to create Java native threads and one
    way to create a pool of threads. These will involve the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三种创建Java本地线程的方法以及一种创建线程池的方法。这些将涉及以下内容：
- en: Extending the `Thread` class
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`Thread`类
- en: Implementing the `Runnable` interface
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Runnable`接口
- en: Creating a thread pool with `ExecutorService`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ExecutorService`创建线程池
- en: Implementing the `Callable` interface
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Callable`接口
- en: Managing threads
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程管理
- en: 'The final items we will cover are the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后几个主题是以下内容：
- en: Daemon and non-daemon threads
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护线程和非守护线程
- en: Thread priority
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程优先级
- en: Extending the Thread class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展`Thread`类
- en: Any class that extends the `Thread` class can contain methods that execute as
    part of a thread. Just creating an object does not create threads. Instead, a
    class that extends `Thread` must override the `run` method of the `Thread` superclass.
    Anything in this method becomes a thread. The `run` method can carry out all the
    work in the thread. Unless this is a simple task, the `run` method acts like the
    `perform` method I have used in my previous samples. Everything in the `run` method
    is what this thread will do. Let us look at a simple class that extends the `Thread`
    class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何扩展`Thread`类的类都可以包含作为线程一部分执行的方法。仅仅创建一个对象并不会创建线程。相反，扩展`Thread`类的类必须重写`Thread`超类的`run`方法。这个方法中的任何内容都成为线程。`run`方法可以执行线程中的所有工作。除非这是一个简单的任务，否则`run`方法就像我在之前的示例中使用的`perform`方法一样。`run`方法中的所有内容都是这个线程将要执行的操作。让我们看看一个扩展`Thread`类的简单类。
- en: 'We extend `Thread` to indicate that code in this class contains code that will
    be threaded:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展`Thread`类来表示这个类中的代码将被线程化：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, the work that each thread will do is count backward from whatever
    value we initially assign to a field called `actionCounter`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个线程将要执行的工作是从我们最初分配给名为`actionCounter`的字段的任何值开始倒数：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Threads can be assigned a name. We want each thread in this example to have
    a number as its name. For this reason, it must be a static variable because there
    will just be one `threadCounter` integer, no matter how many instances of `threadCounter`
    we create. Static fields are considered thread-safe, meaning that there cannot
    be a conflict if two or more threads want access to the static field:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以被赋予一个名称。我们希望在这个例子中的每个线程都有一个数字作为其名称。因此，它必须是一个静态变量，因为不管我们创建多少个`threadCounter`实例，都只有一个`threadCounter`整数。静态字段被认为是线程安全的，这意味着如果有两个或更多线程想要访问静态字段，则不会发生冲突：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The constructor is assigning the thread’s name to the superclass’s constructor.
    Each time we create an instance of this object, the value of `threadCounter` will
    be the same as what the previous instance set it as. This allows each thread to
    have a unique name:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将线程的名称分配给超类的构造函数。每次我们创建这个对象的实例时，`threadCounter`的值将与前一个实例设置的值相同。这使得每个线程都有一个唯一的名称：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The only task that this thread will perform is to display its name and the
    current value of the `actionCounter` field. We are overriding the `toString` method
    that is called whenever a reference to an object must act as `String`. It will
    return a string made up of the name assigned to it, by calling the superclass
    `getName` method, and the current value of `actionCounter`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程唯一要执行的任务是显示其名称和`actionCounter`字段的当前值。我们重写了在对象引用必须作为`String`操作时调用的`toString`方法。它将返回一个字符串，由分配给它的名称组成，通过调用超类的`getName`方法，以及`actionCounter`的当前值：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Thread classes must override the superclass `run` method. This is where the
    work of a thread happens. In this case, we are using an infinite `while` loop
    in which we are displaying this object’s thread name and the current value of
    `actionCounter`. When `actionCounter` reaches zero, we return from the `run` method
    and the thread ends. The use of an infinite look syntax, `while (true)`, means
    that the decision to end the loop is based on something that is happening in the
    loop, which, in this case, is decrementing `actionCounter` until it reaches zero.
    This is not the only way to write a `run` method, but it is the most common:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 线程类必须重写超类的`run`方法。线程的工作就在这里发生。在这种情况下，我们使用一个无限`while`循环，在这个循环中我们显示这个对象的线程名称和`actionCounter`的当前值。当`actionCounter`达到零时，我们从`run`方法返回，线程结束。使用无限循环语法`while
    (true)`意味着结束循环的决定是基于循环中发生的事情，在这种情况下，是递减`actionCounter`直到它达到零。这不是编写`run`方法的唯一方法，但这是最常见的方法：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With our threaded class in place, we can now write a class that will instantiate
    and run each of the threads:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的线程类就绪后，我们现在可以编写一个类，该类将实例化和运行每个线程：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, in `perform`, we are instantiating five instances of `ThreadClass`. We
    call `start` and not `run`. The `start` method is an override of the `Thread`
    superclass’s `start` method, and it is responsible for setting up the thread and
    then calling the `run` method. Calling the `run` method yourself will not start
    a thread:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`perform`中，我们创建了`ThreadClass`的五个实例。我们调用`start`而不是`run`。`start`方法是对`Thread`超类`start`方法的覆盖，它负责设置线程并调用`run`方法。自己调用`run`方法不会启动线程：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Threads are not deterministic.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是非确定性的。
- en: This is an important point to always be aware of. Each time you run this example
    code, the output will be different. The threads will execute in an order unrelated
    to the order they were created. Run this example a few times and take note that
    the order of the results is different every time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个始终需要注意的重要点。每次运行这个示例代码时，输出都会不同。线程的执行顺序与它们创建的顺序无关。运行这个示例几次并注意每次结果的顺序都是不同的。
- en: There is one problem with this approach. You cannot extend any other superclass
    in `ThreadClass`. This brings us to the second approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个问题。你无法在`ThreadClass`中扩展任何其他超类。这把我们带到了第二种方法。
- en: Implementing the Runnable interface
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Runnable接口
- en: 'In this approach, we implement the `Runnable` interface. We are performing
    the same task as in the previous example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们实现了`Runnable`接口。我们执行的任务与上一个示例相同：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are calling `Thread.currentThread().getName()` to retrieve the name of this
    thread. When we extended the `Thread` class, we could call `getName`. As we are
    implementing the `Runnable` interface, we do not have superclass methods to call.
    We now get the name by using static methods of the `Thread` class, which will
    return information about the current thread that calls these methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`Thread.currentThread().getName()`来获取这个线程的名称。当我们扩展`Thread`类时，我们可以调用`getName`。由于我们正在实现`Runnable`接口，我们没有超类方法可以调用。我们现在通过使用`Thread`类的静态方法来获取名称，这些方法将返回调用这些方法时当前线程的信息：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `run` method is unchanged:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法没有改变：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `perform` method in the class that starts the threads is different when
    using the `Runnable` interface:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Runnable`接口时，启动线程的类中的`perform`方法有所不同：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We create these threads by instantiating a `Thread` class, passing to its constructor
    an instance of the `Runnable` thread class along with the thread’s name. In this
    example, the `Thread` object is anonymous; we do not assign it to a variable,
    and on it, we call `start`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实例化一个`Thread`类，将其构造函数传递给`Runnable`线程类的一个实例以及线程的名称来创建这些线程。在这个例子中，`Thread`对象是匿名的；我们没有将其分配给一个变量，并在其上调用`start`：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just like in the previous example, the output will be different for each run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个示例一样，每次运行都会得到不同的输出。
- en: Which technique should you use? The current best practice is to prefer the `Runnable`
    interface. This permits you to extend another class while it’s still being threaded.
    Let us look at thread pooling.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用哪种技术？当前的最好实践是优先选择`Runnable`接口。这允许你在线程化的同时扩展另一个类。让我们看看线程池。
- en: Creating a thread pool with ExecutorService
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ExecutorService创建线程池
- en: What we have seen so far requires us to create a thread for every instance of
    the `Thread` class. An alternative approach is to create a pool of threads that
    can be reused. This is where the `ExecutorService` approach comes in. With this,
    we can create a pool of threads while, at the same time, defining the maximum
    number that can run concurrently. If more threads are required than the pool allows,
    then threads will wait until an executing thread ends. Let us change our basic
    example to use this service.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的内容要求我们为`Thread`类的每一个实例创建一个线程。一种替代方法是创建一个可以重复使用的线程池。这就是`ExecutorService`方法发挥作用的地方。使用这种方法，我们可以在定义最大并发数的同时创建一个线程池。如果需要的线程数超过了池中允许的数量，那么线程将等待直到一个正在执行的线程结束。让我们改变我们的基本示例以使用这个服务。
- en: 'We begin with a class that implements `Runnable`. The `actionCounter` field
    is the number we will count down from in the thread:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个实现了`Runnable`接口的类开始。`actionCounter`字段是线程中将递减的数字：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we will leave the creation of the `Thread` class to `ExecutorService`, we
    no longer have a constructor that accepts `String` for the name of the thread.
    We will pass the name as `int` to the constructor and store it here. Fields in
    a class that becomes a single thread will each have their own `actionCounter`
    and `threadCount` instances:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将创建 `Thread` 类的任务留给 `ExecutorService`，我们不再有接受线程名称 `String` 的构造函数。我们将把名称作为
    `int` 传递给构造函数，并在这里存储它。成为单个线程的类的字段将各自拥有自己的 `actionCounter` 和 `threadCount` 实例：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the constructor that takes the name we want to know the thread by:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是接受我们想要知道的线程名称的构造函数：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are overriding the `toString` method to return `String` with the current
    thread’s name, which is assigned by `ExecutorService`, along with the name we
    assigned to `threadCount` as a number, followed by the current value of `actionCounter`,
    which decreases while the thread runs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写 `toString` 方法以返回包含当前线程名称的 `String`，这是由 `ExecutorService` 分配的，以及我们分配给 `threadCount`
    的名称，后面跟着 `actionCounter` 的当前值，它在线程运行时减少：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last method is `run`. This remains unchanged:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是 `run`。这保持不变：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let us look at how we use `ExecutorService` to create the threads:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用 `ExecutorService` 来创建线程：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I have chosen to make the variables we use as fields. They could all just be
    declared as local variables in a single method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将我们使用的变量作为字段。它们都可以在单个方法中声明为局部变量：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The constructor now has the responsibility to instantiate `ExecutorService`,
    along with an array of `Runnable` threads:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数现在负责实例化 `ExecutorService`，以及一个 `Runnable` 线程数组：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We add threads to `ExecutorService` using the `execute` method. We do not need
    access to the threads, so they are instantiated anonymously:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `execute` 方法将线程添加到 `ExecutorService`。我们不需要访问线程，因此它们是匿名实例化的：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The service will shut down after all threads have finished. You can no longer
    add any threads to the service after this method is called:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程完成后，服务将关闭。在此方法调用后，你不能再向服务添加任何线程：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We end this class with the usual `main` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以通常的 `main` 方法结束这个类：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These three approaches allow you to easily create threads. One issue that they
    all share is that when the thread ends, it does not return a value because `run`
    is void. We can resolve this, if needed, by combining `ExecutorService` with a
    third type of threaded class by using the `Callable` interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法允许你轻松地创建线程。它们共同的一个问题是，当线程结束时，它不会返回一个值，因为 `run` 是空值。如果需要，我们可以通过结合 `ExecutorService`
    和使用 `Callable` 接口的一种第三类线程类来解决这个问题。
- en: Implementing the Callable interface
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 `Callable` 接口
- en: In each of the thread classes we have seen, they have all had a `run` method
    that returned void when the thread ended. This leads us to the `Callable` interface.
    Using this interface, the end of a thread returns a value. We can only use this
    technique if we use `ExecutorService`. Let’s begin by looking at a `Callable`
    thread class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到的每个线程类中，它们都有一个 `run` 方法，当线程结束时返回空值。这引导我们到 `Callable` 接口。使用这个接口，线程的结束会返回一个值。我们只能在使用
    `ExecutorService` 的情况下使用这种技术。让我们先看看一个 `Callable` 线程类。
- en: 'We begin with the class that we want to thread. We implement the `Callable`
    interface, and using generic notation, we state that the value returned when the
    thread ends will be a string. The fields, constructor, and `toString` are the
    same as `ExecutorThreadingInterface`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从想要线程化的类开始。我们实现 `Callable` 接口，并使用泛型表示法，声明线程结束时返回的值将是一个字符串。字段、构造函数和 `toString`
    方法与 `ExecutorThreadingInterface` 相同：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we replace `run` with `call` and show a return type. The `return` statement
    will display the thread name that we assigned as an integer to each thread.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `run` 替换为 `call` 并显示返回类型。`return` 语句将显示我们分配给每个线程的线程名称，作为一个整数。
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let us look at the runner for this `Callable` thread.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个 `Callable` 线程的运行者。
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first variable we are declaring is `List` of the `Future` type. `Future`
    is an interface, like `List`. When we use, not execute, the `submit` method of
    `ExecutorService`, it returns an object that implements the `Future` interface.
    Objects that implement this interface represent the result of an asynchronous
    task. When we instantiate this object in a few lines from here, it will be `List`
    of `Future` strings that are delivered by the thread:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的第一个变量是`Future`类型的`List`。`Future`是一个接口，就像`List`一样。当我们使用（而不是执行）`ExecutorService`的`submit`方法时，它返回一个实现`Future`接口的对象。实现此接口的对象代表异步任务的结果。当我们在这里几行之后实例化此对象时，它将是线程传递的`Future`字符串的`List`：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A new feature in this example is the display of the current date and time that
    each thread ends. The `DateTimeFormatter` object converts an `LocalDateTime` object
    into a readable string:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的一个新特性是显示每个线程结束时的当前日期和时间。`DateTimeFormatter`对象将`LocalDateTime`对象转换为可读的字符串：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The constructor instantiates the class fields:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数实例化了类的字段：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We instantiate `futureList` as `ArrayList`. We follow this by defining the
    format of the date and time we want:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`futureList`实例化为`ArrayList`。随后我们定义我们想要的日期和时间的格式：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we use `submit` to submit the threads to the `ExecutorService`. Using
    `submit` implies that we expect a return of type `Future`. We also add each `Future`
    object to an `ArrayList` instance:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`submit`将线程提交给`ExecutorService`。使用`submit`意味着我们期望返回类型为`Future`。我们还把每个`Future`对象添加到一个`ArrayList`实例中：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we cycle through the `ArrayList` instance displaying the current date
    and time along with the thread’s returned value – in this example, `String`. We
    access the return value of the `Future` object by calling the `get` method. This
    is a blocking method call. Each `Future` object is associated with a specific
    thread, and `get` will wait for its result before it allows the next `Future`
    object’s `get` to execute. A call to `get` can result in two checked exceptions,
    so we must place the call in a `try`/`catch` block. For the purpose of this example,
    we are just printing the stack trace. You should never just print a stack trace
    without taking any appropriate action:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历`ArrayList`实例，显示当前日期和时间以及线程返回的值——在这个例子中，是`String`。我们通过调用`get`方法来访问`Future`对象的返回值。这是一个阻塞的方法调用。每个`Future`对象都与一个特定的线程相关联，`get`将在允许下一个`Future`对象的`get`执行之前等待其结果。对`get`的调用可能导致两个检查型异常，因此我们必须将调用放在`try`/`catch`块中。为了这个示例的目的，我们只是打印堆栈跟踪。你永远不应该在没有采取任何适当行动的情况下打印堆栈跟踪：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`ExecutorService` must be explicitly shut down when you no longer need the
    service:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再需要服务时，必须显式关闭`ExecutorService`：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We end this with the usual `main` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以通常的`main`方法结束：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we have reviewed the most common approaches to creating `Threads`,
    let us look a little deeper at how we can manage a thread.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了创建`Threads`最常见的方法，让我们更深入地看看我们如何管理一个线程。
- en: Managing threads
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程管理
- en: 'There are three `Thread` methods that are commonly used to manage a thread.
    These are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常用的`Thread`方法用于管理线程。这些如下：
- en: '`yield()`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield()`'
- en: '`join()`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`'
- en: '`sleep()`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep()`'
- en: The `yield()` method informs the thread scheduler that it can give up its current
    usage of the processor but wishes to be rescheduled as soon as possible. This
    is only a suggestion, and the scheduler is free to do what it wishes. This makes
    it non-deterministic as well as dependent on the platform it is running on. It
    should only be used when it can be proved, usually by profiling the code, that
    it can improve performance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield()`方法通知线程调度器它可以放弃当前对处理器的使用，但希望尽快重新调度。这只是一个建议，调度器可以自由地做它想做的事情。这使得它是非确定性的，并且依赖于它运行的平台。只有在可以证明的情况下，通常通过代码分析，它才能提高性能时才应该使用。'
- en: The `join()` method can be useful when one thread (we will call it `join()`
    affects the first thread that created the second thread. There are two additional
    overloaded versions of join that allow you to set the length of time to block
    the thread that started it in either milliseconds, or milliseconds and nanoseconds.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程（我们将称之为`join()`）影响创建了第二个线程的第一个线程时，`join()`方法可能很有用。`join()`有两个额外的重载版本，允许你设置阻塞启动线程的时间长度，可以是毫秒，也可以是毫秒和纳秒。
- en: The final method is a static method of the `Thread` class. The `sleep()` method
    pauses the thread it is executed in for a specific length of time. The time can
    be, like join, in milliseconds, or milliseconds and nanoseconds.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法是`Thread`类的一个静态方法。`sleep()`方法会使正在执行的线程暂停特定的时间长度。时间可以是，就像`join`一样，以毫秒为单位，也可以是毫秒和纳秒。
- en: One characteristic of both `join()` and `sleep()` is that they can throw checked
    exceptions. They must be coded inside a `try`/`catch` block. The following is
    a thread class that instantiates and starts a second class but then joins the
    second class, thus blocking itself until the thread it started finishes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`和`sleep()`的一个共同特点是它们可以抛出检查异常。它们必须在`try`/`catch`块中编码。以下是一个线程类，它实例化和启动第二个类，但随后与第二个类连接，从而阻塞自身，直到它启动的线程完成。'
- en: 'This is like the first `ThreadClass` instance we had seen. The difference is
    that it instantiates another thread class and then starts that thread at the beginning
    of the `run` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像我们之前看到的第一个`ThreadClass`实例。区别在于它实例化另一个线程类，然后在`run`方法的开头启动该线程：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we start the second thread, and it will now execute as determined by
    the scheduler:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们启动第二个线程，它现在将根据调度器的决定执行：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the first thread reaches 225, we issue a join on the second thread. The
    result will be that the first thread is blocked, and the second thread will run
    till it finishes before unblocking the first thread:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个线程达到225时，我们对第二个线程发出连接请求。结果将是第一个线程被阻塞，第二个线程将一直运行到完成，然后才会解除第一个线程的阻塞：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Daemon and non-daemon threads
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守护线程和非守护线程
- en: The term *daemon* refers to what is considered a low-priority thread. What this
    means is that any such native threads designated as daemons will end, regardless
    of what they are doing at that moment in time when the application’s main thread
    ends.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: “守护”一词指的是被认为是低优先级的线程。这意味着任何被指定为守护的本地线程都将结束，无论在应用程序的主线程结束时它们正在做什么。
- en: A non-daemon thread, the default for when a native thread is created, will block
    the application’s main thread from ending until the thread completes its task.
    This tells us that non-daemon threads must have an ending condition. A daemon
    thread does not need an ending condition, as it will end with the main thread.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 非守护线程，当创建本地线程时的默认设置，将阻止应用程序的主线程结束，直到该线程完成任务。这告诉我们非守护线程必须有一个结束条件。守护线程不需要结束条件，因为它会随着主线程结束。
- en: 'You can set a native thread to be a daemon with a simple method call:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单的调用方法将本地线程设置为守护线程：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can only call this method on a thread after it has been instantiated but
    before it has started. You cannot change the daemon status after it starts. Calling
    this method will result in an exception being thrown.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在线程实例化后但在它启动之前调用此方法。一旦它开始，就不能更改守护线程的状态。调用此方法会导致抛出异常。
- en: Thread priority
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程优先级
- en: As already pointed out, threads are non-deterministic. This means we have no
    absolute control over when a thread will get its slice of time to run or how long
    that time slice will be. We can make a suggestion, also called a hint, and that
    is where thread priority comes in.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经指出的，线程是非确定性的。这意味着我们无法绝对控制线程何时获得其运行的时间片或该时间片将持续多长时间。我们可以提出一个建议，也称为提示，这就是线程优先级的作用所在。
- en: 'The range of possible values for thread priority is 1 through 10\. There are
    three defined static constants that are used in most cases rather than a number.
    These are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 线程优先级的可能值范围是1到10。在大多数情况下，使用三个定义的静态常量而不是数字。如下所示：
- en: '`Thread.MAX_PRIORITY`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.MAX_PRIORITY`'
- en: '`Thread.MIN_PRIORITY`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.MIN_PRIORITY`'
- en: '`Thread.NORM_PRIORITY`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.NORM_PRIORITY`'
- en: As this suggests, you cannot rely on maximum priority getting more time slices
    than minimum priority. It should get more slices, and that is the best that you
    can hope for.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这所暗示的，你不能依赖最大优先级比最小优先级获得更多的时间片。它应该获得更多的时间片，这是你能期望的最好的结果。
- en: Now that we have seen how to manage our threads, let us look at one more topic,
    thread safety.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何管理我们的线程，让我们再看看一个额外的主题，线程安全。
- en: Preventing race and deadlock conditions in threads
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止线程中的竞态和死锁条件
- en: There are two common problems that can cause problems with threaded code. The
    first is the race condition. This is what can happen when two or more threads
    work with a block of code that changes a variable shared by all the threads.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个常见问题可能导致线程代码出现问题。第一个是竞态条件。当两个或更多线程共同操作一个改变所有线程共享变量的代码块时，就会发生这种情况。
- en: The second is the deadlock condition. To resolve race conditions, you lock a
    block of code. If multiple threads use the same lock object, then you could have
    a situation where these threads are waiting for each other to finish with the
    lock but none finish. Let us look more closely at these two conditions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种是死锁条件。为了解决竞态条件，你锁定一段代码。如果多个线程使用相同的锁对象，那么可能会出现这些线程都在等待其他线程完成锁但没有任何一个线程完成的情况。让我们更仔细地看看这两个条件。
- en: Race condition
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞态条件
- en: Imagine a scenario where you share a reference to an object among multiple threads.
    Calling upon methods in this shared class that only use local variables is thread-safe.
    Thread-safe, in this case, occurs because each thread maintains its own private
    stack for local variables. There can be no conflict between threads.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你需要在多个线程之间共享一个对象的引用。调用这个共享类中只使用局部变量的方法是线程安全的。在这种情况下，线程安全发生是因为每个线程都维护自己的私有栈用于局部变量。线程之间不可能存在冲突。
- en: It is a different story if the shared object’s methods access and alter a class
    field. Unlike local variables, class fields are unique to the shared object and
    every thread that calls methods in this class is possibly altering a field. Operations
    on these fields may not finish before the thread’s time slice ends. Now, imagine
    that a thread expects a field to have a specific value based on the last time
    slice that accessed the field. Unbeknown to it, another thread has changed that
    value. This results in what is referred to as a race condition. Let us look at
    an example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果共享对象的方法访问并修改类字段，情况就不同了。与局部变量不同，类字段是共享对象的唯一属性，并且每个调用此类方法线程都有可能修改字段。在这些字段上的操作可能不会在线程的时间片结束之前完成。现在，想象一下，一个线程期望基于上次访问该字段的时间片，字段具有特定的值。然而，它并不知道，另一个线程已经改变了这个值。这导致所谓的竞态条件。让我们看看一个例子。
- en: 'Here is a simple class that adds a passed value to a field of the class called
    `counter` and returns the result of adding the value. Every time we call `addUp`,
    we expect the `counter` field to change the value:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的类，它将传递的值添加到名为`counter`的类字段中，并返回加法的结果。每次我们调用`addUp`时，我们都期望`counter`字段改变值：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'How much time a thread gets from the scheduler is related to the CPU of your
    computer. A high clock rate along with multiple CPU cores sometimes permits a
    thread to complete its task before the next thread takes over. For that reason,
    I have slowed down the `addUp` method by having it sleep for a half second:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 线程从调度器获得的时间与你的计算机的CPU有关。高时钟频率以及多个CPU核心有时允许线程在下一个线程接管之前完成其任务。因此，我通过让`addUp`方法休眠半秒钟来减慢了`addUp`方法：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The threaded class is based on `ThreadClass` we have already seen:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 线程类基于我们之前看到的`ThreadClass`：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have a field for holding a reference to an `Adder` object. No matter how
    many threads we create, they will all share the field variables:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个字段用于存储对`Adder`对象的引用。无论我们创建多少个线程，它们都将共享字段变量：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The constructor receives a reference to the `Adder` object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收对`Adder`对象的引用：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we are printing information on this thread and the current value from
    the `addUp` method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在打印有关此线程和`addUp`方法当前值的信息：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is the `main` class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`main`类：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will have two threads of type `SynchronizedThreadClass`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有两个类型的`SynchronizedThreadClass`线程：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Before we instantiate each thread, we create a single `Adder` object that we
    share with each threaded class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实例化每个线程之前，我们创建一个单独的`Adder`对象，并将其与每个线程类共享：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This code is not yet synchronized. Here is a table of results when access to
    the adder is not synchronized:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码尚未同步。以下是访问加法器未同步时的结果表：
- en: '| **Unsynchronized** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **未同步** |'
- en: '| **Thread** | **Thread** **class actionCounter** | **Adder** **class counter**
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **线程** | **线程** **类动作计数器** | **Adder** **类计数器** |'
- en: '| #1 | 5 | 4 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 5 | 4 |'
- en: '| #2 | 5 | 4 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 5 | 4 |'
- en: '| #1 | 4 | 8 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 4 | 8 |'
- en: '| #2 | 4 | 10 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 4 | 10 |'
- en: '| #1 | 3 | 12 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 3 | 12 |'
- en: '| #2 | 3 | 14 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 3 | 14 |'
- en: '| #1 | 2 | 16 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 2 | 16 |'
- en: '| #2 | 2 | 18 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 2 | 18 |'
- en: '| #1 | 1 | 20 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 1 | 20 |'
- en: '| #2 | 1 | 20 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 1 | 20 |'
- en: Table 9.1 – The results from running the code unsynchronized
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 – 运行未同步代码的结果
- en: The expectation is that the `Adder` class counter should count from 2 to 20\.
    It does not. The first thread begins adding the value passed, 2, to the counter.
    But before it can display its result, the second thread comes along and adds 2
    to the same counter, now increasing the value to 4\. When we return to the first
    thread that will just display the result, it is now 4, and not the value of 2
    that it had when its first time slice ended. If you run this multiple times, the
    results will be different, but we will see this problem in other places in the
    output.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是`Adder`类计数器应该从2计数到20。但它没有。第一个线程开始将传递的值2加到计数器上。但在它能够显示结果之前，第二个线程出现了，并将2加到同一个计数器上，现在值增加到4。当我们回到第一个线程去显示结果时，它现在是4，而不是它第一次时间片结束时的2。如果你多次运行这个程序，结果将会不同，但我们将在输出的其他地方看到这个问题。
- en: 'Now, let us synchronize the code. Synchronizing applies a lock to a section
    of code commonly called a critical section. The lock is a reference to an object,
    as all objects, by virtue of their `Object` superclass, can be used as a lock.
    We only need to change the `Adder` class and specifically the `addUp` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们同步代码。同步将锁应用于代码的一个部分，通常称为临界区。锁是对一个对象的引用，因为所有对象，凭借它们的`Object`超类，都可以用作锁。我们只需要更改`Adder`类，特别是`addUp`方法：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As the entire method is considered a critical section, we can remove the synchronize
    block and apply the `synchronized` keyword to the method name:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个方法被视为临界区，我们可以移除同步块并将`synchronized`关键字应用于方法名：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is the table of results using the synchronized version of the `addUp`
    `Adder` class method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`synchronized`版本的`addUp` `Adder`类方法的结果表：
- en: '| **Synchronized** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **同步** |'
- en: '| **Thread** | **Thread** **class actionCounter** | **Adder** **class counter**
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **线程** | **线程** **类 actionCounter** | **类 Adder** **的 counter** |'
- en: '| #1 | 5 | 2 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 5 | 2 |'
- en: '| #2 | 5 | 4 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 5 | 4 |'
- en: '| #1 | 4 | 6 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 4 | 6 |'
- en: '| #2 | 4 | 8 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 4 | 8 |'
- en: '| #1 | 3 | 10 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 3 | 10 |'
- en: '| #2 | 3 | 12 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 3 | 12 |'
- en: '| #1 | 2 | 14 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 2 | 14 |'
- en: '| #2 | 2 | 16 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 2 | 16 |'
- en: '| #1 | 1 | 18 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| #1 | 1 | 18 |'
- en: '| #2 | 1 | 20 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| #2 | 1 | 20 |'
- en: Table 9.2 – The results from running the code synchronized
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2 – 运行代码同步的结果
- en: You can see that every value from 2 to 20 appears.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到从2到20的每个值都出现了。
- en: As a developer, you are always looking for tasks that can be carried out concurrently.
    Once identified, you will apply threading where appropriate. Any long-running
    task is a candidate for a thread. User interfaces typically run the interface
    in one or more threads, and as tasks are selected from menus or buttons, they
    too are run in threads. This means that the user interface can respond to you
    even while it is performing a long-running task.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你总是在寻找可以并发执行的任务。一旦确定，你将在适当的地方应用线程。任何长时间运行的任务都适合作为线程的候选。用户界面通常在一个或多个线程中运行界面，当从菜单或按钮中选择任务时，它们也在线程中运行。这意味着用户界面即使在执行长时间运行的任务时也能对你做出响应。
- en: Now, let us look at a problem that can arise if we synchronize blocks of code
    with the same lock object improperly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们不正确地使用相同的锁对象同步代码块可能会出现的问题。
- en: Deadlock condition
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁条件
- en: A thread deadlock occurs when thread locks get intertwined, especially if a
    thread is nested inside another one. This results in each thread waiting for the
    other to end. When using synchronize, a lock can be any object or class in Java
    that will protect a critical section, usually to avoid the race condition. You
    can also create objects of type `Lock` or `ReentrantLock`. Either approach, as
    we shall see, can result in a deadlock. Deadlock can be difficult to recognize,
    as it does not crash the program or throw an exception. Let us look at an example
    of code that will be deadlocked.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程锁交织在一起时，尤其是在一个线程嵌套在另一个线程内部时，会发生线程死锁。这导致每个线程都在等待另一个线程结束。当使用`synchronized`时，锁可以是Java中任何将保护临界区的对象或类，通常是为了避免竞态条件。你还可以创建`Lock`或`ReentrantLock`类型的对象。无论哪种方法，正如我们将看到的，都可能导致死锁。死锁可能很难识别，因为它不会使程序崩溃或抛出异常。让我们看看一个会导致死锁的代码示例。
- en: 'We begin with the class that will create the lock objects and then we start
    two threads with them:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建锁对象所在的类，然后我们使用它们启动两个线程：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here are the two lock objects we will use with synchronize in `Thread1` and
    `Thread2`. Any object in Java, either one you create or one that already exists,
    such as `String`, can be used as a lock:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将在`Thread1`和`Thread2`中使用的两个锁对象。Java中的任何对象，无论是你创建的还是已经存在的，例如`String`，都可以用作锁：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let us look at the class that extends `Thread`. Take note of the fact
    that `Thread1` uses `lock1` before `lock2`, while `Thread2` uses `lock2` before
    `lock1`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看扩展`Thread`类的类。请注意，`Thread1`在使用`lock2`之前使用`lock1`，而`Thread2`在使用`lock1`之前使用`lock2`：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this `run` method, we have a synchronized block that uses `lock1` and then
    a nested synchronized block that uses `lock2`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`run`方法中，我们有一个使用`lock1`的同步块，然后是一个嵌套的同步块，使用`lock2`：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this `run` method, we have a synchronized block that uses `lock2` and then
    a nested synchronized block that uses `lock1`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`run`方法中，我们有一个使用`lock2`的同步块，然后是一个嵌套的同步块，使用`lock1`：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When we run this code, the output will be as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，输出将如下所示：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The program is now deadlocked, and both threads are waiting for the other thread
    to finish. If we change the order of the locks we use so that both use `lock1`
    first and `lock2` second, we will get the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个程序已经死锁，两个线程都在等待另一个线程完成。如果我们改变我们使用的锁的顺序，使得两个都先使用`lock1`然后使用`lock2`，我们将得到以下结果：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The deadlock condition is solved. Deadlocks are rarely this obvious, and you
    may not even be aware that there is a deadlock happening. You need a thread dump
    to determine whether there is a deadlock in your code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁条件已解决。死锁很少这么明显，你可能甚至没有意识到正在发生死锁。你需要线程转储来确定你的代码中是否存在死锁。
- en: Here’s one final point on this topic – rather than using an instance of the
    `Object` class as the lock, you can use the `Lock` class. The syntax is a little
    different, and you can ask a `Lock` object whether it is being used. The following
    code snippet shows what it will look like, but it does not solve the deadlock.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题的最后一个要点——与其使用`Object`类的一个实例作为锁，你可以使用`Lock`类。语法略有不同，你可以询问一个`Lock`对象它是否正在被使用。以下代码片段显示了它将是什么样子，但它不能解决死锁。
- en: 'In the `main` class, the locks will use the `Lock` interface with the `ReentrantLock`
    class that implements the interface:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`类中，锁将使用实现该接口的`ReentrantLock`类的`Lock`接口：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In this code, we are passing the `Lock` objects to the class through the constructor:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们通过构造函数将`Lock`对象传递给类：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Note that we do not use a synchronized block, but instead, we call `lock` on
    `lock1`, and when the critical section is finished, we issue `unlock` on `lock1`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有使用同步块，而是调用`lock1`上的`lock`，当关键部分完成时，我们在`lock1`上发出`unlock`：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: One advantage of using `lock` objects rather than a synchronized block is that
    the call to `unlock` does not have to be in the same class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lock`对象而不是同步块的一个优点是，`unlock`调用不需要在同一类中。
- en: Multithreading is a powerful feature of Java that you should use when appropriate.
    What we saw is based on native threading available in Java from version 1.0\.
    Recently, a new type of threading was introduced. Let us look at it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是Java的一个强大特性，你应该在适当的时候使用它。我们所看到的是基于从Java 1.0版本中可用的原生线程。最近，引入了一种新的线程类型。让我们看看它。
- en: Creating new virtual threads
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的虚拟线程
- en: As pointed out at the beginning of the previous section, native Java threads
    are managed by the JVM by working directly with the OS’s threading library. There
    is a one-to-one relationship between a native thread and an OS thread. This new
    approach is called **virtual threads**. While native threads are managed by the
    JVM in collaboration with the OS, virtual threads are managed exclusively by the
    JVM. OS threads are still used, but what makes this approach significant is that
    virtual threads can share OS threads and are no longer one-to-one.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节开头所指出的，原生Java线程是由JVM通过直接与操作系统的线程库合作来管理的。原生线程和操作系统线程之间存在一对一的关系。这种新的方法被称为**虚拟线程**。虽然原生线程是由JVM与操作系统合作管理的，但虚拟线程完全由JVM管理。操作系统线程仍然被使用，但使这种方法变得显著的是，虚拟线程可以共享操作系统线程，并且不再是点对点的关系。
- en: 'Virtual threads do not run faster and can suffer from race and deadlock conditions.
    What is special with virtual threads is that the number of threads that you can
    start up could be in the millions. How we use virtual threads is not much different
    from native threads. The following code snippet shows the `perform` method that
    we saw in the previous examples creating virtual threads. The thread class is
    unchanged, thus making the use of a virtual thread rather than a native thread
    quite easy:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程运行速度并不快，可能会遭受竞态和死锁条件。虚拟线程的特殊之处在于，您可以启动的线程数量可能达到数百万。我们使用虚拟线程的方式与本地线程没有太大区别。以下代码片段显示了我们在前面的示例中看到的`perform`方法创建虚拟线程。线程类没有改变，这使得使用虚拟线程而不是本地线程变得非常容易：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, we are creating a virtual thread and starting it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在创建一个虚拟线程并启动它：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: I must embarrassingly admit that it took me 3 days to get this code to work.
    Why? I neglected an important characteristic of virtual threads – they are daemon
    threads. Attempting to make them non-daemon has no effect. What was happening
    to me is that the program would end before any output appeared, or only some appeared
    but not all of the expected output from the threads. When `perform` ended and
    returned to the `main()` method, the main native thread ended. When this happened,
    all daemon threads were ended. My PC executed `perform`, returned to `main`, and
    ended before a single virtual thread could display its output.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须尴尬地承认，我花了3天时间才让这段代码工作。为什么？我忽略了虚拟线程的一个重要特性——它们是守护线程。尝试使它们非守护线程没有任何效果。发生在我身上的情况是，程序会在任何输出出现之前结束，或者只出现了一些输出，但没有出现所有预期的线程输出。当`perform`结束并返回到`main()`方法时，主本地线程结束。当这种情况发生时，所有守护线程都会结束。我的电脑执行了`perform`，返回到`main`，并在单个虚拟线程能够显示其输出之前结束。
- en: You can see the solution I used to make this code work. I called `Thread.sleep()`.
    This puts the current thread to sleep for a specified length of time. In this
    case, 500 milliseconds was enough time for the virtual threads to complete all
    their tasks before the main thread ended.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我用来使这段代码工作的解决方案。我调用了`Thread.sleep()`。这会使当前线程休眠指定的时间长度。在这种情况下，500毫秒足够虚拟线程完成所有任务，而主线程结束。
- en: Finally, you cannot change the priority of virtual threads. They all run at
    `NORM_PRIORITY`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您不能更改虚拟线程的优先级。它们都运行在`NORM_PRIORITY`。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As mentioned at the start of this chapter, Java’s native support of threads
    is one of the reasons for its popularity. In this chapter, we saw how we can create
    threads by extending the `Thread` class and by implementing either a `Runnable`
    or `Callable` interface. We saw how `ExecutorService` allows us to pool threads.
    We concluded by looking at one specific issue, where two or more threads compete
    for access to a shared resource, called a race condition, and saw how we resolve
    this by applying locks through the application of synchronization.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，Java对线程的原生支持是其受欢迎的原因之一。在本章中，我们看到了如何通过扩展`Thread`类和实现`Runnable`或`Callable`接口来创建线程。我们看到了`ExecutorService`如何允许我们池化线程。我们通过查看一个特定问题来结束本章，即两个或多个线程竞争访问共享资源，称为竞态条件，并看到我们如何通过应用同步来解决这个问题。
- en: There are changes coming to threading. Project Loom, at the time of writing,
    introduces threads managed exclusively by the JVM along with a framework for concurrency.
    Some features are in preview, while others are in incubation. It will be a few
    years before these new types of threads become commonplace. I recommend following
    the development of this project.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 线程领域即将发生一些变化。在撰写本文时，Project Loom引入了由JVM独家管理的线程以及一个并发框架。一些功能处于预览阶段，而其他功能处于孵化阶段。在几年内，这些新型线程才会变得普遍。我建议关注这个项目的开发。
- en: In our next chapter, we will look at the most used design patterns in Java development.
    These patterns will provide us with well-established approaches to organizing
    our code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一章中，我们将探讨Java开发中最常用的设计模式。这些模式将为我们提供组织代码的既定方法。
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Creating and Starting Java* *Threads*: [https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html](https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建和启动Java线程*：[https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html](https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html)'
- en: '*Introduction to Thread Pools in* *Java*: [https://www.baeldung.com/thread-pool-java-and-guava](https://www.baeldung.com/thread-pool-java-and-guava)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java中的线程池简介*: [https://www.baeldung.com/thread-pool-java-and-guava](https://www.baeldung.com/thread-pool-java-and-guava)'
- en: '*Deadlock in Java* *Multithreading*: [https://www.geeksforgeeks.org/deadlock-in-java-multithreading/](https://www.geeksforgeeks.org/deadlock-in-java-multithreading/)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java多线程中的死锁*: [https://www.geeksforgeeks.org/deadlock-in-java-multithreading/](https://www.geeksforgeeks.org/deadlock-in-java-multithreading/)'
- en: 'Here is a book from 2006, that remains one of the finest references on threading
    in Java: *Java Concurrency in Practice, 1st Edition*, by Brian Goetz with Tim
    Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (ISBN-13: 978-0321349606)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '这里有一本2006年的书，仍然是Java中线程方面最优秀的参考资料之一：*《Java并发实践，第1版》*，由Brian Goetz与Tim Peierls、Joshua
    Bloch、Joseph Bowbeer、David Holmes和Doug Lea合著（ISBN-13: 978-0321349606）'
- en: '*JEP 425: Virtual* *Threads*: [https://openjdk.org/jeps/425](https://openjdk.org/jeps/425)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JEP 425: 虚拟* *线程*: [https://openjdk.org/jeps/425](https://openjdk.org/jeps/425)'
