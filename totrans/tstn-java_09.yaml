- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Threads in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first software development contracts I had was to develop software
    for an invisible fence security system at thoroughbred horse farms in Kentucky,
    USA. The computer we used was an Apple II plus. There was no such thing as threads
    in the 6502 CPU or the OS, ProDOS. What we did was write all the code in assembly
    language in small units that were measured by the number of cycles each unit took.
    Once we finished our allotted cycles, we would save our state in a defined region
    of memory and turn over control to the next unit. It worked quite well, and if
    a horse wandered off, alarms would be sounded. The monitoring of the fence, just
    a buried cable that could detect a horse walking over it, continued even while
    the alarm sounded. This was my introduction to threaded programming. This was
    in 1982.
  prefs: []
  type: TYPE_NORMAL
- en: I did not work with threads again until 1999 when I moved from C++ to Java.
    One of the features that made Java stand out and why I abandoned C++ was Java’s
    standardized support for threading in the language. This, along with support for
    GUI applications with Swing, made it clear to me that Java was the language that
    students in my program needed to learn. In 2002, Dawson College’s Computer Science
    Technology program, of which I was the chairperson, abandoned COBOL as the primary
    teaching language in favor of Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, many languages, including C++, have native support for multithreaded
    programming. In this chapter, we will examine how you can write threaded code
    in Java that depends on the Java virtual machine working with the computer’s OS.
    There are issues to deal with when threads share a resource. Using synchronization
    to deal with these issues will be examined. In this chapter, we will look at the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Java native OS threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing race and deadlock conditions in threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new virtual threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us begin by looking at how we write threaded code using native threads.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17 installed to work with native threads only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Java native OS threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *native thread* refers to threads managed by the computer’s OS. When
    we create a Java native thread, we are referring to threads that the JVM manages
    using the underlying OS’s threads library API. This also means that the JVM deals
    with the different threads libraries on different OSs, while we use the Java API
    to create threads. A program that employs threads written on an Apple Mac will
    work on a Windows machine as the JVM handles the lowest levels of threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at three different ways to create Java native threads and one
    way to create a pool of threads. These will involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the `Thread` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `Runnable` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a thread pool with `ExecutorService`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `Callable` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final items we will cover are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Daemon and non-daemon threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the Thread class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any class that extends the `Thread` class can contain methods that execute as
    part of a thread. Just creating an object does not create threads. Instead, a
    class that extends `Thread` must override the `run` method of the `Thread` superclass.
    Anything in this method becomes a thread. The `run` method can carry out all the
    work in the thread. Unless this is a simple task, the `run` method acts like the
    `perform` method I have used in my previous samples. Everything in the `run` method
    is what this thread will do. Let us look at a simple class that extends the `Thread`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We extend `Thread` to indicate that code in this class contains code that will
    be threaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the work that each thread will do is count backward from whatever
    value we initially assign to a field called `actionCounter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Threads can be assigned a name. We want each thread in this example to have
    a number as its name. For this reason, it must be a static variable because there
    will just be one `threadCounter` integer, no matter how many instances of `threadCounter`
    we create. Static fields are considered thread-safe, meaning that there cannot
    be a conflict if two or more threads want access to the static field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is assigning the thread’s name to the superclass’s constructor.
    Each time we create an instance of this object, the value of `threadCounter` will
    be the same as what the previous instance set it as. This allows each thread to
    have a unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The only task that this thread will perform is to display its name and the
    current value of the `actionCounter` field. We are overriding the `toString` method
    that is called whenever a reference to an object must act as `String`. It will
    return a string made up of the name assigned to it, by calling the superclass
    `getName` method, and the current value of `actionCounter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Thread classes must override the superclass `run` method. This is where the
    work of a thread happens. In this case, we are using an infinite `while` loop
    in which we are displaying this object’s thread name and the current value of
    `actionCounter`. When `actionCounter` reaches zero, we return from the `run` method
    and the thread ends. The use of an infinite look syntax, `while (true)`, means
    that the decision to end the loop is based on something that is happening in the
    loop, which, in this case, is decrementing `actionCounter` until it reaches zero.
    This is not the only way to write a `run` method, but it is the most common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With our threaded class in place, we can now write a class that will instantiate
    and run each of the threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in `perform`, we are instantiating five instances of `ThreadClass`. We
    call `start` and not `run`. The `start` method is an override of the `Thread`
    superclass’s `start` method, and it is responsible for setting up the thread and
    then calling the `run` method. Calling the `run` method yourself will not start
    a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Threads are not deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important point to always be aware of. Each time you run this example
    code, the output will be different. The threads will execute in an order unrelated
    to the order they were created. Run this example a few times and take note that
    the order of the results is different every time.
  prefs: []
  type: TYPE_NORMAL
- en: There is one problem with this approach. You cannot extend any other superclass
    in `ThreadClass`. This brings us to the second approach.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Runnable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this approach, we implement the `Runnable` interface. We are performing
    the same task as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are calling `Thread.currentThread().getName()` to retrieve the name of this
    thread. When we extended the `Thread` class, we could call `getName`. As we are
    implementing the `Runnable` interface, we do not have superclass methods to call.
    We now get the name by using static methods of the `Thread` class, which will
    return information about the current thread that calls these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run` method is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `perform` method in the class that starts the threads is different when
    using the `Runnable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We create these threads by instantiating a `Thread` class, passing to its constructor
    an instance of the `Runnable` thread class along with the thread’s name. In this
    example, the `Thread` object is anonymous; we do not assign it to a variable,
    and on it, we call `start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the previous example, the output will be different for each run.
  prefs: []
  type: TYPE_NORMAL
- en: Which technique should you use? The current best practice is to prefer the `Runnable`
    interface. This permits you to extend another class while it’s still being threaded.
    Let us look at thread pooling.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread pool with ExecutorService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have seen so far requires us to create a thread for every instance of
    the `Thread` class. An alternative approach is to create a pool of threads that
    can be reused. This is where the `ExecutorService` approach comes in. With this,
    we can create a pool of threads while, at the same time, defining the maximum
    number that can run concurrently. If more threads are required than the pool allows,
    then threads will wait until an executing thread ends. Let us change our basic
    example to use this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a class that implements `Runnable`. The `actionCounter` field
    is the number we will count down from in the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we will leave the creation of the `Thread` class to `ExecutorService`, we
    no longer have a constructor that accepts `String` for the name of the thread.
    We will pass the name as `int` to the constructor and store it here. Fields in
    a class that becomes a single thread will each have their own `actionCounter`
    and `threadCount` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the constructor that takes the name we want to know the thread by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We are overriding the `toString` method to return `String` with the current
    thread’s name, which is assigned by `ExecutorService`, along with the name we
    assigned to `threadCount` as a number, followed by the current value of `actionCounter`,
    which decreases while the thread runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method is `run`. This remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us look at how we use `ExecutorService` to create the threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I have chosen to make the variables we use as fields. They could all just be
    declared as local variables in a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor now has the responsibility to instantiate `ExecutorService`,
    along with an array of `Runnable` threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We add threads to `ExecutorService` using the `execute` method. We do not need
    access to the threads, so they are instantiated anonymously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The service will shut down after all threads have finished. You can no longer
    add any threads to the service after this method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We end this class with the usual `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These three approaches allow you to easily create threads. One issue that they
    all share is that when the thread ends, it does not return a value because `run`
    is void. We can resolve this, if needed, by combining `ExecutorService` with a
    third type of threaded class by using the `Callable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Callable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In each of the thread classes we have seen, they have all had a `run` method
    that returned void when the thread ended. This leads us to the `Callable` interface.
    Using this interface, the end of a thread returns a value. We can only use this
    technique if we use `ExecutorService`. Let’s begin by looking at a `Callable`
    thread class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the class that we want to thread. We implement the `Callable`
    interface, and using generic notation, we state that the value returned when the
    thread ends will be a string. The fields, constructor, and `toString` are the
    same as `ExecutorThreadingInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we replace `run` with `call` and show a return type. The `return` statement
    will display the thread name that we assigned as an integer to each thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us look at the runner for this `Callable` thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first variable we are declaring is `List` of the `Future` type. `Future`
    is an interface, like `List`. When we use, not execute, the `submit` method of
    `ExecutorService`, it returns an object that implements the `Future` interface.
    Objects that implement this interface represent the result of an asynchronous
    task. When we instantiate this object in a few lines from here, it will be `List`
    of `Future` strings that are delivered by the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A new feature in this example is the display of the current date and time that
    each thread ends. The `DateTimeFormatter` object converts an `LocalDateTime` object
    into a readable string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor instantiates the class fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We instantiate `futureList` as `ArrayList`. We follow this by defining the
    format of the date and time we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `submit` to submit the threads to the `ExecutorService`. Using
    `submit` implies that we expect a return of type `Future`. We also add each `Future`
    object to an `ArrayList` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we cycle through the `ArrayList` instance displaying the current date
    and time along with the thread’s returned value – in this example, `String`. We
    access the return value of the `Future` object by calling the `get` method. This
    is a blocking method call. Each `Future` object is associated with a specific
    thread, and `get` will wait for its result before it allows the next `Future`
    object’s `get` to execute. A call to `get` can result in two checked exceptions,
    so we must place the call in a `try`/`catch` block. For the purpose of this example,
    we are just printing the stack trace. You should never just print a stack trace
    without taking any appropriate action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`ExecutorService` must be explicitly shut down when you no longer need the
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We end this with the usual `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have reviewed the most common approaches to creating `Threads`,
    let us look a little deeper at how we can manage a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Managing threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three `Thread` methods that are commonly used to manage a thread.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sleep()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `yield()` method informs the thread scheduler that it can give up its current
    usage of the processor but wishes to be rescheduled as soon as possible. This
    is only a suggestion, and the scheduler is free to do what it wishes. This makes
    it non-deterministic as well as dependent on the platform it is running on. It
    should only be used when it can be proved, usually by profiling the code, that
    it can improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: The `join()` method can be useful when one thread (we will call it `join()`
    affects the first thread that created the second thread. There are two additional
    overloaded versions of join that allow you to set the length of time to block
    the thread that started it in either milliseconds, or milliseconds and nanoseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The final method is a static method of the `Thread` class. The `sleep()` method
    pauses the thread it is executed in for a specific length of time. The time can
    be, like join, in milliseconds, or milliseconds and nanoseconds.
  prefs: []
  type: TYPE_NORMAL
- en: One characteristic of both `join()` and `sleep()` is that they can throw checked
    exceptions. They must be coded inside a `try`/`catch` block. The following is
    a thread class that instantiates and starts a second class but then joins the
    second class, thus blocking itself until the thread it started finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is like the first `ThreadClass` instance we had seen. The difference is
    that it instantiates another thread class and then starts that thread at the beginning
    of the `run` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start the second thread, and it will now execute as determined by
    the scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When the first thread reaches 225, we issue a join on the second thread. The
    result will be that the first thread is blocked, and the second thread will run
    till it finishes before unblocking the first thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Daemon and non-daemon threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *daemon* refers to what is considered a low-priority thread. What this
    means is that any such native threads designated as daemons will end, regardless
    of what they are doing at that moment in time when the application’s main thread
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: A non-daemon thread, the default for when a native thread is created, will block
    the application’s main thread from ending until the thread completes its task.
    This tells us that non-daemon threads must have an ending condition. A daemon
    thread does not need an ending condition, as it will end with the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set a native thread to be a daemon with a simple method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can only call this method on a thread after it has been instantiated but
    before it has started. You cannot change the daemon status after it starts. Calling
    this method will result in an exception being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Thread priority
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As already pointed out, threads are non-deterministic. This means we have no
    absolute control over when a thread will get its slice of time to run or how long
    that time slice will be. We can make a suggestion, also called a hint, and that
    is where thread priority comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The range of possible values for thread priority is 1 through 10\. There are
    three defined static constants that are used in most cases rather than a number.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Thread.MAX_PRIORITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.MIN_PRIORITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.NORM_PRIORITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this suggests, you cannot rely on maximum priority getting more time slices
    than minimum priority. It should get more slices, and that is the best that you
    can hope for.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to manage our threads, let us look at one more topic,
    thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing race and deadlock conditions in threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two common problems that can cause problems with threaded code. The
    first is the race condition. This is what can happen when two or more threads
    work with a block of code that changes a variable shared by all the threads.
  prefs: []
  type: TYPE_NORMAL
- en: The second is the deadlock condition. To resolve race conditions, you lock a
    block of code. If multiple threads use the same lock object, then you could have
    a situation where these threads are waiting for each other to finish with the
    lock but none finish. Let us look more closely at these two conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Race condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where you share a reference to an object among multiple threads.
    Calling upon methods in this shared class that only use local variables is thread-safe.
    Thread-safe, in this case, occurs because each thread maintains its own private
    stack for local variables. There can be no conflict between threads.
  prefs: []
  type: TYPE_NORMAL
- en: It is a different story if the shared object’s methods access and alter a class
    field. Unlike local variables, class fields are unique to the shared object and
    every thread that calls methods in this class is possibly altering a field. Operations
    on these fields may not finish before the thread’s time slice ends. Now, imagine
    that a thread expects a field to have a specific value based on the last time
    slice that accessed the field. Unbeknown to it, another thread has changed that
    value. This results in what is referred to as a race condition. Let us look at
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple class that adds a passed value to a field of the class called
    `counter` and returns the result of adding the value. Every time we call `addUp`,
    we expect the `counter` field to change the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'How much time a thread gets from the scheduler is related to the CPU of your
    computer. A high clock rate along with multiple CPU cores sometimes permits a
    thread to complete its task before the next thread takes over. For that reason,
    I have slowed down the `addUp` method by having it sleep for a half second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The threaded class is based on `ThreadClass` we have already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a field for holding a reference to an `Adder` object. No matter how
    many threads we create, they will all share the field variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor receives a reference to the `Adder` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are printing information on this thread and the current value from
    the `addUp` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have two threads of type `SynchronizedThreadClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we instantiate each thread, we create a single `Adder` object that we
    share with each threaded class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is not yet synchronized. Here is a table of results when access to
    the adder is not synchronized:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Unsynchronized** |'
  prefs: []
  type: TYPE_TB
- en: '| **Thread** | **Thread** **class actionCounter** | **Adder** **class counter**
    |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 4 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 4 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 3 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 3 | 14 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 2 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 2 | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 1 | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 1 | 20 |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – The results from running the code unsynchronized
  prefs: []
  type: TYPE_NORMAL
- en: The expectation is that the `Adder` class counter should count from 2 to 20\.
    It does not. The first thread begins adding the value passed, 2, to the counter.
    But before it can display its result, the second thread comes along and adds 2
    to the same counter, now increasing the value to 4\. When we return to the first
    thread that will just display the result, it is now 4, and not the value of 2
    that it had when its first time slice ended. If you run this multiple times, the
    results will be different, but we will see this problem in other places in the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us synchronize the code. Synchronizing applies a lock to a section
    of code commonly called a critical section. The lock is a reference to an object,
    as all objects, by virtue of their `Object` superclass, can be used as a lock.
    We only need to change the `Adder` class and specifically the `addUp` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As the entire method is considered a critical section, we can remove the synchronize
    block and apply the `synchronized` keyword to the method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the table of results using the synchronized version of the `addUp`
    `Adder` class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Synchronized** |'
  prefs: []
  type: TYPE_TB
- en: '| **Thread** | **Thread** **class actionCounter** | **Adder** **class counter**
    |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 4 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 4 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 3 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 3 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 2 | 14 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 2 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| #1 | 1 | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| #2 | 1 | 20 |'
  prefs: []
  type: TYPE_TB
- en: Table 9.2 – The results from running the code synchronized
  prefs: []
  type: TYPE_NORMAL
- en: You can see that every value from 2 to 20 appears.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you are always looking for tasks that can be carried out concurrently.
    Once identified, you will apply threading where appropriate. Any long-running
    task is a candidate for a thread. User interfaces typically run the interface
    in one or more threads, and as tasks are selected from menus or buttons, they
    too are run in threads. This means that the user interface can respond to you
    even while it is performing a long-running task.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at a problem that can arise if we synchronize blocks of code
    with the same lock object improperly.
  prefs: []
  type: TYPE_NORMAL
- en: Deadlock condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A thread deadlock occurs when thread locks get intertwined, especially if a
    thread is nested inside another one. This results in each thread waiting for the
    other to end. When using synchronize, a lock can be any object or class in Java
    that will protect a critical section, usually to avoid the race condition. You
    can also create objects of type `Lock` or `ReentrantLock`. Either approach, as
    we shall see, can result in a deadlock. Deadlock can be difficult to recognize,
    as it does not crash the program or throw an exception. Let us look at an example
    of code that will be deadlocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the class that will create the lock objects and then we start
    two threads with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the two lock objects we will use with synchronize in `Thread1` and
    `Thread2`. Any object in Java, either one you create or one that already exists,
    such as `String`, can be used as a lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us look at the class that extends `Thread`. Take note of the fact
    that `Thread1` uses `lock1` before `lock2`, while `Thread2` uses `lock2` before
    `lock1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `run` method, we have a synchronized block that uses `lock1` and then
    a nested synchronized block that uses `lock2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `run` method, we have a synchronized block that uses `lock2` and then
    a nested synchronized block that uses `lock1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is now deadlocked, and both threads are waiting for the other thread
    to finish. If we change the order of the locks we use so that both use `lock1`
    first and `lock2` second, we will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The deadlock condition is solved. Deadlocks are rarely this obvious, and you
    may not even be aware that there is a deadlock happening. You need a thread dump
    to determine whether there is a deadlock in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s one final point on this topic – rather than using an instance of the
    `Object` class as the lock, you can use the `Lock` class. The syntax is a little
    different, and you can ask a `Lock` object whether it is being used. The following
    code snippet shows what it will look like, but it does not solve the deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` class, the locks will use the `Lock` interface with the `ReentrantLock`
    class that implements the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we are passing the `Lock` objects to the class through the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we do not use a synchronized block, but instead, we call `lock` on
    `lock1`, and when the critical section is finished, we issue `unlock` on `lock1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: One advantage of using `lock` objects rather than a synchronized block is that
    the call to `unlock` does not have to be in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading is a powerful feature of Java that you should use when appropriate.
    What we saw is based on native threading available in Java from version 1.0\.
    Recently, a new type of threading was introduced. Let us look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new virtual threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As pointed out at the beginning of the previous section, native Java threads
    are managed by the JVM by working directly with the OS’s threading library. There
    is a one-to-one relationship between a native thread and an OS thread. This new
    approach is called **virtual threads**. While native threads are managed by the
    JVM in collaboration with the OS, virtual threads are managed exclusively by the
    JVM. OS threads are still used, but what makes this approach significant is that
    virtual threads can share OS threads and are no longer one-to-one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual threads do not run faster and can suffer from race and deadlock conditions.
    What is special with virtual threads is that the number of threads that you can
    start up could be in the millions. How we use virtual threads is not much different
    from native threads. The following code snippet shows the `perform` method that
    we saw in the previous examples creating virtual threads. The thread class is
    unchanged, thus making the use of a virtual thread rather than a native thread
    quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating a virtual thread and starting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: I must embarrassingly admit that it took me 3 days to get this code to work.
    Why? I neglected an important characteristic of virtual threads – they are daemon
    threads. Attempting to make them non-daemon has no effect. What was happening
    to me is that the program would end before any output appeared, or only some appeared
    but not all of the expected output from the threads. When `perform` ended and
    returned to the `main()` method, the main native thread ended. When this happened,
    all daemon threads were ended. My PC executed `perform`, returned to `main`, and
    ended before a single virtual thread could display its output.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the solution I used to make this code work. I called `Thread.sleep()`.
    This puts the current thread to sleep for a specified length of time. In this
    case, 500 milliseconds was enough time for the virtual threads to complete all
    their tasks before the main thread ended.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you cannot change the priority of virtual threads. They all run at
    `NORM_PRIORITY`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the start of this chapter, Java’s native support of threads
    is one of the reasons for its popularity. In this chapter, we saw how we can create
    threads by extending the `Thread` class and by implementing either a `Runnable`
    or `Callable` interface. We saw how `ExecutorService` allows us to pool threads.
    We concluded by looking at one specific issue, where two or more threads compete
    for access to a shared resource, called a race condition, and saw how we resolve
    this by applying locks through the application of synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: There are changes coming to threading. Project Loom, at the time of writing,
    introduces threads managed exclusively by the JVM along with a framework for concurrency.
    Some features are in preview, while others are in incubation. It will be a few
    years before these new types of threads become commonplace. I recommend following
    the development of this project.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will look at the most used design patterns in Java development.
    These patterns will provide us with well-established approaches to organizing
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating and Starting Java* *Threads*: [https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html](https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Thread Pools in* *Java*: [https://www.baeldung.com/thread-pool-java-and-guava](https://www.baeldung.com/thread-pool-java-and-guava)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deadlock in Java* *Multithreading*: [https://www.geeksforgeeks.org/deadlock-in-java-multithreading/](https://www.geeksforgeeks.org/deadlock-in-java-multithreading/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a book from 2006, that remains one of the finest references on threading
    in Java: *Java Concurrency in Practice, 1st Edition*, by Brian Goetz with Tim
    Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (ISBN-13: 978-0321349606)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 425: Virtual* *Threads*: [https://openjdk.org/jeps/425](https://openjdk.org/jeps/425)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
