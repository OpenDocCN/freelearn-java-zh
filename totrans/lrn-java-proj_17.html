<html><head></head><body>
		<div id="_idContainer280">
			<h1 id="_idParaDest-430" class="chapter-number"><a id="_idTextAnchor430"/>17</h1>
			<h1 id="_idParaDest-431"><a id="_idTextAnchor431"/>Concurrency</h1>
			<p>In the previous chapter, we explored the nuances of streamlined data manipulation and parallelized operations that utilize the power of modern multi-core processors. This was already a little introduction to this chapter’s <span class="No-Break">topic: concurrency!</span></p>
			<p>Concurrency allows applications to perform multiple tasks at the same time. This makes the system more efficient. Any available resources can be utilized more efficiently, and this leads to overall improved performance. In order to do multiple things at the same in Java, we need to know quite a bit. That’s what this chapter <span class="No-Break">is for!</span></p>
			<p>Here’s what <span class="No-Break">we’ll cover:</span></p>
			<ul>
				<li>A definition <span class="No-Break">of concurrency</span></li>
				<li>Working <span class="No-Break">with threads</span></li>
				<li><span class="No-Break">Atomic classes</span></li>
				<li>The <span class="No-Break">synchronized keyword</span></li>
				<li>Using locks for exclusive <span class="No-Break">thread access</span></li>
				<li><span class="No-Break">Concurrent collections</span></li>
				<li><span class="No-Break">Using </span><span class="No-Break"><strong class="source-inline">ExecutorService</strong></span></li>
				<li>Common threading problems and how to <span class="No-Break">avoid them</span></li>
			</ul>
			<p>This is often a dreaded (or threaded?) topic, especially for new developers, so don’t despair if you need to go over parts of this chapter twice. I’m going to try my best to carefully walk you through all the concepts you need to know. Unlike your applications, focus solely on this chapter and don’t do other things simultaneously. Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-432"><a id="_idTextAnchor432"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch17"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch17</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-433"><a id="_idTextAnchor433"/>Understanding concurrency</h1>
			<p>Have you ever wondered how many tasks a computer can truly run simultaneously? It’s tempting to say <em class="italic">several</em>, yet, in reality, a single-core computer can only execute one process at a given instant. This might appear as simultaneous due to the impressive speed at which CPUs switch between processes, thus creating the illusion of <span class="No-Break">simultaneous multitasking.</span></p>
			<p>Concurrency is the concept of executing multiple tasks or threads at the same time, rather than sequentially. In a <a id="_idIndexMarker1420"/>sequential system, tasks are executed one after the other, with each task waiting for its predecessor to complete <span class="No-Break">before starting.</span></p>
			<p>For our Java applications, concurrency refers to executing different segments of a program, simultaneously. The term <em class="italic">simultaneously</em> might be a little ambiguous here, as it could mean multiple things – and that is because concurrency can occur at the hardware level, such as in multi-core processors, or at the software level. An OS could schedule threads to run on <span class="No-Break">different cores.</span></p>
			<p>Which one we mean exactly depends on the type of concurrency being employed. An overview of them can be found in <span class="No-Break"><em class="italic">Figure 17</em></span><em class="italic">.1</em>. These can be any of <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Multiprocessing</span></li>
				<li><span class="No-Break">Multitasking</span></li>
				<li><span class="No-Break">Multithreading</span></li>
			</ul>
			<p> First off, let’s <span class="No-Break">discuss multiprocessing.</span></p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor434"/>Multiprocessing</h2>
			<p>In the context of <strong class="bold">multiprocessing</strong>, the simultaneous execution of diverse processes is facilitated by the <a id="_idIndexMarker1421"/>presence of multiple CPUs. Each CPU independently <a id="_idIndexMarker1422"/>executes its own process. To draw a parallel from our daily life, consider two individuals managing a household where one person is occupied with childcare, while the other is out for grocery shopping. They are both a “CPU,” each taking care of a unique <span class="No-Break">task concurrently.</span></p>
			<h2 id="_idParaDest-435"><a id="_idTextAnchor435"/>Multitasking</h2>
			<p>The next concept is <strong class="bold">multitasking</strong>, where the term “simultaneous” obtains a slightly different <a id="_idIndexMarker1423"/>connotation. It implies rapid alternating execution rather than literal <a id="_idIndexMarker1424"/>simultaneous execution. Imagine a scenario where a person is cooking and intermittently stepping out to hang laundry while the pot is cooking (safely away from the kids, of course). They are the “CPU,” continuously switching between two (or more) tasks, giving the illusion of simultaneous progression. This, however, doesn’t exactly constitute parallel execution, but it is a very efficient use of resources <span class="No-Break">for sure.</span></p>
			<h2 id="_idParaDest-436"><a id="_idTextAnchor436"/>Multithreading</h2>
			<p>Last but not least, we have <strong class="bold">multithreading</strong> – and that happens to be our primary focus. Multithreading involves different sections of the program running on different threads of execution. This <a id="_idIndexMarker1425"/>can take place in both single- and multi-CPU <a id="_idIndexMarker1426"/>environments. Both previously mentioned everyday scenarios can <span class="No-Break">exemplify multithreading.</span></p>
			<div>
				<div id="_idContainer279" class="IMG---Figure">
					<img src="image/B19793_17_01.jpg" alt="Figure 17.1 - Schematic overview of multiprocessing, multitasking, and multithreading"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 - Schematic overview of multiprocessing, multitasking, and multithreading</p>
			<p>We <a id="_idIndexMarker1427"/>will delve <a id="_idIndexMarker1428"/>deeper into the concept of threads shortly. Let’s first talk about why we need to have concurrency in our applications (or <span class="No-Break">lives actually!).</span></p>
			<h2 id="_idParaDest-437"><a id="_idTextAnchor437"/>Importance of concurrency in modern applications</h2>
			<p>To help you visualize concurrency in computing, consider the way your computer runs multiple programs <a id="_idIndexMarker1429"/>at the same time. You might have a browser, an email client, a text editor, a code editor, and Slack running concurrently. This kind of operation demands the ability to manage multiple processes concurrently. It’s also seen within applications, such as an IDE processing your input while executing code. Without some sort of concurrency, stopping a script with an infinite loop would be impossible, as the IDE would be too consumed with the execution of the infinite loop to deal with your click on <span class="No-Break">the button.</span></p>
			<p>And let’s think of web services for a second; imagine a web server processing hundreds, even thousands, of requests concurrently. Such an operation would be unfeasible without concurrency, so it’s safe to say that concurrency is an essential aspect of our day-to-day computer use and even <span class="No-Break">daily life!</span></p>
			<p>Let’s sum up <span class="No-Break">the advantages:</span></p>
			<ul>
				<li><strong class="bold">Improved performance</strong>: Applications can complete <span class="No-Break">operations faster</span></li>
				<li><strong class="bold">Responsiveness</strong>: Applications <a id="_idIndexMarker1430"/>remain responsive even when performing resource-intensive tasks (as background threads can handle these tasks without blocking the <span class="No-Break">main thread)</span></li>
				<li><strong class="bold">Resource utilization</strong>: More efficient use of system resources by taking advantage of multi-core processors and other <span class="No-Break">hardware resources</span></li>
			</ul>
			<p>Advantages like this, make real-time execution use cases possible. At this point, you might be very enthusiastic about concurrency. And you should be! However, employing <a id="_idIndexMarker1431"/>concurrency in our Java applications does come with its own set of costs and complexities. Let’s talk <span class="No-Break">about it.</span></p>
			<h2 id="_idParaDest-438"><a id="_idTextAnchor438"/>Challenges in concurrent programming</h2>
			<p>I’ve said it before, and I’ll say it again: every magic trick comes with a price. While concurrency <a id="_idIndexMarker1432"/>offers many benefits, it also introduces challenges that can make concurrent programming complex and even error-prone. We even have some errors that are unique to concurrent environments. We’ll mention them in more detail later, but it’s good to keep these in mind before <span class="No-Break">diving in:</span></p>
			<ul>
				<li><strong class="bold">Data race</strong>: When multiple threads access the same memory location in a non-synchronized manner and at least one of these threads performs a write. For example, one thread wants to read the value and concludes the value is 5, but the other thread increments to 6. This way, the former thread doesn’t have the <span class="No-Break">latest value.</span></li>
				<li><strong class="bold">Race condition</strong>: A problem that occurs due to the timing and order of events. This problematic order of events can influence the correctness of the outcome. A race condition typically requires external input, from the OS, hardware, or even user. It can, for example, happen when two users try to sign up with the same username at the same. When not handled well, this can lead to unpredictable and <span class="No-Break">undesirable results.</span></li>
				<li><strong class="bold">Deadlocks</strong>: When two or more threads are waiting for each other to release a resource, a deadlock can occur, causing the application to become unresponsive. For example, when you think your friend will call you and you wait until they do, and your friend thinks you’ll call them and they wait until you do, nothing happens, and the friendship <span class="No-Break">is stuck.</span></li>
				<li><strong class="bold">Livelocks</strong>: Similar to deadlocks, livelocks occur when two or more threads are stuck in a loop, unable to progress due to constantly changing conditions. Let’s say you and your friend said you’d meet up at a church in the city center. You are at church <em class="italic">a</em>, and your friend is at church <em class="italic">b</em>. You wonder whether your friend is at church <em class="italic">b</em> and you walk there. Your friend wonders if you are at church <em class="italic">a</em> and walks there. (And you take a different path and don’t bump into each other.) You don’t find each other at the church and keep on walking from church <em class="italic">a</em> to church <em class="italic">b</em>. Not a very effective use of resources (but all the walking is probably great for <span class="No-Break">your health!).</span></li>
			</ul>
			<p>Starvation: When a thread is unable to obtain the resources it needs to progress, it can experience starvation, leading to poor application performance and inefficient use of resources. A <a id="_idIndexMarker1433"/>real-life example could be a busy bar where multiple people are trying to acquire a drink from the bartender. There are a lot of people at the bar; the people represent threads. The bartender is serving the people who shout the loudest (comparable to threads with higher priority). The shy person that doesn’t stand out experiences “starvation” (or thirst) because he doesn’t get access to the shared resource (<span class="No-Break">the bartender).</span></p>
			<p>Challenges are there to be overcome! Java provides various concurrency constructs and tools, which we will explore throughout this chapter. I will refer to these aforementioned problems every now and then. At the end of the chapter, you’ll even see some examples of how to break things! But first, let’s talk about a key concept of <span class="No-Break">concurrency: threads!</span></p>
			<h1 id="_idParaDest-439"><a id="_idTextAnchor439"/>Working with threads</h1>
			<p>Let’s finally get to explaining <em class="italic">threads</em>. Threads are sequences <a id="_idIndexMarker1434"/>of executed instructions, representing the most fundamental units of execution. Each thread follows a <a id="_idIndexMarker1435"/>certain path through the code. The threads perform specific tasks within processes. A process is typically composed of <span class="No-Break">multiple threads.</span></p>
			<p>To give you an example, the programs we’ve created so far had one user-created thread (and the user in this case is the developer). The thread went through the lines of code in a certain order; for example, when a method was called, the thread would execute that method before continuing with the code that was directly on the next line after the method call. This is the path of execution of <span class="No-Break">the thread.</span></p>
			<p>When multiple threads are running, multiple paths of execution are being walked through your code, and that’s why multiple things are happening at the <span class="No-Break">same time.</span></p>
			<p>In order to make this possible, we’ll need duplicates of certain Java constructs. For example, we cannot have two threads using the same stack. That’s why every thread has its own stack. We will not dive into the details of the Java memory model here. However, it helps to at least realize that while each thread has its own stack, they share the heap with <span class="No-Break">other threads.</span></p>
			<p>In order to make this digestible for your brain, we’ll explain the theory with some not-too-interesting but easy-to-follow examples.. We’ll start with threads. There are multiple ways to create and start a thread. Let’s see how we can create a thread using the <span class="No-Break"><strong class="source-inline">Thread</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-440"><a id="_idTextAnchor440"/>The Thread class</h2>
			<p>Possibly the simplest way to create a thread is by extending the <strong class="source-inline">Thread</strong> class. The <strong class="source-inline">Thread</strong> class provides an <a id="_idIndexMarker1436"/>entry point for your thread’s execution through the <strong class="source-inline">run()</strong> method. To create a custom thread, you need to define a subclass of <strong class="source-inline">Thread</strong> and override the <strong class="source-inline">run()</strong> method with the code that the thread should execute. Here’s a silly example to <span class="No-Break">demonstrate this:</span></p>
			<pre class="source-code">
class MyThread extends Thread {    @Override
    public void run() {
        System.out.println("Hello from MyThread!");
    }
}</pre>
			<p>And then in <a id="_idIndexMarker1437"/>some other class (or even in the same but that might be confusing), we can create a new <strong class="source-inline">MyThread</strong> and kick off the thread execution with the <span class="No-Break"><strong class="source-inline">start()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
public class Main {    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start(); // starts the new thread
    System.out.println("Hello from Main!");
    }
}</pre>
			<p>This will output the following two lines, but we cannot be sure about <span class="No-Break">the order:</span></p>
			<pre class="console">
Hello from MyThread!Hello from Main!</pre>
			<p>The <strong class="source-inline">start()</strong> method is part of the <strong class="source-inline">Thread</strong> class that we inherited from and it is used to start a new thread. You could also execute the content of the <strong class="source-inline">run()</strong> method by calling <strong class="source-inline">myThead.run()</strong>, but that would not start a new thread! That would be the same thread as the one executing the <strong class="source-inline">main</strong> method, which would be executing the content of the <span class="No-Break"><strong class="source-inline">run()</strong></span><span class="No-Break"> method.</span></p>
			<p>We started with this way <a id="_idIndexMarker1438"/>to create a thread because it is easiest to understand. It’s definitely not the most common way. It’s more common to implement the <strong class="source-inline">Runnable</strong> interface. Let’s see how to <span class="No-Break">do that.</span></p>
			<h2 id="_idParaDest-441"><a id="_idTextAnchor441"/>The Runnable interface</h2>
			<p>An alternative approach to creating <a id="_idIndexMarker1439"/>threads is by implementing the <strong class="source-inline">Runnable</strong> interface. This is a built-in functional interface that can be used to create threads in Java. The <strong class="source-inline">Runnable</strong> interface has a single method, <strong class="source-inline">run()</strong>, that you must implement in your class when you extend this interface. Instead of extending the <strong class="source-inline">Thread</strong> class, you pass an instance of your <strong class="source-inline">Runnable</strong> implementation to a <strong class="source-inline">Thread</strong> object. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
class MyRunnable implements Runnable {    @Override
    public void run() {
        System.out.println("Hello from MyRunnable!");
    }
}</pre>
			<p>And again, we can now instantiate <strong class="source-inline">MyRunnable</strong> at another spot. The second step is different though; we are going to instantiate the <strong class="source-inline">Thread</strong> class and pass our instance of <strong class="source-inline">MyRunnable</strong> to its constructor. This way, when we start the instance of the thread, whatever we specified in the <strong class="source-inline">run()</strong> method of the <strong class="source-inline">Runnable</strong> instance will <span class="No-Break">be executed:</span></p>
			<pre class="source-code">
public class Main {    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // starts the new thread
    }
}</pre>
			<p>This will output <span class="No-Break">the following:</span></p>
			<pre class="console">
Hello from MyRunnable!</pre>			<p>And again, to execute what is in <strong class="source-inline">MyRunnable</strong>’s <strong class="source-inline">run</strong> method, we could have written <strong class="source-inline">myRunnable.run()</strong>, but <a id="_idIndexMarker1440"/>this also would not have started a new thread! Let’s prove that we actually start a new thread. Every thread has a unique ID. By outputting the ID of the thread in the <strong class="source-inline">run</strong> method, we can prove it’s a different thread. Here’s the adjusted example <span class="No-Break">for that:</span></p>
			<pre class="source-code">
class MyRunnable implements Runnable {    @Override
    public void run() {
        System.out.println("Hello from thread: " + Thread.
          currentThread().threadId());
    }
}</pre>
			<p>And here’s our adjusted <span class="No-Break"><strong class="source-inline">Main</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public class Main {    public static void main(String[] args) {
        System.out.println("Hello from main: " + Thread.
          currentThread().threadId());
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // starts the new thread
    }
}</pre>
			<p>This will print <span class="No-Break">the following:</span></p>
			<pre class="console">
Hello from main: 1Hello from thread: 22</pre>
			<p>Please note that the IDs might be different for you, but they will also be two different threads. The thread IDs remain <a id="_idIndexMarker1441"/>consistent across multiple executions due to some background threads started by Java such as the garbage collector. Say we change the <strong class="source-inline">start()</strong> method to <strong class="source-inline">run()</strong>, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public static void main(String[] args) {        System.out.println("Hello from main: " + Thread.
          currentThread().threadId());
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.run(); // doesn't start a new thread
    }</pre>
			<p>The IDs are the same; this is <span class="No-Break">the result:</span></p>
			<pre class="console">
Hello from main: 1Hello from thread: 1</pre>
			<p>This is already a bit more common, but more often we don’t create a class for <strong class="source-inline">Runnable</strong> and rather implement <strong class="source-inline">Runnable</strong> with a lambda expression. As you might be able to recall from the Lambda expression <em class="italic">Chapters 15</em> and <em class="italic">16</em>, we can implement any functional interface with a lambda expression. Let’s see how that <span class="No-Break">is done.</span></p>
			<h2 id="_idParaDest-442"><a id="_idTextAnchor442"/>Lambda expressions with Runnable</h2>
			<p>Since the <strong class="source-inline">Runnable</strong> interface is<a id="_idIndexMarker1442"/> a functional interface with a single method, you can use lambda expressions to create <a id="_idIndexMarker1443"/>and run threads more concisely. Here’s an example using a <span class="No-Break">lambda expression:</span></p>
			<pre class="source-code">
public static void main(String[] args) {    Runnable myRunnable = () -&gt; System.out.println("Hello
      from a lambda Runnable!");
    Thread thread = new Thread(myRunnable);
    thread.start(); // starts the new thread
}</pre>
			<p>As you <a id="_idIndexMarker1444"/>can see, we don’t need a separate class for <strong class="source-inline">Runnable</strong> anymore. We can just do it <em class="italic">on the fly</em>. Here’s <span class="No-Break">the output:</span></p>
			<pre class="console">
Hello from a lambda Runnable!</pre>			<p>And as I <a id="_idIndexMarker1445"/>mentioned a few times before, if you use <strong class="source-inline">run()</strong> instead of <strong class="source-inline">start()</strong>, you are getting the same output in this case, but this is not done by a <span class="No-Break">new thread.</span></p>
			<p>These are the basics of how to create threads. Let’s see how we can control the execution with <strong class="source-inline">sleep()</strong> and <strong class="source-inline">join()</strong>. So, join me for <span class="No-Break">some sleep!</span></p>
			<h1 id="_idParaDest-443"><a id="_idTextAnchor443"/>Thread management – sleep() and join()</h1>
			<p>This might <a id="_idIndexMarker1446"/>be a weird statement, but threads can go to <em class="italic">sleep</em>. This means that the execution of the thread gets paused for a short while. Before we dive into how to do this, it is worth noting that this is something that is often considered to be a code smell. This means that it can be a problematic solution to, for example, a data race or a challenge with loading times. However, sometimes you will need this – for example, to slow down a background thread. Just make sure to proceed with caution here. Let’s see how we can make our threads go to <span class="No-Break">sleep now.</span></p>
			<h2 id="_idParaDest-444"><a id="_idTextAnchor444"/>The Thread.sleep() method</h2>
			<p>The <strong class="source-inline">Thread.sleep()</strong> method is a static method that causes the currently executing thread to go to <a id="_idIndexMarker1447"/>sleep. That means pausing its execution for a specified period. It is useful for simulating delays, allowing other threads to execute, or performing time-based operations. The <strong class="source-inline">sleep()</strong> method takes a single argument, the duration of the sleep in milliseconds. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
public class Main {    public static void main(String[] args) {
        Thread t = new Thread(() -&gt; {
            try {
      // Next two lines represent the same Java line
                System.out.println("Thread will go to sleep
                  for 2 seconds...");
                Thread.sleep(2000);
                System.out.println("*Yawn...* I'm awake!");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        t.start();
    }
}</pre>
			<p>We need the <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block here because <strong class="source-inline">sleep()</strong> can be interrupted. This interrupt would result in the checked <a id="_idIndexMarker1448"/>exception, <strong class="source-inline">InterruptedException</strong>, <span class="No-Break">being thrown.</span></p>
			<h2 id="_idParaDest-445"><a id="_idTextAnchor445"/>Handling InterruptedException</h2>
			<p>Imagine if the <a id="_idIndexMarker1449"/>main thread decides that the execution is taking too long and wants to end the program. It can <a id="_idIndexMarker1450"/>suggest the secondary thread stops by using the <strong class="source-inline">interrupt</strong> method. If the instance is called t, this can be done with <strong class="source-inline">t.interrupt()</strong>. Interrupting a sleeping thread <span class="No-Break">throws </span><span class="No-Break"><strong class="source-inline">InterruptedException</strong></span><span class="No-Break">.</span></p>
			<p>This is a checked exception that you must handle if you use the <strong class="source-inline">Thread.sleep()</strong> method. We can also make our thread wait for another thread to be done. This is done with the <span class="No-Break"><strong class="source-inline">join()</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-446"><a id="_idTextAnchor446"/>Using the join() method</h2>
			<p>Threads can <a id="_idIndexMarker1451"/>wait until another thread is done. The <strong class="source-inline">join()</strong> method allows the calling thread to wait until <a id="_idIndexMarker1452"/>the specified thread has finished its execution. This is useful when you need to ensure that a particular thread has completed its work before proceeding. Here’s an example where the main thread is waiting for <span class="No-Break">thread </span><span class="No-Break"><strong class="source-inline">t1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Main {    public static void main(String[] args) {
        Thread t1 = new Thread(() -&gt; {
            System.out.println("t1 started");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread finished!");
        });
        t1.start();
        try {
            System.out.println("Main thread will be waiting
              for other t1 to be done...");
            <strong class="bold">t1.join();</strong>
            System.out.println("Main thread continues...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</pre>
			<p>This will output <span class="No-Break">the following:</span></p>
			<pre class="console">
Main thread will be waiting for other t1 to be done...t1 started
t1 finished!
Main thread continues...</pre>
			<p>So, as you <a id="_idIndexMarker1453"/>can see, <strong class="source-inline">t1.join()</strong> is called. This makes the main thread wait until <strong class="source-inline">t1</strong> is done executing (and that includes 2 seconds of sleep) before the main thread continues. The main thread can also wait for a specified amount of time, for example, 1 second, by calling <strong class="source-inline">t1.join(1000)</strong> instead. This is a bit safer because our program would get stuck if <strong class="source-inline">t1</strong> for some reason hung indefinitely. You should go ahead and try to remove <strong class="source-inline">join()</strong> and run the program a few times to inspect the behavior and see if you can get it to <span class="No-Break">hang indefinitely.</span></p>
			<p>As you can see, we also <a id="_idIndexMarker1454"/>need to catch <strong class="source-inline">InterruptedException</strong> when we use the <strong class="source-inline">join()</strong> method. This is in case the calling thread gets interrupted while waiting for the other thread to <span class="No-Break">be done.</span></p>
			<p>Let’s have a look at how to avoid (or solve) some common issues with read and write operations in <span class="No-Break">concurrent environments.</span></p>
			<h1 id="_idParaDest-447"><a id="_idTextAnchor447"/>Atomic classes</h1>
			<p>Data integrity can easily be a problem in a concurrent program. Imagine two threads reading a value, and then both changing it and overwriting each other’s change right after. This could, for example, result in a counter that ends up being only one higher, while it should be two higher. Data integrity gets lost! This is where atomic classes <span class="No-Break">come in.</span></p>
			<p>Atomic classes are used for atomic operations. That means that the read (getting a value) and write (changing a value) are considered one <a id="_idIndexMarker1455"/>operation instead of two separate ones. This avoids the problems with data integrity that we just demonstrated. We’ll briefly discuss how to use <strong class="source-inline">AtomicInteger</strong>, <strong class="source-inline">AtomicLong</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AtomicReference</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-448"><a id="_idTextAnchor448"/>AtomicInteger, AtomicLong, and AtomicReference</h2>
			<p>There<a id="_idIndexMarker1456"/> are several atomic classes for basic data types. We have <strong class="source-inline">AtomicInteger</strong> to represent an integer value and support atomic operations on it. Similarly, we <a id="_idIndexMarker1457"/>have <strong class="source-inline">AtomicLong</strong> for the <strong class="source-inline">Long</strong> type. We<a id="_idIndexMarker1458"/> have <strong class="source-inline">AtomicReference</strong> for references to an object and to support atomic operations <span class="No-Break">on it.</span></p>
			<p>These atomic classes provide methods for performing atomic operations, such as <strong class="source-inline">get</strong>, <strong class="source-inline">set</strong>, <strong class="source-inline">compareAndSet</strong>, and various arithmetic operations. Let’s have a look at an example that would be problematic <span class="No-Break">without </span><span class="No-Break"><strong class="source-inline">AtomicInteger</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class ExampleAtomicInteger {    private static AtomicInteger counter = new
      AtomicInteger(0);
    public static void main(String[] args) throws
      InterruptedException {
        Thread thread1 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                counter.getAndIncrement();
            }
        });
        Thread thread2 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                counter.getAndIncrement();
            }
        });
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println("Counter value: " + counter);
    }
}</pre>
			<p>This code will print the <span class="No-Break">following output:</span></p>
			<pre class="console">
Counter value: 20000</pre>			<p>Without <strong class="source-inline">AtomicInteger</strong>, the value of the <strong class="source-inline">counter</strong> at the end of the program would <a id="_idIndexMarker1459"/>differ. It could be 14387, 15673, 19876, and so on. (It could not be more than 20000). This is<a id="_idIndexMarker1460"/> because multiple threads <a id="_idIndexMarker1461"/>would read it at the same time (so reading the same value) and then update it in the next operations, thereby potentially writing a lower value than the current value of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">counter</strong></span><span class="No-Break">.</span></p>
			<p>To illustrate, picture this. You’re in a room with two friends. On the table is a hat with a piece of paper in it. The piece of paper is folded and has a number on it, the number 4. All three of you need to increment the value by 1. If your friend reads the value, then puts the number back in the hat, and then starts to search the house for a piece of paper and a pen. Your other friend might read the value right after, before your friend had a chance to increment the number. The other friend has a piece of paper and pen available (quite a friend to not share with the other friend) and replaces the piece of paper with the new value 5. You then go next, read the value, see that it is 5, get your piece of paper and pen, write down the number 6 and put it in the hat. The other friend then finally comes back, and updates the piece of paper with the new value, which, according to his knowledge from when he was reading, should be 5. The final value in the hat is then 5. Even though it has been 6 before, it went back down. You and your friends behave like threads that treat reading and writing as two <span class="No-Break">different operations.</span></p>
			<p>Let’s say that you<a id="_idIndexMarker1462"/> are not just friends, but you are atomic friends. This <a id="_idIndexMarker1463"/>would mean that you would treat reading and<a id="_idIndexMarker1464"/> writing as one action. So instead of putting the piece of paper back in the hat right after reading it, you would not put it back before updating it with the new value. So now, if you would all have to increment it by 1, there would be no confusion and the value would end up <span class="No-Break">being 7.</span></p>
			<p>We have a Java way of doing this with the atomic classes. In the snippet above, the <strong class="source-inline">getAndIncrement</strong> method ensures that two threads cannot access the counter at the same time and guarantees that the counter will have the correct value. This is because getting and incrementing are not two separate operations, but one atomic operation. This is why atomic classes are particularly useful in multi-threaded environments where you need to ensure consume shared resources without using explicit synchronization. However, we can always work with explicit synchronization. Let’s explore the <strong class="source-inline">synchronized</strong> <span class="No-Break">keyword next.</span></p>
			<h1 id="_idParaDest-449"><a id="_idTextAnchor449"/>The synchronized keyword</h1>
			<p>As we’ve just seen, working <a id="_idIndexMarker1465"/>with many threads can bring potential new problems, such as data integrity. The <strong class="bold">synchronized</strong> keyword is a Java keyword that uses a lock mechanism to achieve synchronization. It is used to control access to critical sections of code for different threads. When a thread is inside a synchronized method or block, no other thread can enter any of the synchronized methods for the <span class="No-Break">same object.</span></p>
			<p>To understand the <a id="_idIndexMarker1466"/>need for synchronization, let’s consider another simple concurrent counting scenario where unexpected outcomes can occur. We have a class named <strong class="source-inline">Count</strong> with a static <strong class="source-inline">counter</strong> variable. This class also has a method, <strong class="source-inline">incrementCounter</strong>, which increments the value of <strong class="source-inline">counter</strong> <span class="No-Break">by one:</span></p>
			<pre class="source-code">
public class Count {    static int counter = 0;
    static void incrementCounter() {
        int current = counter;
        System.out.println("Before: " + counter + ",
          Current thread: " + Thread.currentThread()
            .threadId());
        counter = current + 1;
        System.out.println("After: " + counter);
    }
}</pre>
			<p>This program, when run in a <strong class="source-inline">for</strong> loop 10 times in a single-threaded environment, will behave as expected, incrementing the counter sequentially from 0 to 10.  The value of the id of the thread would also be the same since it’s a <span class="No-Break">single thread.</span></p>
			<pre class="console">
Before: 0, Current thread: 1After: 1
Before: 1, Current thread: 1
After: 2
Before: 2, Current thread: 1
After: 3
Before: 3, Current thread: 1
After: 4
Before: 4, Current thread: 1
After: 5
Before: 5, Current thread: 1
After: 6
Before: 6, Current thread: 1
After: 7
Before: 7, Current thread: 1
After: 8
Before: 8, Current thread: 1
After: 9
Before: 9, Current thread: 1
After: 10</pre>
			<p>Now, imagine instead of a single-threaded environment, we have 10 threads, and each thread is tasked to increment <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">counter</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Main {    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            new Thread(Count::incrementCounter).start();
        }
    }
}</pre>
			<p>And now we have a <a id="_idIndexMarker1467"/>problem! Here’s the output I got (yours might <span class="No-Break">be different!):</span></p>
			<pre class="console">
Before: 0, Current thread: 26Before: 0, Current thread: 29
Before: 0, Current thread: 22
Before: 0, Current thread: 30
Before: 0, Current thread: 25
Before: 0, Current thread: 31
Before: 0, Current thread: 23
Before: 0, Current thread: 24
Before: 0, Current thread: 27
Before: 0, Current thread: 28
After: 1
After: 1
After: 1
After: 1
After: 1
After: 1
After: 1
After: 1
After: 1
After: 1</pre>
			<p>The output becomes unpredictable because of a phenomenon called <em class="italic">thread interference</em>. In a <a id="_idIndexMarker1468"/>multithreaded environment, multiple threads may read and increment the value of <strong class="source-inline">counter</strong> concurrently. This concurrent modification can lead to <a id="_idIndexMarker1469"/>unexpected results, causing a loss of data integrity. This is again due to a race condition. We have seen how to solve that by using an atomic class, but we could also solve it by synchronizing the method. The best option would be the one that allows multiple threads in most part of the code, without creating data integrity problems. For this case, that would be the atomic classes. However, this is a great example to demonstrate how the <strong class="source-inline">synchronized</strong> keyword <span class="No-Break">is working.</span></p>
			<h2 id="_idParaDest-450"><a id="_idTextAnchor450"/>Using synchronized methods</h2>
			<p>To create a synchronized method, you simply add the <strong class="source-inline">synchronized</strong> keyword before the method definition. This<a id="_idIndexMarker1470"/> ensures that only one thread at a time can execute the method for a given object instance. Here’s the <span class="No-Break">updated example:</span></p>
			<pre class="source-code">
public class Count {    static int counter = 0;
    static synchronized void incrementCounter() {
        int current = counter;
        System.out.println("Before: " + counter + ",
          Current thread: " + Thread.currentThread()
            .threadId());
        counter = current + 1;
        System.out.println("After: " + counter);
    }
}</pre>
			<p>In this case, if multiple threads call the <strong class="source-inline">incrementCounter()</strong> method simultaneously, the <strong class="source-inline">synchronized</strong> keyword ensures that only one thread at a time can access the method. This prevents race conditions. Without any changes to the <strong class="source-inline">Main</strong> class, this will be the output (your thread IDs <span class="No-Break">might differ):</span></p>
			<pre class="console">
Before: 0, Current thread: 22After: 1
Before: 1, Current thread: 31
After: 2
Before: 2, Current thread: 30
After: 3
Before: 3, Current thread: 29
After: 4
Before: 4, Current thread: 28
After: 5
Before: 5, Current thread: 27
After: 6
Before: 6, Current thread: 26
After: 7
Before: 7, Current thread: 25
After: 8
Before: 8, Current thread: 24
After: 9
Before: 9, Current thread: 23
After: 10</pre>
			<p>You can imagine that <a id="_idIndexMarker1471"/>synchronizing an entire method can be inefficient. Since this makes all the threads wait outside of the method and it creates a possible bottleneck for your performance. It is very possible that part of the code in the method can be executed by multiple threads at the same time without being a threat<strong class="bold"> </strong>(sorry) to data integrity. Sometimes, you only need to synchronize a part of the method. This can be done with a <span class="No-Break">synchronized block.</span></p>
			<h2 id="_idParaDest-451"><a id="_idTextAnchor451"/>Using synchronized blocks</h2>
			<p>In some cases, you may want to synchronize only a portion of a method, rather than the entire method. To <a id="_idIndexMarker1472"/>do this, you can use a <em class="italic">synchronized block</em>. A synchronized block requires an object to lock on, and the code inside the block is executed while holding the lock. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
class Counter {    private int count;
    public void increment() {
        synchronized (this) {
            count++;
        }
    }
    public int getCount() {
        synchronized (this) {
            return count;
        }
    }
}</pre>
			<p>In this code snippet, the <strong class="source-inline">increment()</strong> and <strong class="source-inline">getCount()</strong> methods use synchronized blocks instead <a id="_idIndexMarker1473"/>of synchronized methods. The result is the same – the <strong class="source-inline">count</strong> variable is accessed and modified safely in a <span class="No-Break">multi-threaded environment.</span></p>
			<h2 id="_idParaDest-452"><a id="_idTextAnchor452"/>Synchronized methods versus synchronized blocks</h2>
			<p>It’s a best practice to <a id="_idIndexMarker1474"/>minimize the scope of synchronization to improve performance and reduce contention among threads. This concept is closely related to <strong class="bold">lock granularity</strong>, which refers <a id="_idIndexMarker1475"/>to the size or scope of the code that is being locked. The finer the granularity, the smaller the locked section, allowing more threads to execute in parallel without waiting for <span class="No-Break">each other.</span></p>
			<p>Synchronizing large sections of code or entire methods is considered coarse-grained locking and can lead to poorer performance. In this scenario, multiple threads may be queued up, waiting for a single lock to be released, which can create a bottleneck. While coarse-grained locking might be necessary for ensuring data integrity, it should be used with caution and only if there is no <span class="No-Break">other option.</span></p>
			<p>On the other <a id="_idIndexMarker1476"/>hand, fine-grained locking involves using synchronized blocks to limit the scope of synchronization to the smallest possible critical section. This allows for better concurrency, as threads are less likely to be blocked waiting for a lock, thereby improving the <span class="No-Break">system’s throughput.</span></p>
			<p>So, to achieve optimal performance without compromising data integrity, aim for fine-grained locking by using synchronized blocks whenever possible. This aligns well with the principle of minimizing the scope of synchronization. The <strong class="source-inline">synchronized</strong> keyword provides a low-level mechanism for synchronization. For more complex scenarios, consider using higher-level concurrency constructs, such as the <strong class="source-inline">Lock</strong> interface or concurrent collections. Let’s see the <strong class="source-inline">Lock</strong> <span class="No-Break">interface next!</span></p>
			<h1 id="_idParaDest-453"><a id="_idTextAnchor453"/>The Lock interface</h1>
			<p>Let’s talk about the <strong class="source-inline">Lock</strong> interface. This is an alternative to the <strong class="source-inline">synchronized</strong> keyword for handling concurrency <a id="_idIndexMarker1477"/>control. While synchronized helps us achieve thread safety, it also introduces <span class="No-Break">some drawbacks:</span></p>
			<ul>
				<li>Threads are blocked <a id="_idIndexMarker1478"/>while waiting for a lock, potentially wasting <span class="No-Break">processing time</span></li>
				<li>There’s no mechanism to check whether a lock is available or to time out if a lock is held for <span class="No-Break">too long</span></li>
			</ul>
			<p>If you need to overcome these limitations, you can use the built-in <strong class="source-inline">Lock</strong> interface with implementations that offer more control over synchronization. We will discuss one of the most common <span class="No-Break">implementations: </span><span class="No-Break"><strong class="source-inline">ReentrantLock</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-454"><a id="_idTextAnchor454"/>ReentrantLock</h2>
			<p>The <strong class="source-inline">ReentrantLock</strong> class is a <a id="_idIndexMarker1479"/>popular implementation <a id="_idIndexMarker1480"/>of the <strong class="source-inline">Lock</strong> interface. <strong class="source-inline">ReentrantLock</strong> is used to protect a section of code similar to <strong class="source-inline">synchronized</strong> but provides additional features through <span class="No-Break">its methods:</span></p>
			<ul>
				<li><strong class="source-inline">lock()</strong>: This method locks <span class="No-Break">the lock</span></li>
				<li><strong class="source-inline">unlock()</strong>: This method releases <span class="No-Break">the lock</span></li>
				<li><strong class="source-inline">tryLock()</strong>: This method attempts to acquire the lock and returns a boolean indicating whether the lock <span class="No-Break">was acquired</span></li>
				<li><strong class="source-inline">tryLock(time, unit)</strong>: This method attempts to acquire the lock for a <span class="No-Break">specified duration</span></li>
			</ul>
			<p>Let’s update the example we used to demonstrate the synchronized keyword <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ReentrantLock</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;
public class Count {
    static int counter = 0;
    static Lock lock = new ReentrantLock();
    static void incrementCounter() {
        try {
            lock.lock();
            int current = counter;
            System.out.println("Before: " + counter + ",
              Current thread: " + Thread.currentThread()
                .threadId());
            counter = current + 1;
            System.out.println("After: " + counter);
        } finally {
            lock.unlock();
        }
    }
}</pre>
			<p>In the preceding <a id="_idIndexMarker1481"/>code snippet, we replace the <strong class="source-inline">synchronized</strong> block <a id="_idIndexMarker1482"/>with <strong class="source-inline">ReentrantLock</strong>. We lock the <strong class="source-inline">Lock</strong> before the critical section and unlock it afterward in the <strong class="source-inline">finally</strong> block. This unlocking in the <strong class="source-inline">finally</strong> block is of utmost importance; otherwise, the lock won’t be released when an <span class="No-Break">exception occurs.</span></p>
			<p>The <strong class="source-inline">Main</strong> class remains <span class="No-Break">the same:</span></p>
			<pre class="source-code">
public class Main {    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            new Thread(Count::incrementCounter).start();
        }
    }
}</pre>
			<p>And this works like a charm. Here is <span class="No-Break">the output:</span></p>
			<pre class="console">
Before: 0, Current thread: 22After: 1
Before: 1, Current thread: 23
After: 2
Before: 2, Current thread: 24
After: 3
Before: 3, Current thread: 25
After: 4
Before: 4, Current thread: 26
After: 5
Before: 5, Current thread: 27
After: 6
Before: 6, Current thread: 28
After: 7
Before: 7, Current thread: 29
After: 8
Before: 8, Current thread: 30
After: 9
Before: 9, Current thread: 31
After: 10</pre>
			<p>But what if the block was locked already? We want to avoid waiting indefinitely. In that case, it may be <a id="_idIndexMarker1483"/>better to use <strong class="source-inline">tryLock</strong>. If the lock is unavailable, the <a id="_idIndexMarker1484"/>thread can continue with other tasks. This is one of the benefits compared to using the <strong class="source-inline">synchronized</strong> keyword! Here’s the <span class="No-Break">updated code:</span></p>
			<pre class="source-code">
public class Count {    static int counter = 0;
    static Lock lock = new ReentrantLock();
    static void incrementCounter() {
        if <strong class="bold">(lock.tryLock())</strong> {
            try {
                int current = counter;
                System.out.println("Before: " + counter +
                  ", Current thread: " + Thread.
                    currentThread().threadId());
                counter = current + 1;
                System.out.println("After: " + counter);
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("Thread didn't get the lock
              and is looking for a new task.");
        }
    }
}</pre>
			<p>As you can see, we <a id="_idIndexMarker1485"/>surround the <strong class="source-inline">try</strong> block with <strong class="source-inline">tryLock()</strong>. If the lock is not available, the thread proceeds to do other work. We could also have <a id="_idIndexMarker1486"/>used the <strong class="source-inline">tryLock(time, unit)</strong> method to wait for the lock for a <span class="No-Break">specific duration.</span></p>
			<p>We won’t go into detail due to the scope of this book, but there are other locks available – for example, the <strong class="source-inline">ReadWriteLock</strong> interface. It separates read and write operations, allowing multiple concurrent reads but exclusive writes. This can improve performance in <span class="No-Break">read-heavy workloads.</span></p>
			<h2 id="_idParaDest-455"><a id="_idTextAnchor455"/>Best practices for working with locks</h2>
			<p>When working <a id="_idIndexMarker1487"/>with the <strong class="source-inline">Lock</strong> interface, it’s important to keep a few best practices <span class="No-Break">in mind:</span></p>
			<ul>
				<li>Always unlock in a <strong class="source-inline">finally</strong> block to ensure the lock is released even in the case of <span class="No-Break">an exception.</span></li>
				<li>Use <strong class="source-inline">tryLock()</strong> for non-blocking operations, which can help avoid deadlocks and <span class="No-Break">improve performance.</span></li>
				<li>Even though we didn’t discuss it in detail, consider using <strong class="source-inline">ReadWriteLock</strong> for read-heavy workloads. This allows concurrent reads and exclusive writes. This improves the throughput of <span class="No-Break">your application.</span></li>
			</ul>
			<p>Enough about locks! Let’s talk about the another key tool for working with concurrency in Java: <span class="No-Break">concurrent collections!</span></p>
			<h1 id="_idParaDest-456"><a id="_idTextAnchor456"/>Concurrent collections</h1>
			<p>Multi-threaded <a id="_idIndexMarker1488"/>environments are important for performance, but in any multi-threaded environment, data integrity becomes an issue to consider. Imagine a situation where you have several threads interacting with a shared data structure, such as an <strong class="source-inline">ArrayList</strong> or <strong class="source-inline">HashMap</strong>. While one thread might be trying to read data from the structure, another could be writing to it. This can lead to data inconsistency and other types <span class="No-Break">of errors.</span></p>
			<p>One common problem that arises in such situations is known as a concurrent modification exception. This occurs when one thread is iterating over a data structure, and another thread attempts to modify it. Java recognizes that this can cause inconsistencies and throws an exception to prevent this <span class="No-Break">dangerous operation.</span></p>
			<p>Consider the following example, where a <strong class="source-inline">HashMap</strong> is <span class="No-Break">being used:</span></p>
			<pre class="source-code">
Map&lt;String, String&gt; languageMap = new HashMap&lt;&gt;();languageMap.put("Maaike", "Java");
languageMap.put("Seán", "C#");
for (String key : languageMap.keySet()) {
    System.out.println(key + " loves coding");
    languageMap.remove(key);
}</pre>
			<p>In this example, we’re trying to iterate over <strong class="source-inline">HashMap</strong> and remove an entry during the process. This will <span class="No-Break">throw </span><span class="No-Break"><strong class="source-inline">ConcurrentModificationException</strong></span><span class="No-Break">.</span></p>
			<p>You might have <a id="_idIndexMarker1489"/>guessed it; this is exactly why we have concurrent collections. A concurrent collection, such as <strong class="source-inline">ConcurrentHashMap</strong>, is a thread-safe alternative to <strong class="source-inline">HashMap</strong>, which means it can handle simultaneous reading and writing from multiple threads. With <strong class="source-inline">ConcurrentHashMap</strong>, you can modify the map while looping <span class="No-Break">over it:</span></p>
			<pre class="source-code">
ConcurrentMap&lt;String, String&gt; languageMap = new  ConcurrentHashMap&lt;&gt;();
languageMap.put("Maaike", "Java");
languageMap.put("Seán", "C#");
for (String key : languageMap.keySet()) {
    System.out.println(key + " loves coding");
    languageMap.remove(key);
}</pre>
			<p>We don’t get <strong class="source-inline">ConcurrentModificationException</strong> this time. <strong class="source-inline">ConcurrentHashMap</strong> allows us to remove items <span class="No-Break">while iterating.</span></p>
			<p>And that’s not even all! Concurrent collections offer another advantage. They allow us to lock on a per-segment basis. This means that multiple threads can have read access simultaneously, which can enhance the performance without compromising <span class="No-Break">data integrity.</span></p>
			<h2 id="_idParaDest-457"><a id="_idTextAnchor457"/>Concurrent collection interfaces</h2>
			<p>Within the <strong class="source-inline">java.util.concurrent</strong> package, there are several interfaces designed to facilitate concurrent operations on collections. The two primary ones we will discuss are <strong class="source-inline">ConcurrentMap</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">BlockingQueue</strong></span><span class="No-Break">.</span></p>
			<h3>ConcurrentMap</h3>
			<p><strong class="source-inline">ConcurrentMap</strong> is a sub-interface <a id="_idIndexMarker1490"/>of the standard <strong class="source-inline">java.util.Map</strong>. It provides atomic operations for <a id="_idIndexMarker1491"/>adding, removing, and replacing key-value pairs, enhancing thread safety. The two primary implementations of <strong class="source-inline">ConcurrentMap</strong> are <strong class="source-inline">ConcurrentHashMap</strong> and <strong class="source-inline">ConcurrentSkipListMap</strong>. It works very similarly to a <span class="No-Break">regular </span><span class="No-Break"><strong class="source-inline">Map</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
ConcurrentMap&lt;String, String&gt; map = new  ConcurrentHashMap&lt;&gt;();
map.put("Nadesh", "PHP");
String language = map.get("Nadesh");  // Returns "PHP"</pre>
			<p><strong class="source-inline">ConcurrentHashMap</strong> is a thread-safe <strong class="source-inline">Map</strong> implementation that provides better performance than <strong class="source-inline">Hashtable</strong> (an older thread-safe alternative). It allows concurrent reads and writes with <span class="No-Break">minimal contention.</span></p>
			<h3>BlockingQueue</h3>
			<p><strong class="source-inline">BlockingQueue</strong> is another interface, a subtype of <strong class="source-inline">Queue</strong>, optimized for multi-threaded <a id="_idIndexMarker1492"/>operations. Unlike standard <a id="_idIndexMarker1493"/>queues, <strong class="source-inline">BlockingQueue</strong> will block or time out when attempting to add an element to a full queue or retrieve an element from an <span class="No-Break">empty queue:</span></p>
			<pre class="source-code">
BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();queue.offer("Maria");
String name = queue.poll();</pre>
			<p>These interfaces provide additional functionality that becomes invaluable when working in a multi-threaded environment, enhancing both performance and <span class="No-Break">data integrity.</span></p>
			<p>There are quite a few other concurrent implementations of collections that you might work with in <a id="_idIndexMarker1494"/>the future, they work very <a id="_idIndexMarker1495"/>similarly to their non-concurrent counterparts. We’ll talk about two categories: <strong class="source-inline">SkipList</strong> and <span class="No-Break"><strong class="source-inline">CopyOnWrite</strong></span><span class="No-Break"> collections.</span></p>
			<h2 id="_idParaDest-458"><a id="_idTextAnchor458"/>Understanding SkipList collections</h2>
			<p><strong class="source-inline">ConcurrentSkipList</strong> collections <a id="_idIndexMarker1496"/>represent naturally <a id="_idIndexMarker1497"/>ordered collections, which means they maintain their elements in a sorted manner. <strong class="source-inline">ConcurrentSkipListSet</strong> and <strong class="source-inline">ConcurrentSkipListMap</strong> are the two most common <strong class="source-inline">ConcurrentSkipList</strong> collections. They work very similar to the collections that we’re <span class="No-Break">used to.</span></p>
			<h3>ConcurrentSkipListSet</h3>
			<p>Using <strong class="source-inline">ConcurrentSkipListSet </strong>is <a id="_idIndexMarker1498"/>the same<a id="_idIndexMarker1499"/> as using <strong class="source-inline">TreeSet</strong>, but it’s optimized for concurrent usage. Let’s take a look at <span class="No-Break">an example:</span></p>
			<pre class="source-code">
Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;&gt;();set.add("Gaia");
set.add("Jonas");
set.add("Adnane");
for (String s : set) {
    System.out.println(s);
}</pre>
			<p>In the preceding code block, when you print the set, the elements will be displayed in their natural order: <strong class="source-inline">Adnane</strong>, <strong class="source-inline">Gaia</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Jonas</strong></span><span class="No-Break">.</span></p>
			<h3>ConcurrentSkipListMap</h3>
			<p><strong class="source-inline">ConcurrentSkipListMap</strong> works similarly to <strong class="source-inline">TreeMap</strong>, but it’s designed for concurrent <a id="_idIndexMarker1500"/>operations. Like <strong class="source-inline">ConcurrentSkipListSet</strong>, the <a id="_idIndexMarker1501"/>map entries are maintained in the natural order of <span class="No-Break">their keys:</span></p>
			<pre class="source-code">
Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;&gt;();map.put("Flute", "Nabeel");
map.put("Bass", "Job");
map.put("Piano", "Malika");
for (String s : map.keySet()) {
    System.out.println(s + ": " + map.get(s));
}</pre>
			<p>In this code, the map entries are printed in the alphabetical order of the keys: <strong class="source-inline">Bass</strong>, <strong class="source-inline">Flute</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Piano</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-459"><a id="_idTextAnchor459"/>Understanding CopyOnWrite collections</h2>
			<p><strong class="source-inline">CopyOnWrite</strong> collections, as <a id="_idIndexMarker1502"/>the name suggests, make a fresh copy of the <a id="_idIndexMarker1503"/>collection every time it is modified. This means they perform well when there are more read operations than write operations but can be inefficient when there are more writes. Let’s discuss the <span class="No-Break">common implementations.</span></p>
			<h3>CopyOnWriteArrayList</h3>
			<p><strong class="source-inline">CopyOnWriteArrayList</strong> works just like a regular <strong class="source-inline">ArrayList</strong> but creates a new copy of the <a id="_idIndexMarker1504"/>list every time it <span class="No-Break">gets modified:</span></p>
			<pre class="source-code">
List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();list.add("Squirrel");
list.add("Labradoodle");
list.add("Bunny");
for (String item : list) {
    System.out.println(item);
    list.add(item);
}
System.out.println(list);</pre>
			<p>Even though we’re <a id="_idIndexMarker1505"/>modifying the list during iteration, it doesn’t result in <strong class="source-inline">ConcurrentModificationException</strong> because a new copy of the list is created when <span class="No-Break">it’s modified.</span></p>
			<h3>CopyOnWriteArraySet</h3>
			<p><strong class="source-inline">CopyOnWriteArraySet</strong> is similar <a id="_idIndexMarker1506"/>to <strong class="source-inline">HashSet</strong>, but it creates a new copy every time the set <span class="No-Break">is modified:</span></p>
			<pre class="source-code">
Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();set.add("Dog");
set.add("Cat");
set.add("Horse");
for (String s : set) {
    System.out.println(s);
    set.add(s);
}
System.out.println(set);</pre>
			<p>In the preceding <a id="_idIndexMarker1507"/>code, the size of the set remains the same after the loop because the set only contains <span class="No-Break">unique objects.</span></p>
			<h2 id="_idParaDest-460"><a id="_idTextAnchor460"/>Synchronized collections</h2>
			<p><em class="italic">Synchronized collections</em> are a <a id="_idIndexMarker1508"/>different way to use <a id="_idIndexMarker1509"/>collections in a multithreaded environment. The <strong class="source-inline">Collections</strong> class provides several static methods for returning synchronized versions of regular collections such as <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong>. Here’s an example <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
List&lt;String&gt; regularList = new ArrayList&lt;&gt;();List&lt;String&gt; syncList =
  Collections.synchronizedList(regularList);</pre>
			<p>In this example, <strong class="source-inline">syncList</strong> is a thread-safe version of <strong class="source-inline">regularList</strong>. These synchronized collections are a good choice when you need to turn an existing collection into a thread-safe one, but if you know a collection will be used in a multithreaded environment upon creation, it’s better to use concurrent collections as they <span class="No-Break">perform better.</span></p>
			<p>The most important difference between synchronized and concurrent collections is that synchronized collections cannot be modified in a loop as they will throw <strong class="source-inline">ConcurrentModificationException</strong>. They are otherwise safe to use and don’t lead to issues with data integrity when used with multiple threads. Managing a lot of threads by hand would be quite a daunting task. Luckily, there is a special interface, <strong class="source-inline">ExecutorService</strong>, to help us <span class="No-Break">with that!</span></p>
			<h1 id="_idParaDest-461"><a id="_idTextAnchor461"/>ExecutorService and thread pools</h1>
			<p>Java’s <strong class="source-inline">ExecutorService</strong> is a mechanism for executing tasks asynchronously. As a part of the <strong class="source-inline">java.util.concurrent</strong> package, <strong class="source-inline">ExecutorService</strong> is an interface used to manage <a id="_idIndexMarker1510"/>and control thread execution in a multithreaded environment. We have seen so far how we can manually control threads, and we’ll now see how we can use <strong class="source-inline">ExecutorService</strong> instead. We’ll see the details of <strong class="source-inline">ExecutorService</strong> and its implementations, such as <strong class="source-inline">SingleThreadExecutor</strong> and <strong class="source-inline">ScheduledExecutorService</strong>. Let’s see <span class="No-Break"><strong class="source-inline">SingleThreadExecutor</strong></span><span class="No-Break"> first.</span></p>
			<h2 id="_idParaDest-462"><a id="_idTextAnchor462"/>Executing tasks using SingleThreadExecutor</h2>
			<p>Firstly, let’s start with <strong class="source-inline">SingleThreadExecutor</strong>. This <strong class="source-inline">ExecutorService</strong> has one single worker <a id="_idIndexMarker1511"/>thread to process tasks, guaranteeing <a id="_idIndexMarker1512"/>that tasks are executed in the order they’re submitted. It’s useful when we need <span class="No-Break">sequential execution.</span></p>
			<p>Consider a scenario with an election where votes are being counted. To mimic this process, we’ll represent each vote as a task. For simplicity, let’s assume we’re counting votes for <span class="No-Break">one candidate.</span></p>
			<p>Here’s how we can <span class="No-Break">do that:</span></p>
			<pre class="source-code">
import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;
public class VoteCounter {
    public static void main(String[] args) {
        <strong class="bold">ExecutorService executor = Executors.</strong>
<strong class="bold">          newSingleThreadExecutor();</strong>
        // Submitting tasks
        for(int i=1; i&lt;=4; i++) {
      // We must create a new variable to use in the
      // lambda, because variables in lambdas must be
      // effectively final. And i is not.
            int voteId = i;
            <strong class="bold">executor.execute(() -&gt; {</strong>
                <strong class="bold">System.out.println("Vote " + voteId + "</strong>
<strong class="bold">                  counted by " + Thread.currentThread().</strong>
<strong class="bold">                    threadId());</strong>
            <strong class="bold">});</strong>
        }
        // Remember to shutdown the executor
        executor.shutdown();
    }
}</pre>
			<p>In the preceding <a id="_idIndexMarker1513"/>code block, we first create a <strong class="source-inline">SingleThreadExecutor</strong> instance. We then submit four tasks, each representing a vote <a id="_idIndexMarker1514"/>being counted. Notice that we use <strong class="source-inline">executor.execute()</strong>, passing a <strong class="source-inline">Runnable</strong> lambda function as an argument. This function prints the vote number and the thread ID handling it. At the end, we shut down <strong class="source-inline">ExecutorService</strong> using <strong class="source-inline">executor.shutdown()</strong>. This is crucial to terminate the non-daemon thread of the executor and failing to do so will prevent your application from terminating. A non-daemon thread is one that prevents the program from ending. When you forget to do that, you’ll see that once you run the program, it will not stop. The stop button will <span class="No-Break">stay visible.</span></p>
			<p>This is what it outputs (<span class="No-Break">for me):</span></p>
			<pre class="console">
Vote 1 counted by 22Vote 2 counted by 22
Vote 3 counted by 22
Vote 4 counted by 22</pre>
			<p>As you can see, it will count four votes, printing the corresponding vote number and the same thread ID each time since all tasks are processed by a single thread. We can actually also invoke multiple tasks at the same time. Before we can do that, we need to understand <strong class="source-inline">Callable</strong> and <strong class="source-inline">Future</strong>. So, let’s see what that means first – is the future <span class="No-Break">calling us?</span></p>
			<h2 id="_idParaDest-463"><a id="_idTextAnchor463"/>The Callable interface and Future</h2>
			<p>While the <strong class="source-inline">Runnable</strong> interface enables you to execute code concurrently, it does not return a <a id="_idIndexMarker1515"/>result. In contrast, the <strong class="source-inline">Callable</strong> interface allows concurrent tasks to <a id="_idIndexMarker1516"/>produce a result. It has a single <strong class="source-inline">call</strong> method that returns a value. So, it’s a functional <span class="No-Break">interface too.</span></p>
			<p><strong class="source-inline">ExecutorService</strong> not only executes <strong class="source-inline">Runnable</strong> tasks but also <strong class="source-inline">Callable</strong> tasks, which return a result. The <strong class="source-inline">submit()</strong> method is used to execute <strong class="source-inline">Callable</strong> tasks. This <strong class="source-inline">submit()</strong> method returns a <strong class="source-inline">Future</strong> object, which can be used to retrieve the result once it’s ready. If you’d like to think of a non-code example, you can compare it to placing an order at a restaurant: you receive a token (<strong class="source-inline">Future</strong>) and you can use it to collect your order (the result) when <span class="No-Break">it’s ready.</span></p>
			<p>The <strong class="source-inline">Future</strong> object represents the result of an ongoing computation—a placeholder of sorts. When you <a id="_idIndexMarker1517"/>submit a <strong class="source-inline">Callable</strong> task to <strong class="source-inline">ExecutorService</strong>, it returns a <strong class="source-inline">Future</strong> object. You can use this <strong class="source-inline">Future</strong> object to check whether the computation is complete, wait for its completion, and retrieve the result. It’s time to see <span class="No-Break">an example!</span></p>
			<h2 id="_idParaDest-464"><a id="_idTextAnchor464"/>Submitting tasks and handling results</h2>
			<p>Let’s simulate counting <a id="_idIndexMarker1518"/>votes and maintaining a tally using <strong class="source-inline">Callable</strong> tasks. Here, we’ll <a id="_idIndexMarker1519"/>use the <strong class="source-inline">submit()</strong> method, which returns a <span class="No-Break"><strong class="source-inline">Future</strong></span><span class="No-Break"> object.</span></p>
			<p>The code might look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
import java.util.concurrent.*;public class VoteCounter {
    private static final ExecutorService executorService =
      Executors.newSingleThreadExecutor();
    public static void main(String[] args) {
        try {
            Future&lt;Integer&gt; vote1 = getRandomVote(1);
            Future&lt;Integer&gt; vote2 = getRandomVote(2);
            Future&lt;Integer&gt; vote3 = getRandomVote(3);
            Future&lt;Integer&gt; vote4 = getRandomVote(4);
            // wait until all tasks are done
            while (!(vote1.isDone() &amp;&amp; vote2.isDone() &amp;&amp;
              vote3.isDone() &amp;&amp; vote4.isDone())) {
                Thread.sleep(10); // sleep for 10ms then
                                 //   try again
            }
            int totalVotes = vote1.get() + vote2.get() +
              vote3.get() + vote4.get();
            System.out.println("Total votes: " +
              totalVotes);
        } catch (InterruptedException |
            ExecutionException e) {
            e.printStackTrace();
        } finally {
            executorService.shutdown();
        }
    }
    public static Future&lt;Integer&gt; getRandomVote(int i) {
        return executorService.submit(() -&gt; {
            Thread.sleep(1000); // simulate delay
            System.out.println("Vote " + i + " counted by "
              + Thread.currentThread().threadId());
            return 1; // each vote counts as 1
        });
    }
}</pre>
			<p>And here is what it <span class="No-Break">will output:</span></p>
			<pre class="console">
Vote 1 counted by 22Vote 2 counted by 22
Vote 3 counted by 22
Vote 4 counted by 22
Total votes: 4</pre>
			<p>We are still using <strong class="source-inline">SingleExecutorService</strong> in the preceding code. To our <strong class="source-inline">ExecutorService</strong>, we submit four <strong class="source-inline">Callable</strong> tasks using <strong class="source-inline">executorService.submit()</strong> in the <strong class="source-inline">getRandomVote</strong> method. Each task waits for one <a id="_idIndexMarker1520"/>second (simulating vote counting) and then returns <strong class="source-inline">1</strong> (representing one vote). Each submission <a id="_idIndexMarker1521"/>returns a <strong class="source-inline">Future</strong> object, which is stored in <strong class="source-inline">vote1</strong>, <strong class="source-inline">vote2</strong>, <strong class="source-inline">vote3</strong>, and <span class="No-Break"><strong class="source-inline">vote4</strong></span><span class="No-Break">, respectively.</span></p>
			<p>Then, we wait in a loop until all <strong class="source-inline">Future</strong> objects report they’re done. Once all votes are counted (all <strong class="source-inline">Future</strong> objects are done), we retrieve the results using the <strong class="source-inline">get()</strong> method on each <strong class="source-inline">Future</strong> object. This is wrapped in a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block to handle potential exceptions. Finally, we add all the votes and print the total votes. Before we continue, let’s talk a bit more about the methods on the <span class="No-Break"><strong class="source-inline">Future</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-465"><a id="_idTextAnchor465"/>Future objects and their methods</h2>
			<p>The <strong class="source-inline">Future</strong> object <a id="_idIndexMarker1522"/>provides several methods to handle the results of asynchronous computations. We already used <strong class="source-inline">isDone()</strong> to check whether the task was done and the result was in. And we already used <strong class="source-inline">get()</strong> to get the result of the task when it was done. This <strong class="source-inline">get() </strong>method waits until the task is done executing. Here are some other methods that <a id="_idIndexMarker1523"/>are important <span class="No-Break">to know:</span></p>
			<ul>
				<li><strong class="source-inline">get(long timeout, TimeUnit unit)</strong>: Retrieves the result only if it’s ready within the provided <span class="No-Break">timeout duration</span></li>
				<li><strong class="source-inline">isCancelled()</strong>: Checks whether the computation <span class="No-Break">was canceled</span></li>
				<li><strong class="source-inline">cancel(boolean mayInterruptIfRunning)</strong>: Attempts to cancel <span class="No-Break">the task</span></li>
			</ul>
			<p>In the latest example, we submitted the four tasks one by one, but we can also submit multiple tasks at the same time. Let’s see how that <span class="No-Break">is done.</span></p>
			<h2 id="_idParaDest-466"><a id="_idTextAnchor466"/>Invoking multiple tasks and handling the results</h2>
			<p>We can submit <a id="_idIndexMarker1524"/>multiple tasks and handle their results. For this, we’ll <a id="_idIndexMarker1525"/>use the <strong class="source-inline">invokeAny()</strong> and <strong class="source-inline">invokeAll()</strong> methods, and represent tasks as <strong class="source-inline">Callable</strong> tasks instead of <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> tasks.</span></p>
			<p>The <strong class="source-inline">invokeAny()</strong> method takes a <a id="_idIndexMarker1526"/>collection of <strong class="source-inline">Callable</strong> objects and returns the result of a successfully executed task (the first one to finish), canceling all others. Conversely, <strong class="source-inline">invokeAll()</strong> executes all tasks and returns a list of <strong class="source-inline">Future</strong> objects representing <span class="No-Break">the results.</span></p>
			<p>Consider the following code, which is counting our votes again. In this case, people can vote for option 1 or option 2. Counting is now implemented with the use of <strong class="source-inline">Callable</strong> and <strong class="source-inline">Future</strong>. We will demonstrate the use of <strong class="source-inline">invokeAny</strong> (not very democratic) and <strong class="source-inline">invokeAll</strong> in this <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
import java.util.Arrays;import java.util.List;
import java.util.concurrent.*;
public class VoteCounter {
    public static void main(String[] args) {
        ExecutorService executor = Executors.
          newSingleThreadExecutor();
        List&lt;Callable&lt;Integer&gt;&gt; callables = Arrays.asList(
                () -&gt; { Thread.sleep(1000); return 1; },
                () -&gt; { Thread.sleep(2000); return 2; }
        );
        try {
            // Invoking any task and printing result
            Integer result = executor.invokeAny(callables);
            System.out.println("Result of the fastest task:
              " + result);
            // Invoking all tasks and printing results
            List&lt;Future&lt;Integer&gt;&gt; futures = executor.
              invokeAll(callables);
            for (Future&lt;Integer&gt; future : futures) {
                System.out.println("Task result: " +
                  future.get());
            }
        } catch (InterruptedException |
             ExecutionException e) {
            e.printStackTrace();
        }
        executor.shutdown();
    }
}</pre>
			<p>And this is what the <span class="No-Break">code outputs:</span></p>
			<pre class="console">
Result of the fastest task: 1Task result: 1
Task result: 2</pre>
			<p>In the code, we start by defining a list of <strong class="source-inline">Callable</strong> tasks. Each <strong class="source-inline">Callable</strong> returns an <strong class="source-inline">Integer</strong> after a certain sleep period (simulating the work done by the task). We then invoke the tasks <a id="_idIndexMarker1527"/>using the <strong class="source-inline">invokeAny()</strong> and <strong class="source-inline">invokeAll()</strong> methods, displaying <a id="_idIndexMarker1528"/>the results accordingly. The <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block is needed to handle potential exceptions that may arise during <span class="No-Break">task execution.</span></p>
			<p>This example gives us a good understanding of invoking tasks and handling results using <strong class="source-inline">ExecutorService</strong>. So far, we’ve only seen <strong class="source-inline">SingleThreadExecutor</strong>. There are also <strong class="source-inline">ExecutorService</strong> available that use multiple threads. That’s going to make it a lot more interesting (and complicated, so stay focussed!). Let’s see <span class="No-Break">these next.</span></p>
			<h2 id="_idParaDest-467"><a id="_idTextAnchor467"/>Thread pools and task execution</h2>
			<p>Thread pools are a key concept of concurrent programming. Thread pools can be compared to a crew <a id="_idIndexMarker1529"/>of workers—multiple threads waiting for tasks. When a task is available, each thread can pick it up from the queue, execute it, and wait for new tasks rather than being destroyed. This is a lot more efficient compared to creating a new thread for <span class="No-Break">every task.</span></p>
			<p>There are different <strong class="source-inline">ExecutorServices</strong> to manage thread pools, and each has its specific use case. Let’s explore <span class="No-Break"><strong class="source-inline">FixedThreadPool</strong></span><span class="No-Break"> first.</span></p>
			<h3>FixedThreadPool</h3>
			<p><strong class="source-inline">FixedThreadPool</strong> maintains<a id="_idIndexMarker1530"/> a fixed number of threads. If a task is submitted and all threads are active, the <a id="_idIndexMarker1531"/>task waits in a queue until a thread <span class="No-Break">becomes available.</span></p>
			<p>So far, we’ve had a single thread do all the vote counting for us. Instead, consider an election scenario where you have three polling stations to count the votes from all 100 <span class="No-Break">voting stations:</span></p>
			<pre class="source-code">
public static void main(String[] args) {    ExecutorService executorService = Executors.
      newFixedThreadPool(3);
    for (int i = 0; i &lt; 100; i++) {
        final int stationId = i;
        executorService.submit(() -&gt; {
            try {
                System.out.println("Counting votes from
                   station: " + stationId + ", Thread id: "
                     + Thread.currentThread().threadId());
                Thread.sleep((int) (Math.random() * 200));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
    executorService.shutdown();
}</pre>
			<p>This will output something <span class="No-Break">like this:</span></p>
			<pre class="console">
Counting votes from station: 1, Thread id: 23Counting votes from station: 2, Thread id: 24
Counting votes from station: 0, Thread id: 22
Counting votes from station: 3, Thread id: 23
Counting votes from station: 4, Thread id: 23
[part omitted]
Counting votes from station: 97, Thread id: 22
Counting votes from station: 98, Thread id: 23
Counting votes from station: 99, Thread id: 24</pre>
			<p>Every time you<a id="_idIndexMarker1532"/> run the program, it will be somewhat different! The count for each vote is carried out asynchronously, as demonstrated by the randomly assigned sleep times. This is because we’re simulating a scenario in which each of the three threads (in this case with id <strong class="source-inline">22</strong>, <strong class="source-inline">23</strong>, and <strong class="source-inline">24</strong>) corresponds to a <a id="_idIndexMarker1533"/>polling station that starts counting the votes. Even if there is a large number of votes, there will still only be three threads (polling stations) performing <span class="No-Break">the counting.</span></p>
			<p>As you can see, the order of the voting stations is no longer the same. This is because multiple threads are working simultaneously. And that’s not a problem, as it doesn’t influence the <span class="No-Break">end result.</span></p>
			<h3>CachedThreadPool</h3>
			<p><strong class="source-inline">CachedThreadPool</strong>, on the<a id="_idIndexMarker1534"/> other hand, creates new threads as needed and reuses previously constructed <a id="_idIndexMarker1535"/>threads if they are available. Threads in this pool that haven’t been used for a certain amount of time are terminated and removed from <span class="No-Break">the cache.</span></p>
			<p>Imagine an election with numerous mobile polling stations that move around to different locations and count votes <span class="No-Break">as needed:</span></p>
			<pre class="source-code">
public static void main(String[] args) {    ExecutorService executorService = Executors.
       newCachedThreadPool();
    for (int i = 0; i &lt; 100; i++) {
        final int stationId = i;
        executorService.submit(() -&gt; {
            try {
                System.out.println("Counting votes at
                   station: " + stationId + ", Thread id: "
                     + Thread.currentThread().threadId());
                Thread.sleep((int) (Math.random() * 200));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
    executorService.shutdown();
}</pre>
			<p>This<a id="_idIndexMarker1536"/> code<a id="_idIndexMarker1537"/> can output <span class="No-Break">the following:</span></p>
			<pre class="console">
Counting votes at station: 5, Thread id: 27Counting votes at station: 19, Thread id: 41
Counting votes at station: 24, Thread id: 46
Counting votes at station: 3, Thread id: 25
Counting votes at station: 6, Thread id: 28
Counting votes at station: 0, Thread id: 22
[middle omitted]
Counting votes at station: 97, Thread id: 125
Counting votes at station: 98, Thread id: 126
Counting votes at station: 99, Thread id: 127</pre>
			<p>In this case, <strong class="source-inline">CachedThreadPool</strong> creates as many threads as needed to process the votes simultaneously, leading <a id="_idIndexMarker1538"/>to faster vote counting. However, this<a id="_idIndexMarker1539"/> comes at the cost of system resources since an uncontrolled number of threads could <span class="No-Break">be created.</span></p>
			<p>Another option that we have is to schedule commands to run after a given delay or to execute periodically. This is done with <strong class="source-inline">ScheduledExecutorService</strong>. Let’s see how we can schedule tasks to run after a certain delay <span class="No-Break">or periodically.</span></p>
			<h2 id="_idParaDest-468"><a id="_idTextAnchor468"/>ScheduledExecutorServices</h2>
			<p>Now, we’re going to take a look at <strong class="source-inline">ScheduledExecutorService</strong>. As the name suggests, <strong class="source-inline">ScheduledExecutorService</strong> allows you to schedule tasks to be executed after a <a id="_idIndexMarker1540"/>certain delay, or to be executed periodically. This is incredibly useful when you need a task to be executed at regular intervals without having to manually reschedule it <span class="No-Break">each time.</span></p>
			<p>To use <strong class="source-inline">ScheduledExecutorService</strong>, you first create one using the <strong class="source-inline">Executors</strong> class. There are multiple options, but we’ll only <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">newScheduledThreadPool()</strong></span><span class="No-Break">.</span></p>
			<p>Let’s see some example code. Assume that we are building a simple voting system where we need to schedule a task to close the voting process after a certain period, say 1 hour. Here’s how we can <span class="No-Break">do that:</span></p>
			<pre class="source-code">
import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
public class VotingSystem {
    private static final ScheduledExecutorService scheduler
      = Executors.newScheduledThreadPool(1);
    public static void main(String[] args) {
        // Open voting
        System.out.println("Voting started!");
        // Schedule voting to close after 1 hour
        scheduler.schedule(VotingSystem::closeVoting, 1,
          TimeUnit.HOURS);
    }
    private static void closeVoting() {
        // Close voting
        System.out.println("Voting closed!");
        // Shut down the scheduler
        scheduler.shutdown();
    }
}</pre>
			<p>This outputs <span class="No-Break">the following:</span></p>
			<pre class="console">
Voting started!Voting closed!</pre>
			<p>We create <strong class="source-inline">ScheduledExecutorService</strong> with a single thread. We then use the <strong class="source-inline">schedule()</strong> method to <a id="_idIndexMarker1541"/>schedule the <strong class="source-inline">closeVoting()</strong> method to be executed after 1 hour. The <strong class="source-inline">schedule()</strong> method takes three arguments: the method to execute, the delay before execution, and the time unit of <span class="No-Break">the delay.</span></p>
			<p>This is a simple example. You could also schedule tasks to be executed periodically. For example, if you wanted to remind voters every 15 minutes that voting will close soon, you could <span class="No-Break">do this:</span></p>
			<pre class="source-code">
// Schedule reminders every 15 minutes  scheduler.scheduleAtFixedRate(VotingSystem::remindVoters,
  15, 15, TimeUnit.MINUTES);
// ...
private static void remindVoters() {
    // Remind voters
    System.out.println("Remember to vote! Voting will close
      soon!");
}</pre>
			<p>In this code, we <a id="_idIndexMarker1542"/>use the <strong class="source-inline">scheduleAtFixedRate()</strong> method to schedule the <strong class="source-inline">remindVoters()</strong> method to be executed every 15 minutes. The <strong class="source-inline">scheduleAtFixedRate()</strong> method takes four arguments: the method to execute, the initial delay before execution, the period between executions, and the time unit of the delay <span class="No-Break">and period.</span></p>
			<p>And this is what it outputs with <span class="No-Break">these modifications:</span></p>
			<pre class="console">
Voting started!Remember to vote! Voting will close soon!
Remember to vote! Voting will close soon!
Remember to vote! Voting will close soon!
Remember to vote! Voting will close soon!
Voting closed!</pre>
			<p>Remember, when you are done with your <strong class="source-inline">ScheduledExecutorService</strong>, don’t forget to shut it <a id="_idIndexMarker1543"/>down. This will stop any new tasks from being accepted and allow the existing tasks to complete. If you don’t shut down <strong class="source-inline">ScheduledExecutorService</strong>, your application might not terminate because the non-daemon threads in the pool will keep <span class="No-Break">it running.</span></p>
			<p>And that’s all you need to know to get started with <strong class="source-inline">ScheduledExecutorService</strong>. Let’s explore the data race problem in a bit more detail before moving on to other Java tools, such as atomic classes for dealing <span class="No-Break">with concurrency.</span></p>
			<h1 id="_idParaDest-469"><a id="_idTextAnchor469"/>Data races</h1>
			<p>Instead of starting by <a id="_idIndexMarker1544"/>explaining atomic classes, let’s start with explaining a problem called a data race with an example. We already have seen how to fix this problem with the use of atomic classes, synchronized keyword, and locks. Can you spot the problem in the following <span class="No-Break">code snippet?</span></p>
			<p><strong class="source-inline">public class </strong><span class="No-Break"><strong class="source-inline">Main {</strong></span></p>
			<pre class="source-code">
    private static int counter = 0;    public static void main(String[] args) throws
      InterruptedException {
        Thread thread1 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                counter++;
            }
        });
        Thread thread2 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                counter++;
            }
        });
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println("Counter value: " + counter);
    }
}</pre>
			<p>We have a static <strong class="source-inline">int</strong> counter that is being incremented 10,000 times by two threads. You’d expect the counter to be 20,000 then, right? Yet, if we print the value of the counter, this is what <span class="No-Break">we get:</span></p>
			<pre class="console">
Counter value: 12419</pre>			<p>And if we run it again, this is what <span class="No-Break">we get:</span></p>
			<pre class="console">
Counter value: 13219</pre>			<p>A third time? This is what <span class="No-Break">we get:</span></p>
			<pre class="console">
Counter value: 15089</pre>			<p>Long story short, we <a id="_idIndexMarker1545"/>have a problem! But why? Well, we are looking at the result of a data race. A data race occurs when two or more threads access shared data simultaneously, and at least one of them modifies the data. So, in our case, <strong class="source-inline">thread1</strong> reads the value and wants to increase it, but at the same time, <strong class="source-inline">thread2</strong> read the value and increases it too. Let’s say the value was 2,000 at the time. Both <strong class="source-inline">thread1</strong> and <strong class="source-inline">thread2</strong> increase it to 2,001. There are a few other variations possible, for example, <strong class="source-inline">thread1</strong> writing 4,022, and then <strong class="source-inline">thread2</strong> overwriting the value with a much lower value, such <span class="No-Break">as 3,785.</span></p>
			<p>This happens because these <strong class="source-inline">++</strong> and <strong class="source-inline">--</strong> operators are not atomic operators. This means that getting the value and increasing it are two separate operations, allowing it to be intersected by another <a id="_idIndexMarker1546"/>thread. In order to avoid this, we can work with atomic classes. As we have seen, for atomic classes, getting and modifying the value is just one single operation, avoiding <span class="No-Break">this issue.</span></p>
			<p class="callout-heading">A non-code data race</p>
			<p class="callout">Let’s tell you a true story to give you a non-code example (and a first-world problem) about a data race I had to experience myself. I love it when my friends have wish lists for their birthdays so that I can get them something they want instead of spending lots of time thinking about what to get them. So apparently, I and another friend saw that the kid of one of our friends wanted an inflatable bouncy unicorn. So, we both checked the list at almost the same time and we saw that the bouncy unicorn was still an available gift option. We both crossed it off and got the unicorn. (Okay, to be honest, I remember that I had to cross it off twice actually, but I figured it was <span class="No-Break">a glitch.)</span></p>
			<p class="callout">Turns out that we were looking at that list, at the very same time, ordering the unicorn and crossing it off. Can’t say it ended up being a real problem, because what is better to a 6-year-old than one inflatable bouncy unicorn? Yup, two inflatable <span class="No-Break">bouncy unicorns!</span></p>
			<p>Let’s see the common problems such as the data race mentioned here before we wrap up <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-470"><a id="_idTextAnchor470"/>Threading problems</h1>
			<p>When working with concurrency, we have the opportunity to increase performance! However, with great power comes great responsibility; things can go awfully wrong as well. Therefore, we <a id="_idIndexMarker1547"/>must be aware of several potential problems that can arise due to incorrect or inefficient synchronization. Let’s discuss four common threading problems: data races, race conditions, deadlocks, livelocks, <span class="No-Break">and starvation.</span></p>
			<h2 id="_idParaDest-471"><a id="_idTextAnchor471"/>Data races</h2>
			<p>We have just talked quite a bit about data races already. They occur when two or more threads access shared<a id="_idIndexMarker1548"/> data concurrently, and at least one of them <a id="_idIndexMarker1549"/>modifies the data, leading to unpredictable results. Here’s an example of an innocent-looking snippet of code that can lead to a data race in <span class="No-Break">multithreaded environments:</span></p>
			<pre class="source-code">
class Counter {    private int count = 0;
    public void increment() {
        count++;
    }
    public int getCount() {
        return count;
    }
}</pre>
			<p>If multiple threads call the <strong class="source-inline">increment()</strong> method simultaneously, the <strong class="source-inline">count</strong> variable’s value may not be updated correctly, resulting in an incorrect <span class="No-Break">final count.</span></p>
			<h3>Strategies to prevent data races</h3>
			<p>To prevent data <a id="_idIndexMarker1550"/>races, you can use various synchronization techniques as we have seen in this chapter, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Using the <strong class="source-inline">synchronized </strong>keyword on methods or blocks <span class="No-Break">of code</span></li>
				<li>Using atomic classes, such as <strong class="source-inline">AtomicInteger</strong>, <strong class="source-inline">AtomicLong</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AtomicReference</strong></span></li>
				<li>Using locks, such as <strong class="source-inline">ReentrantLock</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">ReadWriteLock</strong></span></li>
			</ul>
			<h2 id="_idParaDest-472"><a id="_idTextAnchor472"/>Race conditions</h2>
			<p>A race condition is a situation in concurrent programming where the program’s outcome can change <a id="_idIndexMarker1551"/>based on the sequence or timing of thread <a id="_idIndexMarker1552"/>scheduling and execution. It is a flaw that occurs when the timing or order of events affects the program’s correctness. Unlike a data race, where concurrent access to shared data is the issue, a race condition is about multiple threads sequencing their <span class="No-Break">operations incorrectly.</span></p>
			<p>Here’s an example code snippet to illustrate <span class="No-Break">the problem:</span></p>
			<pre class="source-code">
class Flight {    private int seatsAvailable;
    public Flight(int seats) {
        this.seatsAvailable = seats;
    }
    public void bookSeat() {
        if(seatsAvailable &gt; 0) {
            try {
                // Simulate the time needed
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
            seatsAvailable--;
            System.out.println(Thread.currentThread().
                getName() + " successfully booked a seat.
                Remaining seats: " + seatsAvailable);
        } else {
            System.out.println("Sorry, " + Thread.
              currentThread().getName() + ". The flight is
                fully booked.");
        }
    }
    public int getSeatsAvailable() {
        return seatsAvailable;
    }
}</pre>
			<p>If two threads (representing two customers) called the <strong class="source-inline">bookSeat</strong> method at the same time when only one seat is left, they could both pass the <strong class="source-inline">if(seatsAvailable &gt; 0)</strong> check before either of them had the chance to decrement <strong class="source-inline">seatsAvailable</strong>. As a result, two customers might book the last seat, which is a <span class="No-Break">race condition.</span></p>
			<p>This situation is an <a id="_idIndexMarker1553"/>example of a race condition because <a id="_idIndexMarker1554"/>the order of operations (checking the availability and then decrementing the number of seats) matters for correctness. Specifically, there is a critical section of code (<strong class="source-inline">if(seatsAvailable &gt; 0)</strong> and <strong class="source-inline">seatsAvailable--;</strong>) that needs to be executed atomically (without interruption) to <span class="No-Break">prevent errors.</span></p>
			<p>To make sure that we understand the difference from a data race, a data race specifically involves simultaneous access to shared data where at least one operation is a write operation. A data race could occur in our example if multiple threads attempted to decrement <strong class="source-inline">seatsAvailable</strong> at the same time, potentially leading to one thread reading the value of <strong class="source-inline">seatsAvailable</strong> before another thread had finished <span class="No-Break">decrementing it.</span></p>
			<h3>Strategies to prevent race conditions</h3>
			<p>To avoid these types of problems, we need to ensure that the critical section of code is executed atomically, which <a id="_idIndexMarker1555"/>can be achieved by synchronization. For instance, we can use the <strong class="source-inline">synchronized</strong> keyword to prevent multiple threads from executing the critical section simultaneously. You should consider these <span class="No-Break">general strategies:</span></p>
			<ul>
				<li><strong class="bold">Synchronization</strong>: Use synchronization mechanisms such as the <strong class="source-inline">synchronized</strong> keyword or explicit locks to ensure that only one thread can execute a critical section at <span class="No-Break">a time.</span></li>
				<li><strong class="bold">Atomic operations</strong>: Use atomic operations that are completed in a single step without the possibility of <span class="No-Break">being interrupted.</span></li>
				<li><strong class="bold">Sequential design</strong>: Design your program so that thread access to shared data is sequenced or coordinated in a manner that eliminates the timing or order of events as a factor, reducing the chance of <span class="No-Break">race conditions</span></li>
				<li><strong class="bold">Higher-level concurrency abstractions</strong>: We haven’t talked about it here, but the <strong class="source-inline">java.util.concurrent</strong> package provides higher-level synchronization utilities such as <strong class="source-inline">Semaphores</strong>, <strong class="source-inline">CountDownLatches</strong>, and <strong class="source-inline">CyclicBarriers</strong>, which can be used to coordinate operations between threads and thus prevent <span class="No-Break">race conditions.</span></li>
			</ul>
			<h2 id="_idParaDest-473"><a id="_idTextAnchor473"/>Deadlocks</h2>
			<p>A deadlock occurs <a id="_idIndexMarker1556"/>when two or more threads wait for each other to <a id="_idIndexMarker1557"/>release a resource, resulting in a circular waiting pattern. Here’s an example of <span class="No-Break">a deadlock:</span></p>
			<pre class="source-code">
Object resourceA = new Object();Object resourceB = new Object();
Thread thread1 = new Thread(() -&gt; {
    synchronized (resourceA) {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (resourceB) {
            System.out.println("Thread 1: Locked
              ResourceB");
        }
    }
});
Thread thread2 = new Thread(() -&gt; {
    synchronized (resourceB) {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (resourceA) {
            System.out.println("Thread 2: Locked
              ResourceA");
        }
    }
});
thread1.start();
thread2.start();</pre>
			<p>So, please mind the problem here is the incorrect use of the <strong class="source-inline">synchronized</strong> keyword! The <strong class="source-inline">thread1</strong> variable <a id="_idIndexMarker1558"/>acquires a lock on <strong class="source-inline">resourceA</strong> and <strong class="source-inline">thread2</strong> acquires <a id="_idIndexMarker1559"/>a lock on <strong class="source-inline">resourceB</strong>. Then, both threads attempt to acquire a lock on the other resource, leading to a deadlock. Meaning that both threads are <span class="No-Break">stuck indefinitely.</span></p>
			<h3>Strategies to prevent and resolve deadlocks</h3>
			<p>To prevent and resolve <a id="_idIndexMarker1560"/>deadlocks, you can employ the <a id="_idIndexMarker1561"/><span class="No-Break">following strategies:</span></p>
			<ul>
				<li><strong class="bold">Avoid nested locks</strong>: Ensure that you only lock one resource at a time, or acquire locks in a <span class="No-Break">specific order.</span></li>
				<li><strong class="bold">Use lock timeouts</strong>: Set a timeout for acquiring locks and release them if the <span class="No-Break">timeout expires.</span></li>
			</ul>
			<h2 id="_idParaDest-474"><a id="_idTextAnchor474"/>Livelocks</h2>
			<p>A livelock occurs when <a id="_idIndexMarker1562"/>two or more threads are stuck in a loop, repeatedly <a id="_idIndexMarker1563"/>releasing and re-acquiring resources, without making any progress. Here’s a silly example of <span class="No-Break">a livelock:</span></p>
			<pre class="source-code">
public class ExampleLivelock {    public static void main(String[] args) {
        run();
    }
    public static void run(){
        final PhoneCall buddy1 = new PhoneCall("Patricia");
        final PhoneCall buddy2 = new PhoneCall("Patrick");
        final HangUpButton s = new HangUpButton(buddy1);
        new Thread(new Runnable() {
            public void run() { buddy1.callWith(s, buddy2); }
        }).start();
        new Thread(new Runnable() {
            public void run() { buddy2.callWith(s, buddy1); }
        }).start();
    }
    static class HangUpButton {
        private PhoneCall owner;
        public HangUpButton(PhoneCall d) { owner = d; }
        public PhoneCall getOwner() { return owner; }
        public synchronized void setOwner(PhoneCall d) {
            owner = d;
        }
        public synchronized void use() {
            System.out.printf("%s has hang up!",
              owner.name);
        }
    }
    static class PhoneCall {
        private String name;
        private boolean isDone;
        public PhoneCall(String n) {
            name = n; isDone = true;
        }
        public String getName() { return name; }
        public boolean isDone() { return isDone; }
        public void callWith(HangUpButton hangUpButton,
          PhoneCall buddy) {
            while (isDone) {
                if (hangUpButton.owner != this) {
                    try {
                        Thread.sleep(1);
                    }catch(InterruptedException e) {
                        continue;
                    }
                    continue;
                }
                if (buddy.isDone()) {
                    System.out.printf(
                            "%s: You hang up, buddy %s!%n",
                            name, buddy.getName());
                    hangUpButton.setOwner(buddy);
                    continue;
                }
            }
        }
    }
}</pre>
			<p>In this example, two <strong class="source-inline">PhoneCall</strong> objects, <strong class="source-inline">Patricia</strong> and <strong class="source-inline">Patrick</strong>, are trying to hang up a phone call using a shared <strong class="source-inline">hangUpButton</strong> object. The <strong class="source-inline">hangUpButton</strong> object can have only one owner at a time. <strong class="source-inline">Patricia</strong> and <strong class="source-inline">Patrick</strong> both seem to have the rule that if they own <strong class="source-inline">hangUpButton</strong> and the other person hasn’t hung up yet, they will pass <strong class="source-inline">hangUpButton</strong> to the other person. This leads to a situation where the two of them are <a id="_idIndexMarker1564"/>perpetually passing <strong class="source-inline">hangUpButton</strong> back <a id="_idIndexMarker1565"/>and forth to each other because they’re always seeing that the other person hasn’t hung up yet, which is a <span class="No-Break">livelock situation.</span></p>
			<p>Please note that in this particular silly code, there is no mechanism to break out of the livelock (the infinite <strong class="source-inline">while</strong> loop in the <strong class="source-inline">callWith</strong> method). In real-world scenarios, a mechanism to detect and recover from the livelock should <span class="No-Break">be implemented.</span></p>
			<h3>Strategies to prevent and resolve livelocks</h3>
			<p>To prevent <a id="_idIndexMarker1566"/>and resolve livelocks, consider the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker1567"/></span><span class="No-Break">strategies:</span></p>
			<ul>
				<li><strong class="bold">Use a backoff algorithm</strong>: Introduce a (very small) random delay or an exponential backoff before retrying an operation to minimize the chances <span class="No-Break">of livelock.</span></li>
				<li><strong class="bold">Prioritize resources or threads</strong>: Assign priorities to resources or threads to avoid contention and ensure that higher-priority tasks <span class="No-Break">can proceed.</span></li>
				<li><strong class="bold">Detect and recover from livelocks</strong>: Monitor the application for livelocks and take corrective action, such as restarting threads or <span class="No-Break">reassigning priorities.</span></li>
			</ul>
			<p>A livelock is a special <a id="_idIndexMarker1568"/>case of resource starvation. It’s a condition where <a id="_idIndexMarker1569"/>two or more processes continuously change their state in response to changes in the other process(es) without doing any useful work. Let’s talk about <span class="No-Break">starvation next.</span></p>
			<h2 id="_idParaDest-475"><a id="_idTextAnchor475"/>Starvation</h2>
			<p>Starvation occurs when <a id="_idIndexMarker1570"/>a thread is unable to access shared resources <a id="_idIndexMarker1571"/>for an extended period, hindering its progress. This usually happens when higher-priority threads monopolize resources, causing lower-priority threads to be starved. Here’s an example <span class="No-Break">of starvation:</span></p>
			<pre class="source-code">
Object sharedResource = new Object();Thread highPriorityThread = new Thread(() -&gt; {
    synchronized (sharedResource) {
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
highPriorityThread.setPriority(Thread.MAX_PRIORITY);
highPriorityThread.start();
Thread lowPriorityThread = new Thread(() -&gt; {
    synchronized (sharedResource) {
        System.out.println("Low priority thread accessed
          the shared resource.");
    }
});
lowPriorityThread.setPriority(Thread.MIN_PRIORITY);
lowPriorityThread.start();</pre>
			<p>In this example, the high-priority <a id="_idIndexMarker1572"/>thread monopolizes the shared <a id="_idIndexMarker1573"/>resource for a long time, causing the low-priority thread to be starved. Please mind that thread priorities are only hints of how to the scheduler. It’s up to the OS implementation <span class="No-Break">to decide.</span></p>
			<h3>Strategies to prevent and resolve starvation</h3>
			<p>To prevent and <a id="_idIndexMarker1574"/>resolve starvation, you can employ the <a id="_idIndexMarker1575"/><span class="No-Break">following strategies:</span></p>
			<ul>
				<li><strong class="bold">Fairness</strong>: Ensure fair access to shared resources by using data structures or synchronization mechanisms that provide fairness guarantees, such as <strong class="source-inline">ReentrantLock</strong> with the <strong class="source-inline">fair</strong> parameter set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Monitor resource usage</strong>: Keep track of resource usage and adjust thread priorities or access patterns to <span class="No-Break">avoid monopolization.</span></li>
				<li><strong class="bold">Use time-sharing</strong>: Limit the time for which a thread can hold a resource or ensure that each thread gets a chance to access the <span class="No-Break">resource periodically.</span></li>
			</ul>
			<p>And that’s it for now! There’s a lot more to know about concurrency  in fact, we could write an entire book on it – but this will be enough to get you started. Time to roll up your sleeves and get started with the <span class="No-Break">hands-on part!</span></p>
			<h1 id="_idParaDest-476"><a id="_idTextAnchor476"/>Exercises</h1>
			<ol>
				<li><strong class="bold">Create threads</strong>: Create two classes, <strong class="source-inline">FeedingActivity</strong> and <strong class="source-inline">CleaningActivity</strong>. Make <strong class="source-inline">FeedingActivity</strong> extend the <strong class="source-inline">Thread</strong> class and <strong class="source-inline">CleaningActivity</strong> implement the <strong class="source-inline">Runnable</strong> interface. In both, override the <strong class="source-inline">run</strong> method to print out the activity’s name and a message indicating that the activity <span class="No-Break">is happening.</span></li>
				<li><strong class="bold">Use sleep() and join()</strong>: Create a <strong class="source-inline">ParkOperations</strong> class with two threads, one for feeding and another for cleaning. Start both threads and then use <strong class="source-inline">sleep()</strong> to simulate a time delay for the feeding activity. Use <strong class="source-inline">join()</strong> to ensure cleaning only happens after feeding <span class="No-Break">is complete.</span></li>
				<li><strong class="bold">Use ExecutorService</strong>: Create a <strong class="source-inline">TaskAssigner</strong> class where you use <strong class="source-inline">ExecutorService</strong> to assign tasks to employees. Tasks could be represented as <strong class="source-inline">Runnable</strong> or <strong class="source-inline">Callable</strong> objects, and employees could be represented <span class="No-Break">as threads.</span></li>
				<li>Solve race conditions in the following code snippet. <strong class="source-inline">updater1</strong> and <strong class="source-inline">updater2</strong> both are trying to update the status of the same dinosaur object. Since they run concurrently, it might lead to inconsistent outputs. Use the <strong class="source-inline">synchronized</strong> keyword or <strong class="source-inline">AtomicReference</strong> to prevent <span class="No-Break">data inconsistency:</span><pre class="source-code">
class Dinosaur {    private String status;    public Dinosaur(String status) {        this.status = status;    }    public String getStatus() {        return status;    }    public void setStatus(String status) {        this.status = status;    }}class DinosaurStatusUpdater implements Runnable {    private Dinosaur;    private String newStatus;    public DinosaurStatusUpdater(Dinosaur dinosaur,      String newStatus) {        this.dinosaur = dinosaur;        this.newStatus = newStatus;    }    @Override    public void run() {        dinosaur.setStatus(newStatus);        System.out.println("Dinosaur status set to: "          + dinosaur.getStatus());    }}public class Main {    public static void main(String[] args) {        Dinosaur dinosaur = new Dinosaur("Healthy");        Thread updater1 = new Thread(new          DinosaurStatusUpdater(dinosaur, "Feeding"));        Thread updater2 = new Thread(new          DinosaurStatusUpdater(dinosaur, "Resting"));        updater1.start();        updater2.start();    }}</pre></li>			</ol>
			<h1 id="_idParaDest-477"><a id="_idTextAnchor477"/>Project – Park Operations System – the calm before the storm</h1>
			<p>While our <a id="_idIndexMarker1576"/>park thrives with lively dinosaurs and excited visitors, our behind-the-scenes operations must run concurrently and seamlessly. The use of concurrency can ensure that tasks such as feeding dinosaurs, tracking dinosaur movements, and scheduling staff shifts are <span class="No-Break">handled efficiently.</span></p>
			<p>However, despite our best efforts, things start to go awry. A few dinosaurs become restless, security systems begin to glitch, and staff reports mysterious occurrences. Could this be the calm before the storm, and will we relive what happened in a famous competing park they made a <span class="No-Break">movie about?</span></p>
			<p>Update the following <em class="italic">Park Operations System</em> so that it concurrently safely handles different park operations. Use low-level threading, <strong class="source-inline">ExecutorService</strong>, atomic classes, synchronized blocks, and the <strong class="source-inline">Lock</strong> interface to manage concurrent access to shared resources. Prevent and handle race conditions, deadlocks, livelocks, and starvation scenarios to keep things under control as <span class="No-Break">tensions rise.</span></p>
			<p>Here’s the problematic code that causes <span class="No-Break">the issues:</span></p>
			<pre class="source-code">
import java.util.concurrent.*;class ParkStatus {
    private int foodStock;
    public ParkStatus(int foodStock) {
        this.foodStock = foodStock;
    }
    public int getFoodStock() {
        return this.foodStock;
    }
    public void reduceFood(int amount) {
        this.foodStock -= amount;
    }
}
class FeedingDinosaurs implements Runnable {
    private ParkStatus parkStatus;
    public FeedingDinosaurs(ParkStatus parkStatus) {
        this.parkStatus = parkStatus;
    }
    @Override
    public void run() {
        while (true) {
            parkStatus.reduceFood(1);
            System.out.println("Food stock after feeding: "
              + parkStatus.getFoodStock());
        }
    }
}
class TrackingMovements implements Runnable {
    private ParkStatus parkStatus;
    public TrackingMovements(ParkStatus parkStatus) {
        this.parkStatus = parkStatus;
    }
    @Override
    public void run() {
        while (true) {
            System.out.println("Current food stock: " +
              parkStatus.getFoodStock());
        }
    }
}
public class Main {
    public static void main(String[] args) {
        ParkStatus parkStatus = new ParkStatus(100);
        Thread feedingThread = new Thread(new
          FeedingDinosaurs(parkStatus));
        Thread trackingThread = new Thread(new
          TrackingMovements(parkStatus));
        feedingThread.start();
        trackingThread.start();
    }
}</pre>
			<p>As you can<a id="_idIndexMarker1577"/> see, there is a race condition when accessing and modifying <strong class="source-inline">foodStock</strong>. Additionally, these threads will run indefinitely, creating the potential for starvation of other threads in <span class="No-Break">the system.</span></p>
			<p>Here are some hints <span class="No-Break">for modifications:</span></p>
			<ul>
				<li><strong class="bold">Solving race condition</strong>: To solve the race condition, you could use a synchronized block, the <strong class="source-inline">Lock</strong> interface, or an atomic class. Remember, the goal is to ensure that the <strong class="source-inline">reduceFood()</strong> method and the reading of <strong class="source-inline">foodStock</strong> <span class="No-Break">happen atomically.</span></li>
				<li><strong class="source-inline">ExecutorService</strong>: Rather than creating threads directly, you could use <strong class="source-inline">ExecutorService</strong> to manage the threads. This provides more flexibility and utility methods for <span class="No-Break">handling threads.</span></li>
				<li><strong class="bold">Preventing indefinite looping</strong>: Currently, the <strong class="source-inline">run</strong> methods of <strong class="source-inline">FeedingDinosaurs</strong> and <strong class="source-inline">TrackingMovements</strong> run indefinitely. You could use conditions to control these loops and ensure <strong class="source-inline">ExecutorService</strong> shuts down after the operations <span class="No-Break">are complete.</span></li>
				<li><strong class="bold">Deadlocks, livelocks, and starvation</strong>: To simulate and prevent these, consider adding more shared resources and threads, and experiment with different locking orders, lock-releasing mechanisms, and <span class="No-Break">thread priorities.</span></li>
			</ul>
			<p>Remember to be cautious when modifying the code to prevent and handle these concurrency issues. Incorrect modifications could cause more problems than they solve. Thank you for saving <span class="No-Break">the day!</span></p>
			<h1 id="_idParaDest-478"><a id="_idTextAnchor478"/>Summary</h1>
			<p>Concurrency is a fundamental concept in modern software development, allowing applications to perform multiple tasks simultaneously, and efficiently utilizing system resources. In this chapter, we explored various aspects of concurrent programming in Java, from basic thread creation and management to advanced techniques for handling synchronization and <span class="No-Break">shared data.</span></p>
			<p>We started by introducing concurrency and its importance, followed by walking through creating threads using the <strong class="source-inline">Thread</strong> class, the <strong class="source-inline">Runnable</strong> interface, and implementing the <strong class="source-inline">Runnable</strong> interface with lambda expressions. We then moved on to two thread management methods: <strong class="source-inline">sleep()</strong> and <strong class="source-inline">join()</strong>. Next, we talked about <strong class="source-inline">ExecutorService</strong>, which provides a higher level of abstraction for managing thread execution and made our lives a little easier (after making it <span class="No-Break">harder first).</span></p>
			<p>A crucial aspect of concurrent programming is avoiding data races. We demonstrated a data race example and discussed strategies to resolve them, including the use of atomic classes and the <strong class="source-inline">synchronized</strong> keyword. We also explore the <strong class="source-inline">Lock</strong> interface as an alternative to the <strong class="source-inline">synchronized</strong> keyword. This gave us more flexibility <span class="No-Break">and control.</span></p>
			<p>Concurrent collections, such as <strong class="source-inline">ConcurrentHashMap</strong>, <strong class="source-inline">CopyOnWriteArrayList</strong>, and <strong class="source-inline">ConcurrentLinkedQueue</strong>, provide thread-safe alternatives to standard Java collections. We briefly mentioned their benefits and use cases and saw some examples of <span class="No-Break">their usage.</span></p>
			<p>Finally, we examined common threading problems, including data races, race conditions, deadlocks, livelocks, and starvation. We provided examples and strategies to prevent and resolve these issues. By this point, you should have a solid understanding of concurrent programming in Java and be equipped with the skills to deal with <span class="No-Break">multi-threaded applications.</span></p>
		</div>
	</body></html>