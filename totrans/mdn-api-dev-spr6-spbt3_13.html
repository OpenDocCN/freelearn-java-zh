<html><head></head><body>
<div id="_idContainer065">
<h1 class="chapter-number" id="_idParaDest-289"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-290"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.2.1">Getting Started with GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, you will learn about the fundamentals of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">GraphQL</span></strong><span class="koboSpan" id="kobo.5.1">, including its </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">schema definition language</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">SDL</span></strong><span class="koboSpan" id="kobo.9.1">), queries, mutations, and subscriptions. </span><span class="koboSpan" id="kobo.9.2">The GraphQL API is popular in hand-held device-based apps such as mobile apps because it is fast and efficient in fetching the data and better than REST in certain cases. </span><span class="koboSpan" id="kobo.9.3">Therefore, it is important to learn about GraphQL. </span><span class="koboSpan" id="kobo.9.4">You will learn more about its comparison with REST in the </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Comparing GraphQL with REST</span></em><span class="koboSpan" id="kobo.11.1"> section in this chapter. </span><span class="koboSpan" id="kobo.11.2">After completing this chapter, you will know the basics of GraphQL, including its semantics, schema design, and everything you need to develop a GraphQL-based API using Spring and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Spring Boot.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Getting to </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">know GraphQL</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Learning the fundamentals </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">of GraphQL</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Designing a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">GraphQL schema</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Testing GraphQL queries </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">and mutations</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Solving the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">N+1 problem</span></span></li>
</ul>
<h1 id="_idParaDest-291"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">This chapter covers the theory behind GraphQL and related concepts. </span><span class="koboSpan" id="kobo.26.2">It is advised to go through this chapter first to develop and test the GraphQL-based service code presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">next chapter.</span></span></p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.28.1">Getting to know GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.29.1">You might have heard of or be </span><a id="_idIndexMarker1152"/><span class="koboSpan" id="kobo.30.1">aware of GraphQL, which has become more popular in the API space in past few years and is becoming the preferred way of implementing APIs for handheld devices and </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the web.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">GraphQL is a declarative query and manipulation language and server-side runtime for APIs. </span><span class="koboSpan" id="kobo.32.2">GraphQL empowers the client to query exactly the data they want – no more, </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">no less.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">We’ll discuss its brief</span><a id="_idIndexMarker1153"/><span class="koboSpan" id="kobo.35.1"> history in the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">next subsection.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.37.1">A brief history of GraphQL</span></h2>
<p><span class="koboSpan" id="kobo.38.1">In 2011, Facebook was facing challenges in terms of improving the performance of its website on mobile browsers. </span><span class="koboSpan" id="kobo.38.2">They started </span><a id="_idIndexMarker1154"/><span class="koboSpan" id="kobo.39.1">building their own mobile app with mobile-native technologies. </span><span class="koboSpan" id="kobo.39.2">However, APIs were not up to the mark because of hierarchical and recursive data. </span><span class="koboSpan" id="kobo.39.3">They wanted to optimize their network calls. </span><span class="koboSpan" id="kobo.39.4">Note that in those days, mobile network speed was in Kb/s in some parts of the world. </span><span class="koboSpan" id="kobo.39.5">Having a fast, high-quality mobile app was going to be the key to their success, since their consumers had started shifting to </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">mobile devices.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">In 2012, a few engineers on Facebook – Lee Byron, Dan Schafer, and Nick Schrock – teamed up to create GraphQL. </span><span class="koboSpan" id="kobo.41.2">Initially, it was used to design and develop Facebook’s newsfeed feature, but later, it was used across its infrastructure, being used internally at Facebook exclusively until it was open sourced in 2015, when the GraphQL specification and its JavaScript implementation were made available to the public. </span><span class="koboSpan" id="kobo.41.3">Soon, other language implementations of the GraphQL specification started rolling out, </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">including Java.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">I think you would enjoy watching this GraphQL documentary at </span><a href="https://www.youtube.com/watch?v=783ccP__No8"><span class="koboSpan" id="kobo.44.1">https://www.youtube.com/watch?v=783ccP__No8</span></a><span class="koboSpan" id="kobo.45.1">, which walks through GraphQL’s journey from being an internal Facebook tool to its </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">current success.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.47.1">Did you know?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.48.1">Netflix and Coursera were also working on a similar idea to build efficient and performant APIs. </span><span class="koboSpan" id="kobo.48.2">Coursera didn’t take it forward, but Netflix open </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">sourced Falcor.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.50.1">Comparing GraphQL with REST</span></h2>
<p><span class="koboSpan" id="kobo.51.1">You developed APIs using REST in </span><em class="italic"><span class="koboSpan" id="kobo.52.1">Part 1: RESTful Web Services</span></em><span class="koboSpan" id="kobo.53.1"> of this book. </span><span class="koboSpan" id="kobo.53.2">In fact, an example e-commerce</span><a id="_idIndexMarker1155"/><span class="koboSpan" id="kobo.54.1"> UI app also consumed REST APIs to implement its e-commerce </span><a id="_idIndexMarker1156"/><span class="koboSpan" id="kobo.55.1">functionality in the first part of this book. </span><span class="koboSpan" id="kobo.55.2">We are going to keep referring to REST in this chapter so that we can understand the necessary GraphQL concepts wherever they’re applicable. </span><span class="koboSpan" id="kobo.55.3">This correlation should help you grasp the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">concepts easily.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">GraphQL is more powerful, flexible, and efficient than REST. </span><span class="koboSpan" id="kobo.57.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">understand why.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Let’s consider an example where a user logs in to an e-commerce UI app and automatically navigates to the product listing page. </span><span class="koboSpan" id="kobo.59.2">When this happens, the UI app consumes three different endpoints, </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.61.1">The user endpoint, to fetch </span><a id="_idIndexMarker1157"/><span class="koboSpan" id="kobo.62.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">user’s information</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">The product endpoint, to fetch the </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">product list</span></span></li>
<li><span class="koboSpan" id="kobo.66.1">The cart endpoint, to fetch the cart items from the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">user’s cart</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.68.1">So, basically, you must </span><a id="_idIndexMarker1158"/><span class="koboSpan" id="kobo.69.1">make three calls in REST to fetch the required information in a fixed structure (you can’t change the fields that are sent in response) from </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">On the other hand, GraphQL can fetch a user’s information, a user’s cart data, and the product list in a single call. </span><span class="koboSpan" id="kobo.71.2">Thus, it reduces the number of network calls from three to one. </span><span class="koboSpan" id="kobo.71.3">GraphQL just exposes a single endpoint, unlike REST, where you must define an endpoint for each use case. </span><span class="koboSpan" id="kobo.71.4">You might say that you can write a new REST endpoint that does that. </span><span class="koboSpan" id="kobo.71.5">Yes, that may solve this specific use case, but it is not flexible; it won’t allow for </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">quick iteration.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Moreover, GraphQL lets you describe the fields you want to fetch from the backend in a request. </span><span class="koboSpan" id="kobo.73.2">The server response contains only those fields, which are sent as a part of the request– no more, </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">no less.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">For example, you may want to add user reviews to products. </span><span class="koboSpan" id="kobo.75.2">For this, you just need to add the reviews field to the GraphQL query. </span><span class="koboSpan" id="kobo.75.3">Similarly, you don’t need to consume extra fields. </span><span class="koboSpan" id="kobo.75.4">You just add those fields that you need to the GraphQL query. </span><span class="koboSpan" id="kobo.75.5">On the other hand, REST’s response contains predefined fields, regardless of whether you need certain fields in the response object or not. </span><span class="koboSpan" id="kobo.75.6">Then, you must filter the required fields at the client end. </span><span class="koboSpan" id="kobo.75.7">Therefore, we can say that GraphQL uses network bandwidth more efficiently by avoiding </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">over-/under-fetching problems.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">GraphQL APIs don’t need constant changes as happens with REST, where you may need to change the API or add new APIs for a requirement change. </span><span class="koboSpan" id="kobo.77.2">This improves the development speed and iteration. </span><span class="koboSpan" id="kobo.77.3">You can easily add new fields or mark thsose that have been deprecated (fields not being used by a client anymore). </span><span class="koboSpan" id="kobo.77.4">Therefore, you can make the changes in the client without impacting the backend. </span><span class="koboSpan" id="kobo.77.5">In short, you can write evolving APIs without any versioning and </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">breaking changes.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">REST offers caching </span><a id="_idIndexMarker1159"/><span class="koboSpan" id="kobo.80.1">using built-in HTTP specifications. </span><span class="koboSpan" id="kobo.80.2">However, GraphQL does not follow the HTTP </span><a id="_idIndexMarker1160"/><span class="koboSpan" id="kobo.81.1">specifications; instead, it makes use of libraries such as Apollo/Relay for caching. </span><span class="koboSpan" id="kobo.81.2">However, REST is based on HTTP and does not follow any specification for implementation, which may lead to inconsistent implementations, as we discussed when comparing REST with gRPC. </span><span class="koboSpan" id="kobo.81.3">You can use the HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">GET</span></strong><span class="koboSpan" id="kobo.83.1"> method to delete </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">a resource.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">GraphQL is superior to REST APIs in terms of its usage in mobile clients. </span><span class="koboSpan" id="kobo.85.2">The capabilities of GraphQL APIs are also defined using strong types. </span><span class="koboSpan" id="kobo.85.3">These types are part of the schema that contains the API definitions. </span><span class="koboSpan" id="kobo.85.4">These types are written in the</span><a id="_idIndexMarker1161"/><span class="koboSpan" id="kobo.86.1"> schema </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">using </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.88.1">SDL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">GraphQL acts as a contract between the server and the client. </span><span class="koboSpan" id="kobo.90.2">You can correlate the GraphQL schema with the</span><a id="_idIndexMarker1162"/><span class="koboSpan" id="kobo.91.1"> gRPC </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">interface definition language</span></strong><span class="koboSpan" id="kobo.93.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.94.1">IDL</span></strong><span class="koboSpan" id="kobo.95.1">) file and OpenAPI </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">specification file.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">We’ll discuss the fundamentals of GraphQL in the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">next section.</span></span></p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.99.1">Learning the fundamentals of GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.100.1">GraphQL APIs contain three important </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">root types</span></strong><span class="koboSpan" id="kobo.102.1"> – </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">query</span></strong><span class="koboSpan" id="kobo.104.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">mutation</span></strong><span class="koboSpan" id="kobo.106.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">subscription</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">These are all </span><a id="_idIndexMarker1163"/><span class="koboSpan" id="kobo.109.1">defined in the GraphQL schema using special </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">SDL </span></span><span class="No-Break"><a id="_idIndexMarker1164"/></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">GraphQL provides a single</span><a id="_idIndexMarker1165"/><span class="koboSpan" id="kobo.113.1"> endpoint that returns the JSON response based on the request, which can be a query, a mutation, or </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">a subscription.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">First, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">understand queries.</span></span></p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.117.1">Exploring the Query type</span></h2>
<p><span class="koboSpan" id="kobo.118.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Query</span></strong><span class="koboSpan" id="kobo.120.1"> type is </span><a id="_idIndexMarker1166"/><span class="koboSpan" id="kobo.121.1">used for reading operations that fetch information from the server. </span><span class="koboSpan" id="kobo.121.2">A </span><a id="_idIndexMarker1167"/><span class="koboSpan" id="kobo.122.1">single </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Query</span></strong><span class="koboSpan" id="kobo.124.1"> type can contain many queries. </span><span class="koboSpan" id="kobo.124.2">Let’s write a query using SDL to retrieve the logged-in user, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">GraphQL schema:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
type Query {  </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">me</span></strong><span class="koboSpan" id="kobo.128.1">: LogginInUser
  </span><strong class="bold"><span class="koboSpan" id="kobo.129.1"># You can add other queries here</span></strong><span class="koboSpan" id="kobo.130.1">
}
type </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">LoggedInUser</span></strong><span class="koboSpan" id="kobo.132.1"> {
  id: </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">ID</span></strong><span class="koboSpan" id="kobo.134.1">
  accessToken: </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">String</span></strong><span class="koboSpan" id="kobo.136.1">
  refreshToken: String
  username: String
}</span></pre>
<p><span class="koboSpan" id="kobo.137.1">Here, you have done </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">two things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.139.1">You have defined </span><a id="_idIndexMarker1168"/><span class="koboSpan" id="kobo.140.1">the query root of the GraphQL interface, which contains the query you can run. </span><span class="koboSpan" id="kobo.140.2">It contains just a single query type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">me</span></strong><span class="koboSpan" id="kobo.142.1">, that returns an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">LoggedInUser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.144.1"> type.</span></span></li>
<li><span class="koboSpan" id="kobo.145.1">You have specified the user-defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">LoggedInUser</span></strong><span class="koboSpan" id="kobo.147.1"> object type, which contains four fields. </span><span class="koboSpan" id="kobo.147.2">These </span><a id="_idIndexMarker1169"/><span class="koboSpan" id="kobo.148.1">fields are followed by their types. </span><span class="koboSpan" id="kobo.148.2">In the preceding code, you used GraphQL’s built-in </span><em class="italic"><span class="koboSpan" id="kobo.149.1">scalar types</span></em><span class="koboSpan" id="kobo.150.1">, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">ID</span></strong><span class="koboSpan" id="kobo.152.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">String</span></strong><span class="koboSpan" id="kobo.154.1">, to define the types of the fields. </span><span class="koboSpan" id="kobo.154.2">We’ll discuss these types later in this chapter when we discuss built-in scalar types </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">in detail.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.156.1">Once you have this schema implementation on the server and have fired the following GraphQL query, you will only get the fields you requested, along with their values, as a JSON object </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">in response.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">You can find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">me</span></strong><span class="koboSpan" id="kobo.160.1"> query and its JSON response in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
# Request input</span><strong class="bold"><span class="koboSpan" id="kobo.163.1">{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.164.1">  me {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.165.1">    id</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.166.1">    username</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.167.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.168.1">}</span></strong><span class="koboSpan" id="kobo.169.1">
#JSON response
{
  "data": {
    "me": {
      "id": "asdf90asdkqwe09kl",
      "username": "scott"
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.170.1">Interestingly, here GraphQL’s request input does not start with a query because </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">Query</span></strong><span class="koboSpan" id="kobo.172.1"> is the default for the </span><a id="_idIndexMarker1170"/><span class="koboSpan" id="kobo.173.1">payload. </span><span class="koboSpan" id="kobo.173.2">This is called an </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">anonymous query</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">The GraphQL handler on the server always assumes the</span><a id="_idIndexMarker1171"/><span class="koboSpan" id="kobo.176.1"> payload to be a</span><a id="_idIndexMarker1172"/><span class="koboSpan" id="kobo.177.1"> query unless you specify something specific, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Mutation</span></strong><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">However, if you want, you can also prefix the query request input with </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">query</span></strong><span class="koboSpan" id="kobo.181.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.183.1">query</span></strong><span class="koboSpan" id="kobo.184.1"> {  me {
    id
    username
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.185.1">As you can see, this allows you to only query those fields that you need. </span><span class="koboSpan" id="kobo.185.2">Here, only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">id</span></strong><span class="koboSpan" id="kobo.187.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">username</span></strong><span class="koboSpan" id="kobo.189.1"> fields were requested from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">LoggedInUser</span></strong><span class="koboSpan" id="kobo.191.1"> type, and the server responded with only these two fields. </span><span class="koboSpan" id="kobo.191.2">The request payload is enclosed in curly braces </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">{}</span></strong><span class="koboSpan" id="kobo.193.1">. </span><span class="koboSpan" id="kobo.193.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">#</span></strong><span class="koboSpan" id="kobo.195.1"> for commenting in </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the schema.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Now, you know how to define </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">Query</span></strong><span class="koboSpan" id="kobo.199.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">object</span></strong><span class="koboSpan" id="kobo.201.1"> types in a GraphQL schema. </span><span class="koboSpan" id="kobo.201.2">You also learned how to form a GraphQL request payload according to its query type and the expected </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">JSON </span></span><span class="No-Break"><a id="_idIndexMarker1173"/></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">response.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">We’ll learn about GraphQL </span><a id="_idIndexMarker1174"/><span class="koboSpan" id="kobo.205.1">mutations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">next subsection.</span></span></p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.207.1">Exploring the Mutation type</span></h2>
<p><span class="koboSpan" id="kobo.208.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">Mutation</span></strong><span class="koboSpan" id="kobo.210.1"> type is used in</span><a id="_idIndexMarker1175"/><span class="koboSpan" id="kobo.211.1"> GraphQL requests for all the add, update, and delete operations that get performed on the server. </span><span class="koboSpan" id="kobo.211.2">A single </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Mutation</span></strong><span class="koboSpan" id="kobo.213.1"> type can contain</span><a id="_idIndexMarker1176"/><span class="koboSpan" id="kobo.214.1"> many mutations. </span><span class="koboSpan" id="kobo.214.2">Let’s define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">addItemInCart</span></strong><span class="koboSpan" id="kobo.216.1"> mutation that adds a new item to </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">the cart:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
type Mutation {  addItemInCart(productId: ID, qty: </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Int</span></strong><span class="koboSpan" id="kobo.220.1">): </span><strong class="bold"><span class="koboSpan" id="kobo.221.1">[</span></strong><span class="koboSpan" id="kobo.222.1">Item</span><strong class="bold"><span class="koboSpan" id="kobo.223.1">]</span></strong><span class="koboSpan" id="kobo.224.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.225.1"># You can add other mutations here</span></strong><span class="koboSpan" id="kobo.226.1">
}
type Item {
  id: ID!
</span><span class="koboSpan" id="kobo.226.2">  productId: ID
  qty: Int
}</span></pre>
<p><span class="koboSpan" id="kobo.227.1">Here, you have defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">Mutation</span></strong><span class="koboSpan" id="kobo.229.1"> type and a new object type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Item</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">The mutation is added and called </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">addItemInCart</span></strong><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">Query</span></strong><span class="koboSpan" id="kobo.235.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Mutation</span></strong><span class="koboSpan" id="kobo.237.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Subscription</span></strong><span class="koboSpan" id="kobo.239.1"> types can pass arguments. </span><span class="koboSpan" id="kobo.239.2">To define the necessary parameters, you can enclose the named arguments with </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">()</span></strong><span class="koboSpan" id="kobo.241.1"> brackets; the arguments are divided by commas. </span><span class="koboSpan" id="kobo.241.2">The signature of </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">addItemInCart</span></strong><span class="koboSpan" id="kobo.243.1"> contains two arguments and returns a list of cart items. </span><span class="koboSpan" id="kobo.243.2">A list is marked using </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">[]</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.245.1">brackets.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.246.1">Optional and required arguments</span></p>
<p class="callout"><span class="koboSpan" id="kobo.247.1">Let’s say you declare an argument with a default value, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">following mutation:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">pay(amount: Float, currency: String = "</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">USD"): Payment</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.251.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">currency</span></strong><span class="koboSpan" id="kobo.253.1"> is an optional argument. </span><span class="koboSpan" id="kobo.253.2">It contains the default value, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">amount</span></strong><span class="koboSpan" id="kobo.255.1"> is a required field because it does not contain any </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">default value.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Please note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Int</span></strong><span class="koboSpan" id="kobo.259.1"> is a built-in scalar type for signed 32-bit integers. </span><span class="koboSpan" id="kobo.259.2">Default values are null in GraphQL. </span><span class="koboSpan" id="kobo.259.3">If you </span><a id="_idIndexMarker1177"/><span class="koboSpan" id="kobo.260.1">want to force a non-nullable value for any field, then its type should be marked with an exclamation mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">!</span></strong><span class="koboSpan" id="kobo.262.1">). </span><span class="koboSpan" id="kobo.262.2">Once it (</span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">!</span></strong><span class="koboSpan" id="kobo.264.1">) has been applied to any field in the schema, the GraphQL server will always provide a value instead of a null for that field when it is placed in the request payload by the client. </span><span class="koboSpan" id="kobo.264.2">You</span><a id="_idIndexMarker1178"/><span class="koboSpan" id="kobo.265.1"> can also declare a list with exclamation marks; for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">items: [Item]!</span></strong><span class="koboSpan" id="kobo.267.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">items: [Item!]!</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">Both declarations will provide zero or more items in a list. </span><span class="koboSpan" id="kobo.269.3">However, the latter would provide only a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Item</span></strong><span class="koboSpan" id="kobo.271.1"> object (i.e., a </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">non-nullable value).</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Once you have this schema implementation on the server, you can use the following GraphQL query. </span><span class="koboSpan" id="kobo.273.2">You will get only the fields you requested, along with their values, as a </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">JSON object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.275.1">
# Request input</span><strong class="bold"><span class="koboSpan" id="kobo.276.1">mutation</span></strong><span class="koboSpan" id="kobo.277.1"> {
  addItemInCart(productId: "qwer90asdkqwe09kl", qty: 2) {
    id
    productId
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.278.1">You can see that this time, the GraphQL request input starts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">mutation</span></strong><span class="koboSpan" id="kobo.280.1"> keyword. </span><span class="koboSpan" id="kobo.280.2">If you don’t start a mutation with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">mutation</span></strong><span class="koboSpan" id="kobo.282.1"> keyword, then you might get an error with a message along the lines of </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Field ‘addItemInCart’ doesn’t exist on type ‘Query’</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">This is because the server treats the request payload as </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">a query.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Here, you must add the required arguments to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">addItemInCart</span></strong><span class="koboSpan" id="kobo.288.1"> mutation and then add the fields (</span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">id</span></strong><span class="koboSpan" id="kobo.290.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">productId</span></strong><span class="koboSpan" id="kobo.292.1">) you want to retrieve in response. </span><span class="koboSpan" id="kobo.292.2">Once the request has been processed successfully, you will get a JSON output like </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
#JSON response{
  "data": {
    addItemInCart: [
      {
        "id": "zxcv90asdkqwe09kl",
        "productId": "qwer90asdkqwe09kl"
      }
    ]
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.295.1">Here, the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">id</span></strong><span class="koboSpan" id="kobo.297.1"> field is generated </span><a id="_idIndexMarker1179"/><span class="koboSpan" id="kobo.298.1">by the server. </span><span class="koboSpan" id="kobo.298.2">Similarly, you can write other mutations, such as delete and update, in the schema. </span><span class="koboSpan" id="kobo.298.3">Then, you can use the</span><a id="_idIndexMarker1180"/><span class="koboSpan" id="kobo.299.1"> payload in the GraphQL request to process the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">mutation accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">We’ll explore the GraphQL </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">Subscription</span></strong><span class="koboSpan" id="kobo.303.1"> type in the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">next subsection.</span></span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.305.1">Exploring the Subscription type</span></h2>
<p><span class="koboSpan" id="kobo.306.1">The concept of subscriptions will be </span><a id="_idIndexMarker1181"/><span class="koboSpan" id="kobo.307.1">new to you if you are only familiar with REST. </span><span class="koboSpan" id="kobo.307.2">In the absence of GraphQL, you might use polling or WebSockets to implement </span><a id="_idIndexMarker1182"/><span class="koboSpan" id="kobo.308.1">similar functionality. </span><span class="koboSpan" id="kobo.308.2">There are many use cases where you will need the subscription feature, including </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.310.1">Live score updates or </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">election results</span></span></li>
<li><span class="koboSpan" id="kobo.312.1">Batch </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">processing updates</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.314.1">There are many such cases where you will need to immediately update events. </span><span class="koboSpan" id="kobo.314.2">GraphQL provides a subscription feature for this use case. </span><span class="koboSpan" id="kobo.314.3">In such cases, the client subscribes to the event by initiating and holding a steady connection. </span><span class="koboSpan" id="kobo.314.4">When the subscribed event occurs, the server pushes the resultant event data to the client. </span><span class="koboSpan" id="kobo.314.5">For example, let’s say you want to know whenever there is a change in any item’s inventory in an e-commerce app. </span><span class="koboSpan" id="kobo.314.6">Any change in the quantity of an item would trigger the event and the subscription would get a response with the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">updated quantity.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">This data is sent as a stream through an initiated connection, rather than through a request/response kind of </span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.317.1">communication (which was used in the cases </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">of query/mutation).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.319.1">Recommended approach</span></p>
<p class="callout"><span class="koboSpan" id="kobo.320.1">It is recommended that a subscription should only be used when a small update occurs for a large object (such as batch processing), or there are live updates with low latency, such as a live score update. </span><span class="koboSpan" id="kobo.320.2">Otherwise, you should use polling (executing a query periodically at a </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">specified interval).</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Let’s create a subscription in a</span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.323.1"> schema, </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
type </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Subscription</span></strong><span class="koboSpan" id="kobo.327.1"> {  orderShipped(customerID: ID!): Order
  </span><strong class="bold"><span class="koboSpan" id="kobo.328.1"># You can add other subscriptions here</span></strong><span class="koboSpan" id="kobo.329.1">
}
# Order type contains order information and another object
# Shipping. </span><span class="koboSpan" id="kobo.329.2">Shipping contains id and estDeliveryDate and
# carrier fields
type Order {
  # other fields omitted for brevity
  shipping: Shipping
}
type Shipping {
  Id: ID!
</span><span class="koboSpan" id="kobo.329.3">  estDeliveryDate: String
  carrier: String
}</span></pre>
<p><span class="koboSpan" id="kobo.330.1">Here, we have defined an </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">orderShipped</span></strong><span class="koboSpan" id="kobo.332.1"> subscription that accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">customer ID</span></strong><span class="koboSpan" id="kobo.334.1"> as an argument and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Order</span></strong><span class="koboSpan" id="kobo.336.1">. </span><span class="koboSpan" id="kobo.336.2">Clients subscribe to this event, and then whenever an order is shipped for the given </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">customerId</span></strong><span class="koboSpan" id="kobo.338.1">, the server will push the requested order details </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.339.1">to the client using </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">a stream.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">You can use the following </span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.342.1">GraphQL request to subscribe to the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">GraphQL subscription:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
# Request Inputsubscription {
  orderShipped(customerID: "customer90asdkqwe09kl") {
    shipping {
      estDeliveryDate
      trackingId
    }
  }
}
# JSON Output
{
  "data": {
    "orderShipped": {
      "estDeliveryDate": "13-Aug-2022",
      "trackingId": "tracking90asdkqwe09kl"
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.345.1">The client will request a JSON response whenever any order belonging to a given customer is shipped. </span><span class="koboSpan" id="kobo.345.2">The server pushes these updates to all the clients who subscribed to this </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">GraphQL subscription.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">In this section, you learned how to declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Query</span></strong><span class="koboSpan" id="kobo.349.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Mutation</span></strong><span class="koboSpan" id="kobo.351.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Subscription</span></strong><span class="koboSpan" id="kobo.353.1"> types in a </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">GraphQL schema.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">You have defined scalar</span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.356.1"> types and the user-defined object types in a schema. </span><span class="koboSpan" id="kobo.356.2">You also explored how to write a GraphQL request input for a query, mutation, </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">or subscription.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">Now, you know how to </span><a id="_idIndexMarker1188"/><span class="koboSpan" id="kobo.359.1">define the operation parameters in root types and pass arguments while sending GraphQL requests. </span><span class="koboSpan" id="kobo.359.2">Note that the non-nullable field in the schema can be marked by an exclamation mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">!</span></strong><span class="koboSpan" id="kobo.361.1">). </span><span class="koboSpan" id="kobo.361.2">For arrays, or lists of objects, you must use square </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">brackets (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">[]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">In the next section, we’ll deep dive into </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">GraphQL schema.</span></span></p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.367.1">Designing a GraphQL schema</span></h1>
<p><span class="koboSpan" id="kobo.368.1">A schema is a GraphQL file that is </span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.369.1">written using DSL syntax. </span><span class="koboSpan" id="kobo.369.2">Primarily, it contains root types (query, mutation, and subscription), and the respective types that are used in root types, such as object types, scalar types, interfaces, union types, input types, </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">and fragments.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">First, let’s discuss these types. </span><span class="koboSpan" id="kobo.371.2">You learned about root types (query, mutation, and subscription) and object types in the previous section. </span><span class="koboSpan" id="kobo.371.3">Let’s now learn more about </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">scalar types.</span></span></p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.373.1">Understanding scalar types</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.374.1">Scalar types</span></strong><span class="koboSpan" id="kobo.375.1"> resolve concrete data. </span><span class="koboSpan" id="kobo.375.2">There</span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.376.1"> are three kinds of scalar types – built-in scalar types, custom scalar types, and enumeration types. </span><span class="koboSpan" id="kobo.376.2">Let’s discuss built-in scalar</span><a id="_idIndexMarker1191"/><span class="koboSpan" id="kobo.377.1"> types first. </span><span class="koboSpan" id="kobo.377.2">GraphQL provides the following five kinds of built-in </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">scalar types:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Int</span></strong><span class="koboSpan" id="kobo.380.1">: This stores integers, and is represented by a signed </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">32-bit integer.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Float</span></strong><span class="koboSpan" id="kobo.383.1">: This stores a signed, double-precision, </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">floating-point value.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">String</span></strong><span class="koboSpan" id="kobo.386.1">: This stores a sequence of </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">UTF-8 characters.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Boolean</span></strong><span class="koboSpan" id="kobo.389.1">: This stores a Boolean value – true </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">or false.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">ID</span></strong><span class="koboSpan" id="kobo.392.1">: This is used to define the object identifier string. </span><span class="koboSpan" id="kobo.392.2">This can only be serialized as a string, and is </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">not human-readable.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.394.1">You can also define your own </span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.395.1">scalar types, which are known as custom scalar types. </span><span class="koboSpan" id="kobo.395.2">An example is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Date</span></strong><span class="koboSpan" id="kobo.397.1"> type, which can be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
 scalar Date</span></pre> <p><span class="koboSpan" id="kobo.400.1">You need to write an implementation that determines the serialization, deserialization, and validation of these custom scalar types. </span><span class="koboSpan" id="kobo.400.2">For example, the date can be treated as a Unix timestamp, or a string with a particular date format in a custom scalar </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Date</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.402.1">type case.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Another special scalar type is</span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.404.1"> the enumeration type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">enum</span></strong><span class="koboSpan" id="kobo.406.1">), which is used to define a particular set of allowed values. </span><span class="koboSpan" id="kobo.406.2">Let’s define an order status enumeration, as </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.408.1">enum</span></strong><span class="koboSpan" id="kobo.409.1"> OrderStatus {  CREATED
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}</span></pre>
<p><span class="koboSpan" id="kobo.410.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">OrderStatus</span></strong><span class="koboSpan" id="kobo.412.1"> enumeration type represents the order status at a given point </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">in time.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">We’ll next examine GraphQL fragments in the following subsection before exploring </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">other types.</span></span></p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.416.1">Understanding fragments</span></h2>
<p><span class="koboSpan" id="kobo.417.1">You may encounter</span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.418.1"> conflicting scenarios while</span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.419.1"> querying on the client side. </span><span class="koboSpan" id="kobo.419.2">You may have two or more queries that return the same result (the same object or set of fields). </span><span class="koboSpan" id="kobo.419.3">To avoid this conflict, you can give the query result a name. </span><span class="koboSpan" id="kobo.419.4">This name is</span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.420.1"> known as </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">an </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.422.1">alias</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">Let’s use an alias in the </span><a id="_idIndexMarker1197"/><span class="No-Break"><span class="koboSpan" id="kobo.425.1">following query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
query HomeAndBillingAddress {  </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">home</span></strong><span class="koboSpan" id="kobo.428.1">: getAddress(type: "home") {
    number
    residency
    street
    city
    pincode
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">billing</span></strong><span class="koboSpan" id="kobo.430.1">: getAddress(type: "home") {
    number
    residency
    street
    city
    pincode
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.431.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">HomeAndBillingAddress</span></strong><span class="koboSpan" id="kobo.433.1"> is a named query that contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">getAddress</span></strong><span class="koboSpan" id="kobo.435.1"> query operation. </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">getAddress</span></strong><span class="koboSpan" id="kobo.437.1"> is being used twice, which results in it returning the same set of fields. </span><span class="koboSpan" id="kobo.437.2">Therefore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">home</span></strong><span class="koboSpan" id="kobo.439.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">billing</span></strong><span class="koboSpan" id="kobo.441.1"> aliases are used to differentiate the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">result object.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">getAddress</span></strong><span class="koboSpan" id="kobo.445.1"> query</span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.446.1"> may return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Address</span></strong><span class="koboSpan" id="kobo.448.1"> object. </span><span class="koboSpan" id="kobo.448.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Address</span></strong><span class="koboSpan" id="kobo.450.1"> object may have additional fields, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">type</span></strong><span class="koboSpan" id="kobo.452.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">state</span></strong><span class="koboSpan" id="kobo.454.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">country</span></strong><span class="koboSpan" id="kobo.456.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">contactNo</span></strong><span class="koboSpan" id="kobo.458.1">. </span><span class="koboSpan" id="kobo.458.2">So, when you have queries that may use the same set of fields, you can create a </span><strong class="bold"><span class="koboSpan" id="kobo.459.1">fragment</span></strong><span class="koboSpan" id="kobo.460.1"> and use it in queries. </span><span class="koboSpan" id="kobo.460.2">A fragment logically creates a subgroup of fields from the existing object in the GraphQL schema that can be reused at multiple places, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">code snippet.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">Let’s create a fragment </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.463.1">and replace the common fields in the previous </span><a id="_idIndexMarker1200"/><span class="No-Break"><span class="koboSpan" id="kobo.464.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
 query HomeAndBillingAddress {   </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">home</span></strong><span class="koboSpan" id="kobo.467.1">: getAddress(type: "home") {
     </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">...addressFragment</span></strong><span class="koboSpan" id="kobo.469.1">
   }
   </span><strong class="bold"><span class="koboSpan" id="kobo.470.1">billing</span></strong><span class="koboSpan" id="kobo.471.1">: getAddress(type: "home") {
     </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">...addressFragment</span></strong><span class="koboSpan" id="kobo.473.1">
   }
 }
 </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">fragment addressFragment on Address</span></strong><span class="koboSpan" id="kobo.475.1"> {
   number
   residency
   street
   city
   pincode
 }</span></pre>
<p><span class="koboSpan" id="kobo.476.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">addressFragment</span></strong><span class="koboSpan" id="kobo.478.1"> fragment has been created and used in </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">the query.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">You can also create an </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">inline fragment</span></strong><span class="koboSpan" id="kobo.482.1"> in the query. </span><span class="koboSpan" id="kobo.482.2">An inline fragment is a fragment that you can create on the fly in a GraphQL payload without declaring it explicitly. </span><span class="koboSpan" id="kobo.482.3">Such fragments are helpful when a response object</span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.483.1"> contains the nested object and you just want a few fields of the nested object rather than all the object fields. </span><span class="koboSpan" id="kobo.483.2">Inline fragments can be used when a querying field returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">Interface</span></strong><span class="koboSpan" id="kobo.485.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Union</span></strong><span class="koboSpan" id="kobo.487.1"> type. </span><span class="koboSpan" id="kobo.487.2">We will explore inline fragments in more detail later in the </span><em class="italic"><span class="koboSpan" id="kobo.488.1">Understanding interfaces</span></em><span class="koboSpan" id="kobo.489.1"> subsection under the </span><em class="italic"><span class="koboSpan" id="kobo.490.1">Designing a GraphQL </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.491.1">schema</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">We’ll look at GraphQL interfaces in the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">next subsection.</span></span></p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.495.1">Understanding interfaces</span></h2>
<p><span class="koboSpan" id="kobo.496.1">GraphQL interfaces are abstract. </span><span class="koboSpan" id="kobo.496.2">You may have a few fields that are common across multiple objects. </span><span class="koboSpan" id="kobo.496.3">You can create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">interface</span></strong><span class="koboSpan" id="kobo.498.1"> type for such sets of fields. </span><span class="koboSpan" id="kobo.498.2">For example, a product may have</span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.499.1"> some common attributes, such as ID, name, and description. </span><span class="koboSpan" id="kobo.499.2">The product can also</span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.500.1"> have other attributes based on its type. </span><span class="koboSpan" id="kobo.500.2">For example, a book may have several pages, an author, and a publisher, while a bookcase may have material, width, height, and </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">depth attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">Let’s define these three objects (</span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">Product</span></strong><span class="koboSpan" id="kobo.504.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Book</span></strong><span class="koboSpan" id="kobo.506.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Bookcase</span></strong><span class="koboSpan" id="kobo.508.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">using interfaces:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.510.1">interface</span></strong><span class="koboSpan" id="kobo.511.1"> Product {   id: ID!
</span><span class="koboSpan" id="kobo.511.2">   name: String!
</span><span class="koboSpan" id="kobo.511.3">   description: string
 }
 type Book </span><strong class="bold"><span class="koboSpan" id="kobo.512.1">implements Product</span></strong><span class="koboSpan" id="kobo.513.1"> {
   </span><strong class="bold"><span class="koboSpan" id="kobo.514.1">id: ID!</span></strong><span class="koboSpan" id="kobo.515.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">name: String!</span></strong><span class="koboSpan" id="kobo.517.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">description: string</span></strong><span class="koboSpan" id="kobo.519.1">
   author: String!
</span><span class="koboSpan" id="kobo.519.2">   publisher: String
   noOfPages: Int
 }
 type Bookcase </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">implements Product</span></strong><span class="koboSpan" id="kobo.521.1"> {
   </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">id: ID!</span></strong><span class="koboSpan" id="kobo.523.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">name: String!</span></strong><span class="koboSpan" id="kobo.525.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">description: string</span></strong><span class="koboSpan" id="kobo.527.1">
   material: [String!]!
</span><span class="koboSpan" id="kobo.527.2">   width: Int
   height: Int
   depth: Int
 }</span></pre>
<p><span class="koboSpan" id="kobo.528.1">Here, an abstract type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Product</span></strong><span class="koboSpan" id="kobo.530.1"> has been created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">interface</span></strong><span class="koboSpan" id="kobo.532.1"> keyword. </span><span class="koboSpan" id="kobo.532.2">This interface can</span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.533.1"> be implemented when we wish to create new</span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.534.1"> object types – </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">Book</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.536.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Bookcase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">Now, you can simply write the following query that will return all the products (books </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">and bookcases):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
 type query {   allProducts: [Product]
 }</span></pre>
<p><span class="koboSpan" id="kobo.542.1">Now, you can use the following query on the client side to retrieve all </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">the products:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
 query getProducts {   allProducts {
     id
     name
     description
   }
 }</span></pre>
<p><span class="koboSpan" id="kobo.545.1">You might have noticed that the preceding code only contains attributes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">Product</span></strong><span class="koboSpan" id="kobo.547.1"> interface. </span><span class="koboSpan" id="kobo.547.2">If you want to retrieve attributes from </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">Book</span></strong><span class="koboSpan" id="kobo.549.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Bookcase</span></strong><span class="koboSpan" id="kobo.551.1">, then you must use </span><strong class="bold"><span class="koboSpan" id="kobo.552.1">inline fragments</span></strong><span class="koboSpan" id="kobo.553.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
 query getProducts {   allProducts {
     id
     name
     description
     </span><strong class="bold"><span class="koboSpan" id="kobo.556.1">... </span><span class="koboSpan" id="kobo.556.2">on Book {</span></strong><span class="koboSpan" id="kobo.557.1">
       author
       publisher
     }
     </span><strong class="bold"><span class="koboSpan" id="kobo.558.1">... </span><span class="koboSpan" id="kobo.558.2">on BookCase {</span></strong><span class="koboSpan" id="kobo.559.1">
       material
       height
     }
   }
 }</span></pre>
<p><span class="koboSpan" id="kobo.560.1">Here, an operation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">…</span></strong><span class="koboSpan" id="kobo.562.1">) is used </span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.563.1">to create inline fragments. </span><span class="koboSpan" id="kobo.563.2">This way, you can fetch the fields</span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.564.1"> from the type that implements </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">We’ll understand </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Union</span></strong><span class="koboSpan" id="kobo.568.1"> types in the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">next subsection.</span></span></p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.570.1">Understanding Union types</span></h2>
<p><span class="koboSpan" id="kobo.571.1">Let’s say there are two object types – </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Book</span></strong><span class="koboSpan" id="kobo.573.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">Author</span></strong><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">Here, you want to write a GraphQL query that can return both books and </span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.576.1">authors. </span><span class="koboSpan" id="kobo.576.2">Note that the interface is not there; so, how can we combine both objects in the query result? </span><span class="koboSpan" id="kobo.576.3">In such cases, you </span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.577.1">can use a </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">Union type</span></strong><span class="koboSpan" id="kobo.579.1">, which is a combination of two or </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">more objects.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Consider the following before creating a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Union</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.583.1"> type:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.584.1">You don’t need to have a </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">common field.</span></span></li>
<li><span class="koboSpan" id="kobo.586.1">Union members should be of a concrete type. </span><span class="koboSpan" id="kobo.586.2">Therefore, you can’t use </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">union</span></strong><span class="koboSpan" id="kobo.588.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">interface</span></strong><span class="koboSpan" id="kobo.590.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">input</span></strong><span class="koboSpan" id="kobo.592.1">, or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">scalar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.594.1"> types.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.595.1">Let’s create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">union</span></strong><span class="koboSpan" id="kobo.597.1"> type that can return any object included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">union</span></strong><span class="koboSpan" id="kobo.599.1"> type – books and bookcases – as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">code block:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.601.1">union SearchResult = Book | Author</span></strong><span class="koboSpan" id="kobo.602.1"> type Book {
   </span><strong class="bold"><span class="koboSpan" id="kobo.603.1">id: ID!</span></strong><span class="koboSpan" id="kobo.604.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">name: String!</span></strong><span class="koboSpan" id="kobo.606.1">
   publisher: String
 }
 type Author {
   </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">id: ID!</span></strong><span class="koboSpan" id="kobo.608.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.609.1">name: String!</span></strong><span class="koboSpan" id="kobo.610.1">
 }
 type Query {
  search(text: String): [</span><strong class="bold"><span class="koboSpan" id="kobo.611.1">SearchResult</span></strong><span class="koboSpan" id="kobo.612.1">]
 }</span></pre>
<p><span class="koboSpan" id="kobo.613.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">union</span></strong><span class="koboSpan" id="kobo.615.1"> keyword is used to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">union</span></strong><span class="koboSpan" id="kobo.617.1"> type for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">Book</span></strong><span class="koboSpan" id="kobo.619.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Author</span></strong><span class="koboSpan" id="kobo.621.1"> objects. </span><span class="koboSpan" id="kobo.621.2">A pipe symbol (</span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">|</span></strong><span class="koboSpan" id="kobo.623.1">) is used to </span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.624.1">separate the included objects. </span><span class="koboSpan" id="kobo.624.2">Finally, a query is defined that returns a collection </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.625.1">of books or authors that contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">given text.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">Now, let’s write this query for the client, as </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.629.1">
 # Request Input {
   search(text: "Malcolm Gladwell") {
     __typename
     ... </span><span class="koboSpan" id="kobo.629.2">on Book {
       name
       publisher
     }
     ... </span><span class="koboSpan" id="kobo.629.3">on Author {
       name
     }
   }
 }
 Response JSON
 {
   "data": {
     "search": [
       {
         "__typename": "Book",
         "name": "Blink",
         "publisher": "Back Bay Books"
       },
       {
         "__typename": "Author",
         "name": " Malcolm Gladwell ",
       }
     ]
   }
 }</span></pre>
<p><span class="koboSpan" id="kobo.630.1">As you can see, an inline</span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.631.1"> fragment is used in the query. </span><span class="koboSpan" id="kobo.631.2">Another important point is the</span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.632.1"> extra field, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">__typename</span></strong><span class="koboSpan" id="kobo.634.1">, which refers to the object it belongs to and helps you differentiate between different objects in </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">We’ll look at input types in the </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">next subsection.</span></span></p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.638.1">Understanding input types</span></h2>
<p><span class="koboSpan" id="kobo.639.1">So far, you have used scalar types as arguments. </span><span class="koboSpan" id="kobo.639.2">GraphQL also allows you to pass object types as arguments in</span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.640.1"> mutations. </span><span class="koboSpan" id="kobo.640.2">The only difference is that you have to declare them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">input</span></strong><span class="koboSpan" id="kobo.642.1"> instead of </span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.643.1">using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">Let’s create a mutation that accepts an input type as </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">an argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
 type Mutation {   addProduct(</span><strong class="bold"><span class="koboSpan" id="kobo.649.1">prodInput: ProductInput</span></strong><span class="koboSpan" id="kobo.650.1">): Product
 }
 </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">input</span></strong><span class="koboSpan" id="kobo.652.1"> ProductInput {
   name: String!
</span><span class="koboSpan" id="kobo.652.2">   description: String
   price: Float!
</span><span class="koboSpan" id="kobo.652.3">   # other fields…
 }
 type Product {
   # Product Input fields. </span><span class="koboSpan" id="kobo.652.4">Truncated for brevity.
 </span><span class="koboSpan" id="kobo.652.5">}</span></pre>
<p><span class="koboSpan" id="kobo.653.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">addProduct</span></strong><span class="koboSpan" id="kobo.655.1"> mutation accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">ProductInput</span></strong><span class="koboSpan" id="kobo.657.1"> as an argument and </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">Now, let’s use the GraphQL request to add a product to the client, as </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
 # Request Input mutation AddProduct (</span><strong class="bold"><span class="koboSpan" id="kobo.664.1">$input: ProductInput</span></strong><span class="koboSpan" id="kobo.665.1">) {
   addProduct(prodInput: </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">$input</span></strong><span class="koboSpan" id="kobo.667.1">) {
     name
   }
 }
 </span><strong class="bold"><span class="koboSpan" id="kobo.668.1">#---- Variable Section ----</span></strong><span class="koboSpan" id="kobo.669.1">
 {
   "input": {
     name: "Blink",
     description: "a book",
     "price": 10.00
   }
 }
 # JSON Output
 {
   "data": {
     addProduct {
       "name": "Blink"
     }
   }
 }</span></pre>
<p><span class="koboSpan" id="kobo.670.1">Here, you are running a mutation that uses an </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">input</span></strong><span class="koboSpan" id="kobo.672.1"> variable. </span><span class="koboSpan" id="kobo.672.2">You might have observed that </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Variable</span></strong><span class="koboSpan" id="kobo.674.1"> is being used here to pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">ProductInput</span></strong><span class="koboSpan" id="kobo.676.1">. </span><span class="koboSpan" id="kobo.676.2">The named mutation is used for the variable. </span><span class="koboSpan" id="kobo.676.3">If variables, along with their types, are defined in the mutation, then they should</span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.677.1"> be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">the mutation.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">Variable values should be assigned in the variable section (or beforehand in the client). </span><span class="koboSpan" id="kobo.679.2">The value of a variable’s input is</span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.680.1"> assigned using a JSON object that should map </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">ProductInput</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">We’ll look at the tools we can use while designing a GraphQL schema in the </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">next subsection.</span></span></p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.686.1">Designing a schema with GraphQL tools</span></h2>
<p><span class="koboSpan" id="kobo.687.1">You can use the following tools</span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.688.1"> for design and work with GraphQL, with each having its </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">own offerings:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.690.1">GraphiQL</span></strong><span class="koboSpan" id="kobo.691.1">: This is pronounced </span><em class="italic"><span class="koboSpan" id="kobo.692.1">graphical</span></em><span class="koboSpan" id="kobo.693.1">. </span><span class="koboSpan" id="kobo.693.2">It is an official GraphQL Foundation project that provides the web-based GraphQL </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">IDE</span></strong><span class="koboSpan" id="kobo.695.1">. </span><span class="koboSpan" id="kobo.695.2">It makes</span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.696.1"> use of </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">Language Server Protocol</span></strong><span class="koboSpan" id="kobo.698.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.699.1">LSP</span></strong><span class="koboSpan" id="kobo.700.1">), which uses the</span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.701.1"> JSON-RPC-based protocol between the source code editor and the IDE. </span><span class="koboSpan" id="kobo.701.2">It is available </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">at </span></span><a href="https://github.com/graphql/graphiql"><span class="No-Break"><span class="koboSpan" id="kobo.703.1">https://github.com/graphql/graphiql</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.704.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.705.1">GraphQL Playground</span></strong><span class="koboSpan" id="kobo.706.1">: This is another popular GraphQL IDE that once provided better features than </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.707.1">GraphiQL. </span><span class="koboSpan" id="kobo.707.2">However, GraphiQL now has feature parity with Playground. </span><span class="koboSpan" id="kobo.707.3">At the time of writing, GraphQL Playground is in maintenance mode. </span><span class="koboSpan" id="kobo.707.4">Check out </span><a href="https://github.com/graphql/graphql-playground/issues/1366"><span class="koboSpan" id="kobo.708.1">https://github.com/graphql/graphql-playground/issues/1366</span></a><span class="koboSpan" id="kobo.709.1"> for more details. </span><span class="koboSpan" id="kobo.709.2">It is available </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">at </span></span><a href="https://github.com/graphql/graphql-playground"><span class="No-Break"><span class="koboSpan" id="kobo.711.1">https://github.com/graphql/graphql-playground</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.712.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.713.1">GraphQL Faker</span></strong><span class="koboSpan" id="kobo.714.1">: This provides </span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.715.1">mock data for your GraphQL APIs. </span><span class="koboSpan" id="kobo.715.2">It is available </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">at </span></span><a href="https://github.com/APIs-guru/graphql-faker"><span class="No-Break"><span class="koboSpan" id="kobo.717.1">https://github.com/APIs-guru/graphql-faker</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.718.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.719.1">GraphQL Editor</span></strong><span class="koboSpan" id="kobo.720.1">: This allows you</span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.721.1"> to design your schema visually and then transform it into code. </span><span class="koboSpan" id="kobo.721.2">It is available </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">at </span></span><a href="https://github.com/graphql-editor/graphql-editor"><span class="No-Break"><span class="koboSpan" id="kobo.723.1">https://github.com/graphql-editor/graphql-editor</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.724.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.725.1">GraphQL Voyager</span></strong><span class="koboSpan" id="kobo.726.1">: This converts</span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.727.1"> your schema into interactive graphs, such as entity diagrams and all the relationships among these entities. </span><span class="koboSpan" id="kobo.727.2">It is available </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">at </span></span><a href="https://github.com/APIs-guru/graphql-voyager"><span class="No-Break"><span class="koboSpan" id="kobo.729.1">https://github.com/APIs-guru/graphql-voyager</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.730.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.731.1">In the next section, you’ll test the knowledge that you have acquired throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">this chapter.</span></span></p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.733.1">Testing GraphQL queries and mutations</span></h1>
<p><span class="koboSpan" id="kobo.734.1">Let’s write queries and </span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.735.1">mutations in a real GraphQL schema to test the skills you have learned up to this point using GitHub’s GraphQL API explorer. </span><span class="koboSpan" id="kobo.735.2">Let’s perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.737.1">First, go </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">to </span></span><a href="https://docs.github.com/en/graphql/overview/explorer"><span class="No-Break"><span class="koboSpan" id="kobo.739.1">https://docs.github.com/en/graphql/overview/explorer</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.740.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.741.1">You might have to authorize it using your GitHub account, so that you can execute </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">GraphQL queries.</span></span></li>
<li><span class="koboSpan" id="kobo.743.1">GitHub Explorer is based on GraphiQL. </span><span class="koboSpan" id="kobo.743.2">It is divided into three vertical sections (from left to right in the gray area in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.744.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.745.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">):</span></span><ul><li><span class="koboSpan" id="kobo.747.1">The left-hand section is divided into two subsections – an upper section for writing queries and a bottom section for </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">defining variables.</span></span></li><li><span class="koboSpan" id="kobo.749.1">The middle vertical section shows </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">the response.</span></span></li><li><span class="koboSpan" id="kobo.751.1">Normally, the rightmost section is hidden. </span><span class="koboSpan" id="kobo.751.2">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.752.1">Docs</span></strong><span class="koboSpan" id="kobo.753.1"> link to display it. </span><span class="koboSpan" id="kobo.753.2">It shows the respective documentation and schema, along with the root types that you </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">can explore.</span></span></li></ul></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.755.1"><img alt="Figure 13.1 – GraphQL API Explorer" src="image/Figure_13.1_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.756.1">Figure 13.1 – GraphQL API Explorer</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.757.1">Let’s fire the</span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.758.1"> following query to find out the ID of the repository you wish to mark with </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">a star:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.760.1">
{  </span><strong class="bold"><span class="koboSpan" id="kobo.761.1">repository</span></strong><span class="koboSpan" id="kobo.762.1">(    </span><strong class="bold"><span class="koboSpan" id="kobo.763.1">name</span></strong><span class="koboSpan" id="kobo.764.1">: "Modern-API-Development-with-Spring-6-and-Spring-Boot-3"    </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">owner</span></strong><span class="koboSpan" id="kobo.766.1">: "PacktPublishing"  ) {    </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">id</span></strong><span class="koboSpan" id="kobo.768.1">    owner {      id      login    }    name    description    viewerHasStarred    </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">stargazerCount</span></strong><span class="koboSpan" id="kobo.770.1">  }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.771.1">Here, you are querying the previous edition of this book’s repository by providing two arguments – the repository’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">name</span></strong><span class="koboSpan" id="kobo.773.1"> and its </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">owner</span></strong><span class="koboSpan" id="kobo.775.1">. </span><span class="koboSpan" id="kobo.775.2">You are fetching a few of the fields. </span><span class="koboSpan" id="kobo.775.3">One </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.776.1">of the most important ones is </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">stargazerCount</span></strong><span class="koboSpan" id="kobo.778.1"> because we are going to perform an </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">addStar</span></strong><span class="koboSpan" id="kobo.780.1"> mutation. </span><span class="koboSpan" id="kobo.780.2">This count will tell us whether the mutation was successful </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">or not.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.782.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.783.1">Execute Query</span></strong><span class="koboSpan" id="kobo.784.1"> button on the top bar or press </span><em class="italic"><span class="koboSpan" id="kobo.785.1">Ctrl </span></em><span class="koboSpan" id="kobo.786.1">+ </span><em class="italic"><span class="koboSpan" id="kobo.787.1">Enter</span></em><span class="koboSpan" id="kobo.788.1"> to execute the query. </span><span class="koboSpan" id="kobo.788.2">You should get the following output once this query </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">executes successfully:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.790.1">
{  "data": {    "repository": {      </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">"id": "R_kgDOHzYNwg"</span></strong><span class="koboSpan" id="kobo.792.1">,      "owner": {        "id": "MDEyOk9yZ2FuaXphdGlvbjEwOTc0OTA2",        "login": "PacktPublishing"      },      "name": "Modern-API-Development-with-Spring-6-        and-Spring-Boot-3",      "description": "Modern API Development with      Spring 6 and Spring Boot 3, Published by Packt",      "viewerHasStarred": false,      "stargazerCount": 1    }  }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.793.1">Here, you need to </span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.794.1">copy the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">id</span></strong><span class="koboSpan" id="kobo.796.1"> from the response, as it will be needed to mark this repository with </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">a star.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.798.1">Execute the following query to perform the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">addStar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1"> mutation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.801.1">
mutation {  </span><strong class="bold"><span class="koboSpan" id="kobo.802.1">addStar</span></strong><span class="koboSpan" id="kobo.803.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.804.1">input</span></strong><span class="koboSpan" id="kobo.805.1">: {</span><strong class="bold"><span class="koboSpan" id="kobo.806.1">starrableId: "R_kgDOHzYNwg"</span></strong><span class="koboSpan" id="kobo.807.1">}) {    clientMutationId  }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.808.1">This performs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">addStar</span></strong><span class="koboSpan" id="kobo.810.1"> mutation for the repository with the </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">given ID.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.812.1">Once the previous query has executed successfully, you must re-execute the query from </span><em class="italic"><span class="koboSpan" id="kobo.813.1">step 4</span></em><span class="koboSpan" id="kobo.814.1"> to find out about the change. </span><span class="koboSpan" id="kobo.814.2">If you get an access issue, then you can choose your own GitHub repository to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">these steps.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.816.1">You can also explore other queries and mutations to deep dive </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">into GraphQL.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">Finally, let’s understand the N+1 problem in GraphQL queries before we jump into the implementation in the </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">next chapter.</span></span></p>
<h1 id="_idParaDest-307"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.820.1">Solving the N+1 problem</span></h1>
<p><span class="koboSpan" id="kobo.821.1">The N+1 problem is not new to Java developers. </span><span class="koboSpan" id="kobo.821.2">You might have encountered this problem while using</span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.822.1"> Hibernate, which occurs if you don’t optimize your queries or write </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">entities properly.</span></span></p>
<p><span class="koboSpan" id="kobo.824.1">Let’s look at what the N+1 </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">problem is.</span></span></p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.826.1">What is the N+1 problem?</span></h2>
<p><span class="koboSpan" id="kobo.827.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">N+1 problem</span></strong><span class="koboSpan" id="kobo.829.1"> normally occurs when associations are involved. </span><span class="koboSpan" id="kobo.829.2">There are one-to-many relationships between the customer and the order. </span><span class="koboSpan" id="kobo.829.3">One customer can have many orders. </span><span class="koboSpan" id="kobo.829.4">If you need to find all the </span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.830.1">customers and their orders, you can do </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.832.1">First, find all the users. </span><span class="koboSpan" id="kobo.832.2">This find operation returns the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">user objects.</span></span></li>
<li><span class="koboSpan" id="kobo.834.1">Then, find all the orders belonging to each user found in </span><em class="italic"><span class="koboSpan" id="kobo.835.1">step 1</span></em><span class="koboSpan" id="kobo.836.1">. </span><span class="koboSpan" id="kobo.836.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">userId</span></strong><span class="koboSpan" id="kobo.838.1"> field acts as the relation between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">Order</span></strong><span class="koboSpan" id="kobo.840.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">User</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.842.1"> objects.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.843.1">So, here, you fire two queries. </span><span class="koboSpan" id="kobo.843.2">If you further optimize the implementation, you can place a </span><em class="italic"><span class="koboSpan" id="kobo.844.1">join</span></em><span class="koboSpan" id="kobo.845.1"> between these two entities (</span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">Order</span></strong><span class="koboSpan" id="kobo.847.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">User</span></strong><span class="koboSpan" id="kobo.849.1">) and receive all the records in a </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">single query.</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">If this is so simple, then why does GraphQL encounter the N+1 problem? </span><span class="koboSpan" id="kobo.851.2">You need to understand the </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">resolver</span></strong><span class="koboSpan" id="kobo.853.1"> function to answer </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">this question.</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">If you refer to the database schema you created in </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.856.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.857.1">, </span><em class="italic"><span class="koboSpan" id="kobo.858.1">Writing Business Logic for APIs</span></em><span class="koboSpan" id="kobo.859.1">, you can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">getUsersOrders</span></strong><span class="koboSpan" id="kobo.861.1"> query will lead to the following SQL statements </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">being executed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.863.1">
 SELECT * FROM ecomm.user; SELECT * FROM ecomm.orders WHERE customer_id in (1);
 SELECT * FROM ecomm.orders WHERE customer_id in (2);
 ...
 </span><span class="koboSpan" id="kobo.863.2">...
 </span><span class="koboSpan" id="kobo.863.3">SELECT * FROM ecomm.orders WHERE customer_id in (n);</span></pre>
<p><span class="koboSpan" id="kobo.864.1">Here, to perform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">getUsersOrders()</span></strong><span class="koboSpan" id="kobo.866.1"> operation, you execute a query on the user to fetch all the users. </span><span class="koboSpan" id="kobo.866.2">Then, you executes N queries on orders. </span><span class="koboSpan" id="kobo.866.3">This is why it is called the N+1 problem. </span><span class="koboSpan" id="kobo.866.4">This is not efficient because ideally you should execute a single query, or in the worst case, </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">two queries.</span></span></p>
<p><span class="koboSpan" id="kobo.868.1">GraphQL can only</span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.869.1"> respond with the values of fields that have been requested in the query due to resolvers. </span><span class="koboSpan" id="kobo.869.2">Each field has its own resolver function in the GraphQL server implementation that fetches the data for its corresponding field. </span><span class="koboSpan" id="kobo.869.3">Let’s assume we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">following schema:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.871.1">
 type Mutation {   getUsersOrders: [User]
 }
 type User {
   name: String
   orders: [Order]
 }
 type Order {
   id: Int
   status: Status
 }</span></pre>
<p><span class="koboSpan" id="kobo.872.1">Here, we have a mutation that returns a collection of users. </span><span class="koboSpan" id="kobo.872.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">User</span></strong><span class="koboSpan" id="kobo.874.1"> may have a collection of orders. </span><span class="koboSpan" id="kobo.874.2">You could therefore use the following query in </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">the client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.876.1">
 {   getUsersOrders {
     name
     orders {
       id
       status
     }
   }
 }</span></pre>
<p><span class="koboSpan" id="kobo.877.1">Let’s understand how this query will be processed by </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.879.1">In the server, each field will have its own resolver function that fetches the corresponding data. </span><span class="koboSpan" id="kobo.879.2">The first resolver will be for the user and will fetch all the users from the data store. </span><span class="koboSpan" id="kobo.879.3">Next, the </span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.880.1">resolver will fetch orders for each user. </span><span class="koboSpan" id="kobo.880.2">It will fetch the orders from the data store based on the given user ID. </span><span class="koboSpan" id="kobo.880.3">Therefore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">orders</span></strong><span class="koboSpan" id="kobo.882.1"> resolver will execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">n</span></strong><span class="koboSpan" id="kobo.884.1"> times, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">n</span></strong><span class="koboSpan" id="kobo.886.1"> is the number of users that have been fetched from the </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">data store.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">We’ll learn how to resolve the N+1 problem in the </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">next subsection.</span></span></p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.890.1">How can we solve the N+1 problem?</span></h2>
<p><span class="koboSpan" id="kobo.891.1">The required solution will wait until all </span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.892.1">the orders have been loaded. </span><span class="koboSpan" id="kobo.892.2">Once all the user IDs have been retrieved, a database call should be made to fetch all the orders in a single data-store call. </span><span class="koboSpan" id="kobo.892.3">You can use a batch if the size of the database is huge. </span><span class="koboSpan" id="kobo.892.4">Then, the executer can resolve the individual order resolvers. </span><span class="koboSpan" id="kobo.892.5">However, this is easier said than done. </span><span class="koboSpan" id="kobo.892.6">GraphQL provides a</span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.893.1"> library called </span><strong class="bold"><span class="koboSpan" id="kobo.894.1">DataLoader</span></strong><span class="koboSpan" id="kobo.895.1"> (</span><a href="https://github.com/graphql/dataloader"><span class="koboSpan" id="kobo.896.1">https://github.com/graphql/dataloader</span></a><span class="koboSpan" id="kobo.897.1">) that does this job for you. </span><span class="koboSpan" id="kobo.897.2">This library mainly performs the batching and caching </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">of queries.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">Java provides a similar library called </span><strong class="bold"><span class="koboSpan" id="kobo.900.1">java-dataloader</span></strong><span class="koboSpan" id="kobo.901.1"> (</span><a href="https://github.com/graphql-java/java-dataloader"><span class="koboSpan" id="kobo.902.1">https://github.com/graphql-java/java-dataloader</span></a><span class="koboSpan" id="kobo.903.1">) that can </span><a id="_idIndexMarker1235"/><span class="koboSpan" id="kobo.904.1">help you solve this problem. </span><span class="koboSpan" id="kobo.904.2">You can find out more about it </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">at </span></span><a href="https://www.graphql-java.com/documentation/batching"><span class="No-Break"><span class="koboSpan" id="kobo.906.1">https://www.graphql-java.com/documentation/batching</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.907.1">.</span></span></p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.908.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.909.1">In this chapter, you learned about GraphQL, its advantages, and how it compares to REST. </span><span class="koboSpan" id="kobo.909.2">You learned how GraphQL solves over-fetching and under-fetching problems. </span><span class="koboSpan" id="kobo.909.3">You then learned about GraphQL’s root types – queries, mutations, and subscriptions – and how different blocks can help you design the GraphQL schema. </span><span class="koboSpan" id="kobo.909.4">Finally, you understood how resolvers work, how they can lead to the N+1 problem, and the solution to </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">this problem.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">Now that you know about the fundamentals of GraphQL, you can start designing GraphQL schemas. </span><span class="koboSpan" id="kobo.911.2">You also learned about GraphQL’s client-side queries and how to make use of aliases, fragments, and variables to resolve </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">common problems.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">In the next chapter, you will make use of the GraphQL skills you acquired in this chapter to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">GraphQL APIs.</span></span></p>
<h1 id="_idParaDest-311"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.915.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.916.1">Is GraphQL better than REST? </span><span class="koboSpan" id="kobo.916.2">If yes, then in </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">what way?</span></span></li>
<li><span class="koboSpan" id="kobo.918.1">When should you </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">use fragments?</span></span></li>
<li><span class="koboSpan" id="kobo.920.1">How can you use variables in a </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">GraphQL query?</span></span></li>
</ol>
<h1 id="_idParaDest-312"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.922.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.923.1">It depends on the use cases. </span><span class="koboSpan" id="kobo.923.2">However, GraphQL performs much better for mobile apps and web-based UI applications and is best suited for </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">service-to-service</span></strong><span class="koboSpan" id="kobo.925.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.926.1">s2s</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">) communications.</span></span></li>
<li><span class="koboSpan" id="kobo.928.1">Fragments should be used while sending a request from the GraphQL client when the response contains an interface </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">or union.</span></span></li>
<li><span class="koboSpan" id="kobo.930.1">You can use a variable in a GraphQL query/mutation, as shown in the following code. </span><span class="koboSpan" id="kobo.930.2">This code used to modify the GraphQL request sent in </span><em class="italic"><span class="koboSpan" id="kobo.931.1">step 6</span></em><span class="koboSpan" id="kobo.932.1"> of the </span><em class="italic"><span class="koboSpan" id="kobo.933.1">Testing GraphQL queries and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.934.1">mutations</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1"> section:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.936.1">
mutation {  addStar(input: {starrableId: </span><strong class="bold"><span class="koboSpan" id="kobo.937.1">$repoId</span></strong><span class="koboSpan" id="kobo.938.1"> }) {    clientMutationId  }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.939.1">Here, you can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">$repoId</span></strong><span class="koboSpan" id="kobo.941.1"> variable is used. </span><span class="koboSpan" id="kobo.941.2">You must declare that variable in the named mutation and it can then be used in the mutation’s argument, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.943.1">
{  "repoId": "R_kgDOHzYNwg"
}</span></pre>
<h1 id="_idParaDest-313"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.944.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.945.1">GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">specifications: </span></span><a href="https://spec.graphql.org/"><span class="No-Break"><span class="koboSpan" id="kobo.947.1">https://spec.graphql.org/</span></span></a></li>
<li><span class="koboSpan" id="kobo.948.1">GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">documentation: </span></span><a href="https://graphql.org/learn/"><span class="No-Break"><span class="koboSpan" id="kobo.950.1">https://graphql.org/learn/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.951.1">Full-Stack Web Development with GraphQL and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.952.1">React</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">: </span></span><a href="https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880"><span class="No-Break"><span class="koboSpan" id="kobo.954.1">https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880</span></span></a></li>
</ul>
</div>
</body></html>