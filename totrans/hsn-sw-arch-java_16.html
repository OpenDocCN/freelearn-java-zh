<html><head></head><body>
		<div id="_idContainer128">
			<h1 id="_idParaDest-305"><a id="_idTextAnchor307"/>Chapter 13: Exploring the Software Life Cycle</h1>
			<p>In previous chapters, we explored many different aspects of Java application development. Starting from the <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>), which includes requirements collection and architecture design, we focused on many different technological aspects, including frameworks and middleware.</p>
			<p>At this point, several cross-cutting concerns need to be looked at, regardless of the kind of application we are building and the architectural style we choose.</p>
			<p>In this chapter, we are going to explore such aspects. We will start with things such as the maintenance of source code (including versioning and branching strategies), ranging through to some core topics related to deploying, <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>), and other concepts related to the SDLC in its entirety.</p>
			<p>In this chapter, these are the topics we are going to cover:</p>
			<ul>
				<li>Source Code Management</li>
				<li>Testing</li>
				<li>Deploying</li>
				<li>Continuous integration/continuous delivery (and deployment)</li>
				<li>Releasing</li>
				<li>Maintenance</li>
			</ul>
			<p>I'm almost sure that in your professional life, you will already have had the opportunity to become familiar with these topics. Indeed, these are often taken for granted. </p>
			<p>Nevertheless, by the end of this chapter, you will have a complete view of the entire process, which will be really useful in structuring and maintaining a functional and efficient software toolchain.</p>
			<p>Now, let's start with <strong class="bold">Source Code Management</strong> (<strong class="bold">SCM</strong>).</p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor308"/>Technical requirements</h1>
			<p>You can find the source code used in this chapter here: <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13</a>.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor309"/>Source Code Management</h1>
			<p>SCM is a<a id="_idIndexMarker1678"/> pretty basic concept and should be considered, of course, mandatory in any software project (including very small ones). Nowadays, SCM is synonymous with Git (more on that soon); however, many alternatives <a id="_idIndexMarker1679"/>have been used over the years, including <strong class="bold">Concurrent Versions System</strong> (<strong class="bold">CVS</strong>) and <a id="_idIndexMarker1680"/>Apache <strong class="bold">Subversion</strong> (<strong class="bold">SVN</strong>).</p>
			<p>The basic function of SCM is backing up, sharing, and versioning source code. However, there are many nuances to these features. So, let's have a closer look at Git.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor310"/>Introducing Git</h2>
			<p>Git <a id="_idIndexMarker1681"/>was created by Linus Torvalds, the creator of the Linux OS, as a tool for supporting the development of the OS itself.</p>
			<p>Apart from the history of the project, Git has many<a id="_idIndexMarker1682"/> interesting characteristics that make it a de facto standard:</p>
			<ul>
				<li>It is heavily decentralized. With Git, every developer can work with a local repository, benefitting the versioning of files, branching, and more features, even in the absence of a remote server (such as in a disconnected environment). This also makes it really scalable from a performance point of view.</li>
				<li>With Git, every version is associated with a cryptographical hash ID. In this way, the history of files can be easily reconstructed, and it makes it hard to tamper with them.</li>
				<li>Git relies on well-known and frequently used protocols, such as HTTP, SSH, and FTP. This makes it easy to use in existing environments.</li>
			</ul>
			<p>Git encompasses a lot of different commands and features; however, the basics for <a id="_idIndexMarker1683"/>using it are as follows:</p>
			<ul>
				<li><strong class="source-inline">git init [local folder]</strong>: This<a id="_idIndexMarker1684"/> is the command used to initialize a new repository locally.</li>
				<li><strong class="source-inline">git clone [repository]</strong>: This<a id="_idIndexMarker1685"/> creates a local copy of an existing repository. In the case of an authenticated repository, there are many different ways of authenticating, including passing the username and password as part of the URL (using something such as git clone: <strong class="source-inline">https://username:password@remote</strong>). However, better options (such as using tokens) are advisable.</li>
				<li><strong class="source-inline">git add [files to be added]</strong>: This <a id="_idIndexMarker1686"/>adds a set of files to a staging area (which is basically an intermediate step before committing to a repository).</li>
				<li><strong class="source-inline">git commit -m [commit message]</strong>: This<a id="_idIndexMarker1687"/> commits the files from the staging area to a repository.</li>
				<li><strong class="source-inline">git branch [branch name]</strong>: This<a id="_idIndexMarker1688"/> creates a new<a id="_idIndexMarker1689"/> branch. A <strong class="bold">branch</strong> (which is a concept common to many SCM systems) is a way of storing a set of implementations that can potentially have an impact on the rest of the system (such as a new major version) in an isolated area. Such developments can then be merged with the main developments.</li>
				<li><strong class="source-inline">git tag [tag name]</strong>: This<a id="_idIndexMarker1690"/> creates a new tag. A <strong class="bold">tag</strong> is <a id="_idIndexMarker1691"/>similar to a branch, but it's basically immutable. It is commonly used to mark a specified important event in the code (such as a release) to make it easier to identify the situation of the code in that particular moment, and potentially rebuild it.</li>
				<li><strong class="source-inline">git push [remote] [branch]</strong>: This <a id="_idIndexMarker1692"/>pushes the local changes to a remote repository on the specified branch.</li>
			</ul>
			<p>These Git commands and, in particular, the concept of branching and tagging are very powerful tools. How they are used has become more and more structured over time, creating some specified workflows. In the next sections, we'll see some ideas on this.</p>
			<h3>Git Flow</h3>
			<p>Despite<a id="_idIndexMarker1693"/> the name, <strong class="bold">Git Flow</strong> (and other similar techniques) is not a prerequisite of Git, and, in theory, could also be implemented with SCM tools, which are different from Git. However, it is common to implement this kind of technique together with Git.</p>
			<p>Git Flow is an articulated way of managing and storing developments, creating releases, and, in general, structuring the way the code is handled. </p>
			<p>Git Flow is based on a number of branches coexisting constantly and can be implemented manually or by using some tools created to support such a way of working.</p>
			<p>The core line where the code is stored is called the <strong class="bold">Main</strong> branch. The developers are not supposed to work directly on this <a id="_idIndexMarker1694"/>branch. Instead, a <strong class="bold">develop</strong> (<strong class="bold">Dev</strong>) branch is created from it to store the work in progress. In order to work on a feature, each developer copies the <strong class="bold">Dev</strong> branch into a purposely created <strong class="bold">Feature</strong> branch, which is created to contain a specific feature. When a feature is completed, it's merged back into the <strong class="bold">Dev</strong> branch. In theory, since just a few features are developed, the merge operation should not be too difficult (since not much code has changed). The following diagram illustrates this:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_13.01_B16354.jpg" alt="Figure 13.1 – Feature development in Git Flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Feature development in Git Flow</p>
			<p>As we can see, the <a id="_idIndexMarker1695"/>simplest situation is when features are developed one after the other, hence the feature we just developed has to be merged back. However, in real situations, it's common to have more than one feature developed in parallel, so the merge back into the <strong class="bold">Dev</strong> branch can be slightly more difficult.</p>
			<p>When enough features are developed (and have been merged into the <strong class="bold">Dev</strong> branch), a new branch is created from the <strong class="bold">Dev</strong> branch, called <strong class="bold">Release</strong>. The <strong class="bold">Release</strong> branch should have some kind of a <em class="italic">feature freeze</em>, meaning that all the code committed into this branch must only have the goal of releasing and not adding any new features. This means that while tests are going on against the code in the <strong class="bold">Release</strong> branch, developers are supposed to commit bug fixes (if any) in this branch.</p>
			<p>Other files needed for the release (such as documentation and scripts) can be added there. When the release is ready, the code in the branch will be tagged (that is, <em class="italic">freezed</em> to a specific version). Then, the <strong class="bold">Release</strong> branch is merged back into the <strong class="bold">Main</strong> and <strong class="bold">Dev</strong> branches so that the developments for the upcoming versions can begin, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_13.02_B16354.jpg" alt="Figure 13.2 – Release management in Git Flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Release management in Git Flow</p>
			<p>As we can see, when working <a id="_idIndexMarker1696"/>on a release, all the code is supposed to be modified in the <strong class="bold">Release</strong> branch itself for fixing the issues that prevent this particular release from going into production. Once everything is ready and the production release is successful, the code in the <strong class="bold">Release</strong> branch (including the <em class="italic">freezed</em> code for that release plus the bug fixes, if any) is merged back into the <strong class="bold">Main</strong> and <strong class="bold">Dev</strong> branches.</p>
			<p>If an issue happens in production, an ad hoc <strong class="bold">Hotfix</strong> branch is created from the <strong class="bold">Main</strong> branch for the purpose of production fixes and merged back as soon as possible, as shown here:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/Figure_13.03_B16354.jpg" alt="Figure 13.3 – Hotfix development in Git Flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Hotfix development in Git Flow</p>
			<p>As seen in the <a id="_idIndexMarker1697"/>diagram, in the case of a hotfix, the code should come from the <strong class="bold">Main</strong> branch and the fixes must be done in the <strong class="bold">Hotfix</strong> branch. The changes must then be merged back to both the <strong class="bold">Main</strong> and <strong class="bold">Dev</strong> branches.</p>
			<p>Git Flow seems a bit difficult, and indeed it requires a lot of different branches and merge operations. But it's also considered not very well suited for modern application development techniques, such as CI/CD and DevOps. For such situations, trunk-based development is considered a better choice.</p>
			<h3>Trunk-based development</h3>
			<p><strong class="bold">Trunk-based development</strong> is <a id="_idIndexMarker1698"/>much simpler than Git Flow. Basically, every developer works on the same branch (the main branch, usually). They are <a id="_idIndexMarker1699"/>allowed to create branches for local developments, but it's advised to make them as short-lived as possible, and merge them back to the main branch as soon as possible (at least daily). This needs to be done so that the developments are consistent, the tests should pass, and the changes should not break anything else in the project.</p>
			<p>With this in mind, trunk-based development is often seen as a perfect pair with CI/CD (more on this later in the chapter). It is possible (and common) to have automated processes constantly checking for the integrity of the main branch (such as after every merge), and in the case of tests failing, changes could be reverted; or, someone in the team (usually the developer of such changes) should focus on fixing the issues. The main branch can be released in production at any time (carrying all the latest developments). Before each release, the code is tagged for traceability and reproducibility of the release.</p>
			<p>Trunk-based development, other than being easier to implement and maintain, requires less effort for change management, as merges are smaller and they happen quite often.</p>
			<p>On the other hand, it requires great experience and dedication from every project contributor as it increases the possibility of bugs or other bad code slipping into the main trunk (and, theoretically, into production). A related topic to branching strategies is the versioning standard.</p>
			<h3>Semantic versioning</h3>
			<p>As we<a id="_idIndexMarker1700"/> said, during each release, the source code is <em class="italic">frozen</em> (usually with a tag) and <a id="_idIndexMarker1701"/>uniquely identified for maintenance purposes. </p>
			<p>However, there are many different theories on what the best way for versioning releases is, as in choosing a unique identifier.</p>
			<p>A method that I find particularly elegant and effective is semantic versioning.</p>
			<p><strong class="bold">Semantic versioning</strong> is <a id="_idIndexMarker1702"/>commonly used in open source projects and basically associates each release with three numbers, in the form of <em class="italic">x.y.z</em> (for example, <em class="italic">1.2.3</em>). Changes <a id="_idIndexMarker1703"/>to each of these numbers have a precise meaning:</p>
			<ul>
				<li>The first number (represented by <em class="italic">x</em> in our example) is called the <strong class="bold">major version</strong>. An increase in the major version implies major updates, including new features, re-architecture, technology changes, and, most importantly, potentially breaking changes (including changes in the APIs exposed).</li>
				<li>The second number (represented by <em class="italic">y</em> in our example) is called the <strong class="bold">minor version</strong>. An increase in the minor version implies new functionalities, which can also be non-trivial but are supposed to be backward compatible, so avoid changing the APIs exposed.</li>
				<li>The third number (represented by <em class="italic">z</em> in our example) is called the <strong class="bold">patch version</strong>. An increase in this version just implies bug fixes. No new features should be included (unless very trivial) and, of course, no breaking changes in the APIs exposed.</li>
			</ul>
			<p>An increase in the major version implies that minor and patch versions are reset to <em class="italic">0</em>. So, if we make big changes for version <em class="italic">1.2.3</em> (by breaking the APIs), the next release should be <em class="italic">2.0.0</em>. </p>
			<p>Similarly, an increase in the minor version resets the patch version to <em class="italic">0</em>, so for version <em class="italic">1.2.3</em>, if there are new features that are backward compatible, we go to version <em class="italic">1.3.0</em>. Needless to say, each version can go to double figures with no impact on the other versions. Hence, an increase in the minor version of the software in version <em class="italic">1.9.3</em> means going to version <em class="italic">1.10.0</em>.</p>
			<p>After the<a id="_idIndexMarker1704"/> three<a id="_idIndexMarker1705"/> numbers compose the version, it is possible<a id="_idIndexMarker1706"/> to add an <a id="_idIndexMarker1707"/>optional label. Common labels<a id="_idIndexMarker1708"/> are <strong class="bold">RELEASE</strong> (identifying a version released in production), <strong class="bold">ALPHA</strong> (identifying a preliminary version, not intended for production), and <strong class="bold">Release Candidate</strong> (<strong class="bold">RC</strong>) (this is something almost ready for production, but likely needs some more testing).</p>
			<p>It is also a common convention to set the major version to <em class="italic">0</em> in order to identify the first project draft (such as a prototype not intended to be stable). </p>
			<p>In this section, we have learned some interesting concepts. Starting with Git, which is the de facto standard, and SCM, we learned about a couple of different branching strategies, and we had a look at a standard way for versioning releases. Now, our next step is to make some considerations about testing.</p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor311"/>Testing</h1>
			<p>In <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, we had a look at <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>), quickly<a id="_idIndexMarker1709"/> touching on the concept of <strong class="bold">unit testing</strong>. Now is the right time to make some deeper considerations around the concept of testing and return to some topics that we have taken for granted so far.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor312"/>Unit testing</h2>
			<p><strong class="bold">Unit testing</strong> is the <a id="_idIndexMarker1710"/>most basic technique for software quality assurance and, as we have seen, the tool behind TDD.</p>
			<p>Unit testing<a id="_idIndexMarker1711"/> aims to provide testing (usually automated) for the smallest unit of identifiable software. In the Java world, this means testing at a class and method level. The tests involve calling the method with a defined set of inputs and checking (with assertions) that the output complies with the expectation (including expected failures).</p>
			<p>The reasoning behind it is that each method is tested individually, so the tests can be simple and pervasive. This also allows bugs to be identified early and in the exact spot where they are introduced (at least in the exact method). The limitation of this approach is that it doesn't easily detect bugs caused by corner cases or interaction between complex systems, or with external systems.</p>
			<p>In the Java world, unit testing means JUnit, which is a very famous library widely used for implementing unit tests and more. Let's learn more about it. </p>
			<h3>JUnit</h3>
			<p><strong class="bold">JUnit</strong> is <a id="_idIndexMarker1712"/>the <a id="_idIndexMarker1713"/>de facto standard for unit testing in Java. The current version at the time of writing is <strong class="bold">version 5</strong>. JUnit provides some standards and facilities for defining unit tests and integrating them into common toolchains, such as Maven and Gradle. JUnit is also easy to run from a common IDE, such as IntelliJ.</p>
			<p>The <a id="_idIndexMarker1714"/>Maven standard defines that the test classes must be placed in the <strong class="source-inline">src/test/java</strong> folder, whereas the application code is supposed to stay in the <strong class="source-inline">src/main/java</strong> folder.</p>
			<p>In this way, the test <a id="_idIndexMarker1715"/>classes can mirror the same package structure as the application files, and in the release phase, the test classes can then be discarded and not be part of the release artifacts.</p>
			<p>JUnit automatically considers (and runs) tests contained in classes whose name starts or ends with <strong class="source-inline">Test</strong>.</p>
			<p>Each test method is identified by the <strong class="source-inline">@Test</strong> annotation. It's possible to annotate some method for setting up resources before tests, with annotations such as <strong class="source-inline">@BeforeAll</strong> and <strong class="source-inline">@BeforeEach</strong>. At the same time, it's possible to clean up things after tests, using <strong class="source-inline">@AfterAll</strong> and <strong class="source-inline">@AfterEach</strong>. Test execution can be controlled by using <strong class="source-inline">@Order</strong>.</p>
			<p>Moreover, JUnit provides a set of facility methods, such as <strong class="source-inline">AssertEquals</strong>, <strong class="source-inline">AssertTrue</strong>, and <strong class="source-inline">AssertFalse</strong>, which can be used to check for the expected results. </p>
			<p>JUnit execution is commonly integrated as a step into a build chain (acting as a part of a Maven build or of a more complex pipeline). You can constantly have a view of what is working and what is failing, often with a visual representation with green and red lights for building reports.</p>
			<p>Now, we have a simple class such as the following:</p>
			<p class="source-code">package it.test;</p>
			<p class="source-code"> public class HelloWorld {</p>
			<p class="source-code">     private String who;</p>
			<p class="source-code">     public HelloWorld() {</p>
			<p class="source-code">        this.who="default";</p>
			<p class="source-code">    }</p>
			<p class="source-code">     public String getWho() {</p>
			<p class="source-code">        return who;</p>
			<p class="source-code">    }</p>
			<p class="source-code">     public void setWho(String who) {</p>
			<p class="source-code">        this.who = who;</p>
			<p class="source-code">    }</p>
			<p class="source-code">     public String doIt()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return "Hello "+ this.who;</p>
			<p class="source-code">    }</p>
			<p class="source-code"> }</p>
			<p>The <a id="_idIndexMarker1716"/>preceding class <a id="_idIndexMarker1717"/>basically has a field with a getter and setter, and a method to do the classic <em class="italic">hello world</em> (with a string concatenation). The unit test class associated with the preceding class is as follows:</p>
			<p class="source-code">package it.test;</p>
			<p class="source-code">import org.junit.jupiter.api.Assertions;</p>
			<p class="source-code">import org.junit.jupiter.api.BeforeEach;</p>
			<p class="source-code">import org.junit.jupiter.api.Test;</p>
			<p class="source-code">import io.quarkus.test.junit.QuarkusTest;</p>
			<p class="source-code">public class HelloWorldTest {</p>
			<p class="source-code">    HelloWorld hello;</p>
			<p class="source-code">    @BeforeEach</p>
			<p class="source-code">    public void buildHello()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        this.hello= new HelloWorld();</p>
			<p class="source-code">    }</p>
			<p class="source-code">...</p>
			<p>A few considerations about the <a id="_idIndexMarker1718"/>preceding test are as follows:</p>
			<ul>
				<li>The <strong class="source-inline">it.test</strong> package, where the test resides, is the same as the package where the implementation is. As said, this is possible because the implementations stay in the <strong class="source-inline">src/main/java</strong> folder, while the tests stay in the <strong class="source-inline">src/test/java</strong> folder. During the testing phase, you can consider the preceding two folders as the source folders, while, when building the artifact, you can ditch the test folder. This allows us to access <strong class="source-inline">protected</strong> fields and methods on the class to be tested. </li>
				<li>The class name ends with <strong class="source-inline">Test</strong>. This will suggest to the JUnit framework that the class includes some tests.</li>
				<li>The <strong class="source-inline">buildHello</strong> method is annotated with <strong class="source-inline">@BeforeEach</strong>, hence it's executed before each test method. In this case, of course, the implementation is straightforward for the example purpose, but in the real world, there are a lot of meaningful things to be done there, such as initializing fake data and connecting to external systems.</li>
			</ul>
			<p>You can also use <strong class="source-inline">@BeforeAll</strong>, which is executed once before all tests. Also, it's worth noticing that <strong class="source-inline">@AfterEach</strong> and <strong class="source-inline">@AfterAll</strong> are available for the teardown of resources that need to be safely closed (such as database connections) or for cleaning up the necessary data IDs.</p>
			<ul>
				<li>Each test method is annotated with <strong class="source-inline">@Test</strong> and does some assertions on expected output by using the <strong class="source-inline">Assertions.assertEquals</strong> utility method. Other methods, such as <strong class="source-inline">assertTrue</strong> and <strong class="source-inline">assertFalse</strong>, are available as well. As it's easy to spot, simple things such as setters are tested here, which are usually probably not so vulnerable to bugs:<p class="source-code">...</p><p class="source-code">  @Test</p><p class="source-code">    public void testConstructor()</p><p class="source-code">    {</p><p class="source-code">        Assertions.assertEquals(this.hello.getWho(), </p><p class="source-code">          "default");</p><p class="source-code">    }</p><p class="source-code">    @Test</p><p class="source-code">    public void testGetterSetter()</p><p class="source-code">    {</p><p class="source-code">        String name="Giuseppe";</p><p class="source-code">        this.hello.setWho(name);</p><p class="source-code">        Assertions.assertEquals(this.hello.getWho(),</p><p class="source-code">          name);</p><p class="source-code">    }</p><p class="source-code">    @Test</p><p class="source-code">    public void testDoIt()</p><p class="source-code">    {</p><p class="source-code">        String name="Giuseppe";</p><p class="source-code">        String expected="Hello "+name;</p><p class="source-code">        this.hello.setWho(name);</p><p class="source-code">        Assertions.assertEquals(this.hello.doIt(),</p><p class="source-code">          expected);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The previous <a id="_idIndexMarker1719"/>code can be made more readable by using a <strong class="source-inline">static</strong> import on <strong class="source-inline">Assertions</strong>, and then directly using the methods provided by the class. </p>
			<p>When running these tests, you can easily see a recap of test execution. By way of an example, by running the <strong class="source-inline">mvn clean test</strong> command, you should see something similar to this screenshot:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/Figure_13.04_B16354.jpg" alt="Figure 13.4 – Test execution in the command line&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – Test execution in the command line</p>
			<p>As you can <a id="_idIndexMarker1720"/>see, the<a id="_idIndexMarker1721"/> build succeeds, and there is a recap of the executed tests (that were successful). If a test fails, by default, the build fails. If we know that there is a test intentionally failing (because, as an example, the method is not yet implemented, as it happens in the TDD methodology), we can skip that particular test (by annotating it with <strong class="source-inline">@Disable</strong>) or skip the testing phase completely (which is usually not advised).</p>
			<p>In the case of a big project, usually, the testing results are then saved and archived as part of a build process. This may simply mean saving the console output of the build with the test recap (as seen in the preceding screenshot) or using more sophisticated techniques. By using a <a id="_idIndexMarker1722"/>widespread Maven plugin (<strong class="bold">Surefire</strong>), it's easy to save test results as <strong class="source-inline">.xml</strong> or <strong class="source-inline">.html</strong> files, although more complete commercial test suites are able to do similar things.</p>
			<p>But this was just about unit testing. To complete our view, it's useful to understand that more ways of testing are possible (and advised). Let's have a look at them in the following sections.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor313"/>Beyond unit testing</h2>
			<p>Unit testing, indeed, can be seen as the (basic and essential) lowest step in the testing world. Indeed, as we have already said, unit testing is unable to catch some bugs that depend on more complex interactions between classes. To do so, more testing techniques are<a id="_idIndexMarker1723"/> usually implemented, such as integration, end-to-end, performance, and <strong class="bold">User Acceptance Testing</strong> (<strong class="bold">UAT</strong>).</p>
			<h3>Integration testing</h3>
			<p><strong class="bold">Integration testing</strong> is the <a id="_idIndexMarker1724"/>immediate next step after unit testing. While <a id="_idIndexMarker1725"/>unit testing tests the most atomic modules of software, such as methods and classes, integration testing focuses on the interaction of such modules with each other (but not on the entire system). So, the classes are put together and call each other to check (and realize) more complex testing scenarios. Each test involves more than one method call, usually from different classes.</p>
			<p>There is no fixed rule for defining the granularity of each integration test, even if someone completely ditches this testing technique in favor of end-to-end testing (more on this in the next section). My personal suggestion is to at least add integration testing for the more complex functionalities by trying to involve at least two or three classes simulating the core features or at least the ones most impacted by changes (and by issues).</p>
			<p>While there are libraries that can be implemented specifically for integration testing (<strong class="source-inline">arquillian</strong> comes to mind), JUnit is perfectly usable (and widely used) for integration testing, too, by using the same facility (such as assertion and setup methods) as seen in the previous section. Of course, instead of building tests for testing each method and class, more complex interactions are supposed to be implemented by chaining method calls and plugging different classes together.</p>
			<h3>End-to-end testing</h3>
			<p><strong class="bold">End-to-end testing</strong>, also known as <strong class="bold">system testing</strong>, takes<a id="_idIndexMarker1726"/> the integration testing ideas a bit further. End-to-end testing involves the testing of each<a id="_idIndexMarker1727"/> functionality as a whole, including external <a id="_idIndexMarker1728"/>systems (such as databases), which are commonly dedicated and maintained as part of the testing efforts. The functionality can be defined at many different times, but nowadays usually overlaps with the concept of an API.</p>
			<p>End-to-end testing includes calling an API (or triggering a functionality differently) by passing a known set of inputs and then checking the expected outputs. This will include, alongside the API response, also checking the status of external systems that are supposed to be changed (such as things edited in databases or external systems that are supposed to be contacted, such as sending emails).</p>
			<p>It is<a id="_idIndexMarker1729"/> implied that the system is then tested <em class="italic">from the outside</em>, as opposed to the other testing techniques seen so far, which are more focused on the source code (and then more looking at the project <em class="italic">from the inside</em>).</p>
			<p>End-to-end testing<a id="_idIndexMarker1730"/> provides a good idea of system behavior <em class="italic">as a whole</em>, and it's usually less stable than unit and integration testing because a small change in any of the methods can cause failures in many end-to-end tests depending on that specific method (and go undetected or have a smaller impact on unit and integration tests). However, it is also coarser-grained, so it can be a bit more difficult to understand where and why things are breaking.</p>
			<p>There are a lot of tools for end-to-end testing, both free and commercial. Such tools are usually more of a kind of standalone platform, as opposed to the tools seen so far (such as JUnit), which are more libraries and frameworks. Moreover, end-to-end testing is basically language-independent, hence, Java projects don't usually need any specific testing tool, as the entry points for testing are APIs or user interfaces. So, any tool capable of interacting at that level can be used.</p>
			<p>Commonly used solutions include LoadRunner, a commercial solution originally built by HP and now part of Micro Focus, which is the standard in some projects. Other alternatives are the SmartBear testing suite and other free testing suites, such as JMeter, Cypress, Karate, Gatling, and Selenium. The last two tools are more focused on automating the user interface interactions, which means that there are basic ways to automate the programmatic use of web browsers, simulating a real user accessing a web application, checking all the expected behavior.</p>
			<h3>Performance testing</h3>
			<p><strong class="bold">Performance testing</strong> is a <a id="_idIndexMarker1731"/>special case of end-to-end testing. Instead <a id="_idIndexMarker1732"/>of being exclusively focused on the correct implementation of each API (or feature) tested (which is basically taken for granted), performance tests focus on system capacity and the response time under different loads. While the tools can be (and often are) similar to end-to-end testing, the final goal is different. The metrics measured when doing performance testing are the ones described in <a href="B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Essential Java Architectural Patterns</em>, in the <em class="italic">Designing for large-scale adoption</em> section, and include throughput, response time, and elapsed time. </p>
			<p>Performance testing can include the following<a id="_idIndexMarker1733"/> scenarios:</p>
			<ul>
				<li><strong class="bold">Load testing</strong>, which<a id="_idIndexMarker1734"/> is measuring the performance<a id="_idIndexMarker1735"/> of the system against a defined load, is usually similar to the one expected in production (or an exaggerated case of it, such as doubling the expected number of concurrent users).</li>
				<li><strong class="bold">Spike testing</strong>, which<a id="_idIndexMarker1736"/> is similar to the previous <a id="_idIndexMarker1737"/>one (and indeed they are often run together), basically involves sudden changes in the load of traffic to simulate spikes. This test aims to check the scalability of the system and the time needed for recovery following a sudden traffic increase. In other words, it's often allowed to have a slight slowdown after an unexpected increase in traffic (because the system is expected to adapt to such traffic, such as using an autoscaling technique), but it's worth measuring how long it takes for the system to recover following such a slowdown.</li>
				<li><strong class="bold">Stress testing</strong>, which<a id="_idIndexMarker1738"/> takes the previous test types to <a id="_idIndexMarker1739"/>the extreme, aims to benchmark the system by measuring the maximum traffic that can be correctly handled by the system.</li>
			</ul>
			<p>During a performance test, regardless of the tools and objectives, it's strongly advised to observe the system <em class="italic">as a whole</em>, including OS parameters (such as memory, CPU, and network) and external systems, such as databases, in order to check for bottlenecks and understand how the system can be fine-tuned to perform better.</p>
			<h3>User acceptance testing</h3>
			<p>UAT is a <a id="_idIndexMarker1740"/>crucial step of the testing process, and I'd say of the<a id="_idIndexMarker1741"/> whole software development process. Technically speaking, it is quite similar to end-to-end testing, by focusing on testing functionalities as a whole. There are, however, some crucial differences. The first one is that the test is supposed to be governed by a functional analyst, business people, or the project sponsor.</p>
			<p>This, of course, doesn't mean that these people should be running the tests themselves, but that the test structure (including the acceptance criteria and the priority of the features tested) should be set by those teams, and this is usually done by focusing on the point of view of the end user (hence the name of this phase). </p>
			<p>It's <a id="_idIndexMarker1742"/>accepted <a id="_idIndexMarker1743"/>that part of this test is done manually, with users directly navigating the application feature as a final user is supposed to. A more deterministic approach is to also run the UAT using automated tools, similar to the ones used in end-to-end testing. Even in this case, it's common to still perform a small part of this phase manually, by doing<a id="_idIndexMarker1744"/> what is called a <strong class="bold">smoke test</strong>, which is less structured and aimed at giving a general idea of how the application behaves. </p>
			<p>Whether being done manually or automated, there is a core difference between UAT and the other tests seen so far, and this difference is that the tests need to be designed around business capabilities. Indeed, each test case is supposed to be related to a specific requirement in order to prove that this requirement is currently implemented in that particular software release. We already discussed this in <a href="B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Software Requirements – Collecting, Documenting, Managing</em>, where we saw how each software requirement is supposed to be testable.</p>
			<p>This is where that loop closes. The successful execution of UAT is the gateway for the production release (hence the word <em class="italic">acceptance</em>); if all the tests succeed, it is, of course, safe and accepted to release in production. In case of any failure, a choice needs to be made (usually discussed with an extended team).</p>
			<p>If minor issues occur, this may mean that the release will go into production anyway, with several known issues. Of course, if this is not the case and the issues are too many (or related to critical features), then the issues need to be fixed and the production release may be canceled or delayed. UAT is basically the higher rank of tests, but it's important to understand that it's crucial to have a strategy around every other testing technique seen so far; otherwise, it's likely to have software that is not completely tested and prone to errors. However, some other considerations around testing are worth noticing.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor314"/>Further testing considerations</h2>
			<p>In the previous sections, we saw quite a few interesting things on testing, including the different testing phases and techniques. However, there are a number of other considerations that are worth a few words.</p>
			<h3>Interacting with external systems</h3>
			<p>As we <a id="_idIndexMarker1745"/>have seen, in most of the phases of testing (sometimes even in unit testing), external systems may be involved. Databases, mail servers, and web services are common examples.</p>
			<p>There are a number of different techniques for dealing with such external systems in a testing phase. The easiest one, better suited for some specific testing phases, such as unit tests, is to simply mock such systems. This means implementing special custom classes that simply simulate the interaction with such systems, instead of just providing fake values.</p>
			<p>A very widespread library for mocking in Java is <strong class="source-inline">Mockito</strong>, which offers a simple but very complete setup to implement methods that react to the requests in a programmable way, simulating the behavior of external systems.</p>
			<p>Mocking is handy to use because it's mostly driven by code and requires minimal maintenance. However, as it's easy to understand, it provides limited effectiveness in tests because it tests just a small part of the interaction, often neglecting some aspects such as the connection to the external system (and things that may go bad there), and in general, doesn't test against real (or close to real) systems. </p>
			<p>A step further is to effectively use an external system in tests, but a simplified one. The most common example is using H2 (the embeddable database we saw in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>) in place of a full-fledged database system. The reason behind it is that it may be harder (and more expensive) to use compared to the real system, while such simplified tools are usually easier to automate and use in a testing environment.</p>
			<p>However, as we discussed in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, when talking about 12-factor applications, using external services (backing services, as defined in that context) different from the production ones should be considered a source of potential instability as, of course, the behavior may be different from real systems. So, especially in phases such as end-to-end testing and UAT, it's strongly advised to use external systems that are as close as possible to the production ones. This leads us to the next consideration on ephemeral testing.</p>
			<h3>Ephemeral testing</h3>
			<p><strong class="bold">Ephemeral testing</strong> is a <a id="_idIndexMarker1746"/>technique for creating complete<a id="_idIndexMarker1747"/> test environments when needed. This basically means that the set of components needed for testing, including the application and the external systems, is created on-demand before each test runs, populated with the data and the configuration needed for the test execution.</p>
			<p>Such environments can then be disposed of after each test runs, avoiding wasting computational resources when not needed. This paradigm is particularly suited for IaaS and PaaS environments (as seen in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>) because such infrastructures will facilitate the scripting and automation around environment creation and disposal. IaaS and PaaS are also suited to recreating not only the application components themselves but also the external services (such as databases), and so are a good way to overcome the limitations that we have described in the previous section, and in particular with mocks. </p>
			<p>Testcontainers (<a href="https://www.testcontainers.org">www.testcontainers.org</a>) is an<a id="_idIndexMarker1748"/> open source <a id="_idIndexMarker1749"/>framework very well suited for this kind of scenario. It supports JUnit (as well as other testing frameworks) and provides throwaway containerized instances of testing utilities (such as common databases, Selenium browsers, and more).</p>
			<p>But having all the right components is not the only consideration to be made in order to have a meaningful and complete testing strategy.</p>
			<h3>Code coverage, test coverage, and maintenance</h3>
			<p>A crucial <a id="_idIndexMarker1750"/>topic of testing is coverage. <strong class="bold">Code coverage</strong> basically <a id="_idIndexMarker1751"/>implies that every line of code, including the ones reached after <strong class="source-inline">if</strong> conditions, loops, and so on, is hit by at least a test case.</p>
			<p>These kinds of metrics are not easy to measure manually and indeed are commonly calculated by relying on external tools. The most commonly used technique by such tools is <strong class="bold">bytecode instrumentation</strong>, which <a id="_idIndexMarker1752"/>uses special features of the JVM to check code execution per line, as a result of tests running. Common libraries used for calculating code coverage, such as Cobertura and JaCoCo, use a similar approach.</p>
			<p>Code coverage is<a id="_idIndexMarker1753"/> the baseline of test completeness: a certain threshold must be defined, and a lower coverage should be considered as incomplete testing, especially when creating new functions and modules. But code coverage doesn't ensure that all the features are tested, nor that the data used for tests is complete and variable enough. Hence, a further concept—<strong class="bold">test coverage</strong>—must be introduced.</p>
			<p>Test coverage<a id="_idIndexMarker1754"/> is, in my opinion, a bit less <em class="italic">scientific</em> to calculate. Whether <a id="_idIndexMarker1755"/>code coverage is exactly measurable (even if it requires tools) as the percentage of lines of code executed during tests versus the total lines of code, test coverage revolves around many different points of view. Some common ones are as follows:</p>
			<ul>
				<li><strong class="bold">Features coverage</strong>, as<a id="_idIndexMarker1756"/> in the number of features tested versus the total features of the application.</li>
				<li><strong class="bold">Requirements coverage</strong>, as<a id="_idIndexMarker1757"/> in the number of requirements effectively tested versus the total requirements that the software implements.</li>
				<li><strong class="bold">Device coverage</strong>, particularly <a id="_idIndexMarker1758"/>meaningful in web and mobile applications, is related to the number of different configurations (different mobile devices, multiple OS versions, multiple browsers versions, and so on) that our application is tested against.</li>
				<li><strong class="bold">Data coverage</strong>, related<a id="_idIndexMarker1759"/> to the different inputs and configuration that our application is tested against. This is, of course, very difficult to test against, as the combination can really be limitless. On the other hand, having a good variety of inputs to test ensures better protection against unexpected behaviors.</li>
			</ul>
			<p>Both code coverage and test coverage should be constantly measured and possibly improved. That implies covering the code added with new features (if any), and checking against the bugs found in the current software releases in order to understand whether there is a way to improve test coverage to check for such bugs in the future. Customer reports are particularly useful in this sense. </p>
			<p>Most of us are familiar with issues in the applications we use (especially in mobile applications) when, following an error message, there is the opportunity to send details of the error to the application team. By doing so, the application team has the opportunity to check for the particular conditions (inputs used, device used, and software version) at the time of that particular error, and can potentially extend the test suite (and, hence, the test coverage) to check for similar situations and avoid this family of errors in the future.</p>
			<p>Last but not least, it's important to<a id="_idIndexMarker1760"/> understand when to run what kind of tests.</p>
			<p>Since running a whole test suite (including acceptance tests run by human operators) could be expensive and time-intensive, it's a common choice to have different test suites run in different situations. If we are fixing a minor bug or adding a small functionality, then we can probably take the risk of not testing the whole application, but just a subset.</p>
			<p>However, with test automation becoming more and more pervasive and disposable test environments made possible by the cloud, the advice is to test as much as possible, especially for performance. In this way, it will become easier to understand whether the release we are testing <a id="_idIndexMarker1761"/>introduces any performance issues. This concept, taken to the extreme, is called <strong class="bold">continuous testing</strong>, and basically implies running the complete suite of tests, in an automated way, after every code or configuration change (even the smallest one). </p>
			<p>In this section, we have seen a complete overview of the different testing techniques and phases. Starting with unit testing, we also explored integration, end-to-end, and performance tests.</p>
			<p>In the next section, we are going to talk about a step that is contiguous to (and mutually dependent on) testing: deployment.</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor315"/>Deploying</h1>
			<p><strong class="bold">Software deployment</strong> is a<a id="_idIndexMarker1762"/> very broad term, and can extensively be used to refer to the whole software life cycle, from development to release into production. However, in this particular context, I am referring to the deployment phase as<a id="_idIndexMarker1763"/> the one in which the software is compiled and opportunely packaged, and the right configurations are applied. The software is then supposedly run and made ready for users to access (which is part of the process of releasing; more on this in a couple of sections). While we already mentioned some of these topics in this book, I would like to highlight a couple of them, useful for the purpose of this chapter.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor316"/>Building the code</h2>
			<p>The<a id="_idIndexMarker1764"/> phase of building the code, intended as compilation and packaging into a deployable artifact (<strong class="source-inline">.jar</strong>, <strong class="source-inline">.war</strong>, and <strong class="source-inline">.ear</strong> in the case of Java), is done by utilities shipped with the JDK (in particular, the <strong class="source-inline">javac</strong> tool).</p>
			<p>However, this process often includes at the very least the management of dependencies, but in the real world, many other steps can be involved, such as code formatting, the parsing of resources or configuration files, and the execution of unit tests (as seen before).</p>
			<p>A widely used technology to perform all of those steps, mentioned and used many times in this book, is Apache Maven.</p>
			<p>While I assume that most of you already know and have used Maven, I think it is relevant to highlight some<a id="_idIndexMarker1765"/> features that are useful to consider from an architect's perspective:</p>
			<ul>
				<li>Maven uses a standard way (the <strong class="source-inline">pom.xml</strong> file) to define instructions about building the software. Indeed, the <strong class="source-inline">pom</strong> file collects the list of dependencies (including the one needed just for testing purposes and the one needed just at development time). It can also specify the steps needed for the compilation and packaging of the software and provide some configurations for each step.</li>
				<li>It provides an extensible system, based on plugins. Hence, you can find (or implement) different plugins, to run tests, create documentation, generate code, and other steps that could be useful at deployment time.</li>
				<li>It can define a hierarchy between different projects and provide a unique way to identify each software artifact (also called a Maven artifact) by setting what is called<a id="_idIndexMarker1766"/> the <strong class="bold">Group, Artifact, Version</strong> (<strong class="bold">GAV</strong>) coordinate standard, a triplet made by <strong class="source-inline">GroupId</strong> (basically a namespace or package for the project), <strong class="source-inline">ArtifactId</strong> (the identifying name of the project), and the version.</li>
			</ul>
			<p>As said, Maven is basically a standard technology for building in the Java world, though it's not the only one. <strong class="bold">Ant</strong> is <a id="_idIndexMarker1767"/>another option that used to be widely used some years ago and is more similar to scripting and less flexible. It has been progressively abandoned for its verbosity <a id="_idIndexMarker1768"/>and a number of shortcomings in dependency management.</p>
			<p><strong class="bold">Gradle</strong> is a <a id="_idIndexMarker1769"/>modern alternative to Maven, mostly widespread in the context of Android application development. However, the concept of code building raises the need of archiving and managing the dependencies, in the form of built artifacts (which, as we have seen, are referenced uniquely into the <strong class="source-inline">pom.xml</strong> configuration files). Let's have a quick overview of this concept.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor317"/>Managing artifacts</h2>
			<p>Software <a id="_idIndexMarker1770"/>artifacts are essential, both as part of the building process of bigger components (as dependencies) and to be directly deployed (as an example, to production environments). While it's possible to directly manage such contents (which, in the Java world, are basically <strong class="source-inline">.jar</strong>, <strong class="source-inline">.ear</strong>, and <strong class="source-inline">.war</strong> files) in filesystem folders, it's way better to do so in optimized systems. Such systems are<a id="_idIndexMarker1771"/> called <strong class="bold">artifact repositories</strong>.</p>
			<p>An artifact repository often provides many advanced features, including the following:</p>
			<ul>
				<li><strong class="bold">Web interfaces</strong>, to <a id="_idIndexMarker1772"/>simplify the search of the artifacts and the management of them.</li>
				<li><strong class="bold">Role-based access control and authenticated access</strong>, providing differentiated <a id="_idIndexMarker1773"/>access to different artifacts. A common example is that some artifacts can be changed only by certain groups, while others can be accessed in read-only mode, and maybe others have no access at all.</li>
				<li>Other <strong class="bold">security features</strong>, such <a id="_idIndexMarker1774"/>as inspecting the code for known vulnerabilities (as we have seen in <a href="B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292"><em class="italic">Chapter 12</em></a>, <em class="italic">Cross-Cutting Concerns</em>, when talking about security).</li>
				<li><strong class="bold">Versioning of the dependencies</strong>, including the cleanup of older versions under <a id="_idIndexMarker1775"/>configurable policies.</li>
				<li><strong class="bold">Mirroring and hierarchy</strong>, by <a id="_idIndexMarker1776"/>providing the possibility of querying other artifact <a id="_idIndexMarker1777"/>repositories over the<a id="_idIndexMarker1778"/> internet to look up dependencies not available locally, and then mirroring it in order to avoid downloads when not necessary. A very famous repository available over the internet <a id="_idIndexMarker1779"/>is <strong class="bold">Maven Central</strong>.</li>
			</ul>
			<p>Two<a id="_idIndexMarker1780"/> very famous implementations of Maven artifact repositories are JFrog Artifactory and Sonatype Nexus.</p>
			<p>It's worth noting that the container technology (as discussed in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>) is often seen as an extension (but not a replacement) of Java artifacts. Indeed, a container image contains a complete application component, including dependencies at an OS level, where JVM and other middleware are needed. Moreover, a container image is immutable and can be uniquely identified (by using a version and a signature), so it is really similar to a Java artifact and raises similar needs in terms of management.</p>
			<p>For this reason, the ideas exposed about Java artifact repositories can be extended to container repositories. It's not incidental that both the mentioned technologies (Artifactory and Nexus) have extensions used for handling containers.</p>
			<p>Popular container repositories available online include Docker Hub and Quay.io.</p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor318"/>Completing the deployment</h2>
			<p>As we <a id="_idIndexMarker1781"/>have looked at code compiling and the management of artifacts, it is now time to complete the deployment. This may include different steps, which ultimately aim to install the artifacts in the right places, perform some configurations, and execute the software. The details of these steps may vary heavily depending on the technology used:</p>
			<ul>
				<li>In the traditional Java world, there are custom ways to use Java application servers (such as WildFly, as seen in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>) depending on the application server used. Common ones are copying the application artifact in a specific folder or invoking a command-line utility that triggers the deployment process. More steps for configuring things (such as a connection to databases) may be needed and usually involve changes in configuration files or commands issued.</li>
				<li>When using fat <strong class="source-inline">.jar</strong> applications (such as Spring Boot or Quarkus) in a non-containerized environment, the deployment process usually involves just copying the fat <strong class="source-inline">.jar</strong> in a specified location and running it using a command. This may be done with shell scripts, which can then address other steps (where relevant), such as the cleanup of the previous versions and the changes in configuration files.</li>
				<li>In <a id="_idIndexMarker1782"/>containerized environments, deployment basically involves copying the container (Kubernetes and Docker are usually configured to access remote container repositories) and executing a number of commands to make it run. In Kubernetes, this is almost entirely done by using <strong class="source-inline">kubectl</strong>. </li>
			</ul>
			<p>As we have seen, different technologies require slightly different ways to complete deployment and effectively distribute and run the software packages. If you consider that more steps can be required, including the configuration of external systems such as databases and IaaS or PaaS systems, it's often a good idea to orchestrate those steps in a unified way. This is one of the characteristics of CI/CD.</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor319"/>Continuous integration/continuous delivery (and deployment)</h1>
			<p>CI/CD is the<a id="_idIndexMarker1783"/> process of automating most of the steps seen so far (and sometimes some more) in order to straighten the process and have a complete overview of it. Since the process includes many steps executed in a mostly sequential way, the tool providing it is commonly<a id="_idIndexMarker1784"/> called a <strong class="bold">pipeline</strong>.</p>
			<p>A typical CI pipeline<a id="_idIndexMarker1785"/> includes these steps, usually executed sequentially:</p>
			<ol>
				<li>Building the code (as seen in previous sections).</li>
				<li>Testing, usually limited to static code testing, unit testing, and some limited integration testing. Since <a id="_idIndexMarker1786"/>deployment has not occurred yet, end-to-end testing is not possible in this phase.</li>
			</ol>
			<p>CD includes<a id="_idIndexMarker1787"/> a few further steps, focused on deployment (also, in this case, usually executed in a sequence):</p>
			<ol>
				<li value="1">Versioning of software artifacts in repositories.</li>
				<li>Deployment of artifacts from repositories to testing environments, including all the configuration needed. This may be done in ephemeral environments (as seen in previous sections).</li>
				<li>End-to-end testing in such environments.</li>
				<li>Deployment in other non-production environments, with the goal of user acceptance and/or performance testing.</li>
			</ol>
			<p>Here is a<a id="_idIndexMarker1788"/> simplified sample pipeline:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_13.05_B16354.jpg" alt="Figure 13.5 – A sample pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 – A sample pipeline</p>
			<p>In the preceding diagram, you can see a simplified pipeline example. There are a few steps (<strong class="bold">Automated tests</strong> and <strong class="bold">Artifact archiving</strong>) that are performed in parallel. Moreover, between <strong class="bold">Staging Deployment</strong> and <strong class="bold">Prod Deployment</strong>, some actions may happen, such as UAT and manual approval.</p>
			<p>CD is considered a further extension of the pipeline, and basically includes the deployment of the environments in production environments. This may happen in a completely automated way (with no manual intervention), or it may require manual approval by a release manager (in more traditional environments).</p>
			<p>It's of <a id="_idIndexMarker1789"/>course intended that a failure in any step usually means that the pipeline stops and the release fails. It's also worth noticing that deployment in production does not necessarily mean that the software is released and available to users, as we will see soon. But first, it is worth having a look at widespread pipeline implementations.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor320"/>Common CI/CD software implementations</h2>
			<p>It's almost<a id="_idIndexMarker1790"/> impossible to talk about CI/CD without mentioning Jenkins.</p>
			<p>Jenkins is a <a id="_idIndexMarker1791"/>complete automation server, which is basically a synonym of CI/CD pipelines.</p>
			<p>It's written in Java and deployed in a servlet container (usually Tomcat). It's possible to define pipelines in Jenkins, using a domain-specific language, which describes each step with the required parameters. Through a system of plugins, steps in Jenkins can do many different things, including compilation using Maven, performing SSH commands, and executing test suites.</p>
			<p>Jenkins can then display the pipeline execution results, archive them, and optionally send notifications (as an example, in case of a build failure).</p>
			<p>While still being widely used, Jenkins is nowadays famous for having a monolithic architecture (although some steps can be delegated to agents) and for being resource-intensive.</p>
			<p>Attempts to create alternative pipeline software, with a more modern design and better performances in a cloud environment, are currently underway. The most famous ones are Jenkins X and Tekton. </p>
			<p>Both of these software types, while created using different languages and frameworks, share the concept of implementing each step in a container, thereby improving horizontal scaling and reusability. </p>
			<p>Other famous implementations of CI/CD capabilities include Travis, GitLab, and, more recently, some cloud alternatives such as GitHub Actions.</p>
			<p>As we have said, regardless of the implementation, the CI/CD process can automate steps up to the production deployment. However, in order to make the software available to final users, the process requires some final steps.</p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor321"/>Releasing</h1>
			<p><strong class="bold">Releasing</strong> is usually the<a id="_idIndexMarker1792"/> final step of a complete CI/CD pipeline. The process can be performed, in simple environments, together with deployment in production.</p>
			<p>However, nowadays, it's common to split deployment and releasing into two different steps, and this allows more sophisticated (and often safer) ways of releasing software versions to end users. To do so, the most basic ingredient is to have different versions of the software available in production at the same time and to route users to each version by following different criteria (which is done by operating at a network level, routing each request to the desired target version). Let's look <a id="_idIndexMarker1793"/>at some scenarios opened by this kind of technique:</p>
			<ul>
				<li><strong class="bold">Blue-green deployment</strong>: Two <a id="_idIndexMarker1794"/>versions of <a id="_idIndexMarker1795"/>production environments (including database and other external systems) are released in production. This includes the version we want to release (identified as blue or green) and the previous version (identified by the color left, so either green or blue). The candidate release can then be tested in a real environment. If everything works as expected, the network traffic is then routed to the new version. A rollback can be easily performed at any time. In the next release, the same is done, replacing the previous version with the next one and changing the color-coding. The following diagram illustrates this:</li>
			</ul>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_13.06_B16354.jpg" alt="Figure 13.6 – Blue-green deployment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6 – Blue-green deployment</p>
			<ul>
				<li><strong class="bold">Rolling releases</strong>: This <a id="_idIndexMarker1796"/>implies that our application<a id="_idIndexMarker1797"/> components are provided on a set of identical instances (hosted on VMs or containers). When a release occurs, the <strong class="bold">New version</strong> is installed on a new instance and traffic starts to be sent to such new instances, too. Then, an <strong class="bold">Old instance</strong> is shut down (optionally draining all the pending connections). This process keeps going until all the instances are running on the new version, as shown here:</li>
			</ul>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_13.07_B16354.jpg" alt="Figure 13.7 – Rolling releases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7 – Rolling releases</p>
			<p>In the preceding diagram, each <em class="italic">circle</em> represents an instance (such as a VM or an application instance). The two steps are represented as a sample, but you can imagine that the <strong class="bold">New version</strong> starts from an instance, goes to two, and so on, and the <strong class="bold">Old version</strong> is progressively shut down, one instance at a time.</p>
			<p>While this can be a subtle difference, compared to the blue-green deployment, a rolling release can be seen as a kind of technical trick aiming to reduce downtime in releases, but it provides fewer guarantees if a rollback is needed. Moreover, since old and new instances coexist for a certain amount of time, issues may occur, both on the application and on the external systems (such as databases).</p>
			<ul>
				<li><strong class="bold">Canary releases</strong>: Basically, this <a id="_idIndexMarker1798"/>is a variant of<a id="_idIndexMarker1799"/> blue-green deployment. The new release is still provided alongside the previous version, but instead of switching traffic as a whole, this is done progressively, such as routing 1% of the users, then 2%, and so on, until all the users are running on the new release. This technique allows smoother releases and makes it easier to identify issues, if present (and optionally roll back), without impacting the whole customer base, as illustrated here:</li>
			</ul>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_13.08_B16354.jpg" alt="Figure 13.8 – Canary releases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8 – Canary releases</p>
			<p>In the <a id="_idIndexMarker1800"/>preceding diagram, we can see just two sample phases, where we start routing <strong class="bold">90%</strong> of the traffic toward the <strong class="bold">Old version</strong>, and <strong class="bold">10%</strong> to the <strong class="bold">New version</strong>, and another one representing <strong class="bold">1%</strong> toward the <strong class="bold">Old version</strong> and <strong class="bold">99%</strong> toward the <strong class="bold">New version</strong>. Of course, in a real situation, you<a id="_idIndexMarker1801"/> can imagine a constant flow going from 1% to 100% and vice versa. The name <em class="italic">canary</em> refers to the canary used by miners to identify gas leakages. In a similar way, bugs are identified sooner, by a small percentage of users, and it's possible to stop the release before impacting more users.</p>
			<ul>
				<li><strong class="bold">A/B testing</strong>: Technically, this <a id="_idIndexMarker1802"/>is identical to the blue-green deployment. The<a id="_idIndexMarker1803"/> most important difference is that, in this case, we are evaluating two alternative versions. The two versions should not be considered as a previous one and a next one, but instead two slightly different variants of the same software that the business wants to test against real users. The following diagram shows this:</li>
			</ul>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_13.09_B16354.jpg" alt="Figure 13.9 – A/B testing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9 – A/B testing</p>
			<p>Such<a id="_idIndexMarker1804"/> variants are usually small changes in the user interface or other features, and the business aims to measure how those changes perform in the real world. The most <a id="_idIndexMarker1805"/>common example is with online shops, where the business is willing to check whether changes in the purchase process (colors, position of the buttons, and the number of steps) enhance commercial performance.</p>
			<p>In A/B testing, the less performant version is usually discarded. It's also worth noticing that the users routed to each version can be chosen randomly, split by percentage (such as 50% for each version), or even selected by specific criteria (where available), such as the geographical location or the age of the user.</p>
			<ul>
				<li><strong class="bold">Traffic shadowing</strong>: This<a id="_idIndexMarker1806"/> is a bit less common than<a id="_idIndexMarker1807"/> the other alternatives. It implies that a new release of the software is released in production, where users keep using the older version while the new version gets a copy of all the production traffic:</li>
			</ul>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/Figure_13.10_B16354.jpg" alt="Figure 13.10 – Traffic shadowing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10 – Traffic shadowing</p>
			<p>It can be really useful for load testing in the case of major releases, but it may not work<a id="_idIndexMarker1808"/> in some specific scenarios, and it's necessary to understand the impacts in any specific use case. As an example, if notifications (such as via email) are sent, we should ensure that they are not sent by both the old and the new systems, to minimize the impact on users.</p>
			<p>It's worth noticing that these kinds of release techniques (especially the simpler ones) are nothing new, and were also possible before modern cloud and microservice architectures. However, to <a id="_idIndexMarker1809"/>use them in traditional environments, you may need to coordinate with external teams (such as the ones administering the network), while modern architectures (such as the ones based on public clouds, IaaS or PaaS) provide way more flexibility, allowing the creation of new instances on the fly, and changing network configurations favored by software-defined networking. In the next section, we are going to complete our view of the software life cycle by looking at some considerations regarding software maintenance.</p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor322"/>Maintenance</h1>
			<p><strong class="bold">Software maintenance</strong> is <a id="_idIndexMarker1810"/>usually a great part of software life. In my professional experience, it's not uncommon for a project to be fully active (with a lot of new features and developments happening) for a couple of years, followed by many years of maintenance, which is focused on fixing bugs and keeping the product alive (without releasing any new features).</p>
			<p>It goes without saying that the maintenance period can become more expensive than the building of the project. Moreover, but this is a consideration purely from an economic perspective, enterprises often find it easier to access the budget for building new applications (which is seen as money generating, or at least associated with business initiatives) than for maintaining and modernizing older ones (which is seen as IT for IT, which means that this is a project with no business impact, hence, purely a cost).</p>
			<p>With that said, maintenance activities on existing applications can be roughly categorized into one of the following buckets:</p>
			<ul>
				<li><strong class="bold">Bug fixes</strong> address <a id="_idIndexMarker1811"/>defects in the software, which may be an existing issue in code or code behaving badly due to an external unforeseeable situation.</li>
				<li><strong class="bold">Requests For Enhancement</strong> (<strong class="bold">RFEs</strong>), which<a id="_idIndexMarker1812"/> are targeted around covering new use cases<a id="_idIndexMarker1813"/> that were not originally planned.</li>
			</ul>
			<p>Of course, both of these types of activities can then have an impact and an effort associated, which may help prioritize the implementation.</p>
			<p>The software maintenance process is then further categorized into four types, independent of the previous two categories:</p>
			<ul>
				<li><strong class="bold">Corrective maintenance</strong>, which <a id="_idIndexMarker1814"/>must<a id="_idIndexMarker1815"/> be done as a reaction to issues occurring and problems being reported. Think about a classic bug fixing activity as a consequence of the application behaving incorrectly.</li>
				<li><strong class="bold">Adapting maintenance</strong>, which<a id="_idIndexMarker1816"/> aims <a id="_idIndexMarker1817"/>at keeping the software correctly working in changing environments. Think about the application needing to be adapted to a newer version of the JVM, or to the release of a new browser. </li>
				<li><strong class="bold">Perfecting maintenance</strong>, which<a id="_idIndexMarker1818"/> aims<a id="_idIndexMarker1819"/> at making our application just better, in terms of performance, resource usage, maintainability, or other enhancements (such as a better user experience). This is often neglected, as it's a proactive activity and nothing in the short term usually happens if it's not done. However, it may have a big positive impact (also in terms of savings) because it can, of course, prevent issues in the future. Moreover, avoiding perfecting maintenance may mean growing the so-called <em class="italic">technical debt</em>, which means that more and more tasks (such as fine-tuning, refactoring, and enhancing test coverage) will pile up, becoming less and less manageable (and more expensive to tackle).</li>
				<li><strong class="bold">Preventive maintenance</strong>, which <a id="_idIndexMarker1820"/>is really <a id="_idIndexMarker1821"/>similar to the previous one, but revolves around fixing issues that have been identified (such as known bugs) before they become actual <a id="_idIndexMarker1822"/>problems. As per the previous point, it risks being neglected and can cause technical debt if not handled properly.</li>
			</ul>
			<p>Other than having a direct cost (because somebody needs to do it), all the maintenance categories may have several impacts. Indeed, such activities often involve software releases or configuration changes, and this may impact the application availability (and have a negative influence on <a id="_idIndexMarker1823"/>the <strong class="bold">Service Level Agreement</strong> (<strong class="bold">SLA</strong>) established). There may even be legal agreements relegating maintenance activities to well-defined timeframes or allowing it only to solve high-severity issues. </p>
			<p>Moreover, software maintenance can have an indirect impact because the activities (both enhancements and bug fixing) can change the application behavior and, in some cases, even leave the API exposed, hence, forcing the users to adapt to such changes or the developers to plan for implementing the retro compatibility.</p>
			<p>With that said, application maintenance should never be neglected. Instead, it should be planned (and financed) from the very beginning of the project and be constantly adjusted over time. Indeed, a project that is not correctly maintained can incur security issues or customer dissatisfaction, or also simply lose attractivity on the market. This will risk nullifying all the efforts made to design and implement the project. </p>
			<p>This was the last topic of this chapter. Let's now have a look at a summary of what we have learned.</p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor323"/>Summary</h1>
			<p>In this chapter, we have had an overview of many crucial phases of the software life cycle. </p>
			<p>Starting with SCM, we had a quick discussion of Git, which is the de facto standard over SCM. This allowed us to understand development models, with a focus on trunk-based development, which is common in CI/CD and DevOps-based projects.</p>
			<p>We also briefly discussed semantic versioning, which is a way to identify what changes to expect based on the release version numbering. </p>
			<p>We then entered the testing phase, starting with unit testing (and the inevitable description of JUnit, a standard for testing in Java). From unit testing, we moved on to other testing techniques, including integration, end-to-end, and UAT.</p>
			<p>Deploying was the next step. We discussed the steps needed to compile software and run it, including an overview of Apache Maven and artifact management. The next topic was CI/CD and pipelines with some consideration around automating most of the steps seen in this chapter.</p>
			<p>Then, we focused on releasing, which is the process of making the deployed software available to final users, and we saw many different options to do so, including blue-green and canary releases. Last but not least, we had an overview of maintenance activities (both bug fixes and enhancements) and why they are crucial for the overall success of our project.</p>
			<p>In the next chapter, we are going to discuss monitoring and tracing, which are some core concepts for ensuring that our software is performing well in production, and for constantly understanding and governing what's happening.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor324"/>Further reading</h1>
			<ul>
				<li>Richard E. Silverman: <em class="italic">Git Pocket Guide</em></li>
				<li>Konrad Gadzinowski: <em class="italic">Trunk-based Development vs. Git Flow</em> (<a href="https://www.toptal.com/software/trunk-based-development-git-flow">https://www.toptal.com/software/trunk-based-development-git-flow</a>)</li>
				<li>Hardik Shah: <em class="italic">Why Test Coverage is an Important Part of Software Testing?</em> (<a href="https://www.simform.com/blog/test-coverage/">https://www.simform.com/blog/test-coverage/</a>)</li>
				<li>Himanshu Sheth: <em class="italic">Code Coverage vs Test Coverage – Which Is Better?</em> (<a href="https://dzone.com/articles/code-coverage-vs-test-coverage-which-is-better">https://dzone.com/articles/code-coverage-vs-test-coverage-which-is-better</a>)</li>
				<li>Sten Pittet: <em class="italic">Continuous integration vs. continuous delivery vs. continuous deployment</em> (<a href="https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment">https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment</a>)</li>
				<li>Michael T. Nygard: <em class="italic">Release It!: Design and Deploy Production-Ready Software</em></li>
				<li>Martin Fowler: <em class="italic">BlueGreenDeployment </em>(<a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">https://martinfowler.com/bliki/BlueGreenDeployment.html</a>)</li>
			</ul>
		</div>
	</body></html>