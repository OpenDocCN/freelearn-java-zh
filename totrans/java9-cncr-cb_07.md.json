["```java\n        public class AddTask implements Runnable {\n\n```", "```java\n        private final ConcurrentLinkedDeque<String> list;\n\n```", "```java\n        public AddTask(ConcurrentLinkedDeque<String> list) { \n         this.list=list; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          String name=Thread.currentThread().getName(); \n          for (int i=0; i<10000; i++){ \n            list.add(name+\": Element \"+i); \n          } \n        }\n\n```", "```java\n        public class PollTask implements Runnable {\n\n```", "```java\n        private final ConcurrentLinkedDeque<String> list;\n\n```", "```java\n        public PollTask(ConcurrentLinkedDeque<String> list) { \n          this.list=list; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<5000; i++) { \n            list.pollFirst(); \n            list.pollLast(); \n          } \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) {\n\n```", "```java\n        ConcurrentLinkedDeque<String> list=new ConcurrentLinkedDeque<>();\n\n```", "```java\n        Thread threads[]=new Thread[100];\n\n```", "```java\n        for (int i=0; i<threads.length ; i++){ \n          AddTask task=new AddTask(list); \n          threads[i]=new Thread(task); \n          threads[i].start(); \n        } \n        System.out.printf(\"Main: %d AddTask threads have been launched\\n\",\n                          threads.length);\n\n```", "```java\n        for (int i=0; i<threads.length; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        System.out.printf(\"Main: Size of the List: %d\\n\",list.size());\n\n```", "```java\n        for (int i=0; i< threads.length; i++){ \n          PollTask task=new PollTask(list); \n          threads[i]=new Thread(task); \n          threads[i].start(); \n        } \n        System.out.printf(\"Main: %d PollTask threads have been launched\\n\",\n                          threads.length);\n\n```", "```java\n        for (int i=0; i<threads.length; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        System.out.printf(\"Main: Size of the List: %d\\n\",list.size());\n\n```", "```java\n        public class Client implements Runnable{\n\n```", "```java\n        private final LinkedBlockingDeque<String> requestList;\n\n```", "```java\n        public Client (LinkedBlockingDeque<String> requestList) { \n          this.requestList=requestList; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<3; i++) { \n            for (int j=0; j<5; j++) { \n              StringBuilder request=new StringBuilder(); \n              request.append(i); \n              request.append(\":\"); \n              request.append(j); \n              try { \n                requestList.put(request.toString()); \n              } catch (InterruptedException e) { \n                e.printStackTrace(); \n              } \n              System.out.printf(\"Client added: %s at %s.\\n\",request,\n                                new Date()); \n            } \n            try { \n              TimeUnit.SECONDS.sleep(2); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } \n          } \n          System.out.printf(\"Client: End.\\n\"); \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        LinkedBlockingDeque<String> list=new LinkedBlockingDeque<>(3);\n\n```", "```java\n        Client client=new Client(list); \n        Thread thread=new Thread(client); \n        thread.start();\n\n```", "```java\n        for (int i=0; i<5 ; i++) { \n          for (int j=0; j<3; j++) { \n            String request=list.take(); \n            System.out.printf(\"Main: Removed: %s at %s. Size: %d\\n\",\n                              request,new Date(), list.size()); \n          } \n          TimeUnit.MILLISECONDS.sleep(300); \n        }\n\n```", "```java\n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        public class Event implements Comparable<Event> {\n\n```", "```java\n        private final int thread;\n\n```", "```java\n        private final int priority;\n\n```", "```java\n        public Event(int thread, int priority){ \n          this.thread=thread; \n          this.priority=priority; \n        }\n\n```", "```java\n        public int getThread() { \n          return thread; \n        }\n\n```", "```java\n        public int getPriority() { \n          return priority; \n        }\n\n```", "```java\n        @Override \n        public int compareTo(Event e) { \n          if (this.priority>e.getPriority()) { \n            return -1; \n          } else if (this.priority<e.getPriority()) { \n            return 1;  \n          } else { \n            return 0; \n          } \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final int id;\n\n```", "```java\n        private final PriorityBlockingQueue<Event> queue;\n\n```", "```java\n        public Task(int id, PriorityBlockingQueue<Event> queue) { \n          this.id=id; \n          this.queue=queue; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<1000; i++){ \n            Event event=new Event(id,i); \n            queue.add(event); \n          } \n        }\n\n```", "```java\n        public class Main{ \n          public static void main(String[] args) {\n\n```", "```java\n        PriorityBlockingQueue<Event> queue=new PriorityBlockingQueue<>();\n\n```", "```java\n        Thread taskThreads[]=new Thread[5];\n\n```", "```java\n        for (int i=0; i<taskThreads.length; i++){ \n          Task task=new Task(i,queue); \n          taskThreads[i]=new Thread(task); \n        }\n\n```", "```java\n        for (int i=0; i<taskThreads.length ; i++) { \n          taskThreads[i].start(); \n        }\n\n```", "```java\n        for (int i=0; i<taskThreads.length ; i++) { \n          try { \n            taskThreads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        System.out.printf(\"Main: Queue Size: %d\\n\",queue.size()); \n        for (int i=0; i<taskThreads.length*1000; i++){ \n          Event event=queue.poll(); \n          System.out.printf(\"Thread %s: Priority %d\\n\",\n                            event.getThread(),event.getPriority()); \n        }\n\n```", "```java\n        System.out.printf(\"Main: Queue Size: %d\\n\",queue.size()); \n        System.out.printf(\"Main: End of the program\\n\");\n\n```", "```java\n        public class Event implements Delayed {\n\n```", "```java\n        private final Date startDate;\n\n```", "```java\n        public Event (Date startDate) { \n          this.startDate=startDate; \n        }\n\n```", "```java\n        @Override \n        public int compareTo(Delayed o) { \n          long result=this.getDelay(TimeUnit.NANOSECONDS)-o.getDelay\n                                                    (TimeUnit.NANOSECONDS); \n          if (result<0) { \n            return -1; \n          } else if (result>0) { \n            return 1; \n          } \n          return 0; \n        }\n\n```", "```java\n        public long getDelay(TimeUnit unit) {   \n          Date now=new Date(); \n          long diff=startDate.getTime()-now.getTime(); \n          return unit.convert(diff,TimeUnit.MILLISECONDS); \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final int id;\n\n```", "```java\n        private final DelayQueue<Event> queue;\n\n```", "```java\n        public Task(int id, DelayQueue<Event> queue) { \n          this.id=id; \n          this.queue=queue; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          Date now=new Date(); \n          Date delay=new Date(); \n          delay.setTime(now.getTime()+(id*1000)); \n          System.out.printf(\"Thread %s: %s\\n\",id,delay);\n\n```", "```java\n          for (int i=0; i<100; i++) { \n            Event event=new Event(delay); \n            queue.add(event); \n          }   \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        DelayQueue<Event> queue=new DelayQueue<>();\n\n```", "```java\n        Thread threads[]=new Thread[5];\n\n```", "```java\n        for (int i=0; i<threads.length; i++){ \n          Task task=new Task(i+1, queue); \n          threads[i]=new Thread(task); \n        }\n\n```", "```java\n        for (int i=0; i<threads.length; i++) { \n          threads[i].start(); \n        }\n\n```", "```java\n        for (int i=0; i<threads.length; i++) { \n          threads[i].join(); \n        }\n\n```", "```java\n            do { \n              int counter=0; \n              Event event; \n              do { \n                event=queue.poll(); \n                if (event!=null) counter++; \n              } while (event!=null); \n              System.out.printf(\"At %s you have read %d events\\n\",\n                                new Date(), counter); \n              TimeUnit.MILLISECONDS.sleep(500); \n            } while (queue.size()>0); \n          } \n        }\n\n```", "```java\n        public class Contact {\n\n```", "```java\n        private final String name; \n        private final String phone;\n\n```", "```java\n        public Contact(String name, String phone) { \n          this.name=name; \n          this.phone=phone; \n        }\n\n```", "```java\n        public String getName() { \n          return name; \n        } \n\n        public String getPhone() { \n          return phone; \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final ConcurrentSkipListMap<String, Contact> map;\n\n```", "```java\n        private final String id;\n\n```", "```java\n        public Task (ConcurrentSkipListMap<String, Contact> map,String id){ \n          this.id=id; \n          this.map=map; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<1000; i++) { \n            Contact contact=new Contact(id, String.valueOf(i+1000)); \n            map.put(id+contact.getPhone(), contact); \n          }     \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        ConcurrentSkipListMap<String, Contact> map = new\n                                          ConcurrentSkipListMap<>();\n\n```", "```java\n        Thread threads[]=new Thread[26]; \n        int counter=0;\n\n```", "```java\n        for (char i='A'; i<='Z'; i++) { \n          Task task=new Task(map, String.valueOf(i)); \n          threads[counter]=new Thread(task); \n          threads[counter].start(); \n          counter++; \n        }\n\n```", "```java\n        for (Thread thread : threads){ \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        System.out.printf(\"Main: Size of the map: %d\\n\",map.size()); \n\n        Map.Entry<String, Contact> element; \n        Contact contact; \n\n        element=map.firstEntry(); \n        contact=element.getValue(); \n        System.out.printf(\"Main: First Entry: %s: %s\\n\", contact.getName(), \n                          contact.getPhone());\n\n```", "```java\n        element=map.lastEntry(); \n        contact=element.getValue(); \n        System.out.printf(\"Main: Last Entry: %s: %s\\n\", contact.getName(),\n                          contact.getPhone());\n\n```", "```java\n          System.out.printf(\"Main: Submap from A1996 to B1002: \\n\"); \n          ConcurrentNavigableMap<String, Contact> submap=map\n                                               .subMap(\"A1996\",\"B1002\"); \n          do { \n            element=submap.pollFirstEntry(); \n            if (element!=null) { \n              contact=element.getValue(); \n              System.out.printf(\"%s: %s\\n\", contact.getName(),\n                                contact.getPhone()); \n            } \n          } while (element!=null); \n        }\n\n```", "```java\n        public class HashFiller implements Runnable {\n\n```", "```java\n        private ConcurrentHashMap<String, ConcurrentLinkedDeque<Operation>>\n                userHash; \n\n        public HashFiller(ConcurrentHashMap<String, ConcurrentLinkedDeque\n                          <Operation>> userHash) { \n          this.userHash = userHash; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n\n          Random randomGenerator = new Random(); \n          for (int i = 0; i < 100; i++) { \n            Operation operation = new Operation(); \n            String user = \"USER\" + randomGenerator.nextInt(100); \n            operation.setUser(user); \n            String action = \"OP\" + randomGenerator.nextInt(10); \n            operation.setOperation(action); \n            operation.setTime(new Date()); \n\n            addOperationToHash(userHash, operation); \n          } \n        }\n\n```", "```java\n        private void addOperationToHash(ConcurrentHashMap<String,\n                                        ConcurrentLinkedDeque<Operation>>\n                                        userHash, Operation operation) { \n\n          ConcurrentLinkedDeque<Operation> opList = userHash\n                                   .computeIfAbsent(operation.getUser(),\n                                   user -> new ConcurrentLinkedDeque<>()); \n\n          opList.add(operation); \n        }\n\n```", "```java\n        ConcurrentHashMap<String, ConcurrentLinkedDeque<Operation>>\n          userHash = new ConcurrentHashMap<>(); \n        HashFiller hashFiller = new HashFiller(userHash);\n\n```", "```java\n        Thread[] threads = new Thread[10]; \n        for (int i = 0; i < 10; i++) { \n          threads[i] = new Thread(hashFiller); \n          threads[i].start(); \n        } \n\n        for (int i = 0; i < 10; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        System.out.printf(\"Size: %d\\n\", userHash.size()); \n\n        userHash.forEach(10, (user, list) -> { \n          System.out.printf(\"%s: %s: %d\\n\", Thread.currentThread()\n                            .getName(), user, list.size()); \n        });\n\n```", "```java\n        userHash.forEachEntry(10, entry -> { \n          System.out.printf(\"%s: %s: %d\\n\", Thread.currentThread()\n                            .getName(), entry.getKey(), \n          entry.getValue().size()); \n        });\n\n```", "```java\n        Operation op = userHash.search(10, (user, list) -> { \n          for (Operation operation : list) { \n            if (operation.getOperation().endsWith(\"1\")) { \n              return operation; \n            } \n          } \n          return null; \n        }); \n\n        System.out.printf(\"The operation we have found is: %s, %s, %s,\\n\",\n                          op.getUser(), op.getOperation(), op.getTime());\n\n```", "```java\n        ConcurrentLinkedDeque<Operation> operations = userHash.search(10,\n                                                          (user, list) -> { \n          if (list.size() > 10) { \n            return list; \n          } \n          return null; \n        }); \n\n        System.out.printf(\"The user we have found is: %s: %d operations\\n\",\n                          operations.getFirst().getUser(),\n                          operations.size());\n\n```", "```java\n            int totalSize = userHash.reduce(10, (user, list) -> { \n              return list.size(); \n            }, (n1, n2) -> { \n              return n1 + n2; \n            }); \n\n            System.out.printf(\"The total size is: %d\\n\", totalSize); \n          } \n        }\n\n```", "```java\n        public class Account {\n\n```", "```java\n        private final AtomicLong balance; \n        private final LongAdder operations; \n        private final DoubleAccumulator commission;\n\n```", "```java\n        public Account() { \n          balance = new AtomicLong(); \n          operations = new LongAdder(); \n          commission = new DoubleAccumulator((x,y)-> x+y*0.2, 0); \n        }\n\n```", "```java\n        public long getBalance() { \n          return balance.get(); \n        } \n        public long getOperations() { \n          return operations.longValue(); \n        } \n        public double getCommission() { \n          return commission.get(); \n        }\n\n```", "```java\n        public void setBalance(long balance) { \n          this.balance.set(balance); \n          operations.reset(); \n          commission.reset(); \n        }\n\n```", "```java\n        public void addAmount(long amount) { \n          this.balance.getAndAdd(amount); \n          this.operations.increment(); \n          this.commission.accumulate(amount);\n        }\n\n```", "```java\n        public void subtractAmount(long amount) { \n          this.balance.getAndAdd(-amount); \n          this.operations.increment(); \n          this.commission.accumulate(amount);\n        }\n\n```", "```java\n        public class Company implements Runnable {\n\n```", "```java\n        private final Account account;\n\n```", "```java\n        public Company(Account account) { \n          this.account=account; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<10; i++){ \n            account.addAmount(1000); \n          } \n        }\n\n```", "```java\n        public class Bank implements Runnable {\n\n```", "```java\n        private final Account account;\n\n```", "```java\n        public Bank(Account account) { \n          this.account=account; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<10; i++){ \n            account.subtractAmount(1000); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        Account  account=new Account(); \n        account.setBalance(1000);\n\n```", "```java\n        Company company=new Company(account);\n        Thread companyThread=new Thread(company);\n\n```", "```java\n        Bank bank=new Bank(account);\n        Thread bankThread=new Thread(bank);\n\n```", "```java\n        System.out.printf(\"Account : Initial Balance: %d\\n\",\n                          account.getBalance());\n\n```", "```java\n        companyThread.start(); \n        bankThread.start();\n\n```", "```java\n        try { \n          companyThread.join(); \n          bankThread.join(); \n          System.out.printf(\"Account : Final Balance: %d\\n\",\n                            account.getBalance()); \n          System.out.printf(\"Account : Number of Operations: %d\\n\",\n                            account.getOperations().intValue()); \n          System.out.printf(\"Account : Accumulated commisions: %f\\n\",\n                            account.getCommission().doubleValue()); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        public class Incrementer implements Runnable {\n\n```", "```java\n        private final AtomicIntegerArray vector;\n\n```", "```java\n        public Incrementer(AtomicIntegerArray vector) { \n          this.vector=vector; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<vector.length(); i++){ \n            vector.getAndIncrement(i); \n          } \n        }\n\n```", "```java\n        public class Decrementer implements Runnable {\n\n```", "```java\n        private AtomicIntegerArray vector;\n\n```", "```java\n        public Decrementer(AtomicIntegerArray vector) { \n          this.vector=vector; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<vector.length(); i++) { \n            vector.getAndDecrement(i); \n          }   \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        final int THREADS=100; \n        AtomicIntegerArray vector=new AtomicIntegerArray(1000);\n\n```", "```java\n        Incrementer incrementer=new Incrementer(vector);\n\n```", "```java\n        Decrementer decrementer=new Decrementer(vector);\n\n```", "```java\n        Thread threadIncrementer[]=new Thread[THREADS]; \n        Thread threadDecrementer[]=new Thread[THREADS];\n\n```", "```java\n        for (int i=0; i<THREADS; i++) { \n          threadIncrementer[i]=new Thread(incrementer); \n          threadDecrementer[i]=new Thread(decrementer); \n\n          threadIncrementer[i].start(); \n          threadDecrementer[i].start(); \n        }\n\n```", "```java\n        for (int i=0; i<100; i++) { \n          try { \n            threadIncrementer[i].join(); \n            threadDecrementer[i].join();\n\n```", "```java\n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        int errors=0;  \n        for (int i=0; i<vector.length(); i++) { \n          if (vector.get(i)!=0) { \n            System.out.println(\"Vector[\"+i+\"] : \"+vector.get(i)); \n            errors++; \n          } \n        } \n        if (errors==0) { \n          System.out.printf(\"No errors found\\n\"); \n        }\n\n```", "```java\n        System.out.println(\"Main: End of the example\");\n\n```", "```java\n        public class Flag { \n          public boolean flag=true; \n        }\n\n```", "```java\n        public class VolatileFlag { \n          public volatile boolean flag=true; \n        }\n\n```", "```java\n        public class Task implements Runnable { \n          private Flag flag; \n          public Task(Flag flag) { \n            this.flag = flag; \n          }\n\n```", "```java\n        @Override \n        public void run() { \n          int i = 0; \n\n```", "```java\n          while (flag.flag) { \n            i++; \n          } \n          System.out.printf(\"VolatileTask: Stopped %d - %s\\n\", i,\n                            new Date()); \n        }\n\n```", "```java\n        public class VolatileTask implements Runnable { \n\n          private VolatileFlag flag; \n          public VolatileTask(VolatileFlag flag) { \n            this.flag = flag; \n          }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) { \n            VolatileFlag volatileFlag=new VolatileFlag(); \n            Flag flag=new Flag(); \n\n            VolatileTask vt=new VolatileTask(volatileFlag); \n            Task t=new Task(flag);\n\n```", "```java\n        Thread thread=new Thread(vt); \n        thread.start(); \n        thread=new Thread(t); \n        thread.start(); \n\n        try { \n          TimeUnit.SECONDS.sleep(1); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        System.out.printf(\"Main: Going to stop volatile task: %s\\n\",\n                          new Date()); \n        volatileFlag.flag=false; \n        System.out.printf(\"Main: Volatile task stoped: %s\\n\", new Date()); \n\n        try { \n          TimeUnit.SECONDS.sleep(1); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        System.out.printf(\"Main: Going to stop task: %s\\n\", new Date()); \n        flag.flag=false; \n        System.out.printf(\"Main: Volatile stop flag changed: %s\\n\",\n                          new Date()); \n\n        try { \n          TimeUnit.SECONDS.sleep(1); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        public class Account { \n          public double amount; \n          public double unsafeAmount; \n\n          public Account() { \n            this.amount=0; \n            this.unsafeAmount=0; \n          } \n        }\n\n```", "```java\n        public class Decrementer implements Runnable { \n\n          private Account account; \n          public Decrementer(Account account) { \n            this.account = account; \n          }\n\n```", "```java\n        @Override \n        public void run() { \n          VarHandle handler; \n          try { \n            handler = MethodHandles.lookup().in(Account.class)\n                        .findVarHandle(Account.class, \"amount\",\n                        double.class); \n            for (int i = 0; i < 10000; i++) { \n              handler.getAndAdd(account, -100); \n              account.unsafeAmount -= 100; \n            } \n          } catch (NoSuchFieldException | IllegalAccessException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) { \n            Account account = new Account();\n\n```", "```java\n        Thread threadIncrementer = new Thread(new Incrementer(account)); \n        Thread threadDecrementer = new Thread(new Decrementer(account)); \n\n        threadIncrementer.start(); \n        threadDecrementer.start(); \n\n        try { \n          threadIncrementer.join(); \n          threadDecrementer.join(); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n            System.out.printf(\"Safe amount: %f\\n\", account.amount); \n            System.out.printf(\"Unsafe amount: %f\\n\", account.unsafeAmount); \n\n          } \n        }\n\n```"]