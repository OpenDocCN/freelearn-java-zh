- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exposing MongoDB Data as a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to analyze and design solutions for
    various data ingestion and storage problems. We also learned how to analyze and
    classify those problems. After that, we learned how to apply scalable design principles
    and optimally choose technologies to implement those solutions. Finally, we learned
    how to develop, deploy, execute, and verify those solutions. However, in a real-world
    scenario, it is not always a good idea to expose the whole database to downstream
    systems. If we plan to do so, we must ensure that proper authorization and access
    rules are implemented on the database (please refer to the *Publishing problems*
    section of [*Chapter 1*](B17084_01.xhtml#_idTextAnchor014), *Basics of Modern
    Data Architecture*, for various ways of publishing data). One of the ways to give
    selective and authorized access to data is by publishing via **Data as a Service**
    (**DaaS**).
  prefs: []
  type: TYPE_NORMAL
- en: DaaS enables data to be published by a platform and language-independent web
    service such as SOAP, REST, or GraphQL. In this chapter, we will analyze and implement
    a DaaS solution using the REST API to publish the previously ingested and sorted
    data from a MongoDB database. Here, we will learn how to design, develop, and
    unit test a REST application for publishing data. We will also learn how to deploy
    our application in Docker. In addition to this, we will briefly learn how to use
    API management tools and how they can be of help. Although Apigee is the most
    popular API management tool, we will be using AWS API Gateway as we are deploying
    and running our application on an AWS cluster. By the end of this chapter, you
    will know what DaaS is and when it should be used. You will also know how to design
    and develop a DaaS API, as well as how to enable security and monitor/control
    traffic on a DaaS API using API management tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing DaaS – what and why
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a DaaS to expose data using Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling API management over the DaaS API using AWS API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prior knowledge of Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 1.11 installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven, Docker, and Postman installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS CLI installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ Idea Community or Ultimate Edition installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing DaaS – what and why
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction, we briefly discussed and established that DaaS is useful
    for publishing already-ingested and analyzed data securely.
  prefs: []
  type: TYPE_NORMAL
- en: 'But *what* is DaaS? It is a data management strategy that enables data as a
    business asset, which makes valuable and business-critical data accessible on
    demand to various internal and external systems. **Software-as-a-Service** (**SaaS**)
    started becoming popular in the late 90s when software was provided to consumers
    on demand. Similarly, DaaS enables access to data on demand. With the help of
    **service-oriented architectures** (**SOAs**) and APIs, it enables secure platform-independent
    data access. The following diagram provides an overview of a DaaS stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – DaaS stack overview ](img/B17084_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – DaaS stack overview
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, data from different kinds of data stores, such as data warehouses,
    data lakes, or online databases, can be unified by a virtual data layer that can
    be used to build the services or API layer. The API management layer is present
    between the users of the data and the API layer. The API management layer is responsible
    for registering, securing, documenting, and orchestrating the underlying Service
    APIs. All consumer applications interact with the API management layer to consume
    the data from the Service APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a DaaS is, let’s figure out *why* it’s important.
  prefs: []
  type: TYPE_NORMAL
- en: Data is the new gold. Every organization collects huge volumes of data, but
    a successful organization knows how to optimally use that data to drive its profits.
    Data collection and storage are done using different mediums across the organization.
    But to fully utilize the potential of that data, teams across the organization
    should be able to access it easily and securely. Data in silos, maintained by
    a team, may have the opportunity to derive value across the organization.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, exposing a database to teams across the organization may
    be a governance or security headache. This is where DaaS plays a vital role. By
    exposing valuable and business-critical data using APIs, DaaS enables teams to
    share data with internal teams while implementing the necessary access and security
    checks on the dataset. This helps teams easily register and subscribe to data
    on demand instead of having to go through the unnecessary and cumbersome effort
    of analyzing, ingesting, and maintaining a dataset that is already ingested and
    maintained by some other team in the organization. This enables fast-paced development
    and cost saving in developing and maintaining redundant datasets across the organization.
    In addition to this, DaaS has enabled a lot of businesses to selectively provide
    data on demand to the external world for profit or usability.
  prefs: []
  type: TYPE_NORMAL
- en: According to Gartner’s hype cycle, DaaS is still a long way from reaching its
    plateau of peak productivity, which means it has the potential to be one of the
    most impactful advancements in data engineering for the next decade.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using DaaS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are a few of the major benefits of using DaaS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agility**: DaaS enables users to access data without needing a comprehensive
    understanding of where data is stored or how is it indexed. It also enables teams
    to focus on their business functionality, and not unnecessarily spend time storing
    and managing the data. This helps considerably decrease time-to-market.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy maintainability**: There are fewer maintenance headaches for the teams
    that use DaaS to get their data since they don’t have to worry about managing
    and maintaining it, nor its storage and data pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data quality**: Since data is served by APIs, data is more non-redundant,
    so taking care of data quality becomes much easier and more robust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: DaaS gives companies the flexibility to trade off between
    initial investment versus operational expenses. It helps organizations save costs
    on the initial setup to store data, as well as ongoing maintenance costs. It also
    enables teams to get data on demand, which means that teams don’t need to have
    a long-term commitment to that service. This enables teams to start using the
    data provided by DaaS in a much quicker fashion. On the other hand, if, after
    a while, there is no need for that data or the user wants to move to a newer technology
    stack, the migration becomes much faster and hassle-free. DaaS also enables easy
    integration in on-premises environments or the cloud for its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood the concept and benefits of publishing data using
    a DaaS, in the next section, we will learn how to implement a DaaS solution using
    the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DaaS to expose data using Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to expose a REST-based DaaS API using Java
    and Spring Boot. But before we try to create the solution, we must understand
    the problem that we are going to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**REST** stands for **Representational State Transfer**. It is not a protocol
    or standard; instead, it provides certain architectural constraints to expose
    the data layer. The REST API allows you to transfer the representational state
    of a data resource to the REST endpoint. These representations can be in JSON,
    XML, HTML, XLT, or plain text format so that they can be transferred over the
    HTTP/(S) protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the solution described in [*Chapter 6*](B17084_06.xhtml#_idTextAnchor092),
    *Architecting a Real-Time Processing Pipeline*, we analyzed and ingested analytical
    data in a MongoDB-based collection. Now, we want to expose the documents present
    in the collection using a DaaS service that can be searched for by either `ApplicationId`
    or `CustomerId`. In the next section, we will analyze and design the solution
    and then implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing and designing a solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s analyze the requirement to solve the given problem. First, we will note
    down all the facts and information available. The following are the facts we know:'
  prefs: []
  type: TYPE_NORMAL
- en: The data to be published is stored in a MongoDB collection hosted in the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to publish the DaaS with security and API management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to create endpoints so that the data can be fetched by either `ApplicationId`
    or `CustomerId`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DaaS that’s been built for this data should be platform or language-independent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on these facts, we can conclude that we don’t necessarily need a virtual
    data layer. However, we need the application to publish two endpoints – one exposing
    data based on `ApplicationId` and the other exposing data based on `CustomerId`.
    Also, since the MongoDB instance is in the cloud, and most of the frontend applications
    using this DaaS are in the cloud, it makes sense to deploy this application in
    an EC2 or **Elastic Container Repository** (**ECR**) instance. However, since
    we have no information about the traffic that will use this DaaS, it makes more
    sense to containerize the application so that, in the future, we can easily scale
    out the application by adding more containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the proposed solution architecture for our problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Proposed solution architecture of DaaS ](img/B17084_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Proposed solution architecture of DaaS
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we use our REST application to read data from MongoDB and fetch
    the results for the REST endpoint. We use Spring Boot as the technology stack
    to build the REST API as it is modular, flexible, extendible, and provides an
    amazing range of I/O integrations and community support. We will create Docker
    containers for this application and deploy them in the AWS Elastic Container Service
    cluster using the AWS Fargate service. This gives us the flexibility to scale
    up or down quickly when traffic increases in the future. Finally, we apply the
    API management layer on top of the deployed application. There are many API management
    tools available on the market, including Google’s APIJEE, Microsoft’s Azure API
    Management, AWS API Gateway, and IBM’s API Connect. However, since our stack is
    deployed on AWS, we will be using the native API management tool of AWS: AWS API
    Gateway.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have discussed the overall architecture of the solution, let’s
    learn more about the design of the Spring Boot application. The following diagram
    depicts the low-level design of the Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Low-level design of the Spring Boot REST application ](img/B17084_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Low-level design of the Spring Boot REST application
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Spring application has a controller class called `DaaSController` that
    exposes two `GET` endpoints, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /rdaas/application/{applicationId}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /rdaas/customer/{id}/application`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first REST endpoint returns the application document based on `applicationId`,
    while the second REST endpoint returns all the applications of a given customer
    using `customerId` as the search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The `MongoConfig` class is used to configure and initialize `mongoTemplate`
    and `MongoRepository`. We create a custom `MongoRepository` called `ApplicationRepository`
    that uses `QueryDSL` to dynamically generate custom MongoDB queries at runtime.
    The controller class uses the `ApplicationRepository` class to connect to MongoDB
    and fetch document(s) from the collection as per the request.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have analyzed the problem and created a solution design. Now,
    let’s discuss how we can implement this solution. First, we will develop the Spring
    Boot REST application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Spring Boot REST application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to build the Spring Boot application to implement
    the solution we designed in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create a Maven project using our IDE and add the following Spring
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These dependencies ensure that all the Spring Boot basic dependencies, as well
    as the REST-based dependencies, are fulfilled. However, we must add dependencies
    related to MongoDB. The following dependencies are related to Spring’s MongoDB
    integration, as well as the necessary QueryDSL dependencies, to write custom MongoDB
    queries via the Spring JPA implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from these dependencies, we need to add build plugins to the `pom.xml`
    file. These plugins help generate Q classes dynamically, which are required for
    QueryDSL to work properly. The following plugins need to be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added all the necessary dependencies, we will create the entry
    point, or the `main` class, of our Spring Boot application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the preceding code, all the Bean components in the `com.scalabledataarch.rest`
    package will be scanned recursively and instantiated when the Spring Boot application
    is started. Now, let’s create Mongo configuration beans using the `Configuration`
    class called `MongoConfig`. The source code for the same is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `MongoConfig` class is annotated with `@EnableMongoRepositories`,
    where the base package of the repositories is configured. All classes extending
    the `MongoRepository` interface under the base package will be scanned and Spring
    beans will be created. Apart from that, we have created the `MongoClient` and
    `MongoTemplate` beans. Here, we used the `com.mongodb.client.MongoClients` API
    to create the `MongoClient` bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a model class that can hold the deserialized data from
    a MongoDB document. We can create the model `Application` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is important to annotate the class with `@Document` and give the value of
    the collection name as its argument for `spring-data-mongo` to understand that
    this POJO represents a MongoDB document structure for the specified collection.
    Also, annotating with `@QueryEntity` is essential for QueryDSL to generate Q classes
    dynamically using `apt-maven-plugin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use this `Application` POJO to write our custom Mongo repository,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To implement a custom repository, it must implement or extend the `MongoRepository`
    interface. Since our `ApplicationRepository` uses QueryDSL, it must extend `QuerydslPredicateExecutor`.
    We can specify a Mongo query using the `@Query` annotation, as shown in the preceding
    code, which will be executed when the corresponding method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a controller class called `DaasController`. The `DaasController`
    class should be annotated with the `@RestController` annotation to indicate that
    it is a Spring component that publishes REST endpoints. A basepath to the endpoints
    in `DaaSController` can be created using the `@RequestMapping` annotation, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add our methods, each corresponding to a REST endpoint. The following
    code shows the source code for one of the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the method that will be triggered when a REST endpoint call is
    made is annotated with `@GetMapping` or `@PostMapping`, based on the HTTP method
    type. In our case, we need a `GET` request. Each mapping should be accompanied
    by the URL path and the other necessary properties as parameters for these annotations.
    In this method, the autowired `applicationRepository` bean is used to fetch Mongo
    documents using the `applicationId` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will create `application.yml` to set up the configuration parameters
    to run the Spring Boot application. The `application.yml` file in our case will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the source code of the `application.yml` file earlier, we configure
    various Mongo connectivity details in the `application.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application from our local machine by running the `main`
    class and test it using Postman, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, click the `ApplicationDaaS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Creating a new Postman collection ](img/B17084_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Creating a new Postman collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a request to the collection using the **Add request** option, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Adding a request to the Postman collection ](img/B17084_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Adding a request to the Postman collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, fill in the configurations for the HTTP method, REST URL, and headers.
    Now, you can execute the request using the **Send** button, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Testing the REST API via Postman ](img/B17084_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Testing the REST API via Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have tested the application locally, let’s see how we can deploy
    it in ECR. Follow these steps to deploy in ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to containerize this application. To do that, we must create
    our Docker file. The source code for this `DockerFile` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the first line imports the base image, which contains the preconfigured
    OpenJDK 11 software. There, we create a volume called `/tmp`. Then, we add a new
    user to this Docker container called `appuser` using the `RUN useradd` command.
    Using the `USER` command, we log in as `appuser`. Then, we copy the JAR file to
    `app.jar`. The JAR file path is passed as an argument to this `DockerFile`. Passing
    the JAR file path as an argument will help us in the future if we want to build
    a `8080` is exposed from the container. Finally, we run the `java -jar` command
    using the `ENTRYPOINT` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can build the Docker image by running the following command from a
    command line or Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create a Docker image called `apprestdaas` with a tag of `v1.0` in
    the local Docker image repository. You can either view the image listed in Docker
    Desktop or a Terminal by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have created the Docker image, let’s discuss how can we deploy this
    image in an ECS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application in an ECS cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will discuss how to deploy our REST application in an AWS
    ECS cluster. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a repository in AWS ECR to store our Docker image.
    We will require the **Amazon Resource Name** (**ARN**) for this repository to
    tag and upload the image. First, we will navigate to ECR in the AWS Management
    Console and click **Create repository**. You’ll see a **Create repository** page,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The Create repository page ](img/B17084_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The Create repository page
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, fill in the repository’s name, leave the rest of the fields as-is, and
    submit the request. Once it has been created, you will be able to see the repository
    listed on ECR’s **Private repositories** page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The ECR repository has been created  ](img/B17084_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The ECR repository has been created
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the latest AWS CLI and install it. Then, configure the AWS CLI using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While configuring the AWS CLI, you need to provide the access key ID and the
    secret access key. You can generate these variables by following the instructions
    at [https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to generate an ECR login token for Docker using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you run this command, an authentication token will be generated that is
    needed by Docker to push the image to ECR. We can pipe the previous command with
    the following command, where we directly pass the token to a `docker login` command.
    The final command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, please replace `region` with the correct AWS region,
    such as `us-east-2` or `us-east-1`, and `accountid` with the correct AWS account
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will tag the local Docker image with the ECR repository URI. This
    is required for ECR to map the correct repository with the image we are pushing.
    The command for this is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will use the following command to push the Docker image into the ECR
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon running this command, the local Docker image will be pushed to the ECR
    repository with the `restdaas:v1` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create an AWS Fargate cluster. To do that, we must log into the
    AWS Management Console again. Here, search for `Elastic Container Services` and
    select it. From the **Elastic Container Service** dashboard, navigate to **Cluster**
    in the left pane and select **Create Cluster**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Creating an ECS cluster ](img/B17084_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Creating an ECS cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, set the cluster template to **Networking only** and click **Next step**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Selecting an ECS cluster template ](img/B17084_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Selecting an ECS cluster template
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, enter the name of the cluster. Here, we will name it `daas-cluster`.
    Leave the other fields as-is. Now, click the **Create** button to create the new
    ECS cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Naming and creating the ECS cluster ](img/B17084_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Naming and creating the ECS cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create an ECS task. From the dashboard of AWS ECS console, select
    **Task Definition** from the left menu and then click on **Create new Task Definition**,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Creating a new task definition ](img/B17084_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Creating a new task definition
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, under **Select launch type compatibility**, choose **FARGATE** and click
    **Next step**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Selecting the launch type for the ECS task ](img/B17084_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Selecting the launch type for the ECS task
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must set `restdaas`. Set **Task role** to **None** and **Operating
    system family** to **Linux**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Setting up a task definition ](img/B17084_09_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Setting up a task definition
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave **Task execution role** as-is, set **Task memory (GB)** to **1GB**, and
    set **Task CPU (vCPU)** to **0.5 vCPU**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Choosing Task memory and Task CPU (vCPU) values ](img/B17084_09_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Choosing Task memory and Task CPU (vCPU) values
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add a container to the ECS task. We can add the container by clicking
    on the `restdaas` as the container name and populate the ECR ARN of our image,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Adding a container to the ECS task ](img/B17084_09_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Adding a container to the ECS task
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Add** button to add a container. Then, click the **Create** button
    on the **Create new Task Definition** page. This will create the new task, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – ECS task created ](img/B17084_09_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – ECS task created
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the previous screenshot, the task we’ve created, **restdaas**, is
    in an **ACTIVE** state but it is not running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the task. Click on the **ACTION** dropdown button and select
    **Run Task**. This submits the task so that it can be in runnable status. On clicking
    **Run Task**, a screen will appear where we must fill out various configurations
    for running the task, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Run Task ](img/B17084_09_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Run Task
  prefs: []
  type: TYPE_NORMAL
- en: 'Set **Launch type** to **FARGATE** and **Operating system family** to **Linux**.
    Also, select any available VPC and subnet group, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Setting the VPC and security groups  ](img/B17084_09_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Setting the VPC and security groups
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, please make sure that `8080` since our
    Spring Boot application will be running on port `8080`, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Allowing port 8080  ](img/B17084_09_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Allowing port 8080
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the other fields as-is and click **Run Task**. By refreshing the **Task**
    tab, we can see that the task changes state from **PROVISIONING** to **RUNNING**.
    The following screenshot shows a **RUNNING** task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Task in the RUNNING state ](img/B17084_09_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Task in the RUNNING state
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will test the DaaS that we’ve deployed in ECS. To do that, click on
    the text under the **Task** column shown in the preceding screenshot. This takes
    us to the **Running task** screen, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Running task details ](img/B17084_09_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Running task details
  prefs: []
  type: TYPE_NORMAL
- en: 'As highlighted in the preceding screenshot, we will get the public IP. We will
    use this IP for testing purposes. Now, from Postman, we can test our REST endpoints
    using this IP address and port `8080`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Testing the REST endpoint that was deployed in AWS ECS ](img/B17084_09_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Testing the REST endpoint that was deployed in AWS ECS
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to develop a REST application to publish the
    DaaS, containerize the application, deploy it in an AWS ECS cluster, and test
    the endpoints. In the next section, we will understand the need for API management,
    and we will provide a step-by-step guide to attaching the API management layer
    to the REST endpoints that we developed and deployed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: API management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API management is a set of tools and technologies that allows us to distribute,
    analyze, and control APIs that expose data and services across the organization.
    It can act like a wrapper on top of the APIs, whether they are deployed on-premises
    or in the cloud. It is always a good idea to use API management while we are architecting
    a solution to publish data via an API. First, let’s understand what API management
    is and how it helps. The following diagram shows where and how the API management
    layer helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – How API management helps ](img/B17084_09_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – How API management helps
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, API management is a wrapper layer that sits between the customer-facing
    API and the internal service API. We can define resources and methods in the API
    management layer that get exposed to the customer. Primarily, an architecture
    gets the following benefits while using an API management layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: API management enables easy deployment in a different environment
    by enabling continuous deployment and testing. It also provides a unified interface
    where a single customer-facing API can be fetched from multiple complex internal
    service APIs. This enables easy integration and allows you to publish resources
    without the need to create extra APIs to integrate and manage multiple APIs. On
    the other hand, in a very dynamic technological landscape, chances are that internal
    service APIs may be updated or their structure may change frequently. The API
    management layer gives us easy access to move from an older internal service API
    to a new one without changing or affecting the customer-facing API. This gives
    us huge flexibility in design and helps us overcome technical debts in the internal
    service API layer without any hassle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: API management provides security in different ways. First, it
    enables APIs to have custom authorizers such as OAuth. Second, it enables customer-specific
    usage plans and API keys. This ensures only a consumer who is registered with
    a usage plan and API key will be able to access the application. Also, it puts
    a limit on how many transactions a consumer can do per second. This, along with
    the throttling feature, helps us avoid any **distributed denial-of-service** (**DDoS**)
    attacks on the Service APIs. Apart from these, role-based access can be enabled
    using the RBAC feature of the API. All these security features make API management
    a necessary component in designing a DaaS architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: This allows you to easily create, publish, and maintain
    the documentation of the API. The published documentation can be easily accessed
    by consumers of the API, making their lives easy. Apart from this, even the *Swagger*
    and *OpenAPI* specifications can be published and maintained using API management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis**: One of the major advantages of using API management is the ability
    to monitor and analyze the traffic, latency, and other parameters while the API
    is deployed and used in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we understood what API management is and how it can help us
    create a robust architecture for DaaS solutions. In the next section, we will
    attach an API management layer on top of the ECS REST Service API that we developed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling API management over the DaaS API using AWS API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss how to set up API management using AWS API
    Gateway. We will use the REST DaaS API that we developed and deployed in ECS earlier
    in this chapter. Follow these steps to set up an API management layer for our
    REST DaaS API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the AWS Management Console, search for `AWS API Gateway` and navigate to
    the **AWS API Gateway** service dashboard. From here, select **REST API** and
    click **Build**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.25 – The AWS API Gateway dashboard ](img/B17084_09_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – The AWS API Gateway dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'A new window will open, as shown in the following screenshot. Select **REST**
    as the protocol and then select **New API** under **Create new API**. Fill in
    the API’s name and a description and click **Create API**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Creating a REST API ](img/B17084_09_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Creating a REST API
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the resource has been created, we will be taken to the details of the
    API. We can add resources or methods from the **Actions** dropdown in this interface,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.27 – Adding resources to the API ](img/B17084_09_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27 – Adding resources to the API
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will click `/loanapplications`. Then, we will add another resource
    under `loanapplications` whose name is `appId` and the path is `/{appId}`. Note
    that `{}` denotes that `appId` is a path variable. Finally, in the `appId` resource,
    we will add a method by selecting **Create Method**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28 – Configuring the GET method ](img/B17084_09_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28 – Configuring the GET method
  prefs: []
  type: TYPE_NORMAL
- en: Set `/loanapplications/{appId}` API resource to the `/rdaas/application/{appId}`
    DaaS API resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the API by choosing the **Deploy API** option from the **Actions** dropdown,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Deploy API ](img/B17084_09_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29 – Deploy API
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon doing this, a window will appear, as shown in the following screenshot.
    Set **Deployment stage** to **[New Stage]** and fill in the stage’s name and description.
    Finally, click **Deploy**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.30 – Deploying the API configuration ](img/B17084_09_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.30 – Deploying the API configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will test the new customer-facing API via Postman. But before that,
    we must find out the base URL of the API. To do so, navigate to **Stages** in
    the left pane and select **dev**. The **dev Stage Editor** page will appear, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.31 – Using dev Stage Editor to get the base URL of the API ](img/B17084_09_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.31 – Using dev Stage Editor to get the base URL of the API
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in the preceding screenshot, we can get the base URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can form the customer API by adding the consumer API’s URI to the basepath;
    for example, `http://<baseurl>/loanapplications/<some_app_id>`. We can use this
    API and test it in Postman, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.32 – Testing the external API exposed by AWS API Gateway (without
    security) ](img/B17084_09_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.32 – Testing the external API exposed by AWS API Gateway (without security)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the dashboard to monitor the API, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.33 – AWS API Gateway dashboard for RESTDaasAPI ](img/B17084_09_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.33 – AWS API Gateway dashboard for RESTDaasAPI
  prefs: []
  type: TYPE_NORMAL
- en: From this dashboard, we can gather useful information about the number of API
    calls made every day. We can also monitor the latency of the response or any internal
    server errors that have been noticed over time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added the API management layer, we will try to add API key-based
    security to the consumer-facing API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Resource** pane of **RestDaasAPI** and select the **GET**
    method under the **{appId}** resource. In the configuration, change the value
    of the required API key from **false** to **true**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.34 – Changing the API key’s required value to true ](img/B17084_09_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.34 – Changing the API key’s required value to true
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, navigate to **Usage Plans** and create a usage plan. Set the API-level
    throttling parameters and monthly quota, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.35 – Create Usage Plan ](img/B17084_09_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.35 – Create Usage Plan
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Next** and set the method-level throttling parameters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.36 – Configuring the method-level throttling parameters ](img/B17084_09_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.36 – Configuring the method-level throttling parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Next** and set up a new API key for this usage plan by clicking the
    **Create API Key and add to Usage Plan** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.37 – Generating a new API key to attach to the usage plan ](img/B17084_09_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.37 – Generating a new API key to attach to the usage plan
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have clicked this, the **API Key** window will appear. Provide a name
    and description. Also, set **API key*** to **Auto Generate**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.38 – The API Key window ](img/B17084_09_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.38 – The API Key window
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have saved the newly generated API key and created the usage plan,
    we can get the API key’s value by navigating to **API Keys** and clicking on the
    **Show** option. By doing so, we can view the generated API key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.39 – Showing the generated API key by clicking Show (highlighted)
    ](img/B17084_09_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.39 – Showing the generated API key by clicking Show (highlighted)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have set up the API key as required in the API, and if you do not
    provide `apikey` in the header while invoking the REST endpoint, you will get
    an error message in the response body, similar to `{"message":"Forbidden"}`. Now,
    you must add a header called `x-api-key` whose value should be the API key that
    you generated in *Step 9*. Then, you can test the secure API via Postman, along
    with the API key, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.40 – Testing the external API exposed by AWS API Gateway (with Security)
    ](img/B17084_09_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.40 – Testing the external API exposed by AWS API Gateway (with Security)
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create an API management layer on top of
    our REST DaaS API. We also discussed how AWS API Gateway can help to monitor and
    secure the API.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s summarize what we’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basics of DaaS. First, we discussed how
    to develop and test REST-based DaaS APIs using Spring Boot. Then, we learned how
    to containerize the application and publish the containers to the AWS ECR repository.
    We also learned how to deploy the containers published in the AWS ECR repository
    to an AWS ECS cluster. After that, we learned how to run this application using
    the cloud-managed Fargate service. Then, we learned about API management and its
    benefits. Finally, we implemented an API management layer to provide security
    and monitoring on top of our REST DaaS API using AWS API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to build, deploy, publish, and manage a REST-based
    DaaS API, in the next chapter, we will learn how and when a GraphQL-based DaaS
    can be a good design choice. We will also learn how to design and develop a GraphQL
    DaaS API.
  prefs: []
  type: TYPE_NORMAL
