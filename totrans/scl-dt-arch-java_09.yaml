- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Exposing MongoDB Data as a Service
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将MongoDB数据作为服务暴露
- en: In the previous chapters, we learned how to analyze and design solutions for
    various data ingestion and storage problems. We also learned how to analyze and
    classify those problems. After that, we learned how to apply scalable design principles
    and optimally choose technologies to implement those solutions. Finally, we learned
    how to develop, deploy, execute, and verify those solutions. However, in a real-world
    scenario, it is not always a good idea to expose the whole database to downstream
    systems. If we plan to do so, we must ensure that proper authorization and access
    rules are implemented on the database (please refer to the *Publishing problems*
    section of [*Chapter 1*](B17084_01.xhtml#_idTextAnchor014), *Basics of Modern
    Data Architecture*, for various ways of publishing data). One of the ways to give
    selective and authorized access to data is by publishing via **Data as a Service**
    (**DaaS**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何分析和设计针对各种数据导入和存储问题的解决方案。我们还学习了如何分析和分类这些问题。之后，我们学习了如何应用可扩展的设计原则，并选择最佳技术来实现这些解决方案。最后，我们学习了如何开发、部署、执行和验证这些解决方案。然而，在现实世界的场景中，将整个数据库暴露给下游系统并不总是好主意。如果我们计划这样做，我们必须确保数据库上实施了适当的授权和访问规则（请参阅[*第1章*](B17084_01.xhtml#_idTextAnchor014)，*现代数据架构基础*中的*发布问题*部分，了解各种发布数据的方式）。提供选择性授权访问数据的一种方法是通过**数据即服务**（**DaaS**）进行发布。
- en: DaaS enables data to be published by a platform and language-independent web
    service such as SOAP, REST, or GraphQL. In this chapter, we will analyze and implement
    a DaaS solution using the REST API to publish the previously ingested and sorted
    data from a MongoDB database. Here, we will learn how to design, develop, and
    unit test a REST application for publishing data. We will also learn how to deploy
    our application in Docker. In addition to this, we will briefly learn how to use
    API management tools and how they can be of help. Although Apigee is the most
    popular API management tool, we will be using AWS API Gateway as we are deploying
    and running our application on an AWS cluster. By the end of this chapter, you
    will know what DaaS is and when it should be used. You will also know how to design
    and develop a DaaS API, as well as how to enable security and monitor/control
    traffic on a DaaS API using API management tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: DaaS使数据可以通过一个平台和语言无关的Web服务（如SOAP、REST或GraphQL）进行发布。在本章中，我们将分析和实现一个使用REST API发布从MongoDB数据库中已导入和排序数据的DaaS解决方案。在这里，我们将学习如何设计、开发和单元测试用于发布数据的REST应用程序。我们还将学习如何将我们的应用程序部署到Docker中。此外，我们将简要了解如何使用API管理工具，以及它们如何提供帮助。尽管Apigee是最受欢迎的API管理工具，但我们将使用AWS
    API Gateway，因为我们将在AWS集群上部署和运行我们的应用程序。到本章结束时，您将了解DaaS是什么以及何时应该使用它。您还将了解如何设计和开发DaaS
    API，以及如何使用API管理工具启用DaaS API的安全性并监控/控制流量。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing DaaS – what and why
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍DaaS – 什么和为什么
- en: Creating a DaaS to expose data using Spring Boot
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建一个DaaS以暴露数据
- en: API management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API管理
- en: Enabling API management over the DaaS API using AWS API Gateway
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS API Gateway在DaaS API上启用API管理
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要以下内容：
- en: Prior knowledge of Java
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备Java的先验知识
- en: OpenJDK 1.11 installed on your local system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地系统上安装了OpenJDK 1.11
- en: Maven, Docker, and Postman installed on your local system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地系统上安装了Maven、Docker和Postman
- en: An AWS account
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS账户
- en: The AWS CLI installed on your local system
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地系统上安装了AWS CLI
- en: IntelliJ Idea Community or Ultimate Edition installed on your local system
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地系统上安装了IntelliJ Idea Community或Ultimate Edition
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09).
- en: Introducing DaaS – what and why
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍DaaS – 什么和为什么
- en: In the introduction, we briefly discussed and established that DaaS is useful
    for publishing already-ingested and analyzed data securely.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们简要讨论并确定DaaS对于安全发布已导入和分析了的数据是有用的。
- en: 'But *what* is DaaS? It is a data management strategy that enables data as a
    business asset, which makes valuable and business-critical data accessible on
    demand to various internal and external systems. **Software-as-a-Service** (**SaaS**)
    started becoming popular in the late 90s when software was provided to consumers
    on demand. Similarly, DaaS enables access to data on demand. With the help of
    **service-oriented architectures** (**SOAs**) and APIs, it enables secure platform-independent
    data access. The following diagram provides an overview of a DaaS stack:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但*什么是* DaaS？它是一种数据管理策略，使数据成为业务资产，这使得有价值和业务关键数据能够按需提供给各种内部和外部系统。**软件即服务**（**SaaS**）在90年代末开始流行，当时软件是按需提供给消费者的。同样，DaaS使数据按需访问成为可能。借助**面向服务的架构**（**SOAs**）和API，它实现了安全且平台无关的数据访问。以下图表提供了一个DaaS堆栈的概述：
- en: '![Figure 9.1 – DaaS stack overview ](img/B17084_09_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – DaaS堆栈概述](img/B17084_09_001.jpg)'
- en: Figure 9.1 – DaaS stack overview
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – DaaS堆栈概述
- en: As we can see, data from different kinds of data stores, such as data warehouses,
    data lakes, or online databases, can be unified by a virtual data layer that can
    be used to build the services or API layer. The API management layer is present
    between the users of the data and the API layer. The API management layer is responsible
    for registering, securing, documenting, and orchestrating the underlying Service
    APIs. All consumer applications interact with the API management layer to consume
    the data from the Service APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，来自不同类型的数据存储，如数据仓库、数据湖或在线数据库的数据可以通过虚拟数据层进行统一，该层可用于构建服务或API层。API管理层位于数据用户和API层之间。API管理层负责注册、保护、记录和编排底层服务API。所有消费者应用程序都与API管理层交互，以从服务API中消费数据。
- en: Now that we know what a DaaS is, let’s figure out *why* it’s important.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了什么是DaaS，让我们来探讨一下*为什么*它很重要。
- en: Data is the new gold. Every organization collects huge volumes of data, but
    a successful organization knows how to optimally use that data to drive its profits.
    Data collection and storage are done using different mediums across the organization.
    But to fully utilize the potential of that data, teams across the organization
    should be able to access it easily and securely. Data in silos, maintained by
    a team, may have the opportunity to derive value across the organization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是新的黄金。每个组织都收集了大量的数据，但成功的组织知道如何最优地使用这些数据来推动其利润。数据收集和存储在组织内使用不同的介质进行。但为了充分利用这些数据的潜力，组织内的团队应该能够轻松且安全地访问它们。由团队维护的孤岛数据可能在整个组织中产生价值。
- en: On the other hand, exposing a database to teams across the organization may
    be a governance or security headache. This is where DaaS plays a vital role. By
    exposing valuable and business-critical data using APIs, DaaS enables teams to
    share data with internal teams while implementing the necessary access and security
    checks on the dataset. This helps teams easily register and subscribe to data
    on demand instead of having to go through the unnecessary and cumbersome effort
    of analyzing, ingesting, and maintaining a dataset that is already ingested and
    maintained by some other team in the organization. This enables fast-paced development
    and cost saving in developing and maintaining redundant datasets across the organization.
    In addition to this, DaaS has enabled a lot of businesses to selectively provide
    data on demand to the external world for profit or usability.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，将数据库暴露给组织内的各个团队可能会成为治理或安全上的头疼问题。这正是DaaS发挥关键作用的地方。通过使用API公开有价值和业务关键数据，DaaS使团队能够在数据集上实施必要的访问和安全检查的同时与内部团队共享数据。这有助于团队轻松注册和订阅所需的数据，而不是不得不进行不必要的繁琐工作，如分析、摄取和维护由组织中的其他团队已经摄取和维护的数据集。这有助于组织内快速开发和节省在开发和维护冗余数据集上的成本。此外，DaaS还使许多企业能够有选择地向外部世界提供数据以获取利润或实用性。
- en: According to Gartner’s hype cycle, DaaS is still a long way from reaching its
    plateau of peak productivity, which means it has the potential to be one of the
    most impactful advancements in data engineering for the next decade.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Gartner的炒作周期，DaaS距离达到其生产力的顶峰还有很长的路要走，这意味着它有潜力成为未来十年数据工程中最具影响力的进步之一。
- en: Benefits of using DaaS
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DaaS的好处
- en: 'The following are a few of the major benefits of using DaaS:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用DaaS的一些主要好处：
- en: '**Agility**: DaaS enables users to access data without needing a comprehensive
    understanding of where data is stored or how is it indexed. It also enables teams
    to focus on their business functionality, and not unnecessarily spend time storing
    and managing the data. This helps considerably decrease time-to-market.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏捷性**：DaaS使用户能够访问数据，而无需全面了解数据存储的位置或其索引方式。它还使团队能够专注于其业务功能，而不必不必要地花费时间存储和管理数据。这有助于显著缩短上市时间。'
- en: '**Easy maintainability**: There are fewer maintenance headaches for the teams
    that use DaaS to get their data since they don’t have to worry about managing
    and maintaining it, nor its storage and data pipelines.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护**：使用DaaS获取数据的团队在维护方面遇到的麻烦较少，因为他们不必担心管理和维护它，也不必担心其存储和数据管道。'
- en: '**Data quality**: Since data is served by APIs, data is more non-redundant,
    so taking care of data quality becomes much easier and more robust.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据质量**：由于数据是通过API提供的，数据更加非冗余，因此关注数据质量变得更加容易和稳健。'
- en: '**Flexibility**: DaaS gives companies the flexibility to trade off between
    initial investment versus operational expenses. It helps organizations save costs
    on the initial setup to store data, as well as ongoing maintenance costs. It also
    enables teams to get data on demand, which means that teams don’t need to have
    a long-term commitment to that service. This enables teams to start using the
    data provided by DaaS in a much quicker fashion. On the other hand, if, after
    a while, there is no need for that data or the user wants to move to a newer technology
    stack, the migration becomes much faster and hassle-free. DaaS also enables easy
    integration in on-premises environments or the cloud for its users.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：DaaS为公司提供了在初始投资与运营成本之间进行权衡的灵活性。它有助于组织在存储数据的初始设置以及持续维护成本上节省成本。它还使团队能够按需获取数据，这意味着团队不需要对这项服务做出长期承诺。这使得团队能够更快地开始使用DaaS提供的数据。另一方面，如果在一段时间后不再需要这些数据或用户希望迁移到更新的技术堆栈，迁移过程将变得更快、更无烦恼。DaaS还使用户能够轻松地在本地环境或云端进行集成。'
- en: Now that we have understood the concept and benefits of publishing data using
    a DaaS, in the next section, we will learn how to implement a DaaS solution using
    the REST API.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用DaaS发布数据的概念和好处，在下一节中，我们将学习如何使用REST API实现DaaS解决方案。
- en: Creating a DaaS to expose data using Spring Boot
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建DaaS以公开数据
- en: In this section, we will learn how to expose a REST-based DaaS API using Java
    and Spring Boot. But before we try to create the solution, we must understand
    the problem that we are going to solve.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Java和Spring Boot公开基于REST的DaaS API。但在我们尝试创建解决方案之前，我们必须了解我们将要解决的问题。
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**REST** stands for **Representational State Transfer**. It is not a protocol
    or standard; instead, it provides certain architectural constraints to expose
    the data layer. The REST API allows you to transfer the representational state
    of a data resource to the REST endpoint. These representations can be in JSON,
    XML, HTML, XLT, or plain text format so that they can be transferred over the
    HTTP/(S) protocol.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表征状态转移**。它不是一个协议或标准；相反，它提供了一些架构约束来暴露数据层。REST API允许您将数据资源的表征状态传输到REST端点。这些表征可以是JSON、XML、HTML、XLT或纯文本格式，以便可以通过HTTP/(S)协议进行传输。'
- en: Problem statement
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题陈述
- en: In the solution described in [*Chapter 6*](B17084_06.xhtml#_idTextAnchor092),
    *Architecting a Real-Time Processing Pipeline*, we analyzed and ingested analytical
    data in a MongoDB-based collection. Now, we want to expose the documents present
    in the collection using a DaaS service that can be searched for by either `ApplicationId`
    or `CustomerId`. In the next section, we will analyze and design the solution
    and then implement it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B17084_06.xhtml#_idTextAnchor092)“构建实时处理管道”中描述的解决方案中，我们分析了MongoDB基础集合中的分析数据。现在，我们希望通过一个可以按`ApplicationId`或`CustomerId`进行搜索的DaaS服务来公开集合中的文档。在下一节中，我们将分析、设计和实现该解决方案。
- en: Analyzing and designing a solution
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析和设计解决方案
- en: 'Let’s analyze the requirement to solve the given problem. First, we will note
    down all the facts and information available. The following are the facts we know:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析解决给定问题的需求。首先，我们将记录所有可用的事实和信息。以下是我们所知道的事实：
- en: The data to be published is stored in a MongoDB collection hosted in the cloud
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发布的数据存储在云中托管的MongoDB集合中
- en: We need to publish the DaaS with security and API management
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要以安全和 API 管理的方式发布 DaaS
- en: We need to create endpoints so that the data can be fetched by either `ApplicationId`
    or `CustomerId`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建端点，以便可以通过 `ApplicationId` 或 `CustomerId` 获取数据
- en: The DaaS that’s been built for this data should be platform or language-independent
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为此数据构建的 DaaS 应该是平台或语言无关的
- en: Based on these facts, we can conclude that we don’t necessarily need a virtual
    data layer. However, we need the application to publish two endpoints – one exposing
    data based on `ApplicationId` and the other exposing data based on `CustomerId`.
    Also, since the MongoDB instance is in the cloud, and most of the frontend applications
    using this DaaS are in the cloud, it makes sense to deploy this application in
    an EC2 or **Elastic Container Repository** (**ECR**) instance. However, since
    we have no information about the traffic that will use this DaaS, it makes more
    sense to containerize the application so that, in the future, we can easily scale
    out the application by adding more containers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些事实，我们可以得出结论，我们不一定需要一个虚拟数据层。然而，我们需要应用程序发布两个端点——一个基于 `ApplicationId` 暴露数据，另一个基于
    `CustomerId` 暴露数据。另外，由于 MongoDB 实例在云端，并且大多数使用此 DaaS 的前端应用程序也在云端，因此将此应用程序部署在 EC2
    或 **弹性容器仓库**（**ECR**）实例中是有意义的。然而，由于我们没有关于将使用此 DaaS 的流量的信息，因此将应用程序容器化更有意义，这样在未来，我们可以通过添加更多容器轻松扩展应用程序。
- en: 'The following diagram depicts the proposed solution architecture for our problem:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了我们问题的提出的解决方案架构：
- en: '![Figure 9.2 – Proposed solution architecture of DaaS ](img/B17084_09_002.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – DaaS 提出的解决方案架构](img/B17084_09_002.jpg)'
- en: Figure 9.2 – Proposed solution architecture of DaaS
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – DaaS 提出的解决方案架构
- en: 'As we can see, we use our REST application to read data from MongoDB and fetch
    the results for the REST endpoint. We use Spring Boot as the technology stack
    to build the REST API as it is modular, flexible, extendible, and provides an
    amazing range of I/O integrations and community support. We will create Docker
    containers for this application and deploy them in the AWS Elastic Container Service
    cluster using the AWS Fargate service. This gives us the flexibility to scale
    up or down quickly when traffic increases in the future. Finally, we apply the
    API management layer on top of the deployed application. There are many API management
    tools available on the market, including Google’s APIJEE, Microsoft’s Azure API
    Management, AWS API Gateway, and IBM’s API Connect. However, since our stack is
    deployed on AWS, we will be using the native API management tool of AWS: AWS API
    Gateway.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用我们的 REST 应用程序从 MongoDB 读取数据并为 REST 端点检索结果。我们使用 Spring Boot 作为技术栈来构建
    REST API，因为它模块化、灵活、可扩展，并提供了一个惊人的 I/O 集成范围和社区支持。我们将为该应用程序创建 Docker 容器，并使用 AWS Fargate
    服务在 AWS 弹性容器服务集群中部署它们。这使我们能够在未来流量增加时快速扩展或缩减。最后，我们在部署的应用程序之上应用 API 管理层。市场上有很多 API
    管理工具，包括谷歌的 APIJEE、微软的 Azure API 管理、AWS API Gateway 和 IBM 的 API Connect。然而，由于我们的堆栈部署在
    AWS 上，我们将使用 AWS 的原生 API 管理工具：AWS API Gateway。
- en: 'Now that we have discussed the overall architecture of the solution, let’s
    learn more about the design of the Spring Boot application. The following diagram
    depicts the low-level design of the Spring Boot application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了解决方案的整体架构，让我们更多地了解 Spring Boot 应用程序的设计。下面的图示展示了 Spring Boot 应用的底层设计：
- en: '![Figure 9.3 – Low-level design of the Spring Boot REST application ](img/B17084_09_003.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – Spring Boot REST 应用程序的底层设计](img/B17084_09_003.jpg)'
- en: Figure 9.3 – Low-level design of the Spring Boot REST application
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Spring Boot REST 应用程序的底层设计
- en: 'Our Spring application has a controller class called `DaaSController` that
    exposes two `GET` endpoints, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Spring 应用程序有一个名为 `DaaSController` 的控制器类，它公开了两个 `GET` 端点，如下所示：
- en: '`GET /rdaas/application/{applicationId}`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /rdaas/application/{applicationId}`'
- en: '`GET /rdaas/customer/{id}/application`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /rdaas/customer/{id}/application`'
- en: The first REST endpoint returns the application document based on `applicationId`,
    while the second REST endpoint returns all the applications of a given customer
    using `customerId` as the search criteria.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 REST 端点根据 `applicationId` 返回应用程序文档，而第二个 REST 端点使用 `customerId` 作为搜索条件返回给定客户的全部应用程序。
- en: The `MongoConfig` class is used to configure and initialize `mongoTemplate`
    and `MongoRepository`. We create a custom `MongoRepository` called `ApplicationRepository`
    that uses `QueryDSL` to dynamically generate custom MongoDB queries at runtime.
    The controller class uses the `ApplicationRepository` class to connect to MongoDB
    and fetch document(s) from the collection as per the request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`MongoConfig` 类用于配置和初始化 `mongoTemplate` 和 `MongoRepository`。我们创建了一个名为 `ApplicationRepository`
    的自定义 `MongoRepository`，它使用 `QueryDSL` 在运行时动态生成自定义 MongoDB 查询。控制器类使用 `ApplicationRepository`
    类连接到 MongoDB，并根据请求从集合中获取文档。'
- en: With that, we have analyzed the problem and created a solution design. Now,
    let’s discuss how we can implement this solution. First, we will develop the Spring
    Boot REST application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经分析了问题并创建了解决方案设计。现在，让我们讨论如何实施这个解决方案。首先，我们将开发 Spring Boot REST 应用程序。
- en: Implementing the Spring Boot REST application
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Spring Boot REST应用程序
- en: In this section, we will learn how to build the Spring Boot application to implement
    the solution we designed in the preceding section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何构建 Spring Boot 应用程序以实现上一节中设计的解决方案。
- en: 'First, we must create a Maven project using our IDE and add the following Spring
    dependencies:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用我们的 IDE 创建一个 Maven 项目，并添加以下 Spring 依赖项：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These dependencies ensure that all the Spring Boot basic dependencies, as well
    as the REST-based dependencies, are fulfilled. However, we must add dependencies
    related to MongoDB. The following dependencies are related to Spring’s MongoDB
    integration, as well as the necessary QueryDSL dependencies, to write custom MongoDB
    queries via the Spring JPA implementation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项确保了所有 Spring Boot 基础依赖项以及基于 REST 的依赖项都得到满足。然而，我们必须添加与 MongoDB 相关的依赖项。以下是与
    Spring 的 MongoDB 集成相关的依赖项，以及编写自定义 MongoDB 查询所需的必要 QueryDSL 依赖项：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Apart from these dependencies, we need to add build plugins to the `pom.xml`
    file. These plugins help generate Q classes dynamically, which are required for
    QueryDSL to work properly. The following plugins need to be added:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些依赖项之外，我们还需要将构建插件添加到 `pom.xml` 文件中。这些插件有助于动态生成 Q 类，这对于 QueryDSL 正常工作至关重要。以下是需要添加的插件：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have added all the necessary dependencies, we will create the entry
    point, or the `main` class, of our Spring Boot application, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所有必要的依赖项，我们将创建 Spring Boot 应用的入口点，即 `main` 类，如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As per the preceding code, all the Bean components in the `com.scalabledataarch.rest`
    package will be scanned recursively and instantiated when the Spring Boot application
    is started. Now, let’s create Mongo configuration beans using the `Configuration`
    class called `MongoConfig`. The source code for the same is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码，`com.scalabledataarch.rest` 包中的所有 Bean 组件将在 Spring Boot 应用程序启动时递归扫描并实例化。现在，让我们使用名为
    `MongoConfig` 的 `Configuration` 类创建 Mongo 配置 Bean。相应的源代码如下：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, the `MongoConfig` class is annotated with `@EnableMongoRepositories`,
    where the base package of the repositories is configured. All classes extending
    the `MongoRepository` interface under the base package will be scanned and Spring
    beans will be created. Apart from that, we have created the `MongoClient` and
    `MongoTemplate` beans. Here, we used the `com.mongodb.client.MongoClients` API
    to create the `MongoClient` bean.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`MongoConfig` 类使用了 `@EnableMongoRepositories` 注解，其中配置了仓库的基本包。在基本包下扩展 `MongoRepository`
    接口的所有类都将被扫描，并将创建 Spring Bean。除此之外，我们还创建了 `MongoClient` 和 `MongoTemplate` Bean。在这里，我们使用了
    `com.mongodb.client.MongoClients` API 来创建 `MongoClient` Bean。
- en: 'Next, we will create a model class that can hold the deserialized data from
    a MongoDB document. We can create the model `Application` class as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个模型类，它可以存储从 MongoDB 文档反序列化出来的数据。我们可以创建名为 `Application` 的模型类，如下所示：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is important to annotate the class with `@Document` and give the value of
    the collection name as its argument for `spring-data-mongo` to understand that
    this POJO represents a MongoDB document structure for the specified collection.
    Also, annotating with `@QueryEntity` is essential for QueryDSL to generate Q classes
    dynamically using `apt-maven-plugin`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在类上使用 `@Document` 注解并给出集合名称的值作为其参数，对于 `spring-data-mongo` 来说是重要的，以便理解这个 POJO
    代表了指定集合的 MongoDB 文档结构。此外，使用 `@QueryEntity` 注解对于 QueryDSL 使用 `apt-maven-plugin`
    动态生成 Q 类是必不可少的。
- en: 'Now, we will use this `Application` POJO to write our custom Mongo repository,
    as shown in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个 `Application` POJO 来编写我们的自定义 Mongo 仓库，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To implement a custom repository, it must implement or extend the `MongoRepository`
    interface. Since our `ApplicationRepository` uses QueryDSL, it must extend `QuerydslPredicateExecutor`.
    We can specify a Mongo query using the `@Query` annotation, as shown in the preceding
    code, which will be executed when the corresponding method is called.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现自定义仓库，它必须实现或扩展`MongoRepository`接口。由于我们的`ApplicationRepository`使用QueryDSL，它必须扩展`QuerydslPredicateExecutor`。我们可以使用`@Query`注解指定Mongo查询，如前面的代码所示，这将当调用相应的方法时执行。
- en: 'Now, we will create a controller class called `DaasController`. The `DaasController`
    class should be annotated with the `@RestController` annotation to indicate that
    it is a Spring component that publishes REST endpoints. A basepath to the endpoints
    in `DaaSController` can be created using the `@RequestMapping` annotation, as
    shown in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`DaasController`的控制器类。`DaasController`类应该被注解为`@RestController`，以表明它是一个发布REST端点的Spring组件。可以使用`@RequestMapping`注解在`DaaSController`中创建端点的基路径，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will add our methods, each corresponding to a REST endpoint. The following
    code shows the source code for one of the methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加我们的方法，每个方法对应一个REST端点。下面的代码显示了其中一个方法的源代码：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, the method that will be triggered when a REST endpoint call is
    made is annotated with `@GetMapping` or `@PostMapping`, based on the HTTP method
    type. In our case, we need a `GET` request. Each mapping should be accompanied
    by the URL path and the other necessary properties as parameters for these annotations.
    In this method, the autowired `applicationRepository` bean is used to fetch Mongo
    documents using the `applicationId` field.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当调用REST端点时将被触发的那个方法被注解为`@GetMapping`或`@PostMapping`，这取决于HTTP方法类型。在我们的情况下，我们需要一个`GET`请求。每个映射都应该由URL路径和其他必要的属性作为这些注解的参数来伴随。在这个方法中，使用了自动装配的`applicationRepository`豆来使用`applicationId`字段获取Mongo文档。
- en: 'Finally, we will create `application.yml` to set up the configuration parameters
    to run the Spring Boot application. The `application.yml` file in our case will
    look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`application.yml`文件来设置运行Spring Boot应用程序的配置参数。在我们的情况下，`application.yml`文件将如下所示：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As shown in the source code of the `application.yml` file earlier, we configure
    various Mongo connectivity details in the `application.yml` file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的`application.yml`文件的源代码所示，我们在`application.yml`文件中配置了各种Mongo连接细节。
- en: 'Now, we can run the application from our local machine by running the `main`
    class and test it using Postman, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行`main`类在我们的本地机器上运行应用程序，并使用Postman进行测试，如下所示：
- en: 'First, click the `ApplicationDaaS`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击`ApplicationDaaS`：
- en: '![Figure 9.4 – Creating a new Postman collection ](img/B17084_09_004.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 创建新的Postman集合](img/B17084_09_004.jpg)'
- en: Figure 9.4 – Creating a new Postman collection
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 创建新的Postman集合
- en: 'Add a request to the collection using the **Add request** option, as shown
    in the following screenshot:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加请求**选项向集合添加请求，如下面的屏幕截图所示：
- en: '![Figure 9.5 – Adding a request to the Postman collection ](img/B17084_09_005.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 向Postman集合添加请求](img/B17084_09_005.jpg)'
- en: Figure 9.5 – Adding a request to the Postman collection
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 向Postman集合添加请求
- en: 'Next, fill in the configurations for the HTTP method, REST URL, and headers.
    Now, you can execute the request using the **Send** button, as shown in the following
    screenshot:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填写HTTP方法、REST URL和头部的配置。现在，您可以使用**发送**按钮执行请求，如下面的屏幕截图所示：
- en: '![Figure 9.6 – Testing the REST API via Postman ](img/B17084_09_006.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 通过Postman测试REST API](img/B17084_09_006.jpg)'
- en: Figure 9.6 – Testing the REST API via Postman
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 通过Postman测试REST API
- en: 'Now that we have tested the application locally, let’s see how we can deploy
    it in ECR. Follow these steps to deploy in ECR:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地测试了应用程序，让我们看看如何将其部署到ECR。按照以下步骤在ECR中部署：
- en: 'First, we need to containerize this application. To do that, we must create
    our Docker file. The source code for this `DockerFile` is as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将这个应用程序容器化。为此，我们必须创建我们的Docker文件。这个`DockerFile`的源代码如下：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the first line imports the base image, which contains the preconfigured
    OpenJDK 11 software. There, we create a volume called `/tmp`. Then, we add a new
    user to this Docker container called `appuser` using the `RUN useradd` command.
    Using the `USER` command, we log in as `appuser`. Then, we copy the JAR file to
    `app.jar`. The JAR file path is passed as an argument to this `DockerFile`. Passing
    the JAR file path as an argument will help us in the future if we want to build
    a `8080` is exposed from the container. Finally, we run the `java -jar` command
    using the `ENTRYPOINT` command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行导入了一个包含预配置 OpenJDK 11 软件的基图像。在那里，我们创建了一个名为 `/tmp` 的卷。然后，我们使用 `RUN useradd`
    命令向这个 Docker 容器中添加一个名为 `appuser` 的新用户。使用 `USER` 命令，我们以 `appuser` 身份登录。然后，我们将 JAR
    文件复制到 `app.jar`。JAR 文件路径作为参数传递给此 `DockerFile`。将 JAR 文件路径作为参数传递将有助于我们在将来如果想要构建一个
    `8080` 端口从容器中暴露出来。最后，我们使用 `ENTRYPOINT` 命令运行 `java -jar` 命令。
- en: 'Now, we can build the Docker image by running the following command from a
    command line or Terminal:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在命令行或终端中运行以下命令来构建 Docker 图像：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will create a Docker image called `apprestdaas` with a tag of `v1.0` in
    the local Docker image repository. You can either view the image listed in Docker
    Desktop or a Terminal by using the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在本地 Docker 图像仓库中创建一个名为 `apprestdaas` 并带有 `v1.0` 标签的 Docker 图像。您可以通过以下命令在 Docker
    Desktop 或终端中查看图像列表：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have created the Docker image, let’s discuss how can we deploy this
    image in an ECS cluster.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 Docker 图像，让我们讨论如何在 ECS 集群中部署此图像。
- en: Deploying the application in an ECS cluster
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ECS 集群中部署应用程序
- en: 'In this section, we will discuss how to deploy our REST application in an AWS
    ECS cluster. Follow these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何在 AWS ECS 集群中部署我们的 REST 应用程序。请按照以下步骤操作：
- en: 'First, we are going to create a repository in AWS ECR to store our Docker image.
    We will require the **Amazon Resource Name** (**ARN**) for this repository to
    tag and upload the image. First, we will navigate to ECR in the AWS Management
    Console and click **Create repository**. You’ll see a **Create repository** page,
    as shown in the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在 AWS ECR 中创建一个存储我们的 Docker 图像的仓库。我们需要这个仓库的 **Amazon Resource Name**（**ARN**）来标记和上传图像。首先，我们将导航到
    AWS 管理控制台中的 ECR 并点击 **创建仓库**。您将看到一个 **创建仓库** 页面，如下面的截图所示：
- en: '![Figure 9.7 – The Create repository page ](img/B17084_09_007.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 创建仓库页面](img/B17084_09_007.jpg)'
- en: Figure 9.7 – The Create repository page
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 创建仓库页面
- en: 'Here, fill in the repository’s name, leave the rest of the fields as-is, and
    submit the request. Once it has been created, you will be able to see the repository
    listed on ECR’s **Private repositories** page, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，填写仓库的名称，其余字段保持不变，并提交请求。一旦创建，您将能够在 ECR 的 **私有仓库** 页面上看到仓库列表，如下所示：
- en: '![Figure 9.8 – The ECR repository has been created  ](img/B17084_09_008.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – ECR 仓库已创建](img/B17084_09_008.jpg)'
- en: Figure 9.8 – The ECR repository has been created
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – ECR 仓库已创建
- en: 'Download the latest AWS CLI and install it. Then, configure the AWS CLI using
    the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载最新的 AWS CLI 并安装它。然后，使用以下命令配置 AWS CLI：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While configuring the AWS CLI, you need to provide the access key ID and the
    secret access key. You can generate these variables by following the instructions
    at [https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 AWS CLI 时，您需要提供访问密钥 ID 和秘密访问密钥。您可以通过遵循 [https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey)
    中的说明来生成这些变量。
- en: 'Next, we need to generate an ECR login token for Docker using the following
    command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用以下命令为 Docker 生成一个 ECR 登录令牌：
- en: '[PRE14]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you run this command, an authentication token will be generated that is
    needed by Docker to push the image to ECR. We can pipe the previous command with
    the following command, where we directly pass the token to a `docker login` command.
    The final command looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，将生成一个由 Docker 用于将图像推送到 ECR 所需的认证令牌。我们可以使用以下命令将前面的命令与以下命令连接起来，其中我们直接将令牌传递给
    `docker login` 命令。最终的命令如下所示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding command, please replace `region` with the correct AWS region,
    such as `us-east-2` or `us-east-1`, and `accountid` with the correct AWS account
    ID.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，请将 `region` 替换为正确的 AWS 区域，例如 `us-east-2` 或 `us-east-1`，并将 `accountid`
    替换为正确的 AWS 账户 ID。
- en: 'Next, we will tag the local Docker image with the ECR repository URI. This
    is required for ECR to map the correct repository with the image we are pushing.
    The command for this is as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 ECR 仓库 URI 对本地 Docker 镜像进行标记。这对于 ECR 将正确的仓库与我们要推送的镜像进行映射是必需的。此操作的命令如下：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we will use the following command to push the Docker image into the ECR
    repository:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下命令将 Docker 镜像推送到 ECR 仓库：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Upon running this command, the local Docker image will be pushed to the ECR
    repository with the `restdaas:v1` tag.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，本地 Docker 镜像将带有 `restdaas:v1` 标签推送到 ECR 仓库。
- en: 'Now, let’s create an AWS Fargate cluster. To do that, we must log into the
    AWS Management Console again. Here, search for `Elastic Container Services` and
    select it. From the **Elastic Container Service** dashboard, navigate to **Cluster**
    in the left pane and select **Create Cluster**:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 AWS Fargate 集群。为此，我们必须再次登录 AWS 管理控制台。在这里，搜索 `弹性容器服务` 并选择它。从 **弹性容器服务**
    仪表板，在左侧面板中导航到 **集群** 并选择 **创建集群**：
- en: '![Figure 9.9 – Creating an ECS cluster ](img/B17084_09_009.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 创建 ECS 集群](img/B17084_09_009.jpg)'
- en: Figure 9.9 – Creating an ECS cluster
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 创建 ECS 集群
- en: 'Next, set the cluster template to **Networking only** and click **Next step**:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将集群模板设置为 **仅网络** 并点击 **下一步**：
- en: '![Figure 9.10 – Selecting an ECS cluster template ](img/B17084_09_010.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 选择 ECS 集群模板](img/B17084_09_010.jpg)'
- en: Figure 9.10 – Selecting an ECS cluster template
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 选择 ECS 集群模板
- en: 'Then, enter the name of the cluster. Here, we will name it `daas-cluster`.
    Leave the other fields as-is. Now, click the **Create** button to create the new
    ECS cluster:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入集群的名称。在这里，我们将命名为 `daas-cluster`。保留其他字段不变。现在，点击 **创建** 按钮以创建新的 ECS 集群：
- en: '![Figure 9.11 – Naming and creating the ECS cluster ](img/B17084_09_011.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 命名并创建 ECS 集群](img/B17084_09_011.jpg)'
- en: Figure 9.11 – Naming and creating the ECS cluster
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 命名并创建 ECS 集群
- en: 'Now, we will create an ECS task. From the dashboard of AWS ECS console, select
    **Task Definition** from the left menu and then click on **Create new Task Definition**,
    as shown in the following screenshot:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 ECS 任务。从 AWS ECS 控制台仪表板，从左侧菜单中选择 **任务定义**，然后点击 **创建新任务定义**，如图所示：
- en: '![Figure 9.12 – Creating a new task definition ](img/B17084_09_012.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 创建新的任务定义](img/B17084_09_012.jpg)'
- en: Figure 9.12 – Creating a new task definition
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 创建新的任务定义
- en: 'Then, under **Select launch type compatibility**, choose **FARGATE** and click
    **Next step**, as shown in the following screenshot:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **选择启动类型兼容性** 下，选择 **FARGATE** 并点击 **下一步**，如图所示：
- en: '![Figure 9.13 – Selecting the launch type for the ECS task ](img/B17084_09_013.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 选择 ECS 任务的启动类型](img/B17084_09_013.jpg)'
- en: Figure 9.13 – Selecting the launch type for the ECS task
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 选择 ECS 任务的启动类型
- en: 'Next, we must set `restdaas`. Set **Task role** to **None** and **Operating
    system family** to **Linux**, as shown in the following screenshot:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置 `restdaas`。将 **任务角色** 设置为 **无** 并将 **操作系统家族** 设置为 **Linux**，如图所示：
- en: '![Figure 9.14 – Setting up a task definition ](img/B17084_09_014.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 设置任务定义](img/B17084_09_014.jpg)'
- en: Figure 9.14 – Setting up a task definition
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 设置任务定义
- en: 'Leave **Task execution role** as-is, set **Task memory (GB)** to **1GB**, and
    set **Task CPU (vCPU)** to **0.5 vCPU**, as shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 **任务执行角色** 不变，将 **任务内存（GB）** 设置为 **1GB**，并将 **任务 CPU（vCPU）** 设置为 **0.5 vCPU**，如图所示：
- en: '![Figure 9.15 – Choosing Task memory and Task CPU (vCPU) values ](img/B17084_09_015.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 选择任务内存和任务 CPU（vCPU）值](img/B17084_09_015.jpg)'
- en: Figure 9.15 – Choosing Task memory and Task CPU (vCPU) values
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 选择任务内存和任务 CPU（vCPU）值
- en: 'Now, we will add a container to the ECS task. We can add the container by clicking
    on the `restdaas` as the container name and populate the ECR ARN of our image,
    as shown in the following screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将向 ECS 任务添加容器。我们可以通过点击 `restdaas` 作为容器名称并填写我们镜像的 ECR ARN 来添加容器，如图所示：
- en: '![Figure 9.16 – Adding a container to the ECS task ](img/B17084_09_016.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 向 ECS 任务添加容器](img/B17084_09_016.jpg)'
- en: Figure 9.16 – Adding a container to the ECS task
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 向 ECS 任务添加容器
- en: 'Click the **Add** button to add a container. Then, click the **Create** button
    on the **Create new Task Definition** page. This will create the new task, as
    shown in the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加** 按钮以添加容器。然后，在 **创建新任务定义** 页面上点击 **创建** 按钮。这将创建新的任务，如图所示：
- en: '![Figure 9.17 – ECS task created ](img/B17084_09_017.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 创建的ECS任务](img/B17084_09_017.jpg)'
- en: Figure 9.17 – ECS task created
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 创建的ECS任务
- en: As shown in the previous screenshot, the task we’ve created, **restdaas**, is
    in an **ACTIVE** state but it is not running.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，我们创建的任务**restdaas**处于**活动**状态，但它尚未运行。
- en: 'Now, let’s run the task. Click on the **ACTION** dropdown button and select
    **Run Task**. This submits the task so that it can be in runnable status. On clicking
    **Run Task**, a screen will appear where we must fill out various configurations
    for running the task, as shown in the following screenshot:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行任务。点击**操作**下拉按钮，选择**运行任务**。这将提交任务，使其处于可运行状态。点击**运行任务**后，将出现一个屏幕，我们必须填写运行任务的各种配置，如下截图所示：
- en: '![Figure 9.18 – Run Task ](img/B17084_09_018.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 运行任务](img/B17084_09_018.jpg)'
- en: Figure 9.18 – Run Task
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 运行任务
- en: 'Set **Launch type** to **FARGATE** and **Operating system family** to **Linux**.
    Also, select any available VPC and subnet group, as shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将**启动类型**设置为**FARGATE**，并将**操作系统家族**设置为**Linux**。同时，选择任何可用的VPC和子网组，如下截图所示：
- en: '![Figure 9.19 – Setting the VPC and security groups  ](img/B17084_09_019.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19 – 设置VPC和安全组](img/B17084_09_019.jpg)'
- en: Figure 9.19 – Setting the VPC and security groups
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 设置VPC和安全组
- en: 'As shown in the preceding screenshot, please make sure that `8080` since our
    Spring Boot application will be running on port `8080`, as shown in the following
    screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前述截图所示，请确保端口为`8080`，因为我们的Spring Boot应用程序将在端口`8080`上运行，如下截图所示：
- en: '![Figure 9.20 – Allowing port 8080  ](img/B17084_09_020.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20 – 允许端口8080](img/B17084_09_020.jpg)'
- en: Figure 9.20 – Allowing port 8080
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 允许端口8080
- en: 'Leave the other fields as-is and click **Run Task**. By refreshing the **Task**
    tab, we can see that the task changes state from **PROVISIONING** to **RUNNING**.
    The following screenshot shows a **RUNNING** task:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其他字段不变，然后点击**运行任务**。通过刷新**任务**选项卡，我们可以看到任务状态从**配置中**变为**运行中**。以下截图显示了一个**运行中**的任务：
- en: '![Figure 9.21 – Task in the RUNNING state ](img/B17084_09_021.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图9.21 – 运行状态的任务](img/B17084_09_021.jpg)'
- en: Figure 9.21 – Task in the RUNNING state
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – 运行状态的任务
- en: 'Now, we will test the DaaS that we’ve deployed in ECS. To do that, click on
    the text under the **Task** column shown in the preceding screenshot. This takes
    us to the **Running task** screen, as shown in the following screenshot:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将测试我们在ECS中部署的DaaS。为此，点击前述截图中**任务**列下的文本。这会带我们到**运行任务**屏幕，如下截图所示：
- en: '![Figure 9.22 – Running task details ](img/B17084_09_022.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22 – 运行任务详情](img/B17084_09_022.jpg)'
- en: Figure 9.22 – Running task details
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 – 运行任务详情
- en: 'As highlighted in the preceding screenshot, we will get the public IP. We will
    use this IP for testing purposes. Now, from Postman, we can test our REST endpoints
    using this IP address and port `8080`, as shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，我们将获取公网IP。我们将使用此IP进行测试。现在，从Postman，我们可以使用此IP地址和端口`8080`测试我们的REST端点，如下截图所示：
- en: '![Figure 9.23 – Testing the REST endpoint that was deployed in AWS ECS ](img/B17084_09_023.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图9.23 – 测试在AWS ECS中部署的REST端点](img/B17084_09_023.jpg)'
- en: Figure 9.23 – Testing the REST endpoint that was deployed in AWS ECS
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 – 测试在AWS ECS中部署的REST端点
- en: In this section, we learned how to develop a REST application to publish the
    DaaS, containerize the application, deploy it in an AWS ECS cluster, and test
    the endpoints. In the next section, we will understand the need for API management,
    and we will provide a step-by-step guide to attaching the API management layer
    to the REST endpoints that we developed and deployed in this section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何开发一个REST应用程序以发布DaaS，将应用程序容器化，并在AWS ECS集群中部署它，并测试端点。在下一节中，我们将了解API管理的必要性，并提供一个逐步指南，将API管理层附加到本节中开发和部署的REST端点。
- en: API management
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API管理
- en: 'API management is a set of tools and technologies that allows us to distribute,
    analyze, and control APIs that expose data and services across the organization.
    It can act like a wrapper on top of the APIs, whether they are deployed on-premises
    or in the cloud. It is always a good idea to use API management while we are architecting
    a solution to publish data via an API. First, let’s understand what API management
    is and how it helps. The following diagram shows where and how the API management
    layer helps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: API管理是一套工具和技术，使我们能够分发、分析和控制组织内部暴露数据和服务的API。它可以在API之上充当包装器，无论这些API是在本地部署还是云中部署。在我们架构解决方案以通过API发布数据时，使用API管理总是一个好主意。首先，让我们了解API管理是什么以及它如何帮助。以下图表显示了API管理层在哪里以及如何提供帮助：
- en: '![Figure 9.24 – How API management helps ](img/B17084_09_024.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图9.24 – API管理如何提供帮助](img/B17084_09_024.jpg)'
- en: Figure 9.24 – How API management helps
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 – API管理如何提供帮助
- en: 'As we can see, API management is a wrapper layer that sits between the customer-facing
    API and the internal service API. We can define resources and methods in the API
    management layer that get exposed to the customer. Primarily, an architecture
    gets the following benefits while using an API management layer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，API管理是一个介于面向客户的API和内部服务API之间的包装层。我们可以在API管理层中定义资源和方法，这些资源和方法会被暴露给客户。主要来说，使用API管理层，架构可以得到以下好处：
- en: '**Flexibility**: API management enables easy deployment in a different environment
    by enabling continuous deployment and testing. It also provides a unified interface
    where a single customer-facing API can be fetched from multiple complex internal
    service APIs. This enables easy integration and allows you to publish resources
    without the need to create extra APIs to integrate and manage multiple APIs. On
    the other hand, in a very dynamic technological landscape, chances are that internal
    service APIs may be updated or their structure may change frequently. The API
    management layer gives us easy access to move from an older internal service API
    to a new one without changing or affecting the customer-facing API. This gives
    us huge flexibility in design and helps us overcome technical debts in the internal
    service API layer without any hassle.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：API管理通过启用持续部署和测试，使在不同环境中轻松部署成为可能。它还提供了一个统一的接口，其中单个面向客户的API可以从多个复杂的内部服务API中获取。这使集成变得容易，并允许你发布资源，而无需创建额外的API来集成和管理多个API。另一方面，在非常动态的技术环境中，内部服务API可能会频繁更新或其结构可能会改变。API管理层使我们能够轻松地从旧的内部服务API迁移到新的API，而无需更改或影响面向客户的API。这为我们提供了巨大的设计灵活性，并帮助我们轻松克服内部服务API层中的技术债务。'
- en: '**Security**: API management provides security in different ways. First, it
    enables APIs to have custom authorizers such as OAuth. Second, it enables customer-specific
    usage plans and API keys. This ensures only a consumer who is registered with
    a usage plan and API key will be able to access the application. Also, it puts
    a limit on how many transactions a consumer can do per second. This, along with
    the throttling feature, helps us avoid any **distributed denial-of-service** (**DDoS**)
    attacks on the Service APIs. Apart from these, role-based access can be enabled
    using the RBAC feature of the API. All these security features make API management
    a necessary component in designing a DaaS architecture.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：API管理以不同的方式提供安全性。首先，它使API能够拥有自定义授权器，如OAuth。其次，它使客户特定的使用计划和API密钥成为可能。这确保只有注册了使用计划和API密钥的消费者才能访问应用程序。此外，它还限制了消费者每秒可以进行的交易数量。这一点加上节流功能，有助于我们避免对服务API的任何**分布式拒绝服务**（**DDoS**）攻击。除此之外，还可以通过API的RBAC功能启用基于角色的访问。所有这些安全特性使API管理成为设计DaaS架构的必要组件。'
- en: '**Documentation**: This allows you to easily create, publish, and maintain
    the documentation of the API. The published documentation can be easily accessed
    by consumers of the API, making their lives easy. Apart from this, even the *Swagger*
    and *OpenAPI* specifications can be published and maintained using API management.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：这允许你轻松创建、发布和维护API的文档。发布的文档可以很容易地被API的消费者访问，使他们的生活变得简单。除此之外，甚至*Swagger*和*OpenAPI*规范也可以通过API管理进行发布和维护。'
- en: '**Analysis**: One of the major advantages of using API management is the ability
    to monitor and analyze the traffic, latency, and other parameters while the API
    is deployed and used in production.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：使用API管理的主要优势之一是能够在API部署并用于生产时监控和分析流量、延迟和其他参数。'
- en: In this section, we understood what API management is and how it can help us
    create a robust architecture for DaaS solutions. In the next section, we will
    attach an API management layer on top of the ECS REST Service API that we developed
    earlier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了API管理是什么以及它如何帮助我们为DaaS解决方案创建一个强大的架构。在下一节中，我们将为我们之前开发的ECS REST Service
    API附加一个API管理层。
- en: Enabling API management over the DaaS API using AWS API Gateway
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS API网关在DaaS API上启用API管理
- en: 'In this section, we will discuss how to set up API management using AWS API
    Gateway. We will use the REST DaaS API that we developed and deployed in ECS earlier
    in this chapter. Follow these steps to set up an API management layer for our
    REST DaaS API:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用AWS API网关设置API管理。我们将使用本章前面在ECS中开发和部署的REST DaaS API。按照以下步骤为我们的REST
    DaaS API设置API管理层：
- en: 'In the AWS Management Console, search for `AWS API Gateway` and navigate to
    the **AWS API Gateway** service dashboard. From here, select **REST API** and
    click **Build**, as shown in the following screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS管理控制台中，搜索`AWS API Gateway`并导航到**AWS API Gateway**服务仪表板。从这里，选择**REST API**并点击**构建**，如图下所示截图：
- en: '![Figure 9.25 – The AWS API Gateway dashboard ](img/B17084_09_025.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图9.25 – AWS API网关仪表板](img/B17084_09_025.jpg)'
- en: Figure 9.25 – The AWS API Gateway dashboard
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 – AWS API网关仪表板
- en: 'A new window will open, as shown in the following screenshot. Select **REST**
    as the protocol and then select **New API** under **Create new API**. Fill in
    the API’s name and a description and click **Create API**:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打开一个新窗口，如图下所示截图。选择**REST**作为协议，然后在**创建新API**下选择**新建API**。填写API的名称和描述，然后点击**创建API**：
- en: '![Figure 9.26 – Creating a REST API ](img/B17084_09_026.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图9.26 – 创建REST API](img/B17084_09_026.jpg)'
- en: Figure 9.26 – Creating a REST API
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 – 创建REST API
- en: 'Once the resource has been created, we will be taken to the details of the
    API. We can add resources or methods from the **Actions** dropdown in this interface,
    as shown in the following screenshot:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源创建完成后，我们将进入API的详细信息。我们可以通过此界面中的**操作**下拉菜单添加资源或方法，如图下所示截图：
- en: '![Figure 9.27 – Adding resources to the API ](img/B17084_09_027.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图9.27 – 向API添加资源](img/B17084_09_027.jpg)'
- en: Figure 9.27 – Adding resources to the API
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27 – 向API添加资源
- en: 'Here, we will click `/loanapplications`. Then, we will add another resource
    under `loanapplications` whose name is `appId` and the path is `/{appId}`. Note
    that `{}` denotes that `appId` is a path variable. Finally, in the `appId` resource,
    we will add a method by selecting **Create Method**, as shown in the following
    screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将点击`/loanapplications`。然后，在`loanapplications`下添加另一个名为`appId`、路径为`/{appId}`的资源。请注意，`{}`表示`appId`是一个路径变量。最后，在`appId`资源中，我们将通过选择**创建方法**添加一个方法，如图下所示截图：
- en: '![Figure 9.28 – Configuring the GET method ](img/B17084_09_028.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图9.28 – 配置GET方法](img/B17084_09_028.jpg)'
- en: Figure 9.28 – Configuring the GET method
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 – 配置GET方法
- en: Set `/loanapplications/{appId}` API resource to the `/rdaas/application/{appId}`
    DaaS API resource.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将`/loanapplications/{appId}` API资源设置为`/rdaas/application/{appId}` DaaS API资源。
- en: 'Deploy the API by choosing the **Deploy API** option from the **Actions** dropdown,
    as shown in the following screenshot:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从**操作**下拉菜单中选择**部署API**选项来部署API，如图下所示截图：
- en: '![Figure 9.29 – Deploy API ](img/B17084_09_029.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图9.29 – 部署API](img/B17084_09_029.jpg)'
- en: Figure 9.29 – Deploy API
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 – 部署API
- en: 'Upon doing this, a window will appear, as shown in the following screenshot.
    Set **Deployment stage** to **[New Stage]** and fill in the stage’s name and description.
    Finally, click **Deploy**:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，将出现一个窗口，如图下所示截图。将**部署阶段**设置为**[新阶段**]，填写阶段的名称和描述。最后，点击**部署**：
- en: '![Figure 9.30 – Deploying the API configuration ](img/B17084_09_031.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图9.30 – 部署API配置](img/B17084_09_031.jpg)'
- en: Figure 9.30 – Deploying the API configuration
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 – 部署API配置
- en: 'Now, we will test the new customer-facing API via Postman. But before that,
    we must find out the base URL of the API. To do so, navigate to **Stages** in
    the left pane and select **dev**. The **dev Stage Editor** page will appear, as
    shown in the following screenshot:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过Postman测试新的面向客户的API。但在那之前，我们必须找出API的基础URL。要做到这一点，导航到左侧面板中的**阶段**并选择**dev**。将出现**dev阶段编辑器**页面，如下截图所示：
- en: '![Figure 9.31 – Using dev Stage Editor to get the base URL of the API ](img/B17084_09_032.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图9.31 – 使用开发阶段编辑器获取API的基础URL](img/B17084_09_032.jpg)'
- en: Figure 9.31 – Using dev Stage Editor to get the base URL of the API
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31 – 使用开发阶段编辑器获取API的基础URL
- en: As highlighted in the preceding screenshot, we can get the base URL.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们可以获取基础URL。
- en: 'Now, we can form the customer API by adding the consumer API’s URI to the basepath;
    for example, `http://<baseurl>/loanapplications/<some_app_id>`. We can use this
    API and test it in Postman, as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将消费者API的URI添加到基础路径来形成客户API；例如，`http://<baseurl>/loanapplications/<some_app_id>`。我们可以使用这个API并在Postman中测试它，如下所示：
- en: '![Figure 9.32 – Testing the external API exposed by AWS API Gateway (without
    security) ](img/B17084_09_033.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图9.32 – 测试AWS API Gateway公开的外部API（无安全措施）](img/B17084_09_033.jpg)'
- en: Figure 9.32 – Testing the external API exposed by AWS API Gateway (without security)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32 – 测试AWS API Gateway公开的外部API（无安全措施）
- en: 'We can also see the dashboard to monitor the API, as shown in the following
    screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到用于监控API的仪表板，如下截图所示：
- en: '![Figure 9.33 – AWS API Gateway dashboard for RESTDaasAPI ](img/B17084_09_034.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图9.33 – RESTDaasAPI的AWS API Gateway仪表板](img/B17084_09_034.jpg)'
- en: Figure 9.33 – AWS API Gateway dashboard for RESTDaasAPI
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33 – RESTDaasAPI的AWS API Gateway仪表板
- en: From this dashboard, we can gather useful information about the number of API
    calls made every day. We can also monitor the latency of the response or any internal
    server errors that have been noticed over time.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个仪表板中，我们可以收集有关每天API调用次数的有用信息。我们还可以监控响应的延迟或随着时间的推移注意到的任何内部服务器错误。
- en: Now that we have added the API management layer, we will try to add API key-based
    security to the consumer-facing API.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了API管理层，我们将尝试向面向消费者的API添加基于API密钥的安全措施。
- en: 'Navigate to the **Resource** pane of **RestDaasAPI** and select the **GET**
    method under the **{appId}** resource. In the configuration, change the value
    of the required API key from **false** to **true**:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**RestDaasAPI**的**资源**面板，并在**{appId}**资源下选择**GET**方法。在配置中，将必需API密钥的值从**false**更改为**true**：
- en: '![Figure 9.34 – Changing the API key’s required value to true ](img/B17084_09_035.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图9.34 – 将API密钥的必需值更改为true](img/B17084_09_035.jpg)'
- en: Figure 9.34 – Changing the API key’s required value to true
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34 – 将API密钥的必需值更改为true
- en: 'Then, navigate to **Usage Plans** and create a usage plan. Set the API-level
    throttling parameters and monthly quota, as shown in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，导航到**使用计划**并创建一个使用计划。设置API级别的节流参数和月度配额，如下截图所示：
- en: '![Figure 9.35 – Create Usage Plan ](img/B17084_09_036.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图9.35 – 创建使用计划](img/B17084_09_036.jpg)'
- en: Figure 9.35 – Create Usage Plan
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35 – 创建使用计划
- en: 'Click **Next** and set the method-level throttling parameters, as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**并设置方法级别的节流参数，如下所示：
- en: '![Figure 9.36 – Configuring the method-level throttling parameters ](img/B17084_09_037.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图9.36 – 配置方法级别的节流参数](img/B17084_09_037.jpg)'
- en: Figure 9.36 – Configuring the method-level throttling parameters
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36 – 配置方法级别的节流参数
- en: 'Click **Next** and set up a new API key for this usage plan by clicking the
    **Create API Key and add to Usage Plan** button:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，通过点击**创建API密钥并添加到使用计划**按钮来为这个使用计划设置一个新的API密钥：
- en: '![Figure 9.37 – Generating a new API key to attach to the usage plan ](img/B17084_09_038.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图9.37 – 生成新的API密钥以附加到使用计划](img/B17084_09_038.jpg)'
- en: Figure 9.37 – Generating a new API key to attach to the usage plan
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37 – 生成新的API密钥以附加到使用计划
- en: 'Once you have clicked this, the **API Key** window will appear. Provide a name
    and description. Also, set **API key*** to **Auto Generate**:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击此按钮后，将出现**API密钥**窗口。提供名称和描述。同时，将**API密钥**设置为**自动生成**：
- en: '![Figure 9.38 – The API Key window ](img/B17084_09_039.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图9.38 – API密钥窗口](img/B17084_09_039.jpg)'
- en: Figure 9.38 – The API Key window
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38 – API密钥窗口
- en: 'Once we have saved the newly generated API key and created the usage plan,
    we can get the API key’s value by navigating to **API Keys** and clicking on the
    **Show** option. By doing so, we can view the generated API key:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存新生成的API密钥并创建使用计划后，我们可以通过导航到**API密钥**并点击**显示**选项来获取API密钥的值。这样做，我们可以查看生成的API密钥：
- en: '![Figure 9.39 – Showing the generated API key by clicking Show (highlighted)
    ](img/B17084_09_040.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图9.39 – 通过点击“显示”来展示生成的API密钥（突出显示）](img/B17084_09_040.jpg)'
- en: Figure 9.39 – Showing the generated API key by clicking Show (highlighted)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39 – 通过点击“显示”来展示生成的API密钥（突出显示）
- en: 'Once you have set up the API key as required in the API, and if you do not
    provide `apikey` in the header while invoking the REST endpoint, you will get
    an error message in the response body, similar to `{"message":"Forbidden"}`. Now,
    you must add a header called `x-api-key` whose value should be the API key that
    you generated in *Step 9*. Then, you can test the secure API via Postman, along
    with the API key, as shown in the following screenshot:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在API中按要求设置了API密钥，并且在调用REST端点时不在头部提供`apikey`，你将在响应体中收到一个错误消息，类似于`{"message":"Forbidden"}`。现在，你必须添加一个名为`x-api-key`的头部，其值应该是你在*步骤9*中生成的API密钥。然后，你可以通过Postman测试安全的API，并附带API密钥，如下面的截图所示：
- en: '![Figure 9.40 – Testing the external API exposed by AWS API Gateway (with Security)
    ](img/B17084_09_041.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图9.40 – 测试AWS API Gateway暴露的外部API（带有安全功能）](img/B17084_09_041.jpg)'
- en: Figure 9.40 – Testing the external API exposed by AWS API Gateway (with Security)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.40 – 测试AWS API Gateway暴露的外部API（带有安全功能）
- en: In this section, we learned how to create an API management layer on top of
    our REST DaaS API. We also discussed how AWS API Gateway can help to monitor and
    secure the API.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在我们的REST DaaS API之上创建一个API管理层。我们还讨论了AWS API Gateway如何帮助监控和保障API。
- en: Now, let’s summarize what we’ve learned in this chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下本章所学的内容。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the basics of DaaS. First, we discussed how
    to develop and test REST-based DaaS APIs using Spring Boot. Then, we learned how
    to containerize the application and publish the containers to the AWS ECR repository.
    We also learned how to deploy the containers published in the AWS ECR repository
    to an AWS ECS cluster. After that, we learned how to run this application using
    the cloud-managed Fargate service. Then, we learned about API management and its
    benefits. Finally, we implemented an API management layer to provide security
    and monitoring on top of our REST DaaS API using AWS API Gateway.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了DaaS的基础知识。首先，我们讨论了如何使用Spring Boot开发和测试基于REST的DaaS API。然后，我们学习了如何将应用程序容器化并将容器发布到AWS
    ECR仓库。我们还学习了如何将发布在AWS ECR仓库中的容器部署到AWS ECS集群。之后，我们学习了如何使用云管理的Fargate服务运行此应用程序。然后，我们学习了API管理和其优势。最后，我们使用AWS
    API Gateway实现了一个API管理层，以在REST DaaS API之上提供安全和监控。
- en: Now that we have learned how to build, deploy, publish, and manage a REST-based
    DaaS API, in the next chapter, we will learn how and when a GraphQL-based DaaS
    can be a good design choice. We will also learn how to design and develop a GraphQL
    DaaS API.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何构建、部署、发布和管理基于REST的DaaS API，在下一章中，我们将学习何时以及如何选择基于GraphQL的DaaS作为良好的设计选项。我们还将学习如何设计和开发GraphQL
    DaaS API。
