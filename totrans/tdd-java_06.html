<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-109"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.2.1">Following the Rhythms of TDD</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We’ve seen how individual unit tests help us explore and capture design decisions about our code and keep our code defect-free and simple to use, but that’s not all they can do. </span><span class="koboSpan" id="kobo.3.2">TDD has rhythms that help us with the whole development cycle. </span><span class="koboSpan" id="kobo.3.3">By following the rhythms, we have a guide on what to do next at each step. </span><span class="koboSpan" id="kobo.3.4">It is helpful to have this technical structure that allows us to think deeply about engineering good code and then capture </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the results.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The first rhythm was covered in the last chapter. </span><span class="koboSpan" id="kobo.5.2">Inside each test, we have a rhythm of writing the Arrange, Act, and Assert sections. </span><span class="koboSpan" id="kobo.5.3">We’ll add some detailed observations on succeeding with this next. </span><span class="koboSpan" id="kobo.5.4">We’ll go on to cover the larger rhythm that guides us as we refine our code, known as the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">red, green, refactor</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">RGR</span></strong><span class="koboSpan" id="kobo.9.1">) cycle. </span><span class="koboSpan" id="kobo.9.2">Together, they help us craft our code to be easy to integrate into the broader application and made of clean, simple-to-understand code. </span><span class="koboSpan" id="kobo.9.3">Applying these two rhythms ensures that we deliver high-quality code at pace. </span><span class="koboSpan" id="kobo.9.4">It provides us with several small milestones to hit during each coding session. </span><span class="koboSpan" id="kobo.9.5">This is highly motivating, as we gain a sense of steady progress toward our goal of building </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Following the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">RGR cycle</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Writing our next tests </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">for Wordz</span></span></li>
</ul>
<h1 id="_idParaDest-110"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">The final code in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter06"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter06</span></a><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">It is recommended to follow along with the exercise by typing the code in yourself – and thinking about all the decisions we will be making as </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">we go.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.22.1">Following the RGR cycle</span></h1>
<p><span class="koboSpan" id="kobo.23.1">We saw in the previous chapter</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.24.1"> how a single unit test is split into three parts, known as the Arrange, Act, and Assert</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.25.1"> sections. </span><span class="koboSpan" id="kobo.25.2">This forms a simple rhythm of work that guides us through writing every test. </span><span class="koboSpan" id="kobo.25.3">It forces us to design how our code is going to be used – the outside of our code. </span><span class="koboSpan" id="kobo.25.4">If we think of an object as being an encapsulation boundary, it makes sense to talk about what is inside and outside that boundary. </span><span class="koboSpan" id="kobo.25.5">The public methods form the outside of our object. </span><span class="koboSpan" id="kobo.25.6">The Arrange, Act and Assert rhythm helps us </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">design those.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">We’re using the word </span><em class="italic"><span class="koboSpan" id="kobo.28.1">rhythm</span></em><span class="koboSpan" id="kobo.29.1"> here in an almost musical sense. </span><span class="koboSpan" id="kobo.29.2">It’s a constant, repeating theme that holds our work together. </span><span class="koboSpan" id="kobo.29.3">There is a regular flow of work in writing tests, writing code, improving that code, and then deciding which test to write next. </span><span class="koboSpan" id="kobo.29.4">Every test and piece of code will be different, but the rhythm of work is the same, as though it were a steady beat in an </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">ever-changing song.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Once we have written our test, we turn to creating the code that is inside our object – the private fields and methods. </span><span class="koboSpan" id="kobo.31.2">For this, we make use of another rhythm called RGR. </span><span class="koboSpan" id="kobo.31.3">This is a three-step process that helps us to build confidence in our test, create a basic implementation of our code, and then refine </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">it safely.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">In this section, we will learn what work needs to be done in each of the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">three phases.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.35.1">Starting on red</span></h2>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.36.1"><img alt="Figure 6.1 – The red phase" src="image/Figure_6.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">Figure 6.1 – The red phase</span></p>
<p><span class="koboSpan" id="kobo.38.1">We always start</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.39.1"> with the first phase called the red phase. </span><span class="koboSpan" id="kobo.39.2">The goal of this phase is to use the Arrange, Act and Assert template to get our test up and running and ready to test the code we will write next. </span><span class="koboSpan" id="kobo.39.3">The most important part of this phase is to make sure that the test does not pass. </span><span class="koboSpan" id="kobo.39.4">We call this a failing test, or a red test, due to the color that most graphical test tools use to indicate a </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">failing test.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">That’s rather counter-intuitive, isn’t it? </span><span class="koboSpan" id="kobo.41.2">We normally aim to make things work right the first time in development. </span><span class="koboSpan" id="kobo.41.3">However, we want our test to fail at this stage to give us confidence that it is working correctly. </span><span class="koboSpan" id="kobo.41.4">If the test passes at this point, it’s a concern. </span><span class="koboSpan" id="kobo.41.5">Why does it pass? </span><span class="koboSpan" id="kobo.41.6">We know that we have not yet written any of the code we are testing. </span><span class="koboSpan" id="kobo.41.7">If the test passes now, that means we either do not need to write any new code or we have made a mistake in the test. </span><span class="koboSpan" id="kobo.41.8">The </span><em class="italic"><span class="koboSpan" id="kobo.42.1">Further reading</span></em><span class="koboSpan" id="kobo.43.1"> section has a link to eight reasons why a test might not be </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">running correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">The most common mistake here is getting the assertion wrong. </span><span class="koboSpan" id="kobo.45.2">Identify the error and fix it before moving on. </span><span class="koboSpan" id="kobo.45.3">We must have that red test in place so that we can see it change from failing to passing</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.46.1"> as we correctly </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">add code.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.48.1">Keep it simple – moving to green</span></h2>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.49.1"><img alt="Figure 6.2 – The green phase" src="image/Figure_6.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.50.1">Figure 6.2 – The green phase</span></p>
<p><span class="koboSpan" id="kobo.51.1">Once we have our failing</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.52.1"> test, we are free to write</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.53.1"> the code that will make it pass. </span><span class="koboSpan" id="kobo.53.2">We call this the production code – the code that will form part of our production system. </span><span class="koboSpan" id="kobo.53.3">We treat our production code as a </span><em class="italic"><span class="koboSpan" id="kobo.54.1">black-box</span></em><span class="koboSpan" id="kobo.55.1"> component. </span><span class="koboSpan" id="kobo.55.2">Think of an integrated </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.56.1">circuit in electronics, or perhaps some kind of mechanical sealed unit. </span><span class="koboSpan" id="kobo.56.2">The component has an inside and an outside. </span><span class="koboSpan" id="kobo.56.3">The inside is where we write our production code. </span><span class="koboSpan" id="kobo.56.4">It is where we hide the data and algorithms of our implementation. </span><span class="koboSpan" id="kobo.56.5">We can do this using any approach we choose – object-oriented, functional, declarative, or procedural. </span><span class="koboSpan" id="kobo.56.6">Anything</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.57.1"> we fancy. </span><span class="koboSpan" id="kobo.57.2">The outside is the </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">Application Programming Interface</span></strong><span class="koboSpan" id="kobo.59.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.60.1">API</span></strong><span class="koboSpan" id="kobo.61.1">). </span><span class="koboSpan" id="kobo.61.2">This is the part we use to connect to our component and use it to build bigger pieces of software. </span><span class="koboSpan" id="kobo.61.3">If we choose an object-oriented approach, this API will be made of public methods on an object. </span><span class="koboSpan" id="kobo.61.4">With TDD, the first piece we connect to is our test, and that gives us fast feedback on how easy the connection is </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">The following diagram</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.64.1"> shows the different pieces – the inside, outside, test code, and other users of </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">our component:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.66.1"><img alt="Figure 6.3 – The inside and outside a ﻿black-box component" src="image/Figure_6.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.67.1">Figure 6.3 – The inside and outside a black-box component</span></p>
<p><span class="koboSpan" id="kobo.68.1">Because our implementation</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.69.1"> is encapsulated, we can change our minds about it later as we learn more without breaking </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the test.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">There are two guidelines for </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">this phase:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Use the simplest code that could possibly work</span></strong><span class="koboSpan" id="kobo.74.1">: Using the simplest code is important. </span><span class="koboSpan" id="kobo.74.2">There can be a temptation to use over-engineered algorithms, or perhaps use the latest language feature just for an excuse to use it. </span><span class="koboSpan" id="kobo.74.3">Resist this temptation. </span><span class="koboSpan" id="kobo.74.4">At this stage, our goal is to get the test to pass and </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">nothing more.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Don’t overthink the implementation details</span></strong><span class="koboSpan" id="kobo.77.1">: We don’t need to overthink this. </span><span class="koboSpan" id="kobo.77.2">We don’t need to write the perfect code on our first attempt. </span><span class="koboSpan" id="kobo.77.3">We can write a single line, a method, several methods, or entirely new classes. </span><span class="koboSpan" id="kobo.77.4">We will improve this code in the next step. </span><span class="koboSpan" id="kobo.77.5">Just remember to make the test pass and not go beyond what this test</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.78.1"> is covering in terms </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">of functionality.</span></span></li>
</ul>
<h2 id="_idParaDest-114"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.80.1">Refactoring to clean code</span></h2>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.81.1"><img alt="Figure 6.4 – The refactor phase" src="image/Figure_6.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.82.1">Figure 6.4 – The refactor phase</span></p>
<p><span class="koboSpan" id="kobo.83.1">This is the</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.84.1"> phase where we go</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.85.1"> into software engineering mode. </span><span class="koboSpan" id="kobo.85.2">We have some working, simple code with a test that passes. </span><span class="koboSpan" id="kobo.85.3">Now is the time to refine that into clean code – meaning code that will be easy to read later. </span><span class="koboSpan" id="kobo.85.4">With the confidence that a passing test provides, we are free to apply any valid refactoring technique to our code. </span><span class="koboSpan" id="kobo.85.5">Some examples of refactoring techniques we can use during this phase include </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.87.1">Extracting a method to remove </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">duplicated code</span></span></li>
<li><span class="koboSpan" id="kobo.89.1">Renaming a method to express what it </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">does better</span></span></li>
<li><span class="koboSpan" id="kobo.91.1">Renaming a variable to express what it </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">contains better</span></span></li>
<li><span class="koboSpan" id="kobo.93.1">Splitting a long method into several </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">smaller ones</span></span></li>
<li><span class="koboSpan" id="kobo.95.1">Extracting a </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">smaller class</span></span></li>
<li><span class="koboSpan" id="kobo.97.1">Combining a long parameter list into its </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">own class</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.99.1">All these techniques have one goal: to make our code easier to understand. </span><span class="koboSpan" id="kobo.99.2">This will make it easier to maintain. </span><span class="koboSpan" id="kobo.99.3">Remember to keep that green test passing throughout these changes. </span><span class="koboSpan" id="kobo.99.4">By the end of this phase, we will have a unit test covering a piece of production code that we have engineered to be easy to work with in the future. </span><span class="koboSpan" id="kobo.99.5">That’s a good place </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Now we’re familiar</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.102.1"> with what to do in each phase of the RGR</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.103.1"> cycle, let’s apply that to our </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Wordz application.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.105.1">Writing our next tests for Wordz</span></h1>
<p><span class="koboSpan" id="kobo.106.1">So, what should we write</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.107.1"> for our next</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.108.1"> tests? </span><span class="koboSpan" id="kobo.108.2">What would be a useful and small-enough step so that we do not fall into the trap of writing beyond what our tests can support? </span><span class="koboSpan" id="kobo.108.3">In this section, we will continue building out the Wordz application scoring system using TDD. </span><span class="koboSpan" id="kobo.108.4">We will discuss how we choose to move forward at </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">each step.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">For the next test, a good choice is to play it safe and move only a small step further. </span><span class="koboSpan" id="kobo.110.2">We will add a test for a single correct letter. </span><span class="koboSpan" id="kobo.110.3">This will drive out our first piece of genuine </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">application logic:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.112.1">Let’s start on red. </span><span class="koboSpan" id="kobo.112.2">Write a failing test for a single, </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">correct letter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.114.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
public void oneCorrectLetter() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.116.1">
   var word = new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.117.1">
   var score = word.guess("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.118.1">
   assertThat(score.letter(0))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.119.1">
      .isEqualTo(Letter.CORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.120.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.121.1">This test is intentionally similar to the one before. </span><span class="koboSpan" id="kobo.121.2">The difference is that it tests for a letter being correct, rather than being incorrect. </span><span class="koboSpan" id="kobo.121.3">We have used the same word – a single letter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">"A"</span></strong><span class="koboSpan" id="kobo.123.1"> – intentionally. </span><span class="koboSpan" id="kobo.123.2">This is important</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.124.1"> when writing tests – use test data that helps</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.125.1"> to tell the story of what we are testing and why. </span><span class="koboSpan" id="kobo.125.2">The story here is that the same word with a different guess will lead to a different score – obviously key to the problem we are solving. </span><span class="koboSpan" id="kobo.125.3">Our two test cases completely cover both possible outcomes of any guess of a </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">single-letter word.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">Using our IDE auto-completion features, we quickly arrive at changes to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">class Word</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.130.1">Now let’s move to green by adding the production code to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">test pass:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.132.1">
public class Word {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.133.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">private final String word</span></strong><span class="koboSpan" id="kobo.135.1">;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.136.1">
    public Word(String correctWord) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.137.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">this.word = correctWord</span></strong><span class="koboSpan" id="kobo.139.1">;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.140.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.141.1">
    public Score guess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.142.1">
        var score = new </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Score(word);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.144.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">score.assess( 0, attempt );</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.146.1">
        return score;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.147.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.148.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.149.1">The goal here is to get the new</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.150.1"> test to pass while keeping the existing test passing. </span><span class="koboSpan" id="kobo.150.2">We don’t want to break</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.151.1"> any existing code. </span><span class="koboSpan" id="kobo.151.2">We’ve added a field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">word</span></strong><span class="koboSpan" id="kobo.153.1">, which will store the word we are supposed to be guessing. </span><span class="koboSpan" id="kobo.153.2">We’ve added a public constructor to initialize this field. </span><span class="koboSpan" id="kobo.153.3">We have added code into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">guess()</span></strong><span class="koboSpan" id="kobo.155.1"> method to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Score</span></strong><span class="koboSpan" id="kobo.157.1"> object. </span><span class="koboSpan" id="kobo.157.2">We decide to add a method to this </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Score</span></strong><span class="koboSpan" id="kobo.159.1"> class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">assess()</span></strong><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">This method has the responsibility of assessing what our guess should score. </span><span class="koboSpan" id="kobo.161.3">We decide that </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">assess()</span></strong><span class="koboSpan" id="kobo.163.1"> should have two parameters. </span><span class="koboSpan" id="kobo.163.2">The first parameter is a zero-based index for which letter of the word we wish to assess a score. </span><span class="koboSpan" id="kobo.163.3">The second parameter is our guess at what the word </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">might be.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">We use the IDE to help us write </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">class Score</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
public class Score {
    private final String correct;
    </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">private Letter result = Letter.INCORRECT ;</span></strong><span class="koboSpan" id="kobo.170.1">
    public Score(String correct) {
        </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">this.correct = correct;</span></strong><span class="koboSpan" id="kobo.172.1">
    }
    public Letter letter(int position) {
        </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">return result;</span></strong><span class="koboSpan" id="kobo.174.1">
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.175.1">    public void assess(int position, String attempt) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.176.1">        if ( correct.charAt(position) == attempt.            charAt(position)){</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.177.1">            result = Letter.CORRECT;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.178.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.179.1">    }</span></strong><span class="koboSpan" id="kobo.180.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.181.1">To cover the new behavior</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.182.1"> tested by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">oneCorrectLetter()</span></strong><span class="koboSpan" id="kobo.184.1"> test, we add</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.185.1"> the preceding code. </span><span class="koboSpan" id="kobo.185.2">Instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">assess()</span></strong><span class="koboSpan" id="kobo.187.1"> method always returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Letter.INCORRECT</span></strong><span class="koboSpan" id="kobo.189.1"> as it did previously, the new test has forced a new direction. </span><span class="koboSpan" id="kobo.189.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">assess()</span></strong><span class="koboSpan" id="kobo.191.1"> method must now be able to return the correct score when a guessed letter </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">is correct.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">To achieve this, we added a field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">result</span></strong><span class="koboSpan" id="kobo.195.1"> to hold the latest score, code to return that result from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">letter()</span></strong><span class="koboSpan" id="kobo.197.1"> method, and code into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">assess()</span></strong><span class="koboSpan" id="kobo.199.1"> method to check whether the first letter of our guess matches the first letter of our word. </span><span class="koboSpan" id="kobo.199.2">If we have got this right, both of our tests should </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">now pass.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Run all the tests to see how we </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">are doing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.203.1"><img alt="Figure 6.﻿5 – Two tests passing" src="image/Figure_6.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.204.1">Figure 6.5 – Two tests passing</span></p>
<p><span class="koboSpan" id="kobo.205.1">There’s a lot to review here. </span><span class="koboSpan" id="kobo.205.2">Notice how both of our tests are passing. </span><span class="koboSpan" id="kobo.205.3">By running all the tests so far, we have proven that we have not broken anything. </span><span class="koboSpan" id="kobo.205.4">The changes we made to our code added the new feature and did not break any existing features. </span><span class="koboSpan" id="kobo.205.5">That’s powerful. </span><span class="koboSpan" id="kobo.205.6">Take note of another obvious aspect – we know our code works. </span><span class="koboSpan" id="kobo.205.7">We do not have to wait until a manual test phase, wait until some integration point, or wait until the user interface is ready. </span><span class="koboSpan" id="kobo.205.8">We know our code works now. </span><span class="koboSpan" id="kobo.205.9">As a minor point, note the time duration of 0.103 seconds. </span><span class="koboSpan" id="kobo.205.10">The two tests were completed in one-tenth of one second, much faster than testing this manually. </span><span class="koboSpan" id="kobo.205.11">Not bad </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Design-wise, we have moved</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.208.1"> on. </span><span class="koboSpan" id="kobo.208.2">We have moved past</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.209.1"> the hard-coded </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Letter.INCORRECT</span></strong><span class="koboSpan" id="kobo.211.1"> result with code that can detect both correct and incorrect guesses. </span><span class="koboSpan" id="kobo.211.2">We have added the important design concept of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">assess()</span></strong><span class="koboSpan" id="kobo.213.1"> method into </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">class Score</span></strong><span class="koboSpan" id="kobo.215.1">. </span><span class="koboSpan" id="kobo.215.2">This is significant. </span><span class="koboSpan" id="kobo.215.3">Our code now reveals a design; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">Score</span></strong><span class="koboSpan" id="kobo.217.1"> object will know the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">word</span></strong><span class="koboSpan" id="kobo.219.1"> and will be able to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">assess()</span></strong><span class="koboSpan" id="kobo.221.1"> method against the guess, </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">attempt</span></strong><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">The terminology used here forms a good description of the problem we are solving. </span><span class="koboSpan" id="kobo.223.3">We want to assess a guess to return a </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">word score.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Now that the test passes, we can move on – but an important part of TDD is continuously improving our code and working toward a better design, guided by tests. </span><span class="koboSpan" id="kobo.225.2">We now enter the refactor phase of the RGR cycle. </span><span class="koboSpan" id="kobo.225.3">Once again, TDD hands control back to us. </span><span class="koboSpan" id="kobo.225.4">Do we want to refactor? </span><span class="koboSpan" id="kobo.225.5">What things should we refactor? </span><span class="koboSpan" id="kobo.225.6">Why? </span><span class="koboSpan" id="kobo.225.7">Is it worth doing this right now or can we defer this until a </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">later step?</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Let’s review the code and look for </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">code smells</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">A code smell is an indication that the implementation</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.230.1"> may need improving. </span><span class="koboSpan" id="kobo.230.2">The name comes from the idea of the smell that food has once it starts to </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">go off.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">One code smell is duplicated code. </span><span class="koboSpan" id="kobo.232.2">Alone, a little duplicated code might be okay. </span><span class="koboSpan" id="kobo.232.3">But it is an early warning that perhaps too much copy-and-paste has been used, and that we have failed to capture an important concept more directly. </span><span class="koboSpan" id="kobo.232.4">Let’s review our code to eliminate duplication. </span><span class="koboSpan" id="kobo.232.5">We can also look for two other common code smells – unclear naming, and blocks of code that would be easier to read if they were extracted out into their own method. </span><span class="koboSpan" id="kobo.232.6">Obviously, this is subjective, and we will all have different views on what </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">to change.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.234.1">Defining code smells</span></p>
<p class="callout"><span class="koboSpan" id="kobo.235.1">The term code smell originally</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.236.1"> appeared on the C2 wiki. </span><span class="koboSpan" id="kobo.236.2">It’s worth a read to see the given examples</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.237.1"> of code smells. </span><span class="koboSpan" id="kobo.237.2">It has a helpful definition</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.238.1"> that notes a code smell is something that needs review but may not necessarily</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.239.1"> need to be changed: </span></p>
<p class="callout"><a href="https://wiki.c2.com/?CodeSmell"><span class="No-Break"><span class="koboSpan" id="kobo.240.1">https://wiki.c2.com/?CodeSmell</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.241.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Let’s reflect on the inside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">assess()</span></strong><span class="koboSpan" id="kobo.244.1"> method. </span><span class="koboSpan" id="kobo.244.2">It just seems cluttered with too much code. </span><span class="koboSpan" id="kobo.244.3">Let’s extract a helper method to add some clarity. </span><span class="koboSpan" id="kobo.244.4">We can always revert the change if we feel it </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">doesn’t help.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.246.1">Let’s refactor. </span><span class="koboSpan" id="kobo.246.2">Extract an </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">isCorrectLetter()</span></strong><span class="koboSpan" id="kobo.248.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">for clarity:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.250.1">
public void assess(int position, String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
    if (</span><strong class="bold"><span class="koboSpan" id="kobo.252.1">isCorrectLetter</span></strong><span class="koboSpan" id="kobo.253.1">(position, attempt)){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.254.1">
        result = Letter.CORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.255.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.256.1">
}</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.257.1">private boolean isCorrectLetter(int position,</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.258.1">
                                </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">String attempt) {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.260.1">    return correct.charAt(position) ==</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.261.1">
           </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">attempt.charAt(position);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.263.1">}</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.264.1">Once more, we run all the tests to prove this refactoring has not broken anything. </span><span class="koboSpan" id="kobo.264.2">The tests pass. </span><span class="koboSpan" id="kobo.264.3">In the preceding code, we have split out a complex conditional statement into its own private method. </span><span class="koboSpan" id="kobo.264.4">The motivation was to get a method name into the code. </span><span class="koboSpan" id="kobo.264.5">This is an effective way of commenting on our code – in a way that the compiler helps us keep up to date. </span><span class="koboSpan" id="kobo.264.6">It helps the calling code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">assess()</span></strong><span class="koboSpan" id="kobo.266.1"> method tell a better story. </span><span class="koboSpan" id="kobo.266.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">if</span></strong><span class="koboSpan" id="kobo.268.1"> statement now says “if this is a correct letter” more or less in English. </span><span class="koboSpan" id="kobo.268.2">That is a powerful aid </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">to readability.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.270.1">Readability happens during writing not reading</span></p>
<p class="callout"><span class="koboSpan" id="kobo.271.1">A common question</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.272.1"> from coding beginners is “How can I improve my ability to </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">read code?”</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.274.1">This is a valid question, as any line of code will be read by human programmers many more times than it was written. </span><span class="koboSpan" id="kobo.274.2">Readability is won or lost when you write the code. </span><span class="koboSpan" id="kobo.274.3">Any line of code can be written either to be easy to read or hard to read. </span><span class="koboSpan" id="kobo.274.4">We get to choose as writers. </span><span class="koboSpan" id="kobo.274.5">If we consistently choose ease of reading over anything else, others will find our code easy </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">to read.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.276.1">Badly written code is hard to read. </span><span class="koboSpan" id="kobo.276.2">Sadly, it is easy </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">to write.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">There are two more</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.279.1"> areas I want to refactor</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.280.1"> at this stage. </span><span class="koboSpan" id="kobo.280.2">The first is a simple method to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">test readability.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">Let’s refactor the test code to improve its clarity. </span><span class="koboSpan" id="kobo.282.2">We will add a </span><em class="italic"><span class="koboSpan" id="kobo.283.1">custom </span></em><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">assert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
@Test
public void oneCorrectLetter() {
    var word = new Word("A");
    var score = word.guess("A");
    </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">assertScoreForLetter(score, 0, Letter.CORRECT)</span></strong><span class="koboSpan" id="kobo.288.1">;
}
</span><strong class="bold"><span class="koboSpan" id="kobo.289.1">private void assertScoreForLetter(Score score,</span></strong><span class="koboSpan" id="kobo.290.1">
                  </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">int position, Letter expected) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.292.1">    assertThat(score.letter(position))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.293.1">          .isEqualTo(expected);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.294.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.295.1">The preceding code</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.296.1"> has taken the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">assertThat()</span></strong><span class="koboSpan" id="kobo.298.1"> assertion and moved</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.299.1"> it into its own private method. </span><span class="koboSpan" id="kobo.299.2">We have called this method </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">assertScoreForLetter()</span></strong><span class="koboSpan" id="kobo.301.1"> and given it a signature that describes what information is needed. </span><span class="koboSpan" id="kobo.301.2">This change provides a more direct description of what the test is doing while reducing some duplicated code. </span><span class="koboSpan" id="kobo.301.3">It also protects us against changes in the implementation of the assertion. </span><span class="koboSpan" id="kobo.301.4">This seems to be a step toward a more comprehensive assertion, which we will need once we support guesses with more letters. </span><span class="koboSpan" id="kobo.301.5">Once again, instead of adding a comment to the source code, we have used a method name to capture the intent of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">assertThat()</span></strong><span class="koboSpan" id="kobo.303.1"> code. </span><span class="koboSpan" id="kobo.303.2">Writing </span><em class="italic"><span class="koboSpan" id="kobo.304.1">AssertJ custom matchers</span></em><span class="koboSpan" id="kobo.305.1"> are another way of </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">doing this.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">The next refactoring we may want to do is a little more controversial, as it is a design change. </span><span class="koboSpan" id="kobo.307.2">Let’s do the refactoring, discuss it, then possibly revert the code if we don’t like it. </span><span class="koboSpan" id="kobo.307.3">That will save hours of wondering about what the change would </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">look like.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.309.1">Let’s change how we specify the letter position to check in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">assess()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.311.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.312.1">
public class Score {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.313.1">
    private final String correct;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.314.1">
    private Letter result = Letter.INCORRECT ;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.315.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">private int position</span></strong><span class="koboSpan" id="kobo.317.1">;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.318.1">
    public Score(String correct) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.319.1">
        this.correct = correct;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.320.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.321.1">
    public Letter letter(int position) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.322.1">
        return result;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.324.1">
    public void assess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.325.1">
        if (</span><strong class="bold"><span class="koboSpan" id="kobo.326.1">isCorrectLetter(attempt)</span></strong><span class="koboSpan" id="kobo.327.1">){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.328.1">
            result = Letter.CORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.329.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.330.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.331.1">
    private boolean </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">isCorrectLetter(String attempt)</span></strong><span class="koboSpan" id="kobo.333.1"> {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.334.1">
        return correct.charAt(position) == attempt.        charAt(position);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.335.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.336.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.337.1">We’ve removed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">position</span></strong><span class="koboSpan" id="kobo.339.1"> parameter</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.340.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">assess()</span></strong><span class="koboSpan" id="kobo.342.1"> method and converted</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.343.1"> it into a field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">position</span></strong><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">The intention is to simplify the usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">assess()</span></strong><span class="koboSpan" id="kobo.347.1"> method. </span><span class="koboSpan" id="kobo.347.2">It no longer needs to explicitly state which position is being assessed. </span><span class="koboSpan" id="kobo.347.3">That makes the code easier to call. </span><span class="koboSpan" id="kobo.347.4">The code we have just added will only work in the case where the position is zero. </span><span class="koboSpan" id="kobo.347.5">This is fine, as this is the only thing required by our tests at this stage. </span><span class="koboSpan" id="kobo.347.6">We will make this code work for non-zero </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">values later.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">The reason this is a controversial change is that it requires us to change the test code to reflect that change in the method signature. </span><span class="koboSpan" id="kobo.349.2">I am prepared to accept this, knowing that I can use my IDE-automated refactoring support to do this safely. </span><span class="koboSpan" id="kobo.349.3">It also introduces a risk: we must ensure that position is set to the correct value before we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">isCorrectLetter()</span></strong><span class="koboSpan" id="kobo.351.1">. </span><span class="koboSpan" id="kobo.351.2">We’ll see how this develops. </span><span class="koboSpan" id="kobo.351.3">This may make the code more difficult to understand, in which case the simplified </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">assess()</span></strong><span class="koboSpan" id="kobo.353.1"> method probably will not be worth it. </span><span class="koboSpan" id="kobo.353.2">We can change our approach if we find this to be </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">the case.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">We are now at a point</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.356.1"> where the code is complete for any single-letter</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.357.1"> word. </span><span class="koboSpan" id="kobo.357.2">What should we attempt next? </span><span class="koboSpan" id="kobo.357.3">It seems as though we should move on to two-letter words and see how that changes our tests </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">and logic.</span></span></p>
<h3><span class="koboSpan" id="kobo.359.1">Advancing the design with two-letter combinations</span></h3>
<p><span class="koboSpan" id="kobo.360.1">We can proceed</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.361.1"> to add tests aimed at getting the code</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.362.1"> to handle two-letter combinations. </span><span class="koboSpan" id="kobo.362.2">This is an obvious step to take after getting the code to work with a single letter. </span><span class="koboSpan" id="kobo.362.3">To do this, we will need to introduce a new concept into the code: a letter can be present in the word, but not in the position we guessed it </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">to be:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.364.1">Let’s begin by writing a test for a second letter that is in the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">wrong position:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.367.1">
void secondLetterWrongPosition() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.368.1">
    var word = new Word("AR");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.369.1">
    var score = word.guess("ZA");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.370.1">
    assertScoreForLetter(score, 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
                         Letter.PART_CORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.373.1">Let’s change the code inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">assess()</span></strong><span class="koboSpan" id="kobo.375.1"> method to make this pass and keep the existing </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">tests passing.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.377.1">Let’s add initial code to check all the letters in </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">our guess:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.379.1">
public void assess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">for (char current: attempt.toCharArray())</span></strong><span class="koboSpan" id="kobo.382.1"> {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.383.1">
        if (isCorrectLetter(current)) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.384.1">
            result = Letter.CORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.386.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.387.1">
}</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.388.1">private boolean isCorrectLetter(char currentLetter) {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.389.1">    return correct.charAt(position) == currentLetter;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.390.1">}</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.391.1">The main change</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.392.1"> here is to assess</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.393.1"> all of the letters in </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">attempt</span></strong><span class="koboSpan" id="kobo.395.1"> and not assume it only has one letter in it. </span><span class="koboSpan" id="kobo.395.2">That, of course, was the purpose of this test – to drive out this behavior. </span><span class="koboSpan" id="kobo.395.3">By choosing to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">attempt</span></strong><span class="koboSpan" id="kobo.397.1"> string into an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">char</span></strong><span class="koboSpan" id="kobo.399.1">, the code seems to read quite well. </span><span class="koboSpan" id="kobo.399.2">This simple algorithm iterates over each </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">char</span></strong><span class="koboSpan" id="kobo.401.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">current</span></strong><span class="koboSpan" id="kobo.403.1"> variable to represent the current letter to be assessed. </span><span class="koboSpan" id="kobo.403.2">This requires the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">isCorrectLetter()</span></strong><span class="koboSpan" id="kobo.405.1"> method to be refactored for it to accept and work with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">char</span></strong><span class="koboSpan" id="kobo.407.1"> input – well, either that or converting </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">char</span></strong><span class="koboSpan" id="kobo.409.1"> to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">String</span></strong><span class="koboSpan" id="kobo.411.1">, and that </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">looks ugly.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">The original tests for single-letter behaviors still pass, as they must. </span><span class="koboSpan" id="kobo.413.2">We know the logic inside our loop cannot possibly be correct – we are simply overwriting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">result</span></strong><span class="koboSpan" id="kobo.415.1"> field, which can only store a result for one letter at most. </span><span class="koboSpan" id="kobo.415.2">We need to improve that logic, but we won’t do that until</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.416.1"> we have added a test for that. </span><span class="koboSpan" id="kobo.416.2">Working this way is known as </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">triangulation</span></strong><span class="koboSpan" id="kobo.418.1"> – we make the code more general-purpose as we add more specific tests. </span><span class="koboSpan" id="kobo.418.2">For our next step, we will add code to detect when our attempted letter occurs in the word in some </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">other position.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.420.1">Let’s add code</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.421.1"> to detect when a correct letter</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.422.1"> is in the </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">wrong position:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.424.1">
public void assess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.425.1">
    for (char current: attempt.toCharArray()) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.426.1">
        if (isCorrectLetter(current)) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.427.1">
            result = Letter.CORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
        } </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">else if (occursInWord(current)) {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.430.1">            result = Letter.PART_CORRECT;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.431.1">        }</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.432.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.433.1">
}</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.434.1">    private boolean occursInWord(char current) {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.435.1">        return</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.436.1">          correct.contains(String.valueOf(current));</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.437.1">    }</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.438.1">We’ve added a call to a new private method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">occursInWord(),</span></strong><span class="koboSpan" id="kobo.440.1"> which will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">true</span></strong><span class="koboSpan" id="kobo.442.1"> if the current letter occurs anywhere in the word. </span><span class="koboSpan" id="kobo.442.2">We have already established that this current letter is not in the right place. </span><span class="koboSpan" id="kobo.442.3">This should give us a clear result for a correct letter not in the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">correct position.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">This code makes all three tests pass. </span><span class="koboSpan" id="kobo.444.2">Immediately, this is suspicious, as it shouldn’t happen. </span><span class="koboSpan" id="kobo.444.3">We already know that our logic overwrites the single </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">result</span></strong><span class="koboSpan" id="kobo.446.1"> field and this means that many combinations will fail. </span><span class="koboSpan" id="kobo.446.2">What has happened is that our latest test is fairly weak. </span><span class="koboSpan" id="kobo.446.3">We could go back and strengthen that test, by adding an extra assertion. </span><span class="koboSpan" id="kobo.446.4">Alternatively, we can leave it as it is and write another test. </span><span class="koboSpan" id="kobo.446.5">Dilemmas such as this are common in development and it’s not usually worth spending too much time thinking about them. </span><span class="koboSpan" id="kobo.446.6">Either way will move </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">us forward.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">Let’s add another </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.449.1">test to completely exercise</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.450.1"> the behavior around the second letter being in the </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">wrong position.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.452.1">Add a new test exercising all three </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">scoring possibilities:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.454.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.455.1">
void allScoreCombinations() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
    var word = new Word("ARI");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
    var score = word.guess("ZAI");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
    assertScoreForLetter(score, 0, Letter.INCORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.459.1">
    assertScoreForLetter(score, 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.460.1">
                         Letter.PART_CORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.461.1">
    assertScoreForLetter(score, 2, Letter.CORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.462.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.463.1">As expected, this test fails. </span><span class="koboSpan" id="kobo.463.2">The reason is obvious upon inspecting the production code. </span><span class="koboSpan" id="kobo.463.3">It’s because we were storing results in the same single-valued field. </span><span class="koboSpan" id="kobo.463.4">Now that we have a failing test for that, we can correct the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">scoring logic.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.465.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">List</span></strong><span class="koboSpan" id="kobo.467.1"> of results to store the result for each letter </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">position separately:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.469.1">
public class Score {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
    private final String correct;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
    private final </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">List&lt;Letter&gt; results =</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
                             </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">new ArrayList&lt;&gt;()</span></strong><span class="koboSpan" id="kobo.475.1">;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
    private int position;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.477.1">
    public Score(String correct) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.478.1">
        this.correct = correct;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.479.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.480.1">
    public Letter letter(int position) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.481.1">
        return </span><strong class="bold"><span class="koboSpan" id="kobo.482.1">results.get(position)</span></strong><span class="koboSpan" id="kobo.483.1">;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.485.1">
    public void assess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.486.1">
        for (char current: attempt.toCharArray()) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.487.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.488.1">if (isCorrectLetter(current)) {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.489.1">                results.add(Letter.CORRECT);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.490.1">            } else if (occursInWord(current)) {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.491.1">                </span></strong><strong class="bold"><span class="koboSpan" id="kobo.492.1">results.add(Letter.PART_CORRECT);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.493.1">            } else {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.494.1">                results.add(Letter.INCORRECT);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.495.1">            }</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.496.1">            position++;</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.497.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.498.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.499.1">
    private boolean occursInWord(char current) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.500.1">
        return</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.501.1">
         correct.contains(String.valueOf(current));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.502.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.503.1">
    private boolean isCorrectLetter(char</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.504.1">
      currentLetter) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.505.1">
        return correct.charAt(position) ==</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.506.1">
                 currentLetter;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.507.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.508.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.509.1">This took a couple</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.510.1"> of attempts to get right, driven</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.511.1"> by failures in the test we just added. </span><span class="koboSpan" id="kobo.511.2">The preceding end result passes all four tests, proving it can correctly score all combinations in a three-letter word. </span><span class="koboSpan" id="kobo.511.3">The main change was to replace the single-valued </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">result</span></strong><span class="koboSpan" id="kobo.513.1"> field with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">ArrayList</span></strong><span class="koboSpan" id="kobo.515.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">results</span></strong><span class="koboSpan" id="kobo.517.1"> and change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">letter(position)</span></strong><span class="koboSpan" id="kobo.519.1"> implementation method to use this new collection of results. </span><span class="koboSpan" id="kobo.519.2">Running that change caused a failure, as the code could no longer detect an incorrect letter. </span><span class="koboSpan" id="kobo.519.3">Previously, that had been handled by the default value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">result</span></strong><span class="koboSpan" id="kobo.521.1"> field. </span><span class="koboSpan" id="kobo.521.2">Now, we must do that explicitly for each letter. </span><span class="koboSpan" id="kobo.521.3">We then need to update the position within the loop to track which letter position we </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">are assessing.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">We’ve added a test, watched it go red and fail, then added code to make the test go green and pass, so now it is time to refactor. </span><span class="koboSpan" id="kobo.523.2">There are things about both the test and the production code that don’t seem </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">quite right.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">In the production code </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">class Score</span></strong><span class="koboSpan" id="kobo.527.1">, it is the loop body of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">assess()</span></strong><span class="koboSpan" id="kobo.529.1"> method that seems unwieldy. </span><span class="koboSpan" id="kobo.529.2">It has a long loop body with logic in it and a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">if</span></strong><span class="koboSpan" id="kobo.531.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">else</span></strong><span class="koboSpan" id="kobo.533.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">if</span></strong><span class="koboSpan" id="kobo.535.1"> blocks. </span><span class="koboSpan" id="kobo.535.2">It feels as though the code could be made clearer. </span><span class="koboSpan" id="kobo.535.3">We can extract the loop body into a method. </span><span class="koboSpan" id="kobo.535.4">The method name then gives us a place to describe what is happening to each thing. </span><span class="koboSpan" id="kobo.535.5">The loop then becomes shorter and simpler to grasp. </span><span class="koboSpan" id="kobo.535.6">We can also replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">if</span></strong><span class="koboSpan" id="kobo.537.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">else</span></strong><span class="koboSpan" id="kobo.539.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">if</span></strong><span class="koboSpan" id="kobo.541.1"> ladders with a </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">simpler construct.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.543.1">Let’s extract the logic inside the loop body into a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">scoreFor()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.545.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.546.1">
public void assess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
    for (char current: attempt.toCharArray()) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">results.add( scoreFor(current) );</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.550.1">
        position++;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.551.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.552.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.553.1">
private Letter scoreFor(char current) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.554.1">
    if (isCorrectLetter(current)) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
        return Letter.CORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
    if (occursInWord(current)) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.558.1">
        return Letter.PART_CORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.559.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.560.1">
    return Letter.INCORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.562.1">This reads far more</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.563.1"> clearly. </span><span class="koboSpan" id="kobo.563.2">The body</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.564.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">scoreFor()</span></strong><span class="koboSpan" id="kobo.566.1"> method is now a concise description of the rules for scoring each letter. </span><span class="koboSpan" id="kobo.566.2">We replaced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">if</span></strong><span class="koboSpan" id="kobo.568.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">else</span></strong><span class="koboSpan" id="kobo.570.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">if</span></strong><span class="koboSpan" id="kobo.572.1"> construction with a simpler </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">if</span></strong><span class="koboSpan" id="kobo.574.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">return</span></strong><span class="koboSpan" id="kobo.576.1"> construction. </span><span class="koboSpan" id="kobo.576.2">We work out what the score is, then exit the </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">method immediately.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">The next job is to clean up the test code. </span><span class="koboSpan" id="kobo.578.2">In TDD, test code is given equal priority to production code. </span><span class="koboSpan" id="kobo.578.3">It forms part of the documentation about the system. </span><span class="koboSpan" id="kobo.578.4">It needs to be maintained and extended alongside the production code. </span><span class="koboSpan" id="kobo.578.5">We treat test code readability with the same importance as </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">production code.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">The code smell with the test code is around the asserts. </span><span class="koboSpan" id="kobo.580.2">Two things could be improved. </span><span class="koboSpan" id="kobo.580.3">There is an obvious duplication in the code that we could eliminate. </span><span class="koboSpan" id="kobo.580.4">There is also a question about how many assertions should be made in </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">one test.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.582.1">Let’s remove</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.583.1"> the duplicated assertion</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.584.1"> code by extracting </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">a method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.586.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.587.1">
void allScoreCombinations() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.588.1">
    var word = new Word("ARI");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.589.1">
    var score = word.guess("ZAI");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.590.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.591.1">assertScoreForGuess(score, INCORRECT,</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.592.1">
                               </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">PART_CORRECT,</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.594.1">                               CORRECT);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.595.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">assertScoreForGuess</span></strong><span class="koboSpan" id="kobo.598.1">(Score score, Letter…</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
    for (int position=0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
             position &lt; expectedScores.length;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
             position++){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.602.1">
        Letter expected = expectedScores[position];</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.603.1">
        assertThat(score.letter(position))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.604.1">
            .isEqualTo(expected);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.605.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.606.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.607.1">By extracting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">assertScoreForGuess()</span></strong><span class="koboSpan" id="kobo.609.1"> method, we create</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.610.1"> a way to check the scores</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.611.1"> for a variable number of letters. </span><span class="koboSpan" id="kobo.611.2">This eliminates those copy-pasted </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">assert</span></strong><span class="koboSpan" id="kobo.613.1"> lines that we had and raises the level of abstraction. </span><span class="koboSpan" id="kobo.613.2">The test code reads more clearly as we now describe tests in terms of the order of </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">INCORRECT, PART_CORRECT, CORRECT</span></strong><span class="koboSpan" id="kobo.615.1"> that we expect the score to be in. </span><span class="koboSpan" id="kobo.615.2">By adding a static import to those </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">enum</span></strong><span class="koboSpan" id="kobo.617.1">s, syntax clutter is also </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">beneficially reduced.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">The earlier tests can now be manually modified to make use of this new assertion helper. </span><span class="koboSpan" id="kobo.619.2">This allows us to inline the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">assertScoreForLetter()</span></strong><span class="koboSpan" id="kobo.621.1"> method, as it no longer </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">adds value.</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.623.1">Now, let’s take a look at the final set of tests following </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">our refactoring:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.625.1">
package com.wordz.domain;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.626.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.627.1">
import static com.wordz.domain.Letter.*;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.628.1">
import static org.assertj.core.api.Assertions.assertThat;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.629.1">
public class WordTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.630.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.631.1">
    public void oneIncorrectLetter() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
        var word = new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.633.1">
        var score = word.guess("Z");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
        assertScoreForGuess(score, INCORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.635.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.637.1">
    public void oneCorrectLetter() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.638.1">
        var word = new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.639.1">
        var score = word.guess("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.640.1">
        assertScoreForGuess(score, CORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.641.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.642.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.643.1">
    public void secondLetterWrongPosition() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.644.1">
        var word = new Word("AR");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.645.1">
        var score = word.guess("ZA");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.646.1">
        assertScoreForGuess(score,  INCORRECT,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.647.1">
                                    PART_CORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.648.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.649.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.650.1">
    public void allScoreCombinations() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.651.1">
        var word = new Word("ARI");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.652.1">
        var score = word.guess("ZAI");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.653.1">
        assertScoreForGuess(score,  INCORRECT,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.654.1">
                                    PART_CORRECT,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.655.1">
                                    CORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.656.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.657.1">
    private void assertScoreForGuess(Score score,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.658.1">
        Letter... </span><span class="koboSpan" id="kobo.658.2">expectedScores) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.659.1">
        for (int position = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.660.1">
              position &lt; expectedScores.length;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.661.1">
              position++) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.662.1">
            Letter expected =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.663.1">
                    expectedScores[position];</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.664.1">
            assertThat(score.letter(position))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.665.1">
                    .isEqualTo(expected);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.666.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.667.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.668.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.669.1">This appears to be a comprehensive set of test cases. </span><span class="koboSpan" id="kobo.669.2">Every line of production code has been driven out as a direct result of adding a new test to explore a new aspect of behavior. </span><span class="koboSpan" id="kobo.669.3">The test code seems easy to read and the production code also seems clearly implemented and simple to call. </span><span class="koboSpan" id="kobo.669.4">The test forms an executable specification of the rules for scoring a guess at </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">a word.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">That’s achieved everything</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.672.1"> we set out to at the start</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.673.1"> of this coding session. </span><span class="koboSpan" id="kobo.673.2">We have grown the capability of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">Score</span></strong><span class="koboSpan" id="kobo.675.1"> class using TDD. </span><span class="koboSpan" id="kobo.675.2">We have followed the RGR cycle to keep both our test code and production code following good engineering practices. </span><span class="koboSpan" id="kobo.675.3">We have robust code, validated by unit tests, and a design that makes this code easy to call from our </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">wider application.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.677.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.678.1">In this chapter, we have applied the RGR cycle to our code. </span><span class="koboSpan" id="kobo.678.2">We’ve seen how this splits the work into separate tasks, which results in confidence in our test, a rapid path to simple production code, and less time spent to improve the maintainability of our code. </span><span class="koboSpan" id="kobo.678.3">We’ve looked at removing code smells from both the production code and the test code. </span><span class="koboSpan" id="kobo.678.4">As part of our work in this chapter, we’ve used ideas that help us move ahead and decide what tests we should write next. </span><span class="koboSpan" id="kobo.678.5">The techniques in this chapter enable us to write multiple tests and incrementally drive out the detailed logic in our </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">production code.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">In the next chapter, we’re going to learn about some object-oriented design ideas known as the SOLID principles, enabling us to use TDD to grow our application </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">still further.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.682.1">Questions and answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.683.1">What are the two key rhythms </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">of TDD?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.685.1">Arrange, Act, Assert, and RGR. </span><span class="koboSpan" id="kobo.685.2">The first rhythm helps us write the body of the test while designing the interface to our production code. </span><span class="koboSpan" id="kobo.685.3">The second rhythm works to help us create and then refine the implementation of that </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">production code.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.687.1">How can we write tests </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">before code?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.689.1">Instead of thinking about how we are going to implement some code, we think about how we are going to call that code. </span><span class="koboSpan" id="kobo.689.2">We capture those design decisions inside a </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">unit test.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.691.1">Should tests be </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">throwaway code?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.693.1">No. </span><span class="koboSpan" id="kobo.693.2">In TDD, unit tests are given equal weight to the production code. </span><span class="koboSpan" id="kobo.693.3">They are written with the same care and are stored in the same code repository. </span><span class="koboSpan" id="kobo.693.4">The only difference is that the test code itself will not be present in the </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">delivered executable.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.695.1">Do we need to refactor after every </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">test pass?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.697.1">No. </span><span class="koboSpan" id="kobo.697.2">Use this time as an opportunity to decide what refactoring is needed. </span><span class="koboSpan" id="kobo.697.3">This applies to both the production code and the test code. </span><span class="koboSpan" id="kobo.697.4">Sometimes, none is needed and we move on. </span><span class="koboSpan" id="kobo.697.5">Other times, we sense that a larger change would be beneficial. </span><span class="koboSpan" id="kobo.697.6">We might choose to defer that larger change until later once we have more code </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">in place.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.699.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.700.1">Getting Green </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.701.1">on Red</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.702.1">An article by Jeff Langr describing eight different ways a test can pass for the wrong reasons. </span><span class="koboSpan" id="kobo.702.2">If we’re aware of these issues, we can avoid them as </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">we work.</span></span></p>
<p><a href="https://medium.com/pragmatic-programmers/3-5-getting-green-on-red-d189240b1c87"><span class="No-Break"><span class="koboSpan" id="kobo.704.1">https://medium.com/pragmatic-programmers/3-5-getting-green-on-red-d189240b1c87</span></span></a></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.705.1">Refactoring: Improving the design of existing code</span></em><span class="koboSpan" id="kobo.706.1">, Martin Fowler (</span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">ISBN 978-0134757599)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.708.1">The definitive guide to refactoring code. </span><span class="koboSpan" id="kobo.708.2">The book describes step-by-step transformations of code that preserve its behavior but improve clarity. </span><span class="koboSpan" id="kobo.708.3">Interestingly, most transformations come in pairs, such as the pair of techniques known as </span><em class="italic"><span class="koboSpan" id="kobo.709.1">Extract Method</span></em><span class="koboSpan" id="kobo.710.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.711.1">Inline Method</span></em><span class="koboSpan" id="kobo.712.1">. </span><span class="koboSpan" id="kobo.712.2">This reflects the </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">trade-offs involved.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.714.1">AssertJ documentation for </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">custom matchers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.716.1">This chapter briefly mentioned </span><em class="italic"><span class="koboSpan" id="kobo.717.1">AssertJ custom matchers</span></em><span class="koboSpan" id="kobo.718.1">. </span><span class="koboSpan" id="kobo.718.2">These are very useful ways of creating reusable customized assertions for your code. </span><span class="koboSpan" id="kobo.718.3">These assertion classes are themselves unit-testable and can be written using test-first TDD. </span><span class="koboSpan" id="kobo.718.4">For that reason alone, they are superior to adding a private method to handle a </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">customized assertion.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">The following link provides many examples provided by the AssertJ distribution </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">on github.</span></span></p>
<p><a href="https://github.com/assertj/assertj-examples/tree/main/assertions-examples/src/test/java/org/assertj/examples/custom"><span class="No-Break"><span class="koboSpan" id="kobo.722.1">https://github.com/assertj/assertj-examples/tree/main/assertions-examples/src/test/java/org/assertj/examples/custom</span></span></a></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer045">
</div>
</div>
</body></html>