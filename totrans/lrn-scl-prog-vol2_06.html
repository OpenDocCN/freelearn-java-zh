<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Next Steps in Object-Oriented Scala</h1>
                
            
            <article>
                
<div class="packt_quote">"I was born not knowing and have only had a little time to change that here and there."</div>
<div class="packt_quote1">– Richard Feynman</div>
<p class="calibre2">The idea of companion objects gave us the feeling that it's important to know how your programming language treats the constructs you write. Suppose you were given a task to generate a <kbd class="calibre11">case</kbd> class with some sensitive parameters (by sensitive, we mean when trying to print that class, those sensitive fields should print some dummy values). What you are going to do in order to achieve that entirely depends on your knowledge of how Scala treats the <kbd class="calibre11">case</kbd> classes, and we learned that in the previous chapter. So, what now? Now it's time to do some composition as well as use inheritance. Remember, we talked about how we should think of a class as a type that we can define? It's a really useful and fun task to mix these types all together and try to make sense out of them and at the same time, add functionalities. That's why we have static typing, isn't it? Let me tell you, it's fun to learn composition while mixing in those types, creating more than one way to access such constructs. And that's what we're going to do in this chapter. We'll have fun and learn. So, this is how we are going to proceed:</p>
<ul class="calibre7">
<li class="calibre8">Composition versus inheritance</li>
<li class="calibre8">Class inheritance</li>
<li class="calibre8">Default and parameterized constructors</li>
<li class="calibre8">Traits</li>
<li class="calibre8">Traits as mix-ins</li>
<li class="calibre8">Linearization</li>
<li class="calibre8">Packaging and importing</li>
<li class="calibre8">Visibility rules</li>
<li class="calibre8">Sealed traits</li>
</ul>
<p class="calibre2">Before we move forward I want to clear this up. The terms <em class="calibre18">composition</em> <span>and <em class="calibre18">i</em></span><em class="calibre18">nheritance</em> will be used in this chapter a lot<em class="calibre18">.</em> It's better if we differentiate these two up front.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Composition and inheritance</h1>
                
            
            <article>
                
<p class="calibre2">In programming terms, to inherit or extend our classes we use the <kbd class="calibre11">extends</kbd> or <kbd class="calibre11">with</kbd> keywords. These are essential for the relationship between two or more classes or similar constructs. This association or relation between two classes or similar constructs can be in the form of inheritance (Is-A) or composition (Has-A). They are two different notions but they converge to some extent. In simple words, <strong class="calibre1">inheritance</strong> is a superclass-subclass relationship where the subclass inherits the implementation of the superclass, whereas <strong class="calibre1">composition</strong> is when a class depends on another object to provide some or all functionality. With an inheritance relationship, you can use the subclass object wherever superclass is expected. Think of it as this relationship between a <kbd class="calibre11">Dictionary</kbd> and a <kbd class="calibre11">Book</kbd> class:</p>
<pre class="calibre19">class Book(val title: String) 
class Dictionary(name: String) extends Book(name) { 
  // data and behavior 
} </pre>
<p class="calibre2">We can picture the <strong class="calibre1">Book</strong> and <strong class="calibre1">Dictionary</strong> relationship as shown in the following figure:</p>
<div class="cdpaligncenter"><img class="image-border12" src="../images/00027.jpeg"/></div>
<p class="calibre2">Here, a <kbd class="calibre11">Dictionary</kbd> class is inheriting from a <kbd class="calibre11">Book</kbd> class, so it means that:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">Dictionary</kbd> is a subclass of <kbd class="calibre11">Book</kbd>. It can be used as a <kbd class="calibre11">Book</kbd> type wherever required.</li>
<li class="calibre8">Dictionary has access to all the fields (data) and member functions (behavior) of the <kbd class="calibre11">Book</kbd> class. This means that you're allowed to override the behavior of a particular function from the superclass, as well as define your own functions in terms of behavior from superclass functions.</li>
</ul>
<p class="calibre2">These points in a way make it easier to understand the inheritance relationship and help you to form a good object-oriented design. However, sometimes you as a developer feel duty-bound to change the behavior of the superclass as it's now a dependency for other subtypes as well.</p>
<p class="calibre2">Composition also may look similar when implemented (in case of traits mix-ins) but it's different in nature. As the name suggests, composition actually makes the whole out of parts. It's easier to understand with the help of an example:</p>
<pre class="calibre19">class Book(val title: String) {<br class="title-page-name"/>  val chapters = scala.collection.mutable.Set[Chapter]()<br class="title-page-name"/>  def addChapter(chapter: Chapter) = chapters.add(chapter)<br class="title-page-name"/>  def pages = chapters.foldLeft(0)((b, c) =&gt; b + c.noOfPages)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>case class Chapter(name: String, sn: Int, noOfPages: Int)<br class="title-page-name"/><br class="title-page-name"/>object BookApp extends App {<br class="title-page-name"/>  val book = new Book("The New Book")<br class="title-page-name"/>  book.addChapter(Chapter("Chapter1", 1, 15))<br class="title-page-name"/>  book.addChapter(Chapter("Chapter2", 2, 13))<br class="title-page-name"/>  book.addChapter(Chapter("Chapter3", 3, 17))<br class="title-page-name"/><br class="title-page-name"/>  println(book.title)<br class="title-page-name"/>  println(book.pages)<br class="title-page-name"/>}</pre>
<p class="calibre2">In the preceding code, we have shown a <kbd class="calibre11">Book</kbd> class that consists of a set of chapters. Each chapter is represented by a <kbd class="calibre11">Chapter</kbd> class. This is a <em class="calibre18">Has-a</em> relationship between the <kbd class="calibre11">Book</kbd> and <kbd class="calibre11">Chapter</kbd> classes. This relationship is also called <strong class="calibre1">aggregation</strong>. And as a special form of aggregation, our topic of interest for now is composition. There's a field named <kbd class="calibre11">chapters</kbd> in the <kbd class="calibre11">Book</kbd> class that is composed of <kbd class="calibre11">chapters</kbd>. Without the <kbd class="calibre11">Chapter</kbd> construct, there's no possibility of forming a book object that makes sense.</p>
<p class="calibre2">This is composition and it's directional. The following figure will help us to understand the concept:</p>
<div class="cdpaligncenter"><img class="image-border13" src="../images/00028.jpeg"/></div>
<div class="cdpaligncenter1">Composition relationship between a Book and Chapter</div>
<p class="calibre2">With the <kbd class="calibre11">Set</kbd> object in <kbd class="calibre11">chapters</kbd>, we can extend some functionalities that can only be performed on <kbd class="calibre11">Chapter</kbd> objects. I bet you get the idea of composition. The reason why we're discussing this is because we'll be doing that using mix-ins of traits in Scala, and it looks almost like we're extending them as part of inheritance, but that's not the case. So the idea is clear:</p>
<ul class="calibre7">
<li class="calibre8">Composition is not just code reuse but also making a whole out of parts. The existence of <kbd class="calibre11">Book</kbd> is unclear without a <kbd class="calibre11">Chapter</kbd> object.</li>
<li class="calibre8">Composition also adds up functionalities to our already defined class constructs (we'll see this when we talk about <em class="calibre18">traits as mix-ins</em> later in the chapter).</li>
</ul>
<p class="calibre2">It's important to know the difference between these two. You may only have a vague idea of how to implement inheritance or composition in Scala for now, but the terms and their meaning are clear. It's going to make the way clear for us to move forward and discuss how we can implement class inheritance in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Class inheritance</h1>
                
            
            <article>
                
<p class="calibre2">You already know that inheritance plays an important role in good object-oriented design. We are lucky enough to have constructs such as classes with names, and we can increase the possibility of relating those with other classes by using inheritance. Inheritance is about forming a meaningful hierarchy of classes to solve the purpose of code reuse. And mark my words, I mentioned <em class="calibre18">meaningful hierarchies.</em> I'll justify my words later. Let's take a look at how we can extend classes to make a hierarchy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Extending classes</h1>
                
            
            <article>
                
<p class="calibre2">We use the <kbd class="calibre11">extend</kbd> keyword to inherit a class. Let's see our <kbd class="calibre11">Book</kbd> example to understand this:</p>
<pre class="calibre19">class Book(val title: String){ 
  // data and behaviour for Book 
} 
 
class Dictionary(name: String) extends Book(name) { 
  // data and behaviour for dictionary 
} 
 
object BookApp extends App { 
  val dictionary = new Dictionary("Collins") 
  println(dictionary.title) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Collins </pre>
<p class="calibre2">We can see that <kbd class="calibre11">Dictionary</kbd> inherits from <kbd class="calibre11">Book</kbd> or <kbd class="calibre11">Dictionary</kbd> and is a subclass of the <kbd class="calibre11">Book</kbd> superclass. It's important to know that all classes, regardless of using the <kbd class="calibre11">extends</kbd> keyword, explicitly inherit <kbd class="calibre11">Any</kbd> in Scala. It means that our <kbd class="calibre11">Book</kbd> class inherits <kbd class="calibre11">Any</kbd>. Now with the establishment of this relationship, if you try to create an instance of <kbd class="calibre11">Dictionary</kbd>, you'll have access to all non-private members of the superclass. That's the reason we're able to print the title of our dictionary. That's code reuse. If you don't want to allow a particular member to be accessible from outside, you may make it <kbd class="calibre11">private</kbd>, an access modifier. We'll learn about access levels later in this chapter. With this inheritance relationship, it's possible to use a <kbd class="calibre11">Dictionary</kbd> instance wherever a <kbd class="calibre11">Book</kbd> instance is expected. The reason for this is that <kbd class="calibre11">dictionary</kbd> is a subtype of the <kbd class="calibre11">Book</kbd> type. To make things clearer, let's talk about subtyping and subclassing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Subtyping versus subclassing</h1>
                
            
            <article>
                
<p class="calibre2">Classes are not types in Scala<em class="calibre18">.</em> When we inherit from a class, we form a superclass-subclass relationship between the two. And for most cases, the notion of subclassing and subtyping are the same. But in cases where <em class="calibre18">variance (</em>inheritance behavior under parameterized classes<em class="calibre18">)</em> plays its part, things become different. Under variance, subclassing doesn't guarantee subtyping as well.</p>
<p class="calibre2">We will take a look at both cases, positive and negative. Let's say a dictionary inherits from book, and it makes sense to say that a stack of dictionaries is a stack of books. This is the positive scenario, where subclassing and subtyping are similar in nature. But what about the second scenario? Suppose the <kbd class="calibre11">Keyboard</kbd> class extends from the <kbd class="calibre11">Button</kbd> class<em class="calibre18">.</em> <kbd class="calibre11">Button</kbd> has a value and also the functionality. So, while forming a meaningful keyboard object, we used the <kbd class="calibre11">Button</kbd> class. But do you think a stack of keyboards is the same as a stack of buttons? No! Hence here, the subclassing is perfect between <kbd class="calibre11">Keyboard</kbd> and <kbd class="calibre11">Button</kbd> classes, but we're not allowed to say that the <kbd class="calibre11">Keyboard</kbd> is a subtype of <kbd class="calibre11">Button</kbd>. I think you get the idea of subtyping and subclassing and their differences. Still, in programming terms, let's see it this way: if <kbd class="calibre11">Dictionary</kbd> is a subtype of <kbd class="calibre11">Book</kbd>, then <kbd class="calibre11">List</kbd>[<kbd class="calibre11">Dictionary</kbd>] is going to be a subtype of <kbd class="calibre11">List</kbd>[<kbd class="calibre11">Book</kbd>]. We call this property <strong class="calibre1">covariance</strong>. In the other case, <kbd class="calibre11">Keyboard</kbd> sub-classes <kbd class="calibre11">Button</kbd> but it's not a subtype of <kbd class="calibre11">Button</kbd>. Let's visualize what we just tried to understand:</p>
<div class="cdpaligncenter"><img class="image-border14" src="../images/00029.jpeg"/></div>
<div class="cdpaligncenter1">Sub-classing</div>
<p class="calibre2">This relationship speaks for itself. In the case of keyboard and buttons, it's better to choose composition instead of inheritance. But that's a different perspective. For now, it has become clear we should differentiate between subtyping and subclassing. So now, let's go over one more interesting topic—overriding the behavior of superclasses. Yes, it's possible for us to override the functions defined in a superclass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Overriding data and behavior</h1>
                
            
            <article>
                
<p class="calibre2">We know that subclasses have access to all non-private members of a superclass, hence we can call or invoke functions from a superclass to show some behavior. If we want to manipulate the behavior, it's possible in Scala to override any function or value from a superclass. Let's see how we can do that. We'll refer to our previously mentioned <kbd class="calibre11">Book</kbd> and <kbd class="calibre11">Dictionary</kbd> example. Suppose in the <kbd class="calibre11">Book</kbd> class we have a function named <kbd class="calibre11">cover</kbd> that for demonstration purposes simply takes a <kbd class="calibre11">String</kbd> object as <kbd class="calibre11">cover</kbd>.</p>
<p class="calibre2">We inherit from <kbd class="calibre11">Book</kbd> and create a <kbd class="calibre11">Dictionary</kbd> class that wants to override the functionality of this function named <kbd class="calibre11">cover</kbd>:</p>
<pre class="calibre19">class Book(val title: String){ 
  def cover(cover: String): String = "Paperback_" + cover 
} 
 
class Dictionary(name: String) extends Book(name){ 
  // wants to define its own version of cover method 
} </pre>
<p class="calibre2">We can <kbd class="calibre11">override</kbd> the definition of the <kbd class="calibre11">cover</kbd> method by simply adding the modifier keyword named <kbd class="calibre11">override</kbd>:</p>
<pre class="calibre19">class Dictionary(name: String) extends Book(name){ 
  override def cover(cover: String): String = "Hardcover_" + cover 
} 
 
object BookApp extends App { 
  val dictionary = new Dictionary("Collins") 
  println(dictionary.title) 
  println(dictionary.cover("The Collins Dictionary")) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Collins 
Hardcover_The Collins Dictionary </pre>
<p class="calibre2">As you can see in the preceding example, we've overridden the <kbd class="calibre11">cover</kbd> <span>method</span><em class="calibre18">.</em> What if we don't use this keyword named <kbd class="calibre11">override</kbd>? In that case, the Scala compiler will give us an error stating the following:</p>
<pre class="calibre19">Error:(18, 7) overriding method cover in class Book of type (cover: String)String; 
 method cover needs `override' modifier 
 def cover(cover: String): String = "Hardcover_" + cover </pre>
<p class="calibre2">The <kbd class="calibre11">cover</kbd> method needs the <kbd class="calibre11">override</kbd> modifier. Method overriding works if we've kept the signature <span>in the subclass</span> intact. If you try to change the signature, the compiler will give you an error stating that the <kbd class="calibre11">cover</kbd> method overrides nothing:</p>
<pre class="calibre19">Error:(18, 16) method cover overrides nothing. 
Note: the super classes of class Dictionary contain the following, non-final members named cover: 
def cover(cover: String): String 
override def cover(cover: Cover): String = "Hardcover_" + cover </pre>
<p class="calibre2">So it's important to keep the method signature as it is in the subclass to override it. Scala requires you to provide the <kbd class="calibre11">override</kbd> keyword whenever you try reusing the same method in a subclass. In Java, the <kbd class="calibre11">override</kbd> keyword is optional. This causes problems in real-time scenarios when writing code. Let's suppose you want to change the behavior in the <kbd class="calibre11">Book</kbd> superclass to support the newly introduced <kbd class="calibre11">Cover</kbd> class as a parameter in the <kbd class="calibre11">cover</kbd> method, and you have overridden this <kbd class="calibre11">cover</kbd> method in a few places, such as the <kbd class="calibre11">Dictionary</kbd> class. What happens in scenarios where the <kbd class="calibre11">override</kbd> keyword is not mandatory? you may ask. Hence, Scala requires you to add it. So at compile time, you're going to get an error that the <kbd class="calibre11">cover</kbd> method in <kbd class="calibre11">Dictionary</kbd> overrides nothing, and you can change the definition as needed.</p>
<p class="calibre2">One more important thing to know: for understanding overriding behaviors thoroughly we must understand the scope of them. It's possible to override a non-parameter <kbd class="calibre11">def</kbd> member with a <kbd class="calibre11">val</kbd> field. What do we mean by this? Let's take a look:</p>
<pre class="calibre19">class Book(val title: String){ 
  def coverType: String = "Paperback" 
  def cover(cover: String): String = coverType + "_" + cover 
} 
 
class Dictionary(name: String) extends Book(name){ 
  override val coverType: String = "Hardcover" 
} </pre>
<p class="calibre2">This example shows you that a non-parameter method named <kbd class="calibre11">coverType</kbd> in <kbd class="calibre11">Book</kbd> can be overridden in the <kbd class="calibre11">Dictionary</kbd> <span>subclass</span> with a <kbd class="calibre11">val</kbd> object. It's perfectly legal to perform such overriding operations. If you try to do this the other way around, it's not possible. The Scala compiler will not allow you to perform such an operation stating that the <kbd class="calibre11">coverType</kbd> method needs to be a stable, immutable value:</p>
<pre class="calibre19">Error:(19, 16) overriding value coverType in class Book of type String; 
 method coverType needs to be a stable, immutable value 
  override def coverType: String = "Hardcover" </pre>
<p class="calibre2">It's logical; what you're trying to do here is to make something mutable, a definition is mutable. This shouldn't be allowed and the Scala compiler is intelligent enough to tell you this. Suppose you want a particular member of your superclass to be intact, and not changeable. You want to restrict following subclasses from overriding behavior of the superclass, what'll you do in that case? That's what we'll learn next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Restricting inheritance – final keyword</h1>
                
            
            <article>
                
<p class="calibre2">If you want to restrict subclasses from overriding a particular behavior or some data, you may use the <kbd class="calibre11">final</kbd> <span>keyword</span> to do so:</p>
<pre class="calibre19">class Book(val title: String){ 
  final val coverType: String = "Paperback" 
  def cover(cover: String): String = coverType + "_" + cover 
} </pre>
<p class="calibre2">Here, we have declared our <kbd class="calibre11">coverType</kbd> <span>value</span> as <kbd class="calibre11">final</kbd>. If you try to override this, the Scala compiler will throw an error stating the value cannot override the <kbd class="calibre11">final</kbd> member:</p>
<pre class="calibre19">Error:(19, 16) overriding value coverType in class Book of type String; 
 value coverType cannot override final member 
 override val coverType: String = "Hardcover" </pre>
<p class="calibre2">It's useful for when there's some data you want to remain intact and still have this superclass-subclass relationship working. With this overriding of behaviors in several related classes, there comes confusion when you try to invoke a particular method that's in a superclass as well as subclasses. That confusion is solved using the concept of dynamic binding. So, let's explain where dynamic binding is used before we learn how it works <span>in detail.</span> Dynamic binding is used to resolve which member function will get invoked when classes are in an inheritance relationship. This is resolved on the basis of objects at runtime. Let's talk in detail about it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dynamic binding in function invocation</h1>
                
            
            <article>
                
<p class="calibre2">We talked about the dynamic binding of objects to their references and invocation of methods. The invocation takes place based on the type of object on which that method is called. This is easier to understand with an example. Take a look at the following example:</p>
<pre class="calibre19">class Book(val title: String){ 
  val coverType: String = "Paperback" 
  def cover(cover: String): String = coverType + "_" + cover 
} 
 
class Dictionary(name: String) extends Book(name){ 
  override val coverType: String = "Hardcover" 
} 
 
class Encyclopedia(name: String) extends Book(name){ 
  override val coverType: String = "Blue_Hardcover" 
} 
 
object BookApp extends App { 
  val dictionary: Book = new Dictionary("Collins") 
  val encyclopedia: Book = new Encyclopedia ("Britannica") 
  val theBoringBook: Book = new Book("TheBoringBook") 
 
  println(s"${dictionary.title} has cover ${dictionary.cover("The Collins Dictionary")}") 
  println(s"${encyclopedia.title} has cover ${encyclopedia.cover("Britannica")}") 
  println(s"${theBoringBook.title} has cover ${theBoringBook.cover("Some Book")}") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Collins has cover Hardcover_The Collins Dictionary 
Britannica has cover Blue_Hardcover_Britannica 
TheBoringBook has cover Paperback_Some Book </pre>
<p class="calibre2">Take a closer look at the following:</p>
<pre class="calibre19">val dictionary: Book = new Dictionary("Collins") 
val encyclopedia: Book = new Encyclopedia ("Britannica") 
val theBoringBook: Book = new Book("TheBoringBook") </pre>
<p class="calibre2">Here, we have created three different objects with the same return types, <kbd class="calibre11">Book</kbd>. The first thing to notice is that the class on the left-hand side of the equals operator will always be higher in the inheritance hierarchy. Secondly, all three are different instances. So, when you try to invoke a member function named <kbd class="calibre11">cover</kbd> from all these instances, you may observe different behavior in all three cases and see that the invocation is done based on the runtime type of the class. What do we mean by the runtime type of the class? It means that at compile time, all three expressions were of the same type, <kbd class="calibre11">Book</kbd>, but at runtime, things are different. Invocation of <kbd class="calibre11">Dictionary</kbd>, <kbd class="calibre11">Encyclopedia</kbd>, and <kbd class="calibre11">Book</kbd> takes place resulting in invocation of their respective versions of the cover method. In our case, the result that gets printed out shows the expected behavior. This behavior is termed <strong class="calibre1">dynamic binding</strong> in object-oriented languages.</p>
<p class="calibre2">By now, I'm sure that you're pretty well-versed in the concept of inheritance, and are ready to take this characteristic into account when designing models for your next application, right? Well to make it clearer, we'll think of inheritance as a concept that solves the issue of code duplication, by code reuse. But it's our responsibility to keep in mind that with the relationship that these classes form using inheritance, they also transmit some significant semantic information. What do we mean by that? We mean that it's important to understand that when we inherit from some superclass, it becomes a public interface/construct representing our subclass.</p>
<p class="calibre2">Hence, when inheriting dictionary from book, if it also keeps semantic information about whether the book is going to have a title, pages, cover, author, or other information, then its subclass is also expected to have this information available. The reason for this is that a <kbd class="calibre11">Book</kbd> is a public interface for a <kbd class="calibre11">dictionary</kbd> because of the inheritance relationship. And that's where sometimes we find ourselves using inheritance in the wrong way. Let's discuss this in brief.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Misusing inheritance</h1>
                
            
            <article>
                
<p class="calibre2">Take a look at this example:</p>
<pre class="calibre19">class CustomStack extends util.ArrayList[String] { 
  def push(value: String) = ??? 
  def pop = ??? 
} </pre>
<p class="calibre2">Here, a class named <kbd class="calibre11">CustomStack</kbd> is inheriting from <kbd class="calibre11">ArrayList[String]</kbd>. What you see here is a semantic code smell. Just because your <kbd class="calibre11">CustomStack</kbd> class has extended from <kbd class="calibre11">ArrayList</kbd> means that you have access to all of its public members. Anyone with a stack object is not only going to have access to <kbd class="calibre11">push</kbd> or <kbd class="calibre11">pop</kbd>, but a whole set of methods like <kbd class="calibre11">get</kbd>, <kbd class="calibre11">set</kbd>, <kbd class="calibre11">add</kbd>, <kbd class="calibre11">remove</kbd>, and so on. This is wrong; you're allowed to use an array list object internally to form a stack object but the public interface should have nothing to do with it. In our case, our code shows that if you have access to <kbd class="calibre11">CustomStack</kbd>, you have access to all those methods. You should avoid using this in the <kbd class="calibre11">Stack</kbd> construct. The reality is that both of these are different concepts altogether so we should avoid using such types of modeling where it is semantically wrong. Although it may be a design choice, still we should keep in mind a few points when making these decisions:</p>
<ul class="calibre7">
<li class="calibre8">Check for Is-A relationship, if it holds true.</li>
<li class="calibre8">Check if rules for encapsulation, such as data hiding, hold true. You should never expose internal implementation details to the outer world. In our case, <kbd class="calibre11">Stack</kbd> should've implemented the array list internally instead of inheriting from it.</li>
<li class="calibre8">We should check for domains of each construct, the cross domain inheritance model is not a good choice, for sure. <kbd class="calibre11">Stack</kbd> and <kbd class="calibre11">ArrayList</kbd> are different conceptually. One can be composed using the other but should not inherit the other.</li>
</ul>
<p class="calibre2">If you follow these points, you'll make a better design choice for modeling inheritance relationships.</p>
<p class="calibre2">Well, you remember we learned about <kbd class="calibre11">case</kbd> classes and the way we used to instantiate them without the <kbd class="calibre11">new</kbd> keywords? That makes me wonder, what if we want to have more than one way to construct new objects of such a <kbd class="calibre11">case</kbd> class? If you're also thinking the same; good! It's possible to have parameterized constructors in Scala. Let's talk about them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Default and parameterized constructors</h1>
                
            
            <article>
                
<p class="calibre2">The primary constructor for any class defined in Scala is the body itself. It means that whatever you declare and define inside a class body gets instantiated when you make an instance of it. There are other ways to define secondary/auxiliary constructors as well. Take a look at the following <kbd class="calibre11">case</kbd> classes:</p>
<pre class="calibre19">import java.time.LocalDate<br class="title-page-name"/><br class="title-page-name"/>case class Employee(name: String, id: String, contact: String, email: String) 

case class StartUp(name: String, founder: Employee, coFounders: Option[Set[Employee]], members: Option[List[Employee]], foundingDate: Option[LocalDate]) </pre>
<p class="calibre2">We can see two <kbd class="calibre11">case</kbd> classes named <kbd class="calibre11">Employee</kbd> and <kbd class="calibre11">StartUp</kbd>. You may wonder why <kbd class="calibre11">Employee</kbd> is specific to our <kbd class="calibre11">StartUp</kbd> class. The <kbd class="calibre11">StartUp</kbd> case class takes a few attributes such as <kbd class="calibre11">founder</kbd>, <kbd class="calibre11">coFounder</kbd>, <kbd class="calibre11">members</kbd>, and <kbd class="calibre11">foundingDate</kbd>. So, for creating instances of these <kbd class="calibre11">case</kbd> classes, we have to provide values for each member. In this case, if someone on the client side wants to use this <kbd class="calibre11">case</kbd> class and does not want to provide <kbd class="calibre11">members</kbd> or <kbd class="calibre11">coFounder</kbd> information, they still have to give dummy values. Now, the solution to this could be to construct auxiliary constructors for our client's sake. This can be done if we provide alternative invocation strategies for the <kbd class="calibre11">StartUp</kbd> case class. Let's do that:</p>
<pre class="calibre19">case class StartUp(name: String, founder: Employee, coFounders: Option[Set[Employee]], members: Option[List[Employee]], foundingDate: Option[LocalDate]){ 
 
  //founder | name 
  def this(name: String, founder: Employee) = this(name, founder, None, None, None) 
 
 
  //founder | foundingDate 
  def this(name: String, founder: Employee, foundingDate: LocalDate) = this(name, founder, None, None, Some(foundingDate)) 
 
  //founder | coFounders 
  def this(name: String, founder: Employee, coFounders: Set[Employee]) = this(name, founder, Some(coFounders), None, None) 
 
  //founder | coFounders | members 
  def this(name: String, founder: Employee, coFounders: Set[Employee], members: List[Employee]) = this(name, founder, Some(coFounders), Some(members), None) 
 
  //founder | coFounders | foundingDate 
  def this(name: String, founder: Employee, coFounders: Set[Employee], foundingDate: LocalDate) = this(name, founder, Some(coFounders), None, Some(foundingDate)) 
 
  //founder | members    | foundingDate 
  def this(name: String, founder: Employee, members: List[Employee], foundingDate: LocalDate) = this(name, founder, None, Some(members), Some(foundingDate)) 
 
} </pre>
<p class="calibre2">A few points to note here. Firstly, we can define overloaded versions of <kbd class="calibre11">this</kbd> method that work as auxiliary constructors. Secondly, in each definition, we're making a call to the main constructor with some other values. This practice can be done on either of these sides. By this we mean that passing optional values can be done either at the time of declaring these <kbd class="calibre11">case</kbd> classes or on the client side where we use these. We've done it while declaring these classes. Now let's use them in our <kbd class="calibre11">StartUpApp</kbd>:</p>
<pre class="calibre19">object StartUpApp extends App { 
 
  val startUpWithFoundingDate = new StartUp("WSup", Employee("Rahul Sharma", "RH_ID_1", "9090000321", "rahul_sharma@abc.com"), LocalDate.now()) 
 
  println(s"${startUpWithFoundingDate.name} founded on ${startUpWithFoundingDate.foundingDate.get} by ${startUpWithFoundingDate.founder.name}") 
 
  val startUp = new StartUp("Taken", Employee("David Barbara", "DB_ID_1", "9090654321", "david_b@abc.com")) 
 
  println(s"${startUp.name} founded by ${startUp.founder.name}") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">WSup founded on Sun Jun 13 20:29:00 IST 2016 by Rahul Sharma 
Taken founded by David Barbara </pre>
<p class="calibre2">It was easy to use these auxiliary constructor versions of the <kbd class="calibre11">StartUp</kbd> case class. We can see that we only passed the needed parameters, and if the version was available to us, we were able to create an instance for it. But wait a second, we had these case classes and yet still we used the <kbd class="calibre11">new</kbd> keyword to create an instance for the <kbd class="calibre11">StartUp</kbd> class. What if we try to create an instance without using the <kbd class="calibre11">new</kbd> keyword? Let's try that:</p>
<pre class="calibre19">object StartUpApp extends App { 
   
  val startUp = StartUp("Taken", Employee("David Barbara", "DB_ID_1", "9090654321", "david_b@abc.com")) 
  println(s"${startUp.name} founded by ${startUp.founder.name}")<br class="title-page-name"/> } </pre>
<p class="calibre2">If you try to do so, the Scala compiler will throw an error stating the following:</p>
<pre class="calibre19">Error:(30, 24) not enough arguments for method apply: (name: String, founder: chapter7.Employee, coFounders: Option[Set[chapter7.Employee]], members: Option[List[chapter7.Employee]], foundingDate: Option[java.util.Date])chapter7.StartUp in object StartUp. 
Unspecified value parameters coFounders, members, foundingDate. 
val startUp = StartUp("Taken", Employee("David Barbara", "DB_ID_1", "9090654321", "david_b@abc.com"))  </pre>
<p class="calibre2">This happens because when you declare <kbd class="calibre11">case</kbd> classes, the compiler generates a companion object with the <kbd class="calibre11">apply</kbd> method for it and the <kbd class="calibre11">apply</kbd> method takes all the parameters of the <kbd class="calibre11">case</kbd> class definition. When we define auxiliary constructors, we don't really overload the <kbd class="calibre11">apply</kbd> method defined in companion objects. Hence, when we try to use <kbd class="calibre11">case</kbd> class instantiation without the <kbd class="calibre11">new</kbd> keyword, the Scala compiler is not able to find a corresponding <kbd class="calibre11">apply</kbd> method version and gives an error. If you really want to use it that way, you can define overloaded versions of the <kbd class="calibre11">apply</kbd> method in companion objects. We'll try to overload an implementation with only two parameters, <kbd class="calibre11">name</kbd> and <kbd class="calibre11">founder</kbd><em class="calibre18">.</em> Let's do this:</p>
<pre class="calibre19">object StartUp { 
 
  def apply(name: String, founder: Employee): StartUp = new StartUp(name, founder, None, None, None) 
} </pre>
<p class="calibre2">It's easy to do. Defining an <kbd class="calibre11">apply</kbd> method that takes only <kbd class="calibre11">name</kbd> and <kbd class="calibre11">founder</kbd> gives us the option to create an instance of our <kbd class="calibre11">StartUp</kbd> object without using the <kbd class="calibre11">new</kbd> keyword:</p>
<pre class="calibre19">object StartUpApp extends App { 
 
  val startUp = StartUp("Taken", Employee("David Barbara", "DB_ID_1", "9090654321", "david_b@abc.com")) 
 
  println(s"${startUp.name} founded by ${startUp.founder.name}") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Taken founded by David Barbara </pre>
<p class="calibre2">These are just a few ways; we can make the client's life easier by providing a variety of options to construct new objects. Now that we have seen how we can define various options for a class construct and also how inheritance can be effective if used properly, we can make our constructs more powerful by using traits in Scala. That's what we're going to explore next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traits</h1>
                
            
            <article>
                
<p class="calibre2">What are traits? For those coming from a Java background, it's tempting to see them as interfaces, but in reality they are something different. <strong class="calibre1">Trait</strong> constructs may look similar but are of a different nature to interfaces in Java. The meaning of the word trait is: a distinguishing quality or characteristic, typically one belonging to a person. One of the purposes of traits is the same. What if you want to add a particular characteristic to our hierarchy of classes or a single class? You can do this by extending or mixing in a trait. It's easier to say that we mix-in traits rather than extend from them. How are these two different? We'll talk about this as we go along but for now, let's take a look at how we define a <kbd class="calibre11">trait</kbd> in Scala:</p>
<pre class="calibre19">trait Socialize { 
  <br class="title-page-name"/>  //people who socialise, greets. 
  def greet(name: <span>String</span>) = <span>"Hello " </span>+ name<br class="title-page-name"/>}</pre>
<p class="calibre2">Look at it this way. One of the qualities of people who tend to socialize well is that they greet you wholeheartedly when they meet you. In programming terms, you want to make a class named <kbd class="calibre11">Person</kbd> social. You can create a <kbd class="calibre11">trait</kbd> named <kbd class="calibre11">Socialize</kbd>, which for now just defines a method <kbd class="calibre11">greet</kbd>. This is simple: by defining a <kbd class="calibre11">trait</kbd>, we use the keyword <kbd class="calibre11">trait</kbd> and give it a name. We'll talk about this as we go along but for now, let's take a look at how we define a <kbd class="calibre11">trait</kbd> in Scala:</p>
<pre class="calibre19">case class Person(val name: String) 
 
object SocializeApp extends App { 
  val person = Person("Victor Mark") 
  val employee = new Employee("David Barbara") with Socialize 
 
  println(employee.greet(person.name)) 
 
  class Employee(fullName: String) extends Person(fullName) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Hello Victor Mark </pre>
<p class="calibre2">In the preceding code snippet, we defined an <kbd class="calibre11">Employee</kbd> <span>class</span> that extends <kbd class="calibre11">Person</kbd> in the inheritance hierarchy. While instantiating the <kbd class="calibre11">Employee</kbd> object, we're able to extend an employee's characteristic of socializing through a mix-in. Also, we have access to the <kbd class="calibre11">greet</kbd> method from our <kbd class="calibre11">trait</kbd>. This happened on the go, we didn't specify <kbd class="calibre11">Employee</kbd> to have this characteristic statically, but dynamically. When instantiating, we extended the possibilities and characteristics of <kbd class="calibre11">Employee</kbd>. That's why traits are powerful. A few points to note about traits are as follows<em class="calibre18">:</em></p>
<ul class="calibre7">
<li class="calibre8">Traits do not take parameters</li>
<li class="calibre8">Traits can also form an inheritance hierarchy, a trait can mix-in another trait</li>
<li class="calibre8">You can't have a class and trait with the same name in the same scope</li>
<li class="calibre8">The order in which we mix-in traits matters and can affect the behavior of your implementation</li>
</ul>
<p class="calibre2">We can define traits by observing the previous points, but it's also good to know how Scala treats traits at compile time. To understand this, we can use the <kbd class="calibre11">javap</kbd> command on our <kbd class="calibre11">Socialize</kbd> class. It's going to show the compiled form of our trait:</p>
<pre class="calibre19">public interface chapter7.Socialize { 
  public static java.lang.String greet$(chapter7.Socialize, java.lang.String); 
  public java.lang.String greet(java.lang.String); 
  public static void $init$(chapter7.Socialize); 
} </pre>
<p class="calibre2">In the preceding snippet, you can see the compiled version of the <kbd class="calibre11">Socialize</kbd> trait. The Scala compiler compiles down a trait to its Java counterpart, <kbd class="calibre11">interface</kbd> (this happens in Scala version 2.12 and later. In previous versions, traits were also compiled to a set of classes). Here, the <kbd class="calibre11">greet</kbd> method is available as a static and a non-static member. It's possible for us to include an abstract, as well as concrete, method of a trait. For example, take a look at the following:</p>
<pre class="calibre19">trait Socialize { 
 
  def greet(name: String) = "Hello " + name 
 
  val socialNetworks = Set("Facebook", "LinkedIn", "Twitter", "Instagram", "Youtube") 
 
  def linkToSocialNetwork(network: String, uri: String) 
} 
 
object SocializeApp extends App { 
 
  val employee = new Employee("David Barbara") 
  employee.linkToSocialNetwork("LinkedIn", "www.linkedin.com/profiles/david_b") 
 
  println(employee.mapOfSocialNetwork) 
 
} 
 
class Employee(fullName: String) extends Person(fullName) with Socialize { 
 
  var mapOfSocialNetwork = new scala.collection.mutable.HashMap[String, String]() 
 
  override val socialNetworks = Set("LinkedIn", "Twitter", "Youtube") <br class="title-page-name"/>  override def linkToSocialNetwork(network: String, uri: String): Unit = if (socialNetworks contains network) mapOfSocialNetwork.put(network, uri) 
}  </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Map(LinkedIn -&gt; www.linkedin.com/profiles/david_b) </pre>
<p class="calibre2">The preceding example shows that we can have abstract, as well as concrete members, as part of our traits. Here we have just declared our <kbd class="calibre11">linkToSocialNetwork</kbd> meth<span>od</span> without definition and also our previous method, named <kbd class="calibre11">greet</kbd>, that has its definition:</p>
<pre class="calibre19">def linkToSocialNetwork(network: String, uri: String)   </pre>
<p class="calibre2">We have given its implementation in the <kbd class="calibre11">Employee</kbd> class, which mixes in this trait. With this abstraction, we now can compare traits to abstract classes in Scala. What's the distinction between these two? First, you may see that we can't pass constructor parameters to our traits. Second, as constructs, traits are heavier than abstract classes. So it's a matter of choice for you to decide between these two. The recommendation is to select a trait if you're extending any functionality, or if only as a class hierarchy, then an abstract class could be a good choice. One more aspect of a trait is that it's stackable. This means it's obvious you can mix-in more than one and its effect can be used in a stackable manner. Let's take a look at how traits can be used to showcase stackable behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traits as mix-ins</h1>
                
            
            <article>
                
<p class="calibre2">The way we do trait mix-ins is no different than inheriting any class in Scala; the only difference is that you can mix-in more than one trait and for that we have this nice keyword called <kbd class="calibre11">with</kbd>. Why do we call it mix-in? We could have called it something else. Well, yes but this explains almost everything you can do with traits. It's easy to modify or add up behaviors to an already existing functionality or construct without affecting already existing behavior. We'll see that in a bit. Traits can be used in a variety of use cases such as:</p>
<ul class="calibre7">
<li class="calibre8">Composable mix-ins; to make already existing interfaces richer</li>
<li class="calibre8">Stackable modifications</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traits as composable mix-ins</h1>
                
            
            <article>
                
<p class="calibre2">By <strong class="calibre1">composable mix-ins</strong> we mean that we can create an instance of a particular type, with mix-ins of a trait, that can have certain additive functionalities. If you're thinking why would we want to do that, then the answer is maybe you want to add some particular behavior that makes sense to your functionality and you want it to behave as if it has come from the library itself. As a client of such constructs or libraries, we want them to feel as natural as they are. Traits help us add certain functions, keeping the real library intact.</p>
<p class="calibre2">We can understand this better with the help of an example. So, suppose you have an already existing <kbd class="calibre11">CreditCard</kbd> functionality. For demonstration purposes, we'll limit our expectations from this <kbd class="calibre11">CreditCard</kbd> functionality. This class has a certain way of generating credit card numbers for each subscriber. This is a thing of the past. Now, in the future, let's say in the next few days, we want to introduce certain new <kbd class="calibre11">CreditCard</kbd> subscriptions with more offers (conditions apply). Also, we want to have our own way of generating <kbd class="calibre11">CreditCard</kbd> numbers, without affecting the already existing functionalities or the business. The reality might be different, but for learning purposes it's fine to generate credit card numbers ourselves, isn't it? So, now that you have this picture in mind. Let's see what we already have:</p>
<pre class="calibre19">package chapter7 
 
 
case class Amount(amt: Double, currency: String){ 
  override def toString: String = s"$amt ${currency.toUpperCase}" 
} 
 
abstract class CreditCard { 
  val ccType = "Default" 
  def creditLimit(x: Double) : Amount 
  
  //legacy creditCardNumberGeneratorLogic 
  val ccNum = scala.util.Random.nextInt(1000000000).toString 
  
  //other methods 
} 
 
object CCApp extends App { 
  val basicCreditCard = new CreditCard { 
    override def creditLimit(x: Double): Amount = Amount(x, "USD") 
  } 
 
  val limit = basicCreditCard.creditLimit(1000) 
  println(s"CreditCardNumber ${basicCreditCard.ccNum} with limit: $limit") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">CreditCardNumber 44539599 with limit: 1000.0 USD </pre>
<p class="calibre2">Now, we can see how this <kbd class="calibre11">CreditCard</kbd> abstract class is defined, and our client <kbd class="calibre11">CCApp</kbd> is accessing that to create a new credit card account with a certain amount. Also, if you take a closer look, we didn't try to define isolated concrete classes that extend our abstract class named <kbd class="calibre11">CreditCard</kbd>, but we directly instantiated <kbd class="calibre11">CreditCard</kbd>, which is only possible because Scala generates and instantiates an anonymous class for us and expects us to define the abstract method, in our case <kbd class="calibre11">creditLimit</kbd>. Now, our requirement is that without playing with the already available code, we want to have our own version of the <kbd class="calibre11">creditCardNumber</kbd> generator that generates the credit card number for us. Let's do that then. But think about it, how are we going to do that and make it look natural? We want to do it this way:</p>
<pre class="calibre19">val basicCreditCard = // Some Credit Card impl 
basicCreditCard.ccNumber </pre>
<p class="calibre2">For this, we can define a <kbd class="calibre11">trait</kbd>, let's say <kbd class="calibre11">CreditCardOps</kbd>, that's going to define the functionality with which we can refer to the new logic without affecting the logic previously implemented. And for the clients it's going to be natural. Let's take a look at the implementation:</p>
<pre class="calibre19">trait CreditCardOps { 
   self: CreditCard =&gt; 
   val ccNumber: String = ccType match { 
     case "BASIC" =&gt; "BC" + ccNum 
     case _ =&gt; "DC" + ccNum 
   } 
} 
 
object CCApp extends App { 
  val basicCreditCard = new CreditCard with CreditCardOps { 
    override def creditLimit(x: Double): Amount = Amount(x, "USD") 
  } 
 
  val limit = basicCreditCard.creditLimit(1000) 
  println(s"CreditCardNumber ${basicCreditCard.ccNumber} with limit: $limit") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">CreditCardNumber DC896146072 with limit: 1000.0 USD </pre>
<p class="calibre2">The usage didn't change too much, and we also achieved what we intended. The only new thing we introduced was a <kbd class="calibre11">trait</kbd> named <kbd class="calibre11">CreditCardOps</kbd>. This <kbd class="calibre11">trait</kbd> has defined the new logic that we wanted. A few points to note about this implementation:</p>
<ul class="calibre7">
<li class="calibre8">First, we need to mix-in this <kbd class="calibre11">trait</kbd> to our <kbd class="calibre11">CreditCard</kbd> implementations whenever we want this synthetic behavior.</li>
<li class="calibre8">We also may want to ensure that this <kbd class="calibre11">trait</kbd> is specific to <kbd class="calibre11">CreditCard</kbd> types, hence any other traits or classes should not be allowed to mix-in this. We have eventually ensured that too. If you try to do something like the following:</li>
</ul>
<pre class="calibre36">class DebitCard 
val someDebitCard = new DebitCard with CreditCardOps </pre>
<ul class="calibre7">
<li class="calibre8">The Scala compiler will not allow us to do this; the reason being that the syntax we choose to write while defining our trait is as follows:</li>
</ul>
<pre class="calibre36">self: CreditCard =&gt; </pre>
<ul class="calibre7">
<li class="calibre8">This syntax gives a bit of information to the Scala compiler about upcoming statements in the current scope, as well as also limiting the trait's availability for certain types. Because of this syntax, we're only allowed to mix-in the <kbd class="calibre11">CreditCardOps</kbd> trait to <kbd class="calibre11">CreditCard</kbd> types.</li>
</ul>
<ul class="calibre7">
<li class="calibre8">Look at the following implementation:</li>
</ul>
<pre class="calibre36">trait CreditCardOps { 
   self: CreditCard =&gt; 
   val ccNumber: String = ccType match { 
     case "BASIC" =&gt; "BC" + ccNum 
     case _ =&gt; "DC" + ccNum 
   } 
} </pre>
<p class="calibre37">We are able to refer to <kbd class="calibre11">ccType</kbd> and <kbd class="calibre11">ccNum</kbd>, members of the <kbd class="calibre11">CreditCard</kbd> class, only because of this <kbd class="calibre11">self</kbd> type declaration<em class="calibre18">.</em> This declaration gives us access to members of the type specified.</p>
<ul class="calibre7">
<li class="calibre8">We've just modified the logic for <kbd class="calibre11">ccNum</kbd> and consumed the previous logic to create the new one. This was possible because of mix-ins.</li>
<li class="calibre8">Also, one constraint that we faced is that you may have wanted to <kbd class="calibre11">override</kbd> the value, <kbd class="calibre11">ccNum</kbd>, so that the clients of your <kbd class="calibre11">CreditCard</kbd> object, when accessing <kbd class="calibre11">ccNum</kbd>, could get the value based on the new logic, something similar to the following:</li>
</ul>
<pre class="calibre36">trait CreditCardOps { 

   self: CreditCard =&gt; 
   val ccNumber: String = ccType match { 
     case "BASIC" =&gt; "BC" + ccNum 
     case _ =&gt; "DC" + ccNum 
   } 
  override val ccNum = ccNumber // will be null 
} </pre>
<p class="calibre37">But, that's not possible. The compiler will let you do so but at runtime, the value will be null. A closer look will tell you that <kbd class="calibre11">self</kbd> is just a reference to the <kbd class="calibre11">CreditCard</kbd> type, hence you'll be able to refer to members, like we did while doing pattern matching, but if you try to <kbd class="calibre11">override</kbd>, it won't show the expected behavior. One reason for that is traits evaluate at runtime.</p>
<p class="calibre2">With this, we are finally able to get add-on behavior for only <kbd class="calibre11">CreditCard</kbd> types. This is the way we can make already existing constructs more powerful and can also modify them to suite our specific needs. We have a term for this process, we call it making thin interfaces rich through composable mix-ins. Why rich? Because of additive or selective modifications. There's more to traits based on our own use-cases. It's natural for an entity to have more than one trait, isn't it? Also, its understood if two or more composable behaviors are applied together, they'll both have their impact. It's an interesting topic; the way these behaviors are implemented. One of the ways these can be implemented is as <em class="calibre18">stackable modifications.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traits as stackable modifications</h1>
                
            
            <article>
                
<p class="calibre2">Before we learn about <strong class="calibre1">stackable modifications<em class="calibre18">,</em></strong> we should know why we may need them, shouldn't we? Yes, so the best way to understand that is by using an example. Suppose there's a consumer of a service. He can pay to subscribe to a particular service. That service, for example your DTH TV subscription service, includes several channel packages. Now, what's of interest to us here is that we may want to implement this service. For implementation, we want to have a list of channels or packages the consumer is subscribed to. At the beginning of the month, he subscribed to a particular package, let's say <kbd class="calibre11">BasicPackage</kbd>. So we said the following:</p>
<pre class="calibre19">new Service with BasicPackage </pre>
<p class="calibre2">This, in fact is self-explanatory. We created a <kbd class="calibre11">Service</kbd> with <kbd class="calibre11">BasicPackage</kbd>. Thinking programmatically, we can assume that we've a particular value in our <kbd class="calibre11">Service</kbd> class that has the list of packages/channels listed in a certain package. So with this declaration, that attribute must've been updated with the value. Up till now, everything has been fine. What if the consumer wants to subscribe to one more package? And we don't want to have a mechanism that explicitly modifies the list of channels for us, but it should happen by default. This is like a behavior that's getting modified as we keep adding different packages. This kind of situation gets you to the concept of stackable modifications:</p>
<pre class="calibre19">new Service with BasicPackage with DiamondPackage </pre>
<p class="calibre2">With each added package, a list of channels/packages is going to update. We'll see in a bit how the implementation implicitly stacks modifications as we add more packages. These modifications can be done on some data structure, where we can pipeline operations on data, or scenarios like we just mentioned. A sequence of operations/modifications in terms of traits can be added. Let's take another example and work on it. For that we'll take our <kbd class="calibre11">CreditCard</kbd> abstract class and modify it to suit our newly introduced <kbd class="calibre11">GoldCreditCard</kbd> and <kbd class="calibre11">PlatinumCreditCard</kbd>. These new card subscriptions have a lot to offer to consumers along with an increased limit. Subscribers to the gold card will get a credit limit of 10% more than the standard/basic credit card. The increased limit amount for a platinum card is 25% more than a standard card, apart from the other goodies that they bring. A consumer who is adventurous enough may want to opt for both subscriptions together. So how do you think we can implement this? One hint, we may be using stackable modifications, which we just discussed<em class="calibre18">.</em> So, let's take a look what we already have:</p>
<pre class="calibre19">abstract class CreditCard { 
  val ccType = "Default" 
  def creditLimit(x: Double) : Amount 
 
  //legacy creditCardNumberGeneratorLogic 
  val ccNum = scala.util.Random.nextInt(1000000000).toString 
 
  //other methods} </pre>
<p class="calibre2">Nothing different here. We have our old abstract <kbd class="calibre11">CreditCard</kbd> class. We may want to create a standard/basic credit card:</p>
<pre class="calibre19">class BasicCreditCard extends CreditCard { 
  override def creditLimit(x: Double): Amount = Amount(x,"USD") 
} </pre>
<p class="calibre2">This isn't alien code, it's easy to understand. We created a <kbd class="calibre11">BasicCreditCard</kbd> class extending <kbd class="calibre11">CreditCard</kbd> and we are overriding the <kbd class="calibre11">creditLimit</kbd> method. This method is simply returning the <kbd class="calibre11">Amount</kbd> object for the limit amount. Now, let's take a look at the implementation of other subscription types:</p>
<pre class="calibre19">trait GoldSubscription extends CreditCard { 
  abstract override def creditLimit(x: Double): Amount = super.creditLimit(x * 1.10) 
} 
 
trait PlatinumSubscription extends CreditCard { 
  abstract override def creditLimit(x: Double): Amount = super.creditLimit(x * 1.25) 
} </pre>
<p class="calibre2">Two more types named <kbd class="calibre11">GoldSubscription</kbd> and <kbd class="calibre11">PlatinumSubscription</kbd> as we discussed in terms of traits are added. What's different here? Syntactical analysis will say that this has an <kbd class="calibre11">abstract override</kbd> modifier, but how? How can you have these two together? We declare something <kbd class="calibre11">abstract</kbd> if we are not willing to provide its definition and use <kbd class="calibre11">override</kbd> to redefine something already in scope. So, the thing is, both of these are conflicting. However, Scala, as we already know, is intelligent enough to know that this is done in the context of a trait, which gets evaluated at runtime, and when you try to create an instance of such a trait or mix-in with some already created concrete class, it's going to override the particular definition. See the following:</p>
<pre class="calibre19">abstract override def creditLimit(x: Double): Amount = //super call </pre>
<p class="calibre2">Here, we are going to expect a concrete implementation of <kbd class="calibre11">CreditCard</kbd> to mix-in this trait. Let's take a look at the implementation <kbd class="calibre11">CCApp</kbd> to understand better:</p>
<pre class="calibre19">object CCApp extends App { 
  val basicCreditCard = new BasicCreditCard()       
  println(basicCreditCard.creditLimit(15000)) 
 
  val goldCreditCard = new BasicCreditCard() with GoldSubscription 
  println(goldCreditCard.creditLimit(15000)) 
 
  val platinumCreditCard = new BasicCreditCard() with PlatinumSubscription 
  println(platinumCreditCard.creditLimit(15000)) 
 
  val gpluspCreditCard = new BasicCreditCard() with GoldSubscription with PlatinumSubscription 
  println(gpluspCreditCard.creditLimit(15000)) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">15000.0 USD 
16500.0 USD 
18750.0 USD 
20625.0 USD </pre>
<p class="calibre2">In the preceding code is the implementation of the solution we came up with for our problem using stackable modifications. A few points to note here are as follows:</p>
<ul class="calibre7">
<li class="calibre8">Consider the following code snippet:</li>
</ul>
<pre class="calibre36">trait GoldSubscription extends CreditCard { 
  abstract override def creditLimit(x: Double): Amount = super.creditLimit(x * 1.10) 
} </pre>
<p class="calibre37">We didn't try to define some explicit logic implementation but made a <em class="calibre18">super</em> call to an already defined method with certain <em class="calibre18">additions</em>/<em class="calibre18">limitations</em>/<em class="calibre18">modifications</em> in a parameter value.</p>
<ul class="calibre7">
<li class="calibre8">With this, we're allowed to pass the same type of parameter and as it is composed, the value we'll get will be modified.</li>
<li class="calibre8">We can apply as many <kbd class="calibre11">CreditCard</kbd> subscriptions as we want and based on the logic, we'll get the expected value for <kbd class="calibre11">creditLimit</kbd>. That's why we were able to call the following:</li>
</ul>
<pre class="calibre36">val gpluspCreditCard = new BasicCreditCard() with GoldSubscription with PlatinumSubscription 
 
println(gpluspCreditCard.creditLimit(15000)) 
             and we got the desired result: 20625.0 USD </pre>
<ul class="calibre7">
<li class="calibre8">Last but not least, we mix-in the traits to concrete classes with overridden implementations for our abstract method, that's why <kbd class="calibre11">abstract override</kbd> worked here.</li>
</ul>
<p class="calibre2">This was interesting, you know. We passed a <kbd class="calibre11">creditLimit</kbd> value of <kbd class="calibre11">15000</kbd> for all the different instances and we got corresponding values. All of this is due to trait's use of stackable modifications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linearization</h1>
                
            
            <article>
                
<p class="calibre2">The reason why multiple inheritances become a burden when we try to implement them is due to <em class="calibre18">the diamond problem</em>. Take a look at the following image:</p>
<div class="cdpaligncenter"><img src="../images/00030.jpeg" class="calibre38"/></div>
<div class="cdpaligncenter1">Diamond problem</div>
<p class="calibre2">Here, suppose we have an abstract class named <kbd class="calibre11">Language</kbd>, that has a method named <kbd class="calibre11">sayHello</kbd>. Two traits, named <kbd class="calibre11">British</kbd> and <kbd class="calibre11">Spanish</kbd>, extend the abstract <kbd class="calibre11">Language</kbd> class and define their own implementation of the <kbd class="calibre11">sayHello</kbd> method. Then we create a trait, named <kbd class="calibre11">Socializer</kbd>, that mixes in the other two traits with a <kbd class="calibre11">super</kbd> call to the <kbd class="calibre11">sayHello</kbd> method implementation. Now, confusion occurs as to which implementation of <kbd class="calibre11">sayHello</kbd> is getting called when we invoke this method. The primary reason for this problem is there's no multiple inheritance in Java, but Scala supports a form of multiple inheritance through <em class="calibre18">trait mix-in</em>. The concept Scala uses to resolve the problem of super calls is linearization. Let's first code for the problem and see it's behavior, then we'll understand linearization and the rules that justify the behavior we are going to see.</p>
<p class="calibre2">Suppose we code for the problem shown in the preceding image. It's going to look as follows:</p>
<pre class="calibre19">abstract class Language { 
  def sayHello: String 
} 
 
trait British extends Language { 
  override def sayHello: String = "Hello" 
} 
 
trait Spanish extends Language { 
  override def sayHello: String = "Hola" 
} 
 
class Socializer extends British with Spanish { 
  override def sayHello: String = super.sayHello 
} 
 
object Linearization extends App { 
 
  class Person(val name: String) 
 
  val albert = new Person("Alberto") 
  val socializer = new Socializer() 
 
  println(s"${socializer.sayHello} ${albert.name}") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Hola Alberto </pre>
<p class="calibre2">Did you expect this result? We had declared our class <kbd class="calibre11">Socializer</kbd>:</p>
<pre class="calibre19">class Socializer extends British with Spanish { 
  override def sayHello: String = super.sayHello 
} </pre>
<p class="calibre2">The result shows that the call made to <kbd class="calibre11">super.sayHello</kbd> invoked <kbd class="calibre11">sayHello</kbd> from the <kbd class="calibre11">Spanish</kbd> trait. Well, such behavior is due to linearization. But how does it work? The rules for linearization are as follows:</p>
<ol class="calibre13">
<li value="1" class="calibre8">We'll start with the very first extended trait/class and think of the hierarchy. We'll consider <kbd class="calibre11">AnyRef</kbd> and <kbd class="calibre11">Any</kbd> are also part of the inheritance hierarchy.</li>
</ol>
<p class="calibre37">This is going to give us the following result:</p>
<pre class="calibre36">British -&gt; AnyRef -&gt; Any</pre>
<p class="calibre37">Let's call this a <strong class="calibre1">linearized hierarchy </strong>for now.</p>
<ol start="2" class="calibre13">
<li value="2" class="calibre8">Take the next trait/class and write a hierarchy down for it:</li>
</ol>
<pre class="calibre36">Spanish -&gt; AnyRef -&gt; Any</pre>
<p class="calibre37">Remove the traits/classes from this hierarchy that already exist in the linearized hierarchy.</p>
<p class="calibre37">So we'll remove <kbd class="calibre11">AnyRef -&gt; Any</kbd>. Remaining syntax will be:</p>
<pre class="calibre36">Spanish -&gt;</pre>
<p class="calibre37">Add the remaining traits/classes to the bottom of the already available linearized hierarchy.</p>
<pre class="calibre36">Spanish -&gt; British -&gt; AnyRef -&gt; Any</pre>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">Repeat <em class="calibre18">step 2</em> for all traits/classes.</li>
<li value="4" class="calibre8">Finally, place the trait/class at the very first position from the left:</li>
</ol>
<pre class="calibre36">Socializer -&gt; Spanish -&gt; British -&gt; AnyRef -&gt; Any</pre>
<p class="calibre2">The direction of super calls is going to be from <em class="calibre18">left</em> to <em class="calibre18">right.</em> And for our implementation, where we extended from <kbd class="calibre11">Spanish</kbd> with <kbd class="calibre11">British</kbd>, we now know that the <kbd class="calibre11">super</kbd> call invoked is on the <kbd class="calibre11">Spanish</kbd> trait due to linearization. The result was from the <kbd class="calibre11">Spanish</kbd> trait.</p>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Hola Alberto </pre>
<p class="calibre2">This understanding can help us a lot to learn the usual behavior of trait mix-ins and inheritance. Knowing how linearization works is essential to understanding already written code and creating a good design yourself. Now that you know how linearization works, why not learn another important concept in object-oriented programming?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Packaging and importing</h1>
                
            
            <article>
                
<p class="calibre2">One of the important aspects of object-oriented programs is how we define modular, reusable, and hierarchical structures. We're allowed to put all the code that we write, constructs like classes, traits, and objects, in some particular package. By using <em class="calibre18">packaging</em> and <em class="calibre18">visibility</em> rules, we can make our code more to reason about, means to expose some method to other classes or  and we get structured and modular code as an added advantage. There are a couple of ways you're allowed to write package statements in Scala; we'll take a look at those.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Package statements</h1>
                
            
            <article>
                
<p class="calibre2">We can write package statements at the beginning of the file. One of the simplest examples is as follows:</p>
<pre class="calibre19">package country 
 
class Country(val name: String) { 
  import Country._ 
 
  val populationsMap  = scala.collection.mutable.Map[Int, Double]() 
 
  def showAveragePopulation() = println(averagePopulation(this.populationsMap.values))<br class="title-page-name"/> } 
 
object Country {<br class="title-page-name"/>   def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size 
 
} </pre>
<p class="calibre2">Here, we defined the package name as <kbd class="calibre11">country</kbd>. Now, whatever we define in the corresponding file is going to stay within the scope of this <kbd class="calibre11">country</kbd> package. This is the reason why, when we wanted to use a function in the <kbd class="calibre11">Country</kbd> companion object<em class="calibre18">,</em> we did not need to explicitly put the following:</p>
<pre class="calibre19">  import country.Country._ </pre>
<p class="calibre2">The ending <kbd class="calibre11">_</kbd> underscore symbol, is Scala's ways of doing a wildcard import. It means that non-private members are going to be accessible within the current scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multiple package statements in a file</h1>
                
            
            <article>
                
<p class="calibre2">Scala also allows us to put multiple package declarations and nested package declarations. First let's take a look at how:</p>
<pre class="calibre19">import country.Country 
import customutil.Util.averagePopulation 
 
package country { 
 
  class Country(val name: String) { 
 
    val populationsMap  = scala.collection.mutable.Map[Int, Double]() 
 
    def showAveragePopulation() = println(averagePopulation(this.populationsMap.values))<br class="title-page-name"/>   } 
} 
 
package state { 
 
  class State(val name: String) { 
 
    val populationsMap  = scala.collection.mutable.Map[Int, Double]() 
 
    def showAveragePopulation() = println(averagePopulation(this.populationsMap.values))<br class="title-page-name"/>   } 
 
} 
 
package customutil { 
  object Util { 
 
    def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size 
 
  } 
} </pre>
<p class="calibre2">In the preceding code we see how we can define multiple package statements within a file. A thing worth noticing is the way we did this. We used curly parentheses along with a <kbd class="calibre11">package</kbd> keyword to tell the Scala compiler that here's our package. Whatever we write inside this is going to reside in that package. Here, we defined three packages. One is <kbd class="calibre11">country</kbd>, to define country-specific constructs, another one is <kbd class="calibre11">state</kbd>, to define state specific constructs. The last one is a <kbd class="calibre11">customutil</kbd> package, which, as the name tells us, is to define utility functions for all the country/state functionalities. The <kbd class="calibre11">averagePopulation</kbd> function is not specific to country or state but can be used in both cases, hence it is defined in separate packages and imported globally at the top. With that import, we've gotten access for <kbd class="calibre11">customutil</kbd> to the scope of the whole compilation unit. One more thing we could have done is to declare package <kbd class="calibre11">state</kbd> as a nested package to <kbd class="calibre11">country</kbd>, because it's obvious multiple <kbd class="calibre11">country</kbd> constructs and members should be directly accessible to <kbd class="calibre11">state</kbd> constructs as well. Let's see how it's going to look.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Nested package statements</h1>
                
            
            <article>
                
<p class="calibre2">We know there might be times when we need some <kbd class="calibre11">country</kbd> package constructs directly available to the <kbd class="calibre11">state</kbd> package. In those scenarios we can define the <kbd class="calibre11">state</kbd> package as a nested package inside <kbd class="calibre11">country</kbd>. Let's write that as follows:</p>
<pre class="calibre19">import country.Country 
 
package country { 
  import customutil.Util.averagePopulation 
 
  abstract class Region 
   
  class Country(val name: String) extends Region{ 
 
    val populationsMap  = scala.collection.mutable.Map[Int, Double]() 
 
    def showAveragePopulation() = println(averagePopulation(this.populationsMap.values)) 
 
  } 
 
  package state { 
 
    class State(val name: String) extends Region { 
 
      val populationsMap  = scala.collection.mutable.Map[Int, Double]() 
 
      def showAveragePopulation() = println(averagePopulation(this.populationsMap.values)) 
    } 
 
  } 
} 
 
package customutil { 
  object Util { 
 
    def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size 
 
  } 
} </pre>
<p class="calibre2">Here, we have a package <kbd class="calibre11">state</kbd> declaration nested inside a <kbd class="calibre11">country</kbd> package declaration. What this does is to avoid making explicit mentions to the full package declaration while importing. Also, it makes code easier to understand and more structured. It shows that it's OK to expect a country to be a <kbd class="calibre11">Region</kbd>, and a state can also be treated as a region. Thus, nesting of packages is also a good way to document your code. It shows an understanding of the structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Chaining package statements</h1>
                
            
            <article>
                
<p class="calibre2">There's another way we can put up these package declarations, and that is by chaining the declarations of packages. How can we do this?</p>
<pre class="calibre19">package country 
package state 
 
class State(val name: String) extends Region { 
 
  val populationsMap  = scala.collection.mutable.Map[Int, Double]() 
 
  def showAveragePopulation = println(averagePopulation(this.populationsMap.values)) 
} </pre>
<p class="calibre2">By keeping the <kbd class="calibre11">Region</kbd> class in the <kbd class="calibre11">country</kbd> package, if we declare the <kbd class="calibre11">State</kbd> class with the preceding syntax, things will work out fine, and your class <kbd class="calibre11">State</kbd> is going to reside in package <kbd class="calibre11">country.state</kbd>. That means <kbd class="calibre11">state</kbd> is going to be a nested package. This way of writing package names is widely used in several libraries, you may find this out when you explore some of them.</p>
<p class="calibre2">These are all ways you can declare package names, and now you also know the reasoning behind it. Just because of the fact that we have the license to declare multiple package names, means it's easier for us to separate constructs based on their usage. For example, it's perfectly fine to declare a package for a <kbd class="calibre11">TestSuite</kbd> for your classes in the same file with a different package name. Everyone has their ways of writing and structuring package names. With these, declarations, we also have more than one way of importing these constructs in other scopes. Importing packages in Scala can also be done in some interesting ways; why not take a dig at that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Importing packages</h1>
                
            
            <article>
                
<p class="calibre2">In simpler scenarios, just to bring some objects into scope, we put an <kbd class="calibre11">import</kbd> statement before it. This is how importing can be done:</p>
<pre class="calibre19">object CountryApp extends App { 
  import customutil.Util.averagePopulation 
  val aCountry = new Country("France") 
  aCountry.populationsMap.put(2017, 64.94) 
  aCountry.populationsMap.put(2016, 64.66) 
  aCountry.populationsMap.put(2015, 64.395) 
 
  println(averagePopulation(aCountry.populationsMap.values)) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">64.66499999999999 </pre>
<p class="calibre2">We use an <kbd class="calibre11">import</kbd> keyword and give the name of the import. A few points to note down while using <kbd class="calibre11">import</kbd> in Scala:</p>
<ul class="calibre7">
<li class="calibre8">We are allowed to use imports anywhere in the file</li>
<li class="calibre8">In instances where two imports collide, we have the right to hide one over the other</li>
<li class="calibre8">We can also rename some imports</li>
</ul>
<p class="calibre2">With this, we get flexibility while importing packages. Let's take a look at some of these:</p>
<pre class="calibre19">package country {<br class="title-page-name"/>   abstract class Region<br class="title-page-name"/><br class="title-page-name"/>   import customutil.{Util =&gt; u}<br class="title-page-name"/><br class="title-page-name"/>   class Country(val name: String) extends Region {<br class="title-page-name"/><br class="title-page-name"/>     val populationsMap  = scala.collection.mutable.Map[Int, Double]()<br class="title-page-name"/><br class="title-page-name"/>     def showAveragePopulation = println(u.averagePopulation(this.populationsMap.values))<br class="title-page-name"/>   }<br class="title-page-name"/><br class="title-page-name"/>   package state {<br class="title-page-name"/><br class="title-page-name"/>     class State(val name: String) extends Region {<br class="title-page-name"/><br class="title-page-name"/>       import u.{averagePopulation =&gt; ap}<br class="title-page-name"/><br class="title-page-name"/>       val populationsMap  = scala.collection.mutable.Map[Int, Double]()<br class="title-page-name"/><br class="title-page-name"/>       def showAveragePopulation = println(ap(this.populationsMap.values))<br class="title-page-name"/>     }<br class="title-page-name"/><br class="title-page-name"/>   }<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> package customutil {<br class="title-page-name"/>   object Util {<br class="title-page-name"/><br class="title-page-name"/>     def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size<br class="title-page-name"/><br class="title-page-name"/>   }<br class="title-page-name"/> } </pre>
<p class="calibre2">In the preceding examples, we declared an <kbd class="calibre11">import</kbd> statement just before we wanted to use it. Also, see the following statement:</p>
<pre class="calibre19">import customutil.{Util =&gt; u} </pre>
<p class="calibre2">This allowed us to use <kbd class="calibre11">u</kbd> in place of the <kbd class="calibre11">Util</kbd> object<em class="calibre18">:</em></p>
<pre class="calibre19">println(u.averagePopulation(this.populationsMap.values)) </pre>
<p class="calibre2">Using these depends on the scenario; most often we need to take care of code readability. For example, renaming <kbd class="calibre11">scala.collection.mutable</kbd> to something shorter is a good thing to do—developers following the code are going to find it easier to understand. Also, if you take a closer look, we renamed the object <kbd class="calibre11">Util</kbd>, so it's proven that Scala allows us to import as well as rename objects. Moreover, Scala is capable enough of renaming the function names, and why not? Those are members that we are importing. We did just that in the following:</p>
<pre class="calibre19">import u.{averagePopulation =&gt; ap} </pre>
<p class="calibre2">We renamed the <kbd class="calibre11">averagePopulation</kbd> <span>function</span> to <kbd class="calibre11">ap</kbd><em class="calibre18">,</em> and used that in the following:</p>
<pre class="calibre19">println(ap(this.populationsMap.values)) </pre>
<p class="calibre2">We may need to keep in mind the same point: we may be renaming whenever it makes sense to do so—in our example, it doesn't. But for demonstration purposes, it's OK to consider that it does. Scala's extensive ways for packaging and importing makes things easier for us. In namespace collision scenarios, we've ways to hide a definition over the other. That can be done with the following syntax:</p>
<pre class="calibre19">import package1.{Member =&gt; _} </pre>
<p class="calibre2">You see? The declaration is self-explanatory. We renamed a particular package/member to a wildcard. It no longer provides any means to using this particular <kbd class="calibre11">Member</kbd> in the current scope and hides it. This is Scala's way of hiding a particular package/member.</p>
<p class="calibre2">These multiple ways of packaging and importing make our code easy to understand, but this is not all. We can also provide a few modifiers to control access to our members. We can make them <kbd class="calibre11">private</kbd>, <kbd class="calibre11">protected</kbd>, or by default <kbd class="calibre11">public</kbd>. Let's discuss them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Visibility rules</h1>
                
            
            <article>
                
<p class="calibre2">There are times when we don't want to let another class or similar construct use a few members. Here, we can use Scala's provided access modifiers. How we achieve control over the accessibility of members of our classes/traits/objects is through <kbd class="calibre11">private</kbd>, <kbd class="calibre11">public</kbd>, or <kbd class="calibre11">protected</kbd> access modifiers. Take a look at the following example:</p>
<pre class="calibre19">package restaurant 
 
package privaterestaurant { 
 
  case class Dish(name: String) 
 
  trait Kitchen { 
    self: PrivateRestaurant =&gt; 
 
    private val secret = "Secret to tasty dish" //Think of a secret logical evaluation resulting in value, we don't want to expose. 
 
    def cookMyDish: Option[Dish] = Some(Dish(secret)) 
 
  } 
 
  class PrivateRestaurant extends Kitchen { 
 
    def serveDishWithSecret = Dish(secret) // Symbol secret is inaccessible from this place. 
 
    def serveDish = cookMyDish // Works fine 
  } 
 
} </pre>
<p class="calibre2">Here, we have some trait named <kbd class="calibre11">Kitchen</kbd>. It has a secret way of cooking a really tasty dish, but only for <kbd class="calibre11">PrivateRestaurant</kbd> types. The secret cannot be shared outside the kitchen. In those scenarios, we can keep the secret as it is by declaring it with a modifier named <kbd class="calibre11">private</kbd>. With this, when we try to access the secret recipe, we are not able to do that. The Scala compiler gives an error stating: <em class="calibre18">Symbol secret is inaccessible from this place.</em> With that we were able to keep our secret intact. But what if you want to let your private restaurant access the secret and no one else. In that case you can make it <kbd class="calibre11">protected</kbd>.</p>
<p class="calibre2">After making our secret protected, we can get access to it only if <kbd class="calibre11">PrivateRestaurant</kbd> extends <kbd class="calibre11">Kitchen</kbd>. If you remember, this is doing composition and thus we'll have access to the secret by just changing the <kbd class="calibre11">private</kbd> modifier to <kbd class="calibre11">protected</kbd>:</p>
<pre class="calibre19">protected val secret = "Secret to tasty dish" //Think of a secret logical evaluation resulting in value, we don't want to expose. </pre>
<p class="calibre2">We should know, for <kbd class="calibre11">protected</kbd> to work, it's a must to inherit the member class/trait. What we mean by this is the following:</p>
<pre class="calibre19">class PrivateRestaurant extends Kitchen { 
 
  def serveDishWithSecret = Dish(secret) // Works fine 
  def serveDish = cookMyDish // Works fine 
} </pre>
<p class="calibre2">As you can see, we have this mix-in. That's the reason why, after applying the <kbd class="calibre11">protected</kbd> modifier, we got access to the secret recipe. By the way, when we don't specify any access modifiers, Scala treats the members as <kbd class="calibre11">public</kbd> and those members can be accessed if in scope. When it comes to controlling the access levels, Scala has more to offer than what we just learnt. We can also specify the scope of protection. By scope of protection we mean that the particular member is visible up to a certain level. Here, it depends on us what level we define. Let's look at an example to understand this:</p>
<pre class="calibre19">case class Dish(name: String) 
 
class Restaurant 
 
package privaterestaurant{<br class="title-page-name"/>   trait Kitchen { 
    self: Restaurant =&gt; 
 
    private[privaterestaurant]  val secret = "Secret to tasty dish" //Think of a secret logical evaluation resulting in value, we don't want to expose. 
 
    def cookMyDish: Option[Dish] = Some(Dish(secret)) 
 
  } 
 
  class  PrivateRestaurant  extends Restaurant with Kitchen  { 
 
    def serveDishWithSecret = Dish(secret) // Symbol secret is inaccessible from this place. 
 
    def serveDish = cookMyDish // Works fine 
  } 
 
} 
 
package  protectedrestaurant { 
 
  import restaurant.privaterestaurant.Kitchen 
 
  class ProtectedRestaurant extends Restaurant with Kitchen { 
 
    def serveDishWithSecret = Dish(secret) // Symbol secret is inaccessible from this place. 
 
    def serveDish = cookMyDish // Works fine 
  } 
} </pre>
<p class="calibre2">With a proper look at the code, there are some points that we can consider:</p>
<ul class="calibre7">
<li class="calibre8">In the following declaration, it makes it clear that the secret value is going to be privately accessible within this package named <kbd class="calibre11">privaterestaurant</kbd>:</li>
</ul>
<pre class="calibre36">private[privaterestaurant] val secret = "Secret to tasty dish" //Think of a secret logical evaluation resulting in value, <br class="title-page-name"/>//we don't want to expose </pre>
<ul class="calibre7">
<li class="calibre8">Also, the Scala compiler is not going to complain about the way you used these scopes, but at runtime you can expect an exception if your scope is not within the package. It means that for our following declaration:</li>
</ul>
<pre class="calibre36">private[privaterestaurant] val secret  </pre>
<p class="calibre37">For it to work properly, we need to be part of this package. That's logically correct, otherwise it's not wise to apply privacy to something that's not ours.</p>
<ul class="calibre7">
<li class="calibre8">Similar to <kbd class="calibre11">private[X]</kbd>, we can also define <kbd class="calibre11">protected[Y]</kbd> and so on. Defining <kbd class="calibre11">protected</kbd> for some package is going to make it available to classes in the inheritance tree.</li>
<li class="calibre8">There's another level of protection, that is, <kbd class="calibre11">private[this]</kbd>. It's going to make a particular member available to an instance of the same class.</li>
</ul>
<p class="calibre2">It's really important to control the access level. With it we can have fine-grain scope for every construct. This keeps the client away from unnecessary details that you might not want them to access. This is all about limiting the scope for members. There are a few more construct such as <kbd class="calibre11">sealedtraits</kbd>, that help us structure the code in a good way, but that's just one thing about them. There's much more to know about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sealed traits</h1>
                
            
            <article>
                
<p class="calibre2">One good thing about <strong class="calibre1">sealed traits</strong> is that standard Scala library uses these constructs a lot, and you've also seen them many times so far. It's time to learn about them. We'll start with an example:</p>
<pre class="calibre19">sealed trait Season 
 
case object Autumn extends Season 
case object Winter extends Season 
case object Spring extends Season 
case object Summer extends Season 
case object Monsoon extends Season 
 
object SealedApp extends App { 
  def season(season: Season) = season match { 
    case Autumn =&gt; println(s"It's Autumn :)") 
    case Winter =&gt; println(s"It's Winter, Xmas time!") 
    case Spring =&gt; println(s"It's Spring!!") 
    case Summer =&gt; println(s"It's summer, who likes summer anyway!") 
    case Monsoon =&gt; println(s"It's Monsoon!!") 
  } 
  season(Spring) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">It's Spring!!" </pre>
<p class="calibre2">Here, we defined a sealed trait named <kbd class="calibre11">Season</kbd>. Then there're a few child season case objects extending from the <kbd class="calibre11">sealed trait Season</kbd>. By the way, case objects are like <kbd class="calibre11">case</kbd> classes with the difference being that these are only instances with already available names, unlike the <kbd class="calibre11">case</kbd> classes. There're a few points to note about the preceding implementation of the sealed trait named <kbd class="calibre11">Season</kbd>.</p>
<ul class="calibre7">
<li class="calibre8">All children extending the <kbd class="calibre11">Season</kbd> trait should be defined in the same file.</li>
<li class="calibre8">Constructs such as sealed traits come with a license to perform pattern matching. This is good for design constructs.</li>
<li class="calibre8">Also, when we perform <em class="calibre18">pattern matching</em> on sealed traits, we need to take care of all the possibilities. Otherwise, as we know, the Scala compiler is intelligent enough to come up with a warning about the remaining scenarios whenever it sees that the pattern match is on a sealed trait.</li>
</ul>
<p class="calibre2">A few good and known examples of sealed traits are <kbd class="calibre11">Option</kbd> type to two children named <kbd class="calibre11">Some</kbd> and <kbd class="calibre11">None</kbd>. Then, <kbd class="calibre11">List</kbd> is also defined as a sealed trait. This was a short introduction to sealed traits with the license for you to experiment with the construct. With sealed traits we have come to the end of the chapter. Let's summarize what we have learnt so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was more exciting. We learnt about inheritance in Scala and discussed composition and inheritance. It's really going to help us when we take design decisions about our implementation. Then we learnt about this amazing construct named traits and we tried various ways of using traits. Then we learnt about the concept of linearization which it helped us understand how super calls are resolved. Then we talked about packaging and importing which was exciting as Scala provides different ways to use them. Finally, we learnt about <em class="calibre18">visibility rules</em> and <em class="calibre18">sealed traits</em>. And after going through all these concepts, we can say with confidence that we now understand the object-oriented concepts in Scala. So, it's time for us to do some real functional programming. In the next few chapters our focus will be on using functions in Scala.</p>


            </article>

            
        </section>
    </body></html>