<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Working with Integration and Web Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Working with Integration and Web Services</h1></div></div></div><p>Because technology stacks evolve continuously, a large area to consider when developing commercial software is the integration between systems. The flexibility and scalability of the Web have seen the proliferation of services built on top of HTTP to integrate systems in a loosely-coupled fashion. Moreover, to be able to navigate through secure networks accessible via firewalls and additional security mechanisms, the HTTP model has been increasingly popular. In this chapter, we are going to cover how to involve Scala when integrating with systems either via Web Services or REST Services exchanging messages in formats such as XML and JSON. In particular, we will consider running such services through the Play Framework.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generating data bindings from XML schemas as well as SOAP web service classes out of their WSDL description</li><li class="listitem" style="list-style-type: disc">Manipulating XML and JSON in Scala and in particular in the context of the Play Framework</li><li class="listitem" style="list-style-type: disc">Invoking other REST web services from Play, and validating and displaying their response</li></ul></div><div class="section" title="Binding XML data in Scala"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Binding XML data in Scala</h1></div></div></div><p>Even if XML has recently <a id="id356" class="indexterm"/>stepped down a bit from its ubiquitous position due to the increasing popularity of JSON, both formats will continue to be heavily used to structure data.</p><p>In Java, it is a common practice to <a id="id357" class="indexterm"/>use the JAXB libraries to create classes that are able to serialize and deserialize XML data and construct XML documents through an API.</p><p>In a similar manner, the <code class="literal">scalaxb</code> <a id="id358" class="indexterm"/>library available for Scala can generate help classes for working with XML and web services. As an example, let's consider a small XML schema, <code class="literal">Bookstore.xsd,</code> that defines a set of books as part of a book store as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema 
            targetNamespace="http://www.books.org"
            
            elementFormDefault="qualified"&gt;
    &lt;xsd:element name="book_store"&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:sequence&gt;
                &lt;xsd:element name="book" type="book_type" 
                             minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
    &lt;xsd:complexType name="book_type"&gt;
         &lt;xsd:sequence&gt;
             &lt;xsd:element name="title" type="xsd:string"/&gt;
             &lt;xsd:element name="author" type="xsd:string"/&gt;
             &lt;xsd:element name="date" minOccurs="0" type="xsd:string"/&gt;
             &lt;xsd:element name="publisher" type="xsd:string"/&gt;
         &lt;/xsd:sequence&gt;
         &lt;xsd:attribute name="ISBN" type="xsd:string"/&gt;
     &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;</pre></div><p>A typical book is defined by its title, <a id="id359" class="indexterm"/>author, date of publication, and ISBN number, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">&lt;book ISBN="9781933499185"&gt;
  &lt;title&gt;Madame Bovary&lt;/title&gt;
  &lt;author&gt;Gustave Flaubert&lt;/author&gt;
  &lt;date&gt;1857&lt;/date&gt;
  &lt;publisher&gt;Fonolibro&lt;/publisher&gt;
&lt;/book&gt;</pre></div><p>There are several ways one can run <code class="literal">scalaxb</code> documented on the <a class="ulink" href="http://www.scalaxb.org">www.scalaxb.org</a> website: either directly as a command <a id="id360" class="indexterm"/>line tool, through plugins from SBT or Maven, or as a web API hosted on <code class="literal">heroku</code>. Since we have essentially used SBT so far and should be comfortable with it, let's use the SBT plugin to create the bindings.</p><p>First create a new SBT project entitled <code class="literal">wssample</code> by running the following commands in a new terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mkdir wssample</strong></span>
<span class="strong"><strong>&gt; cd wssample</strong></span>
<span class="strong"><strong>&gt; sbt</strong></span>
<span class="strong"><strong>&gt; set name:="wssample"</strong></span>
<span class="strong"><strong>&gt; session save</strong></span>
<span class="strong"><strong>&gt; </strong></span>
</pre></div><p>Now we need to add the <code class="literal">scalaxb</code> plugin dependency to a <code class="literal">plugins.sbt</code> file under <code class="literal">project/</code> (and at the same <a id="id361" class="indexterm"/>time we will add the <code class="literal">sbteclipse</code> plugin that enables us to generate an Eclipse project out of the SBT project). The resulting <code class="literal">plugins.sbt</code> file will look similar to the following code:</p><div class="informalexample"><pre class="programlisting">addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "2.4.0")

addSbtPlugin("org.scalaxb" % "sbt-scalaxb" % "1.1.2")
 
resolvers += Resolver.sonatypeRepo("public")</pre></div><p>Additionally, we have to slightly <a id="id362" class="indexterm"/>modify the <code class="literal">build.sbt</code> file to notably include a command that will <a id="id363" class="indexterm"/>generate <code class="literal">scalaxb</code> XML bindings when compiling with SBT. The resulting <code class="literal">build.sbt</code> file will look similar to the following code:</p><div class="informalexample"><pre class="programlisting">import ScalaxbKeys._

name:="wssample"

scalaVersion:="2.10.2"

scalaxbSettings

libraryDependencies += "net.databinder.dispatch" %% "dispatch-core" % "0.11.0"
 
libraryDependencies += "org.scalatest" %% "scalatest" % "2.0.M7" % "test"

sourceGenerators in Compile &lt;+= scalaxb in Compile

packageName in scalaxb in Compile := "se.wssample"</pre></div><p>Add the <code class="literal">Bookstore.xsd</code> schema shown previously to a new <code class="literal">src/main/xsd</code> directory created within the project. From now on, each time you invoke the SBT command <code class="literal">&gt; compile</code>, <code class="literal">scalaxb</code> will generate some <a id="id364" class="indexterm"/>Scala classes under the <code class="literal">target/scala-2.10/src_managed</code> directory (in the package given in the <code class="literal">build.sbt</code> file that is, <code class="literal">se.wssample</code>), unless no changes have been made. For instance, in the case of our small example, <code class="literal">scalaxb</code> generates the <a id="id365" class="indexterm"/>following case classes:</p><div class="informalexample"><pre class="programlisting">package se.wssample

case class Book_store(book: se.wssample.Book_type*)

case class Book_type(title: String,
  author: String,
  date: Option[String] = None,
  publisher: String,
  ISBN: Option[String] = None)</pre></div><p>Note the <code class="literal">*</code> at the end of the first case class declaration, which is used to specify varargs (that is, an unspecified number of arguments, so here the <code class="literal">Book_store</code> constructor can take several <code class="literal">Book_type</code> instances). A <a id="id366" class="indexterm"/>possible test class illustrating the usage of the generated code to parse an XML document is given in the <code class="literal">BookstoreSpec.scala</code> class as follows:</p><div class="informalexample"><pre class="programlisting">package se.wssample

import org.scalatest._
import org.scalatest.matchers.Matchers

class BookstoreSpec extends FlatSpec with Matchers {
  "This bookstore" should "contain 3 books" in {
    
    val bookstore =
    &lt;book_store &gt;
        &lt;book ISBN="9781933499185"&gt;
            &lt;title&gt;Madame Bovary&lt;/title&gt;
            &lt;author&gt;Gustave Flaubert&lt;/author&gt;
            &lt;date&gt;1857&lt;/date&gt;
            &lt;publisher&gt;Fonolibro&lt;/publisher&gt;
        &lt;/book&gt;
        &lt;book ISBN="9782070411207"&gt;
            &lt;title&gt;Le malade imaginaire&lt;/title&gt;
            &lt;author&gt;Moliere&lt;/author&gt;
            &lt;date&gt;1673&lt;/date&gt;
            &lt;publisher&gt;Gallimard&lt;/publisher&gt;
        &lt;/book&gt;
        &lt;book ISBN="1475066511"&gt;
            &lt;title&gt;Fables&lt;/title&gt;
            &lt;author&gt;Jean de La Fontaine&lt;/author&gt;
            &lt;date&gt;1678&lt;/date&gt;
            &lt;publisher&gt;CreateSpace&lt;/publisher&gt;
        &lt;/book&gt;
    &lt;/book_store&gt;
    
    val bookstoreInstance = scalaxb.fromXML[Book_store](bookstore)
    
    println("bookstoreInstance: "+ bookstoreInstance.book)
    
    bookstoreInstance.book.length should be === 3
  }
}</pre></div><p>The expected output from this test <a id="id367" class="indexterm"/>when invoking the <code class="literal">&gt; sbt test</code> command is as <a id="id368" class="indexterm"/>follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bookstoreInstance: List(Book_type(Madame Bovary,Gustave Flaubert,Some(1857),Fonolibro,Some(9781933499185)), Book_type(Le malade imaginaire,Molière,Some(1673),Gallimard,Some(9782070411207)), Book_type(Fables,Jean de La Fontaine,Some(1678),CreateSpace,Some(1475066511)))</strong></span>
<span class="strong"><strong>[info] BookstoreSpec:</strong></span>
<span class="strong"><strong>[info] This bookstore</strong></span>
<span class="strong"><strong>[info] - should contain 3 books</strong></span>
<span class="strong"><strong>[info] Passed: : Total 1, Failed 0, Errors 0, Passed 1, Skipped 0</strong></span>
<span class="strong"><strong>[success] Total time: 4 s</strong></span>
</pre></div><div class="section" title="Running scalaxb from a SOAP web service"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Running scalaxb from a SOAP web service</h2></div></div></div><p>Since <code class="literal">scalaxb</code> <a id="id369" class="indexterm"/>supports the <span class="strong"><strong>Web Services Description </strong></span><a id="id370" class="indexterm"/>
<span class="strong"><strong>Language</strong></span> (<span class="strong"><strong>WSDL</strong></span>), we can also generate a full web service <a id="id371" class="indexterm"/>API in addition to the XML data-only related classes. To achieve this functionality, we just need to copy our WSDL service description file to <code class="literal">src/main/wsdl</code>. All the files with the <code class="literal">.wsdl</code> extension will be processed at compile time by the <code class="literal">scalaxb</code> plugin that will create the following three types of output:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The service API specific to your application.</li><li class="listitem" style="list-style-type: disc">Classes specific to the SOAP protocol.</li><li class="listitem" style="list-style-type: disc">Classes responsible for sending the SOAP messages to the endpoint URL via HTTP. <code class="literal">scalaxb</code> uses the dispatch library that we introduced in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>. This is why we added it as a dependency into the <code class="literal">build.sbt</code> file.</li></ul></div><p>Let's take an online SOAP web service as a way to illustrate the usage of <code class="literal">scalaxb</code> from a WSDL description. <a class="ulink" href="http://www.webservicex.net">www.webservicex.net</a> is a site that contains many different samples of such web services in <a id="id372" class="indexterm"/>various market segments. Here, we will focus on their Stock Quote service that returns quotes given by a stock symbol. The API is very straightforward since it consists of only <a id="id373" class="indexterm"/>one request method, <code class="literal">getQuote</code>, and the data it returns is limited in size. You might want to try any other available service (later on as you can have multiple WSDL files in your same project). Its WSDL description looks similar to the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;wsdl:definitions … // headers &gt; 
  &lt;wsdl:types&gt;
    &lt;s:schema elementFormDefault="qualified" targetNamespace="http://www.webserviceX.NET/"&gt;
      &lt;s:element name="GetQuote"&gt;
        &lt;s:complexType&gt;
          &lt;s:sequence&gt;
            &lt;s:element minOccurs="0" maxOccurs="1" name="symbol" type="s:string" /&gt;
          &lt;/s:sequence&gt;
        &lt;/s:complexType&gt;
      &lt;/s:element&gt;
      &lt;s:element name="GetQuoteResponse"&gt;
        &lt;s:complexType&gt;
          &lt;s:sequence&gt;
            &lt;s:element minOccurs="0" maxOccurs="1" name="GetQuoteResult" type="s:string" /&gt;
          &lt;/s:sequence&gt;
        &lt;/s:complexType&gt;
      &lt;/s:element&gt;
      &lt;s:element name="string" nillable="true" type="s:string" /&gt;
    &lt;/s:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="GetQuoteSoapIn"&gt;
    &lt;wsdl:part name="parameters" element="tns:GetQuote" /&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="GetQuoteSoapOut"&gt;
    &lt;wsdl:part name="parameters" element="tns:GetQuoteResponse" /&gt;
  &lt;/wsdl:message&gt;
  ...</pre></div><p>The first part of the WSDL file contains the description of the XML schema. The second part defines the various web service operations as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;wsdl:portType name="StockQuoteSoap"&gt;
    &lt;wsdl:operation name="GetQuote"&gt;
      &lt;wsdl:documentation &gt;Get Stock quote for a company Symbol&lt;/wsdl:documentation&gt;
      &lt;wsdl:input message="tns:GetQuoteSoapIn" /&gt;
      &lt;wsdl:output message="tns:GetQuoteSoapOut" /&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:portType name="StockQuoteHttpGet"&gt;
    &lt;wsdl:operation name="GetQuote"&gt;
      &lt;wsdl:documentation &gt;Get Stock quote for a company Symbol&lt;/wsdl:documentation&gt;
      &lt;wsdl:input message="tns:GetQuoteHttpGetIn" /&gt;
      &lt;wsdl:output message="tns:GetQuoteHttpGetOut" /&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  
  &lt;wsdl:binding name="StockQuoteSoap12" type="tns:StockQuoteSoap"&gt;
    &lt;soap12:binding transport="http://schemas.xmlsoap.org/soap/http" /&gt;
    &lt;wsdl:operation name="GetQuote"&gt;
      &lt;soap12:operation soapAction="http://www.webserviceX.NET/GetQuote" style="document" /&gt;
      &lt;wsdl:input&gt;
        &lt;soap12:body use="literal" /&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap12:body use="literal" /&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  ...</pre></div><p>Finally, the last part of the WSDL file <a id="id374" class="indexterm"/>defines the coupling between web service operations and physical URLs:</p><div class="informalexample"><pre class="programlisting">  &lt;wsdl:service name="StockQuote"&gt;
    …
    &lt;wsdl:port name="StockQuoteSoap12" binding="tns:StockQuoteSoap12"&gt;
      &lt;soap12:address location="http://www.webservicex.net/stockquote.asmx" /&gt;
    &lt;/wsdl:port&gt;
    …
  &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre></div><p>As you can see, the WSDL files are often <a id="id375" class="indexterm"/>pretty verbose, but the Scala contract resulting from the <code class="literal">scalaxb</code> generation boils down to this one method trait:</p><div class="informalexample"><pre class="programlisting">// Generated by &lt;a href="http://scalaxb.org/"&gt;scalaxb&lt;/a&gt;.
package se.wssample

trait StockQuoteSoap {
  def getQuote(symbol: Option[String]): Either[scalaxb.Fault[Any], se.wssample.GetQuoteResponse]
}</pre></div><p>Notice how the resulting type is nicely wrapped into an <code class="literal">Either</code> class that represents a value of one of the two possible types, <code class="literal">Left</code> and <code class="literal">Right</code>, where the <code class="literal">Right</code> object corresponds to a successful invocation of the service whereas the <code class="literal">Left</code> object contains a <code class="literal">scalaxb.Fault</code> value in case of failure, as we have briefly described in <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration</em></span>.</p><p>Since the generated classes concerning the SOAP protocol and the HTTP dispatch-related classes are not specific to the service we are defining, they can be reused and therefore have been generated as stackable traits including data types and interface, SOAP bindings, and full SOAP clients. A typical usage scenario of these traits to invoke a SOAP web service is given in the following <code class="literal">StockQuoteSpec.scala</code> test sample:</p><div class="informalexample"><pre class="programlisting">package se.wssample

import org.scalatest._
import org.scalatest.matchers.Matchers
import scala.xml.{ XML, PrettyPrinter }

class StockQuoteSpec extends FlatSpec with Matchers {
  "Getting a quote for Apple" should "give appropriate data" in {
    
    val pp = new PrettyPrinter(80, 2)
    
    val service = 
      (new se.wssample.StockQuoteSoap12Bindings 
        with scalaxb.SoapClients 
        with scalaxb.DispatchHttpClients {}).service
    
    val stockquote = service.getQuote(Some("AAPL"))
    
    stockquote match {
      case Left(err) =&gt; fail("Problem with stockquote invocation")
      case Right(success) =&gt; success.GetQuoteResult match {
        case None =&gt; println("No info returned for that quote")
        case Some(x) =&gt; {
          println("Stockquote: "+pp.format(XML.loadString(x)))
          x should startWith ("&lt;StockQuotes&gt;&lt;Stock&gt;&lt;Symbol&gt;AAPL&lt;/Symbol&gt;")
        }
      }
    }
  }
}</pre></div><p>In this example, once we have instantiated the service, we will just call the API method <code class="literal">service.getQuote(Some("AAPL"))</code> for retrieving the stock quote of the AAPL symbol (Apple, Inc). We then pattern <a id="id376" class="indexterm"/>match on the result to extract the XML data out of the <code class="literal">Either</code> object that was returned by the service. Finally, since the <a id="id377" class="indexterm"/>retrieved data is given as a string of XML, we parse it and format it for better reading. We can execute the test using the following code to see what comes out of it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; sbt</strong></span>
<span class="strong"><strong>&gt; test-only se.wssample.StockQuoteSpec</strong></span>
<span class="strong"><strong>Stockquote: &lt;StockQuotes&gt;</strong></span>
<span class="strong"><strong>  &lt;Stock&gt;</strong></span>
<span class="strong"><strong>    &lt;Symbol&gt;AAPL&lt;/Symbol&gt;</strong></span>
<span class="strong"><strong>    &lt;Last&gt;553.13&lt;/Last&gt;</strong></span>
<span class="strong"><strong>    &lt;Date&gt;1/2/2014&lt;/Date&gt;</strong></span>
<span class="strong"><strong>    &lt;Time&gt;4:00pm&lt;/Time&gt;</strong></span>
<span class="strong"><strong>    &lt;Change&gt;-7.89&lt;/Change&gt;</strong></span>
<span class="strong"><strong>    &lt;Open&gt;555.68&lt;/Open&gt;</strong></span>
<span class="strong"><strong>    &lt;High&gt;557.03&lt;/High&gt;</strong></span>
<span class="strong"><strong>    &lt;Low&gt;552.021&lt;/Low&gt;</strong></span>
<span class="strong"><strong>    &lt;Volume&gt;8388321&lt;/Volume&gt;</strong></span>
<span class="strong"><strong>    &lt;MktCap&gt;497.7B&lt;/MktCap&gt;</strong></span>
<span class="strong"><strong>    &lt;PreviousClose&gt;561.02&lt;/PreviousClose&gt;</strong></span>
<span class="strong"><strong>    &lt;PercentageChange&gt;-1.41%&lt;/PercentageChange&gt;</strong></span>
<span class="strong"><strong>    &lt;AnnRange&gt;385.10 - 575.14&lt;/AnnRange&gt;</strong></span>
<span class="strong"><strong>    &lt;Earns&gt;39.75&lt;/Earns&gt;</strong></span>
<span class="strong"><strong>    &lt;P-E&gt;14.11&lt;/P-E&gt;</strong></span>
<span class="strong"><strong>    &lt;Name&gt;Apple Inc.&lt;/Name&gt;</strong></span>
<span class="strong"><strong>  &lt;/Stock&gt;</strong></span>
<span class="strong"><strong>&lt;/StockQuotes&gt;</strong></span>
<span class="strong"><strong>[info] StockQuoteSpec:</strong></span>
<span class="strong"><strong>[info] Getting a quote for Apple</strong></span>
<span class="strong"><strong>[info] - should give appropriate data</strong></span>
<span class="strong"><strong>[info] Passed: : Total 1, Failed 0, Errors 0, Passed 1, Skipped 0</strong></span>
<span class="strong"><strong>[success] Total time: 3 s</strong></span>
</pre></div></div></div></div>
<div class="section" title="Working with XML and JSON"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Working with XML and JSON</h1></div></div></div><p>XML and JSON are the dominant formats to structure data that can be exchanged between parts of a system such as backend-frontend or between external systems. In Scala, there is some out-of-the-box support in the Scala library to manipulate both.</p><div class="section" title="Manipulating XML"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Manipulating XML</h2></div></div></div><p>We have briefly seen earlier in this <a id="id378" class="indexterm"/>chapter as well as in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>, when working with HTTP that XML documents can be created as literals and transformed in many ways. For instance, if we launch an REPL by typing <code class="literal">&gt; play console</code> from a Play project root directory, we can start experimenting with XML:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val books =</strong></span>
<span class="strong"><strong>       &lt;Library&gt;</strong></span>
<span class="strong"><strong>         &lt;book title="Programming in Scala" quantity="15" price="30.00" /&gt;</strong></span>
<span class="strong"><strong>         &lt;book title="Scala for Java Developers" quantity="10" price="25.50" /&gt;</strong></span>
<span class="strong"><strong>       &lt;/Library&gt;</strong></span>
<span class="strong"><strong>books: scala.xml.Elem = </strong></span>
<span class="strong"><strong>&lt;Library&gt;</strong></span>
<span class="strong"><strong>  &lt;book title="Programming in Scala" quantity="15" price="30.00"/&gt;</strong></span>
<span class="strong"><strong>  &lt;book title="Scala for Java Developers" quantity="10" price="25.50"/&gt;</strong></span>
<span class="strong"><strong>&lt;/Library&gt;</strong></span>
</pre></div><p>The <code class="literal">books</code> variable is of type <code class="literal">Elem</code>, which represents an XML structure. Rather than directly writing an XML literal, we <a id="id379" class="indexterm"/>could also construct the XML <code class="literal">Elem</code> using utility methods to parse a file or just parse a string, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import scala.xml._</strong></span>
<span class="strong"><strong>scala&gt; val sameBooks = XML.loadString("""</strong></span>
<span class="strong"><strong>         &lt;Library&gt;</strong></span>
<span class="strong"><strong>           &lt;book title="Programming in Scala" quantity="15" price="30.00"/&gt;</strong></span>
<span class="strong"><strong>           &lt;book title="Scala for Java Developers" quantity="10" price="25.50"/&gt;</strong></span>
<span class="strong"><strong>         &lt;/Library&gt;</strong></span>
<span class="strong"><strong>       """)</strong></span>
<span class="strong"><strong>sameBooks: scala.xml.Elem = </strong></span>
<span class="strong"><strong>&lt;Library&gt;</strong></span>
<span class="strong"><strong>&lt;book price="30.00" quantity="15" title="Programming in Scala"/&gt;</strong></span>
<span class="strong"><strong>&lt;book price="25.50" quantity="10" title="Scala for Java Developers"/&gt;</strong></span>
<span class="strong"><strong>&lt;/Library&gt;</strong></span>
</pre></div><p>The triple quote used in the preceding command lets us express a preformatted string where the characters are escaped (for example, the <code class="literal">"</code> within a regular string would have been noted <code class="literal">\"</code>).</p><p>Processing such an XML structure can, for example, consist of computing the total price for the books. This operation can be achieved with a Scala <code class="literal">for comprehension</code> leading to the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val total = (for {</strong></span>
<span class="strong"><strong>         book &lt;- books \ "book"</strong></span>
<span class="strong"><strong>         price = ( book \ "@price").text.toDouble</strong></span>
<span class="strong"><strong>         quantity = ( book \ "@quantity").text.toInt</strong></span>
<span class="strong"><strong>       } yield price * quantity).sum</strong></span>
<span class="strong"><strong>total: Double = 705.0</strong></span>
</pre></div><p>Retrieving and transforming XML structures happens all the time when dealing with the integration of diverse external systems. Accessing the various XML tags through XPath expressions as we have done earlier is very handy and produces concise and readable code. Programmatically, creating XML out of information exported from Excel in the form of CSV data is also a common <a id="id380" class="indexterm"/>operation and can be achieved as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val books = </strong></span>
<span class="strong"><strong>       &lt;Library&gt;</strong></span>
<span class="strong"><strong>         { List("Programming in Scala,15,30.00","Scala for Java Developers,10,25.50") map { row =&gt; row split "," } map { b =&gt; &lt;book title={b(0)} quantity={b(1)} price={b(2)} /&gt; }}</strong></span>
<span class="strong"><strong>       &lt;/Library&gt;</strong></span>
<span class="strong"><strong>books: scala.xml.Elem = </strong></span>
<span class="strong"><strong>&lt;Library&gt;</strong></span>
<span class="strong"><strong>  &lt;book title="Programming in Scala" quantity="15" price="30.00"/&gt;&lt;book title="Scala for Java Developers" quantity="10" price="25.50"/&gt;</strong></span>
<span class="strong"><strong>&lt;/Library&gt;</strong></span>
</pre></div></div><div class="section" title="Manipulating JSON"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Manipulating JSON</h2></div></div></div><p>JSON is supported in the Scala <a id="id381" class="indexterm"/>library and you just need to import the appropriate library. An example of some REPL usage is illustrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import scala.util.parsing.json._</strong></span>
<span class="strong"><strong>import scala.util.parsing.json._</strong></span>
<span class="strong"><strong>scala&gt; val result = JSON.parseFull("""</strong></span>
<span class="strong"><strong>       {</strong></span>
<span class="strong"><strong>         "Library": {</strong></span>
<span class="strong"><strong>           "book": [</strong></span>
<span class="strong"><strong>             {</strong></span>
<span class="strong"><strong>               "title": "Scala for Java Developers",</strong></span>
<span class="strong"><strong>               "quantity": 10</strong></span>
<span class="strong"><strong>             },</strong></span>
<span class="strong"><strong>             {</strong></span>
<span class="strong"><strong>               "title": "Programming Scala",</strong></span>
<span class="strong"><strong>               "quantity": 20</strong></span>
<span class="strong"><strong>             }</strong></span>
<span class="strong"><strong>           ]</strong></span>
<span class="strong"><strong>         }</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>       """)</strong></span>
<span class="strong"><strong>result: Option[Any] = Some(Map(Library -&gt; Map(book -&gt; List(Map(title -&gt; Scala for Java Developers, quantity -&gt; 10.0), Map(title -&gt; Programming Scala, quantity -&gt; 20.0)))))</strong></span>
</pre></div><p>Any valid JSON message can be transformed into a structure made of <code class="literal">Maps</code> and <code class="literal">Lists</code>. However, it is often desirable to create meaningful classes, that is, expressing the business domain out of the <a id="id382" class="indexterm"/>JSON messages. The online service available at <a class="ulink" href="http://json2caseclass.cleverapps.io">http://json2caseclass.cleverapps.io</a> does exactly that; it is a convenient JSON to Scala case class converter. We can, for example, copy our preceding JSON message into the <span class="strong"><strong>Json paste</strong></span> text area and click on the <span class="strong"><strong>Let's go!</strong></span> button to try it out as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_07_05_New.jpg" alt="Manipulating JSON"/></div><p>The converter produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>case class Book(title:String, quantity:Double)</strong></span>
<span class="strong"><strong>case class Library(book:List[Book])</strong></span>
<span class="strong"><strong>case class R00tJsonObject(Library:Library)</strong></span>
</pre></div><p>Among the very interesting features of case classes that we have already introduced in <a class="link" href="ch01.html" title="Chapter 1. Programming Interactively within Your Project">Chapter 1</a>, <span class="emphasis"><em>Programming Interactively within Your Project</em></span>, is a decomposition mechanism for pattern matching. Once JSON messages have been deserialized into case classes, we can, for instance, manipulate them using this mechanism, as the sequence of the following command illustrates:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; case class Book(title:String, quantity:Double)</strong></span>
<span class="strong"><strong>defined class Book</strong></span>
<span class="strong"><strong>scala&gt; val book1 = Book("Scala for Java Developers",10)</strong></span>
<span class="strong"><strong>book1: Book = Book(Scala for Java Developers,10.0)</strong></span>
<span class="strong"><strong>scala&gt; val book2 = Book("Effective Java",12)</strong></span>
<span class="strong"><strong>book2: Book = Book(Effective Java,12.0)</strong></span>
<span class="strong"><strong>scala&gt; val books = List(book1,book2)</strong></span>
<span class="strong"><strong>books: List[Book] = List(Book(Scala for Java Developers,10.0), Book(Effective Java,12.0))</strong></span>
</pre></div><p>First, we defined two instances of books and put them into a list.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def bookAboutScala(book:Book) = book match {</strong></span>
<span class="strong"><strong>         case Book(a,_) if a contains "Scala" =&gt; Some(book)</strong></span>
<span class="strong"><strong>         case _ =&gt; None</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>bookAboutScala: (book: Book)Option[Book]</strong></span>
</pre></div><p>The method defined previously does pattern matching on the <code class="literal">Book</code> constructor, which also contains a guard (that is, the <code class="literal">if</code> condition). Since we do not use the second constructor parameter, we have put an <a id="id383" class="indexterm"/>underscore instead of creating an anonymous variable. Calling this method on both the book instances that we defined earlier will show the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; bookAboutScala(book1)</strong></span>
<span class="strong"><strong>res0: Option[Book] = Some(Book(Scala for Java Developers,10.0))</strong></span>
<span class="strong"><strong>scala&gt; bookAboutScala(book2)</strong></span>
<span class="strong"><strong>res1: Option[Book] = None</strong></span>
</pre></div><p>We can mix case class pattern matching together with other patterns. Let's, for instance, define the following regular expression (note the usage of the triple quotes as well as the use of <code class="literal">.r</code> to specify that it is a regular expression):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val regex = """(.*)(Scala|Java)(.*)""".r</strong></span>
<span class="strong"><strong>regex: scala.util.matching.Regex = (.*)(Scala|Java)(.*)</strong></span>
</pre></div><p>This regular expression will match any string that contains either Scala or Java.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def whatIs(that:Any) = that match {</strong></span>
<span class="strong"><strong>         case Book(t,_) if (t contains "Scala") =&gt;</strong></span>
<span class="strong"><strong>           s"${t} is a book about Scala"</strong></span>
<span class="strong"><strong>         case Book(_,_) =&gt; s"$that is a book "</strong></span>
<span class="strong"><strong>         case regex(_,word,_) =&gt; s"$that is something about ${word}"</strong></span>
<span class="strong"><strong>         case head::tail =&gt; s"$that is a list of books"</strong></span>
<span class="strong"><strong>         case _ =&gt; "You tell me !"</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>whatIs: (that: Any)String</strong></span>
</pre></div><p>We can now try out this method on a number of different inputs and observe the result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; whatIs(book1)</strong></span>
<span class="strong"><strong>res2: String = Scala for Java Developers is a book about Scala</strong></span>
<span class="strong"><strong>scala&gt; whatIs(book2)</strong></span>
<span class="strong"><strong>res3: String = "Book(Effective Java,12.0) is a book "</strong></span>
<span class="strong"><strong>scala&gt; whatIs(books)</strong></span>
<span class="strong"><strong>res4: String = List(Book(Scala for Java Developers,10.0), Book(Effective Java,12.0)) is a list of books</strong></span>
<span class="strong"><strong>scala&gt; whatIs("Scala pattern matching")</strong></span>
<span class="strong"><strong>res5: String = Scala pattern matching is something about Scala</strong></span>
<span class="strong"><strong>scala&gt; whatIs("Love")</strong></span>
<span class="strong"><strong>res6: String = You tell me !</strong></span>
</pre></div></div><div class="section" title="Using Play JSON"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec52"/>Using Play JSON</h2></div></div></div><p>There are many alternative libraries one can use to manipulate JSON in addition to the default implementation of the <a id="id384" class="indexterm"/>Scala library. In addition to the ones built on top of the known Java libraries such as Jerkson (built on top of Jackson) and other known implementations such as sjson, json4s, or Argonaut (functional programming oriented), many web frameworks have created their own including lift-json, spray-json, or play-json. Since in this book we are mostly covering the Play Framework to build web applications, we are going to focus on the play-json implementation. Note that play-json can also be run as standalone since it consists of a single jar without other dependencies to Play. Running an REPL console from within a Play project already includes the play-json dependency so that we can directly experiment with it in a console terminal window.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>If you want to run the following samples into an REPL different from the Play console (for instance, a regular SBT project or a Typesafe activator project) then you will have to add the following dependency to your <code class="literal">build.sbt</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>libraryDependencies += "com.typesafe.play" %% "play-json" % "2.2.1"</strong></span>
</pre></div></div></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import play.api.libs.json._</strong></span>
<span class="strong"><strong>import play.api.libs.json._ </strong></span>
<span class="strong"><strong>scala&gt; val books = Json.parse("""</strong></span>
<span class="strong"><strong>       {</strong></span>
<span class="strong"><strong>         "Library": {</strong></span>
<span class="strong"><strong>           "book": [</strong></span>
<span class="strong"><strong>             {</strong></span>
<span class="strong"><strong>               "title": "Scala for Java Developers",</strong></span>
<span class="strong"><strong>               "quantity": 10</strong></span>
<span class="strong"><strong>             },</strong></span>
<span class="strong"><strong>             {</strong></span>
<span class="strong"><strong>               "title": "Programming Scala",</strong></span>
<span class="strong"><strong>               "quantity": 20</strong></span>
<span class="strong"><strong>             }</strong></span>
<span class="strong"><strong>           ]</strong></span>
<span class="strong"><strong>         }</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>       """)</strong></span>
<span class="strong"><strong>books: play.api.libs.json.JsValue = {"Library":{"book":[{"title":"Scala for Java Developers","quantity":10},{"title":"Programming Scala","quantity":20}]}}</strong></span>
</pre></div><p>The <code class="literal">JsValue</code> type is <a id="id385" class="indexterm"/>the super type of the other JSON data types included in play-json and is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">JsNull</code> to represent a <a id="id386" class="indexterm"/>null value</li><li class="listitem" style="list-style-type: disc"><code class="literal">JsString</code>, <a id="id387" class="indexterm"/><code class="literal">JsBoolean</code>, <a id="id388" class="indexterm"/>and <code class="literal">JsNumber</code> to describe strings, booleans, and <a id="id389" class="indexterm"/>numbers respectively: numbers include short, int, long, float, double, and BigDecimal as seen in the <a id="id390" class="indexterm"/>following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sfjd = JsString("Scala for Java Developers")</strong></span>
<span class="strong"><strong>sfjd: play.api.libs.json.JsString = "Scala for Java Developers"</strong></span>
<span class="strong"><strong>scala&gt; val qty = JsNumber(10)</strong></span>
<span class="strong"><strong>qty: play.api.libs.json.JsNumber = 10</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">JsObject</code> represents a set of <a id="id391" class="indexterm"/>name/value pairs as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val book1 = JsObject(Seq("title"-&gt;sfjd,"quantity"-&gt;qty))</strong></span>
<span class="strong"><strong>book1: play.api.libs.json.JsObject = {"title":"Scala for Java Developers","quantity":10}</strong></span>
<span class="strong"><strong>scala&gt; val book2 = JsObject(Seq("title"-&gt;JsString("Programming in Scala"),"quantity"-&gt;JsNumber(15)))</strong></span>
<span class="strong"><strong>book2: play.api.libs.json.JsObject = {"title":"Programming in Scala","quantity":15}</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">JsArray</code> represents a <a id="id392" class="indexterm"/>sequence of any JSON value types (which can be heterogenous, that is, of different types):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val array = </strong></span>
<span class="strong"><strong>         JsArray(Seq(JsString("a"),JsNumber(2),JsBoolean(true)))</strong></span>
<span class="strong"><strong>array: play.api.libs.json.JsArray = ["a",2,true]</strong></span>
</pre></div></li></ul></div><p>Programmatically, creating a JSON <span class="strong"><strong>Abstract </strong></span><a id="id393" class="indexterm"/>
<span class="strong"><strong>Syntax Tree</strong></span> (<span class="strong"><strong>AST</strong></span>) equivalent to our list of books can therefore be expressed as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val books = JsObject(Seq(</strong></span>
<span class="strong"><strong>         "books" -&gt; JsArray(Seq(book1,book2))</strong></span>
<span class="strong"><strong>       ))</strong></span>
<span class="strong"><strong>books: play.api.libs.json.JsObject = {"books":[{"title":"Scala for Java Developers","quantity":10},{"title":"Programming in Scala","quantity":15}]}</strong></span>
</pre></div><p>Play has recently been enhanced to provide a slightly simpler syntax when creating the JSON structure we have just described. <a id="id394" class="indexterm"/>The alternative syntax to construct the same JSON object is given as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val booksAsJson = Json.obj(</strong></span>
<span class="strong"><strong>         "books" -&gt; Json.arr(</strong></span>
<span class="strong"><strong>           Json.obj(</strong></span>
<span class="strong"><strong>             "title" -&gt; "Scala for Java Developers",</strong></span>
<span class="strong"><strong>             "quantity" -&gt; 10  </strong></span>
<span class="strong"><strong>           ),</strong></span>
<span class="strong"><strong>           Json.obj(</strong></span>
<span class="strong"><strong>             "title" -&gt; "Programming in Scala",</strong></span>
<span class="strong"><strong>             "quantity" -&gt; 15  </strong></span>
<span class="strong"><strong>           )</strong></span>
<span class="strong"><strong>         )</strong></span>
<span class="strong"><strong>       )</strong></span>
<span class="strong"><strong>booksAsJson: play.api.libs.json.JsObject = {"books":[{"title":"Scala for Java Developers","quantity":10},{"title":"Programming in Scala","quantity":15}]}</strong></span>
</pre></div><p>Serializing the JsObject to its string representation can be achieved with the following statement:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val booksAsString = Json.stringify(booksAsJson)</strong></span>
<span class="strong"><strong>booksAsString: String = {"books":[{"title":"Scala for Java Developers","quantity":10},{"title":"Programming in Scala","quantity":15}]}</strong></span>
</pre></div><p>Finally, since a <code class="literal">JsObject</code> object represents a tree structure, you can navigate within the tree by using XPath expressions to retrieve various elements, such as the following example to access the titles of both our books:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val titles = booksAsJson \ "books" \\ "title"</strong></span>
<span class="strong"><strong>titles: Seq[play.api.libs.json.JsValue] = ArrayBuffer("Scala for Java Developers", "Programming in Scala")</strong></span>
</pre></div><p>As the return type is a sequence of <code class="literal">JsValue</code> objects, it can be useful to convert them into Scala types and the <code class="literal">.as[…]</code> method would be convenient to achieve that:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; titles.toList.map(x=&gt;x.as[String])</strong></span>
<span class="strong"><strong>res8: List[String] = List(Scala for Java Developers, Programming in Scala)</strong></span>
</pre></div></div></div>
<div class="section" title="Handling Play requests with XML and JSON"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Handling Play requests with XML and JSON</h1></div></div></div><p>Now that we are familiar <a id="id395" class="indexterm"/>with the JSON and XML formats, we can start <a id="id396" class="indexterm"/>using them to handle HTTP requests and <a id="id397" class="indexterm"/>responses in the context of a Play project.</p><p>To exhibit these behaviors, we are <a id="id398" class="indexterm"/>going to call an online web service, the iTunes media library, which is available and documented at <a class="ulink" href="http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html</a>.</p><p>It returns JSON messages on search invocations. We can, for instance, call the API with the following URL and parameters:</p><p>
<a class="ulink" href="https://itunes.apple.com/search?term=angry+birds&amp;country=se&amp;entity=software">https://itunes.apple.com/search?term=angry+birds&amp;country=se&amp;entity=software</a>
</p><p>The term parameter filters every item in the library that has to do with <span class="emphasis"><em>Angry Birds</em></span> and the entity parameter retains only software items. We also apply an additional filter to query only the Swedish App Store.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>If you don't have it already in your <code class="literal">build.sbt</code> file, you may need to add the dispatch dependency at this point, the same way we did while working with HTTP in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>libraryDependencies += "net.databinder.dispatch" %% "dispatch-core" % "0.11.0"</strong></span>
</pre></div></div></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import dispatch._</strong></span>
<span class="strong"><strong>import dispatch._</strong></span>
<span class="strong"><strong>scala&gt; import Defaults._</strong></span>
<span class="strong"><strong>import Defaults._</strong></span>
<span class="strong"><strong>scala&gt; val request = url("https://itunes.apple.com/search")</strong></span>
<span class="strong"><strong>request: dispatch.Req = Req(&lt;function1&gt;)</strong></span>
</pre></div><p>Parameters that will be part of our GET method call can be expressed as <code class="literal">(key,value)</code> tuples in a Scala <code class="literal">Map</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val params = Map("term" -&gt; "angry birds", "country" -&gt; "se", "entity" -&gt; "software")</strong></span>
<span class="strong"><strong>params: scala.collection.immutable.Map[String,String] = Map(term -&gt; angry birds, country -&gt; se, entity -&gt; software)</strong></span>
<span class="strong"><strong>scala&gt; val result = Http( request &lt;&lt;? params OK as.String).either</strong></span>
<span class="strong"><strong>result: dispatch.Future[Either[Throwable,String]] = scala.concurrent.impl.Promise$DefaultPromise@7a707f7c</strong></span>
</pre></div><p>The type of result in this <a id="id399" class="indexterm"/>case is <code class="literal">Future[Either[Throwable,String]]</code>, which means we can extract a successful <a id="id400" class="indexterm"/>invocation as well as a failed execution by pattern <a id="id401" class="indexterm"/>matching <a id="id402" class="indexterm"/>as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val response = result() match {</strong></span>
<span class="strong"><strong>         case Right(content)=&gt; "Answer: "+ content</strong></span>
<span class="strong"><strong>         case Left(StatusCode(404))=&gt; "404 Not Found"</strong></span>
<span class="strong"><strong>         case Left(x) =&gt; x.printStackTrace()</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>response: Any = </strong></span>
<span class="strong"><strong>"Answer: </strong></span>

<span class="strong"><strong>{</strong></span>
<span class="strong"><strong> "resultCount":50,</strong></span>
<span class="strong"><strong> "results": [</strong></span>
<span class="strong"><strong>{"kind":"software", "features":["gameCenter"], </strong></span>
<span class="strong"><strong>"supportedDevices":["iPhone5s", "iPad23G", "iPadThirdGen", "iPodTouchThirdGen", "iPadFourthGen4G", "iPhone4S", "iPad3G", "iPhone5", "iPadWifi", "iPhone5c", "iPad2Wifi", "iPadMini", "iPadThirdGen4G", "iPodTouchourthGen", "iPhone4", "iPadFourthGen", "iPhone-3GS", "iPodTouchFifthGen", "iPadMini4G"], "isGameCenterEnabled":true, "artistViewUrl":"https://itunes.apple.com/se/artist/rovio-entertainment-ltd/id298910979?uo=4", "artworkUrl60":"http://a336.phobos.apple.com/us/r30/Purple2/v4/6c/20/98/6c2098f0-f572-46bb-f7bd-e4528fe31db8/Icon.png", </strong></span>
<span class="strong"><strong>"screenshotUrls":["http://a2.mzstatic.com/eu/r30/Purple/v4/c0/eb/59/c0eb597b-a3d6-c9af-32a7-f107994a595c/screen1136x1136.jpeg", "http://a4.mzst... </strong></span>
</pre></div><div class="section" title="Mocking Play responses with JSON"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec53"/>Mocking Play responses with JSON</h2></div></div></div><p>Whenever you need to integrate <a id="id403" class="indexterm"/>your services with external systems that you do not own or that are not available until you deploy them in production, it <a id="id404" class="indexterm"/>can be cumbersome to test the interaction of messages that are sent and received. An efficient way to avoid calling a real service is to replace it with mock messages, that is, hardcoded responses that will cut short the real interaction, especially if you need to run your tests as part of an automated process (for instance, daily as a Jenkins job). Returning a plain JSON message from within a Play controller is very straightforward, as the following example illustrates:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api.mvc._
import play.api.libs.json._
import views._

object MockMarketplaceController extends Controller {

  case class AppStoreSearch(artistName: String, artistLinkUrl: String)
  implicit val appStoreSearchFormat = Json.format[AppStoreSearch]

  def mockSearch() = Action {
    val result = List(AppStoreSearch("Van Gogh", " http://www.vangoghmuseum.nl/"), AppStoreSearch("Monet", " http://www.claudemonetgallery.org "))
    Ok(Json.toJson(result))
  }
}</pre></div><p>The <code class="literal">Json.format[. . .]</code> declaration that involves Reads, Writes, and Format will be explained later on in this section when we invoke web services, so we can skip discussing that part for the moment.</p><p>To try out this controller, you can either create a new Play project, or, as we did before, just add this controller to the application we generated out of an existing database in the last section of <a class="link" href="ch06.html" title="Chapter 6. Database Access and the Future of ORM">Chapter 6</a>, <span class="emphasis"><em>Database Access and the Future of ORM</em></span>. You also need to add a route to the <code class="literal">route</code> file under <code class="literal">conf/</code> as follows:</p><div class="informalexample"><pre class="programlisting">GET /mocksearch  controllers.MockMarketplaceController.mockSearch</pre></div><p>Once the app is running, accessing <a id="id405" class="indexterm"/>the <code class="literal">http://localhost:9000/mocksearch</code> URL in a browser will return the following mock JSON message:</p><div class="mediaobject"><img src="graphics/3637OS_07_02.jpg" alt="Mocking Play responses with JSON"/></div><p>Another convenient way to obtain a JSON test message that you can use to mock a response is to use the online service <a id="id406" class="indexterm"/>found at <a class="ulink" href="http://json-generator.appspot.com">http://json-generator.appspot.com</a>. It consists of a JSON generator that we can use as it is by simply clicking on the <span class="strong"><strong>Generate</strong></span> button. By default, it will generate a JSON sample including random data in the panel to the right of the browser window, but adhering to the structure defined in the panel to the left, as illustrated in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_07_03.jpg" alt="Mocking Play responses with JSON"/></div><p>You can click on the <span class="strong"><strong>Copy to </strong></span><a id="id407" class="indexterm"/>
<span class="strong"><strong>clipboard</strong></span> button and paste the resulting mock message directly into the response of the <a id="id408" class="indexterm"/>Play controller.</p></div><div class="section" title="Calling web services from Play"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Calling web services from Play</h2></div></div></div><p>In the previous section, to <a id="id409" class="indexterm"/>quickly experiment with the App Store search API, we have used the <code class="literal">dispatch</code> library; we have already introduced this library in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>. Play provides its own HTTP library to be able to <a id="id410" class="indexterm"/>interact with other online web services. It is also built on top of the Java <code class="literal">AsyncHttpClient</code> library (<a class="ulink" href="https://github.com/AsyncHttpClient/async-http-client">https://github.com/AsyncHttpClient/async-http-client</a>), as <code class="literal">dispatch</code> is.</p><p>Before we dive into invoking REST web services from Play controllers, let's experiment a little bit with Play web services from the REPL. In a terminal window, either create a new Play project or go to the root directory of the one we have used in the previous sections. Once you get a Scala prompt after having typed the <code class="literal">&gt; play console</code> command, enter the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import play.api.libs.ws._</strong></span>
<span class="strong"><strong>import play.api.libs.ws._</strong></span>
<span class="strong"><strong>scala&gt; import scala.concurrent.Future</strong></span>
<span class="strong"><strong>import scala.concurrent.Future</strong></span>
</pre></div><p>Since we are going to invoke a web service asynchronously, we need an execution context to handle the <code class="literal">Future</code> placeholder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; implicit val context = scala.concurrent.ExecutionContext.Implicits.global</strong></span>
<span class="strong"><strong>context: scala.concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl@44d8bd53</strong></span>
</pre></div><p>We can now define a service URL that <a id="id411" class="indexterm"/>needs to be called. Here, we will take a simple web service that returns the geographic location of a site given as a parameter, according to the following signature:</p><div class="informalexample"><pre class="programlisting">http://freegeoip.net/{format}/{site}</pre></div><p>The format parameter can <a id="id412" class="indexterm"/>either be <code class="literal">json</code> or <code class="literal">xml</code>, and the <code class="literal">site</code> will be a reference to a website:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val url = "http://freegeoip.net/json/www.google.com"</strong></span>
<span class="strong"><strong>url: String = http://freegeoip.net/json/www.google.com</strong></span>
<span class="strong"><strong>scala&gt; val futureResult: Future[String] = WS.url(url).get().map {</strong></span>
<span class="strong"><strong>         response =&gt;</strong></span>
<span class="strong"><strong>           (response.json \ "region_name").as[String]</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>futureResult: scala.concurrent.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@e4bc0ba</strong></span>
<span class="strong"><strong>scala&gt; futureResult.onComplete(println)</strong></span>
<span class="strong"><strong>Success(California)</strong></span>
</pre></div><p>As we saw earlier in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>, when working with the <code class="literal">dispatch</code> library, a <code class="literal">Future</code> is a placeholder that contains the result of an asynchronous computation and can be in two states, either <code class="literal">completed</code> or <code class="literal">not</code>. Here, we want to print the result once it is available.</p><p>We have only extracted the <code class="literal">region_name</code> item from the response; the whole JSON document is as follows:</p><div class="informalexample"><pre class="programlisting">{
    "ip":"173.194.64.106",
    "country_code":"US",
    "country_name":"United States",
    "region_code":"CA",
    "region_name":"California",
    "city":"Mountain View",
    "zipcode":"94043",
    "latitude":37.4192,
    "longitude":-122.0574,
    "metro_code":"807",
    "areacode":"650"
}</pre></div><p>We can encapsulate part of the response <a id="id413" class="indexterm"/>if we want to by creating a <code class="literal">case</code> class as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; case class Location(latitude:Double, longitude:Double, region:String, country:String)</strong></span>
<span class="strong"><strong>defined class Location</strong></span>
</pre></div><p>The <code class="literal">play-json</code> <a id="id414" class="indexterm"/>library includes <a id="id415" class="indexterm"/>support to read/write JSON structures via <code class="literal">Reads</code>/<code class="literal">Writes</code>/<code class="literal">Format</code> combinators based on <code class="literal">JsPath</code> so that validation can be made on the fly. If you are interested in all the details behind the use of these combinators, you may want to read through the blog at <a class="ulink" href="http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/">http://mandubian.com/2012/09/08/unveiling-play-2-dot-1-json-api-part1-jspath-reads-combinators/</a>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import play.api.libs.json._</strong></span>
<span class="strong"><strong>import play.api.libs.json._</strong></span>
<span class="strong"><strong>scala&gt; import play.api.libs.functional.syntax._</strong></span>
<span class="strong"><strong>import play.api.libs.functional.syntax._</strong></span>
<span class="strong"><strong>scala&gt; implicit val locationReads: Reads[Location] = (</strong></span>
<span class="strong"><strong>         (__ \ "latitude").read[Double] and</strong></span>
<span class="strong"><strong>         (__ \ "longitude").read[Double] and</strong></span>
<span class="strong"><strong>         (__ \ "region_name").read[String] and</strong></span>
<span class="strong"><strong>         (__ \ "country").read[String]</strong></span>
<span class="strong"><strong>       )(Location.apply _)</strong></span>
<span class="strong"><strong>locationReads: play.api.libs.json.Reads[Location] = play.api.libs.json.Reads$$anon$8@4a13875b</strong></span>
<span class="strong"><strong>locationReads: play.api.libs.json.Reads[Location] = play.api.libs.json.Reads$$anon$8@5430c881</strong></span>
</pre></div><p>Now, invoking the validate method on the JSON response will verify that the data we receive is well-formed and with acceptable values.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val futureResult: Future[JsResult[Location]] = WS.url(url).get().map {</strong></span>
<span class="strong"><strong>         response =&gt; response.json.validate[Location]</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>futureResult: scala.concurrent.Future[play.api.libs.json.JsResult[Location]] = scala.concurrent.impl.Promise$DefaultPromise@3168c842</strong></span>

<span class="strong"><strong>scala&gt; futureResult.onComplete(println)</strong></span>
<span class="strong"><strong>Success(JsError(List((/country,List(ValidationError(error.path.missing,WrappedArray()))))))</strong></span>
</pre></div><p>The previous <code class="literal">JsError</code> <a id="id416" class="indexterm"/>object <a id="id417" class="indexterm"/>illustrates a validation that failed; it detected that the <code class="literal">country</code> element is not found in the response. In fact, the correct spelling is <code class="literal">country_name</code> instead of <code class="literal">country</code>, <a id="id418" class="indexterm"/>which we can correct in our <code class="literal">locationReads</code> declaration. This time validation goes through and what we get as a response is a <code class="literal">JsSuccess</code> object containing the latitude and longitude information as we expect it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; implicit val locationReads: Reads[Location] = (</strong></span>
<span class="strong"><strong>         (__ \ "latitude").read[Double] and</strong></span>
<span class="strong"><strong>         (__ \ "longitude").read[Double] and</strong></span>
<span class="strong"><strong>         (__ \ "region_name").read[String] and</strong></span>
<span class="strong"><strong>         (__ \ "country_name").read[String]</strong></span>
<span class="strong"><strong>       )(Location.apply _)</strong></span>
<span class="strong"><strong>locationReads: play.api.libs.json.Reads[Location] = play.api.libs.json.Reads$$anon$8@70aab9ed</strong></span>
<span class="strong"><strong>scala&gt; val futureResult: Future[JsResult[Location]] = WS.url(url).get().map {</strong></span>
<span class="strong"><strong>         response =&gt; response.json.validate[Location]</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>futureResult: scala.concurrent.Future[play.api.libs.json.JsResult[Location]] = scala.concurrent.impl.Promise$DefaultPromise@361c5860</strong></span>
<span class="strong"><strong>scala&gt; futureResult.onComplete(println)</strong></span>
<span class="strong"><strong>scala&gt; Success(JsSuccess(Location(37.4192,-122.0574,California,United States),))</strong></span>
</pre></div><p>Now, let's create a sample controller that invokes a web service to retrieve some data from the App Store:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api._
import play.api.mvc._
import play.api.libs.ws.WS
import scala.concurrent.ExecutionContext.Implicits.global
import play.api.libs.json._
import play.api.libs.functional.syntax._
import scala.concurrent.Future
import views._
import models._

object MarketplaceController extends Controller {

  val pageSize = 10
  val appStoreUrl = "https://itunes.apple.com/search"

  def list(page: Int, orderBy: Int, filter: String = "*") = Action.async { implicit request =&gt;
    val futureWSResponse =
      WS.url(appStoreUrl)
        .withQueryString("term" -&gt; filter, "country" -&gt; "se", "entity" -&gt; "software")
        .get()
    
      futureWSResponse map { resp =&gt;
        val json = resp.json
        val jsResult = json.validate[AppResult]
        jsResult.map {
          case AppResult(count, res) =&gt;
            Ok(html.marketplace.list(
              Page(res,
                page,
                offset = pageSize * page,
                count),
              orderBy,
              filter))
        }.recoverTotal {
          e =&gt; BadRequest("Detected error:" + JsError.toFlatJson(e))
        }
      } 
  }
}</pre></div><p>Here, the call to the web service is illustrated by invoking methods on the <code class="literal">WS</code> class, first the <code class="literal">url</code> method giving the URL, then the <code class="literal">withQueryString</code> method with input parameters given as a sequence of <code class="literal">key-&gt;value</code> pairs. Notice that the returned type is a <code class="literal">Future</code>, meaning our web service is asynchronous. <code class="literal">recoverTotal</code> takes a function that will return a default value after managing <a id="id419" class="indexterm"/>the error. The line <code class="literal">json.validate[AppResult]</code> makes the JSON response validated against an <code class="literal">AppResult</code> object that is <a id="id420" class="indexterm"/>specified here (as part of a <code class="literal">Marketplace.scala</code> file in <code class="literal">app/models/</code> folder):</p><div class="informalexample"><pre class="programlisting">package models

import play.api.libs.json._
import play.api.libs.functional.syntax._

case class AppInfo(id: Long, name: String, author: String, authorUrl:String,
    category: String, picture: String, formattedPrice: String, price: Double)
object AppInfo {
  implicit val appInfoFormat = (
    (__ \ "trackId").format[Long] and
    (__ \ "trackName").format[String] and
    (__ \ "artistName").format[String] and
    (__ \ "artistViewUrl").format[String] and
    (__ \ "primaryGenreName").format[String] and
    (__ \ "artworkUrl60").format[String] and
    (__ \ "formattedPrice").format[String] and
    (__ \ "price").format[Double])(AppInfo.apply, unlift(AppInfo.unapply))
}

case class AppResult(resultCount: Int, results: Array[AppInfo])
object AppResult {
  implicit val appResultFormat = (
    (__ \ "resultCount").format[Int] and
    (__ \\ "results").format[Array[AppInfo]])(AppResult.apply, unlift(AppResult.unapply))
}</pre></div><p>The <code class="literal">AppResult</code> and <code class="literal">AppInfo</code> case classes are created to encapsulate the elements that we care about for our service. As you may have seen when first experimenting with the API, most of the search queries to the App Store return a large amount of elements, most of which we may not need. This is why, using some Scala syntactic sugar with combinators, we can validate the JSON response on the fly and directly extract the elements of interest. Before trying out this web service call, we just need to add the needed route to the <code class="literal">routes</code> file under <code class="literal">conf/</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">GET /marketplace  controllers.MarketplaceController.list(p:Int ?= 0, s:Int ?= 2, f ?= "*")</pre></div><p>Finally, before launching the application <a id="id421" class="indexterm"/>in a web browser, we also need the sample view that is referred to in the <code class="literal">MarketplaceController.scala</code> file by <code class="literal">html.marketplace.list</code> and created in a <code class="literal">list.scala.html</code> file under <code class="literal">views/marketplace/</code> in several <a id="id422" class="indexterm"/>parts as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@(currentPage: Page[AppInfo], currentOrderBy: Int, currentFilter:
String)(implicit flash: play.api.mvc.Flash)
...
@main("Welcome to Play 2.0") {

&lt;h1&gt;@Messages("marketplace.list.title", currentPage.total)&lt;/h1&gt;

@flash.get("success").map { message =&gt;
&lt;div class="alert-message warning"&gt;
  &lt;strong&gt;Done!&lt;/strong&gt; @message
&lt;/div&gt;
}
&lt;div id="actions"&gt;

  @helper.form(action=routes.MarketplaceController.list()) { &lt;input
    type="search" id="searchbox" name="f" value="@currentFilter"
    placeholder="Filter by name..."&gt; &lt;input type="submit"
    id="searchsubmit" value="Filter by name" class="btn primary"&gt;
  }
&lt;/div&gt;
...</pre></div><p>The first part of the view only consists of helper methods to navigate and is generated the same way as we did for the CRUD sample generation in <a class="link" href="ch06.html" title="Chapter 6. Database Access and the Future of ORM">Chapter 6</a>, <span class="emphasis"><em>Database Access and the Future of ORM</em></span>. The second part of the view includes the JSON elements we have retrieved from the web service:</p><div class="informalexample"><pre class="programlisting">...
@Option(currentPage.items).filterNot(_.isEmpty).map { entities =&gt;
&lt;table class="computers zebra-striped"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      @header(2, "Picture") 
      @header(4, "Name") 
      @header(5, "Author")
      @header(6, "IPO")     
      @header(7, "Category") 
      @header(8, "Price")
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    @entities.map{ entity =&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;img
         src="@entity.picture"
         width="60" height="60" alt="image description" /&gt;
      &lt;/td&gt;
      &lt;td&gt;@entity.name&lt;/td&gt;
      &lt;td&gt;&lt;a href="@entity.authorUrl" class="new-btn btn-back"&gt;@entity.author&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;@entity.category&lt;/td&gt;
      &lt;td&gt;@entity.formattedPrice&lt;/td&gt;
    &lt;/tr&gt;
    }
  &lt;/tbody&gt;
&lt;/table&gt;
...</pre></div><p>The third and final <a id="id423" class="indexterm"/>part of the view <a id="id424" class="indexterm"/>is handling pagination:</p><div class="informalexample"><pre class="programlisting">...
&lt;div id="pagination" class="pagination"&gt;
  &lt;ul&gt;
    @currentPage.prev.map { page =&gt;
    &lt;li class="prev"&gt;&lt;a href="@link(page)"&gt;&amp;larr; Previous&lt;/a&gt;&lt;/li&gt;
    }.getOrElse {
    &lt;li class="prev disabled"&gt;&lt;a&gt;&amp;larr; Previous&lt;/a&gt;&lt;/li&gt; }
    &lt;li class="current"&gt;&lt;a&gt;Displaying @(currentPage.offset + 1)
        to @(currentPage.offset + entities.size) of @currentPage.total&lt;/a&gt;&lt;/li&gt;
    @currentPage.next.map { page =&gt;
    &lt;li class="next"&gt;&lt;a href="@link(page)"&gt;Next &amp;rarr;&lt;/a&gt;&lt;/li&gt;
    }.getOrElse {
    &lt;li class="next disabled"&gt;&lt;a&gt;Next &amp;rarr;&lt;/a&gt;&lt;/li&gt; }
  &lt;/ul&gt;
&lt;/div&gt;
}.getOrElse {
&lt;div class="well"&gt;
  &lt;em&gt;Nothing to display&lt;/em&gt;
&lt;/div&gt;
} }</pre></div><p>Once we re-launch the <a id="id425" class="indexterm"/>Play app with <code class="literal">&gt; play run</code> and access (through a web browser) our local <code class="literal">http://localhost:9000/marketplace?f=candy+crush</code> URL that includes a default search from the App Store (<a id="id426" class="indexterm"/>the <code class="literal">f</code> parameter stands for <code class="literal">filter</code>), we will obtain a page similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_07_04.jpg" alt="Calling web services from Play"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we saw some examples on how to manipulate the XML and JSON formats in Scala and how to connect to other systems via web services. In the case of XML, we also covered how to generate SOAP bindings out of a WSDL description as well as Scala classes to encapsulate the XML domain included in an XML schema. Web services in the Play Framework run asynchronously, which means that the caller is not waiting for the answer to come back before he continues to do other useful processing (such as serving other requests). In the next chapter, we are going to study this notion of asynchronous invocations more precisely. It is based on the concepts of <code class="literal">Future</code> and <code class="literal">Promise</code> that are also emerging in the Java world to deal with the execution of concurrent code. In particular, we will go through the Akka framework, an open source toolkit and runtime simplifying the construction of concurrent applications. Designed and written in Scala, Akka contains both Scala and Java APIs and is the basis of the Play Framework infrastructure that makes the Play Framework an ideal candidate for running scalable web applications on multicore architectures.</p></div></body></html>