<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Injection with Google Guice</h1>
                
            
            <article>
                
<p class="calibre2">Since our journey began, we have learned the concepts of the DI pattern to understand IoC, got an idea about the modular framework of Java 9 and its DI mechanism, and in the last chapter, we acquired knowledge of the most widely used Spring Framework to understand DI using various examples.</p>
<p class="calibre2">In this chapter, we will see the rudiments of the <strong class="calibre4">Google Guice</strong> framework and its <span class="calibre11"><span class="calibre11">DI </span></span>mechanism, and we will also learn various injection types and binding techniques while defining DI in Guice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A brief introduction to the Google Guice framework</h1>
                
            
            <article>
                
<p class="calibre2">We learned the benefits of DI in software engineering, but choosing a framework wisely is also important when implementing DI because each framework has its own advantages and disadvantages. There are various Java-based dependency injection frameworks available in the open source community, such as Dagger, Google Guice, Spring DI, JAVA EE 8 DI, and PicoContainer.</p>
<p class="calibre2">Here, we will learn in detail about Google Guice (pronounced <em class="calibre13">juice</em>), a lightweight DI framework that helps developers to modularize applications. Guice encapsulates annotation and generics features introduced by Java 5 to make code type-safe. It enables objects to wire together and tests with fewer efforts. Annotations help you to write error-prone and reusable code.</p>
<p class="calibre2"><span class="calibre11">In Guice, the </span><kbd class="calibre12">new</kbd><span class="calibre11"> keyword is replaced with </span><kbd class="calibre12">@inject</kbd><span class="calibre11"> for injecting dependency. It allows constructors, fields, and methods</span> <span class="calibre11">(any method with mult</span><span class="calibre11">iple numbers of arguments) level injections</span><span class="calibre11">. Using Guice, we can define custom scopes and circular </span><span class="calibre11">dependency, </span><span class="calibre11">and it has features to integrate with Spring and AOP interception.</span></p>
<p class="calibre2"><span class="calibre11">Moreover, </span>Guice also implements <strong class="calibre4">Java Specification Request</strong> (<strong class="calibre4">JSR</strong>) <strong class="calibre4">330</strong>, and uses the standard annotation provided by JSR-330. The f<span class="calibre11">irst version of Guice was introduced by Google in 2007 and the latest version is Guice 4.1.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Guice setup</h1>
                
            
            <article>
                
<p class="calibre2">To make our coding simple, throughout this chapter, we are going to use a Maven project to understand Guice DI.  Let’s create a simple Maven project using the following parameters: <kbd class="calibre12">groupid:</kbd>,<kbd class="calibre12"> com.packt.guice.id</kbd>, <kbd class="calibre12">artifactId : chapter4</kbd>, and <kbd class="calibre12">version : 0.0.1-SNAPSHOT</kbd>. By adding <kbd class="calibre12">Guice 4.1.0</kbd> dependency on the <kbd class="calibre12">pom.xml</kbd> file, our final <kbd class="calibre12">pom.xml</kbd> will look like this:</p>
<pre class="calibre17">&lt;project  <br class="title-page-name"/>  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;<br class="title-page-name"/>  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br class="title-page-name"/>  &lt;groupId&gt;com.packt.guice.di&lt;/groupId&gt;<br class="title-page-name"/>  &lt;artifactId&gt;chapter4&lt;/artifactId&gt;<br class="title-page-name"/>  <br class="title-page-name"/>  &lt;packaging&gt;jar&lt;/packaging&gt;<br class="title-page-name"/>  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br class="title-page-name"/>  &lt;name&gt;chapter4&lt;/name&gt;<br class="title-page-name"/>  <br class="title-page-name"/>  &lt;dependencies&gt;<br class="title-page-name"/>    &lt;dependency&gt;<br class="title-page-name"/>      &lt;groupId&gt;junit&lt;/groupId&gt;<br class="title-page-name"/>      &lt;artifactId&gt;junit&lt;/artifactId&gt;<br class="title-page-name"/>      &lt;version&gt;4.12&lt;/version&gt;<br class="title-page-name"/>      &lt;scope&gt;test&lt;/scope&gt;<br class="title-page-name"/>    &lt;/dependency&gt;<br class="title-page-name"/>    &lt;dependency&gt;<br class="title-page-name"/>      &lt;groupId&gt;com.google.inject&lt;/groupId&gt;<br class="title-page-name"/>      &lt;artifactId&gt;guice&lt;/artifactId&gt;<br class="title-page-name"/>      &lt;version&gt;4.1.0&lt;/version&gt;<br class="title-page-name"/>    &lt;/dependency&gt;<br class="title-page-name"/>  &lt;/dependencies&gt;<br class="title-page-name"/>  &lt;build&gt;<br class="title-page-name"/>    &lt;finalName&gt;chapter2&lt;/finalName&gt;<br class="title-page-name"/>  &lt;/build&gt;<br class="title-page-name"/>&lt;/project&gt;</pre>
<div class="packt_infobox">For this chapter, we have used JDK 9, but not as a module project because the Guice library is not available as a Java 9 modular jar.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection and JSR-330</h1>
                
            
            <article>
                
<p class="calibre2">Before diving into Guice injection, let's look at the DI pattern again, along with JSR-330, in brief. </p>
<p class="calibre2">A dependency injection mechanism enables an object to pass dependencies to another object. In Java, using DI, we can move dependency resolution from compile time to runtime. DI removes hard dependency between two Java classes; this allows us to reuse class as much as and also classes are  independently testable.</p>
<p class="calibre2"><strong class="calibre4">Java Specification Request-330</strong>: There is a different way to define dependency in Java classes, but <kbd class="calibre12">@Inject</kbd> and <kbd class="calibre12">@Named</kbd> are the most common annotations used to describe dependencies in Java classes from JSR-330. <span class="calibre11">According to JSR-330, objects can be injected into the class constructor, the parameter of the method, and a field level. As per best practices, static field and method-level injection should be avoided for the following reasons:</span></p>
<ul class="calibre9">
<li class="calibre10">Static field only injected when the first-time class object was created via DI, which makes static field inaccessible for the constructor</li>
<li class="calibre10">At runtime, the compiler complains if a static field is marked as final</li>
<li class="calibre10">When the first instance of the class is created, only static methods are called</li>
</ul>
<p class="calibre2">As per JSR-330, the injection can be performed in this order: first, constructor injection; then field injection; and the last is method level injection. But, you can't expect the methods or fields to be called in the sequence of their assertion in the class.</p>
<div class="packt_infobox">A constructor can't use injected member variables, because field and method parameter injection takes place only after calling a constructor.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example of simple DI</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">NotifictionService</kbd> represents a common service interface for sending data to a different system:</p>
<pre class="calibre17">public interface NotificationService {<br class="title-page-name"/>    boolean sendNotification(String message, String recipient);<br class="title-page-name"/>}</pre>
<p class="calibre2">The previous interface defines a method signature for <kbd class="calibre12">sendNotification()</kbd> by passing the message and recipient details and returning the type as Boolean. <kbd class="calibre12">SMSService.java</kbd> is a <span class="calibre11">concrete </span>implementation of this interface for sending SMS notifications:</p>
<pre class="calibre17">public class SMSService implements NotificationService {<br class="title-page-name"/><br class="title-page-name"/>  public boolean sendNotification(String message, String recipient) {<br class="title-page-name"/>    // Code for sending SMS<br class="title-page-name"/>    System.out.println("SMS message has been sent to " + recipient);<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The previous class implemented code for sending SMS by accepting the message and recipient details. Now, we create a client application, <kbd class="calibre12">NotificationClient.java</kbd>, which will use <kbd class="calibre12">NotificationService</kbd> to initialize the actual SMSService. The same object can be used to send notifications to different systems, including email or custom notifications:</p>
<pre class="calibre17">public class NotificationClient {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    NotificationService notificationService = new SMSService();<br class="title-page-name"/>    notificationService.sendNotification("Hello", "1234567890");<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">In the previous example, even though implementation and interface are loosely coupled, we need to create a manual instance of the real implementation of the class in the client application. In this <span class="calibre11">scenario, at compilation time, the </span>client application knows which execution classes related to interfaces will be bound<span class="calibre11">.</span></p>
<p class="calibre2"><span class="calibre11">That is the thing that Google Guice does; it takes instances as services from the client application code and the dependency between the clients, and their service is consequently injected through a simple configuration mechanism.</span></p>
<p class="calibre2">Let's see an example of dependency injection in Guice by using different API in the next topic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Basic injection in Guice</h1>
                
            
            <article>
                
<p class="calibre2">We have seen a basic DI implementation, now it is time to understand how injection works in Guice. Let's rewrite the example of a notification system using Guice, and along with that, we will see several indispensable interfaces and classes in Guice.  We have a base interface called <kbd class="calibre12">NotificationService</kbd>, which is expecting a message and recipient details as arguments:</p>
<pre class="calibre17">public interface NotificationService {<br class="title-page-name"/>  boolean sendNotification(String message, String recipient);<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre12">SMSService</kbd> concrete class is an implementation of the <kbd class="calibre12">NotificationService</kbd> interface. Here, we will apply the <kbd class="calibre12">@Singleton</kbd> annotation to the implementation class. When you consider that service objects will be made through injector classes, this annotation is furnished to allow them to understand that the service class ought to be a singleton object. Because of JSR-330 support in Guice, annotation, either from <kbd class="calibre12">javax.inject</kbd> or the <kbd class="calibre12">com.google.inject</kbd> package, can be used:</p>
<pre class="calibre17">import javax.inject.Singleton;<br class="title-page-name"/>import com.packt.guice.di.service.NotificationService;<br class="title-page-name"/><br class="title-page-name"/>@Singleton<br class="title-page-name"/>public class SMSService implements NotificationService {<br class="title-page-name"/><br class="title-page-name"/>  public boolean sendNotification(String message, String recipient) {<br class="title-page-name"/>    // Write code for sending SMS<br class="title-page-name"/>    System.out.println("SMS has been sent to " + recipient);<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">In the same way, we can also implement another service, such as sending notifications to a social media platform, by implementing the <kbd class="calibre12">NotificationService</kbd> interface. </p>
<p class="calibre2">It's time to define the consumer class, where we can initialize the service class for the application. In Guice, the <kbd class="calibre12">@Inject</kbd> annotation will be used to define <kbd class="calibre12">setter-based</kbd> as well as <kbd class="calibre12">constructor-based</kbd> <span class="calibre11">dependency injection. An instance of this class is utilized to send notifications by means of the accessible correspondence services. </span><span class="calibre11">Our</span> <kbd class="calibre12">AppConsumer</kbd><span class="calibre11"> class defines <kbd class="calibre12">setter-based</kbd> injection as follows:</span></p>
<pre class="calibre17">import javax.inject.Inject;<br class="title-page-name"/><br class="title-page-name"/>import com.packt.guice.di.service.NotificationService;<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>public class AppConsumer {<br class="title-page-name"/><br class="title-page-name"/>  private NotificationService notificationService;<br class="title-page-name"/><br class="title-page-name"/>  //Setter based DI<br class="title-page-name"/>  @Inject<br class="title-page-name"/>  public void setService(NotificationService service) {<br class="title-page-name"/>    this.notificationService = service;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public boolean sendNotification(String message, String recipient){<br class="title-page-name"/>    //Business logic<br class="title-page-name"/>    return notificationService.sendNotification(message, recipient);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Guice needs to recognize which service implementation to apply, so we should configure it with the aid of extending the <kbd class="calibre12">AbstractModule</kbd> class, and offer an implementation for the <kbd class="calibre12">configure()</kbd> method. Here is an example of an injector configuration:</p>
<pre class="calibre17">import com.google.inject.AbstractModule;<br class="title-page-name"/>import com.packt.guice.di.impl.SMSService;<br class="title-page-name"/>import com.packt.guice.di.service.NotificationService;<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>public class ApplicationModule extends AbstractModule{<br class="title-page-name"/><br class="title-page-name"/>  @Override<br class="title-page-name"/>  protected void configure() {<br class="title-page-name"/>    //bind service to implementation class<br class="title-page-name"/>    bind(NotificationService.class).to(SMSService.class);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">In the previous class, <span class="calibre11">the module implementation determines that an </span><span class="calibre11">instance</span><span class="calibre11"> of <kbd class="calibre12">SMSService</kbd> is to be injected </span><span class="calibre11">any place</span><span class="calibre11"> a <kbd class="calibre12">NotificationService</kbd> variable is </span><span class="calibre11">determined</span><span class="calibre11">. In the s</span>ame way, we just need to define a binding for the new service implementation, if required. Binding in Guice is similar to wiring in Spring:</p>
<pre class="calibre17">import com.google.inject.Guice;<br class="title-page-name"/>import com.google.inject.Injector;<br class="title-page-name"/>import com.packt.guice.di.consumer.AppConsumer;<br class="title-page-name"/>import com.packt.guice.di.injector.ApplicationModule;<br class="title-page-name"/><br class="title-page-name"/>public class NotificationClient {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/><br class="title-page-name"/>    Injector injector = Guice.createInjector(new ApplicationModule());<br class="title-page-name"/><br class="title-page-name"/>    AppConsumer app = injector.getInstance(AppConsumer.class);<br class="title-page-name"/><br class="title-page-name"/>    app.sendNotification("Hello", "9999999999");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In the previous program, <span class="calibre11">the</span>  <kbd class="calibre12">Injector</kbd> object is created using <span class="calibre11">the</span> <kbd class="calibre12">Guice</kbd> class's <kbd class="calibre12">createInjector()</kbd> method, by passing <span class="calibre11">the</span> <kbd class="calibre12">ApplicationModule</kbd> class's implementation object. By using the injector's <kbd class="calibre12">getInstance()</kbd> method, we can <span class="calibre11">initialize the <kbd class="calibre12">AppConsumer</kbd> class. A</span><span class="calibre11">t the same time as</span><span class="calibre11"> </span><span class="calibre11">creating the </span>AppConsumer's objects, Guice injects the needy service class <span class="calibre11">implementation</span><span class="calibre11"> </span>(<kbd class="calibre12">SMSService</kbd>, in our case). The following is the yield of running the previous code:</p>
<pre class="calibre17"><strong class="calibre1">SMS has been sent to Recipient :: 9999999999 with Message :: Hello</strong></pre>
<p class="calibre2">So, this is how Guice dependency injection works compared to other DI. <span class="calibre11">Guice has embraced </span><span class="calibre11">a code-first </span><span class="calibre11">technique</span><span class="calibre11"> for dependency injection, and </span><span class="calibre11">management</span><span class="calibre11"> of </span><span class="calibre11">numerous </span><span class="calibre11">XML is not required.</span></p>
<p class="calibre2">Let's test our client application by writing a <strong class="calibre4">JUnit</strong> test case. We can simply mock the service implementation of <kbd class="calibre12">SMSService</kbd>, so there is no need to implement the actual service. The <kbd class="calibre12">MockSMSService</kbd> class looks like this:</p>
<pre class="calibre17">import com.packt.guice.di.service.NotificationService;<br class="title-page-name"/><br class="title-page-name"/>public class MockSMSService implements NotificationService {<br class="title-page-name"/><br class="title-page-name"/>  public boolean sendNotification(String message, String recipient) {<br class="title-page-name"/>    System.out.println("In Test Service :: " + message + "Recipient :: " + recipient);<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">The following is the JUnit 4 test case for the client application:</p>
<pre class="calibre17">import org.junit.After;<br class="title-page-name"/>import org.junit.Assert;<br class="title-page-name"/>import org.junit.Before;<br class="title-page-name"/>import org.junit.Test;<br class="title-page-name"/><br class="title-page-name"/>import com.google.inject.AbstractModule;<br class="title-page-name"/>import com.google.inject.Guice;<br class="title-page-name"/>import com.google.inject.Injector;<br class="title-page-name"/>import com.packt.guice.di.consumer.AppConsumer;<br class="title-page-name"/>import com.packt.guice.di.impl.MockSMSService;<br class="title-page-name"/>import com.packt.guice.di.service.NotificationService;<br class="title-page-name"/><br class="title-page-name"/>public class NotificationClientTest {<br class="title-page-name"/>    private Injector injector;<br class="title-page-name"/>    <br class="title-page-name"/>    @Before<br class="title-page-name"/>    public void setUp() throws Exception {<br class="title-page-name"/>      injector = Guice.createInjector(new AbstractModule() {<br class="title-page-name"/>        <br class="title-page-name"/>        @Override<br class="title-page-name"/>        protected void configure() {<br class="title-page-name"/>          bind(NotificationService.class).to(MockSMSService.class);<br class="title-page-name"/>        }<br class="title-page-name"/>      });<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>    @After<br class="title-page-name"/>    public void tearDown() throws Exception {<br class="title-page-name"/>      injector = null;<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>    @Test<br class="title-page-name"/>    public void test() {<br class="title-page-name"/>      AppConsumer appTest = injector.getInstance(AppConsumer.class);<br class="title-page-name"/>      Assert.assertEquals(true, appTest.sendNotification("Hello There", "9898989898"));;<br class="title-page-name"/>    }<br class="title-page-name"/>  <br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">Take note</span><span class="calibre11"> that we are </span><span class="calibre11">binding <span class="calibre11">the</span></span> <span class="calibre11"><kbd class="calibre12">MockSMSService</kbd> </span><span class="calibre11">class</span><span class="calibre11"> to <kbd class="calibre12">NotificationService</kbd> by having an </span><span class="calibre11">anonymous</span><span class="calibre11"> </span><span class="calibre11">class</span><span class="calibre11"> </span><span class="calibre11">implementation</span><span class="calibre11"> of <kbd class="calibre12">AbstractModule</kbd>. This is done in the <kbd class="calibre12">setUp()</kbd></span> <span class="calibre11">method</span><span class="calibre11">, which </span><span class="calibre11">runs for </span><span class="calibre11">some time before </span><span class="calibre11">the test </span><span class="calibre11">methods run</span><span class="calibre11">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Guice API and Phases</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">We have seen DI examples using various Guice APIs, including interfaces and classes. So, it is time to understand the principal API and architecture. Guice architecture is divided into two phases: Start-up and runtime.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Start up phase</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">In the start-up phase, APIs such as <kbd class="calibre12">Module</kbd>, <kbd class="calibre12">AbstractModule</kbd>, <kbd class="calibre12">Binder</kbd>,  <kbd class="calibre12">Injector</kbd>, <kbd class="calibre12">Guice</kbd>, and <kbd class="calibre12">Provider</kbd> play a significant role in Guice dependency injection. Let us learn about each API in detail, starting with <strong class="calibre4">module interface</strong>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module interface</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">This is a special interface that you use to tell Guice which implementations go with which interfaces. Modules are objects that preserve a set of <strong class="calibre4">bindings</strong>. It is viable to have multiple modules in a piece of software. Injectors interact with modules to get the feasible bindings.</span></p>
<p class="calibre2"><span class="calibre11">The module is represented by using an interface with a method referred to as <kbd class="calibre12">Module.configure()</kbd>, which ought to be overridden with the aid of the application to populate the bindings. If we rewrite our <kbd class="calibre12">ApplicationModule</kbd> by implementing the <kbd class="calibre12">Module</kbd> interface, then it would look like this:</span></p>
<pre class="calibre17">import com.google.inject.Module;<br class="title-page-name"/>import com.packt.guice.di.impl.SMSService;<br class="title-page-name"/>import com.packt.guice.di.service.NotificationService;<br class="title-page-name"/><br class="title-page-name"/>public class ApplicationModule implements Module{<br class="title-page-name"/><br class="title-page-name"/>  @Override<br class="title-page-name"/>  protected void configure(Binder binder) {<br class="title-page-name"/>    //bind NotificationService to SMSService implementation class<br class="title-page-name"/>    //Guice will create a single instance of SMSService for every Injection<br class="title-page-name"/>    binder.bind(NotificationService.class).to(SMSService.class);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The AbstractModule class</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">To improve things, there is an abstract class called <kbd class="calibre12">AbstractModule</kbd>, which straightforwardly extends the module interface, so applications can rely upon <kbd class="calibre12">AbstractModule</kbd> as opposed to module.</span></p>
<p class="calibre2"><span class="calibre11">It's strongly suggested that modules should be extended to the usage of <kbd class="calibre12">AbstractModule</kbd>. It gives a more readable configuration, and additionally steers us away from the excessive invoking of methods on the binder.</span></p>
<p class="calibre2"><span class="calibre11">In our example <kbd class="calibre12">ApplicationModule</kbd>, to configure Guice instead of implementing the module interface, we have used <kbd class="calibre12">AbstractModule</kbd></span><span class="calibre11">, where Guice passes our module to the binder interface.</span></p>
<div class="packt_tip"><span class="calibre18">In the event that an application has a predetermined number of configurations, they could be consolidated in a solitary module. </span><span class="calibre18">For such applications, a single module per package or a single module per application could be a suitable system.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Binder</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">This interface mainly includes information associated with <strong class="calibre4">bindings</strong>. A binding normally consists of a mapping between an interface and a concrete implementation. For example, if we consider an implementation of the module interface for creating custom module, then the reference to the interface <kbd class="calibre12">NotificationService</kbd> is bound to the <kbd class="calibre12">SMSService</kbd> implementation.</span></p>
<p class="calibre2">When coding, notice that the objects for both the interface and implementation classes are passed to the <kbd class="calibre12">bind()</kbd> and then <kbd class="calibre12">to()</kbd> methods:</p>
<pre class="calibre17">binder.bind(NotificationService.class).to(SMSService.class);</pre>
<p class="calibre2">The second way is to tie an interface directly to its instance by writing the following code:</p>
<pre class="calibre17">binder.bind(NotificationService.class).to(new SMSService());</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injector</h1>
                
            
            <article>
                
<p class="calibre2">An <kbd class="calibre12">Injector</kbd> interface creates and maintains object graphs, tracks dependencies of each type, and uses bindings to inject them. Injectors keep a set of <strong class="calibre4">default bindings</strong>, from which they take configuration details for making and maintaining relationships between objects. Consider the following code, which will return an implementation of the <kbd class="calibre12">AppConsumer</kbd> class:</p>
<pre class="calibre17">AppConsumer app = injector.getInstance(AppConsumer.class);</pre>
<p class="calibre2">We can also get all the associated bindings with the injector by calling the <kbd class="calibre12">Injector.getBindings()</kbd> <span class="calibre11">method</span><span class="calibre11">, which returns a map containing binding objects:</span></p>
<pre class="calibre17">Map&lt;Key, Binding&gt; bindings = injector.getBindings()</pre>
<p class="calibre2">From this, we can say that each binding has a matching <kbd class="calibre12">key</kbd> object, which is internally made and kept by the Google Guice class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Guice</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">Guice</kbd> is a final class, an entry point to the Guice framework. It's used to create injectors by providing a set of modules:</p>
<pre class="calibre17">//From NotificationClient.java<br class="title-page-name"/>Injector injector = Guice.createInjector(new ApplicationModule());<br class="title-page-name"/><br class="title-page-name"/>//Syntax from actual Guice Class  <br class="title-page-name"/>Injector injector = Guice.createInjector(<br class="title-page-name"/>                    new ModuleA(),<br class="title-page-name"/>                    new ModuleB(),<br class="title-page-name"/>                    . . .<br class="title-page-name"/>                    new ModuleN(args)<br class="title-page-name"/>);</pre>
<p class="calibre2">In the preceding code snippet, notice that the <kbd class="calibre12">createInjector()</kbd> method takes <kbd class="calibre12">ApplicationModule()</kbd> as an argument; <span class="calibre11">the same method also takes a </span><kbd class="calibre12">varargs</kbd>, which means we can pass zero or more modules separated by a comma.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Provider</h1>
                
            
            <article>
                
<p class="calibre2">By default, whenever an application requires an instance of an object, Guice <span class="calibre11">instantiates</span> and returns it; but, in some cases, if the object creation process needs customization, then Guice providers do that. A provider interface takes after the <span class="calibre11">conventional f</span>actory design in making objects.  For instance, consider our <kbd class="calibre12">ApplicationModule</kbd> class binding process:</p>
<pre class="calibre17">binder.bind(NotificationService.class).to(new SMSProvider());</pre>
<p class="calibre2">By writing above line of code, <span class="calibre11"><kbd class="calibre12">SMSProvider</kbd></span> <span class="calibre11">class</span><span class="calibre11"> </span><span class="calibre11">gives</span><span class="calibre11"> f</span><span class="calibre11">actory</span><span class="calibre11"> </span><span class="calibre11">methods</span><span class="calibre11"> that will return objects of </span><span class="calibre11">type</span><span class="calibre11"> <kbd class="calibre12">NotificationService</kbd>. Let's say we want to customize the object-making and maintenance process for the <kbd class="calibre12">ServiceConnection</kbd> class, which is shown as follows:</span></p>
<pre class="calibre17">public class ServiceConnection {<br class="title-page-name"/><br class="title-page-name"/>    public void startService(){<br class="title-page-name"/>        System.out.println("Start SMS Notification Service");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public void stopService(){<br class="title-page-name"/>        System.out.println("Stop SMS Notification Service");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11"><span class="calibre11">Now</span></span> let's compose a straightforward <kbd class="calibre12">Provider</kbd> interface that acclimates to Guice <kbd class="calibre12">Provider</kbd> that makes and returns <kbd class="calibre12">ServiceConnection</kbd> objects. The following is the code for this:</p>
<pre class="calibre17">import com.google.inject.Provider;<br class="title-page-name"/><br class="title-page-name"/>public class SMSProvider implements Provider{<br class="title-page-name"/><br class="title-page-name"/>    @Override<br class="title-page-name"/>    public ServiceConnection get() {<br class="title-page-name"/><br class="title-page-name"/>        // Write some custom logic here.<br class="title-page-name"/>        ServiceConnection serviceConnection = new ServiceConnection();<br class="title-page-name"/>        // Write some custom logic here.<br class="title-page-name"/>        return serviceConnection;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Every custom provider class should implement <kbd class="calibre12">Provider</kbd> interface, and must override the <kbd class="calibre12">get()</kbd> method to get back the objects made in a custom mold. Presently, the module should be aware about the custom provider class so that Guice asks <kbd class="calibre12">SMSProvider</kbd> to create instances, instead of making them on its own. The following is a module snippet <span class="calibre11"><span class="calibre11">that contains</span></span> the test client code:</p>
<pre class="calibre17">import javax.inject.Provider;<br class="title-page-name"/><br class="title-page-name"/>import com.google.inject.Binder;<br class="title-page-name"/>import com.google.inject.Guice;<br class="title-page-name"/>import com.google.inject.Injector;<br class="title-page-name"/>import com.google.inject.Module;<br class="title-page-name"/><br class="title-page-name"/>public class NotificationClientTest {<br class="title-page-name"/><br class="title-page-name"/>    public static void main(String args[]){<br class="title-page-name"/>        Injector injector = Guice.createInjector(<br class="title-page-name"/>            new Module(){<br class="title-page-name"/>                @Override<br class="title-page-name"/>                public void configure(Binder binder) {<br class="title-page-name"/>                    binder.bind(ServiceConnection.class).toProvider((Class&lt;? extends Provider&lt;? extends ServiceConnection&gt;&gt;) SMSProvider.class);<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>        );<br class="title-page-name"/><br class="title-page-name"/>        ServiceConnection serviceConnection =<br class="title-page-name"/>        injector.getInstance(ServiceConnection.class);<br class="title-page-name"/>        serviceConnection.startService();<br class="title-page-name"/>        serviceConnection.stopService();<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">We have seen the use of major API individually, which has a notable role in Guice's start-up phase. The following is the sequence diagram of our application, which illustrates the complete flow of Guice dependency </span>management:</p>
<div class="mce-root"><img src="../images/00029.jpeg" class="calibre46"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Runtime phase</h1>
                
            
            <article>
                
<p class="calibre2">We will now be able to utilize the injector we made during the start-up phase to inject objects and examine our bindings. <span class="calibre11">Guice's runtime phase consists </span><span class="calibre11">of</span><span class="calibre11"> an injector </span><span class="calibre11">which contains</span><span class="calibre11"> </span><span class="calibre11">a few</span><span class="calibre11"> </span><span class="calibre11">bindings:</span></p>
<div class="mce-root"><img src="../images/00030.jpeg" class="calibre47"/></div>
<p class="calibre2">The preceding diagram defines the components of each binding. Each <strong class="calibre4">key</strong> uniquely recognizes each binding. The key consists of a type, which the client depends on, and an annotation, which is optional. An <strong class="calibre4">annotation</strong> could be used to distinguish a couple of bindings of the same type.</p>
<p class="calibre2">Every single binding has a provider, which gives an instance of the <span class="calibre11">mandatory type. We may offer a class, and Guice will make instances of it for us. We might give Guice an instance of the type for binding the class. Guice can inject dependencies if we provide our own</span> <strong class="calibre4">provider</strong><span class="calibre11">.</span></p>
<p class="calibre2">By default, no bindings have a scope; but it's optionally available, and for each injection, Guice creates a new instance, which is similar to Spring <strong class="calibre4">Prototype.</strong> Guice also provides a facility to define a custom scope to govern <span class="calibre11">whether or not Guice makes a new instance. In this case, we can make one instance per <kbd class="calibre12">HttpSession</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Guice annotations</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">Guice comes with a </span><span class="calibre11">little</span><span class="calibre11"> set of </span><span class="calibre11">valuable</span><span class="calibre11"> a</span><span class="calibre11">nnotations</span><span class="calibre11"> that are </span><span class="calibre11">utilized</span><span class="calibre11"> to </span><span class="calibre11">include</span><span class="calibre11"> metadata values in an application. Now, let's study</span><span class="calibre11"> the a</span><span class="calibre11">nnotations</span><span class="calibre11"> that are going to get </span><span class="calibre11">secured</span><span class="calibre11"> in this </span><span class="calibre11">segment.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inject</h1>
                
            
            <article>
                
<p class="calibre2">Guice provides the <kbd class="calibre12">@Inject</kbd> annotation to indicate that a consumer is dependent on a particular dependency. The injector takes care of initializing this dependency using the object graph. Guice gets a hint from the annotation that it needs to participate in the class construction phase. The <kbd class="calibre12">@Inject</kbd> annotation can be <span class="calibre11">utilized</span><span class="calibre11"> in a constructor for a </span><span class="calibre11">class</span><span class="calibre11">, for a method, </span><span class="calibre11">or for a field. Con</span><span class="calibre11">sider the following</span> code<span class="calibre11">:</span></p>
<pre class="calibre17">//Field level injection<br class="title-page-name"/>@Inject<br class="title-page-name"/>private NotificationService notificationService;<br class="title-page-name"/><br class="title-page-name"/>//Constructor level Injection<br class="title-page-name"/>@Inject<br class="title-page-name"/>public AppConsumer(NotificationService service){<br class="title-page-name"/>     this.notificationService=service;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Method  level injection<br class="title-page-name"/>@Inject<br class="title-page-name"/>public void setService(NotificationService service) {<br class="title-page-name"/>    this.notificationService = service;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ProvidedBy</h1>
                
            
            <article>
                
<p class="calibre2">If we need to customize the object creation process for a few interface types, at that point we would depend on the Guice Provider component. Let’s say, for the <kbd class="calibre12">NotificationService</kbd> interface, we need <kbd class="calibre12">SMSProvider</kbd> to make and return objects of type <kbd class="calibre12">SMSService</kbd>. In such a case, we can authorize the provider type for the interface by specifically explaining it in the interface statement. Consider the following code snippet, <kbd class="calibre12">NotificationService.java</kbd>;</p>
<pre class="calibre17">@ProvidedBy(SMSProvider.class)
public interface NotificationService{
<br class="title-page-name"/>}<br class="title-page-name"/>//@ProvidedBy is <span>equivalent to toProvider() binding like below,<br class="title-page-name"/>bind(NotificationService.class).toProvider(SMSProvider.class)<br class="title-page-name"/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ImplementedBy</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">This a</span><span class="calibre11">nnotation</span><span class="calibre11"> </span><span class="calibre11">focuses</span><span class="calibre11"> on a c</span><span class="calibre11">lass</span><span class="calibre11"> </span><span class="calibre11">object</span><span class="calibre11"> that </span><span class="calibre11">gives</span><span class="calibre11"> an i</span><span class="calibre11">mplementation</span><span class="calibre11"> to the interface. For example, </span><span class="calibre11">in case</span><span class="calibre11"> the <kbd class="calibre12">NotificationService</kbd> </span><span class="calibre11">interface has </span><span class="calibre11">numerous</span><span class="calibre11"> </span><span class="calibre11">usages,</span><span class="calibre11"> and </span><span class="calibre11">in case</span><span class="calibre11"> we wish to have <kbd class="calibre12">SMSService</kbd> as the default </span><span class="calibre11">implementation</span><span class="calibre11">, </span><span class="calibre11">at that point</span><span class="calibre11"> we can</span> <span class="calibre11"> code as follows:</span></p>
<pre class="calibre17">@ImplementedBy(SMSService.class)
public interface NotificationService{
    boolean sendNotification(String message, String recipient);
}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">@Named</h1>
                
            
            <article>
                
<p class="calibre2">Making unused annotation types for each concrete usage doesn’t provide much value, as the sole reason for having such an annotation is to check the implementation class instance required by clients. To support such things, we have a built-in binding annotation called <kbd class="calibre12">@Named</kbd>, which takes a string. There's the method <kbd class="calibre12">Names.named()</kbd>, which returns <kbd class="calibre12">@Named</kbd> annotation when passing names as arguments:</p>
<pre class="calibre17">bind(NotificationService.class).annotatedWith(Names.named("SMS"))<br class="title-page-name"/>          .to(SMSService.class);</pre>
<p class="calibre2">We suggest utilizing <kbd class="calibre12">@Named</kbd> sparingly, because the compiler cannot check the string.</p>
<p class="calibre2"><kbd class="calibre12">@Singleton</kbd> is another useful annotation which we will discuss in detail in <a href="part0131.html#3STPM0-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 5</a>, <em class="calibre13">Scopes</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Binding in Guice</h1>
                
            
            <article>
                
<p class="calibre2">In the previous topic, we became acquainted with the binding process and its importance in Guice DI. Each binding call to the <kbd class="calibre12">bind()</kbd> method is type-checked, so the compiler can report mistakes in case you utilize off-base types.</p>
<p class="calibre2">Guice provides different types of binding techniques which can be used in modules. The types of binding available are: linked bindings, instance bindings; untargeted bindings. <span class="calibre11">Constructor bindings,</span> built-in bindings, Just-in-time bindings. <span class="calibre11">and provider bindings.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linked bindings</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4"><span class="calibre11">Linked</span><span class="calibre11"> </span></strong><span class="calibre11"><strong class="calibre4">binding</strong> helps to </span><span class="calibre11">map</span><span class="calibre11"> a </span><span class="calibre11">type</span><span class="calibre11"> to its </span><span class="calibre11">implementation. Examples of linked bindings include a</span>n interface to its implementation class, and a<span class="calibre11"> superclass to a subclass.</span></p>
<p class="calibre2"><span class="calibre11"><span class="calibre11">Here, <kbd class="calibre12">NotificationService</kbd> is bound to the <kbd class="calibre12">SMSService</kbd> instance in the <kbd class="calibre12">ApplicationModule</kbd> class. This <span class="calibre11">binding</span> <span class="calibre11">affirmation</span> <span class="calibre11">binds</span> an interface to its implementation:</span></span></p>
<pre class="calibre17">   bind(NotificationService.class).to(SMSService.class);</pre>
<p class="calibre2"><span class="calibre11">When we call <kbd class="calibre12">injector.getInstance(ApplicationModule.class)</kbd>,</span> <span class="calibre11">it will </span><span class="calibre11">utilize</span><span class="calibre11"> <kbd class="calibre12">SMSService</kbd>. If binding to a <span class="calibre11">distinctive</span> <span class="calibre11">implementation</span> of <kbd class="calibre12">NotificationService</kbd>, as an <kbd class="calibre12">EmailService</kbd> is required, t</span><span class="calibre11">hen we </span><span class="calibre11">only</span><span class="calibre11"> need </span><span class="calibre11">to </span><span class="calibre11">essentially</span><span class="calibre11"> </span><span class="calibre11">alter</span><span class="calibre11"> the </span><span class="calibre11">binding</span><span class="calibre11">:</span></p>
<pre class="calibre17">bind(NotificationService.class).to(EmailService.class);</pre>
<p class="calibre2">We can <span class="calibre11">even </span>define the link <span class="calibre11">from a </span><span class="calibre11">type</span><span class="calibre11"> to any of its subtypes, such as an </span><span class="calibre11">executing</span><span class="calibre11"> </span><span class="calibre11">class</span><span class="calibre11"> or an </span><span class="calibre11">extending</span><span class="calibre11"> </span><span class="calibre11">class</span><span class="calibre11">. You can </span><span class="calibre11">indeed</span><span class="calibre11"> </span><span class="calibre11">link</span><span class="calibre11"> the concrete <kbd class="calibre12">SMSService</kbd> </span><span class="calibre11">course</span><span class="calibre11"> to a subclass:</span></p>
<pre class="calibre17">bind(SMSService.class).to(SMSDatabase.class);</pre>
<p class="calibre2">A basic thing to be <span class="calibre11">understood</span> is that <span class="calibre11">linked</span> <span class="calibre11">binding</span> could <span class="calibre11">indeed</span> be chained. For <span class="calibre11"><span class="calibre11">example</span></span>, <span class="calibre11">if</span> we <span class="calibre11">need</span> <kbd class="calibre12">SMSService</kbd> to be wired to a <span class="calibre11">specific</span> <span class="calibre11">class</span> which extends the <kbd class="calibre12">SMSService</kbd>, <span class="calibre11">at that point</span> we would do something like this:</p>
<pre class="calibre17">public class ApplicationModule implements AbstractModule{<br class="title-page-name"/>  @Override<br class="title-page-name"/>  protected void configure() {<br class="title-page-name"/>    //Linked binding as chain<br class="title-page-name"/>    bind(NotificationService.class).to(SMSService.class);<br class="title-page-name"/>    bind(SMSService.class).to(SMSDataBase.class);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">Here, if asked for <kbd class="calibre12">NotificationService</kbd>, then the injector will return the <kbd class="calibre12">SMSDataBase</kbd> instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Instance bindings</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11"><strong class="calibre4">Instance bindings</strong> help to </span><span class="calibre11">bind</span><span class="calibre11"> a </span><span class="calibre11">type</span><span class="calibre11"> to a </span><span class="calibre11">particular</span><span class="calibre11"> </span><span class="calibre11">instance</span><span class="calibre11"> of that </span><span class="calibre11">type</span><span class="calibre11">. </span>This is normally helpful only for objects that don't have <span class="calibre11">dependencies</span><span class="calibre11"> </span><span class="calibre11">in their possession;</span> for example, value objects:</p>
<pre class="calibre17">Public class SearchModule extends AbstractModule{<br class="title-page-name"/>    @Override<br class="title-page-name"/>    protected void configure() {<br class="title-page-name"/>        bind(SearchParameters.class).toInstance(new SearchParameters());<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">Avoid </span><span class="calibre11">utilizing </span><span class="calibre11"><kbd class="calibre12">.toInstance</kbd> with objects that are complicated to </span><span class="calibre11">make</span><span class="calibre11">, since it can </span><span class="calibre11">slow down application start-up</span><span class="calibre11">. You can </span><span class="calibre11">utilize</span><span class="calibre11"> the <kbd class="calibre12">@Provides</kbd> technique</span><span class="calibre11">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Untargeted bindings</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11"><span class="calibre11">B</span></span>inding that can be created without target is known as an untargeted bindings. <span class="calibre11">These are </span><span class="calibre11">really</span><span class="calibre11"> </span><span class="calibre11">signs</span><span class="calibre11"> to the injector </span><span class="calibre11">around</span><span class="calibre11"> a </span><span class="calibre11">type,</span><span class="calibre11"> </span><span class="calibre11">so that the </span><span class="calibre11">dependencies</span><span class="calibre11"> are </span><span class="calibre11">arranged</span><span class="calibre11"> </span><span class="calibre11">eagerly</span><span class="calibre11">.</span> <span class="calibre11">In <strong class="calibre4">untargeted binding</strong>, we do not require the</span> <kbd class="calibre12">to</kbd> <span class="calibre11">clause:</span></p>
<pre class="calibre17">bind(Sample<span>ConcreteClass</span><span>.</span>class).in(Singleton.class);
//Another way to define untargeted binding<br class="title-page-name"/>bind(<span>String</span><span>.</span>class).toInstance(<span><span>"</span>./alerts/<span>"</span></span>);</pre>
<p class="calibre2">In this statement, the injector would prepare an instance of the String class eagerly with a value of  <kbd class="calibre12">./alerts/</kbd>. When dependency injection requires it to inject the instance of String, it will inject this specific instance. This binding is useful when defining concrete classes and types annotated by <kbd class="calibre12">@ImplementedBy</kbd> or <kbd class="calibre12">@ProvidedBy</kbd>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructor bindings</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">This kind </span><span class="calibre11">of </span><span class="calibre11">binding</span><span class="calibre11"> </span><span class="calibre11">binds</span><span class="calibre11"> a </span><span class="calibre11">type</span><span class="calibre11"> to a constructor. This </span><span class="calibre11">specific</span><span class="calibre11"> case arises when the <kbd class="calibre12">@Inject</kbd> annotation can't be implemented to the target constructor</span><span class="calibre11">. Possible reasons for this could be:</span></p>
<ul class="calibre9">
<li class="calibre10"><span>If we are using a third-party class</span></li>
<li class="calibre10">A couple of constructors taking part in dependency injection</li>
</ul>
<p class="calibre2"><span class="calibre11">To address such a </span><span class="calibre11">problem</span><span class="calibre11">, we have the <kbd class="calibre12">toConstructor()</kbd> </span><span class="calibre11">binding</span><span class="calibre11"> in</span><span class="calibre11"> our module</span><span class="calibre11">. Here, if the constructor cannot be found, module reflectively select our target constructor and handle the </span><span class="calibre11">exception:</span></p>
<pre class="calibre17"><span>public</span> <span>class</span> <span>SampleModule</span> <span>extends</span> <span>AbstractModule</span> {
  <span>@Override</span> 
  <span>protected</span> <span>void</span> <span>configure</span>() {
    <span>try</span> {
      bind(<span>NotificationService</span><span>.</span>class)<span>.</span>toConstructor(
          <span>SMSService</span><span>.</span>class<span>.</span>getConstructor(<span>SMSDatabaseConnection</span><span>.</span>class));
    } <span>catch</span> (<span>NoSuchMethodException</span> e) {
      e.getPrintStackTrace();
    }
  }
}</pre>
<p class="calibre2">In the previous code, <kbd class="calibre12">SMSService</kbd> should have a constructor that takes a single <kbd class="calibre12">SMSDatabaseConnection</kbd> parameter. Guice will conjure that constructor to fulfill the binding, so the constructor does not require an <kbd class="calibre12">@Inject</kbd> annotation. If we select reflective constructor then we require to handle checked exceptions thrown by the <kbd class="calibre12">getConstructor()</kbd> API.</p>
<div class="packt_tip">The scope of each constructor binding is autonomous. In the event that we make different singleton bindings that target the same constructor, every binding yields its possess instance.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Built-in bindings</h1>
                
            
            <article>
                
<p class="calibre2">As the name suggests, these are bindings that are automatically covered in the injector. Let <span class="calibre11">the injector make </span><span class="calibre11">these</span><span class="calibre11"> bindings, as trying </span><span class="calibre11">to</span><span class="calibre11"> bind them </span><span class="calibre11">yourself</span><span class="calibre11"> is an </span><span class="calibre11">error</span><span class="calibre11">. <strong class="calibre4">Loggers</strong> is one example of this.</span></p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Loggers</strong>: <kbd class="calibre12">java.util.logging.Logger</kbd> has a built-in binding in Guice. The <span>binding</span> <span>naturally</span> sets the logger's <span>title</span> to the <span>title</span> of the <span>class</span> into which the <span>logger</span> is being <span>injected:</span></li>
</ul>
<pre class="calibre17"><span>@Singleton</span>
<span>public</span> <span>class</span> SMSDatabase<span>Log</span> <span>implements</span> Database<span>Log</span> {

  <span>private</span> <span>final</span> <span>Logger</span> logger;

  <span>@Inject</span>
  <span>public</span> <span>SMSDatabaseLog</span>(<span>Logger</span> <span>logger</span>) {
    <span>this</span><span>.</span>logger <span>=</span> logger;
  }

  <span>public</span> <span>void</span> <span>loggerException</span>(<span>UnreachableException</span> <span>e</span>) {
<span>    //Below message will be logged to the SMSDatabaseLog by logger.</span>
    logger<span>.</span>warning(<span><span>"SMS Database connection </span>exception, <span>"</span></span> <span>+</span> e<span>.</span>getMessage());
  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Just-in-time Bindings</h1>
                
            
            <article>
                
<p class="calibre2">These are bindings that might be made by Guice automatically. When there is not a clear binding, the injector will endeavor to make a binding, which is a <strong class="calibre4">Just-in-time </strong>(<strong class="calibre4">JIT</strong>) binding or implicit binding. </p>
<p class="calibre2"><strong class="calibre4">Default constructors</strong>:<strong class="calibre4"> </strong>By default, no argument constructors are invoked to get instances <span class="calibre11">ready</span><span class="calibre11"> </span><span class="calibre11">for injection. Occasionally, in our illustrations there is no express binding as a way to make an instance of <kbd class="calibre12">Client</kbd>. In any case, the injector invoked a default constructor to return the instance of the client.</span></p>
<p class="calibre2"><strong class="calibre4">Constructors with</strong> <kbd class="calibre12">@Inject</kbd>: If  constructors have the <kbd class="calibre12">@Inject</kbd> annotation, then that moreover qualified for implicit bindings. It also includes no arguments and a public constructor:</p>
<pre class="calibre17"><span>//Constructor Based Injector</span><span>
</span><span>@Inject</span><span>
</span><span>public AppConsumer(NotificationService notificationService){</span><span>
    </span><span>this.service = notificationService;</span><span>
</span><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Binding annotations</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">Sometimes we want to use numerous bindings for the same type. </span>In our earlier example, <kbd class="calibre12">NotificationService</kbd> is bound to <kbd class="calibre12">SMSService</kbd>, which is essentially futile since the interface is bound to just one execution. If we need the client to have the adaptability to utilize any of the implementations, at that point we n<span class="calibre11">eed</span><span class="calibre11"> </span><span class="calibre11">to write</span><span class="calibre11"> </span><span class="calibre11">a couple of </span>bind statements in the <kbd class="calibre12">configure()</kbd> method, and to make that possible, we can write code as follows:</p>
<pre class="calibre17"><span>bind(NotificationService.class).annotatedWith(“sms”).to(SMSService.class);</span><br class="title-page-name"/><span>bind(</span><span>NotificationService</span><span>.class).annotatedWith(“email”).to(EmailService.class);</span></pre>
<p class="calibre2">From the previous statement, Guice knows when to bind the <kbd class="calibre12">NotificationService</kbd> interface to <kbd class="calibre12">SMSService</kbd> and when to bind it to <kbd class="calibre12">EmailService</kbd>.</p>
<p class="calibre2"><span class="calibre11">The client-side code t</span>o call the <kbd class="calibre12">SMSService</kbd> implementation will look like this:</p>
<pre class="calibre17">AppConsumer app = injector.getInstance(@Named("sms") AppConsumer.class);</pre>
<p class="calibre2">And to call <kbd class="calibre12">EmailService</kbd> implementation:</p>
<pre class="calibre17">AppConsumer app = injector.getInstance(@Named("email") AppConsumer.class);</pre>
<p class="calibre2">To support such a case, binding supports non-mandatory <em class="calibre13">binding annotations</em>. A <strong class="calibre4">key</strong> is a pair of unique combinations of Annotation and Type. The following is the basic code to define binding annotations for SMS annotation:</p>
<pre class="calibre17"><span>@BindingAnnotation</span> <span>@Target</span>({ <span>FIELD</span>, <span>PARAMETER</span>, <span>METHOD</span> }) <span>@Retention</span>(<span>RUNTIME</span>)
<span>public</span> <span>@interface</span> SMS{}</pre>
<p class="calibre2">From the previous two lines, let's look at the meta-annotations:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre12">@BindingAnnotation</kbd> is utilized to tell Guice that this is a binding's explanation. If we ever define a different binding for the same member, then Guice may produce an error.</li>
<li class="calibre10"><kbd class="calibre12">@Target</kbd> and <kbd class="calibre12">@Retention</kbd> are typical annotations used to create custom annotations in Java. <kbd class="calibre12">@Target</kbd>, helps to locate field, parameter, and method, and <kbd class="calibre12">@Ratention(RUNTIME)</kbd> available in runtime respectively.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Guice injection</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">As we know what dependency injection is, let us explore how Google Guice provides injection.</span></p>
<p class="calibre2">We have seen that the injector helps to resolve dependencies by reading configurations from modules, which are called <em class="calibre13">bindings</em><span class="calibre11"><span class="calibre11">. <em class="calibre13">Injector</em></span></span> is preparing charts for the requested objects.</p>
<p class="calibre2">Dependency injection is managed by injectors using various types of injection:</p>
<ul class="calibre9">
<li class="calibre10">Constructor injection</li>
<li class="calibre10">Method injection</li>
<li class="calibre10">Field injection</li>
<li class="calibre10">Optional injection</li>
<li class="calibre10">Static injection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructor Injection</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Constructor injection</strong> can be achieved  by using the <kbd class="calibre12">@Inject</kbd> annotation at the constructor level. This constructor ought to acknowledge class dependencies as arguments. Multiple constructors will, at that point, assign the arguments to their final fields:</p>
<pre class="calibre17">public class AppConsumer {<br class="title-page-name"/><br class="title-page-name"/>  private NotificationService notificationService;<br class="title-page-name"/><br class="title-page-name"/>  //Constructor level Injection<br class="title-page-name"/>  @Inject<br class="title-page-name"/>  public AppConsumer(NotificationService service){<br class="title-page-name"/>       this.notificationService=service;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public boolean sendNotification(String message, String recipient){<br class="title-page-name"/>    //Business logic<br class="title-page-name"/>    return notificationService.sendNotification(message, recipient);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">If our class does not have a constructor with <kbd class="calibre12">@Inject</kbd>, then it will be considered a default constructor with no arguments. When we have a single constructor and the class accepts its dependency, at that time the constructor injection works perfectly and is helpful for unit testing. It is also easy because Java is maintaining the constructor invocation, so you don't have to stress about objects arriving in an uninitialized state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Method injection</h1>
                
            
            <article>
                
<p class="calibre2">Guice allows us to define injection at the method level by annotating methods with the <kbd class="calibre12">@Inject</kbd> annotation. This is similar to the setter injection available in Spring. In this approach, dependencies are passed as parameters, and are resolved by the injector before invocation of the method. The name of the method and the number of parameters <span class="calibre11">does not </span><span class="calibre11">affect</span><span class="calibre11"> the</span> <span class="calibre11">method injection:</span></p>
<pre class="calibre17">private NotificationService notificationService;<br class="title-page-name"/>//Setter Injection<br class="title-page-name"/>@Inject<br class="title-page-name"/>public void setService(NotificationService service) {<br class="title-page-name"/>   this.notificationService = service;<br class="title-page-name"/>}</pre>
<p class="calibre2">This could be valuable when we don't want to control instantiation of classes. We can, moreover, utilize it in case you have a super class that needs a few dependencies. (This is difficult to achieve in a constructor injection.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Field injection</h1>
                
            
            <article>
                
<p class="calibre2">Fields can be injected by the <kbd class="calibre12">@Inject</kbd> annotation in Guice. This is a simple and short injection, but makes the field untestable if used with the <kbd class="calibre12">private</kbd> access modifier. It is advisable to avoid the following:</p>
<pre class="calibre17">@Inject private NotificationService notificationService;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Optional injection</h1>
                
            
            <article>
                
<p class="calibre2">Guice provides a way to declare an injection as optional. The method and field might be optional, which causes Guice to quietly overlook them when the dependencies aren't accessible. <strong class="calibre4">Optional injection</strong> can be used by mentioning the <span class="calibre11"><kbd class="calibre12">@Inject(optional=true)</kbd> annotation:</span></p>
<pre class="calibre17">public class AppConsumer {<br class="title-page-name"/>  private static final String DEFAULT_MSG = "Hello";<br class="title-page-name"/>  private string message = DEFAULT_MSG;<br class="title-page-name"/>  <br class="title-page-name"/>  @Inject(optional=true)<br class="title-page-name"/>  public void setDefaultMessage(@Named("SMS") String message) {<br class="title-page-name"/>    this.message = message;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Static injection</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Static injection</strong> is helpful when we have to migrate a static factory implementation into Guice. <span class="calibre11">It makes it </span><span class="calibre11">feasible</span><span class="calibre11"> for </span><span class="calibre11">objects</span><span class="calibre11"> to </span><span class="calibre11">mostly</span><span class="calibre11"> </span><span class="calibre11">take part</span><span class="calibre11"> in dependency injection by <span class="calibre11">picking</span></span><span class="calibre11"> up access to</span><span class="calibre11"> injected </span><span class="calibre11">types</span><span class="calibre11"> </span><span class="calibre11">without</span><span class="calibre11"> being injected themselves. In a module, to indicate classes to be injected on injector creation, use <kbd class="calibre12">requestStaticInjection()</kbd></span>. For example,  <kbd class="calibre12">NotificationUtil</kbd> is a utility class that provides a static method, <kbd class="calibre12">timeZoneFormat</kbd>, to  a string in a given format, and returns the date and timezone. The <kbd class="calibre12">TimeZoneFormat</kbd> string is hardcoded in <kbd class="calibre12">NotificationUtil</kbd>, and we will attempt to inject this utility class statically.</p>
<p class="calibre2">Consider that we have one private static string variable, <kbd class="calibre12">timeZonFmt</kbd>, with setter and getter methods. We will use <kbd class="calibre12">@Inject</kbd> for the setter injection, using the <kbd class="calibre12">@Named</kbd> parameter.</p>
<p class="calibre2"><kbd class="calibre12">NotificationUtil</kbd> will look like this:</p>
<pre class="calibre17">@Inject static String timezonFmt = "yyyy-MM-dd'T'HH:mm:ss";<br class="title-page-name"/><br class="title-page-name"/>@Inject<br class="title-page-name"/>public static void setTimeZoneFmt(@Named("timeZoneFmt")String timeZoneFmt){<br class="title-page-name"/> NotificationUtil.timeZoneFormat = timeZoneFmt;<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, <kbd class="calibre12">SMSUtilModule</kbd> should look like this:</p>
<pre class="calibre17">class SMSUtilModule extends AbstractModule{<br class="title-page-name"/>    @Override<br class="title-page-name"/>    protected void configure() {<br class="title-page-name"/>       bindConstant().annotatedWith(Names.named(timeZoneFmt)).to(yyyy-MM-dd'T'HH:mm:ss);<br class="title-page-name"/>       requestStaticInjection(NotificationUtil.class);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"> <span class="calibre11">This API is not </span><span class="calibre11">suggested</span><span class="calibre11"> for </span><span class="calibre11">common</span><span class="calibre11"> </span><span class="calibre11">utilization,</span><span class="calibre11"> </span><span class="calibre11">since</span><span class="calibre11"> it faces many</span><span class="calibre11"> of the same </span><span class="calibre11">issues</span><span class="calibre11"> as </span><span class="calibre11">static</span><span class="calibre11"> </span><span class="calibre11">factories. It is also difficult to </span><span class="calibre11">test and it makes </span><span class="calibre11">dependencies</span><span class="calibre11"> un</span><span class="calibre11">certain.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">So, that's it for Google Guice. To sum up our chapter, we began with basic dependency injection. After that, we learned how basic Dependency Injection works in Guice, with examples.</p>
<p class="calibre2"><span class="calibre11">Then, we</span><span class="calibre11"> </span><span class="calibre11">investigated the phases of Guice, and the role of the API in each phase.<span class="calibre11"> W</span></span>e got the idea that, unlike Spring, in Guice there is no requirement to maintain isolated XML files, as all the setup-related data is nicely typified by means of the module component.</p>
<p class="calibre2"><span class="calibre11">In the middle of the chapter, we explored the major annotations and distinct types of binding available in Guice, a</span>nd at the end, we learned the different types of injections.</p>
<p class="calibre2">In the next chapter, we will <span class="calibre11">become competent in the different scopes offered by Spring and the Google Guice framework</span><span class="calibre11">.</span></p>


            </article>

            
        </section>
    </body></html>