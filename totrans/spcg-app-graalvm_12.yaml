- en: '*Chapter 9*: GraalVM Polyglot – LLVM, Ruby, and WASM'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：GraalVM 多语言 – LLVM、Ruby 和 WASM'
- en: 'In the previous chapter, we covered Truffle interpreters for Java, Python,
    and R and interoperability between languages. In this chapter, we will cover other
    languages'' implementations, such as the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 Java、Python 和 R 的 Truffle 解释器以及语言间的互操作性。在本章中，我们将介绍其他语言的实现，例如以下内容：
- en: '**LLVM**: The LLVM Truffle interpreter'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLVM**：LLVM Truffle 解释器'
- en: '**TruffleRuby**: The Ruby language interpreter implementation'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TruffleRuby**：Ruby 语言解释器实现'
- en: '**WebAssembly** (**WASM**): WebAssembly implementation'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebAssembly** (*WASM*)：WebAssembly 实现'
- en: All of these language implementations are still in the *experimental* phase
    and are not released for production, at the time of writing this book. However,
    we will explore the features and build some code to understand the various concepts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些语言实现目前都处于*实验性*阶段，并且在撰写本书时并未发布用于生产。然而，我们将探索其功能和构建一些代码来理解各种概念。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Understanding LLVM, Ruby, and WASM interpreters and their polyglot features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 LLVM、Ruby 和 WASM 解释器及其多语言特性
- en: Understanding the compatibility and limitations of these various language interpreters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解这些各种语言解释器的兼容性和限制
- en: By the end of this chapter, you will have had hands-on experience in building
    polyglot applications with LLVM, Ruby, and WASM interpreters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将会有使用 LLVM、Ruby 和 WASM 解释器构建多语言应用程序的实践经验。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following to follow along with the various coding/hands-on
    sections:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容以跟随各种编码/实践部分：
- en: The latest version of GraalVM.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 的最新版本。
- en: Various language Graal runtimes. We will cover in the chapter how to install
    and run these runtimes.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种语言的 Graal 运行时。我们将在本章中介绍如何安装和运行这些运行时。
- en: 'Access to GitHub. There are some sample code snippets that are available on
    the Git repository. The code can be downloaded from the following link: [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter09](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter09).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 GitHub。在 Git 仓库中有一些可用的示例代码片段。代码可以从以下链接下载：[https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter09](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter09)。
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3hT7Z1A](https://bit.ly/3hT7Z1A).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在[https://bit.ly/3hT7Z1A](https://bit.ly/3hT7Z1A)找到。
- en: Understanding LLVM – the (Sulong) Truffle interface
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 LLVM – (Sulong) Truffle 接口
- en: LLVM is a compiler infrastructure that provides a modular, reusable set of compiler
    components that can form a toolchain to compile source code to machine code. The
    toolchain provides various levels of optimization, on an **intermediate representation**
    (**IR**). Any source language can use this toolchain, as long as the source code
    can be represented as an LLVM IR. Once the source code is represented as an LLVM
    IR, that language can utilize the advanced optimization techniques that LLVM provides.
    You can refer to the LLVM project at [https://llvm.org/](https://llvm.org/). There
    are various compilers that are already built on this infrastructure. Some of the
    most popular ones are Clang (for C, C++, and Objective C), Swift (used extensively
    by Apple), Rust, and Fortran.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 是一个编译器基础设施，它提供了一组模块化、可重用的编译器组件，可以形成一个工具链，将源代码编译成机器代码。该工具链在**中间表示**（**IR**）上提供各种级别的优化。任何源语言都可以使用这个工具链，只要源代码可以表示为
    LLVM IR。一旦源代码表示为 LLVM IR，该语言就可以利用 LLVM 提供的高级优化技术。您可以参考 [https://llvm.org/](https://llvm.org/)
    上的 LLVM 项目。已经基于这个基础设施构建了各种编译器。其中一些最受欢迎的是 Clang（用于 C、C++ 和 Objective C）、Swift（被苹果广泛使用）、Rust
    和 Fortran。
- en: 'Sulong is an LLVM interpreter that is written in Java and internally uses the
    Truffle language implementation framework. This enables all language compilers
    that can generate LLVM IR to directly run on GraalVM. The following diagram shows
    how Sulong enables LLVM languages to run on GraalVM:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Sulong 是一个用 Java 编写的 LLVM 解释器，内部使用 Truffle 语言实现框架。这使得所有可以生成 LLVM IR 的语言编译器都可以直接在
    GraalVM 上运行。以下图表显示了 Sulong 如何使 LLVM 语言能够在 GraalVM 上运行：
- en: '![Figure 9.1 – LLVM compilation pipeline'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – LLVM 编译管道](img/B16878_Figure_9.1.jpg)'
- en: '](img/B16878_Figure_9.1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – LLVM 编译管道](img/B16878_Figure_9.1.jpg)'
- en: Figure 9.1 – LLVM compilation pipeline
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – LLVM 编译管道
- en: 'The preceding figure shows how LLVM works at a very high level. C/C++ source
    code is compiled to LLVM IR. Let''s understand this diagram better:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示展示了 LLVM 在非常高级的层面上是如何工作的。C/C++ 源代码被编译成 LLVM IR。让我们更好地理解这个图：
- en: C/C++ code is compiled by Clang to LLVM IR.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C/C++ 代码由 Clang 编译成 LLVM IR。
- en: 'The `lli` GraalVM LLVM IR interpreter has two versions: *native* and *managed*.
    Native is the default `lli` version that comes both in Community Edition and Enterprise
    Edition. Managed `lli` is only available in Enterprise Edition and provides a
    managed mode of execution, which we will be covering in the *Understanding the
    LLVM managed environment* section.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lli` GraalVM LLVM IR 解释器有两个版本：*原生*和*管理型*。原生是默认的 `lli` 版本，它既包含在社区版中也包含在企业版中。管理型
    `lli` 仅在企业版中可用，并提供了一种管理执行模式，我们将在 *理解 LLVM 管理环境* 部分中介绍。'
- en: The LLVM IR interpreter performs the initial optimization and integrates with
    Truffle and Graal for further optimizations at runtime.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM IR 解释器执行初始优化并与 Truffle 和 Graal 集成，以便在运行时进行进一步优化。
- en: 'To understand how LLVM IR looks, here is some example C code where we are adding
    two numbers and returning the result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 LLVM IR 的外观，这里有一些示例 C 代码，其中我们添加两个数字并返回结果：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we pass this through Clang, the following LLVM IR is generated. We can
    generate the LLVM IR using the `clang -S -emit-llvm cfile.c` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 Clang 处理它时，将生成以下 LLVM IR。我们可以使用 `clang -S -emit-llvm cfile.c` 命令来生成 LLVM
    IR：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding IR clearly shows how the code gets converted into `a` variable
    (`%0`), which is passed as a parameter, and `b` (`%1`) is allocated `%3` and `%4`
    respectively. The values are then loaded into `%5` and `%6` respectively and added
    to `%7`. The value in `%7` is returned. SSA makes the optimization algorithms
    easy to implement, as the algorithms don't have to keep track of the value changes
    in a single variable, since every change in the variable is assigned to a single
    static value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 IR 清楚地显示了代码是如何转换为 `a` 变量（`%0`），它作为参数传递，而 `b` (`%1`) 分别分配到 `%3` 和 `%4`。然后，值被加载到
    `%5` 和 `%6` 中，并加到 `%7`。`%7` 中的值被返回。SSA 使得优化算法易于实现，因为算法不需要跟踪单个变量的值变化，因为变量的每个变化都分配给一个静态值。
- en: The LLVM IR can be passed to Sulong, which is the LLVM IR interpreter, which
    internally uses the Truffle language implementation framework to run the code
    on GraalVM. This takes advantage of the advanced optimization features of GraalVM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR 可以传递给 Sulong，它是 LLVM IR 解释器，它内部使用 Truffle 语言实现框架在 GraalVM 上运行代码。这利用了
    GraalVM 的高级优化功能。
- en: Installing the LLVM toolchain
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 LLVM 工具链
- en: 'LLVM is available as an optional runtime, and can be installed using Graal
    Updater, with the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 可作为可选的运行时，可以使用 Graal Updater 安装，命令如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'LLVM gets installed in `$GRAALVM_HOME/languages/llvm/native/bin`. We can check
    the path by using the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 被安装到 `$GRAALVM_HOME/languages/llvm/native/bin`。我们可以使用以下命令来检查路径：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will print the path where LLVM is installed. Enterprise Edition also comes
    with a managed LLVM. We will cover that later in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出 LLVM 安装的路径。企业版也附带了一个管理的 LLVM。我们将在本章后面介绍这一点。
- en: 'The GraalVM LLVM runtime can execute language code that is converted to LLVM
    bitcode. The GraalVM `lli` tool interprets bit code and then compiles dynamically
    using Graal `lli` also enables interoperability with dynamic languages. The syntax
    for the `lli` command is shown next:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM LLVM 运行时可以执行转换为 LLVM 位码的语言代码。GraalVM `lli` 工具解释位码，然后使用 Graal `lli` 动态编译。`lli`
    还支持与动态语言的互操作性。`lli` 命令的语法将在下面展示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`lli` can execute plain bitcode or native executables with embedded bitcode
    (Linux: ELF and macOS: Mach-O).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`lli` 可以执行纯位码或嵌入位码的原生可执行文件（Linux：ELF 和 macOS：Mach-O）。'
- en: 'Let''s quickly verify the installation with some simple code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些简单的代码快速验证安装：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s compile the code with Clang:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 Clang 编译这段代码：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This runs the `hellograal` application. Let''s run it using `lli`. `lli` is
    the LLVM interpreter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 `hellograal` 应用程序。让我们使用 `lli` 来运行它。`lli` 是 LLVM 解释器：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following shows the output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了输出：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can directly execute `/hellograal` and get the same output. This is called
    native execution. Sometimes native executions run faster than `lli`, but we don''t
    get the polyglot features that GraalVM provides with `lli`. Let''s take something
    more complex; let''s convert `FibonacciCalculator.java` to C. Here is the source
    code in C:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接执行`/hellograal`并得到相同的输出。这被称为原生执行。有时原生执行比`lli`更快，但我们无法获得`lli`提供的多语言特性。让我们来看一个更复杂的情况；让我们将`FibonacciCalculator.java`转换为C语言。以下是C语言的源代码：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s create an executable by running the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令来创建一个可执行文件：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have to make sure we use the right version of Clang. We have to use the
    Clang that is provided with the GraalVM LLVM toolchain; otherwise, we won''t be
    able to use `lli`. If we use normal Clang and try to execute the generated binary
    with `lli`, we get the following error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们使用正确的Clang版本。我们必须使用与GraalVM LLVM工具链一起提供的Clang；否则，我们无法使用`lli`。如果我们使用普通的Clang并尝试用`lli`执行生成的二进制文件，我们会得到以下错误：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the binary file is created, we execute it with `lli` to use the GraalVM
    JIT compilation capabilities. Here is the output when executed with `lli`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了二进制文件，我们就用`lli`执行它以使用GraalVM JIT编译功能。以下是使用`lli`执行时的输出：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s plot these results on a graph and see how the performance improved over
    iterations. The following is the graph:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在图表上绘制这些结果，看看性能在迭代中是如何提高的。以下是这个图表：
- en: '![Figure 9.2 – GraalVM LLVM performance graph'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – GraalVM LLVM性能图表]'
- en: '](img/B16878_Figure_9.2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – GraalVM LLVM性能图表](img/B16878_Figure_9.2.jpg)'
- en: Figure 9.2 – GraalVM LLVM performance graph
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – GraalVM LLVM性能图表
- en: We can see a significant improvement over iterations. We can see that initially,
    it runs slow, but after the third iteration, it improves by almost sixfold.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在迭代中有一个显著改进。我们可以看到，最初运行速度较慢，但在第三次迭代后，性能提高了近六倍。
- en: Exploring LLVM interoperability
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索LLVM互操作性
- en: In this section, we will explore the interoperability features of LLVM and see
    how we can interact between Java, LLVM (C), and JavaScript.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索LLVM的互操作性功能，并了解我们如何在Java、LLVM（C）和JavaScript之间进行交互。
- en: Java and LLVM interoperability
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java和LLVM互操作性
- en: 'Let''s first try to call the `FibonacciCalculator.c` executable from Java.
    Here is the source code for `FibonacciCalculatorLLVMEmbed.java`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试从Java中调用`FibonacciCalculator.c`可执行文件。以下是`FibonacciCalculatorLLVMEmbed.java`的源代码：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The source code is very similar to what we did with JavaScript. We are creating
    a `Context` object, loading the compiled file with a `Source` object, and building
    the `Source` object from a binary using `SourceBuilder`. The `Context` object
    is then used to evaluate the `Source` object and is finally executed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码与我们用JavaScript所做的工作非常相似。我们正在创建一个`Context`对象，使用`Source`对象加载编译的文件，并使用`SourceBuilder`从二进制文件构建`Source`对象。然后使用`Context`对象评估`Source`对象，并最终执行它。
- en: 'Let''s compile this Java file and run it with GraalVM Java. The following code
    shows the output of the file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译这个Java文件，并用GraalVM Java运行它。以下代码显示了文件的输出：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that we are able to call C code from Java. In this case, we just
    executed the C application. Let's now try to call the member function directly
    and pass an integer, and get the total as a `long` type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们能够从Java中调用C代码。在这种情况下，我们只是执行了C应用程序。现在让我们尝试直接调用成员函数并传递一个整数，并将总和作为`long`类型返回。
- en: 'Here is the modified C code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的C代码：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code implements the `FibonacciCalculator` logic that we had previously
    done using Java.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码实现了我们之前用Java编写的`FibonacciCalculator`逻辑。
- en: In this section, we looked at how to invoke a C method from Java. Let's now
    understand how to invoke C code from a dynamic language such as JavaScript.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何从Java中调用C方法。现在让我们了解如何从动态语言，如JavaScript中调用C代码。
- en: Exploring JavaScript and LLVM interoperability
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索JavaScript和LLVM互操作性
- en: 'Let''s check the interoperability with JavaScript. JavaScript provides a very
    simple snippet. Here is the JavaScript code (`FibonacciCaller.js`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查与JavaScript的互操作性。JavaScript提供了一个非常简单的代码片段。以下是JavaScript代码（`FibonacciCaller.js`）：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run this JavaScript as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式运行此JavaScript：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that we are now able to pass data to C code and execute the C method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们现在能够将数据传递给C代码并执行C方法。
- en: Understanding the LLVM managed environment
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解LLVM托管环境
- en: GraalVM Enterprise Edition provides a managed environment of LLVM. We can find
    a version of the LLVM managed toolchain under the `/languages/llvm/managed` directory,
    while the default, unmanaged toolchain can be found under `/languages/llvm/native`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM企业版提供了LLVM的管理环境。我们可以在`/languages/llvm/managed`目录下找到一个LLVM管理工具链的版本，而默认的非管理工具链可以在`/languages/llvm/native`目录下找到。
- en: When the managed version of `lli` is used, the managed environment or managed
    mode of execution can be enabled with the `--llvm.managed` flag. In this section,
    let's understand what the managed mode of execution is, and why it is specifically
    required for LLVM.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`lli`的管理版本时，可以通过`--llvm.managed`标志启用管理环境或管理执行模式。在本节中，让我们了解执行管理模式是什么，以及为什么它对LLVM特别必要。
- en: 'To understand the problems we typically face, let''s take some very simple
    code, `ManagedLLVM.c`. In the following code, we are intentionally trying to copy
    a character array to an uninitialized `char` pointer:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们通常遇到的问题，让我们取一些非常简单的代码，`ManagedLLVM.c`。在以下代码中，我们故意尝试将字符数组复制到一个未初始化的`char`指针：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s compile this code; Clang actually warns us about incorrectly initializing
    `valueStr`. `valueStr` is only defined to take 10 characters, but we are assigning
    more than 10 characters. Let''s assume that we ignore the warnings and proceed.
    The application is still built and can be executed. The following is the output
    of compiling the `ManagedLLVM.c` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译这段代码；Clang实际上警告我们`valueStr`的初始化不正确。`valueStr`仅定义了10个字符，但我们分配了超过10个字符。让我们假设我们忽略这些警告并继续。应用程序仍然可以构建并执行。以下是编译`ManagedLLVM.c`文件的输出：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we ignore the warnings and still run the application binary, we obviously
    get a page fault. This kills the host process and stops the application completely.
    Such problems cause a core dump and crash the application, and there are a lot
    of such instances with languages such as C/C++ where we face these kinds of issues.
    The following is the output when we run the code in native mode (directly native
    and native `lli`):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略警告并仍然运行应用程序的二进制文件，我们显然会得到一个页面错误。这会杀死宿主进程并完全停止应用程序。这类问题会导致核心转储并使应用程序崩溃，在C/C++等语言中，我们经常遇到这类问题。以下是我们在本地模式（直接本地和本地`lli`）运行代码时的输出：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'GraalVM LLVM managed execution mode provides a graceful way of handling these
    issues. Let''s take the same code and compile it this time with the managed version
    of Clang and run it with the managed version of `lli`. Let''s run the application
    binary with the managed version of `lli`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM LLVM管理执行模式提供了一种优雅地处理这些问题的方法。让我们用相同的代码，这次使用Clang的管理版本进行编译，并用`lli`的管理版本运行它。让我们用`lli`的管理版本运行应用程序的二进制文件：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It still fails, but this time it is not a segmentation fault or crash; it is
    throwing an exception. Exceptions can be caught and handled gracefully.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然失败了，但这次不是段错误或崩溃；它抛出了一个异常。异常可以被捕获并优雅地处理。
- en: 'To understand how to handle this better, lets create a Java class (`ManagedLLVM.java`)
    that calls the `managedllvm` executable from Java and handles the exception gracefully:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何处理这种情况，让我们创建一个Java类（`ManagedLLVM.java`），它从Java调用`managedllvm`可执行文件并优雅地处理异常：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that we are now creating a `Context` object with the `llvm.manage` option
    as `true`. That is very critical for us to run the executable in managed execution
    mode. Let''s compile and run this Java application:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在正在使用`llvm.manage`选项将`Context`对象设置为`true`。这对我们以管理执行模式运行可执行文件至关重要。让我们编译并运行这个Java应用程序：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that the Java application is now able to catch the exception and
    we could be writing exception handling code here. Moreover, it is not stopping
    the application. This is one of the greatest features of running LLVM in managed
    execution mode, and it is supported even in polyglot environments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Java应用程序现在能够捕获异常，我们可以在这里编写异常处理代码。此外，它并没有停止应用程序。这是在管理执行模式下运行LLVM的一个最伟大的特性，并且即使在多语言环境中也得到了支持。
- en: Ruby is another language that has a high-performance interpreter implementation
    in GraalVM. Let's explore and understand TruffleRuby, the Ruby Truffle implementation,
    in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby是另一种在GraalVM中有高性能解释器实现的编程语言。让我们在下一节探索并理解TruffleRuby，Ruby的Truffle实现。
- en: Understanding TruffleRuby – the Ruby Truffle interpreter
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TruffleRuby – Ruby的Truffle解释器
- en: TruffleRuby is a high-performance implementation of the Ruby programming language
    on GraalVM that is built on Truffle. In this section, we will explore some of
    the language-specific concepts, with code examples, to gain a good understanding
    of Ruby implementation on GraalVM.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: TruffleRuby是建立在Truffle之上的GraalVM上Ruby编程语言的高性能实现。在本节中，我们将通过代码示例探索一些语言特定的概念，以获得对GraalVM上Ruby实现的良好理解。
- en: Installing TruffleRuby
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装TruffleRuby
- en: 'TruffleRuby, too, does not come by default with GraalVM installation. You''ll
    have to download and install it using the Graal updater tool. To install TruffleRuby,
    use the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: TruffleRuby默认情况下也不包含GraalVM安装。您必须使用Graal更新工具下载并安装它。要安装TruffleRuby，请使用以下命令：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After installing Ruby, we have to run some post-install scripts to make `OpenSSL`
    C extensions work. We need to run `post_install_hook.sh`, which you will find
    under the `ruby/lib/truffle` directory. Let''s test the installation with a simple
    Ruby application:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Ruby之后，我们必须运行一些后安装脚本，以便`OpenSSL` C扩展能够工作。我们需要运行`post_install_hook.sh`，您可以在`ruby/lib/truffle`目录下找到它。让我们通过一个简单的Ruby应用程序来测试安装：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code accepts the values of `a` and `b` as integers from the user,
    adds the numbers, and prints the result as a string. This is a very simple Ruby
    application to test Ruby. Let''s run this program on TruffleRuby. The following
    is the terminal output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码接受用户输入的`a`和`b`的整数值，将数字相加，并将结果作为字符串打印出来。这是一个非常简单的Ruby应用程序来测试Ruby。让我们在TruffleRuby上运行这个程序。以下是在终端上的输出：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we know that TruffleRuby is installed and working, let's understand
    how the TruffleRuby interpreter works.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道TruffleRuby已安装并正在运行，让我们了解TruffleRuby解释器是如何工作的。
- en: Understanding the TruffleRuby interpreter/compiler pipeline
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解TruffleRuby解释器/编译器管道
- en: 'TrufflyRuby, like any other guest language, is a Truffle interpreter implementation.
    The following figure shows the TruffleRuby interpreter/compiler pipeline:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: TrufflyRuby，像任何其他客座语言一样，是Truffle解释器实现。以下图显示了TruffleRuby解释器/编译器管道：
- en: '![Figure 9.3 – TruffleRuby compiler/interpreter pipeline'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – TruffleRuby编译器/解释器管道](img/B16878_Figure_9.3.jpg)'
- en: '](img/B16878_Figure_9.3.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – TruffleRuby编译器/解释器管道](img/B16878_Figure_9.3.jpg)'
- en: Figure 9.3 – TruffleRuby compiler/interpreter pipeline
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – TruffleRuby编译器/解释器管道
- en: The interpreter/compiler pipeline is very similar to other guest languages.
    The preceding diagram does not capture all the details. Refer to the *Exploring
    the Truffle interpreter/compiler pipeline* section in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120),
    *Truffle – An Overview*, for a more detailed explanation on how Truffle interpreters
    and Graal JIT executes the code. The TruffleRuby interpreter builds the AST after
    parsing and performs optimizations and submits the code to Graal JIT, like any
    other guest language. However, one of the key differences is the way it handles
    C extensions. C extensions are an integral part of Ruby programming, and traditionally,
    C extensions are plugged into the Ruby interpreter. TruffleRuby handles this using
    the LLVM interpreter. This naturally provides polyglot interoperability and we
    can use other LLVM languages such as C++, Rust, and Swift, not just C. TruffleRuby
    brings in polyglot interoperability as it's built on Truffle. Let's explore the
    polyglot interoperability features of TruffleRuby.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器/编译器管道与其他客座语言非常相似。前面的图表没有捕捉到所有细节。请参阅[*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)中的*探索Truffle解释器/编译器管道*部分，*Truffle
    – 概述*，以获取关于Truffle解释器和Graal JIT如何执行代码的更详细解释。TruffleRuby解释器在解析后构建AST，并执行优化，然后将代码提交给Graal
    JIT，就像任何其他客座语言一样。然而，其中一个关键区别是它处理C扩展的方式。C扩展是Ruby编程的一个组成部分，并且传统上，C扩展被插入到Ruby解释器中。TruffleRuby使用LLVM解释器来处理这个问题。这自然提供了多语言互操作性，我们可以使用其他LLVM语言，如C++、Rust和Swift，而不仅仅是C。由于TruffleRuby建立在Truffle之上，它引入了多语言互操作性。让我们探索TruffleRuby的多语言互操作性功能。
- en: Exploring Polyglot interoperability with TruffleRuby
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索TruffleRuby的多语言互操作性
- en: 'TruffleRuby brings all the polyglot interoperability features of Truffle and
    implements similar APIs. Let''s explore these features in this section. Let''s
    write some simple Ruby code that calls the JavaScript file we built in previous
    sections that exports simple math functions and variables:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: TruffleRuby带来了Truffle的所有多语言互操作性功能，并实现了类似的API。让我们在本节中探索这些功能。让我们编写一些简单的Ruby代码，调用我们在前几节中构建的导出简单数学函数和变量的JavaScript文件：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the Ruby code that demonstrates the polyglot capabilities:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Ruby代码示例，展示了多语言能力：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we are calling JavaScript code that creates an array
    of three elements: an integer, a float, and a string. We are evaluating this JavaScript
    code in line with `Polyglot.eval()`. We are then iterating through the array and
    printing the values. In the following code, we are loading `math.js` and importing
    the `message` variable and the `add()`, `subtract()`, and `multiply()` functions.
    We are then invoking those functions and printing the results:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们调用JavaScript代码创建一个包含三个元素的数组：一个整数、一个浮点数和一个字符串。我们使用`Polyglot.eval()`在线评估此JavaScript代码。然后我们遍历数组并打印值。在以下代码中，我们加载`math.js`并导入`message`变量以及`add()`、`subtract()`和`multiply()`函数。然后我们调用这些函数并打印结果：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s run this code. The following is the output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行这段代码。以下是输出：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see that we are able to iterate through the JavaScript array, and also
    call the functions in the `math.js` JavaScript code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们能够遍历JavaScript数组，并且还能调用`math.js` JavaScript代码中的函数。
- en: 'Let''s now explore how to interoperate with Java. We use the `Java.type()`
    method to load the Java class. Let''s use a slightly modified version of `FibonacciCalculator`.
    Here''s the Java source code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何与Java交互。我们使用`Java.type()`方法加载Java类。让我们使用`FibonacciCalculator`的一个稍微修改过的版本。以下是Java源代码：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have defined two methods: `findFibonacci()` and `iterateFibonacci()`. The
    `findFibonacci()` method takes an integer and returns the Fibonacci numbers, as
    per the requested count. `iterateFibonacci()` iterates and generates a large number
    of Fibonacci numbers, and times it to check how the code performs.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个方法：`findFibonacci()`和`iterateFibonacci()`。`findFibonacci()`方法接受一个整数并返回按请求计数生成的斐波那契数。`iterateFibonacci()`迭代并生成大量斐波那契数，并计时以检查代码的性能。
- en: 'The following code is the Ruby script to load the `FibonacciCalculator` class
    and call the `findFibonacci(int count)` method. We pass an integer value to this
    method and we get an array of integers. We then go through the array and print
    the values. We are also calling `iterateFibonacci()` to compare how it performs
    with running directly with Java:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于加载`FibonacciCalculator`类并调用`findFibonacci(int count)`方法的Ruby脚本。我们向此方法传递一个整数值，并得到一个整数数组。然后我们遍历数组并打印值。我们还调用了`iterateFibonacci()`来比较它与直接使用Java运行的性能：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To run this Ruby script, we need to pass `--jvm` in the command line along
    with `--vm.cp` to point to the path where the Java class is available. The following
    is the output of running TruffleRuby:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此Ruby脚本，我们需要在命令行中传递`--jvm`，并使用`--vm.cp`指向Java类可用的路径。以下是运行TruffleRuby的输出：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can see how we are able to call the Java class and go through the Java array
    in Ruby, and even `iterateFibonacci()` performed reasonably well. Let''s try to
    compare this with running this Java class directly with Java. Here''s the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们能够在Ruby中调用Java类并遍历Java数组，甚至`iterateFibonacci()`的性能也相当不错。让我们尝试将此与直接使用Java运行此Java类进行比较。以下是输出：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see that the performance of Ruby is on par with running Java directly.
    TruffleRuby is one of the best-performing Ruby runtimes. TruffleRuby is in the
    experimental phase, while writing this book; for the latest information, refer
    to [https://www.graalvm.org/reference-manual/ruby/](https://www.graalvm.org/reference-manual/ruby/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Ruby的性能与直接运行Java相当。TruffleRuby是性能最好的Ruby运行时之一。TruffleRuby处于实验阶段，在撰写本书时；有关最新信息，请参阅[https://www.graalvm.org/reference-manual/ruby/](https://www.graalvm.org/reference-manual/ruby/)。
- en: One of the biggest advantages of using Ruby is RubyGems. Ruby has a vast library,
    which the developer community has built over a period of time. All Gems are hosted
    in https://rubygems.org/. With GraalVM Polyglot, this opens up a huge opportunity
    to use these gems in Java or any other language, supported by GraalVM. To illustrate
    this, let's use a gem in a Java program. There is a gem called math_engine ([https://rubygems.org/gems/math_engine](https://rubygems.org/gems/math_engine)).
    This has a very interesting method to evaluate complex mathematical expressions.
    Let's assume that we are building a complex algebra calculator that can be used
    to evaluate complex expressions. Let's use this gem in a Ruby program, and invoke
    it from Java.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ruby 最大的优点之一是 RubyGems。Ruby 拥有一个庞大的库，这是开发者社区在一段时间内构建的。所有宝石都托管在 https://rubygems.org/。借助
    GraalVM Polyglot，这为在 Java 或任何其他由 GraalVM 支持的语言中使用这些宝石开辟了巨大的机会。为了说明这一点，让我们在一个 Java
    程序中使用一个宝石。有一个名为 math_engine 的宝石（[https://rubygems.org/gems/math_engine](https://rubygems.org/gems/math_engine)）。它有一个非常有趣的方法来评估复杂的数学表达式。假设我们正在构建一个可以用来评估复杂表达式的复杂代数计算器。让我们在一个
    Ruby 程序中使用这个宝石，并从 Java 中调用它。
- en: 'Let''s first install the gem. To install the gem, let''s use Bundler (https://bundler.io/).
    Bundler is a package manager (equivalent to npm in Node.js). To install Bundler,
    use the gem install command. The following is the output of installing Bundler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装宝石。为了安装宝石，让我们使用 Bundler（https://bundler.io/）。Bundler 是一个包管理器（在 Node.js
    中相当于 npm）。要安装 Bundler，请使用 gem install 命令。以下是安装 Bundler 的输出：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s now create a Gemfile. Bundler uses the configuration in a Gemfile to
    install all the packages/gems. (This is equivalent to package.json in npm.) Here
    is the source of the Gemfile:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个 Gemfile。Bundler 使用 Gemfile 中的配置来安装所有包/宝石。（这相当于 npm 中的 package.json。）以下是
    Gemfile 的源代码：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are providing the source of the Gem repository and specifying the gems that
    depend on our Ruby module. Let's now run Bundler to install these gems. (The bundle
    install command should be executed in the folder where we have the Ruby program
    and Gemfile.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了 Gem 仓库的源代码，并指定了依赖于我们 Ruby 模块的宝石。现在让我们运行 Bundler 来安装这些宝石。（应该在我们有 Ruby 程序和
    Gemfile 的文件夹中执行 bundle install 命令。）
- en: 'The bundle install command will install all the gems. Let''s now use the math_engine
    gem, and define a method called eval() in Ruby that takes in the expression, evaluates
    it, and returns the result:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: bundle install 命令将安装所有宝石。现在让我们使用 math_engine 宝石，并在 Ruby 中定义一个名为 eval() 的方法，该方法接受表达式，评估它，并返回结果：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding source code, we are exporting the method using Polyglot.export_method(),
    so that it can be accessed by other languages. Let's now call this eval() method
    from a Java program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的源代码中，我们使用 Polyglot.export_method() 导出方法，以便其他语言可以访问它。现在让我们从一个 Java 程序中调用这个
    eval() 方法。
- en: 'The following is the Java source code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 Java 源代码：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the previous Java code, we are using the Context object to load the Ruby
    runtime and our Ruby program. We are then binding the eval() method and executing
    it with the passed expression. The value is then captured and converted to a string
    for printing. In the main() method, we are passing a complex mathematical expression.
    Let''s now compile and run this Java code. The following is the output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Java 代码中，我们使用 Context 对象来加载 Ruby 运行时和我们的 Ruby 程序。然后我们将 eval() 方法绑定并使用传递的表达式执行它。然后捕获值并将其转换为字符串以打印。在
    main() 方法中，我们传递一个复杂的数学表达式。现在让我们编译并运行这段 Java 代码。以下是输出：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first output comes from Ruby put_s() and the next output is coming from
    Java. This opens up a huge opportunity to use the vast library of gems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出来自 Ruby 的 put_s()，下一个输出来自 Java。这为使用大量宝石库开辟了巨大的机会。
- en: Understanding TruffleRuby Vs CRuby Vs JRuby
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 TruffleRuby 与 CRuby 与 JRuby 的区别
- en: Ruby has a lot of implementations on the market. JRuby and CRuby are two popular
    implementations of Ruby.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 在市场上有很多实现。JRuby 和 CRuby 是 Ruby 的两种流行实现。
- en: 'JRuby is the Ruby programming language implemented in Java. CRuby is the Ruby
    programming language implemented in C. The following diagram shows the high-level
    compilation pipeline of JRuby and CRuby. JRuby is one of the highest-performing
    implementations of Ruby, as it brings in the optimizations and JIT compilation.
    JRuby also does not have a global interpreter lock, like in CRuby, and this allows
    concurrent execution, and hence is faster. However, JRuby starts slow but performs
    better over a period of time:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JRuby是用Java实现的Ruby编程语言。CRuby是用C实现的Ruby编程语言。以下图表显示了JRuby和CRuby的高级编译管道。JRuby是Ruby性能最高的实现之一，因为它引入了优化和即时编译。JRuby也没有像CRuby那样的全局解释器锁，这允许并发执行，因此速度更快。然而，JRuby启动较慢，但随时间推移性能更佳：
- en: '![Figure 9.4 – JRuby and CRuby compilation pipeline'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – JRuby和CRuby编译管道'
- en: '](img/B16878_Figure_9.4.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_9.4.jpg)'
- en: Figure 9.4 – JRuby and CRuby compilation pipeline
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – JRuby和CRuby编译管道
- en: TruffleRuby outperforms JRuby and CRuby. Please refer to [https://www.graalvm.org/ruby/](https://www.graalvm.org/ruby/)
    for more detailed optcarrot and Rubycon benchmark results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: TruffleRuby的性能优于JRuby和CRuby。请参阅[https://www.graalvm.org/ruby/](https://www.graalvm.org/ruby/)以获取更详细的optcarrot和Rubycon基准测试结果。
- en: Understanding GraalWasm – the WASM Truffle interpreter
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GraalWasm – WASM Truffle解释器
- en: GraalVM provides an interpreter and compiler for WASM code called GraalWasm.
    GraalWasm opens up possibilities of building polyglot web applications that perform
    close to natively. Before we get into the details of GraalWasm, let's have a quick
    overview of WASM.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM为WASM代码提供了一个解释器和编译器，称为GraalWasm。GraalWasm开辟了构建接近本地性能的多语言Web应用程序的可能性。在我们深入了解GraalWasm之前，让我们快速概述一下WASM。
- en: Understanding WASM
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 理解WASM
- en: '**WASM** is a binary format that can run on most modern browsers at near-native
    speeds. Web applications have become more and more sophisticated and demand a
    high-performance, near-native experience. JavaScript can only get to a certain
    level, and we have seen a lot of very good applications built on JavaScript that
    provide almost native experience. WASM augments JavaScript and other technologies
    to allow us to compile C, C++, and Rust programs on the web. The following figure
    shows a very simple pipeline of building WASM applications:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**WASM**是一种可以在大多数现代浏览器上以接近本地速度运行的二进制格式。Web应用程序变得越来越复杂，需要高性能和接近本地的体验。JavaScript只能达到一定水平，我们已经看到了许多基于JavaScript的非常好的应用程序，它们提供了几乎本地的体验。WASM增强了JavaScript和其他技术，使我们能够在Web上编译C、C++和Rust程序。以下图显示了构建WASM应用程序的非常简单的管道：'
- en: '![Figure 9.5 – WASM compilation pipeline flow'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – WASM编译管道流程'
- en: '](img/B16878_Figure_9.5.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_9.5.jpg)'
- en: Figure 9.5 – WASM compilation pipeline flow
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – WASM编译管道流程
- en: In the preceding figure, we can see how C/C++ code can be compiled to WASM using
    Emscripten, and it coexists with the other web technologies and runs on web browsers.
    Both JavaScript and WASM execute logic on the browser. The main difference is
    WASM is delivered as a binary that is already optimized at compile time. There
    is no need for abstract syntax trees and type specializations and speculations
    (refer to the *Exploring the Truffle interpreter/compiler pipeline* section in
    [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An Overview*,
    to understand more about AST and speculative optimization).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到如何使用Emscripten将C/C++代码编译成WASM，并且它与其他Web技术共存，在浏览器上运行。JavaScript和WASM都在浏览器上执行逻辑。主要区别在于WASM是以编译时已经优化过的二进制形式交付的。不需要抽象语法树和类型特化和推测（参考[*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)中的*探索Truffle解释器/编译器管道*部分，*Truffle
    – 概述*，以了解更多关于AST和推测优化）。
- en: This is one of the reasons why WASM has a smaller footprint and faster performance.
    Modern web application architectures leverage WASM to perform more advanced computational
    logic in the browser, while JavaScript is used to run the user interface and simple
    application logic. GraalWasm opens up even more possibilities by bringing in polyglot
    interoperability and embedding. Let's explore that in the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是WASM具有更小体积和更快性能的原因之一。现代Web应用程序架构利用WASM在浏览器中执行更高级的计算逻辑，而JavaScript用于运行用户界面和简单的应用程序逻辑。通过引入多语言互操作性和嵌入，GraalWasm开辟了更多可能性。让我们在下一节中探讨这一点。
- en: Understanding GraalWasm architecture
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解GraalWasm架构
- en: 'Let''s understand how GraalWasm works. The following figure shows the compilation
    pipeline for GraalWasm. The diagram does not capture all the details. Refer to
    the *Exploring the Truffle interpreter/compiler pipeline* section in [*Chapter
    6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An Overview*,
    for a more detailed explanation on how Truffle interpreters and Graal JIT execute
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 GraalWasm 的工作原理。以下图显示了 GraalWasm 的编译管道。该图并未捕捉到所有细节。请参考 [*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)
    中的 *探索 Truffle 解释器/编译器管道* 部分，*Truffle – 概述*，以获取关于 Truffle 解释器和 Graal JIT 如何执行代码的更详细解释：
- en: '![Figure 9.6 – GraalWasm compilation/interpreter pipeline'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6 – GraalWasm 编译/解释器管道'
- en: '](img/B16878_Figure_9.6.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_9.6.jpg)'
- en: Figure 9.6 – GraalWasm compilation/interpreter pipeline
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – GraalWasm 编译/解释器管道
- en: C/C++ source code is compiled using Emscripten (`emcc`). Emscripten is a drop-in
    replacement for `gcc` or Clang, built on LLVM. Emscripten compiles the source
    to a WASM (`.wasm`) file. The GraalWasm interpreter creates the AST and performs
    optimizations. There is not much optimization that is required, as the WASM is
    generated from a strongly typed language, and so already a lot of optimization
    is performed. Since the WASM format is a sequence of instructions, to reduce the
    memory footprint, GraalWasm builds an AST, where each node is pointing to a block
    in WASM (this is called the WASM block node), instead of creating a node for each
    instruction. The GraalWasm interpreter then optimizes the AST and passes it to
    Graal for execution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 源代码使用 Emscripten (`emcc`) 进行编译。Emscripten 是基于 LLVM 的 `gcc` 或 Clang 的替代品。Emscripten
    将源代码编译成 WASM (`.wasm`) 文件。GraalWasm 解释器创建 AST 并执行优化。由于 WASM 是从强类型语言生成的，因此不需要太多优化。由于
    WASM 格式是一系列指令，为了减少内存占用，GraalWasm 构建一个 AST，其中每个节点都指向 WASM 中的一个块（这被称为 WASM 块节点），而不是为每条指令创建一个节点。然后
    GraalWasm 解释器优化 AST 并将其传递给 Graal 以执行。
- en: Installing and running GraalWasm
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和运行 GraalWasm
- en: 'GraalWasm is an optional component; it does not come with the GraalVM installation.
    We have to install it using Graal Updater. To install GraalWasm, we can use the
    following command to download and install it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GraalWasm 是一个可选组件；它不包含在 GraalVM 安装中。我们必须使用 Graal Updater 来安装它。要安装 GraalWasm，我们可以使用以下命令来下载和安装它：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's now build a WASM binary and run it with GraalWasm. To compile C code to
    WASM, we have to install `emcc`. The following section walks through the steps
    to install `emcc`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个 WASM 二进制文件，并使用 GraalWasm 运行它。要将 C 代码编译成 WASM，我们必须安装 `emcc`。以下部分将介绍安装
    `emcc` 的步骤。
- en: Installing Emscripten (emcc)
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Emscripten (emcc)
- en: 'Emscripten is installed using Emscripten SDK. We can download the SDK from
    the Git repository. Let''s execute the following command on a terminal:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 使用 Emscripten SDK 进行安装。我们可以从 Git 仓库下载 SDK。让我们在终端执行以下命令：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This downloads `emsdk`, which also has all the required installation scripts.
    `git clone` will create an `emsdk` directory. Let''s move that to the `cd emsdk`
    folder and perform `git pull` to make sure it is up to date. We can install the
    `emcc` toolchain by executing the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载 `emsdk`，它还包含所有所需的安装脚本。`git clone` 将创建一个 `emsdk` 目录。让我们将其移动到 `cd emsdk`
    文件夹并执行 `git pull` 以确保它是最新的。我们可以通过执行以下命令来安装 `emcc` 工具链：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will download all the required toolchains and SDKs. Once it''s downloaded,
    we need to activate `emsdk` and then set the environment, using the following
    commands in sequence:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载所有所需的工具链和 SDK。一旦下载完成，我们需要激活 `emsdk` 并然后设置环境，按照以下命令顺序执行：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once all of these commands are successfully executed, we should be able to check
    whether Emscripten is installed by running the `emcc` command on the terminal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些命令都成功执行，我们应该能够通过在终端运行 `emcc` 命令来检查 Emscripten 是否已安装。
- en: 'Now let''s build a WASM of the following C code. This is a slight modification
    of the code that we have already used in the *Exploring LLVM interoperability*
    section:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建以下 C 代码的 WASM。这是对我们在 *探索 LLVM 互操作性* 部分中已经使用的代码的轻微修改：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have defined a method that calculates Fibonacci numbers, sums them up, and
    returns the sum of the Fibonacci numbers. In the following code snippet of the
    `main()` method, we are looping through and calling this `fib()` method in interactions,
    just to test the method, and printing the total and time taken for executing each
    iteration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个计算斐波那契数的方法，将它们相加，并返回斐波那契数的总和。在以下 `main()` 方法的代码片段中，我们正在循环调用这个 `fib()`
    方法进行交互，只是为了测试这个方法，并打印每次迭代的总时间和执行时间：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s compile this code with `emcc` with the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令使用 `emcc` 编译此代码：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the previous command, the `-o` option is used to specify the name of the
    output file; in this case, `fibonacci.wasm` is the binary file that is generated,
    after successful compilation. Let''s run this file with GraalWasm by executing
    the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，`-o` 选项用于指定输出文件的名称；在这种情况下，`fibonacci.wasm` 是在成功编译后生成的二进制文件。让我们通过执行以下命令来运行这个文件：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding command, we used `--Builtins` to pass the `wasi_snapshot_preview1`
    module that the Emscripten toolchain requires. The following shows the output
    after executing:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了 `--Builtins` 来传递 Emscripten 工具链所需的 `wasi_snapshot_preview1` 模块。以下是在执行后的输出：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can see the output generated instantly and is quite fast for the number of
    Fibonacci numbers we wanted to create and add up. Also, we can see a huge performance
    improvement from 6,519 ms to 247 ms.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到生成的输出，对于我们要创建和相加的斐波那契数的数量来说，速度相当快。此外，我们还可以看到从 6,519 毫秒到 247 毫秒的巨大性能提升。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went into the details of how LLVM, Ruby, and WASM, Java
    on Truffle and Ruby interpreters are implemented on Truffle. We also explored
    the polyglot interoperability features that these languages provide, along with
    coding examples. We understood the differences in the way each of these languages
    is interpreted. The chapter provided a hands-on walkthrough of how to run code
    and write polyglot applications in these various languages.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了如何在 Truffle 上实现 LLVM、Ruby、WASM、Java 以及 Ruby 解释器。我们还探讨了这些语言提供的多语言互操作性功能，以及编码示例。我们了解了每种语言解释方式的不同。本章提供了在实际这些各种语言中运行代码和编写多语言应用程序的实战指南。
- en: You should be able to use this knowledge to write polyglot applications on GraalVM.
    Though most of these languages are still in the experimental phase at the time
    of writing the book, they provide great opportunities to build high-performance
    polyglot applications. In the next chapter, we will see how the new frameworks
    such as Quarkus and Micronaut implement Graal for most optimum microservices architecture.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够使用这些知识在 GraalVM 上编写多语言应用程序。尽管在撰写本书时，这些语言中的大多数仍然处于实验阶段，但它们提供了构建高性能多语言应用程序的绝佳机会。在下一章中，我们将看到新的框架，如
    Quarkus 和 Micronaut，如何实现 Graal 以实现最优化微服务架构。
- en: Questions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Sulong?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sulong 是什么？
- en: What is the LLVM managed mode of execution?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM 执行的托管模式是什么？
- en: How does TruffleRuby implement C extensions?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TruffleRuby 如何实现 C 扩展？
- en: What is WASM?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WASM 是什么？
- en: What is `emcc`?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emcc` 是什么？'
- en: Further reading
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'GraalVM Enterprise Edition: [https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 企业版：[https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html)
- en: 'GraalVM language reference: [https://www.graalvm.org/reference-manual/languages/](https://www.graalvm.org/reference-manual/languages/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 语言参考：[https://www.graalvm.org/reference-manual/languages/](https://www.graalvm.org/reference-manual/languages/)
- en: 'GraalWasm announcement blog post: [https://medium.com/graalvm/announcing-graalwasm-a-webassembly-engine-in-graalvm-25cd0400a7f2](https://medium.com/graalvm/announcing-graalwasm-a-webassembly-engine-in-graalvm-25cd0400a7f2)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalWasm 宣布博客文章：[https://medium.com/graalvm/announcing-graalwasm-a-webassembly-engine-in-graalvm-25cd0400a7f2](https://medium.com/graalvm/announcing-graalwasm-a-webassembly-engine-in-graalvm-25cd0400a7f2)
- en: '*WASM engine in GraalVM: Introducing Oracle''s GraalWasm*: [https://jaxenter.com/graalvm-webassembly-graalwasm-165111.html](https://jaxenter.com/graalvm-webassembly-graalwasm-165111.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GraalVM 中的 WASM 引擎：介绍 Oracle 的 GraalWasm*：[https://jaxenter.com/graalvm-webassembly-graalwasm-165111.html](https://jaxenter.com/graalvm-webassembly-graalwasm-165111.html)'
