- en: Chapter 2. JavaServer Faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover **JavaServer Faces** (**JSF**), the standard
    component framework of the Java EE platform. Java EE 7 includes JSF 2.2, the latest
    version of JSF. JSF relies a lot on convention over configuration. If we follow
    JSF conventions, then we don't need to write a lot of configuration. In most cases,
    we don't need to write any configuration at all. This fact, combined with the
    fact that `web.xml` has been optional since Java EE 6, means that in many cases,
    we can write complete web applications without having to write a single line of
    XML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JSF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.0 introduced a number of enhancements to make JSF application development
    easier. In the following few sections, we will explain some of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Readers unfamiliar with the earlier versions of JSF may not understand the following
    few sections completely. Don't worry, everything will be perfectly clear by the
    end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One notable difference between the modern versions of JSF and the earlier versions
    is that Facelets is now the preferred view technology. The earlier versions of
    JSF used JSP as their default view technology. Since JSP technology predates JSF,
    sometimes using JSP with JSF felt unnatural or created problems. For example,
    the lifecycle of JSPs is different from the lifecycle of JSFs; this mismatch introduced
    some problems for JSF 1.x application developers.
  prefs: []
  type: TYPE_NORMAL
- en: JSF was designed from the beginning to support multiple view technologies. To
    take advantage of this capability, Jacob Hookom wrote a view technology specifically
    for JSF. He named his view technology **Facelets**. Facelets was so successful
    that it became a de facto standard for JSF. The JSF expert group recognized Facelets'
    popularity and made it the official view technology for JSF in Version 2.0 of
    the JSF specification.
  prefs: []
  type: TYPE_NORMAL
- en: Optional faces-config.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Legacy J2EE applications suffered what some would have considered being excessive
    XML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE 5 took some measures to reduce the XML configuration considerably. Java
    EE 6 reduced the required configuration even further, making the `faces-config.xml`
    JSF configuration file optional in JSF 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: In JSF 2.0 and newer, JSF managed beans can be configured via the `@ManagedBean`
    annotation, obviating the need to configure them in `faces-config.xml`. Java EE
    6 introduced the **Contexts and Dependency Injection** (**CDI**) API, which provides
    an alternative way to implement the functionality that was typically implemented
    with JSF managed beans. As of JSF 2.2, CDI named beans are preferred over JSF
    managed beans.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there is a convention for JSF navigation. If the value of the
    `action` attribute of a JSF 2 command link or command button matches the name
    of a facelet (minus the XHTML extension), then by convention, the application
    will navigate to the facelet that matches the action name. This convention allows
    us to avoid having to configure an application's navigation in `faces-config.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: For many modern JSF applications, `faces-config.xml` is completely unnecessary
    as long as the established JSF conventions are followed.
  prefs: []
  type: TYPE_NORMAL
- en: Standard resource locations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSF 2.0 introduced standard resource locations. Resources are the artifacts
    that a page or JSF component needs to render properly, such as CSS style sheets,
    JavaScript files, and images.
  prefs: []
  type: TYPE_NORMAL
- en: In JSF 2.0 and newer, resources can be placed in a subdirectory under a folder
    called `resources` either at the root of the WAR file or under `META-INF`. By
    convention, JSF components know that they can retrieve resources from one of these
    two locations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid cluttering the resources directory, resources are typically
    placed in a subdirectory. This subdirectory is referred to from the `library`
    attribute of JSF components.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could place a CSS style sheet called `styles.css` under `/resources/css/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our JSF pages, we can retrieve this CSS file using the `<h:outputStylesheet>`
    tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `library` attribute must match the subdirectory where our style
    sheet is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can have a JavaScript file, `somescript.js`, under `/resources/scripts/`
    and we can access it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have an image, `logo.png`, under `/resources/images/` and we can access
    this resource with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that in each case, the value of the `library` attribute matches the corresponding
    subdirectory name under the `resources` directory and the value of the `name`
    attribute matches the resource's filename.
  prefs: []
  type: TYPE_NORMAL
- en: Developing our first JSF application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate basic JSF concepts, we will develop a simple application consisting
    of two Facelets pages and a single CDI named bean.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in this chapter''s introduction, the default view technology
    for JSF 2 is Facelets. Facelets need to be written using standard XML. The most
    popular way of developing Facelets pages is to use XHTML in conjunction with JSF-specific
    XML namespaces. The following example shows how a typical Facelets page looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates how our example page is rendered in the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facelets](img/6886EN_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot, of course, was taken after entering some data in every
    text field; originally, each text field was blank.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much any Facelets JSF page will include the two namespaces illustrated
    in the example. The first namespace (``) is for the tags that render HTML components;
    by convention, the prefix `h` (for HTML) is used when using this tag library.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Tip` ``'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`` `![Facelets](img/6886EN_02_02.jpg)` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Project stages` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`` `To avoid the situation described in the previous paragraph, JSF 2.0 introduced
    the concept of **project stages**.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `The following project stages are defined in JSF 2:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Production` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `Development` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `UnitTest` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `SystemTest` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`` `With GlassFish, we can do this by logging in to the web console, navigating
    to **JNDI** | **Custom Resources**, and then clicking on the **New...** button.
    The page that appears looks as shown in the following screenshot:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `![Project stages](img/6886EN_02_03.jpg)` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `In the resulting page, we need to enter the following information:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JNDI Name** | `javax.faces.PROJECT_STAGE` |'
  prefs: []
  type: TYPE_TB
- en: '| **Resource Type** | `java.lang.String` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`` `After entering the values, we need to add a new property with a name of
    the stage and a value corresponding to the project stage we wish to use.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Setting the project stage allows us to perform some logic only if we are
    running the program in a specific stage. For instance, in one of our named beans,
    we could have code that looks as follows:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`` `![Project stages](img/6886EN_02_04.jpg)` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `In the default Production stage, this error message is not displayed on
    the page, leaving us confused as to why our page navigation doesn''t seem to work.`
    ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Validation` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`` `JSF provides built-in input validation capabilities.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`` `![Validation](img/6886EN_02_05.jpg)` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Again, the default message and style can be overridden; we will cover how
    to do this later in this chapter in the *Customizing JSF''s default messages*
    section.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| Validation tag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateBean>` | Bean validation allows us to validate named bean values
    using annotations in our named beans without having to add validators to our JSF
    tags. These tags allow us to fine-tune Bean Validation if necessary. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateDoubleRange>` | This tag validates that the input is a valid
    `Double` value between the two values specified by the tag''s `minimum` and `maximum`
    attributes, inclusive. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateLength>` | This tag validates that the input''s length is between
    the values specified by the tag''s `minimum` and `maximum` values, inclusive.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateLongRange>` | This tag validates that the input is a valid `Long`
    value between the values specified by the tag''s `minimum` and `maximum` attributes,
    inclusive. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateRegex>` | This tag validates that the input matches a regular
    expression pattern specified in the tag''s `pattern` attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateRequired>` | This tag validates that the input is not empty.
    This tag is equivalent to setting the `required` attribute to `true` in the parent
    input field. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`` `If we wish to take advantage of Bean Validation, all we need to do is annotate
    the desired field with the appropriate Bean Validation annotation, without having
    to explicitly use a JSF validator.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Note` ``'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Grouping components` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Form submission` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Note` ``'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`` `Even though the label for the button reads **Save**, in our simple example
    clicking on the button won''t actually save any data.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Named beans` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`` `There are two types of JavaBeans that can interact with JSF pages: JSF
    managed beans and CDI named beans. JSF managed beans have been around since the
    first version of the JSF specification and can be used only in a JSF context.
    CDI named beans were introduced in Java EE 6 and can interoperate with other Java
    EE APIs such as Enterprise JavaBeans. For these reasons, CDI named beans are preferred
    over JSF managed beans.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Named beans always have a scope. A named bean scope defines the lifespan
    of the bean, and it is defined by a class-level annotation. The following table
    lists all valid named bean scopes:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '| Named bean scope annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@ApplicationScoped` | The same instance of the application scoped named
    beans are available to all of our application''s clients. If one client modifies
    the value of an application scoped managed bean, the change is reflected across
    all clients. |'
  prefs: []
  type: TYPE_TB
- en: '| `@SessionScoped` | An instance of each session scoped named bean is assigned
    to each of our application''s clients. A session scoped named bean can be used
    to hold client-specific data across requests. |'
  prefs: []
  type: TYPE_TB
- en: '| `@RequestScoped` | Request scoped named beans only live through a single
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Dependent` | Dependent scoped named beans are assigned the same scope as
    the bean they are injected into. This is the default scope if none is specified.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@ConversationScoped` | The conversation scope can span multiple requests
    and is typically shorter than the session scope. |'
  prefs: []
  type: TYPE_TB
- en: '`` `Navigation` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Tip` ``'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`` `**Does the same page reload when you click on a button or link that should
    navigate to another page?**` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`` `![Navigation](img/6886EN_02_06.jpg)` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]`# Custom data validation    In addition to providing standard validators,
    JSF allows us to create custom validators. This can be done in two ways: by creating
    a custom validator class or by adding validation methods to our named beans.    ##
    Creating custom validators    In addition to the standard validators, JSF allows
    us to create custom validators by creating a Java class that implements the `javax.faces.validator.Validator`
    interface.    The following class implements an e-mail validator, which we will
    use to validate the e-mail text input field in our customer data entry screen.    [PRE44]    The
    `@FacesValidator` annotation registers our class as a JSF custom validator class.
    The value of its `value` attribute is the logical name that JSF pages can use
    for reference.    As can be seen in the example, the only method we need to implement
    when implementing the `Validator` interface is a method called `validate()`. This
    method takes three parameters: an instance of `javax.faces.context.FacesContext`,
    an instance of `javax.faces.component.UIComponent`, and an object. Typically,
    application developers only need to be concerned with the last two. The second
    parameter is the component whose data we are validating, and the third parameter
    is the actual value. In the example, we cast `uiComponent` to `javax.faces.component.html.HtmlInputText`;
    in this way, we get access to its `getLabel()` method, which we can use as part
    of the error message.    If the entered value is not in a valid e-mail address
    format, a new instance of `javax.faces.application.FacesMessage` is created, passing
    the error message to be displayed in the browser as its constructor parameter.
    We then throw a new exception as `javax.faces.validator.ValidatorException`. The
    error message is then displayed in the browser.    ### Tip    **Apache Commons
    Validator**    Our custom JSF validator uses the Apache Commons Validator to do
    the actual validation. This library includes many common validations such as dates,
    credit card numbers, ISBN numbers, and e-mails. When implementing a custom validator,
    it is worth investigating if this library already has a validator that we can
    use.    In order to use our validator in our page, we need to use the `<f:validator>`
    JSF tag. The following Facelets page is a modified version of the customer data
    entry screen. This version uses the `<f:validator>` tag to validate e-mails.    [PRE45]    Notice
    that the value of the `validatorId` attribute of `<f:validator>` matches the `value`
    attribute of the `@FacesValidator` annotation in our custom validator.    After
    writing our custom validator and modifying our page to take advantage of it, we
    can see our validator in action as shown in the following screenshot:  ![Creating
    custom validators](img/6886EN_02_07.jpg)  ## Validator methods    Another way
    we can implement custom validation is by adding validation methods to one or more
    of the application''s named beans. The following Java class illustrates the use
    of validator methods for JSF validation:    [PRE46]    In this example, the class
    contains only the validator method. We can give our validator method any name
    we want; however, its return value must be void, and it must take the three parameters
    illustrated in the example, in that order. In other words, except for the method
    name, the signature of a validator method must be identical to the signature of
    the `validate()` method defined in the `javax.faces.validator.Validator` interface.    As
    we can see, the body of our validator method is nearly identical to the body of
    our custom validator''s `validate()` method. We check the value entered by the
    user to make sure that it contains only alphabetic characters and/or spaces. If
    it does not, then we throw `ValidatorException`, passing an instance of `FacesMessage`
    containing an appropriate `String` error message.    ### Tip    **StringUtils**    In
    the example, we used `org.apache.commons.lang.StringUtils` to perform the actual
    validation logic. In addition to the method used in the example, this class contains
    several methods to verify whether a string is numeric or alphanumeric. This class,
    part of the Apache `commons-lang` library, is very useful when writing custom
    validators.    Since every validator method must be in a named bean, we need to
    make sure that the class containing our validator method is annotated with the
    `@Named` annotation, as illustrated in our example.    The last thing we need
    to do in order to use our validator method is to bind it to our component via
    the tag''s `validator` attribute. The code to do so is as follows:    [PRE47]    Since
    neither the first name nor the last name fields would accept anything other than
    alphabetic characters or spaces, we added our custom validator method to both
    of these fields.    Notice that the value of the `validator` attribute of the
    `<h:inputText>` tag is a JSF expression language expression that uses the default
    name for the bean containing our validation method. `alphaValidator` is the name
    of our bean, and `validateAlpha` is the name of our validator method.    After
    modifying our page to use our custom validator, we can now see it in action as
    follows:  ![Validator methods](img/6886EN_02_08.jpg)  Note how for the **First
    Name** field both our custom validator message and the standard length validator
    were executed.    The advantage of implementing validator methods is that you
    do not need the overhead of creating a whole class just for a single validator
    method. (Our example does just that, but in many cases, validator methods are
    added to an existing named bean containing other methods.) The disadvantage of
    validator methods is that each component can only be validated by a single validator
    method. When using validator classes, several `<f:validator>` tags can be nested
    inside the tag to be validated; therefore, multiple validations, both custom and
    standard, can be done to the field.    # Customizing JSF''s default messages    As
    we mentioned earlier, it is possible to customize the style (font, color, text,
    and so on) of JSF default validation messages. Additionally, it is possible to
    modify the text of the default JSF validation messages. In the following sections,
    we will explain how to modify error message formatting and text.    ## Customizing
    message styles    Customizing message styles can be done via **Cascading Style
    Sheets** (**CSS**). This can be accomplished using the `<h:message>` style or
    the `styleClass` attributes. The `style` attribute is used when we want to declare
    the CSS style inline. The `styleClass` attribute is used when we want to use a
    predefined style in a CSS style sheet or inside a `<style>` tag in our page.    The
    following markup illustrates the use of the `styleClass` attribute to alter the
    style of error messages. It is a modified version of the input page that we saw
    in the previous section.    [PRE48]    The only difference between this page and
    the previous one is the use of the `styleClass` attribute of the `<h:messages>`
    tag. As mentioned earlier, the value of the `styleClass` attribute must match
    the name of a CSS style defined in a cascading style sheet that our page can access.    In
    our case, we defined a CSS style in `style.css` for messages as follows:    [PRE49]    We
    then used this style as the value of the `styleClass` attribute of our `<h:messages>`
    tag.    The following screenshot illustrates how the validation error messages
    look after we have implemented this change:  ![Customizing message styles](img/6886EN_02_09.jpg)  In
    this particular case, we just set the color of the error message text to red,
    but we are only limited by CSS capabilities in setting the style of the error
    messages.    ## Customizing message text    Sometimes it is desirable to override
    JSF''s default validation errors. Default validation errors are defined in a resource
    bundle called `Messages.properties`. This file can be found inside the `javax.faces.jar`
    file under `[glassfish installation directory]/glassfish/modules`. It can be found
    under the `javax/faces` folder inside the JAR file. The file contains several
    messages, but we are only interested in validation errors at this point. The default
    validation error messages are defined as follows:    [PRE50]    In order to override
    the default error messages, we need to create our own resource bundle using the
    same keys used in the default one, but altering the values to suit our needs.
    The following is a very simple customized resource bundle for our application:    [PRE51]    In
    this resource bundle, we override the error message for when the value entered
    for a field validated by the `<f:validateLength>` tag is less than the allowed
    minimum. In order to let our application know that we have a custom resource bundle
    for message properties, we need to modify the application''s `faces-config.xml`
    file as follows:    [PRE52]    As we can see, the only thing we need to do to
    the application''s `faces-config.xml` file is to add a `<message-bundle>` element
    indicating the name and location of the resource bundle containing our custom
    messages.    ### Note    A custom error message text definition is one of the
    few cases in which we still need to define a `faces-config.xml` file for modern
    JSF applications. However, note how simple our `faces-config.xml` file is; it
    is a far cry from a typical `faces-config.xml` file for JSF 1.x, which typically
    contains named bean definitions, navigation rules, JSF validator definitions,
    and so on.    After adding our custom message resource bundle and modifying the
    application''s `faces-config.xml` file, we can see our custom validation message
    in action, as shown in the following screenshot:  ![Customizing message text](img/6886EN_02_10.jpg)  As
    can be seen in the screenshot, if we haven''t overridden a validation message,
    the default will still be displayed. In our resource bundle, we only overrode
    the minimum length validation error message; therefore, our custom error message
    is shown for the **First Name** text field. Since we didn''t override the error
    messages for the other standard JSF validators, the default error message is shown
    for each one of them. The e-mail validator is the custom validator we developed
    previously in this chapter. Since it is a custom validator, its error message
    is not affected.    # Ajax-enabling JSF applications    Early versions of JSF
    did not include native Ajax support. Custom JSF library vendors were forced to
    implement Ajax in their own way. Unfortunately, this state of events introduced
    incompatibilities between JSF component libraries. JSF 2.0 standardized Ajax support
    by introducing the `<f:ajax>` tag.    The following page illustrates the typical
    usage of the `<f:ajax>` tag:    [PRE53]    After deploying our application, our
    page renders as illustrated in the following screenshot:  ![Ajax-enabling JSF
    applications](img/6886EN_02_11.jpg)  This example page illustrates two uses of
    the `<f:ajax>` tag. At the top of the page, we have used this tag for implementing
    a typical Ajax Echo example, in which we have an `<h:outputText>` component updating
    itself with the value of an input text component. Any time a character is entered
    into the input field, the value of the `<h:outputText>` component is automatically
    updated.    To implement the functionality described in the previous paragraph,
    we put an `<f:ajax>` tag inside an `<h:inputText>` tag. The value of the `render`
    attribute of the `<f:ajax>` tag must correspond to the ID of a component we wish
    to update after the Ajax request finishes. In our example, we wish to update the
    `<h:outputText>` component with an ID of "`textVal`"; therefore, we will use this
    value for the `render` attribute of our `<f:ajax>` tag.    ### Note    In some
    cases, we may need to render more than one JSF component after an Ajax event finishes;
    in order to accommodate this, we can add several IDs as the value of the `render`
    attribute, and we simply need to separate them by spaces.    The other `<f:ajax>`
    attribute we used in this instance is the `event` attribute. This attribute indicates
    the JavaScript event that triggers the Ajax event. In this particular case, we
    need to trigger the event any time a key is released while a user is typing into
    the input field; therefore, the appropriate event to use is `keyup`.    The following
    table lists all supported JavaScript events:     | Event | Description | | ---
    | --- | | `blur` | The component loses focus. | | `change` | The component loses
    focus, and its value is modified. | | `click` | The component is clicked on. |
    | `dblclick` | The component is double-clicked on. | | `focus` | The component
    gains focus. | | `keydown` | A key is depressed while the component has focus.
    | | `keypress` | A key is pressed or held down while the component has focus.
    | | `keyup` | A key is released while the component has focus. | | `mousedown`
    | The mouse button is depressed while the component has focus. | | `mousemove`
    | The mouse pointer is moved over the component. | | `mouseout` | The mouse pointer
    leaves the component. | | `mouseover` | The mouse pointer is placed over the component.
    | | `mouseup` | The mouse button is released while the component has focus. |
    | `select` | The component''s text is selected. | | `valueChange` | Equivalent
    to `change`; the component loses focus and its value has been modified. |    We
    use the `<f:ajax>` tag once again farther down in the page to Ajax-enable a command
    button component. In this instance, we want to recalculate a value based on the
    value of two input components. In order to have the values on the server updated
    with the latest user input, we used the `execute` attribute of `<f:ajax>`; this
    attribute takes a space-separated list of component IDs to use as input. We then
    use the `render` attribute just as before to specify which components need to
    be re-rendered after the Ajax request finishes.    Notice that we used the `actionListener`
    attribute of `<h:commandButton>`. This attribute is typically used when we don''t
    need to navigate to another page after clicking on the button. The value for this
    attribute is an action listener method we wrote in one of our named beans. Action
    listener methods must return void and take an instance of `javax.faces.event.ActionEvent`
    as their sole parameter.    The named bean for our application looks as follows:    [PRE54]    Notice
    that we didn''t have to do anything special in our named bean to enable Ajax in
    our application. It is all controlled by the `<f:ajax>` tag on the page.    As
    we can see from this example, Ajax-enabling JSF applications is very simple. We
    simply need to use a single tag to Ajax-enable our page, without having to write
    a single line of JavaScript, JSON, or XML.    # JSF 2.2 HTML5 support    HTML
    5 is the latest version of the HTML specification. It includes several improvements
    over the previous version of HTML. JSF 2.2 includes several updates to make JSF
    pages work nicely with HTML5.    ## The HTML5-friendly markup    Through the use
    of pass-through elements, we can develop our pages using HTML 5 tags and also
    treat them as JSF components. To do this, we need to specify at least one of the
    `element` attributes using the `http://xmlns.jcp.org/jsf` namespace. The following
    example demonstrates this approach in action:    [PRE55]    The first thing we
    should notice about this example is the XML namespace prefixed by `jsf` near the
    top of the page. This namespace allows us to add JSF-specific attributes to HTML
    5 pages. When the JSF runtime encounters attributes prefixed by `jsf` in any of
    the tags on the page, it automatically converts the HTML5 tag to the equivalent
    JSF component. JSF-specific tags are the same as in regular JSF pages, except
    that they are prefixed with `jsf`. Therefore, at this point, they should be self-explanatory
    and will not be discussed in detail. Our example will render and behave just like
    the first example in this chapter.    The technique described in this section
    is useful if you have experienced HTML web designers in your team who prefer to
    have full control over the look of the page. The pages are developed using standard
    HTML5 with JSF-specific attributes so that the JSF runtime can manage user input.    If
    your team consists primarily of Java developers with limited CSS/HTML knowledge,
    then it is preferable to develop the web pages for your web application using
    JSF components. HTML 5 introduced several new attributes that didn''t exist in
    the previous versions of HTML. For this reason, JSF 2.2 introduces the ability
    to add arbitrary attributes to JSF components. This JSF/HTML5 integration technique
    is discussed in the next section.    ## Pass-through elements    JSF 2.2 allows
    the definition of any arbitrary attributes (not processed by the JSF engine).
    These attributes are simply rendered as is on the generated HTML displayed in
    the browser. The following example is a new version of an earlier example in this
    chapter, which has been modified to take advantage of the HTML5 pass-through elements:    [PRE56]    The
    first thing we should notice about this example is the addition of the ``id227"
    class="indexterm"/>by the defined prefix for the namespace at the top of the application
    (`p`, in our case). The placeholder HTML attribute simply adds some placeholder
    text to the input fields, which is automatically deleted once the user starts
    typing in the input field (this technique was commonly implemented "by hand" using
    JavaScript before HTML5).``    The following screenshot shows our updated page
    in action:  ![Pass-through elements](img/6886EN_02_12.jpg)  # JSF 2.2 Faces Flows    Faces
    Flows is a new JSF 2.2 feature that defines a scope that can span several pages.
    Flow scoped beans are created when the user enters a flow (a set of web pages)
    and are destroyed when the user leaves the flow.    Faces Flows adopts the convention
    over configuration principle of JSF. The following conventions are typically used
    when developing applications employing Faces Flows:    *   All pages in the flow
    must be placed in a directory with a name that defines the name of the flow *   An
    XML configuration file named after the directory name and suffixed with `-flow`
    must exist inside the directory that contains the pages in the flow (the file
    may be empty, but it must exist) *   The first page in the flow must be named
    after the directory name that contains the flow *   The last page in the flow
    must not be located inside the directory containing the flow and must be named
    after the directory name and suffixed with `-return`    The following screenshot
    illustrates these conventions:  ![JSF 2.2 Faces Flows](img/6886EN_02_13.jpg)  In
    this example, we define a flow named `customerinfo`; by convention, these files
    are inside a directory named `customerinfo`, and the first page of the flow is
    named `customerinfo.xhtml` (there are no restrictions on the names of other pages
    in the flow). When we exit the flow, we navigate to `customerinfo-return.xhtml`,
    which follows the naming convention and takes us out of the flow.    The markup
    for the pages doesn''t illustrate anything we haven''t seen before, so we will
    not show it. All example code is available as part of this book''s code download
    bundle.    All the pages in our example store data in a named bean called `Customer`,
    which has a scope of flow.    [PRE57]    The `@FlowScoped` annotation has a `value`
    attribute that must match the name of the flow that the bean is meant to work
    with (`customerinfo` in this example).    This example creates a wizard-style
    set of pages in which data for a user is entered across several pages in the flow.    On
    the first page, we enter information about the name.  ![JSF 2.2 Faces Flows](img/6886EN_02_14.jpg)  On
    the second page, we enter address information as shown in the following screenshot:  ![JSF
    2.2 Faces Flows](img/6886EN_02_15.jpg)  On the next page, we enter phone number
    information as shown in the following screenshot:  ![JSF 2.2 Faces Flows](img/6886EN_02_16.jpg)  Finally,
    we display a confirmation page as shown in the following screenshot:  ![JSF 2.2
    Faces Flows](img/6886EN_02_17.jpg)  If the user verifies that the information
    is correct, we navigate outside the flow to `customerinfo-return.xhtml`; otherwise,
    we go back to the first page in the flow to allow the user to make any necessary
    corrections.    # Additional JSF component libraries    In addition to the standard
    JSF component libraries, there are a number of third-party JSF tag libraries available.
    The following table lists some of the most popular ones:     | Tag library | Distributor
    | License | URL | | --- | --- | --- | --- | | ICEfaces | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    | | RichFaces | Red Hat/JBoss | LGPL | [http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)
    | | Primefaces | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |    # Summary    In this chapter, we covered how to develop web-based applications
    using JavaServer Faces, the standard component framework for the Java EE platform.
    We covered how to write a simple application by creating pages using Facelets
    as the view technology and CDI named beans. We also covered how to validate user
    input by using JSF''s standard validators and by creating our own custom validators
    or by writing validator methods. Additionally, we covered how to customize standard
    JSF error messages, both the message text and the message style (font, color,
    and so on). Also, we covered how to develop Ajax-enabled JSF pages as well as
    how to integrate JSF and HTML5.    In the next chapter, we will cover how to interact
    with relational databases via the Java Persistence API.[PRE58]``'
  prefs: []
  type: TYPE_NORMAL
