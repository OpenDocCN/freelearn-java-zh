- en: Chapter 2. JavaServer Faces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 JavaServer Faces
- en: In this chapter, we will cover **JavaServer Faces** (**JSF**), the standard
    component framework of the Java EE platform. Java EE 7 includes JSF 2.2, the latest
    version of JSF. JSF relies a lot on convention over configuration. If we follow
    JSF conventions, then we don't need to write a lot of configuration. In most cases,
    we don't need to write any configuration at all. This fact, combined with the
    fact that `web.xml` has been optional since Java EE 6, means that in many cases,
    we can write complete web applications without having to write a single line of
    XML configuration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Java EE 平台的标准组件框架 **JavaServer Faces**（**JSF**）。Java EE 7 包含了 JSF
    2.2，这是 JSF 的最新版本。JSF 非常依赖于约定优于配置。如果我们遵循 JSF 约定，那么我们就不需要编写很多配置。在大多数情况下，我们甚至不需要编写任何配置。这一事实，加上
    `web.xml` 自 Java EE 6 以来一直是可选的，意味着在许多情况下，我们可以编写完整的 Web 应用程序，而无需编写任何一行 XML 配置。
- en: Introduction to JSF
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 简介
- en: JSF 2.0 introduced a number of enhancements to make JSF application development
    easier. In the following few sections, we will explain some of these features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0 引入了许多增强功能，使得 JSF 应用程序开发更加容易。在接下来的几节中，我们将解释其中的一些特性。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Readers unfamiliar with the earlier versions of JSF may not understand the following
    few sections completely. Don't worry, everything will be perfectly clear by the
    end of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉 JSF 早期版本的读者来说，可能无法完全理解以下几节。不用担心，到本章结束时，一切都会非常清晰。
- en: Facelets
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facelets
- en: One notable difference between the modern versions of JSF and the earlier versions
    is that Facelets is now the preferred view technology. The earlier versions of
    JSF used JSP as their default view technology. Since JSP technology predates JSF,
    sometimes using JSP with JSF felt unnatural or created problems. For example,
    the lifecycle of JSPs is different from the lifecycle of JSFs; this mismatch introduced
    some problems for JSF 1.x application developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 现代版本与早期版本之间一个明显的区别是，现在 Facelets 是首选的视图技术。JSF 的早期版本使用 JSP 作为它们的默认视图技术。由于
    JSP 技术早于 JSF，有时使用 JSP 与 JSF 感觉不自然或产生问题。例如，JSP 的生命周期与 JSF 的生命周期不同；这种不匹配为 JSF 1.x
    应用程序开发者引入了一些问题。
- en: JSF was designed from the beginning to support multiple view technologies. To
    take advantage of this capability, Jacob Hookom wrote a view technology specifically
    for JSF. He named his view technology **Facelets**. Facelets was so successful
    that it became a de facto standard for JSF. The JSF expert group recognized Facelets'
    popularity and made it the official view technology for JSF in Version 2.0 of
    the JSF specification.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 从一开始就被设计成支持多种视图技术。为了利用这一功能，Jacob Hookom 为 JSF 编写了一种特定的视图技术。他将自己的视图技术命名为
    **Facelets**。Facelets 非常成功，以至于它成为了 JSF 的实际标准。JSF 专家组认识到 Facelets 的流行，并在 JSF 规范的
    2.0 版本中将 Facelets 定为官方视图技术。
- en: Optional faces-config.xml
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的 faces-config.xml
- en: Legacy J2EE applications suffered what some would have considered being excessive
    XML configuration.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 J2EE 应用程序遭受了一些人认为过度的 XML 配置。
- en: Java EE 5 took some measures to reduce the XML configuration considerably. Java
    EE 6 reduced the required configuration even further, making the `faces-config.xml`
    JSF configuration file optional in JSF 2.0.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 5 采取了一些措施来显著减少 XML 配置。Java EE 6 进一步减少了所需的配置，使得在 JSF 2.0 中 `faces-config.xml`
    JSF 配置文件成为可选的。
- en: In JSF 2.0 and newer, JSF managed beans can be configured via the `@ManagedBean`
    annotation, obviating the need to configure them in `faces-config.xml`. Java EE
    6 introduced the **Contexts and Dependency Injection** (**CDI**) API, which provides
    an alternative way to implement the functionality that was typically implemented
    with JSF managed beans. As of JSF 2.2, CDI named beans are preferred over JSF
    managed beans.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2.0 及更高版本中，可以通过 `@ManagedBean` 注解配置 JSF 管理器豆，从而无需在 `faces-config.xml`
    中配置它们。Java EE 6 引入了 **上下文和依赖注入**（**CDI**）API，它提供了一种替代方法来实现通常使用 JSF 管理器豆实现的功能。截至
    JSF 2.2，CDI 命名豆比 JSF 管理器豆更受欢迎。
- en: Additionally, there is a convention for JSF navigation. If the value of the
    `action` attribute of a JSF 2 command link or command button matches the name
    of a facelet (minus the XHTML extension), then by convention, the application
    will navigate to the facelet that matches the action name. This convention allows
    us to avoid having to configure an application's navigation in `faces-config.xml`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JSF 导航有一个约定。如果一个 JSF 2 命令链接或命令按钮的 `action` 属性值与 facelet（去掉 XHTML 扩展名）的名称匹配，那么按照约定，应用程序将导航到与动作名称匹配的
    facelet。这个约定允许我们避免在 `faces-config.xml` 中配置应用程序的导航。
- en: For many modern JSF applications, `faces-config.xml` is completely unnecessary
    as long as the established JSF conventions are followed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多现代 JSF 应用程序，只要遵循已建立的 JSF 约定，`faces-config.xml` 就完全没有必要。
- en: Standard resource locations
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准资源位置
- en: JSF 2.0 introduced standard resource locations. Resources are the artifacts
    that a page or JSF component needs to render properly, such as CSS style sheets,
    JavaScript files, and images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0 引入了标准的资源位置。资源是页面或 JSF 组件需要正确渲染的工件，例如 CSS 样式表、JavaScript 文件和图像。
- en: In JSF 2.0 and newer, resources can be placed in a subdirectory under a folder
    called `resources` either at the root of the WAR file or under `META-INF`. By
    convention, JSF components know that they can retrieve resources from one of these
    two locations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2.0 及更高版本中，资源可以放置在 `resources` 文件夹下的子目录中，这个文件夹位于 WAR 文件的根目录下或 `META-INF`
    下。按照约定，JSF 组件知道它们可以从这两个位置之一检索资源。
- en: In order to avoid cluttering the resources directory, resources are typically
    placed in a subdirectory. This subdirectory is referred to from the `library`
    attribute of JSF components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免资源目录杂乱，资源通常放置在子目录中。这个子目录通过 JSF 组件的 `library` 属性来引用。
- en: For example, we could place a CSS style sheet called `styles.css` under `/resources/css/`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 `/resources/css/` 下放置一个名为 `styles.css` 的 CSS 样式表。
- en: 'In our JSF pages, we can retrieve this CSS file using the `<h:outputStylesheet>`
    tag as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 JSF 页面中，我们可以使用 `<h:outputStylesheet>` 标签来检索此 CSS 文件，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of the `library` attribute must match the subdirectory where our style
    sheet is located.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`library` 属性的值必须与我们的样式表所在的子目录匹配。'
- en: 'Similarly, we can have a JavaScript file, `somescript.js`, under `/resources/scripts/`
    and we can access it using the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在 `/resources/scripts/` 下有一个名为 `somescript.js` 的 JavaScript 文件，并且我们可以使用以下代码来访问它：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can have an image, `logo.png`, under `/resources/images/` and we can access
    this resource with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `/resources/images/` 下放置一个名为 `logo.png` 的图像，并且我们可以使用以下代码来访问这个资源：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that in each case, the value of the `library` attribute matches the corresponding
    subdirectory name under the `resources` directory and the value of the `name`
    attribute matches the resource's filename.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每种情况下，`library` 属性的值都与 `resources` 目录下的相应子目录名称匹配，而 `name` 属性的值与资源的文件名匹配。
- en: Developing our first JSF application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个 JSF 应用程序
- en: To illustrate basic JSF concepts, we will develop a simple application consisting
    of two Facelets pages and a single CDI named bean.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明基本的 JSF 概念，我们将开发一个简单的应用程序，该应用程序由两个 Facelets 页面和一个名为 CDI 的命名豆组成。
- en: Facelets
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facelets
- en: 'As we mentioned in this chapter''s introduction, the default view technology
    for JSF 2 is Facelets. Facelets need to be written using standard XML. The most
    popular way of developing Facelets pages is to use XHTML in conjunction with JSF-specific
    XML namespaces. The following example shows how a typical Facelets page looks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章引言中提到的，JSF 2 的默认视图技术是 Facelets。Facelets 需要使用标准的 XML 编写。开发 Facelets 页面最流行的方式是结合使用
    XHTML 和 JSF 特定的 XML 命名空间。以下示例显示了典型的 Facelets 页面看起来像什么：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot illustrates how our example page is rendered in the
    browser:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了我们的示例页面在浏览器中的渲染方式：
- en: '![Facelets](img/6886EN_02_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Facelets](img/6886EN_02_01.jpg)'
- en: The preceding screenshot, of course, was taken after entering some data in every
    text field; originally, each text field was blank.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的截图是在每个文本字段输入一些数据之后拍摄的；最初，每个文本字段都是空的。
- en: Pretty much any Facelets JSF page will include the two namespaces illustrated
    in the example. The first namespace (``) is for the tags that render HTML components;
    by convention, the prefix `h` (for HTML) is used when using this tag library.``
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何 Facelets JSF 页面都会包括示例中展示的两个命名空间。第一个命名空间（``）用于渲染 HTML 组件的标签；按照约定，当使用此标签库时，使用前缀
    `h`（代表 HTML）。``
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`` `Tip` ``'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `提示` ``'
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`` `![Facelets](img/6886EN_02_02.jpg)` ``'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![Facelets](img/6886EN_02_02.jpg)` ``'
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`` `Project stages` ``'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `项目阶段` ``'
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`` `To avoid the situation described in the previous paragraph, JSF 2.0 introduced
    the concept of **project stages**.` ``'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `为了避免前一段描述的情况，JSF 2.0 引入了 **项目阶段** 的概念。` ``'
- en: '`` `The following project stages are defined in JSF 2:` ``'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `以下是在 JSF 2 中定义的项目阶段：` ``'
- en: '`` `Production` ``'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `生产` ``'
- en: '`` `Development` ``'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `开发` ``'
- en: '`` `UnitTest` ``'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `单元测试` ``'
- en: '`` `SystemTest` ``'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `系统测试` ``'
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`` `With GlassFish, we can do this by logging in to the web console, navigating
    to **JNDI** | **Custom Resources**, and then clicking on the **New...** button.
    The page that appears looks as shown in the following screenshot:` ``'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `使用 GlassFish，我们可以通过登录到 Web 控制台，导航到 **JNDI** | **自定义资源**，然后点击 **新建...**
    按钮。出现的页面如图所示：` ``'
- en: '`` `![Project stages](img/6886EN_02_03.jpg)` ``'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![项目阶段](img/6886EN_02_03.jpg)` ``'
- en: '`` `In the resulting page, we need to enter the following information:` ``'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `在生成的页面中，我们需要输入以下信息：` ``'
- en: '| **JNDI Name** | `javax.faces.PROJECT_STAGE` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **JNDI 名称** | `javax.faces.PROJECT_STAGE` |'
- en: '| **Resource Type** | `java.lang.String` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **资源类型** | `java.lang.String` |'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`` `After entering the values, we need to add a new property with a name of
    the stage and a value corresponding to the project stage we wish to use.` ``'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `输入值后，我们需要添加一个新的属性，其名称为阶段，其值对应于我们希望使用的项目阶段。` ``'
- en: '`` `Setting the project stage allows us to perform some logic only if we are
    running the program in a specific stage. For instance, in one of our named beans,
    we could have code that looks as follows:` ``'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `设置项目阶段允许我们在特定阶段运行程序时执行一些逻辑。例如，在我们的一个命名豆中，我们可能有如下代码：` ``'
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`` `![Project stages](img/6886EN_02_04.jpg)` ``'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![项目阶段](img/6886EN_02_04.jpg)` ``'
- en: '`` `In the default Production stage, this error message is not displayed on
    the page, leaving us confused as to why our page navigation doesn''t seem to work.`
    ``'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `在默认的生产阶段，此错误消息不会在页面上显示，使我们困惑于为什么我们的页面导航似乎不起作用。` ``'
- en: '`` `Validation` ``'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `验证` ``'
- en: '`` `JSF provides built-in input validation capabilities.` ``'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `JSF 提供了内置的输入验证功能。` ``'
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`` `![Validation](img/6886EN_02_05.jpg)` ``'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![验证](img/6886EN_02_05.jpg)` ``'
- en: '`` `Again, the default message and style can be overridden; we will cover how
    to do this later in this chapter in the *Customizing JSF''s default messages*
    section.` ``'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `同样，默认消息和样式可以被覆盖；我们将在本章后面的 *自定义 JSF 的默认消息* 部分介绍如何做到这一点。` ``'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Validation tag | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 验证标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<f:validateBean>` | Bean validation allows us to validate named bean values
    using annotations in our named beans without having to add validators to our JSF
    tags. These tags allow us to fine-tune Bean Validation if necessary. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateBean>` | 使用注解在命名豆中验证命名豆值，而无需在我们的 JSF 标签中添加验证器，这允许我们根据需要微调 Bean
    验证。这些标签允许我们根据需要微调 Bean 验证。 |'
- en: '| `<f:validateDoubleRange>` | This tag validates that the input is a valid
    `Double` value between the two values specified by the tag''s `minimum` and `maximum`
    attributes, inclusive. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateDoubleRange>` | 此标签验证输入是否为在标签的 `minimum` 和 `maximum` 属性指定的两个值之间的有效
    `Double` 值，包括这些值。 |'
- en: '| `<f:validateLength>` | This tag validates that the input''s length is between
    the values specified by the tag''s `minimum` and `maximum` values, inclusive.
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLength>` | 此标签验证输入的长度是否在标签的 `minimum` 和 `maximum` 值之间，包括这些值。
    |'
- en: '| `<f:validateLongRange>` | This tag validates that the input is a valid `Long`
    value between the values specified by the tag''s `minimum` and `maximum` attributes,
    inclusive. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLongRange>` | 此标签验证输入是否为在标签的 `minimum` 和 `maximum` 属性指定的值之间的有效
    `Long` 值，包括这些值。 |'
- en: '| `<f:validateRegex>` | This tag validates that the input matches a regular
    expression pattern specified in the tag''s `pattern` attribute. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRegex>` | 此标签验证输入是否与标签的 `pattern` 属性中指定的正则表达式模式匹配。 |'
- en: '| `<f:validateRequired>` | This tag validates that the input is not empty.
    This tag is equivalent to setting the `required` attribute to `true` in the parent
    input field. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRequired>` | 此标签验证输入是否不为空。此标签等同于在父输入字段中将 `required` 属性设置为 `true`。
    |'
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`` `If we wish to take advantage of Bean Validation, all we need to do is annotate
    the desired field with the appropriate Bean Validation annotation, without having
    to explicitly use a JSF validator.` ``'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `如果我们想利用 Bean 验证，我们只需要使用适当的 Bean 验证注解注释所需的字段，而无需显式使用 JSF 验证器。` ``'
- en: '`` `Note` ``'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `注意` ``'
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`` `Grouping components` ``'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `组件分组` ``'
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`` `Form submission` ``'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `表单提交` ``'
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`` `Note` ``'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `注意` ``'
- en: '`` `Even though the label for the button reads **Save**, in our simple example
    clicking on the button won''t actually save any data.` ``'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `尽管按钮的标签读作**保存**，但在我们的简单示例中，点击按钮实际上不会保存任何数据。` ``'
- en: '`` `Named beans` ``'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `命名bean` ``'
- en: '`` `There are two types of JavaBeans that can interact with JSF pages: JSF
    managed beans and CDI named beans. JSF managed beans have been around since the
    first version of the JSF specification and can be used only in a JSF context.
    CDI named beans were introduced in Java EE 6 and can interoperate with other Java
    EE APIs such as Enterprise JavaBeans. For these reasons, CDI named beans are preferred
    over JSF managed beans.` ``'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `有两种类型的JavaBeans可以与JSF页面交互：JSF管理bean和CDI命名bean。JSF管理bean自JSF规范的第一版以来就存在了，并且只能在JSF上下文中使用。CDI命名bean在Java
    EE 6中引入，可以与其他Java EE API（如企业JavaBeans）交互。因此，CDI命名bean比JSF管理bean更受欢迎。` ``'
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`` `Named beans always have a scope. A named bean scope defines the lifespan
    of the bean, and it is defined by a class-level annotation. The following table
    lists all valid named bean scopes:` ``'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `命名bean始终有一个作用域。命名bean作用域定义了bean的生命周期，它由类级别的注解定义。下表列出了所有有效的命名bean作用域：` ``'
- en: '| Named bean scope annotation | Description |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 命名bean作用域注解 | 描述 |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@ApplicationScoped` | The same instance of the application scoped named
    beans are available to all of our application''s clients. If one client modifies
    the value of an application scoped managed bean, the change is reflected across
    all clients. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `@ApplicationScoped` | 应用程序作用域的命名bean的同一实例对所有应用程序的客户端都是可用的。如果一个客户端修改了应用程序作用域管理bean的值，该更改将在所有客户端中反映出来。
    |'
- en: '| `@SessionScoped` | An instance of each session scoped named bean is assigned
    to each of our application''s clients. A session scoped named bean can be used
    to hold client-specific data across requests. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `@SessionScoped` | 每个会话作用域的命名bean实例都被分配给我们的应用程序的每个客户端。会话作用域的命名bean可以用来在请求之间保持客户端特定的数据。
    |'
- en: '| `@RequestScoped` | Request scoped named beans only live through a single
    request. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `@RequestScoped` | 请求作用域的命名bean只存在于单个请求中。 |'
- en: '| `@Dependent` | Dependent scoped named beans are assigned the same scope as
    the bean they are injected into. This is the default scope if none is specified.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `@Dependent` | 依赖作用域的命名bean被分配给它们注入的bean相同的范围。如果没有指定，这是默认的作用域。 |'
- en: '| `@ConversationScoped` | The conversation scope can span multiple requests
    and is typically shorter than the session scope. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `@ConversationScoped` | 会话作用域可以跨越多个请求，通常比会话作用域短。 |'
- en: '`` `Navigation` ``'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `导航` ``'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`` `Tip` ``'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`` `提示` ``'
- en: '`` `**Does the same page reload when you click on a button or link that should
    navigate to another page?**` ``'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `**当你点击一个应该导航到另一个页面的按钮或链接时，页面会重新加载吗？**` ``'
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`` `![Navigation](img/6886EN_02_06.jpg)` ``'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `![导航](img/6886EN_02_06.jpg)` ``'
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]`# Custom data validation    In addition to providing standard validators,
    JSF allows us to create custom validators. This can be done in two ways: by creating
    a custom validator class or by adding validation methods to our named beans.    ##
    Creating custom validators    In addition to the standard validators, JSF allows
    us to create custom validators by creating a Java class that implements the `javax.faces.validator.Validator`
    interface.    The following class implements an e-mail validator, which we will
    use to validate the e-mail text input field in our customer data entry screen.    [PRE44]    The
    `@FacesValidator` annotation registers our class as a JSF custom validator class.
    The value of its `value` attribute is the logical name that JSF pages can use
    for reference.    As can be seen in the example, the only method we need to implement
    when implementing the `Validator` interface is a method called `validate()`. This
    method takes three parameters: an instance of `javax.faces.context.FacesContext`,
    an instance of `javax.faces.component.UIComponent`, and an object. Typically,
    application developers only need to be concerned with the last two. The second
    parameter is the component whose data we are validating, and the third parameter
    is the actual value. In the example, we cast `uiComponent` to `javax.faces.component.html.HtmlInputText`;
    in this way, we get access to its `getLabel()` method, which we can use as part
    of the error message.    If the entered value is not in a valid e-mail address
    format, a new instance of `javax.faces.application.FacesMessage` is created, passing
    the error message to be displayed in the browser as its constructor parameter.
    We then throw a new exception as `javax.faces.validator.ValidatorException`. The
    error message is then displayed in the browser.    ### Tip    **Apache Commons
    Validator**    Our custom JSF validator uses the Apache Commons Validator to do
    the actual validation. This library includes many common validations such as dates,
    credit card numbers, ISBN numbers, and e-mails. When implementing a custom validator,
    it is worth investigating if this library already has a validator that we can
    use.    In order to use our validator in our page, we need to use the `<f:validator>`
    JSF tag. The following Facelets page is a modified version of the customer data
    entry screen. This version uses the `<f:validator>` tag to validate e-mails.    [PRE45]    Notice
    that the value of the `validatorId` attribute of `<f:validator>` matches the `value`
    attribute of the `@FacesValidator` annotation in our custom validator.    After
    writing our custom validator and modifying our page to take advantage of it, we
    can see our validator in action as shown in the following screenshot:  ![Creating
    custom validators](img/6886EN_02_07.jpg)  ## Validator methods    Another way
    we can implement custom validation is by adding validation methods to one or more
    of the application''s named beans. The following Java class illustrates the use
    of validator methods for JSF validation:    [PRE46]    In this example, the class
    contains only the validator method. We can give our validator method any name
    we want; however, its return value must be void, and it must take the three parameters
    illustrated in the example, in that order. In other words, except for the method
    name, the signature of a validator method must be identical to the signature of
    the `validate()` method defined in the `javax.faces.validator.Validator` interface.    As
    we can see, the body of our validator method is nearly identical to the body of
    our custom validator''s `validate()` method. We check the value entered by the
    user to make sure that it contains only alphabetic characters and/or spaces. If
    it does not, then we throw `ValidatorException`, passing an instance of `FacesMessage`
    containing an appropriate `String` error message.    ### Tip    **StringUtils**    In
    the example, we used `org.apache.commons.lang.StringUtils` to perform the actual
    validation logic. In addition to the method used in the example, this class contains
    several methods to verify whether a string is numeric or alphanumeric. This class,
    part of the Apache `commons-lang` library, is very useful when writing custom
    validators.    Since every validator method must be in a named bean, we need to
    make sure that the class containing our validator method is annotated with the
    `@Named` annotation, as illustrated in our example.    The last thing we need
    to do in order to use our validator method is to bind it to our component via
    the tag''s `validator` attribute. The code to do so is as follows:    [PRE47]    Since
    neither the first name nor the last name fields would accept anything other than
    alphabetic characters or spaces, we added our custom validator method to both
    of these fields.    Notice that the value of the `validator` attribute of the
    `<h:inputText>` tag is a JSF expression language expression that uses the default
    name for the bean containing our validation method. `alphaValidator` is the name
    of our bean, and `validateAlpha` is the name of our validator method.    After
    modifying our page to use our custom validator, we can now see it in action as
    follows:  ![Validator methods](img/6886EN_02_08.jpg)  Note how for the **First
    Name** field both our custom validator message and the standard length validator
    were executed.    The advantage of implementing validator methods is that you
    do not need the overhead of creating a whole class just for a single validator
    method. (Our example does just that, but in many cases, validator methods are
    added to an existing named bean containing other methods.) The disadvantage of
    validator methods is that each component can only be validated by a single validator
    method. When using validator classes, several `<f:validator>` tags can be nested
    inside the tag to be validated; therefore, multiple validations, both custom and
    standard, can be done to the field.    # Customizing JSF''s default messages    As
    we mentioned earlier, it is possible to customize the style (font, color, text,
    and so on) of JSF default validation messages. Additionally, it is possible to
    modify the text of the default JSF validation messages. In the following sections,
    we will explain how to modify error message formatting and text.    ## Customizing
    message styles    Customizing message styles can be done via **Cascading Style
    Sheets** (**CSS**). This can be accomplished using the `<h:message>` style or
    the `styleClass` attributes. The `style` attribute is used when we want to declare
    the CSS style inline. The `styleClass` attribute is used when we want to use a
    predefined style in a CSS style sheet or inside a `<style>` tag in our page.    The
    following markup illustrates the use of the `styleClass` attribute to alter the
    style of error messages. It is a modified version of the input page that we saw
    in the previous section.    [PRE48]    The only difference between this page and
    the previous one is the use of the `styleClass` attribute of the `<h:messages>`
    tag. As mentioned earlier, the value of the `styleClass` attribute must match
    the name of a CSS style defined in a cascading style sheet that our page can access.    In
    our case, we defined a CSS style in `style.css` for messages as follows:    [PRE49]    We
    then used this style as the value of the `styleClass` attribute of our `<h:messages>`
    tag.    The following screenshot illustrates how the validation error messages
    look after we have implemented this change:  ![Customizing message styles](img/6886EN_02_09.jpg)  In
    this particular case, we just set the color of the error message text to red,
    but we are only limited by CSS capabilities in setting the style of the error
    messages.    ## Customizing message text    Sometimes it is desirable to override
    JSF''s default validation errors. Default validation errors are defined in a resource
    bundle called `Messages.properties`. This file can be found inside the `javax.faces.jar`
    file under `[glassfish installation directory]/glassfish/modules`. It can be found
    under the `javax/faces` folder inside the JAR file. The file contains several
    messages, but we are only interested in validation errors at this point. The default
    validation error messages are defined as follows:    [PRE50]    In order to override
    the default error messages, we need to create our own resource bundle using the
    same keys used in the default one, but altering the values to suit our needs.
    The following is a very simple customized resource bundle for our application:    [PRE51]    In
    this resource bundle, we override the error message for when the value entered
    for a field validated by the `<f:validateLength>` tag is less than the allowed
    minimum. In order to let our application know that we have a custom resource bundle
    for message properties, we need to modify the application''s `faces-config.xml`
    file as follows:    [PRE52]    As we can see, the only thing we need to do to
    the application''s `faces-config.xml` file is to add a `<message-bundle>` element
    indicating the name and location of the resource bundle containing our custom
    messages.    ### Note    A custom error message text definition is one of the
    few cases in which we still need to define a `faces-config.xml` file for modern
    JSF applications. However, note how simple our `faces-config.xml` file is; it
    is a far cry from a typical `faces-config.xml` file for JSF 1.x, which typically
    contains named bean definitions, navigation rules, JSF validator definitions,
    and so on.    After adding our custom message resource bundle and modifying the
    application''s `faces-config.xml` file, we can see our custom validation message
    in action, as shown in the following screenshot:  ![Customizing message text](img/6886EN_02_10.jpg)  As
    can be seen in the screenshot, if we haven''t overridden a validation message,
    the default will still be displayed. In our resource bundle, we only overrode
    the minimum length validation error message; therefore, our custom error message
    is shown for the **First Name** text field. Since we didn''t override the error
    messages for the other standard JSF validators, the default error message is shown
    for each one of them. The e-mail validator is the custom validator we developed
    previously in this chapter. Since it is a custom validator, its error message
    is not affected.    # Ajax-enabling JSF applications    Early versions of JSF
    did not include native Ajax support. Custom JSF library vendors were forced to
    implement Ajax in their own way. Unfortunately, this state of events introduced
    incompatibilities between JSF component libraries. JSF 2.0 standardized Ajax support
    by introducing the `<f:ajax>` tag.    The following page illustrates the typical
    usage of the `<f:ajax>` tag:    [PRE53]    After deploying our application, our
    page renders as illustrated in the following screenshot:  ![Ajax-enabling JSF
    applications](img/6886EN_02_11.jpg)  This example page illustrates two uses of
    the `<f:ajax>` tag. At the top of the page, we have used this tag for implementing
    a typical Ajax Echo example, in which we have an `<h:outputText>` component updating
    itself with the value of an input text component. Any time a character is entered
    into the input field, the value of the `<h:outputText>` component is automatically
    updated.    To implement the functionality described in the previous paragraph,
    we put an `<f:ajax>` tag inside an `<h:inputText>` tag. The value of the `render`
    attribute of the `<f:ajax>` tag must correspond to the ID of a component we wish
    to update after the Ajax request finishes. In our example, we wish to update the
    `<h:outputText>` component with an ID of "`textVal`"; therefore, we will use this
    value for the `render` attribute of our `<f:ajax>` tag.    ### Note    In some
    cases, we may need to render more than one JSF component after an Ajax event finishes;
    in order to accommodate this, we can add several IDs as the value of the `render`
    attribute, and we simply need to separate them by spaces.    The other `<f:ajax>`
    attribute we used in this instance is the `event` attribute. This attribute indicates
    the JavaScript event that triggers the Ajax event. In this particular case, we
    need to trigger the event any time a key is released while a user is typing into
    the input field; therefore, the appropriate event to use is `keyup`.    The following
    table lists all supported JavaScript events:     | Event | Description | | ---
    | --- | | `blur` | The component loses focus. | | `change` | The component loses
    focus, and its value is modified. | | `click` | The component is clicked on. |
    | `dblclick` | The component is double-clicked on. | | `focus` | The component
    gains focus. | | `keydown` | A key is depressed while the component has focus.
    | | `keypress` | A key is pressed or held down while the component has focus.
    | | `keyup` | A key is released while the component has focus. | | `mousedown`
    | The mouse button is depressed while the component has focus. | | `mousemove`
    | The mouse pointer is moved over the component. | | `mouseout` | The mouse pointer
    leaves the component. | | `mouseover` | The mouse pointer is placed over the component.
    | | `mouseup` | The mouse button is released while the component has focus. |
    | `select` | The component''s text is selected. | | `valueChange` | Equivalent
    to `change`; the component loses focus and its value has been modified. |    We
    use the `<f:ajax>` tag once again farther down in the page to Ajax-enable a command
    button component. In this instance, we want to recalculate a value based on the
    value of two input components. In order to have the values on the server updated
    with the latest user input, we used the `execute` attribute of `<f:ajax>`; this
    attribute takes a space-separated list of component IDs to use as input. We then
    use the `render` attribute just as before to specify which components need to
    be re-rendered after the Ajax request finishes.    Notice that we used the `actionListener`
    attribute of `<h:commandButton>`. This attribute is typically used when we don''t
    need to navigate to another page after clicking on the button. The value for this
    attribute is an action listener method we wrote in one of our named beans. Action
    listener methods must return void and take an instance of `javax.faces.event.ActionEvent`
    as their sole parameter.    The named bean for our application looks as follows:    [PRE54]    Notice
    that we didn''t have to do anything special in our named bean to enable Ajax in
    our application. It is all controlled by the `<f:ajax>` tag on the page.    As
    we can see from this example, Ajax-enabling JSF applications is very simple. We
    simply need to use a single tag to Ajax-enable our page, without having to write
    a single line of JavaScript, JSON, or XML.    # JSF 2.2 HTML5 support    HTML
    5 is the latest version of the HTML specification. It includes several improvements
    over the previous version of HTML. JSF 2.2 includes several updates to make JSF
    pages work nicely with HTML5.    ## The HTML5-friendly markup    Through the use
    of pass-through elements, we can develop our pages using HTML 5 tags and also
    treat them as JSF components. To do this, we need to specify at least one of the
    `element` attributes using the `http://xmlns.jcp.org/jsf` namespace. The following
    example demonstrates this approach in action:    [PRE55]    The first thing we
    should notice about this example is the XML namespace prefixed by `jsf` near the
    top of the page. This namespace allows us to add JSF-specific attributes to HTML
    5 pages. When the JSF runtime encounters attributes prefixed by `jsf` in any of
    the tags on the page, it automatically converts the HTML5 tag to the equivalent
    JSF component. JSF-specific tags are the same as in regular JSF pages, except
    that they are prefixed with `jsf`. Therefore, at this point, they should be self-explanatory
    and will not be discussed in detail. Our example will render and behave just like
    the first example in this chapter.    The technique described in this section
    is useful if you have experienced HTML web designers in your team who prefer to
    have full control over the look of the page. The pages are developed using standard
    HTML5 with JSF-specific attributes so that the JSF runtime can manage user input.    If
    your team consists primarily of Java developers with limited CSS/HTML knowledge,
    then it is preferable to develop the web pages for your web application using
    JSF components. HTML 5 introduced several new attributes that didn''t exist in
    the previous versions of HTML. For this reason, JSF 2.2 introduces the ability
    to add arbitrary attributes to JSF components. This JSF/HTML5 integration technique
    is discussed in the next section.    ## Pass-through elements    JSF 2.2 allows
    the definition of any arbitrary attributes (not processed by the JSF engine).
    These attributes are simply rendered as is on the generated HTML displayed in
    the browser. The following example is a new version of an earlier example in this
    chapter, which has been modified to take advantage of the HTML5 pass-through elements:    [PRE56]    The
    first thing we should notice about this example is the addition of the ``id227"
    class="indexterm"/>by the defined prefix for the namespace at the top of the application
    (`p`, in our case). The placeholder HTML attribute simply adds some placeholder
    text to the input fields, which is automatically deleted once the user starts
    typing in the input field (this technique was commonly implemented "by hand" using
    JavaScript before HTML5).``    The following screenshot shows our updated page
    in action:  ![Pass-through elements](img/6886EN_02_12.jpg)  # JSF 2.2 Faces Flows    Faces
    Flows is a new JSF 2.2 feature that defines a scope that can span several pages.
    Flow scoped beans are created when the user enters a flow (a set of web pages)
    and are destroyed when the user leaves the flow.    Faces Flows adopts the convention
    over configuration principle of JSF. The following conventions are typically used
    when developing applications employing Faces Flows:    *   All pages in the flow
    must be placed in a directory with a name that defines the name of the flow *   An
    XML configuration file named after the directory name and suffixed with `-flow`
    must exist inside the directory that contains the pages in the flow (the file
    may be empty, but it must exist) *   The first page in the flow must be named
    after the directory name that contains the flow *   The last page in the flow
    must not be located inside the directory containing the flow and must be named
    after the directory name and suffixed with `-return`    The following screenshot
    illustrates these conventions:  ![JSF 2.2 Faces Flows](img/6886EN_02_13.jpg)  In
    this example, we define a flow named `customerinfo`; by convention, these files
    are inside a directory named `customerinfo`, and the first page of the flow is
    named `customerinfo.xhtml` (there are no restrictions on the names of other pages
    in the flow). When we exit the flow, we navigate to `customerinfo-return.xhtml`,
    which follows the naming convention and takes us out of the flow.    The markup
    for the pages doesn''t illustrate anything we haven''t seen before, so we will
    not show it. All example code is available as part of this book''s code download
    bundle.    All the pages in our example store data in a named bean called `Customer`,
    which has a scope of flow.    [PRE57]    The `@FlowScoped` annotation has a `value`
    attribute that must match the name of the flow that the bean is meant to work
    with (`customerinfo` in this example).    This example creates a wizard-style
    set of pages in which data for a user is entered across several pages in the flow.    On
    the first page, we enter information about the name.  ![JSF 2.2 Faces Flows](img/6886EN_02_14.jpg)  On
    the second page, we enter address information as shown in the following screenshot:  ![JSF
    2.2 Faces Flows](img/6886EN_02_15.jpg)  On the next page, we enter phone number
    information as shown in the following screenshot:  ![JSF 2.2 Faces Flows](img/6886EN_02_16.jpg)  Finally,
    we display a confirmation page as shown in the following screenshot:  ![JSF 2.2
    Faces Flows](img/6886EN_02_17.jpg)  If the user verifies that the information
    is correct, we navigate outside the flow to `customerinfo-return.xhtml`; otherwise,
    we go back to the first page in the flow to allow the user to make any necessary
    corrections.    # Additional JSF component libraries    In addition to the standard
    JSF component libraries, there are a number of third-party JSF tag libraries available.
    The following table lists some of the most popular ones:     | Tag library | Distributor
    | License | URL | | --- | --- | --- | --- | | ICEfaces | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    | | RichFaces | Red Hat/JBoss | LGPL | [http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)
    | | Primefaces | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |    # Summary    In this chapter, we covered how to develop web-based applications
    using JavaServer Faces, the standard component framework for the Java EE platform.
    We covered how to write a simple application by creating pages using Facelets
    as the view technology and CDI named beans. We also covered how to validate user
    input by using JSF''s standard validators and by creating our own custom validators
    or by writing validator methods. Additionally, we covered how to customize standard
    JSF error messages, both the message text and the message style (font, color,
    and so on). Also, we covered how to develop Ajax-enabled JSF pages as well as
    how to integrate JSF and HTML5.    In the next chapter, we will cover how to interact
    with relational databases via the Java Persistence API.[PRE58]``'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
