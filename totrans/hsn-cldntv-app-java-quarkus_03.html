<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Developing Your First Application with Quarkus</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will be creating our first Quarkus application using the tooling that's available to us. As you will soon see, this is a pretty simple process that can be bootstrapped from the command line and doesn't require you to download any external tools. By using this process, we will be able to compile an application into a native executable and have solid evidence of how fast and thin a Java application can be when it's turned into native code by Quarkus.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li class="mce-root">Using the Quarkus Maven plugin to bootstrap our projects</li>
<li>Alternative methods to kick-start your projects (Quarkus CLI)</li>
<li class="mce-root">Creating and executing our first Quarkus application</li>
<li class="mce-root">Debugging the application from our IDE</li>
<li>Testing the application with an extension of the JUnit test framework</li>
<li class="mce-root">Turning our application into native code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can find the source code for the project in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02">https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with the Quarkus Maven plugin</h1>
                </header>
            
            <article>
                
<p>In order to scaffold our first Quarkus application, we will be using Maven, which is the most common software and release management tool available. It is used by a variety of developers, mostly because it offers the following:</p>
<ul>
<li>A standard structure for all your projects</li>
<li>Centralized and automatic management of dependencies</li>
</ul>
<p class="mce-root">Maven is distributed in several formats for the user's convenience. You can download it from <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</p>
<p class="mce-root">Once you've downloaded Maven, do the following:</p>
<ol>
<li class="mce-root">Unzip the distribution archive (for example, <kbd>apache-maven-3.6.1-bin.zip</kbd>) to the directory that you want Maven to be installed in (for example, in your <kbd>$HOME/apache</kbd> folder):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ mkdir $HOME/apache</strong><br/><strong>$ unzip $HOME/Downloads/apache-maven-3.6.1-bin.zip -d $HOME/apache </strong></pre>
<ol start="2">
<li>Add the Maven libraries to your system path, as shown in the following code. This will update the <kbd>PATH</kbd> environment variable:</li>
</ol>
<pre style="padding-left: 60px"><strong> $ export PATH=$PATH:$HOME/apache/apache-maven-3.6.1/bin</strong></pre>
<ol start="3">
<li>Once you have completed your installation, you need to check whether Maven has been correctly installed or not. Run <kbd>mvn --version</kbd> to verify this:</li>
</ol>
<pre style="padding-left: 60px"><strong> $ mvn --version</strong><br/><strong> Apache Maven 3.6.1  </strong><br/><strong> Maven home: /home/francesco/apache/apache-maven-3.6.1</strong><br/><strong> Java version: 1.8.0_191, vendor: Oracle Corporation, runtime: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b13-0.fc29.x86_64/jre</strong><br/><strong> Default locale: en_US, platform encoding: UTF-8</strong><br/><strong> OS name: "linux", version: "4.18.16-300.fc29.x86_64", arch: "amd64", family: "unix"</strong></pre>
<p>If you get the preceding output, then you have just verified that Maven is installed on your system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching the Quarkus Maven plugin</h1>
                </header>
            
            <article>
                
<p>Now that Maven has been set up, we can bootstrap our first Quarkus application by means of its Maven plugin. A Maven plugin provides a set of goals that can be executed to compile and build our artifacts or extend our project with some features. Each plugin, like every Maven component, is based on the following coordinates:</p>
<ul>
<li><kbd>groupId</kbd>: The ID of the project's group. This often matches the ID of the package root directory.</li>
<li><kbd>artifactId</kbd>: The ID of the artifact. This often matches with the final artifact name.</li>
<li><kbd>version</kbd>: The version of the artifact under the specified group.</li>
</ul>
<p>You can reference a Maven plugin from the command line by indicating the <kbd>&lt;groupId&gt;:&lt;artifactId&gt;</kbd> coordinates. For Quarkus, the <kbd>&lt;groupId&gt;:&lt;artifactId&gt;</kbd> combination is <kbd>io.quarkus:quarkus-maven-plugin</kbd>. You can check the available goals and the latest version of it with the following command:</p>
<pre><strong>$ mvn -Dplugin=io.quarkus:quarkus-maven-plugin help:describe</strong><span class="packt_screen"><br/></span></pre>
<p>You will see the following output:</p>
<pre><strong><span class="packt_screen"> </span>Name: Quarkus - Maven Plugin</strong><br/><strong> Description: Build parent to bring in required dependencies</strong><br/><strong> Group Id: io.quarkus</strong><br/><strong> Artifact Id: quarkus-maven-plugin</strong><br/><strong> Version: 1.0.0.Final</strong><br/><strong> Goal Prefix: quarkus</strong><br/> <br/><strong> This plugin has 11 goals:</strong><br/> <br/><strong> quarkus:add-extension</strong><br/><strong>   Description: (no description available)</strong><br/> <br/><strong> quarkus:add-extensions</strong><br/><strong>   Description: Allow adding an extension to an existing pom.xml file. </strong><br/><strong>    Because you can add one or several extension in one go, there are 2 </strong><br/><strong>    mojos:</strong><br/><strong>     add-extensions and add-extension. Both supports the extension and</strong><br/><strong>     extensions parameters.</strong><br/> <br/><strong> quarkus:analyze-call-tree</strong><br/><strong>   Description: (no description available)</strong><br/> <br/><strong> quarkus:build</strong><br/><strong>   Description: (no description available)</strong><br/> <br/><strong> quarkus:create</strong><br/><strong>   Description: This goal helps in setting up Quarkus Maven project with</strong><br/><strong>     quarkus-maven-plugin, with sensible defaults</strong><br/> <br/><strong> quarkus:create-example-config</strong><br/><strong>   Description: (no description available)</strong><br/> <br/><strong> quarkus:dev</strong><br/><strong>   Description: The dev mojo, that runs a quarkus app in a forked process</strong><br/> <br/><strong> quarkus:help</strong><br/><strong>   Description: Display help information on quarkus-maven-plugin.</strong><br/><strong>     Call mvn quarkus:help -Ddetail=true -Dgoal=&lt;goal-name&gt; to display parameter</strong><br/><strong>     details.</strong><br/> <br/><strong> quarkus:list-extensions</strong><br/><strong>   Description: (no description available)</strong><br/> <br/><strong> quarkus:native-image</strong><br/><strong>   Description: (no description available)</strong><br/> <br/><strong> quarkus:remote-dev</strong><br/><strong>   Description: The dev mojo, that connects to a remote host</strong></pre>
<p class="mce-root">The source code of our first application can be located in the <kbd>Chapter02/hello-rest</kbd> folder of this book's GitHub repository. For reference, we have created the application using the Maven plugin and configured the following set of arguments:</p>
<pre class="mce-root"><strong>$ mvn io.quarkus:quarkus-maven-plugin:1.0.0.Final:create \</strong><br/><strong> -DprojectGroupId=com.packt.quarkus.Chapter02 \</strong><br/><strong> -DprojectArtifactId=hello-rest \</strong><br/><strong> -DclassName="com.packt.quarkus.Chapter02.SimpleRest" \</strong><br/><strong> -Dpath="/helloworld"</strong></pre>
<p class="mce-root">As a result of the preceding command, the following directory structure has been generated in the <kbd>hello-rest</kbd> folder:</p>
<pre> ├── mvnw<br/> ├── mvnw.cmd<br/> ├── pom.xml<br/> └── src<br/>     ├── main<br/>     │   ├── docker<br/>     │   │   ├── Dockerfile.jvm<br/>     │   │   └── Dockerfile.native<br/>     │   ├── java<br/>     │   │   └── com<br/>     │   │       └── packt<br/>     │   │           └── quarkus<br/>     │   │               └── Chapter02<br/>     │   │                   └── SimpleRest.java<br/>     │   └── resources<br/>     │       ├── application.properties<br/>     │       └── META-INF<br/>     │           └── resources<br/>     │               └── index.html<br/>     └── test<br/>         └── java<br/>             └── com<br/>                 └── packt<br/>                     └── quarkus<br/>                         └── Chapter02<br/>                             ├── NativeSimpleRestIT.java<br/>                             └── SimpleRestTest.java</pre>
<p>In the next section of this chapter, we will learn how to import the project into IntelliJ IDEA (the steps are pretty much the same in any IDE, though). Right now, let's stick to the preceding tree view of the project and look at the files that are included in this project:</p>
<ul>
<li>A <strong>Project Object Model</strong> (<kbd>pom.xml</kbd>) with the project configuration</li>
<li>A sample REST service named <kbd>SimpleRest.java</kbd> and a test class for it named <kbd>SimpleRestTest.java</kbd>, as well as a wrapper class named <kbd>NativeSimpleRestIT.java</kbd> for executing the test against the native executable application</li>
<li>A placeholder for the configuration file (<kbd>application.properties</kbd>)</li>
<li>An <kbd>index.html</kbd> file to indicate where we can add static web content</li>
<li>A <kbd>Dockerfile</kbd> so that we can create a container out of our applications</li>
<li>A Maven wrapper file (<kbd>mvnw/mvnw.cmd</kbd>) to allow us to execute Maven goals without prior installation of it</li>
</ul>
<p>The <span><kbd>pom.xml</kbd> file </span>will be added to the root of your project. There, you will find an upper <kbd>dependencyManagement</kbd> section, which imports Quarkus' <strong>Bill Of Materials</strong>. This allows us to automatically link the exact version of each Quarkus extension.</p>
<div class="packt_infobox">In the 1.0.0.Final version of Quarkus, you will reference the <kbd>artifactId</kbd> named <kbd>quarkus-universe-bom</kbd>, which belongs to <kbd>groupId io.quarkus</kbd>.</div>
<p>Here, <kbd>quarkus-maven-plugin</kbd> has also been included to allow you to package your application and generate the native executable:</p>
<pre><span>&lt;dependencyManagement&gt;<br/></span><span>  &lt;dependencies&gt;<br/></span><span>    &lt;dependency&gt;<br/></span><span>      &lt;groupId&gt;</span>${quarkus.platform.group-id}<span>&lt;/groupId&gt;<br/></span><span>      &lt;artifactId&gt;</span>${quarkus.platform.artifact-id}<span>&lt;/artifactId&gt;<br/></span><span>      &lt;version&gt;</span>${quarkus.platform.version}<span>&lt;/version&gt;<br/></span><span>      &lt;type&gt;</span>pom<span>&lt;/type&gt;<br/></span><span>      &lt;scope&gt;</span>import<span>&lt;/scope&gt;<br/></span><span>    &lt;/dependency&gt;<br/></span><span>  &lt;/dependencies&gt;<br/></span><span>&lt;/dependencyManagement&gt;<br/></span><span>&lt;build&gt;<br/></span><span>  &lt;plugins&gt;<br/></span><span>    &lt;plugin&gt;<br/></span><span>      &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>      &lt;artifactId&gt;</span>quarkus-maven-plugin<span>&lt;/artifactId&gt;<br/></span><span>      &lt;version&gt;</span>${quarkus-plugin.version}<span>&lt;/version&gt;<br/></span><span>      &lt;executions&gt;<br/></span><span>        &lt;execution&gt;<br/></span><span>          &lt;goals&gt;<br/></span><span>            &lt;goal&gt;</span>build<span>&lt;/goal&gt;<br/></span><span>          &lt;/goals&gt;<br/></span><span>        &lt;/execution&gt;<br/></span><span>      &lt;/executions&gt;<br/></span><span>    &lt;/plugin&gt;<br/>&lt;/build&gt;</span></pre>
<p>Moving into the dependencies section, you will see that the only runtime dependency that's been added is the following one, which allows you to execute a basic REST application:</p>
<pre>&lt;dependency&gt;<br/>   &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>   &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p><strong>RESTEasy</strong> is a portable implementation of the JAX-RS specification that is included by default in the WildFly application server (<a href="http://www.wildfly.org">http://www.wildfly.org</a>). You can use it to provide a  representation of your service through the standard HTTP methods using stateless communication.</p>
<p>Besides <kbd>quarkus-resteasy</kbd>, some other libraries have been included in your <kbd>pom.xml</kbd> file for the purpose of testing your applications. This will be discussed more in detail in the <em>Testing Quarkus applications</em> section.</p>
<div class="packt_tip">To add additional libraries to your project, besides editing the <kbd>pom.xml</kbd> file, you can also use <kbd>add-extension</kbd>, which can be found in Quarkus' Maven plugin. An example of this is <kbd>$ mvn quarkus:add-extension -Dextensions="io.quarkus:quarkus-jsonp,io.quarkus:quarkus-smallrye-health"</kbd>.</div>
<p>The following <kbd>SimpleRest</kbd> class has been automatically generated for you in <kbd>src/main/java/com/packt/quarkus/Chapter02</kbd>:</p>
<pre>import javax.ws.rs.GET;<br/>import javax.ws.rs.Path;<br/>import javax.ws.rs.Produces;<br/>import javax.ws.rs.core.MediaType;<br/> <br/>@Path("/helloworld")<br/>public class SimpleRest {<br/> <br/>     @GET<br/>     @Produces(MediaType.TEXT_PLAIN)<br/>     public String hello() {<br/>         return "hello";<br/>     }<br/>}</pre>
<p>As you can see, it's a very simple REST endpoint that leverages the JAX-RS API to produce a <kbd>TEXT_PLAIN</kbd> resource when the <kbd>/helloworld GET</kbd> requests lands on the default port.</p>
<div class="packt_tip"><strong>Simpler than JAX-RS!</strong><br/>
As we mentioned previously, Quarkus simplifies code development to provide sensible defaults. However, we don't need to declare an <kbd>ApplicationScoped</kbd> class to bootstrap the REST service anymore since we will get it as the default option.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Now, we are ready to run our application. Execute the <kbd>compile</kbd> and <kbd>quarkus:dev</kbd> goals to build it and run it:</p>
<pre><strong>$ mvn compile quarkus:dev</strong><span class="packt_screen"><br/></span></pre>
<p>After a few seconds, the application will be compiled and executed, as shown in the following log:</p>
<pre><strong>[INFO] Scanning for projects...</strong><br/><strong>. . . .</strong><br/><strong>[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello-rest ---</strong><br/><strong>[INFO] Using 'UTF-8' encoding to copy filtered resources.</strong><br/><strong>[INFO] Copying 2 resources</strong><br/><strong>[INFO] </strong><br/><strong>[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ hello-rest ---</strong><br/><strong>[INFO] Changes detected - recompiling the module!</strong><br/><strong>[INFO] Compiling 1 source file to /home/francesco/git/packt/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/chapter2/hello-rest/target/classes</strong><br/><strong>[INFO] </strong><br/><strong>[INFO] --- quarkus-maven-plugin:1.0.0.Final:dev (default-cli) @ hello-rest ---</strong><br/><strong>Listening for transport dt_socket at address: 5005</strong><br/><strong>2019-11-11 13:10:34,493 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation</strong><br/><strong>2019-11-11 13:10:35,078 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 585ms</strong><br/><strong>2019-11-11 13:10:35,395 INFO  [io.quarkus] (main) Quarkus 1.0.0.CR1 started in 1.079s. Listening on: http://0.0.0.0:8080</strong><br/><strong>2019-11-11 13:10:35,397 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.</strong><br/><strong>2019-11-11 13:10:35,397 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]</strong></pre>
<p>Now, you can request the provided endpoint with the browser or a tool such as <kbd>curl</kbd>:</p>
<pre><strong> $ curl http://localhost:8080/helloworld</strong><br/><strong> hello</strong></pre>
<p>You can stop the application with <em>Ctrl</em> + <em>C</em>, although we recommend keeping it running as we will be testing the <strong>hot reload </strong>feature soon!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Maven plugin to generate a Gradle project</h1>
                </header>
            
            <article>
                
<p>The Quarkus Maven plugin is pretty agnostic in spite of its name. As a matter of fact, you can also use it to generate <strong>Gradle</strong> projects. A comparison between the two tools is out of the scope of this book; however, a large number of developers prefer Gradle as a build tool since it's modeled in a way that is extensible in the most fundamental ways and has outstanding performance.</p>
<p>That being said, you can generate a Gradle project by simply setting the <kbd>buildTool</kbd> option to <kbd>gradle</kbd>, which otherwise defaults to <kbd>maven</kbd>. Here's how you can generate your project with Gradle:</p>
<pre><strong>mvn io.quarkus:quarkus-maven-plugin:1.0.0.Final:create \</strong><br/><strong> -DprojectGroupId=com.packt.quarkus.Chapter02 \</strong><br/><strong> -DprojectArtifactId=hello-rest \</strong><br/><strong> -DclassName="com.packt.quarkus.Chapter02.SimpleRest" \</strong><br/><strong> -Dpath="/helloworld" \</strong><br/><strong> -DbuildTool=gradle</strong></pre>
<p>The resulting <kbd>build.gradle</kbd> file defines the set of available repositories and dependencies and sets the core project attributes such as <kbd>quarkusPlatformGroupId</kbd>, <kbd>quarkusPlatformArtifactId</kbd>, and <kbd>quarkusPlatformVersion</kbd> as variables:</p>
<pre>buildscript {<br/>    repositories {<br/>        mavenLocal()<br/>    }<br/>    dependencies {<br/>        classpath "io.quarkus:quarkus-gradle-<br/>        plugin:${quarkusPluginVersion}"<br/>    }<br/>}<br/><br/>plugins {<br/>    id 'java'<br/>}<br/><br/>apply plugin: 'io.quarkus'<br/><br/>repositories {<br/>     mavenLocal()<br/>     mavenCentral()<br/>}<br/><br/>dependencies {<br/>    implementation enforcedPlatform("${quarkusPlatformGroupId}:<br/>    ${quarkusPlatformArtifactId}:${quarkusPlatformVersion}")<br/>    implementation 'io.quarkus:quarkus-resteasy'<br/><br/>    testImplementation 'io.quarkus:quarkus-junit5'<br/>    testImplementation 'io.rest-assured:rest-assured'<br/><br/>    nativeTestImplementation 'io.quarkus:quarkus-junit5'<br/>    nativeTestImplementation 'io.rest-assured:rest-assured'<br/>}<br/><br/>group 'org.acme'<br/>version '1.0.0-SNAPSHOT'<br/><br/>compileJava {<br/>    options.compilerArgs &lt;&lt; '-parameters'<br/>}<br/><br/>java {<br/>    sourceCompatibility = JavaVersion.VERSION_1_8<br/>    targetCompatibility = JavaVersion.VERSION_1_8<br/>}</pre>
<p>All the preceding variables are retrieved from the <kbd>gradle.properties</kbd> file, which is located at the root of your project.</p>
<p>As you can see from the configuration, a plugin is also included in the default project so that you can easily build your application and start it in development mode, as follows:</p>
<pre><strong>./gradlew quarkusDev</strong></pre>
<p>Finally, it is worth mentioning that the Gradle extension is still under development, so you may see some changes or updates in the next Quarkus releases.</p>
<p>Now, we will learn how to easily bootstrap our project (either Maven or Gradle) using the online Quarkus project generator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kick-starting applications using the Quarkus online application</h1>
                </header>
            
            <article>
                
<p>Another option for bootstrapping your Quarkus application is using the online application, which is available at the following address: <a href="https://code.quarkus.io/">https://code.quarkus.io/</a>.</p>
<p>By landing on that page, you will be able to generate a basic project with an initial endpoint, as well as all the extensions that you checked out in the user interface:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3c622c55-3ea0-45d9-9a42-06292b82d133.png" style=""/></div>
<p>As shown in the preceding screenshot, by default, just the <strong>RESTEasy</strong> extension is selected. From the top-left corner of the interface, you can configure your project coordinates (<kbd>groupId</kbd>, <kbd>artifactId</kbd>) and the build tool, which can be either Maven or Gradle. More options are available through the <span class="packt_screen">CONFIGURE MORE OPTIONS </span>panel, which lets you configure the package name and the version for the project.</p>
<div class="packt_infobox">By scrolling down the list of available extensions, you can also choose to experiment with alternative languages, such as Kotlin or Scala, to develop your Quarkus applications. These options are still work in progress, so consider that their API and/or configuration may change as the extension matures. The Quarkus team, however, does appreciate your feedback if you have tested any preview extension.</div>
<p>When you are done setting your options, just click on <span class="packt_screen">Start a new application</span> to download the artifact as a compressed folder:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/fa7d5fd7-53b9-45db-aa92-46af103a3160.png" style=""/></div>
<p>Now, you can just unpack it and import it into your favorite IDE. We will do this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing live reload from your IDE</h1>
                </header>
            
            <article>
                
<p>In this section, we will use the live reload feature of Quarkus. For this purpose, we will import the project into our IDE so that we can apply some changes.</p>
<p>Navigate to <span class="packt_screen">File | Open</span> and point to the folder where you created the Maven project. It will be automatically imported into your IDE. Here is the <span class="packt_screen">Files</span> tab view of your Java classes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/67711f22-3b2e-4118-ba1c-3d3d6730d0be.png" style=""/></div>
<p>Now, let's look at how live reload works with Quarkus. For this, let's apply a simple change to our code. Here, we have modified the return value for the <kbd>hello</kbd> method, as follows:</p>
<pre>public class SimpleRest {<br/> <br/>     @GET<br/>     @Produces(MediaType.TEXT_PLAIN)<br/>     public String hello() {<br/><strong>         return "hello changed!";</strong><br/>     }<br/> }          </pre>
<p>Hopefully, you haven't stopped your server. Now, try to call the service once more:</p>
<pre><strong>$ curl http://localhost:8080/helloworld</strong><br/> <strong>hello changed!</strong></pre>
<p>As you can see, when running in development mode, you can have a live reload of your application. Amazing, isn't it?</p>
<p>Live reload also works for resource files such as web pages or the configuration property file. Requesting the service triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed. Your request is then serviced by the redeployed application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging applications</h1>
                </header>
            
            <article>
                
<p>When running in development mode, Quarkus will automatically listen for a debugger on port <kbd>5005</kbd>. You can check that the debugging is active with a basic shell command, as follows:</p>
<pre><strong>$ netstat -an | grep 5005</strong><br/><strong> tcp        0      0 0.0.0.0:5005            0.0.0.0:*               LISTEN </strong>    </pre>
<p>Now, let's undo these changes in the <kbd>hello</kbd> method and include another <kbd>hello</kbd> method, which receives a parameter to be inspected as input:</p>
<pre>package com.packt.quarkus.chapter2;<br/><br/>import javax.ws.rs.GET;<br/>import javax.ws.rs.Path;<br/>import javax.ws.rs.Produces;<br/>import javax.ws.rs.PathParam;<br/>import javax.ws.rs.core.MediaType;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/><br/>@Path("/helloworld")<br/>public class SimpleRest {<br/>    protected final Logger log = LoggerFactory.getLogger(this.getClass());<br/><strong>    @GET</strong><br/><strong>    @Produces(MediaType.TEXT_PLAIN)</strong><br/><strong>    @Path("/{name}")</strong><br/><strong>    public String hello(@PathParam("name") String name) {</strong><br/><br/><strong>        log.info("Called with "+name);</strong><br/><strong>        return "hello "+name;</strong><br/><strong>    }</strong><br/><br/>    @GET<br/>    @Produces(MediaType.TEXT_PLAIN)<br/>    public String hello() {<br/>        return "hello";<br/>    }<br/>} </pre>
<p>By using the <kbd>@PathParam</kbd> expression in our REST service, we will be able to debug the value of this expression as a method variable from within our IDE. Now, place a breakpoint on the logging statement, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/72d2ab1d-e6b6-460a-8d49-938e69a36da4.png" style=""/></div>
<p>Next, in order to attach the IntelliJ IDEA to the debugger, you have to connect to the debugger's port. In IntelliJ IDEA, you can do this in various ways. The simplest way is to select <span class="packt_screen">Run | Attach to Process</span>. The runnable process of your application will be detected, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78ff72c9-472d-4f4f-9abf-9b5fb326f637.png" style=""/></div>
<p>Select it and check that you managed to attach to it successfully. You can do this from the <span class="packt_screen">Debugger</span> <span class="packt_screen"><span class="packt_screen">C</span>onsole</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5f7147f7-c716-4343-b4a1-25d0b2d4da2c.png" style=""/></div>
<p>Now, invoke the application by adding an extra parameter at the end of it so that you hit the breakpoint:</p>
<pre><strong> $ curl http://localhost:8080/helloworld/frank</strong></pre>
<p>From the debugger prompt, you can inspect the class and method variables from its console. You can also control the execution path (<span class="packt_screen">Step Over</span>, <span class="packt_screen">Step Into</span>, <span class="packt_screen">Stop</span>, and many more) by clicking on the buttons located on the left-hand side of the <span class="packt_screen">Debugger</span> <span class="packt_screen"><span class="packt_screen">C</span>onsole</span>, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed190009-53dc-4505-b590-30e79d11bd96.png" style=""/></div>
<p>If you want to wait for the debugger to attach before starting your Quarkus application, you can pass <kbd>-Ddebug</kbd> on the command line. As soon as your IDE's debugger connects, the Quarkus Augmentor will start and your application will be executed. On the other hand, if you don't want the debugger at all, you can use <kbd>-Ddebug=false</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing Quarkus applications</h1>
                </header>
            
            <article>
                
<p>Along with the sample endpoint, the Maven plugin automatically included a test class for our REST service:</p>
<pre>package com.packt.quarkus.chapter2;<br/> <br/>import io.quarkus.test.junit.QuarkusTest;<br/>import org.junit.jupiter.api.Test;<br/> <br/>import static io.restassured.RestAssured.given;<br/>import static org.hamcrest.CoreMatchers.is;<br/> <br/>@QuarkusTest<br/>public class SimpleRestTest {<br/> <br/>     @Test<br/>     public void testHelloEndpoint() {<br/>         given()<br/>           .when().get("/helloworld")<br/>           .then()<br/>              .statusCode(200)<br/>              .body(is("hello"));<br/>     }<br/> <br/>}</pre>
<p>Under the hood, this test class uses JUnit as the core testing framework and the REST Assured library:</p>
<pre>&lt;dependency&gt;<br/>   &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>   &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;<br/>   &lt;scope&gt;test&lt;/scope&gt;<br/> &lt;/dependency&gt;<br/> &lt;dependency&gt;<br/>   &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;<br/>   &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;<br/>   &lt;scope&gt;test&lt;/scope&gt;<br/> &lt;/dependency&gt;</pre>
<p><strong>REST Assured</strong> is a Java library that can be used to write powerful tests for REST APIs using a flexible <strong>Domain Specific Language</strong> (<strong>DSL</strong>). The Fluent API that's available in REST Assured supports the standard patterns from <strong>Behavior-Driven Development</strong> (<strong>BDD</strong>) with its <kbd>Given/When/Then</kbd> syntax. The resulting test is simple to read and can include all the steps that we need in order to build the test with just one line of code.</p>
<p>Now, we can verify the response body's content and check that the HTTP response status code is 200. We can verify the test's execution by running the following command:</p>
<pre><strong>$ mvn clean test</strong></pre>
<p>You should see the following output in your console:</p>
<pre><strong>[INFO] Running com.packt.quarkus.chapter2.SimpleRestTest</strong><br/><strong> 2019-05-16 11:04:21,166 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation</strong><br/><strong> 2019-05-16 11:04:21,832 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 669ms</strong><br/><strong> 2019-05-16 11:04:22,108 INFO  [io.quarkus] (main) Quarkus 1.0.0.Final started in 0.265s. Listening on: http://[::]:8081</strong><br/><strong> 2019-05-16 11:04:22,109 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]</strong><br/><strong> [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.958 s - in com.packt.quarkus.chapter2.SimpleRestTest</strong><br/><br/><strong>2019-05-16 11:04:23,263 INFO </strong><br/><br/><strong>[io.quarkus] (main) Quarkus stopped in 0.005s</strong><br/><strong> [INFO]</strong><br/><strong> [INFO] Results:</strong><br/><strong> [INFO]</strong><br/><strong> [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</strong><br/><strong> [INFO]</strong><br/><strong> [INFO] -----------------------------------------------------------------------</strong><br/><strong> [INFO] BUILD SUCCESS</strong><br/><strong> [INFO] -----------------------------------------------------------------------</strong></pre>
<p>As you can see, the test started the Quarkus runtime on the local IP address at port <kbd>8081</kbd>. Therefore, it doesn't interfere with the development/production environment that runs on port <kbd>8080</kbd> by default.</p>
<p>You can mix and match multiple conditions in your tests by concatenating them using the <kbd>and()</kbd> method. This method works as simple syntactic sugar, that is, it helps make the code more readable. Here's an example of how to include a check on the header's <kbd>Content-Length</kbd>:</p>
<pre>@Test<br/><span>public void </span>testHelloEndpointHeader() {<br/>    given()<br/>      .when().get(<span>"/helloworld"</span>)<br/>         .then()<br/>         .statusCode(<span>200</span>)<br/>         .body(is(<span>"hello</span><span>"</span>))<br/>           .and()<br/>            .header(<span>"Content-Length"</span><span>,</span><span>"6"</span>)<span>;<br/></span>}</pre>
<p>By using parameterized tests, you can test multiple scenarios within a single method by providing different sets of records. REST Assured supports two different types of parameters:</p>
<ul>
<li><strong>Query parameters</strong>: These can be appended at the end of a RESTful API endpoint and are identified by the question mark in front of them. Here's an example:</li>
</ul>
<pre style="padding-left: 60px">@Test<br/><span>public void </span>testHelloEndpointQueryParam() {<br/>    given()<br/>      .param(<span>"name"</span><span>,</span><span>"Frank"</span>)<br/>      .when().get(<span>"/helloworld"</span>)<br/>         .then()<br/>         .statusCode(<span>200</span>)<br/>         .body(is(<span>"hello</span><span>"</span>))<span>;<br/></span><span><br/></span>}</pre>
<p style="padding-left: 90px">As you can see, using query parameters only requires that we specify their name and value by concatenating the <kbd>param()</kbd> method.</p>
<ul>
<li><strong>Path parameters</strong>: These are specified in a similar fashion, that is, by including the <kbd>pathParam()</kbd> method with the parameter name/value combination:</li>
</ul>
<pre style="padding-left: 60px">@Test<br/><span>public void </span>testHelloEndpointPathParam() {<br/><br/> given()<br/> .pathParam(<span>"name"</span><span>, </span><span>"Frank"</span>)<br/> .when().get(<span>"/helloworld/{name}"</span>)<br/> .then()<br/> .statusCode(<span>200</span>)<br/> .body(is(<span>"hello Frank"</span>))<span>;<br/></span>}</pre>
<p>Finally, it's worth mentioning that, since Quarkus aims at top performance, you can also validate your tests based on the response time. This can be done by concatenating <kbd>time()</kbd> to your condition. Here is an example that sets the time to be less than one second when it comes to returning the response:</p>
<pre>@Test<br/><span>public void </span>testTimedHelloEndpointPathParam() {<br/><br/> given()<br/> .pathParam(<span>"name"</span><span>, </span><span>"Frank"</span>)<br/> .when().get(<span>"/helloworld/{name}"</span>)<br/> .then()<br/> .time(lessThan(<span>1000L</span>))<br/> .body(is(<span>"hello Frank"</span>))<span>;</span><span><br/></span>}</pre>
<p>In this section, we have covered the most common testing scenarios that we can build with the REST Assured API. If you want to checkout some more advanced patterns, we recommend having a look at its Wiki, which is available at <a href="https://github.com/rest-assured/rest-assured/wiki/usage">https://github.com/rest-assured/rest-assured/wiki/usage</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing a different port for testing</h1>
                </header>
            
            <article>
                
<p>You can change the default port that's used for testing by Quarkus (<kbd>8081</kbd>) by setting an appropriate value in the <kbd>src/main/resources/application.properties</kbd> file, which is the general configuration file for Quarkus. For example, in order to shift the test port to <kbd>9081</kbd>, you would need to add the following information to <kbd>application.properties</kbd>:</p>
<pre>quarkus.http.test-port=9081</pre>
<div class="packt_tip">As an alternative, you can also use the same property at startup by passing the <kbd>-Dquarkus.http.test-port=9081</kbd> flag.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Turning your application into a native executable</h1>
                </header>
            
            <article>
                
<p>Now, it's time to check what Quarkus can do to turn our bytecode into a native executable. This kind of magic is done under the hood by a Maven profile named <kbd>native</kbd>, which is included out of the box when you scaffold your application:</p>
<pre><span>&lt;profile&gt;<br/></span><strong><span>  &lt;id&gt;</span>native</strong><span><strong>&lt;/id&gt;</strong><br/></span><span>  &lt;activation&gt;<br/></span><span>    &lt;property&gt;<br/></span><span>      &lt;name&gt;</span>native<span>&lt;/name&gt;<br/></span><span>    &lt;/property&gt;<br/></span><span>  &lt;/activation&gt;<br/></span><span>  &lt;build&gt;<br/></span><span>    &lt;plugins&gt;<br/></span><span>      &lt;plugin&gt;<br/></span><span>        &lt;artifactId&gt;</span>maven-failsafe-plugin<span>&lt;/artifactId&gt;<br/></span><span>        &lt;version&gt;</span>${surefire-plugin.version}<span>&lt;/version&gt;<br/></span><span>        &lt;executions&gt;<br/></span><span>          &lt;execution&gt;<br/></span><span>            &lt;goals&gt;<br/></span><span>              &lt;goal&gt;</span>integration-test<span>&lt;/goal&gt;<br/></span><span>              &lt;goal&gt;</span>verify<span>&lt;/goal&gt;<br/></span><span>            &lt;/goals&gt;<br/></span><span>            &lt;configuration&gt;<br/></span><span>              &lt;systemProperties&gt;<br/></span><span>                &lt;native.image.path&gt;</span>${project.build.directory}<br/>                  /${project.build.finalName}-runner<br/>                <span>&lt;/native.image.path&gt;<br/></span><span>              &lt;/systemProperties&gt;<br/></span><span>            &lt;/configuration&gt;<br/></span><span>          &lt;/execution&gt;<br/></span><span>        &lt;/executions&gt;<br/></span><span>      &lt;/plugin&gt;<br/></span><span>    &lt;/plugins&gt;<br/></span><span>  &lt;/build&gt;<br/></span><span>  &lt;properties&gt;<br/></span><span>    &lt;quarkus.package.type&gt;</span>native<span>&lt;/quarkus.package.type&gt;<br/></span><span>  &lt;/properties&gt;<br/></span><span>&lt;/profile&gt;</span></pre>
<p>In addition, <kbd>maven-failsafe-plugin</kbd> <span>has been automatically configured to run <kbd>integration-test goal</kbd> since we've set the path where the native image has been built as the system property. </span></p>
<div class="packt_infobox">Before building your executable, verify that you have set <kbd>GRAALVM_HOME</kbd> in your environment, as described in the previous chapter.</div>
<p>Next, create a native executable by executing the following command:</p>
<pre>$ <strong>mvn package -Pnative</strong></pre>
<p>The plugin will start analyzing the classes and packaging that's used in your application, along with the call tree. The resulting output will be a super lean executable that contains just a thin JVM layer (narrow enough to just execute the application) and the application itself.</p>
<p>You should see something similar to the following at the end of your output:</p>
<pre><strong>[INFO] [io.quarkus.deployment.QuarkusAugmentor] Quarkus augmentation completed in 60485ms</strong></pre>
<p>Along with the JAR file containing the compressed bytecode for your application, the following executable will be generated in the <kbd>target</kbd> folder:</p>
<pre>Nov 11 14:49 hello-rest-1.0-SNAPSHOT-runner</pre>
<div class="packt_infobox">The actual name of your application can be varied by setting the <kbd>native.image.path</kbd> environment variable in your <kbd>pom.xml</kbd> file, which is <kbd>${project.build.directory}/${project.build.finalName}-runner</kbd> by default.</div>
<p>As you can see, with approximately 20 MB, we have an executable application runtime that contains all the libraries and just what it needs from the JVM to run our application. You can execute it with the following command:</p>
<pre>$ <strong>target/hello-rest-1.0-SNAPSHOT-runner</strong></pre>
<p>In as little as 0.006s, we got our service up and running. This can be seen in the console log:</p>
<pre>2019-11-11 14:53:38,619 INFO  [io.quarkus] (main) hello-rest 1.0-SNAPSHOT (running on Quarkus 1.0.0.CR1) started in 0.014s. Listening on: http://0.0.0.0:8080<br/>2019-11-11 14:53:38,619 INFO  [io.quarkus] (main) Profile prod activated. <br/>2019-11-11 14:53:38,619 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]</pre>
<p>Let's check the memory usage of this compact application by executing the <kbd>ps</kbd> command:</p>
<pre><strong>$ ps -o pid,rss,command -p $(pgrep -f hello-rest)</strong></pre>
<p>Here is the output I have collected from my laptop:</p>
<pre><strong>PID   RSS   COMMAND</strong><br/><strong>27919 18720 target/hello-rest-1.0-SNAPSHOT-runner</strong></pre>
<p>Although the output may vary depending on your environment, the <strong>Resident Set Size</strong> (<strong>RSS</strong>) shows that the process is taking about 18 MB of memory, which is a fraction of the minimum memory size required for a Java application.</p>
<p>Now, let's execute it to check the result:</p>
<pre><strong>$ curl http://localhost:8080/helloworld</strong><br/><strong> hello</strong></pre>
<p>As you can see, the result didn't change when we turned our application into a native application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing integration tests against the native executable</h1>
                </header>
            
            <article>
                
<p>Interestingly, native executable code can be tested. When you generated the sample project, a <kbd>Native&lt;project&gt;Test</kbd> class name was included in the test folder. This class differs from Java tests as it's annotated with the <kbd>@NativeImageTest</kbd> annotation.</p>
<div class="packt_infobox"><span class="blob-code-inner blob-code-marker">As a result of the Maven failsafe plugin configuration, all rests ending in <em>*IT</em> or annotated with <kbd>@<span class="x x-first x-last">NativeImageTest</span></kbd> will be run against the native executable.</span></div>
<p>In terms of code, there's no need to make any changes as it uses inheritance to execute the native executable tests from our <kbd>SimpleRestTest</kbd> class:</p>
<pre><span>@NativeImageTest<br/></span><span>public class </span>NativeSimpleRestIT <span>extends </span>SimpleRestTest {<br/><br/>    <span>// Execute the same tests but in native mode.<br/></span>}</pre>
<p>The <kbd>verify</kbd> goal is required to test native executables. Before that, make sure you have exported the path where <span>GraalVM</span> has been installed into your environment:</p>
<pre class="selectionShareable"><span><strong>expor</strong></span><span><strong>t GRAALVM_HOME=</strong></span><strong><span>/path/to/graal</span></strong></pre>
<p>Now, you can run the <kbd>verify</kbd> goal to test the native executable application:</p>
<pre><strong>$ mvn verify -Pnative</strong></pre>
<p>Check that the outcome is the same one that we produced in the <em>Testing Quarkus applications</em> section, earlier in this chapter:</p>
<pre><strong>[INFO] Running com.packt.quarkus.chapter2.SimpleRestTest</strong><br/><strong> 2019-05-16 11:35:22,509 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation</strong><br/><strong> 2019-05-16 11:35:23,084 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 575ms</strong><br/><strong> 2019-05-16 11:35:23,419 INFO  [io.quarkus] (main) Quarkus 1.0.0.Final started in 0.319s. Listening on: http://[::]:8081</strong><br/><strong> 2019-05-16 11:35:23,419 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]</strong><br/><strong> 2019-05-16 11:35:24,354 INFO  [com.pac.qua.cha.SimpleRest] (XNIO-1 task-1) Called with Frank</strong><br/><strong> 2019-05-16 11:35:24,598 INFO  [com.pac.qua.cha.SimpleRest] (XNIO-1 task-1) Called with Frank</strong><br/><strong> [INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.215 s - in com.packt.quarkus.chapter2.SimpleRestTest</strong></pre>
<p>Great! We have just managed to test our sample application in both scenarios (JVM and native executable).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we went through our first proof of concept Quarkus project, which was generated through <kbd>quarkus-maven-plugin</kbd>. The default application is a prototype of the REST service with all the minimal functionalities and a <kbd>Test</kbd> class that we have progressively enriched. In the second part of this chapter, we saw how to turn the Java application code into a thin native executable using the appropriate native profile of <kbd>quarkus-maven-plugin</kbd>.</p>
<p>So far, we have only scratched the surface of what we can do with Quarkus. Now, it's time to move on and learn how to create a <span>Containe</span><span>r</span> <span>image out of our native application and deploy it in a Kubernetes environment. This is what we are going to discuss in the next chapter.</span></p>


            </article>

            
        </section>
    </body></html>