<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Artificial Intelligence"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Artificial Intelligence</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Wisdom begins with Wonder."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Socrates</em></span></span></td></tr></table></div><p>We looked at moving, controlling, detecting collisions between, and animating Greenfoot actors up to now in this book. What we will look at in this chapter, is giving our actors a semblance of intelligent behavior. Doing so will allow us to tell better stories and create more engaging user interactions.</p><p>Now, the field of <a id="id454" class="indexterm"/><span class="strong"><strong>Artificial Intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>) is very complex, and creating truly intelligent behavior for our actors is beyond the scope of this book. However, there are some simple techniques we can use to simulate various levels of intelligent behavior using probability and heuristics. We will then look at a popular algorithm (used in many AAA games) that will allow an actor to traverse a path through a set of obstacles. Specifically, you will learn how to apply the following to simulate intelligence:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Randomness</li><li class="listitem">Behavior heuristics</li><li class="listitem">A* (pronounced A-star) pathfinding</li></ul></div><p>Throughout this book, you have been acquiring the skills to create the<a id="id455" class="indexterm"/> <span class="emphasis"><em>wow</em></span> factor in your applications, animations, and games. Adding simple AI techniques to your repertoire is going to elevate your ability to create and be creative. The more wisdom you have around Java programming, the more wonder you will be able to provide to your audience.</p><div class="section" title="The MazeWorld scenario"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>The MazeWorld scenario</h1></div></div></div><p>In the <a id="id456" class="indexterm"/>preceding chapter, we learned how to<a id="id457" class="indexterm"/> create tile-based worlds. We will augment the Hiking World scenario we created using the tile-based method to create our new scenario entitled <code class="literal">MazeWorld</code>. In this scenario, our hero will need to navigate around obstacles and avoid three intelligent actors, in order to reach the gold at the end of the maze. <span class="emphasis"><em>Figure 1</em></span> contains a screenshot of the completed scenario.</p><div class="mediaobject"><img src="../Images/image00315.jpeg" alt="The MazeWorld scenario"/><div class="caption"><p>Figure 1: This is the completed version of MazeWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p>There are a few<a id="id458" class="indexterm"/> significant differences between the <code class="literal">HikingWorld</code> scenario from the previous chapter and the new <code class="literal">MazeWorld</code> scenario we are building in this chapter. The redundant area will be quickly explained, and we will slow down and explain in detail the changes necessary to create our intelligent actors. Please review <a class="link" title="Chapter 6. Scrolling and Mapped Worlds" href="part0042.xhtml">Chapter 6</a>, <span class="emphasis"><em>Scrolling and Mapped Worlds</em></span>, if needed, for a full description of tile-based world creation.</p><div class="section" title="The MazeWorld class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec65"/>The MazeWorld class</h2></div></div></div><p>Create a <a id="id459" class="indexterm"/>new scenario and call it <code class="literal">MazeWorld</code>. In the<a id="id460" class="indexterm"/> new scenario, create a subclass of the <code class="literal">World</code> class entitled <code class="literal">MazeWorld</code>. Choose <span class="strong"><strong>no image</strong></span> as the image for this scenario. Here is the implementation of the <code class="literal">MazeWorld</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;
import java.util.Stack;

public class MazeWorld extends World {
  private int xOffset = 0;
  private Hiker hiker;
  private final static int SWIDTH = 600;
  private final static int SHEIGHT = 400;
  private final static int WWIDTH = 1200;
  private final static int TWIDTH = 25;
  private final static int THEIGHT = TWIDTH;
  private final static int TILEOFFSET = TWIDTH/2;
  private final static String validSpaces = "WG";
  
  private final static String[] WORLD = {
    "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWB",
    "BWWWWWWWWWWWWWUUWWWWWWWWUUUUUUUWWWWWWWWWWWUWWWWB",
    "BWWWWWUUUUUWWWUUUWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWB",
    "BWWWWWUUUUUWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWUUUWWWB",
    "BWWWWWWWWWWWWWWWWWUUUUUWWWWWWWWUUUUUUWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWUUUUWWWWWWWWWUUUUUUUUWWWWWWWWB",
    "BWWWWUUUUUUUWWWUWWWWWWWWWWWWWWWUWWWWWWWWWWWWWWWB",
    "BWWWWWWWUUUWWWWUWWWWWWWWWWUWWWWUWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWWWWWWWWWWWWWWUWWB",
    "BWWWWWWWWWWWWWWWWWWWUUUUUUUWWWWWWWWWUUUUWWWWUWWB",
    "BWWWWWWWWWWWWWUUWWWWUWWWWWWWWWWWWWWWUUUUWWWWUWWB",
    "BWWWWWWWUUUUUUUUUWWWWWWWWWWWWWWWWWWWUUUUUUWWUWWB",
    "BWWWWWWWUUUUUUUUUWWWWWWWWWUUWWWWWWWWWWWWWWWWUWWB",
    "BWWWWWWWUWWWWWWWWWWWWWWWWWUUWWWWWWWWWWWWWWWWUWGB",
    "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
  };

  public MazeWorld() {  
    super(SWIDTH, SHEIGHT, 1, false); 
    createWorldFromTiles();
    shiftWorld(0);    
    prepare();
  }

  public void shiftWorld(int dx) {
    if( (xOffset + dx) &lt;= 0 &amp;&amp; (xOffset + dx) &gt;= SWIDTH - WWIDTH) {
      xOffset = xOffset+dx;
      shiftWorldActors(dx);
    }
  }
  
private void shiftWorldActors(int dx) {
    List&lt;ScrollingActor&gt; saList = getObjects(ScrollingActor.class);
    for( ScrollingActor a : saList ) {
      a.setAbsoluteLocation(dx);
    }
  }
  
  private void createWorldFromTiles() {
    for( int i=0; i &lt; WORLD.length; i++ ) {
      for( int j=0; j &lt; WORLD[i].length(); j++ ) {
        addActorAtTileLocation(WORLD[i].charAt(j), j, i);
      }
    }
  }
  
  private void addActorAtTileLocation(char c, int x, int y) {
    Actor tile = null;
    switch(c) {
      case 'W':
        tile = new WhiteBlock();
        break;
      case 'B':
        tile = new BlackBlock();
        break;
      case 'U':
        tile = new BlueBlock();
        break;
      case 'G':
        tile = new GoldBlock();
        break;
    }
    if( tile != null) addObject(tile, TILEOFFSET+x*TWIDTH, TILEOFFSET+y*THEIGHT);
    
  }

 public int getTileWidth() {
    return TWIDTH;
  }
  
  public int getTileHeight() {
    return THEIGHT;
  }
  
  public int getTileOffset() {
    return TILEOFFSET;
  }
  
  public String[] getStringWorld() {
    return WORLD;
  }
  
  public int getXHiker() {
    return hiker.getX()-xOffset;
  }
  
  public int getYHiker() {
    return hiker.getY();
  }
  
  public String getValidSpaces() {
    return validSpaces;
  }

  private void prepare()
  {
    hiker = new Hiker();
    addObject(hiker, 80, 200);
    addObject(new Mouse(), 60,40);
    addObject(new Spider(), 1000,40);
    addObject(new Spider(), 120,340);
    addObject(new Spider(), 1050,250);
    addObject(new Snake(), 1050,250);
    addObject(new Mouse(), 1000,200);
    addObject(new Snake(), 400,260);
  }
}</pre></div><p>We first start by<a id="id461" class="indexterm"/> declaring all of the instance<a id="id462" class="indexterm"/> variables for this class. We added the <code class="literal">TILEOFFSET</code> constant (used to record half of the value of the width of a tile) and <code class="literal">String validspaces</code> (used to indicate which tiles our hero can walk on). The <code class="literal">WORLD</code> array defines the tile's type and placement in our world. We augmented the <code class="literal">WORLD</code> array to create various static obstacles with the letter <code class="literal">U</code> and added a goal destination in the lower-right corner via the letter <code class="literal">G</code>. The <code class="literal">W</code> character designates the walkable background area and <code class="literal">B</code> designates an impassable area.</p><p>The <code class="literal">shiftWorld</code>, <code class="literal">shiftWorldActors</code>, and <code class="literal">createWorldFromTiles</code> methods and the constructor are the same as they were in <code class="literal">HikingWorld</code>. The <code class="literal">addActorAtTileLocation</code> method simply had one case added to the <code class="literal">switch</code> statement to handle the creation and placement of gold tiles. Getting to the gold tiles is the goal of this scenario.</p><p>The following<a id="id463" class="indexterm"/> methods were added to provide an<a id="id464" class="indexterm"/> easy way to access information contained in our world: <code class="literal">getTileWidth</code>, <code class="literal">getTileHeight</code>, <code class="literal">getTileOffset</code>, <code class="literal">getStringWorld</code>, <code class="literal">getXHiker</code>, <code class="literal">getYHiker</code>, and <code class="literal">getValidSpaces</code>. We will see their use in the classes we define in this chapter. The last method provided in the implementation of <code class="literal">MazeWorld</code> is <code class="literal">prepare()</code>, which is, by default, used to place the initial actors in our world.</p></div><div class="section" title="The Hiker class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec66"/>The Hiker class</h2></div></div></div><p>Our<a id="id465" class="indexterm"/> <code class="literal">Hiker</code> class is the same as the one we saw in the previous chapter in <code class="literal">HikingWorld,</code> except that<a id="id466" class="indexterm"/> we have expanded the ability of this class to move up and down as well. Moving in two dimensions was covered in previous chapters, and we will provide a summary explanation of this class. Here is the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Hiker extends Actor
{
  private static final int SPEED = 2;
  private static final int BOUNDARY = 40;
  private int speedX = SPEED;
  private int speedY = SPEED;
  
  public void act() {
    handleKeyPresses();
    handleCollisions();
    boundedMove();
  }
  
  private void handleKeyPresses() {
    handleArrowKey("left", -SPEED, 0);
    handleArrowKey("right", SPEED, 0);
    handleArrowKey("up", 0, -SPEED);
    handleArrowKey("down", 0, SPEED);
  }
  
  private void handleArrowKey(String k, int sX, int sY) {
    if( Greenfoot.isKeyDown(k) ) {
      speedX = sX;
      speedY = sY;
    }
  }
  
  private void handleCollisions() {
    if( isTouching(ScrollingEnemy.class) ) {
      Greenfoot.stop(); // Game Over
    }
  }
  
  private void boundedMove() {
    setLocation(getX()+speedX, getY()+speedY);
    if( isTouching(ScrollingObstacle.class) ) {
      setLocation(getX()-speedX, getY()-speedY);
    } else if( isTouching(GoldBlock.class) ) {
      Greenfoot.stop(); // Game over...you Win!!
    }else if( getX() &gt; getWorld().getWidth() - BOUNDARY ) {
      ((MazeWorld)getWorld()).shiftWorld(-speedX);
      setLocation(getX()-speedX, getY()-speedY);
    } else if( getX() &lt; BOUNDARY ) {
      ((MazeWorld)getWorld()).shiftWorld(-speedX);
      setLocation(getX()-speedX, getY()-speedY);
    }
    speedX = 0;
    speedY = 0;
  }
}</pre></div><p>The code for<a id="id467" class="indexterm"/> the <code class="literal">Hiker</code> class handles the left, right, up, and <a id="id468" class="indexterm"/>down arrow key presses and ensures that the actor does not walk through obstacles and calls <code class="literal">shiftWorld()</code> appropriately. It also checks for collision with one of the <code class="literal">ScrollingEnemy</code> actors and stops the game if there is a collision.</p><p>The code for handling up and down movement mirrors the code to handle left and right movement. The <code class="literal">handleKeyPresses()</code> and <code class="literal">boundedMove()</code>methods have been extended by simply adding the cases for up and down movement.</p></div><div class="section" title="Scrolling actor"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec67"/>Scrolling actor</h2></div></div></div><p>The<a id="id469" class="indexterm"/> <code class="literal">ScrollingActor</code> class is the same as it was<a id="id470" class="indexterm"/> in the previous chapter, and we reproduce it here for completeness:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class ScrollingActor extends Actor {
  public void setAbsoluteLocation(int dx) {
    setLocation(getX()+dx, getY());
  }
}</pre></div><p>There are <a id="id471" class="indexterm"/>four classes that subclass <code class="literal">ScrollingActor</code>. The first two are the implementations of <code class="literal">GoldBlock</code> and <code class="literal">WhiteBlock</code>. These two actors are the parts of the background<a id="id472" class="indexterm"/> world that are walkable and thus do not need any special handling. Make sure when you create them, that you associate an image of a gold block and an image of a white block, respectively. Here is the code for both:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class GoldBlock extends ScrollingActor {
}
import greenfoot.*;

public class WhiteBlock extends ScrollingActor {
}</pre></div><p>The other two subclasses of <code class="literal">ScrollingActor</code> are intended to be subclassed (note that they do not have an image associated with them) and help us group actors into one of two categories: obstacles or enemies. We will discuss these two subclasses next.</p><div class="section" title="The ScrollingObstacle class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec51"/>The ScrollingObstacle class</h3></div></div></div><p>This <a id="id473" class="indexterm"/>class does not add any additional functionality. It merely <a id="id474" class="indexterm"/>serves as a convenient way to group tiles that instances of the <code class="literal">Hiker</code> class cannot pass through. This makes it easier to perform collision detection in the <code class="literal">Hiker</code> class. Here is the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class ScrollingObstacle extends ScrollingActor {
}</pre></div><p>We only have two obstacle tiles: <code class="literal">BlackBlock</code> and <code class="literal">BlueBlock</code>. When you create these, make sure you associate the appropriate images (as we did in the previous chapter) with each other. Here is the code for both:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class BlackBlock extends ScrollingObstacle {
}
import greenfoot.*;

public class BlueBlock extends ScrollingObstacle {
}</pre></div><p>We are now in a position to describe the implementation of the classes that exhibit intelligent behavior.</p></div></div></div></div>
<div class="section" title="Intelligently behaving actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Intelligently behaving actors</h1></div></div></div><p>We are now <a id="id475" class="indexterm"/>going to add enemies to our <code class="literal">MazeWorld</code> scenario that implement different methods of simulating intelligent behavior. The <a id="id476" class="indexterm"/>first method we will discuss uses probabilistic movement, the second method uses simple heuristics, and the last method uses the <span class="strong"><strong>A* pathfinding</strong></span> algorithm to guide actor movement. Before discussing each method, we present the <code class="literal">ScrollingEnemy</code> class that implements a <a id="id477" class="indexterm"/>common structure for intelligently behaving actors.</p><div class="section" title="The ScrollingEnemy class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec68"/>The ScrollingEnemy class</h2></div></div></div><p>The<a id="id478" class="indexterm"/> class <code class="literal">ScrollingEnemy</code> inherits from <a id="id479" class="indexterm"/><code class="literal">ScrollingActor</code>, so it will be placed properly within a scrolling world. Then, it sets up a pattern of behavior that is conducive to intelligently moving actors. Modeling actual sentient animals, <code class="literal">ScrollingEnemy</code> provides a three-phase action-taking process in its <code class="literal">act()</code> method. First, it calls a method that requires the actor to sense its environment, then it calls a method to choose a course of action based on what it has sensed, and then it calls a method to move the actor. Please note that this class is <code class="literal">abstract</code> and cannot be instantiated directly.</p><p>Here is the code for <code class="literal">ScrollingEnemy</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

abstract public class ScrollingEnemy extends ScrollingActor {
  protected static final int SPEED = 1;
  private static final int BOUNDARY = 40;
  protected int speedX = SPEED;
  protected int speedY = SPEED;
  
  protected void addedToWorld(World w) {
    MazeWorld mw = (MazeWorld) w;
    GreenfootImage img = getImage();
    img.scale(mw.getTileWidth(),mw.getTileHeight());
    setImage(img);
  }
  
  public void act() {
    sense();
    reaction();
    boundedMove();
  }
  
  protected void sense() {
    // No smarts
  }
  
  protected void reaction() {
    // No reaction
  }
  
  protected void boundedMove() {
    setLocation(getX()+speedX, getY()+speedY);
    if( isTouching(ScrollingObstacle.class) ) {
      setLocation(getX()-speedX, getY()-speedY);
    }
  }
}</pre></div><p>The <code class="literal">sense()</code> and <code class="literal">reaction()</code> methods<a id="id480" class="indexterm"/> are empty, as they are intended <a id="id481" class="indexterm"/>to be overridden by subclasses implementing one of our strategies for intelligent movement. The end result of these methods are that they will change the values of the variables <code class="literal">speedX</code> and <code class="literal">speedY</code> to affect movement. The last method, <code class="literal">boundedMove()</code>, is fully implemented as once the values of <code class="literal">speedX</code> and <code class="literal">speedY</code> are set, the movement for every subclass of <code class="literal">ScrollingEnemy</code> is the same.</p></div><div class="section" title="Randomness"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Randomness</h2></div></div></div><p>Algorithms<a id="id482" class="indexterm"/> using pure probability to determine solutions to problems are surprisingly effective and not uncommon in computer science. While they are almost never the best answer, they make for good comparisons against new algorithms developed for things such as memory management or scheduling.</p><p>For games, an actor that moves randomly provides a unique challenge for players to avoid or capture. We are going to add an actor to our <code class="literal">MazeWorld</code> scenario that moves around the world randomly.</p><div class="section" title="Spider"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec52"/>Spider</h3></div></div></div><p>Let us create a <a id="id483" class="indexterm"/>new actor by right-clicking on <code class="literal">ScrollingEnemy</code>, choosing <span class="strong"><strong>New subclass…</strong></span>, entering <span class="strong"><strong>Spider</strong></span> as the new class name, and then selecting the image <code class="literal">spider.png</code> in the animals category. Add the following code to this new class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Spider extends ScrollingEnemy {
  private final static int SPEEDVARIATION = 3;
  private final static int SPEEDCHANGECHANCE = 20;
  
  protected void reaction() {
    speedX = Greenfoot.getRandomNumber(1000) &lt; SPEEDCHANGECHANCE ? Greenfoot.getRandomNumber(SPEEDVARIATION)-1 : speedX;
    speedY = Greenfoot.getRandomNumber(1000) &lt; 	SPEEDCHANGECHANCE ? Greenfoot.getRandomNumber(SPEEDVARIATION)-1 : speedY;
  }
}</pre></div><p>One of the first things to notice, is that we do not provide an implementation for the empty <code class="literal">sense()</code> method defined in <code class="literal">ScrollingEnemy</code>. Since we are moving randomly, we do not need to do any sensing of the environment. The <code class="literal">reaction()</code> method randomly sets both the <code class="literal">speedX</code> and <code class="literal">speedY</code> variables to <code class="literal">1</code>, <code class="literal">0</code>, or <code class="literal">-1</code>. It only changes the values of those variables 2 percent of the time so that movement is not too sporadic.</p><p>You can now test the scenario. First, comment out the additions of the <code class="literal">Mouse</code> and <code class="literal">Snake</code> objects in the <code class="literal">prepare()</code> method in <code class="literal">MazeWorld</code>, and then compile and run the scenario. Observe the movements of the Spider objects. Can you get around them? Play with the values in the <code class="literal">Spider</code> class and see how they affect the movement of <code class="literal">Spider</code> objects.</p><p>With a little code, we have constructed an enemy that is hard to avoid.</p></div></div><div class="section" title="Behavior heuristics"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Behavior heuristics</h2></div></div></div><p>In this<a id="id484" class="indexterm"/> method, we supply some simple rules for movement that provide pretty good intelligence without complex coding. A good example <a id="id485" class="indexterm"/>of an animal in nature that follows simple behavior heuristics, is an ant. Ants follow a few rules of movement that provide a proven method of finding food in the environment and returning to the hive.</p><p>Examples of these simple heuristics are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If you hit an obstacle, turn left</li><li class="listitem">Follow the sun</li><li class="listitem">If you are close to prey, run at it</li><li class="listitem">Walk in a circular path</li></ul></div><p>Let us<a id="id486" class="indexterm"/> create an actor that will attack the hiker if the hiker gets too close; otherwise, it paces back <a id="id487" class="indexterm"/>and forth.</p><div class="section" title="The Snake class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec53"/>The Snake class</h3></div></div></div><p>Create a <a id="id488" class="indexterm"/>class called <code class="literal">Snake</code> in the same way that we created the previous <code class="literal">Spider</code> class. Of course, you will need to choose the image for a snake, <code class="literal">snake2.png</code>, instead of the spider image.</p><p>Here is the code for the <code class="literal">Snake</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;

public class Snake extends ScrollingEnemy {
  private static final int PATHLENGTH = 200;
  private static final int INRANGE = 100;
  private int pathCounter = PATHLENGTH;
  private boolean pathing = false;
  private int rememberSpeedX = 0;
  private List&lt;Hiker&gt; lse;
  
  public Snake() {
    speedX = rememberSpeedX = SPEED;
    speedY = 0;
  }
  
  protected void sense() {
    // If near, move towards enemy
    lse = getObjectsInRange(INRANGE,Hiker.class);
    pathing = lse.isEmpty();
  }
  
  protected void reaction() {
    if( pathing ) {
      speedX = rememberSpeedX;
      speedY = 0;
      if( --pathCounter == 0 ) {
        pathCounter = PATHLENGTH;
        speedX = rememberSpeedX = -speedX;
      }
    } else {
      speedX = lse.get(0).getX() &gt; getX() ? 1 : -1;
      speedY = lse.get(0).getY() &gt; getY() ? 1 : -1;
    }
  }
}</pre></div><p>The <code class="literal">sense()</code> method for the <code class="literal">Snake</code> actor is simple. It looks to see whether the hiker is within range using the <code class="literal">getObjectsInRange()</code> collision <a id="id489" class="indexterm"/>detection method. If the hiker is within range, then <code class="literal">getObjectsInRange()</code> will return a list containing a reference to the <code class="literal">Hiker</code> object; otherwise, the list will be empty. Next, we check whether the returned list is empty by calling the <code class="literal">isEmpty()</code> method and saving the result in the <code class="literal">pathing</code> variable. We will use the value of <code class="literal">pathing</code> to determine whether the snake should move back and forth or chase the hiker.</p><div class="mediaobject"><img src="../Images/image00316.jpeg" alt="The Snake class"/><div class="caption"><p>Figure 2: This shows the movement decision made by the Snake actors. The snake moves back and forth, as shown by the arrows, unless the hiker is within the green circle. In that case, the snake will move towards the hiker.</p></div></div><p style="clear:both; height: 1em;"> </p><p>In the <code class="literal">reaction()</code> method, we have the snake march back and forth if <code class="literal">pathing</code> is true; otherwise, we have the snake chase the hiker. <span class="emphasis"><em>Figure 2</em></span> shows the two cases. To march back and forth, we use a delay variable, <code class="literal">pathCounter</code>, to define how long the snake marches in each direction. When the variable expires (has a value of <code class="literal">0</code>), we have the snake switch directions and reset the delay variable. To chase the hiker, we simply set the <code class="literal">speedX</code> and <code class="literal">speedY</code> variables using a simple calculation. If the hiker is to the right of the snake, we set <code class="literal">speedX</code> to be <code class="literal">1</code>; otherwise, it is set to <code class="literal">-1</code>. If the hiker is below the snake, then we set <code class="literal">speedY</code> to be <code class="literal">1</code>; otherwise, we set it to <code class="literal">-1</code>.</p><p>Let's test the scenario. Because <a id="id490" class="indexterm"/>we have not yet implemented the <code class="literal">Mouse</code> class, you will need to comment out the addition of <code class="literal">Mouse</code> objects in the <code class="literal">prepare()</code> method present in the <code class="literal">MazeWorld</code> class. Compile and run the scenario. Observe the movements of the <code class="literal">Snake</code> objects. Try getting close to one. Are the <code class="literal">Spider</code> objects or <code class="literal">Snake</code> objects harder to avoid?</p></div></div><div class="section" title="A* pathfinding"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec71"/>A* pathfinding</h2></div></div></div><p>The<a id="id491" class="indexterm"/> A* pathfinding algorithm <a id="id492" class="indexterm"/>finds a path between a start location and an end location that intelligently avoids obstacles. This algorithm is used heavily in the gaming industry. <span class="emphasis"><em>Ever wonder how enemies in games you have played are able to chase you while avoiding obstacles?</em></span> Their movement is programmed using this algorithm. While the algorithm is fairly complex (as we will soon see), understanding it is fairly straightforward. <span class="emphasis"><em>Figure 3</em></span> shows the different areas considered by the A* algorithm when determining a path between the mouse actor and the hiker.</p><div class="mediaobject"><img src="../Images/image00317.jpeg" alt="A* pathfinding"/><div class="caption"><p>Figure 3: The first round of comparisons is done on the areas containing a red "1", the second round on the areas containing a green "2", the third round on the areas containing a blue "3", and the fourth round on the areas containing a purple "4". The competing paths are shown with a black square in the upper-right corner. After round four, the upper path continues to progress until it reaches the goal destination</p></div></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Overview"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec54"/>Overview</h3></div></div></div><p>Before<a id="id493" class="indexterm"/> starting the algorithm, you need to divide the world into a grid of uniform-sized areas. Each individual area immediately surrounding an actor defines a potential location the actor could move to. With this in place, we can start. The A* algorithm works by comparing the areas an actor could move to using a heuristic that approximates the remaining distance to the goal location (often referred to as the <code class="literal">H</code> value) and combines that with the distance traveled thus far (referred to as the <code class="literal">G</code> value). For example, in <span class="emphasis"><em>Figure 3</em></span>, the mouse can initially move to any of the squares marked with a red <code class="literal">1</code>. When an area contains an obstacle, it is not used in the comparison. Therefore, we calculate <code class="literal">H + G</code> (referred to as <code class="literal">F</code>) for the squares above, below, and to the left of the mouse. The <code class="literal">H</code> value is approximated by just counting how far away we are from the goal destination, ignoring any obstacles in the way. The <code class="literal">G</code> value is determined by counting the number of squares back to the starting location of the mouse. Knowing that, we can calculate the <code class="literal">F</code> value (<code class="literal">G+H</code>) for each of the walkable squares around the mouse. For our example, the <code class="literal">F</code> value for each square is <code class="literal">10</code> (<code class="literal">H</code>=9, <code class="literal">G</code>=1). The algorithm will then pretend that the actor has moved to the most favorable current location (the one with the lowest <code class="literal">F</code> value) and then repeat the process. If there is a tie for the best <code class="literal">F</code> values, the algorithm will just choose one at random. <span class="emphasis"><em>Figure 3</em></span> depicts this and a few more iterations of the algorithm pictorially. <span class="emphasis"><em>Our mouse can only move up, down, left, and right—not diagonally</em></span>. However, the algorithm works just as well for actors that can move diagonally.</p></div><div class="section" title="Algorithm"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec55"/>Algorithm</h3></div></div></div><p>Given <a id="id494" class="indexterm"/>that we now have a base understanding of the algorithm, we can state it a bit more formally. Here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the starting location to the <code class="literal">open</code> list.</li><li class="listitem">Pick the node in the <code class="literal">open</code> list that has the minimum <code class="literal">F</code> value. Let's call that <span class="emphasis"><em>n</em></span>.</li><li class="listitem">Remove <span class="emphasis"><em>n</em></span> from the <code class="literal">open</code> list and add it to the <code class="literal">closed</code> list.</li><li class="listitem">For every neighbor of <span class="emphasis"><em>n</em></span> not already in the <code class="literal">closed</code> list and not containing an obstacle, perform the following steps:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Calculate its <code class="literal">F</code> value, set its parent to be <span class="emphasis"><em>n</em></span>.</li><li class="listitem">Add it to the <code class="literal">open</code> list if not already in that list.</li><li class="listitem">Update its <code class="literal">F</code> value and its parent node if it is in the open list.</li></ol><div style="height:10px; width: 1px"/></div></li><li class="listitem">If you have not reached the destination, go back to step 2.</li><li class="listitem">If you have reached the destination node, then construct the path from the start location to the end location by backtracking through the parent links.</li></ol><div style="height:10px; width: 1px"/></div><p>In our algorithm, these <a id="id495" class="indexterm"/>are the definitions of <code class="literal">G</code>, <code class="literal">H</code>, and <code class="literal">F</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">G</code>: This is the number of locations we need to traverse from the start location to get to this node.</li><li class="listitem"><code class="literal">H</code>: This is approximately how far we are from the destination node. This is calculated by summing the absolute value of the difference in the <span class="emphasis"><em>x</em></span> location of the current node and the destination node with the absolute value of the difference in the <span class="emphasis"><em>y</em></span> location of the current node and the destination node. This is known as the <span class="emphasis"><em>Manhattan distance</em></span>.</li><li class="listitem"><code class="literal">F</code>: This is the sum of <code class="literal">H</code> and <code class="literal">G</code>.</li></ul></div><p>Now, let's look<a id="id496" class="indexterm"/> at the implementation of this algorithm in our <code class="literal">MazeWorld</code> scenario.</p><div class="note" title="Note"><h3 class="title"><a id="tip23"/>Tip</h3><p>To learn more about<a id="id497" class="indexterm"/> A* pathfinding, refer to the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><a class="ulink" href="http://www.policyalmanac.org/games/aStarTutorial.htm">http://www.policyalmanac.org/games/aStarTutorial.htm</a></li><li class="listitem"><a class="ulink" href="http://theory.stanford.edu/~amitp/GameProgramming/">http://theory.stanford.edu/~amitp/GameProgramming/</a></li><li class="listitem"><a class="ulink" href="http://www.raywenderlich.com/4946/introduction-to-a-pathfinding">http://www.raywenderlich.com/4946/introduction-to-a-pathfinding</a></li><li class="listitem"><a class="ulink" href="http://en.wikipedia.org/wiki/Pathfinding">http://en.wikipedia.org/wiki/Pathfinding</a></li></ul></div></div></div><div class="section" title="The Mouse class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec56"/>The Mouse class</h3></div></div></div><p>We <a id="id498" class="indexterm"/>are going to create a <code class="literal">Mouse</code> actor that will use A* pathfinding to track down the hiker. Start by right-clicking on <code class="literal">ScrollingEnemy</code>, select <span class="strong"><strong>New subclass…</strong></span>, then enter <code class="literal">Mouse</code> as the new class name, and then select the <code class="literal">mouse.png</code> image in the <span class="strong"><strong>animals</strong></span> category. Open Greenfoot's editor for this new class and enter the following code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.Stack;

public class Mouse extends ScrollingEnemy {
  private TiledWorldPathfinding twp;
  private Stack&lt;Point&gt; apath;
  private int walkDelay = -1;
  private final static int WALKDELAY = 40;
  private int searchDelay = -1;
  private final static int SEARCHDELAY = 130;
  private int prevRow = 0;
  private int prevCol = 0;
  
  /* initilization */
  protected void addedToWorld(World w) {
    MazeWorld mw = (MazeWorld) w;
    super.addedToWorld(w);
    twp = new TiledWorldPathfinding
    (mw.getStringWorld(),mw.getValidSpaces());
    prevRow = getY()/mw.getTileWidth();
    prevCol = getX()/mw.getTileWidth();
    setLocation(prevCol*mw.getTileWidth()+mw.getTileWidth()/2,
    prevRow*mw.getTileWidth()+mw.getTileWidth()/2);
  }
  
  protected void sense() {
    // A* pathfinding determines direction
    if( --searchDelay &lt; 0) {
      MazeWorld w = (MazeWorld) getWorld();
      int hikerCol = w.getXHiker()/w.getTileWidth();
      int hikerRow = w.getYHiker()/w.getTileWidth();
      apath = twp.findShortestFeasiblePath(new
      Point(prevRow,prevCol), new Point(hikerRow,hikerCol));
      if( apath != null &amp;&amp; !apath.isEmpty() ) apath.pop();
      searchDelay = SEARCHDELAY;
    }
  }
  
  protected void reaction() {
    // Move in direction chosen by A* pathfinding
    if( --walkDelay &lt; 0 ) {
      walkDelay = WALKDELAY;
      if( apath != null &amp;&amp; !apath.isEmpty() ) {
        Point p = apath.pop();
        MazeWorld w = (MazeWorld) getWorld();
        speedX = (p.col-prevCol) * w.getTileWidth();
        speedY = (p.row-prevRow) * w.getTileWidth();
        prevCol = p.col;
        prevRow = p.row;
      }
    } else {
      speedX = 0;
      speedY = 0;
    }
  }
  
}</pre></div><p>In the implementation of the <code class="literal">Mouse</code> class, the <code class="literal">sense()</code> method runs the A* algorithm to find a path to the hiker, and the <code class="literal">reaction()</code> method sets <code class="literal">speedX</code> and <code class="literal">speedY</code> to move the <code class="literal">Mouse</code> object along the found path. As the hiker can move, the <code class="literal">Mouse</code> class will need to update its calculated path periodically.</p><p>The <code class="literal">Mouse</code> class <a id="id499" class="indexterm"/>needs to perform a one-time initialization of the A* pathfinding algorithm code in the <code class="literal">addedToWorld()</code> method. First, a call to the parent's <code class="literal">addedToWorld()</code> method is performed to ensure any initialization needed in that class, for example, scaling the actor's image is not skipped. Next, we create a new instance of the <code class="literal">TiledWorldPathfinding</code> class. This is the class that implements A* pathfinding, and we will go over it in detail soon. For now, we can just assume it works flawlessly. To create a new instance of <code class="literal">TiledWorldPathfinding</code>, we need to provide the string representation of the world defined in the <code class="literal">MazeWorld</code> class and the set of spaces in this representation that are walkable, also defined in <code class="literal">MazeWorld</code>. The last thing this method accomplishes is making sure the actor is aligned to be at the center of a grid in the new grid-view of the world needed by the A* algorithm.</p><p>The<code class="literal"> sense()</code> method runs the A* pathfinding algorithm. It is wrapped in a delay variable in order to lower the rate at which we rerun the algorithm, in order to be more efficient as the hiker will not really be able to move very far during the delay. When <code class="literal">searchDelay</code> is less than zero, we ask our world for the location of the <code class="literal">Hiker</code> object and determine what row and column the hiker is on. We pass our location and the location of the hiker to the <code class="literal">findShortestFeasiblePath()</code> method of <code class="literal">TiledWorldPathfinding</code>. For convenience, we have chosen to represent locations in the world as points defined by the <code class="literal">Point</code> class. We will look at the implementation of <code class="literal">Point</code> soon. The <code class="literal">findShortestFeasiblePath()</code> method then returns the shortest feasible path from the location of the mouse to the location of the hiker. The path returned contains our current location, so we remove that from the path and then reset the <code class="literal">searchDelay</code> value.</p><p>In the <code class="literal">reaction()</code> method, we just move the <code class="literal">Mouse</code> object according to the path determined in the <code class="literal">sense()</code> method. First, we check to see whether <code class="literal">walkDelay</code> has become less than zero. We need this delay variable so that the mouse moves at a reasonable pace towards the hiker. Inside the <code class="literal">if</code> statement, we pop off the next location from the path to the hiker and then set <code class="literal">speedX</code> and <code class="literal">speedY</code> to values that will properly move the mouse.</p><p>The <code class="literal">Mouse</code> class actually has a straightforward implementation. The real heavy coding is done in the <code class="literal">TiledWorldPathfinding</code> class—the class that implements A* pathfinding.</p><p>The <code class="literal">TiledWorldPathfinding</code> class is not going to be a subclass of <code class="literal">Actor</code>. It is a non-graphical class that will be used solely to encapsulate the implementation of A* pathfinding. To create this class, click on <span class="strong"><strong>Edit</strong></span> in Greenfoot's main menu bar and then select <span class="strong"><strong>New class…</strong></span>. In the pop-up window, type <code class="literal">TiledWorldPathfinding</code>. You will see the new class appear below all of the <code class="literal">Actor</code> classes in Greenfoot's main scenario window. Later in this chapter, you will create the <code class="literal">Point</code> class and the <code class="literal">Tile</code> class in the same <a id="id500" class="indexterm"/>way.</p><p>Here is the code:</p><div class="informalexample"><pre class="programlisting">import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Stack;

public class TiledWorldPathfinding {
  private String []world;
  private String validSpaces;
  private int worldColumns;
  private int worldRows;
  private Tile[][] tiledWorld;
  
  public TiledWorldPathfinding(String []w, String vs) {
    world = w;
    worldColumns = w[0].length(); // number of columns
    worldRows = w.length; // number of rows
    tiledWorld = new Tile[worldRows][worldColumns];
    validSpaces = vs;
    resetWorld();
  }
  
  public void changeWorld( String []w ) {
    world = w;
    resetWorld();
  }
  
  public Stack&lt;Point&gt; findShortestFeasiblePath(Point start, Point end) {
    Queue&lt;Tile&gt; openList = new PriorityQueue&lt;Tile&gt;();
    Queue&lt;Tile&gt; closedList = new PriorityQueue&lt;Tile&gt;();
    Stack&lt;Point&gt; answer = new Stack&lt;Point&gt;();
    
    // Check for trivial case
    if( start.equals(end) ) {
      answer.push(start);
      return answer;
    }
    
    // Check that both start and end are walkable
    if( !tiledWorld[start.row][start.col].isWalkable() ) {
      return null;
    }
    if( !tiledWorld[end.row][end.col].isWalkable() ) {
      return null;
    }
    
    // Mark location of end point
    tiledWorld[end.row][end.col].setEndNode();
    
    // Add starting node to open list
    openList.add(tiledWorld[start.row][start.col]);
    
    // A* algorithm
    runAStar(openList, closedList, end);
    
    // derive the answer area from the marked up TileWorld
    if( tiledWorld[end.row][end.col].getParent() == null ) {
      resetWorld();
      return null;
    } else {
      deriveWaypoints(answer, end);
    }
    
    // Prepare for next time
    resetWorld();
    
    // return result
    return answer;
  }
  
  /* private methods */
  private void runAStar(Queue&lt;Tile&gt; openList,
  Queue&lt;Tile&gt; closedList, Point end) {
    boolean done = false;
    Tile t;
    
    while( !openList.isEmpty() &amp;&amp; !done ) {
      t = openList.remove();
      done = done || processNeighbor(t, t.getUp(), openList, end);
      done = done || processNeighbor(t, t.getDown(), openList, end);
      done = done || processNeighbor(t, t.getLeft(), openList, end);
      done = done || processNeighbor(t, t.getRight(), openList, end);
      t.setDone();
      closedList.add(t);
    }
  }
  
  private boolean processNeighbor( Tile parent, Tile node, Queue&lt;Tile&gt; openList, Point end) {
    boolean retval = false;
    
    if( node != null &amp;&amp; !node.isDone() &amp;&amp; node.isWalkable()) {
      if( node.isEndNode() ) { // Are we done?
        node.setParent(parent);
        retval = true; // FOUND THE END NODE
      } else {
        node.setParent(parent);
        node.setG(1 + parent.getG());
        node.setH(calculateManhattenDistance(
        node.getPoint(), end));
        openList.add(node);
      }
    }
    return retval;
  }
  
  private int calculateManhattenDistance(Point start,Point end)
  {
    return Math.abs(start.row - end.row) + Math.abs(start.col - end.col);
  }
  
  private void deriveWaypoints(Stack&lt;Point&gt; a, Point end) {
    Tile tp = tiledWorld[end.row][end.col];
    
    while( tp != null ) {
      a.push(tp.getPoint());
      tp = tp.getParent();
    }
  }
  
  private void resetWorld() {
    for( int i = 0; i&lt;worldRows; i++ ) {
      for(int j = 0; j&lt;worldColumns; j++) {
        tiledWorld[i][j] = new Tile();
        tiledWorld[i][j].setPoint(i,j);
      }
    }
    for( int i = 0; i&lt;worldRows; i++ ) {
      for(int j = 0; j&lt;worldColumns; j++) {
        Tile t = tiledWorld[i][j];;
        if( validSpaces.indexOf(world[i].charAt(j)) == -1) {
          t.setNotWalkable();
        } else {
          if( i == 0 ) {
            t.setUp(null);
          } else {
            t.setUp(tiledWorld[i-1][j]);
          }
          if( i == worldRows-1 ) {
            t.setDown(null);
          } else {
            t.setDown(tiledWorld[i+1][j]);
          }
          if( j == 0 ) {
            t.setLeft(null);
          } else {
            t.setLeft(tiledWorld[i][j-1]);
          }
          if( j == worldColumns-1 ) {
            t.setRight(null);
          } else {
            t.setRight(tiledWorld[i][j+1]);
          }
        }
      }
    }
  }
}</pre></div><p>The main<a id="id501" class="indexterm"/> method of this class is <code class="literal">findShortestFeasiblePath()</code>. The other methods in the class support this method, so let's first look at it. The method <code class="literal">findShortestFeasiblePath()</code> accepts two locations in the form of <code class="literal">Point</code>. The <code class="literal">Point</code> class is very simple. It simply records the row and column values of a location. The <code class="literal">findShortestFeasiblePath()</code>method starts by checking the simple case where the start and end locations are the same using the <code class="literal">equals()</code> method defined in the <code class="literal">Point</code> class. If so, we can return a path that just contains the starting node, and we are done. Next, we check that both the starting and end locations are walkable; if they are not, then we really can't run the algorithm as it ignores locations that are not walkable, so we return <code class="literal">null</code>. We then set the end node as our destination, add the start node to the open list (<code class="literal">openList</code>), and then run the A* algorithm. We will now look into the implementation of <code class="literal">runAStar()</code>.</p><p>Because we use good functional decomposition, the implementation of <code class="literal">runAStar()</code> is fairly concise. We remove a node from <code class="literal">openList</code>, process all of its valid neighbors, set the node to <code class="literal">done</code>, and add it to <code class="literal">closedList</code>. As we are processing the neighbors, we add new nodes to <code class="literal">openList</code>. If we encounter the end node, we set <code class="literal">done</code> to <code class="literal">true</code> and break out of the loop. This is a straightforward implementation of the A* pathfinding algorithm we discussed previously. To complete our discussion, we need to look at the implementation of <code class="literal">processNeighbor()</code>.</p><p>In <code class="literal">processNeighbor()</code>, we check for two things. If the node is not valid (we have already processed it or it is not walkable), we skip it. We then check whether the node is our target destination. If so, we set the node we just came from as the parent and return <code class="literal">true</code>. If not, we calculate <code class="literal">G</code>, <code class="literal">H</code>, and <code class="literal">F</code>, set the parent node, and then add this node to <code class="literal">openList</code>.</p><p>After <code class="literal">runAStar()</code> completes, we<a id="id502" class="indexterm"/> return to the <code class="literal">findShortestFeasiblePath()</code> method. We now have either found a path to the target location or have determined that there is no feasible path. If we have found a valid path, we construct a list of points stored in <code class="literal">Stack</code> (see the information box after the following two paragraphs) using <code class="literal">deriveWaypoints()</code>, reset the state of this class so that we can be called again, and return the answer to the caller.</p><p>The <code class="literal">deriveWaypoints()</code> method is small. It derives the path from the <code class="literal">tiledWorld</code> matrix by following the parent pointers from the destination back to the start. Along the way, it pushes each node onto a stack. This is why we set parent references in <code class="literal">processNeighbor()</code>.</p><p>The last method we discuss in this class is <code class="literal">resetWorld()</code>. It has the responsibility of initializing the <code class="literal">tiledWorld</code> matrix and making sure it accurately represents the current state of the game (where obstacles are and where the destination is). We run the A* pathfinding algorithm on <code class="literal">tiledWorld</code> and not the actual screen of the game.</p><div class="note" title="Note"><h3 class="title"><a id="note22"/>Note</h3><p><span class="strong"><strong>Stacks and priority queues</strong></span></p><p>In programming, you will use many different types of data structures to store your data. We have already used arrays and lists (The List class was first used in <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>). Sometimes, we want the ordering to occur in a certain way when storing data, as lists and arrays are unordered. In the implementation of A* pathfinding, we use two new data structures: a stack and a priority queue. A stack stores data in the <a id="id503" class="indexterm"/><span class="strong"><strong>Last-in First-out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) order, while a priority queue stores data in sorted order. To learn more about these two data structures, refer to the following links:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html">http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html</a></li><li class="listitem"><a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html">http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html</a></li><li class="listitem"><a class="ulink" href="http://www.oopweb.com/Java/Documents/ThinkCSJav/Volume/chap16.htm">http://www.oopweb.com/Java/Documents/ThinkCSJav/Volume/chap16.htm</a></li><li class="listitem"><a class="ulink" href="http://www.tutorialspoint.com/java/java_stack_class.htm">http://www.tutorialspoint.com/java/java_stack_class.htm</a></li></ul></div></div><p>We have two classes that we used to support the running of the A* pathfinding algorithm: <code class="literal">Tile</code> and <code class="literal">Point</code>. Let's first discuss the <code class="literal">Tile</code> class. This class is used to represent an area of the screen and is stored<a id="id504" class="indexterm"/> in the <code class="literal">tiledWorld</code> matrix. As we progress through the pathfinding algorithm, we need to track information about each area. For example, we need to store the <code class="literal">G</code>, <code class="literal">H</code>, and <code class="literal">F</code> values for that area; note whether it is the destination node and whether it is walkable and record parent information. The class is set up to store that information and allow easy access to it. The code is as follows:</p><div class="informalexample"><pre class="programlisting">import java.util.Comparator;

public class Tile implements Comparable&lt;Tile&gt; {
  private int g = 0, h = 0;
  private Tile up, down, left, right, parent;
  private Point location;
  private boolean walkable = true;
  private boolean done = false;
  private boolean isEndNode = false;
  
  public Tile() {
    parent = up = down = left = right = null;
    location = new Point(0,0);
  }
  
  public Tile(Tile u, Tile d, Tile l, Tile r) {
    up = u;
    down = d;
    left = l;
    right = r;
    parent = null;
    location = new Point(0,0);
  }
  
  /* state methods */
  public boolean isWalkable() {
    return walkable;
  }
  
  public void setNotWalkable() {
    walkable = false;
  }
  
  public boolean isDone() {
    return done;
  }
  
  public void setDone() {
    done = true;
  }
  
  public boolean isEndNode() {
    return isEndNode;
  }
  
  public void setEndNode() {
    isEndNode = true;
  }
  
  /* neighbors */
  public void setParent(Tile t) {
    parent = t;
  }
  
  public Tile getParent() {
    return parent;
  }
  
  public void setUp(Tile t) {
    up = t;
  }
  
  public Tile getUp() {
    return up;
  }
  
  public void setDown(Tile t) {
    down = t;
  }
  
  public Tile getDown() {
    return down;
  }
  
  public void setRight(Tile t) {
    right = t;
  }
  
  public Tile getRight() {
    return right;
  }
  
  public void setLeft(Tile t) {
    left = t;
  }
  
  public Tile getLeft() {
    return left;
  }
  
  /* accessor methods */
  public void setPoint(int _row, int _col) {
    location.row = _row;
    location.col = _col;
  }
  
  public Point getPoint() {
    return location;
  }
  
  public void setG(int n) {
    g = n;
  }
  
  public int getG() {
    return g;
  }
  
  public void setH( int n) {
    h = n;
  }
  
  public int getH() {
    return h;
  }
  
  public int getF() {
    return g+h;
  }
  
  // needed for Comparable interface
  public int compareTo(Tile t) {
    return getF()-t.getF();
  }
  
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="note23"/>Note</h3><p><span class="strong"><strong>Comparable interface</strong></span></p><p>In <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>, we already discussed Java interfaces in general. The <code class="literal">Comparable</code> interface<a id="id505" class="indexterm"/> is an interface that requires the implementing class to provide a <code class="literal">compareTo()</code> method. This method will then be used in classes such as <code class="literal">PriorityQueue</code> to help determine ordering within the queue.</p></div><p>As mentioned <a id="id506" class="indexterm"/>earlier, the <code class="literal">Point</code> class gives us a convenient way to refer to locations in <code class="literal">tiledWorld</code>. It concisely tracks the row and column position and also provides an easy way to compare points (see whether they are equal). Here is the code to accomplish this:</p><div class="informalexample"><pre class="programlisting">public class Point {
  public int row;
  public int col;
  
  public Point() {
    row = col = 0;
  }
  
  public Point( int _row, int _col) {
    row = _row;
    col = _col;
  } 

  public boolean equals(Point p) {
    return (p.row == row) &amp;&amp; (p.col == col);
  }
}</pre></div><p>We have now fully implemented the <code class="literal">Mouse</code> class. That was quite a bit of coding! But now, we have an actor that can effectively chase our hiker. Compile the scenario and fix any typos you made along the way. We now have a very interesting scenario.</p></div></div><div class="section" title="Play test"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Play test</h2></div></div></div><p>We have spent a long time on this scenario. Time to play!</p><p>Uncomment all of the actors in the <code class="literal">prepare()</code> method, compile the scenario, and then try it out. Can you reach the gold square? Which enemy is hardest to avoid?</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Summary</h1></div></div></div><p>We really covered a lot of ground in this chapter. As we saw, adding intelligent behavior to an actor can range from very simple to very complex. Quite often, using randomness or heuristics, or a combination of both can create some very challenging enemies and will suffice for many of the games/simulations you create. However, there is no substitute for an enemy that knows how to track you down through the A* pathfinding algorithm. I hope you find new and creative ways to bring challenge, intrigue, and surprise into the behavior of your actors.</p><p>At this point in the book, we have really covered a lot of topics to help you create an interesting and engaging interactive application. Next, we will look at creating user interfaces to accept more information from our user and to provide them with more feedback.</p></div></body></html>