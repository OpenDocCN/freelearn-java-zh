<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Dynamic Rendering</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the last chapter, we worked with SpringWebFlux to build simple web services. So far, we have built RESTful web services, which return JSON responses. However, SpringWebFlux is not limited to RESTful web services; it is a complete web framework that offers the capability to build dynamic web pages.</p>
<p class="mce-root">In this chapter, we will discuss the following topics:</p>
<ul>
<li>View templates</li>
<li>Static resources</li>
<li>WebClient</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<ul>
<li>Java Standard Edition, JDK 8 or above</li>
<li><span>IntelliJ IDEA IDE, 2018.1 or above</span></li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter06</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">View templates</h1>
                </header>
            
            <article>
                
<p>SpringWebFlux offers a number of options for rendering views, using various technology platforms. Whatever choice we make, the framework employs the same view resolution process, allowing us to arrive at the correct view. The view can then be rendered by using any of the supported technologies. In this section, we will cover the complete process of rendering views using SpringWebFlux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resolving views</h1>
                </header>
            
            <article>
                
<p><strong>View resolution</strong> is a process used by the framework to determine which view needs to be rendered for a received request. The complete view resolution process enables us to render different views for the same requests, based on content parameters. Before we start to build different views, let's discuss how the framework determines what view it needs to render. </p>
<p>In the last chapter, we configured <kbd>HandlerFunction</kbd> for handling requests. This function gives back a <kbd>HandlerResult</kbd>. The <kbd>HandlerResult</kbd> contains not only the result, but also the attributes passed into the request. The framework then invokes <kbd>ViewResolutionResultHandler</kbd>, using the <kbd>HandlerResult</kbd>. The <kbd>ViewResolutionResultHandler</kbd> determines the correct view by validating the values returned for the following:</p>
<ul>
<li><strong>String</strong>: If the value returned is a string, then the framework builds a view using the configured <kbd>ViewResolvers</kbd>.</li>
<li><strong>Void</strong>: If nothing is returned, it tries to build the default view.</li>
<li><strong>Map</strong>: The framework looks for the default view, but it also adds the key values returned to the request model.</li>
</ul>
<p>The <kbd>ViewResolutionResultHandler</kbd> also looks up the content type passed in the request. In order to determine what view should be used, it compares the content type passed to the content type supported by the <kbd>ViewResolver</kbd>. It then selects the first <kbd>ViewResolver</kbd> that supports the request's content type.</p>
<p>It is important to note that a request can redirect to another request. In order to do this, we prefix the <kbd>redirect:</kbd> keyword before the view name. The framework then uses a  <kbd>UrlBasedViewResolver</kbd> and returns a URL for redirection. If the returned URL is from the same application, then the path can be built in a relative manner (for example, <kbd>redirect:/applicationA/locationA</kbd>). If the returned URL is from an external location, then the view name can be built using an absolute URL (for example, <kbd>redirect:http://www.google.com/search/</kbd>).</p>
<p>Now that you know how the view resolution process works, let's try to build dynamic views by using the various supported template frameworks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Freemarker</h1>
                </header>
            
            <article>
                
<p>Freemarker is a template engine that can be used to generate dynamic HTML output. It is not limited to HTML pages; it can generate any kind of text output, such as emails, and reports. In order to use this, we have to write a template file using the Freemarker syntax. The Freemarker engine then receives the file, along with data to generate the resulting dynamic text.</p>
<p>Now, let's try to configure Freemarker to render our Fibonacci series. In order to use Freemarker for our view resolution, we must first add<span> the required dependencies to our</span> <kbd>build.gradle</kbd><span>, as follows:</span></p>
<pre>plugins {<br/>    id "io.spring.dependency-management" version "1.0.1.RELEASE"<br/>    id "org.springframework.boot" version "2.0.3.RELEASE"<br/>}<br/>apply plugin: 'java'<br/>// Rest removed for Brevity<br/><br/>dependencies {<br/>        compile 'org.springframework.boot:spring-boot-starter-webflux'<br/>        compile 'org.springframework:spring-context-support'<br/>        compile group: 'org.freemarker', name: 'freemarker', version: '2.3.28'<br/>}</pre>
<p>In the preceding code, we added the following:</p>
<ol>
<li><kbd>org.freemarker:freemarker</kbd>: The Freemarker template engine—at the time of writing this book, version 2.3.28 was the most recent version.</li>
<li><kbd>spring-context-support</kbd>: This provides the required integration between Freemarker and Spring. Since we have <kbd>spring-boot</kbd> configured, we need not specify the version of the <kbd>spring-context-support</kbd> dependency.</li>
</ol>
<p>Now that we have added Freemarker, we have to configure it. The Spring context has a view resolver registry that must be updated to include Freemarker resolver, as follows:</p>
<pre>@EnableWebFlux<br/>@Configuration<br/>public class WebfluxConfig implements WebFluxConfigurer {<br/><br/>   @Override<br/>    public void configureViewResolvers(ViewResolverRegistry registry) {<br/>        registry.freeMarker();<br/>   }<br/>   <br/>    @Bean<br/>    public FreeMarkerConfigurer freeMarkerConfigurer() {<br/>        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();<br/>        configurer.setTemplateLoaderPath("classpath:/freemarker/");<br/>        return configurer;<br/>    }<br/>}</pre>
<p> In the preceding code, we did the following:</p>
<ol>
<li>Implemented the <kbd>WebFluxConfigurer</kbd> interface. The interface provides the <kbd>configureViewResolvers</kbd> method. </li>
<li>The <kbd>configureViewResolvers</kbd> is invoked by the Spring context, along with a <kbd>ViewResolverRegistry</kbd>. The registry provides the <kbd>freeMarker()</kbd> method to enable Freemarker—based resolution.</li>
<li>Next, we have to create a <kbd>FreeMarkerConfigurer</kbd>, which can set Freemarker parameters. As shown in the preceding code, we configured the template path to <kbd>classpath:/freemarker/</kbd>. This will allow us to create Freemarker templates under the path <kbd>src/main/resources/freemarker</kbd>.</li>
</ol>
<p>Now, let's add a Freemarker template for showing the Fibonacci series. In this case, we would like to list the numbers as a simple HTML list, as follows:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;Reactor Sample&lt;/title&gt;<br/>        &lt;meta charset="UTF-8"/&gt;<br/>        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;Fibonacci Numbers&lt;/h1&gt;<br/>        &lt;ul style="list-style-type:circle"&gt;<br/>        &lt;#list series as number&gt;<br/>          &lt;li&gt;${number}&lt;/li&gt;<br/>        &lt;/#list&gt;<br/>        &lt;/ul&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>In the preceding HTML template, we did the following:</p>
<ol>
<li>We added a <kbd>series</kbd> variable, containing a list of values.</li>
<li>The <kbd>&lt;#list&gt; &lt;/#list&gt;</kbd> syntax iterates through the list, providing individual values.</li>
</ol>
<ol start="3">
<li>The value is then rendered in the <kbd>&lt;li&gt;</kbd> HTML tag.</li>
</ol>
<p>Now, save the file as <kbd>numbers.ftl</kbd>, under the <kbd>src/main/resources/freemarker</kbd> pa<span>th</span><span>.</span></p>
<div class="packt_tip">This book does not aim to cover Freemarker syntax. To learn more about it, please refer to the official Freemarker documentation.</div>
<p><span>Now, the only configuration remaining is to use the template to render the Fibonacci series. First, let's use this template in our annotation—based controller:</span></p>
<pre>@Controller<br/>public class ReactiveController {<br/><br/>// Rest removed for Brevity<br/>@GetMapping("/numbers")<br/>    public String handleSeries(Model model) {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        model.addAttribute("series", fibonacciGenerator);<br/>        return "numbers";<br/>    }<br/>}</pre>
<p>In the preceding code, we did the following:</p>
<ol>
<li>We added the <kbd>@controller</kbd> annotation, instead of <kbd>@RestContoller</kbd>. The <kbd>RestController</kbd> annotation only renders a JSON response. On the other hand, the <kbd>@controller</kbd> annotation allows us to render any kind of response.</li>
<li>We added <kbd>fibonacciGenerator(Flux&lt;&gt;)</kbd> to our model, as a <kbd>series</kbd> variable<em>.</em> This will provide the series value to the Freemarker template.</li>
<li>Next, we returned a <kbd>numbers</kbd> string as the return value. This will resolve to pick the <kbd>number.ftl</kbd> template.</li>
</ol>
<p>Now, let's run <kbd>ReactorMain</kbd> and hit <kbd>http://localhost:8080/numbers</kbd>. At this point, we will get back an HTML page listing the Fibonacci series, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e5ef1f0f-f009-4f13-b615-2fa47c65ca25.png" style=""/></div>
<p>Now, let's use the Freemarker view with our <kbd>HandlerFunction</kbd>. In order to do this, we have to change <kbd>ServerResponse</kbd>, as follows:</p>
<pre>@Configuration<br/>class FibonacciConfigurer {<br/>    <br/>    // Rest removed  For Brevity<br/>    <br/>     @Bean<br/>     RouterFunction&lt;ServerResponse&gt; fibonacciEndpoint() {<br/>         Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                 Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>             if (state.getT1() &lt; 0)<br/>                 sink.complete();<br/>             else<br/>                 sink.next(state.getT1());<br/>             return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>         });<br/>         Map&lt;String, Flux&gt; model = new HashMap&lt;&gt;();<br/>         model.put("series",fibonacciGenerator);<br/>         RouterFunction&lt;ServerResponse&gt; fibonacciRoute =<br/>                 RouterFunctions.route(RequestPredicates.path("/fibonacci"),<br/>                         request -&gt; ServerResponse.ok().render("numbers",model));<br/>         return fibonacciRoute;<br/>     }</pre>
<p>In the preceding code, we did the following:</p>
<ul>
<li>Instead of building <kbd>ServerResponse.body</kbd>, we are now using the render API. This API takes a view name and an optional map of attributes.</li>
<li>We provided the series values in the map by mapping the series key to the <kbd>fibonacciGenerator (Flux&lt;&gt;)</kbd>.</li>
</ul>
<p>Now, let's run <kbd>ReactorMain</kbd> and hit <kbd>http://localhost:8080/fibonacci</kbd>. At this point, we will get back the same HTML page listing the Fibonacci series.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thymeleaf</h1>
                </header>
            
            <article>
                
<p>Thymeleaf is a modem template engine that is based in Java and XML/HTML. It can be used to render any XML/HTML content. Templates built with Thymeleaf are of a natural order, meaning that they will render exactly how they are designed, unlike JSPs. This template engine is aimed at replacing JSPs. It has an excellent integration with Spring.</p>
<p>Now, let's try to configure Thymeleaf to render the Fibonacci series. In order to use Thymeleaf for view resolution, we must first<span> add the required dependencies to our</span> <kbd>build.gradle</kbd><span>, as follows:</span></p>
<pre>plugins {<br/>    id "io.spring.dependency-management" version "1.0.1.RELEASE"<br/>    id "org.springframework.boot" version "2.0.3.RELEASE"<br/>}<br/>apply plugin: 'java'<br/>// Rest removed for Brevity<br/><br/>dependencies {<br/>        compile 'org.springframework.boot:spring-boot-starter-webflux'<br/>        compile "org.springframework.boot:spring-boot-starter-thymeleaf"<br/>}</pre>
<p>In the preceding code, we added the following:</p>
<ul>
<li><kbd>spring-boot-starter-thymeleaf</kbd>: The Springboot starter imports the required Thymeleaf libraries. It also configures the Thymeleaf engine with predefined defaults.</li>
</ul>
<p>Now that we have added Thymeleaf, we must enable it. The Spring context has a view resolver registry that must be updated to include the Thymeleaf resolver, as follows:</p>
<pre>@EnableWebFlux<br/>@Configuration<br/>public class WebfluxConfig implements WebFluxConfigurer {<br/>    private final ISpringWebFluxTemplateEngine templateEngine;<br/><br/>    public WebfluxConfig(ISpringWebFluxTemplateEngine templateEngine) {<br/>        this.templateEngine = templateEngine;<br/>    }<br/><br/><br/>    @Override<br/>    public void configureViewResolvers(ViewResolverRegistry registry) {<br/>        registry.viewResolver(thymeleafViewResolver());<br/>   }<br/><br/>    @Bean<br/>    public ThymeleafReactiveViewResolver thymeleafViewResolver() {<br/>        final ThymeleafReactiveViewResolver viewResolver = new ThymeleafReactiveViewResolver();<br/>        viewResolver.setTemplateEngine(templateEngine);<br/>        return viewResolver;<br/>    }<br/><br/><br/>}</pre>
<p>In the preceding code, we did the following:</p>
<ol>
<li>Implemented the <kbd>WebFluxConfigurer</kbd> interface. This interface provides the <kbd>configureViewResolvers</kbd> method.</li>
<li>The <kbd>configureViewResolvers</kbd> method is invoked by the Spring context, along with a <kbd>ViewResolverRegistry</kbd>. We have to register a <kbd>ThymeleafReactiveViewResolver</kbd> with this.</li>
</ol>
<ol start="3">
<li><kbd>ThymeleafReactiveViewResolver</kbd> takes a <kbd>ISpringWebFluxTemplateEngine</kbd> engine, which is available with the Spring context.</li>
</ol>
<ol start="4">
<li>The template engine looks for a template under <kbd>src/main/resources/templates</kbd>. It also adds a <kbd>.html</kbd> suffix to a template name before doing a lookup.</li>
</ol>
<p>Now, let's add a Thymeleaf template to show the Fibonacci series. We would like to list the numbers as a simple HTML list, as follows:</p>
<pre>&lt;!DOCTYPE html&gt;<br/><br/>&lt;html &gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;Reactor Sample&lt;/title&gt;<br/>        &lt;meta charset="UTF-8"/&gt;<br/>        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;section class="container"&gt;<br/>            &lt;ul&gt;<br/>                &lt;li th:each="item : ${series}" th:text="${item}"&gt;&lt;/li&gt;<br/>            &lt;/ul&gt;<br/>        &lt;/section&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>In the preceding HTML template, we did the following:</p>
<ol>
<li>Added a <kbd>series</kbd> variable, containing a list of values.</li>
<li>Added <kbd>&lt;li th:each&gt;&lt;/li&gt;</kbd>, which iterates the series variable and renders individual elements.</li>
</ol>
<p>Now, save the file as <kbd>numbers.html</kbd>, under the path <kbd>src/main/resources/templates</kbd>.</p>
<div class="packt_tip">This book does not aim to cover the Thymeleaf syntax. Please refer to the official Thymeleaf documentation for that.</div>
<p><span>Now, the only configuration left is to use the template to render the Fibonacci series. First, let's use the template in our annotation—based controller approach:</span></p>
<pre>@Controller<br/>public class ReactiveController {<br/><br/>// Rest removed for Brevity<br/>@GetMapping("/numbers")<br/>    public String handleSeries(Model model) {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        model.addAttribute("series", fibonacciGenerator);<br/>        return "numbers";<br/>    }<br/>}</pre>
<p>In the preceding code, we did the following:</p>
<ol>
<li>We added the <kbd>@controller</kbd> annotation, instead of <kbd>@RestContoller</kbd>. The <kbd>RestController</kbd> annotation only renders a JSON response. On the other hand, the <kbd>@controller</kbd> annotation can render any kind of response.</li>
<li>We added <kbd>fibonacciGenerator(Flux&lt;&gt;)</kbd> to our model as a series. This will provide the series value to the Freemarker template.</li>
<li>Next, we returned the <kbd>numbers</kbd> string as the return value. The returned value will map to  the <kbd>number.html</kbd> template.</li>
</ol>
<p>Now, let's run <kbd>ReactorMain</kbd> and open <kbd>http://localhost:8080/numbers</kbd>. At this point, we will get back an HTML page listing the Fibonacci series, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e2bd3ce-e54e-4ffe-941d-08ec0e62d0bc.png" style=""/></div>
<p>Now, let's use the Thymeleaf view with our <kbd>HandlerFunction</kbd>. In order to do this, we have to change <kbd>ServerResponse</kbd>, as follows:</p>
<pre>@Configuration<br/>class FibonacciConfigurer {<br/>    <br/>    // Rest removed  For Brevity<br/>    <br/>     @Bean<br/>     RouterFunction&lt;ServerResponse&gt; fibonacciEndpoint() {<br/>         Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                 Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>             if (state.getT1() &lt; 0)<br/>                 sink.complete();<br/>             else<br/>                 sink.next(state.getT1());<br/>             return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>         });<br/>         Map&lt;String, Flux&gt; model = new HashMap&lt;&gt;();<br/>         model.put("series",fibonacciGenerator);<br/>         RouterFunction&lt;ServerResponse&gt; fibonacciRoute =<br/>                 RouterFunctions.route(RequestPredicates.path("/fibonacci"),<br/>                         request -&gt; ServerResponse.ok().render("numbers",model));<br/>         return fibonacciRoute;<br/>     }</pre>
<p>In the preceding code, we did the following:</p>
<ul>
<li>Instead of building <kbd>ServerResponse.body</kbd>, we are now using the render API. The API takes a view name and an optional map of attributes.</li>
<li>We provided the series values in the map by mapping the series key to the <kbd>fibonacciGenerator (Flux&lt;&gt;)</kbd>.</li>
</ul>
<p>Now, let's run <kbd>ReactorMain</kbd> and open <kbd>http://localhost:8080/fibonacci</kbd>. At this point, we will get back the same HTML page that lists the Fibonacci series.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scripting</h1>
                </header>
            
            <article>
                
<p>SpringWebFlux is also capable of using various scripting libraries for view ending. It uses the JSR-223 Java Scripting engine specification to integrate various scripting engines. At the time of writing this book, the following integrations are available:</p>
<ul>
<li>Handlebars, using the Nashrom engine</li>
<li>Mustache, using the Nashrom engine</li>
<li>React, using the Nashrom engine</li>
<li>EJS, using the Nashrom engine</li>
<li>ERB, using the JRuby engine</li>
<li>String, using the Jython engine</li>
<li>Kotlin, using the Kotlin engine</li>
</ul>
<p>In the following section, we will cover integration with Mustache. The integrations for the other options are similar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mustache</h1>
                </header>
            
            <article>
                
<p>Mustache is a simple template engine that is available in various languages. We will now use <kbd>Mustache.js</kbd>, the template engine in JavaScript. Mustache is often seen as logic-less, as it lacks explicit control flow statements. Control flow is achieved by using section tags.</p>
<div class="packt_tip">Refer to <a href="http://mustache.github.io/">http://mustache.github.io/</a> for more details about Mustache.</div>
<p>Now, let's try to configure Mustache to render our Fibonacci series. We don't need any other dependencies in our <kbd>build.gradle</kbd>:</p>
<pre>plugins {<br/>    id "io.spring.dependency-management" version "1.0.1.RELEASE"<br/>    id "org.springframework.boot" version "2.0.3.RELEASE"<br/>}<br/>apply plugin: 'java'<br/>// Rest removed for Brevity<br/><br/>dependencies {<br/>        compile 'org.springframework.boot:spring-boot-starter-webflux'<br/>}</pre>
<p class="mce-root">The Spring framework provides integration out of the box. The Spring context has a view resolver registry, which must be updated to include the <kbd>ScriptTemplate</kbd> resolver, as follows:</p>
<pre>@EnableWebFlux<br/>@Configuration<br/>public class WebfluxConfig implements WebFluxConfigurer {<br/><br/>   @Override<br/>    public void configureViewResolvers(ViewResolverRegistry registry) {<br/>        registry.scriptTemplate();<br/>   }<br/><br/>    @Bean<br/>    public ScriptTemplateConfigurer scrptTemplateConfigurer() {<br/>        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();<br/>        configurer.setEngineName("nashorn");<br/>        configurer.setScripts("mustache.js");<br/>        configurer.setRenderObject("Mustache");<br/>        configurer.setResourceLoaderPath("classpath:/mustache/");<br/>        configurer.setRenderFunction("render");<br/>        return configurer;<br/>    }<br/><br/><br/>}</pre>
<p> </p>
<p>In the preceding code, we did the following:</p>
<ul>
<li>Implemented the <kbd>WebFluxConfigurer</kbd> interface. This interface provides the <kbd>configureViewResolvers</kbd> method. </li>
<li>The <kbd>configureViewResolvers</kbd> method is invoked by the Spring context, along with <kbd>ViewResolverRegistry</kbd>. The registry provides the <kbd>scriptTemplate()</kbd> method to enable a scripting—based resolver.</li>
<li>Next, we must set parameters for <kbd>ScriptTempletConfigure</kbd>. The configurer needs to enable <kbd>Mustache.js</kbd>, and evaluate it using the Nashrom engine.</li>
<li><kbd>ScriptTempletConfigure</kbd> also specifies the location of the templates. In the preceding code, we configured the location as <kbd>src/main/resources/mustache</kbd>.</li>
<li>Since we are using <kbd>Mustache.js</kbd>, we also have to add <kbd>Mustache.js</kbd> (from <a href="http://github.com/janl/mustache.js">http://github.com/janl/mustache.js</a>) under the Mustache template location.</li>
</ul>
<p>Now, let's add a Mustache template to show the Fibonacci series. In this case, it would be beneficial to list the numbers as a simple HTML list, which is shown as follows:</p>
<pre>&lt;!DOCTYPE html&gt;<br/><br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;Reactor Sample&lt;/title&gt;<br/>        &lt;meta charset="UTF-8"/&gt;<br/>        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;section class="container"&gt;<br/>            {{#series}}<br/>            &lt;div class="row"&gt;<br/>                {{.}}<br/>            &lt;/div&gt;<br/>            {{/series}}<br/>        &lt;/section&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>In the preceding HTML template, the following has occurred:</p>
<ol>
<li>There is a <kbd>series</kbd> variable, containing a list of values.</li>
<li>The <kbd>{{#series}} {{/series}}</kbd> syntax iterates through the list, providing individual values.</li>
<li>The value is then rendered by using the <kbd>{{.}}</kbd> syntax in an HTML <kbd>?div&gt;</kbd> tag.</li>
</ol>
<p>Now, save the file as <kbd>numbers.html</kbd>, under the <kbd>src/main/resources/mustache</kbd><span> path</span><span>. The only configuration left</span><span> </span><span>is to use the <kbd>numbers.html</kbd> template to render the Fibonacci series. First, let's use the <kbd>numbers.html</kbd> template in our annotation—based controller approach:</span></p>
<pre>@Controller<br/>public class ReactiveController {<br/><br/>// Rest removed for Brevity<br/>@GetMapping("/numbers")<br/>    public String handleSeries(Model model) {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        model.addAttribute("series", fibonacciGenerator);<br/>        return "numbers.html";<br/>    }<br/>}</pre>
<p>In the preceding code, we did the following:</p>
<ul>
<li>We added the <kbd>@controller</kbd> annotation, instead of <kbd>@RestContoller</kbd>. The <kbd>RestController</kbd> annotation only renders a JSON response. The <kbd>@controller</kbd> annotation, on the other hand, allows us to render any kind of response.</li>
<li>We added <kbd>fibonacciGenerator(Flux&lt;&gt;)</kbd> to our model as a <kbd>series</kbd><em>.</em> This will provide the series value to the Mustache template.</li>
<li>Next, we returned the <kbd>numbers.html</kbd> string as the returned value. The returned value will map to the <kbd>number.html</kbd> template. This is unlike the previous template engines, which automatically added a suffix to the returned string value to determine the template.</li>
</ul>
<p>Now ,let's run <kbd>ReactorMain</kbd> and hit <kbd>http://localhost:8080/numbers</kbd>. At this point, we will get back an HTML page that lists the Fibonacci series, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c211af7-3ec0-4da4-9b3c-31c50e0f5382.png" style=""/></div>
<p class="mce-root"><span>Now, let's use the</span> Mustache <span>view with our</span> <kbd>HandlerFunction</kbd><span>. In order to do this, we have to change</span> <kbd>ServerResponse</kbd><span>, as follows:</span></p>
<pre>@Configuration<br/>class FibonacciConfigurer {<br/>    <br/>    // Rest removed  For Brevity<br/>    <br/>     @Bean<br/>     RouterFunction&lt;ServerResponse&gt; fibonacciEndpoint() {<br/>         Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                 Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>             if (state.getT1() &lt; 0)<br/>                 sink.complete();<br/>             else<br/>                 sink.next(state.getT1());<br/>             return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>         });<br/>         Map&lt;String, Flux&gt; model = new HashMap&lt;&gt;();<br/>         model.put("series",fibonacciGenerator);<br/>         RouterFunction&lt;ServerResponse&gt; fibonacciRoute =<br/>                 RouterFunctions.route(RequestPredicates.path("/fibonacci"),<br/>                         request -&gt; ServerResponse.ok().render("numbers.html",model));<br/>         return fibonacciRoute;<br/>     }</pre>
<p>In the preceding code, we did the following:</p>
<ol>
<li>Instead of building <kbd>ServerRespose.body</kbd>, we are now using the render API. The API takes a view name and an optional map of attributes.</li>
<li>We provided the series values in the map by mapping the series key to the <kbd>fibonacciGenerator (Flux&lt;&gt;)</kbd>.</li>
</ol>
<p>Now ,let's run <kbd>ReactorMain</kbd> and hit <kbd>http://localhost:8080/fibonacci</kbd>. In response, we will get the same HTML page listing the Fibonacci series.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about static resources</h1>
                </header>
            
            <article>
                
<p>A dynamic application often has static parts as well. SpringWebFlux also enables us to configure static resources. Let's suppose that we want to use <kbd>bootstrap.css</kbd> in our Thymeleaf application. In order to do this, we have to enable the server to determine the static content. This can be configured as follows:</p>
<pre>public class WebfluxConfig implements WebFluxConfigurer {<br/>    //Rest Removed for Brevity<br/>    @Override<br/>    public void addResourceHandlers(ResourceHandlerRegistry registry) {<br/>        registry.addResourceHandler("/resources/**")<br/>                .addResourceLocations("classpath:/static/");<br/>    }<br/>}</pre>
<p>In the preceding code, the following has occurred:</p>
<ol>
<li>The <kbd>addResourceHandler</kbd> method takes a URL pattern and configures it to be static locations which must be served by the server. In the preceding code, all of our static URLs should look like <kbd>like/resources/XXXX</kbd>.</li>
<li>The <kbd>addResourceLocations</kbd> method configures a location from which the static content must be served. In the preceding code, we have configured the location as <kbd>src/main/resources/static</kbd>.</li>
</ol>
<p>Now, let's download <kbd>bootstrap.css</kbd> to <kbd>src/main/resources/static</kbd>. This will be served on <kbd>/resources/bootstrap.min.css</kbd>. The only thing left to do is to include the <kbd>css</kbd> in our <kbd>numbers.html</kbd> Thymeleaf template, as follows:</p>
<pre>&lt;html &gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;Reactor Sample&lt;/title&gt;<br/>        &lt;meta charset="UTF-8"/&gt;<br/>        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;<br/>        &lt;link rel="stylesheet" href="/resources/bootstrap.min.css"&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;section class="container"&gt;<br/>            &lt;ul class="list-group"&gt;<br/>                &lt;li th:each="item : ${series}" th:text="${item}" class="list-group-item"&gt;&lt;/li&gt;<br/>            &lt;/ul&gt;<br/>        &lt;/section&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>In the preceding code, the following has occurred:</p>
<ol>
<li>The <kbd>&lt;link rel="stylesheet"../&gt;</kbd> will include the <kbd>css</kbd> from our server.</li>
<li>We have used a <kbd>container</kbd>, as well as <kbd>list-group</kbd> and <kbd>list-group-item</kbd> classes from Bootstrap, for our html elements.</li>
</ol>
<p>Now, run the server and open <kbd>http://localhost:8080/numbers</kbd>. The page is now formatted with a Bootstrap grid, as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/32eafbc7-d821-4444-93ae-8c22d5cf26b2.png" style=""/></div>
<p>The <kbd>ResourceHandlerRegistry</kbd> also enables us to configure cache control headers. It can also be used to build a chain of resolvers that can resolve <kbd>.gz</kbd> static resources and versioned resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebClient</h1>
                </header>
            
            <article>
                
<p>The SpringWebFlux framework also provides a non-blocking, asynchronous HTTP client for making requests. <strong>WebClient</strong> offers APIs that can be configured with Java 8 lambdas, for processing data. At the backend, the WebClient API configures Netty to perform the asynchronous, non-blocking communication<span>. Now, let's look at how we can use WebClient in our applications.</span></p>
<p>WebClient offers the following two methods for consuming data:</p>
<ul>
<li><kbd>Retrieve</kbd>: This is the simplest method, which decodes the body into a Flux or Mono.</li>
<li><kbd>Exchange</kbd>: If we are interested in the response received, the <kbd>exchange</kbd> method is suited for this purpose. It provides the complete message, which can be converted back to a target type. Consider the following code for this:</li>
</ul>
<pre style="padding-left: 60px">public void readFibonacciNumbers() {<br/>  WebClient client = WebClient.create("http://localhost:8080");<br/>  Flux&lt;Long&gt; result = client.get()<br/>          .uri("/fibonacci").accept(MediaType.APPLICATION_JSON)<br/>          .retrieve()<br/>          .bodyToFlux(Long.class);<br/>  result.subscribe( x-&gt; System.out.println(x));<br/>}</pre>
<p>In the preceding code, we built the WebClient to read the Fibonacci series response. This code  achieved the following:</p>
<ol>
<li>It created an instance of WebClient for the following location: <kbd>http://localhost:8080</kbd>.</li>
<li>The client makes an HTTP <kbd>GET</kbd> to <kbd>/fibonacci</kbd>, with the required <kbd>JSON ACCEPT</kbd> header.</li>
<li>It then invokes the <kbd>retrieve</kbd> method and converts the body to a <kbd>Flux&lt;Long&gt;</kbd>.</li>
<li>In the end, we subscribe to the Flux and print the numbers to the console.</li>
</ol>
<p>The same Fibonacci series can be processed using the <kbd>exchange</kbd> method, as follows:</p>
<pre>public void readFibonacciNumbersUsingExchange() {<br/>        WebClient client = WebClient.create("http://localhost:8080");<br/>        Flux&lt;Long&gt; result = client.get()<br/>                .uri("/fibonacci").accept(MediaType.APPLICATION_JSON)<br/>                .exchange()<br/>                .flatMapMany(response -&gt; response.bodyToFlux(Long.class));<br/>        result.subscribe( x-&gt; System.out.println(x));<br/>    }</pre>
<p>The following are the key differences between the <kbd>exchange</kbd> method and the <kbd>retrieve</kbd> method: </p>
<ul>
<li>The exchange method provides a <kbd>Mono&lt;ClientResponse&gt;</kbd>. This must be converted to a Flux by using the <kbd>flatMapMany</kbd> API.</li>
<li>We process the response body and transform it into a <kbd>Flux&lt;Long&gt;</kbd>.</li>
</ul>
<p>In addition to the differences stated in the preceding points, the <kbd>retrieve</kbd> method provides a convenient <kbd>onStatus</kbd> API. This method is used to invoke functions on the specified HTTP status code. On the other hand, in the <kbd>exchange</kbd> method, we get the complete response, so it is up to the developer to read the HTTP status code and invoke the required logic.</p>
<p>WebClient can be used to invoke HTTP <kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>, <kbd>DELETE</kbd>, <kbd>PATCH</kbd>, and <kbd>HEAD</kbd> methods. When using <kbd>POST</kbd>, we often have to add a request body. This is done by invoking the <kbd>body()</kbd> API, available with the <kbd>PUT</kbd> method. The API takes a Mono or a Flux of a specified type. Alternatively, if there is an object available, it can be processed by using the <kbd>syncBody()</kbd> method. The WebClient API also offers the following methods to configure a request:</p>
<ul>
<li><kbd>accepts</kbd>: Configures the <kbd>accepts request</kbd> header with the specified content type</li>
<li><kbd>acceptCharset</kbd>: Configures the <kbd>accepts-charset</kbd> request header</li>
<li><kbd>header(s)</kbd>: Configures the specified header(s) with the specified value(s)</li>
<li><kbd>attributes</kbd>: Adds the specified attributes to the request</li>
<li><kbd>cookies</kbd>: Adds a <kbd>cookies</kbd> header to the request</li>
</ul>
<p>The WebClient also provides a builder, which can be used to build a WebClient for the settings provided. This can be used to instantiate a client as a specific SSL context, or with default headers. The builder configuration is applied to the created instance of WebClient, and is thus invoked for every call we make using the instance.</p>
<p>SpringWebFlux also provides <kbd>WebTestClient</kbd>, which is an extension of WebClient, along with assertions to validate the response body and response status. The class can be instantiated in a manner similar to WebClient. After making a request using the <kbd>exchange</kbd> method, the response can be asserted by using the following methods:</p>
<ul>
<li><kbd>expectStatus()</kbd>: This method can validate response status codes, such as <kbd>OK</kbd> and <kbd>NOT_FOUND</kbd>.</li>
<li><kbd>expectHeader()</kbd>: This method can validate response headers, such as <kbd>MediaType</kbd>.</li>
<li><kbd>expectBody(class)</kbd>: This method can validate whether the response body can be converted to a specified class.</li>
<li><kbd>expectBodyList(class)</kbd>: This method can validate whether the response body can be converted to a list of specified class objects. Post conversion, it can validate the list size and the list objects.</li>
</ul>
<p><kbd>WebTestClient</kbd> can be  used to test and validate a <kbd>SpringWebFlux</kbd> application. <kbd>WebTestClient</kbd> provides different <kbd>bindXXX</kbd> methods, which can be used to configure a <kbd>WebTestClient</kbd> for an <kbd>ApplicationContext</kbd>, URL, controller, router function, and so on. It can then perform invocations against the configured resource, and validate the response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed how to render dynamic content, using the various template engines available with SpringWebFlux. We integrated Java-based template engines, Freemarker, and Thymeleaf. We also looked at how to enable a scripting-based engine, and how to work with Mustache.js. Next, we looked at serving static content by using <kbd>SpringWebFlux</kbd>. In the end, we discussed using WebClient to make asynchronous, non-blocking HTTP requests. We are now generating events and processing them. In  the next chapter we will discuss ways to perform flow-control and backpressure. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How does the <kbd>SpringWebFlux</kbd> framework resolve a view?</li>
<li>What components are configured to use the Thymeleaf template engine?</li>
<li>What API is used to configure static resources in SpringWebFlux?</li>
<li>What are the benefits of WebClient?</li>
<li>What is the difference between the retrieve and exchange WebClient APIs?</li>
</ol>


            </article>

            
        </section>
    </body></html>