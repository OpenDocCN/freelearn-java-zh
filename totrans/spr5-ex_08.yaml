- en: Circuit Breakers and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we configured the microservices that will act in our
    infrastructure, and we created a Eureka server to work as a service discovery
    for our solution. Also, we have created a Config Server application that will
    serve as the configurations for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create microservices to interact with our previous
    infrastructure. We will discover how to apply service discovery features for our
    business microservices and understand how the Circuit Breaker pattern can help
    us to bring resilience to our applications.
  prefs: []
  type: TYPE_NORMAL
- en: During the chapter, we will understand how the microservices can communicate
    with other services through the HTTP asynchronous call powered by the Spring WebFlux
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect microservices with service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pull the configuration from the configuration server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how `Hystrix` brings resilience to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the Edge API strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present the Spring Boot Admin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the service discovery power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create our first microservice with business requirements. We will create
    a `planes` microservice, which will maintain data about company planes, such as
    characteristics, model, and some other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The `planes` microservice will be used to serve plane characteristics for our
    second microservice, the `flights` microservice. It needs to get some plane information
    to be able to create a flight, such as the number of seats.
  prefs: []
  type: TYPE_NORMAL
- en: The `planes` microservice is an excellent candidate to start with because there
    is no business-related dependency to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Our `planes` microservice will be useful soon. Time to create it. Let's go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the planes microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have been doing in the previous chapters, we will use the Spring Initializr
    for that purpose. The following dependencies should be selected, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f843a799-fdab-4014-bfe5-b58fb1578a55.png)'
  prefs: []
  type: TYPE_IMG
- en: There are some necessary dependencies. The Stream Binder Rabbit and Sleuth Stream
    dependencies are necessary to enable us to the send data spans, and to enable
    application trace, across to the RabbitMQ message broker. We will use MongoDB
    to act as a database for this specific application, so we need Reactive MongoDB
    for that. Config Client is mandatory for all microservices present in the solution.
    We will not have any application configuration on the classpath. The Actuator
    provides production-ready metrics and information about the running application;
    it's an essential characteristic of the microservice's architectural style. Moreover, Zuul
    will be essential to enable us to connect the application with our Edge API. We
    will learn more about it during the course of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can now press the Generate Project button to download the project. Open the
    project on the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The `planes` microservice will be created using the Spring Boot 2 framework
    because we are interested in implementing the reactive foundation for our plane
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need to include one more dependency, and it can be done using the
    following snippet on our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `spring-cloud-starter-netflix-eureka-client` enables the service discovery,
    powered by the Eureka server in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the planes microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add some features on the application. For this specific application,
    we will create CRUD functionalities with Spring Reactive WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Plane` class represents the plane model in our microservices and the class
    should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The interesting point is the `@Document` annotation. It enables us to configure
    the name of  the MongoDB collection for our domain. The `@Builder` annotation
    creates an implementation of the Builder pattern using the annotated method. The `Project Lombok` library
    provides this feature ([https://projectlombok.org](https://projectlombok.org)).
    Also, the project has some exciting features, such as `@Data`, which creates `getters/setters`,
    `equals`, and `hashCode` implementation automatically for the annotated class.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are some domain models in this class. These models do not
    need explanation here, and the full source code can be found in the GitHub project
    at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes).
  prefs: []
  type: TYPE_NORMAL
- en: The reactive repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Plane` class needs a repository to persist the data to a database. We
    will use a reactive repository for MongoDB provided by the Spring Reactive MongoDB
    implementation. We will use the `ReactiveCrudRepository` as it makes our repositories
    reactive. Our repository should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is the same as it was in the previous Spring Data versions,
    except for the new reactive interface. Now, we can create our service layer in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Plane service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `PlaneService` will be responsible for creating a kind of glue between
    the `PlaneRepository` and `PlaneResource`; the latter one we will create in the
    next section. The implementation should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special in this class, and the `PlaneService` will invoke the
    `PlaneRepository` to persist the `Plane` in a database. As we can see, we have
    used lambdas extensively. Java 8 is a requirement to run Spring Boot 2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at how the Builder pattern enables us to write clean code. It is
    much easier to read this code; we did it using the `chaining` method provided
    by Lombok.
  prefs: []
  type: TYPE_NORMAL
- en: The REST layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring WebFlux to expose our REST endpoints, and then we need to
    return `Mono` or `Flux` in our methods. The REST implementation should be like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the `plane` method. When `planeService.plane(id)` returns the
    empty Mono, the REST endpoint will return `notFound` like this implementation: `ResponseEntity.notFound().build()`.
    It makes the code extremely easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: On the `newPlane` method, we will return the `location` HTTP header with the
    new entity ID recently created.
  prefs: []
  type: TYPE_NORMAL
- en: Running the plane microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we run the plane microservice, we will create the `plane` microservice''s `main`
    class. It will be responsible for starting the application. To do that, we need
    to include a couple of Spring Annotations. The class implementation can be like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Spring Annotations will be connected with the Zuul proxy. Also, we need
    to connect the application with the Eureka server and configure the application
    automatically. These behaviors can be done using `@EnableZuulProxy`, `@EnableEurekaClient`,
    and `@SpringBootApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a `bootstrap.yaml` file to instruct the Spring Framework
    to search the configuration file on the Config Server, created in the previous
    chapter. The file should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have configured the Config Server address; it was a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add the `application.yaml` file on the GitHub repository, because
    the Config Server will try to find the file in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The file can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: We can run the application on the IDE or via the command line; it is up to you.
    Check that the Config Server, Eureka, MongoDB, and RabbitMQ are up and running
    before trying to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Docker compose file located on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml)). It
    contains RabbitMQ, Config Server, Eureka, MongoDB, MySQL, Redis, and Zipkin containers
    ready to use. If you are using it, run it using the following command: `docker-compose
    -f docker-compose-infra-full.yaml up -d`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the output. We can check it in different ways: on a console, and
    on the Eureka server. Let''s do it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the console. Let''s try to find a line about `DiscoveryClient`. The `planes` microservice
    is trying to connect to the Eureka server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e16ec109-87eb-440a-9e6d-18831ce17433.png)'
  prefs: []
  type: TYPE_IMG
- en: There is some important information on the log files here. The first line indicates
    which application is trying to register with the Eureka server. The next four
    lines are about Sleuth. The Sleuth framework is registering the RabbitMQ queues
    and channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can check the Eureka server, and we can see the PLANES application
    there, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d99adcbd-ebe3-4e58-a3bb-511982067efb.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome, our plane microservice is operational.
  prefs: []
  type: TYPE_NORMAL
- en: We can try our microservices using Postman. This application enables us to call
    our APIs using the intuitive IDE to interact with our microservice. The application
    permits us to group some HTTP calls into collections. The planes collection can
    be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection).
  prefs: []
  type: TYPE_NORMAL
- en: We have finished our first microservices. In the next section, we will create
    our `flights` microservice, which will consume the plane's data.
  prefs: []
  type: TYPE_NORMAL
- en: Flights microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our plane's microservices are up and running. It will be important for now because
    the flight's microservice needs to get the plane's data to create the flight's
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce the Netflix Ribbon, which will act as a client load balancer for
    our applications, and we will consume the service discovery to look up the service's
    address from the service registry.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the Flight microservice project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did this task many times in the previous chapter. We can download the project
    source code on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights).
    In the next section, we will dive deep into Ribbon and how it can help us on distributed
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ribbon is an open source project created and maintained by the Netflix company.
    The project is licensed under Apache 2.0 and can be used for commercial purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The Ribbon provides a client-side software load balancing algorithm for the
    **IPC** (**Inter-Process Communication**). The project supports most popular protocols,
    such as TCP, UDP, and HTTP in an asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: There are more interesting features, such as service discovery integration,
    which enables integration in dynamic and elastic environments such as the cloud.
    For this purpose, we will look at our Eureka server. Both projects are maintained
    by the Netflix team. It fits well for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature is fault tolerance. The Ribbon client can find the
    live servers on the configured list and send the request. Also, the down servers
    will not receive any request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains how the Ribbon works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/820f3ed5-dfd1-4004-b1be-db2802b3ad48.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the **Ribbon Client** can communicate with Eureka and then redirect
    the request for the desired microservice. In our case, the `flights` microservice
    will use the Ribbon client and get the service registry from Eureka and redirect
    the call to a live `planes` microservice instance. It sounds like an amazing solution.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the discovery client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will learn about service discovery and how it works in complex and dynamic
    environments. The basic idea of service discovery is to maintain the services
    repository and provide service addresses for the callers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It requires some complex tasks to achieve this goal. There are two main behaviors
    to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the register. As we know, the service discovery needs to store
    the services information, such as the address and name, and then during the service
    bootstrap, it needs to send the information to the service registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the the second operation, the service discovery clients need to query the
    service registry, asking for the desired service name, for instance. Then the
    service registry will send the service information to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we understand the basics, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4083209-d7bd-4c6b-b3cd-40d9a729d7e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part is the service registration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the second stage, the service client will get the service address from the
    Eureka server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the client can call based on the service information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's do it in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery and load balancing in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will write some code to interact with our service discovery and load
    balance infrastructure. Now we know how it works, it will help us to understand
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `DiscoveryService` class which will discover the addresses
    from a requested service name. The class code should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we inject two objects: the `LoadBalanceClient`, which acts as
    a client load balancer, that is, Netflix Ribbon; and the `DiscoveryClient`, which
    will find the instance from a requested service.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the lambda `Flux.defer()` to organize the flow, and then we will look
    up the service instances from Eureka server. We use `this.dClient.getInstances(service)`
    for that. It will return a list of service names after we look up the service
    URI from the load balancing. This will be done using `this.lbClient.choose(service).` Then
    we will return the `Flux` of service instances addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to see how the client code can use the `DiscoveryService` object.
    The client code can be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code can be found in the `PlaneService` class on the project. Remember
    the `serviceAddressFor()` method returns a `Flux` of service addresses. We will
    get the first one, using the `next()` method. Then we are able to transform the
    service address to a valid address to reach the plane microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will test the service connections. We need to do the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the Config Server, Eureka, the `planes` microservice, and the `flights` microservice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `plane` entity on the `planes` microservice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `flight` entity on the `flights` microservice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check whether all services listed previously are up and running. Then we will
    create a `plane` entity using the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to call the `planes` microservice in `http://localhost:50001/planes`
    using the HTTP `POST` method. We can find the request to create planes in the `Planes
    Collection` on Postman. When we have called the create plane API, we will get
    a new plane ID. It can be found in the HTTP response headers, as shown in the
    following image, on Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: Postman is a tool that helps developers to test APIs. Postman provides a friendly
    **GUI** ( **Graphic User Interface** ) to make requests. Also, the tool supports
    environments and it can be helpful to test different environments, such as development,
    test, and production.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b53de5d-bfbf-47e9-b94f-0b4546b704a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the `location` HTTP response header. The HTTP status code is
    important as well. We will use the plane ID `5a6a6c636798a63817bed8b4`, created
    just now, to create a new flight.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the list of HTTP status code at *W3 Org* ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)). Keep
    this in mind, as it is very important to follow the correct status code. It is
    considered a best practice when we are creating REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flight Collection can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection.](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection) There
    is a Create Flight request we want to execute, but before that, we need to change
    our plane ID created previously. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb4f809-352a-4159-87a4-3c27279de042.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The plane ID has changed to that of our plane previously created. Now we can
    execute the request. The `flights` microservices has the same behavior as a `planes`
    microservice. It will return the location response with the new flight ID. In
    my case, the new ID generated is like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4364b1a9-f2a6-4c11-b823-1804bb6ce2a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can find the flight by ID. The request can be found at Flight Collection*;* the
    name is Flight by Id. We can execute this request, and the result should be like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8f8a66f-921b-49d8-9377-262e0007328f.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the `plane` JSON node. We don't have any data about a plane in
    the `flight` microservice. This information came in from the `planes` microservice.
    We have used service discovery and client load balancing. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the debug provided by the IDE. We want to see the plane
    service address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf33f5c5-78ea-4539-896a-37e3236509b2.png)'
  prefs: []
  type: TYPE_IMG
- en: On the Variables panel, we can see the address variable. The value came in from
    service discovery and client load balancing. It is the **Service IP** or **Domain**
    **Name**. Now we are able to call the requested service transforming the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, our infrastructure works very well, now we are able to find services
    using the infrastructure, but there is something important to pay attention to.
    We will discover it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: When the services fail, hello Hystrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the infrastructure can fail, especially the network. It can cause
    some problems in microservices architecture because in general there are many
    connections between services. It means at runtime that the microservices depend
    on other microservices. Normally these connections are done using the REST APIs
    through the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can cause a behavior called **cascade failure**; that is, when one part
    of the microservices system fails, it can trigger the other microservices failure,
    because of the dependencies. Let''s illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e43b89-aee2-4e59-9731-eb74a060b52b.png)'
  prefs: []
  type: TYPE_IMG
- en: If **Service Y** fails, **Service A** and **Service M** potentially can fail
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a pattern to help us when this happens: the Circuit Breaker.'
  prefs: []
  type: TYPE_NORMAL
- en: Hystrix in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Hystrix` is a library that helps developers to manage interactions between
    services. The project is open source, maintained by the community, and is under
    the Netflix GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Circuit Breaker pattern is a pattern that helps to control the system integrations.
    The idea is quite simple: we will wrap the remote call in a function or object,
    and we will monitor these calls to keep track of the failures. If the calls reach
    the limit, the circuit will open. The behavior is like that of an electrical circuit
    breaker, and the idea is the same—protect something to avoid breaking the electrical
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26cfb6de-0d7d-4a13-8611-f9b5a2c373c5.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Hystrix` implements the Circuit Breaker pattern and has some interesting behaviors,
    such as fallback options. `Hystrix` provides resilience for our applications.
    We are able to provide a fallback, stop cascading failures, and give the operational
    control.'
  prefs: []
  type: TYPE_NORMAL
- en: The library provides high-level configurations and it can be configured through
    an annotation if we are using `Spring Cloud Hystrix`.
  prefs: []
  type: TYPE_NORMAL
- en: The Circuit Breaker pattern was described by Martin Fowler. You can find more
    information about it on Martin Fowler's Page at [https://martinfowler.com/bliki/CircuitBreaker.html](https://martinfowler.com/bliki/CircuitBreaker.html)
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Hystrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we expected, Spring Boot integrates with `Netflix Hystrix.` The integration
    can be done using a couple of annotations and by configuring the annotations with
    Hystrix properties. We will protect the `planes` microservice interactions we
    are coding in the `flight` service. We now have a method that tries to get the
    plane's data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are some configurations for this command. The first configuration is `commandKey.` The
    basic idea here is to create a name for the command. It will be useful for panel
    control. The second one, `groupKey`, is the command used to group the commands.
    It also helps in grouping commands data together on dashboards. There is the concept
    of a rolling window. The idea is to group the request in a gap of time; it is
    used to enable metrics and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '`circuitBreaker.requestVolumeThreshold` configures the number of requests in
    a rolling window that will trip at the circuit. For example, if we have a rolling
    window configured to be open for 10 seconds, if we have nine requests in a gap
    of 10 seconds, the circuit will not open because we have configured it to 10 in
    our command. Another configuration is `circuitBreaker.sleepWindowInMilliseconds`,
    where the basic idea is to give an amount of time, after tripping the circuit,
    to reject requests before trying again to allow attempts.'
  prefs: []
  type: TYPE_NORMAL
- en: The last one is `execution.isolation.thread.timeoutInMilliseconds.` This property
    configures the timeout for the command. It means that if the time configured is
    reached, the circuit breaker system will perform a fallback logic and mark the
    command as a timeout.
  prefs: []
  type: TYPE_NORMAL
- en: The `Hystrix` library is highly customizable, and there are a lot of properties
    to use. The full documentation can be found at [https://github.com/Netflix/Hystrix/wiki/configuration.](https://github.com/Netflix/Hystrix/wiki/configuration) We
    can use these properties for different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot Admin project is a tool that helps developers in production
    environments. The tool shows Spring Boot application metrics in an organized dashboard,
    and it makes it extremely easy to see application metrics and much more information.
  prefs: []
  type: TYPE_NORMAL
- en: The tool uses the data from the Spring Boot Actuator as an information source.
    The project is open source and has a lot of contributors and is an active project
    in the community as well.
  prefs: []
  type: TYPE_NORMAL
- en: Running Spring Boot Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a piece of cake to set up the application. We will need a new Spring Boot
    application, and to connect this new application with our service discovery implementation.
    Let's do it right now.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the code on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin).
    If you want to create a new application, go ahead; the process is similar to what
    we did in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is a Spring Boot regular application, with two new dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These dependencies are about `admin-server` and `admin-server-ui`. The project
    does not support Spring Boot 2 yet, but this is not a problem as we do not need
    reactive stuff for this; it is a monitoring tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have configured our mandatory dependencies. We will need a service discovery
    because we have one in our infrastructure. We need it to provide the service discovery
    feature, and minimize the configurations for our Spring Boot Admin application.
    Let''s add the Eureka client dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome, our dependencies are configured properly. Then we can create our main
    class. The main class should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference here is that `@EnableAdminServer` will configure the Spring
    Boot Admin application and set up the server for us. As we expected, we will use
    the Config Server application to store our `application.yaml`. In order to achieve
    this, we need to create our `bootstrap.yaml`, which should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: No difference at all,  `bootstrap.yaml` is configured to look up the configuration
    file from the Config Server.
  prefs: []
  type: TYPE_NORMAL
- en: Time to create our `application.yaml` file, to which we need to add some configuration
    to set the new health check URL, since the actuator on Spring Boot 2 was moved,
    prefixed by *actuator*. Our new health check URL should be `/actuator/health`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our configuration file should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have configured the Eureka server address and set the health check URL.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run our main class called `AdminApplication.` We can use the Java
    command line or IDE; there is no difference at all.
  prefs: []
  type: TYPE_NORMAL
- en: Run it!
  prefs: []
  type: TYPE_NORMAL
- en: 'We should see the following line at the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c8e76dd-dd5c-41f4-8180-52587573730b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome, our application is ready to use. Now we can go to the main page. Go
    to `http://localhost:50015/#/` (main page), then we can see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe35b8f6-a74e-48e6-9d9c-389c824e2d8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Look how it is easier to see any outage or strange behaviors in our microservices.
    Remember the key point in microservices architecture is monitoring. It is really
    necessary in order to have a good environment.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Cloud Gateway is the natural choice when we adopt the microservices
    architecture, but nowadays the Spring Cloud Gateway does not have support enabled
    for service discovery features, such as the Eureka server. It means we will have
    to configure it route by route. This does not sound good.
  prefs: []
  type: TYPE_NORMAL
- en: We have the Zuul proxy as a gateway for our microservices environment, but keep
    in mind the Spring Cloud Gateway is the best choice when the project has support
    for service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the Zuul proxy project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the EDGE service project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The EDGE service is a service that provides dynamic routing, monitoring, resiliency,
    and security. The basic idea here is to create a reverse proxy for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: This service will act as a proxy for our microservices and will be exposed as
    a central access point. The Spring Cloud Zuul integrates with the Eureka server.
    It will increase our resiliency because we will use the service discovery feature
    provided by the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image demonstrates how we will use the **Edge Service** in our
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3e92e86-ea33-4eaa-8516-b7c2bafbbd53.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the **Zuul Server** will connect to the service discovery server,
    to get the list of available services. After that the Zuul service will redirect
    to the requested service.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the diagram. There is no interaction with the clients, that is, **Mobile**
    and **Browser**, and our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Zuul also supports interesting features, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pre**: This can be used to set some data in`RequestContext`; it is executed
    before the request is routed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**route**: This handles the request routing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**post**: This filters which one acts after the request is routed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**error**: When some errors happen, we can use the error feature to handle
    the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not use these features, but keep in mind that they can be very useful.
    Remember, our Zuul server is our gateway to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EDGE server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Zuul server to act as an API gateway for our applications. Now
    it's time to create our project. As there is no relevant difference involved in
    creating this project, we will take a look at specific Zuul parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency required is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It will configure for us the Zuul server dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add the project''s main class. The class should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The new thing here is `@EnableZuulProxy`. It will set up a Zuul server endpoint
    and configure reverse proxy filters. Then we will be able to forward a request
    to microservices applications. Zuul integrates with the Eureka server, so we do
    not need to configure it manually. The auto-configuration will find the services
    at the time of the discovery client implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the application via the command line or IDE, it is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can see the routes configured. Go to `http://localhost:8888/routes`
    and we will able to see the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d7729e9-8590-4edd-bb95-c73b78c437d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have some routes configured. We did this using the `application.yaml` file.
    The file should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand this configuration. We have created a node called `planes`.
    This node configures a `path` (that is the URI) and configures the service name,
    by `serviceId`, registered in the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a simple test. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the new URL path for the planes service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the request using the Zuul server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the `PlaneResource` class located in the `planes` microservice project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RequestMapping` is configured like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Remember we can use the Zuul server as a router, so we do not need this information
    anymore. With the URI path on the source code, we are able to use the configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `planes` microservice again. The following services need to be running:'
  prefs: []
  type: TYPE_NORMAL
- en: Config Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eureka server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planes microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then we can call the `planes` microservices using the Zuul proxy. Let''s do
    it using cURL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand this a little bit. The port `8888` points to the **Zuul Server**,
    and we have configured it in `application.yaml`. When the path is `/api/v1/planes/**`,
    the **Zuul Server** will redirect to the `planes` microservices. The basic flow
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39a82733-8ff4-48c2-8304-5a6551a105f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The request is coming to the **Zuul Server**, and then the **Zuul Server**
    will redirect it to the requested microservice. The result should be like this;
    in my case, I have some planes in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32018be4-666f-4285-afd8-a67409a980b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome, our API Gateway is fully operational. We will use it for all services
    in the same port, and only the URI will be changed to point to the desired `serviceId`.
  prefs: []
  type: TYPE_NORMAL
- en: We can configure the port like in other Spring Boot applications. We chose the
    `8888` port in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about some important microservice patterns
    and how they can help us to deliver a fault-tolerant, resilient, and error-prone
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We have practiced how to use the service discovery feature provided by the Spring
    Framework and how it works at the application runtime, and we made some debug
    tasks to help us to understand how it works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: The Hystrix project, hosted by Netflix, can increase our application's resilience
    and fault tolerance. When working with remote calls, in this section, we made
    some Hystrix commands and understood how Hystrix is a useful implementation of
    the Circuit Breaker pattern.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we are able to understand the microservices drawbacks
    and how to solve the common problems in a distributed environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to solve the common problems of microservices architectural
    style using the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finish our *Airline Ticket System*, using the configured
    tools to monitoring the microservices' health and look at how it helps developers
    during the operation time when the microservices are running in the production
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: See you there.
  prefs: []
  type: TYPE_NORMAL
