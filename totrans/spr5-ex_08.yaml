- en: Circuit Breakers and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器和安全
- en: In the previous chapter, we configured the microservices that will act in our
    infrastructure, and we created a Eureka server to work as a service discovery
    for our solution. Also, we have created a Config Server application that will
    serve as the configurations for our microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们配置了将在我们的基础设施中运行的微服务，并创建了一个 Eureka 服务器作为我们解决方案的服务发现。此外，我们还创建了一个 Config
    Server 应用程序，它将为我们的微服务提供服务配置。
- en: In this chapter, we will create microservices to interact with our previous
    infrastructure. We will discover how to apply service discovery features for our
    business microservices and understand how the Circuit Breaker pattern can help
    us to bring resilience to our applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建微服务来与我们的先前基础设施交互。我们将发现如何为我们的业务微服务应用服务发现功能，并了解断路器模式如何帮助我们为应用程序带来弹性。
- en: During the chapter, we will understand how the microservices can communicate
    with other services through the HTTP asynchronous call powered by the Spring WebFlux
    client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解微服务如何通过由 Spring WebFlux 客户端提供的 HTTP 异步调用来与其他服务进行通信。
- en: 'By the end of this chapter, we will have learned how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学会如何：
- en: Connect microservices with service discovery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务发现连接微服务
- en: Pull the configuration from the configuration server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置服务器拉取配置
- en: Understand how `Hystrix` brings resilience to microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `Hystrix` 如何为微服务带来弹性
- en: Show the Edge API strategy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示边缘 API 策略
- en: Present the Spring Boot Admin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示 Spring Boot Admin
- en: Understanding the service discovery power
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务发现的力量
- en: We will create our first microservice with business requirements. We will create
    a `planes` microservice, which will maintain data about company planes, such as
    characteristics, model, and some other attributes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据业务需求创建我们的第一个微服务。我们将创建一个 `planes` 微服务，该微服务将维护有关公司飞机的数据，例如特性、型号和其他属性。
- en: The `planes` microservice will be used to serve plane characteristics for our
    second microservice, the `flights` microservice. It needs to get some plane information
    to be able to create a flight, such as the number of seats.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`planes` 微服务将被用来为我们第二个微服务，即 `flights` 微服务，提供飞机特性。它需要获取一些飞机信息以便能够创建航班，例如座位数。'
- en: The `planes` microservice is an excellent candidate to start with because there
    is no business-related dependency to be created.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`planes` 微服务是一个很好的起点，因为没有需要创建与业务相关的依赖项。'
- en: Our `planes` microservice will be useful soon. Time to create it. Let's go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `planes` 微服务很快就会变得有用。是时候创建它了。让我们开始吧。
- en: Creating the planes microservice
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `planes` 微服务
- en: 'As we have been doing in the previous chapters, we will use the Spring Initializr
    for that purpose. The following dependencies should be selected, as shown in the
    following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中所做的那样，我们将使用 Spring Initializr 来实现这个目的。以下是一些应该选择的依赖项，如以下截图所示：
- en: '![](img/f843a799-fdab-4014-bfe5-b58fb1578a55.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f843a799-fdab-4014-bfe5-b58fb1578a55.png)'
- en: There are some necessary dependencies. The Stream Binder Rabbit and Sleuth Stream
    dependencies are necessary to enable us to the send data spans, and to enable
    application trace, across to the RabbitMQ message broker. We will use MongoDB
    to act as a database for this specific application, so we need Reactive MongoDB
    for that. Config Client is mandatory for all microservices present in the solution.
    We will not have any application configuration on the classpath. The Actuator
    provides production-ready metrics and information about the running application;
    it's an essential characteristic of the microservice's architectural style. Moreover, Zuul
    will be essential to enable us to connect the application with our Edge API. We
    will learn more about it during the course of the chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些必要的依赖项。Stream Binder Rabbit 和 Sleuth Stream 依赖项是必要的，使我们能够发送数据跨度，并启用应用程序跟踪，通过
    RabbitMQ 消息代理。我们将使用 MongoDB 作为此特定应用程序的数据库，因此我们需要 Reactive MongoDB。Config Client
    对于解决方案中存在的所有微服务都是强制性的。我们不会在类路径上有任何应用程序配置。Actuator 提供了生产就绪的指标和关于运行应用程序的信息；这是微服务架构风格的一个基本特征。此外，Zuul
    将是连接应用程序与我们的边缘 API 的关键。我们将在本章的学习过程中了解更多关于它的信息。
- en: We can now press the Generate Project button to download the project. Open the
    project on the IDE.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按下“生成项目”按钮来下载项目。在 IDE 中打开项目。
- en: The `planes` microservice will be created using the Spring Boot 2 framework
    because we are interested in implementing the reactive foundation for our plane
    service.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用 Spring Boot 2 框架创建 `planes` 微服务，因为我们感兴趣的是为我们的飞机服务实现响应式基础。
- en: 'Also, we need to include one more dependency, and it can be done using the
    following snippet on our `pom.xml`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要包含一个额外的依赖项，这可以通过在 `pom.xml` 上的以下片段来完成：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `spring-cloud-starter-netflix-eureka-client` enables the service discovery,
    powered by the Eureka server in our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-cloud-starter-netflix-eureka-client` 允许我们的应用程序通过 Eureka 服务器实现服务发现。'
- en: Coding the planes microservice
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写飞机微服务
- en: We will add some features on the application. For this specific application,
    we will create CRUD functionalities with Spring Reactive WebFlux.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中添加一些功能。对于这个特定的应用程序，我们将使用 Spring Reactive WebFlux 创建 CRUD 功能。
- en: 'The `Plane` class represents the plane model in our microservices and the class
    should be like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plane` 类代表我们的微服务中的飞机模型，该类应该像这样：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interesting point is the `@Document` annotation. It enables us to configure
    the name of  the MongoDB collection for our domain. The `@Builder` annotation
    creates an implementation of the Builder pattern using the annotated method. The `Project Lombok` library
    provides this feature ([https://projectlombok.org](https://projectlombok.org)).
    Also, the project has some exciting features, such as `@Data`, which creates `getters/setters`,
    `equals`, and `hashCode` implementation automatically for the annotated class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的点在于 `@Document` 注解。它使我们能够配置领域 MongoDB 集合的名称。`@Builder` 注解使用注解的方法创建构建者模式的实现。`Project
    Lombok` 库提供了这个功能 ([https://projectlombok.org](https://projectlombok.org))。此外，该项目还有一些令人兴奋的功能，如
    `@Data`，它为注解的类自动创建 `getters/setters`、`equals` 和 `hashCode` 实现。
- en: As we can see, there are some domain models in this class. These models do not
    need explanation here, and the full source code can be found in the GitHub project
    at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个类中有一些领域模型。这些模型在这里不需要解释，完整的源代码可以在 GitHub 项目中找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes)。
- en: The reactive repository
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式仓库
- en: 'Our `Plane` class needs a repository to persist the data to a database. We
    will use a reactive repository for MongoDB provided by the Spring Reactive MongoDB
    implementation. We will use the `ReactiveCrudRepository` as it makes our repositories
    reactive. Our repository should be like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Plane` 类需要一个仓库将数据持久化到数据库中。我们将使用 Spring Reactive MongoDB 实现提供的响应式仓库。我们将使用
    `ReactiveCrudRepository`，因为它使我们的仓库变得响应式。我们的仓库应该像这样：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The implementation is the same as it was in the previous Spring Data versions,
    except for the new reactive interface. Now, we can create our service layer in
    the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与之前的 Spring Data 版本相同，只是新增了响应式接口。现在，我们可以在下一节创建我们的服务层。
- en: Creating the Plane service
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建飞机服务
- en: 'Our `PlaneService` will be responsible for creating a kind of glue between
    the `PlaneRepository` and `PlaneResource`; the latter one we will create in the
    next section. The implementation should be like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PlaneService` 将负责在 `PlaneRepository` 和 `PlaneResource` 之间创建一种粘合剂；后者我们将在下一节中创建。实现应该像这样：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is nothing special in this class, and the `PlaneService` will invoke the
    `PlaneRepository` to persist the `Plane` in a database. As we can see, we have
    used lambdas extensively. Java 8 is a requirement to run Spring Boot 2 applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有特别之处，`PlaneService` 将调用 `PlaneRepository` 将 `Plane` 持久化到数据库中。正如我们所看到的，我们广泛地使用了
    lambda 表达式。Java 8 是运行 Spring Boot 2 应用程序的要求。
- en: Take a look at how the Builder pattern enables us to write clean code. It is
    much easier to read this code; we did it using the `chaining` method provided
    by Lombok.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看看构建者模式如何使我们能够编写干净的代码。阅读这段代码要容易得多；我们使用了 Lombok 提供的 `chaining` 方法来编写它。
- en: The REST layer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 层
- en: 'We will use Spring WebFlux to expose our REST endpoints, and then we need to
    return `Mono` or `Flux` in our methods. The REST implementation should be like
    this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring WebFlux 来公开我们的 REST 端点，然后我们需要在我们的方法中返回 `Mono` 或 `Flux`。REST 实现应该像这样：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Take a look at the `plane` method. When `planeService.plane(id)` returns the
    empty Mono, the REST endpoint will return `notFound` like this implementation: `ResponseEntity.notFound().build()`.
    It makes the code extremely easy to understand.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`plane`方法。当`planeService.plane(id)`返回空的Mono时，REST端点将返回`notFound`，如下实现：`ResponseEntity.notFound().build()`。这使得代码极其易于理解。
- en: On the `newPlane` method, we will return the `location` HTTP header with the
    new entity ID recently created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`newPlane`方法中，我们将返回带有新实体ID的`location` HTTP头。
- en: Running the plane microservice
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行飞机微服务
- en: 'Before we run the plane microservice, we will create the `plane` microservice''s `main`
    class. It will be responsible for starting the application. To do that, we need
    to include a couple of Spring Annotations. The class implementation can be like
    this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行飞机微服务之前，我们将创建`plane`微服务的`main`类。它将负责启动应用程序。为此，我们需要包含几个Spring注解。类实现可以像这样：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Spring Annotations will be connected with the Zuul proxy. Also, we need
    to connect the application with the Eureka server and configure the application
    automatically. These behaviors can be done using `@EnableZuulProxy`, `@EnableEurekaClient`,
    and `@SpringBootApplication`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Spring注解将与Zuul代理连接。此外，我们需要将应用程序与Eureka服务器连接，并自动配置应用程序。这些行为可以使用`@EnableZuulProxy`、`@EnableEurekaClient`和`@SpringBootApplication`来完成。
- en: 'Now, we will create a `bootstrap.yaml` file to instruct the Spring Framework
    to search the configuration file on the Config Server, created in the previous
    chapter. The file should be like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`bootstrap.yaml`文件来指导Spring框架在上一章创建的配置服务器上搜索配置文件。文件应该像这样：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have configured the Config Server address; it was a piece of cake.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了配置服务器的地址；这简直易如反掌。
- en: Now, we need to add the `application.yaml` file on the GitHub repository, because
    the Config Server will try to find the file in the repository.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在GitHub仓库中添加`application.yaml`文件，因为配置服务器将尝试在仓库中找到该文件。
- en: The file can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml)。
- en: We can run the application on the IDE or via the command line; it is up to you.
    Check that the Config Server, Eureka, MongoDB, and RabbitMQ are up and running
    before trying to run it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在IDE中运行应用程序或通过命令行运行；这取决于你。在尝试运行之前，请检查配置服务器、Eureka、MongoDB和RabbitMQ是否正在运行。
- en: 'We can use the Docker compose file located on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml)). It
    contains RabbitMQ, Config Server, Eureka, MongoDB, MySQL, Redis, and Zipkin containers
    ready to use. If you are using it, run it using the following command: `docker-compose
    -f docker-compose-infra-full.yaml up -d`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用位于GitHub上的Docker Compose文件([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml))。它包含RabbitMQ、配置服务器、Eureka、MongoDB、MySQL、Redis和Zipkin容器，可供使用。如果您正在使用它，请使用以下命令运行它：`docker-compose
    -f docker-compose-infra-full.yaml up -d`。
- en: 'Let''s check the output. We can check it in different ways: on a console, and
    on the Eureka server. Let''s do it.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查输出。我们可以以不同的方式检查它：在控制台上，以及在Eureka服务器上。让我们这么做。
- en: 'Check the console. Let''s try to find a line about `DiscoveryClient`. The `planes` microservice
    is trying to connect to the Eureka server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 检查控制台。让我们尝试找到关于`DiscoveryClient`的一行。`planes`微服务正在尝试连接到Eureka服务器：
- en: '![](img/e16ec109-87eb-440a-9e6d-18831ce17433.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e16ec109-87eb-440a-9e6d-18831ce17433.png)'
- en: There is some important information on the log files here. The first line indicates
    which application is trying to register with the Eureka server. The next four
    lines are about Sleuth. The Sleuth framework is registering the RabbitMQ queues
    and channels.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志文件中这里有一些重要信息。第一行指示哪个应用程序正在尝试注册到Eureka服务器。接下来的四行是关于Sleuth的。Sleuth框架正在注册RabbitMQ队列和通道。
- en: 'We need to find the following line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到以下行：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also, we can check the Eureka server, and we can see the PLANES application
    there, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以检查Eureka服务器，并可以看到那里的PLANES应用程序，如下所示：
- en: '![](img/d99adcbd-ebe3-4e58-a3bb-511982067efb.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d99adcbd-ebe3-4e58-a3bb-511982067efb.png)'
- en: Awesome, our plane microservice is operational.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的飞机微服务已经上线。
- en: We can try our microservices using Postman. This application enables us to call
    our APIs using the intuitive IDE to interact with our microservice. The application
    permits us to group some HTTP calls into collections. The planes collection can
    be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Postman 尝试我们的微服务。这个应用程序使我们能够使用直观的 IDE 调用我们的 API，并与我们的微服务进行交互。该应用程序允许我们将一些
    HTTP 调用分组到集合中。飞机集合可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection)。
- en: We have finished our first microservices. In the next section, we will create
    our `flights` microservice, which will consume the plane's data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的第一个微服务。在下一节中，我们将创建我们的 `flights` 微服务，它将消费飞机的数据。
- en: Flights microservice
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞行微服务
- en: Our plane's microservices are up and running. It will be important for now because
    the flight's microservice needs to get the plane's data to create the flight's
    entities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的飞机微服务已经启动并运行。现在这很重要，因为飞行微服务需要获取飞机的数据来创建飞行实体。
- en: We will introduce the Netflix Ribbon, which will act as a client load balancer for
    our applications, and we will consume the service discovery to look up the service's
    address from the service registry.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍 Netflix Ribbon，它将作为我们的应用程序的客户端负载均衡器，我们将使用服务发现来从服务注册表中查找服务的地址。
- en: Cloning the Flight microservice project
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆飞行微服务项目
- en: We did this task many times in the previous chapter. We can download the project
    source code on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights).
    In the next section, we will dive deep into Ribbon and how it can help us on distributed
    systems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中多次执行了这个任务。我们可以在 GitHub 上下载项目源代码，地址为 [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights)。在下一节中，我们将深入了解
    Ribbon 以及它如何帮助我们解决分布式系统问题。
- en: Netflix Ribbon
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix Ribbon
- en: The Ribbon is an open source project created and maintained by the Netflix company.
    The project is licensed under Apache 2.0 and can be used for commercial purposes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon 是由 Netflix 公司创建和维护的开源项目。该项目采用 Apache 2.0 许可，可用于商业目的。
- en: The Ribbon provides a client-side software load balancing algorithm for the
    **IPC** (**Inter-Process Communication**). The project supports most popular protocols,
    such as TCP, UDP, and HTTP in an asynchronous manner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon 为 **IPC**（**进程间通信**）提供客户端软件负载均衡算法。该项目以异步方式支持大多数流行的协议，如 TCP、UDP 和 HTTP。
- en: There are more interesting features, such as service discovery integration,
    which enables integration in dynamic and elastic environments such as the cloud.
    For this purpose, we will look at our Eureka server. Both projects are maintained
    by the Netflix team. It fits well for our use case.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多有趣的功能，例如服务发现集成，这使得在动态和弹性的环境中（如云）进行集成成为可能。为此，我们将查看我们的 Eureka 服务器。这两个项目都由
    Netflix 团队维护。它非常适合我们的用例。
- en: Another interesting feature is fault tolerance. The Ribbon client can find the
    live servers on the configured list and send the request. Also, the down servers
    will not receive any request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能是容错性。Ribbon 客户端可以在配置的列表中找到活动服务器并发送请求。此外，下线服务器将不会收到任何请求。
- en: 'The following diagram explains how the Ribbon works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图解说明了 Ribbon 的工作原理：
- en: '![](img/820f3ed5-dfd1-4004-b1be-db2802b3ad48.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/820f3ed5-dfd1-4004-b1be-db2802b3ad48.png)'
- en: As we can see, the **Ribbon Client** can communicate with Eureka and then redirect
    the request for the desired microservice. In our case, the `flights` microservice
    will use the Ribbon client and get the service registry from Eureka and redirect
    the call to a live `planes` microservice instance. It sounds like an amazing solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**Ribbon 客户端**可以与 Eureka 通信，然后重定向对所需微服务的请求。在我们的案例中，`flights` 微服务将使用 Ribbon
    客户端，从 Eureka 获取服务注册表，并将调用重定向到活动的 `planes` 微服务实例。这听起来像是一个令人惊叹的解决方案。
- en: Understanding the discovery client
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解发现客户端
- en: Now, we will learn about service discovery and how it works in complex and dynamic
    environments. The basic idea of service discovery is to maintain the services
    repository and provide service addresses for the callers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将了解服务发现以及它在复杂和动态环境中的工作方式。服务发现的基本思想是维护服务存储库并为调用者提供服务地址。
- en: 'It requires some complex tasks to achieve this goal. There are two main behaviors
    to understand:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个目标需要一些复杂的工作。有两个主要的行为需要理解：
- en: The first one is the register. As we know, the service discovery needs to store
    the services information, such as the address and name, and then during the service
    bootstrap, it needs to send the information to the service registry.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是要注册。正如我们所知，服务发现需要存储服务信息，例如地址和名称，然后在服务引导期间，它需要将信息发送到服务注册表。
- en: In the the second operation, the service discovery clients need to query the
    service registry, asking for the desired service name, for instance. Then the
    service registry will send the service information to the client.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个操作中，服务发现客户端需要查询服务注册表，请求所需的服务名称，例如。然后服务注册表将向客户端发送服务信息。
- en: 'Now we understand the basics, as illustrated in the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，如下面的图所示：
- en: '![](img/d4083209-d7bd-4c6b-b3cd-40d9a729d7e6.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4083209-d7bd-4c6b-b3cd-40d9a729d7e6.png)'
- en: 'As you can see in the preceding diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示：
- en: The first part is the service registration.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一部分是服务注册。
- en: At the second stage, the service client will get the service address from the
    Eureka server.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段，服务客户端将从Eureka服务器获取服务地址。
- en: Then the client can call based on the service information.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，客户端可以根据服务信息进行调用。
- en: Let's do it in the code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中实现它。
- en: Service discovery and load balancing in practice
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际中的服务发现和负载均衡
- en: Now we will write some code to interact with our service discovery and load
    balance infrastructure. Now we know how it works, it will help us to understand
    the source code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一些代码来与我们的服务发现和负载均衡基础设施进行交互。现在我们知道了它是如何工作的，这将帮助我们理解源代码。
- en: 'We will create a `DiscoveryService` class which will discover the addresses
    from a requested service name. The class code should be like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`DiscoveryService`类，该类将根据请求的服务名称发现地址。类代码应该如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see, we inject two objects: the `LoadBalanceClient`, which acts as
    a client load balancer, that is, Netflix Ribbon; and the `DiscoveryClient`, which
    will find the instance from a requested service.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们注入了两个对象：`LoadBalanceClient`，它充当客户端负载均衡器，即Netflix Ribbon；以及`DiscoveryClient`，它将找到请求的服务实例。
- en: We use the lambda `Flux.defer()` to organize the flow, and then we will look
    up the service instances from Eureka server. We use `this.dClient.getInstances(service)`
    for that. It will return a list of service names after we look up the service
    URI from the load balancing. This will be done using `this.lbClient.choose(service).` Then
    we will return the `Flux` of service instances addresses.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用lambda `Flux.defer()`来组织流程，然后我们将从Eureka服务器中查找服务实例。我们使用`this.dClient.getInstances(service)`来做这件事。在从负载均衡中查找服务URI之后，它将返回一个服务名称列表。这将是使用`this.lbClient.choose(service).`完成的。然后我们将返回服务实例地址的`Flux`。
- en: 'It is time to see how the client code can use the `DiscoveryService` object.
    The client code can be like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看客户端代码如何使用`DiscoveryService`对象了。客户端代码可能如下所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code can be found in the `PlaneService` class on the project. Remember
    the `serviceAddressFor()` method returns a `Flux` of service addresses. We will
    get the first one, using the `next()` method. Then we are able to transform the
    service address to a valid address to reach the plane microservice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在项目的`PlaneService`类中找到。记住`serviceAddressFor()`方法返回一个服务地址的`Flux`。我们将使用`next()`方法获取第一个，然后我们能够将服务地址转换为一个有效的地址，以到达飞机微服务。
- en: 'Now, we will test the service connections. We need to do the following tasks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试服务连接。我们需要完成以下任务：
- en: Run the Config Server, Eureka, the `planes` microservice, and the `flights` microservice
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行配置服务器、Eureka、`planes`微服务和`flights`微服务
- en: Create a `plane` entity on the `planes` microservice
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`planes`微服务上创建一个`plane`实体
- en: Create a `flight` entity on the `flights` microservice
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`flights`微服务上创建一个`flight`实体
- en: 'Check whether all services listed previously are up and running. Then we will
    create a `plane` entity using the following JSON:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 检查之前列出的所有服务是否都在运行。然后我们将使用以下JSON创建一个`plane`实体：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to call the `planes` microservice in `http://localhost:50001/planes`
    using the HTTP `POST` method. We can find the request to create planes in the `Planes
    Collection` on Postman. When we have called the create plane API, we will get
    a new plane ID. It can be found in the HTTP response headers, as shown in the
    following image, on Postman:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用 HTTP `POST` 方法在 `http://localhost:50001/planes` 上调用 `planes` 微服务。我们可以在
    Postman 的 `Planes Collection` 中找到创建飞机的请求。当我们调用创建飞机 API 时，我们将获得一个新的飞机 ID。它可以在 HTTP
    响应头中找到，如下面的图片所示，在 Postman 中：
- en: Postman is a tool that helps developers to test APIs. Postman provides a friendly
    **GUI** ( **Graphic User Interface** ) to make requests. Also, the tool supports
    environments and it can be helpful to test different environments, such as development,
    test, and production.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是一个帮助开发者测试 API 的工具。Postman 提供了一个友好的 **GUI**（**图形用户界面**）来发送请求。此外，该工具支持环境，并且可以帮助测试不同的环境，如开发、测试和生产。
- en: '![](img/7b53de5d-bfbf-47e9-b94f-0b4546b704a9.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b53de5d-bfbf-47e9-b94f-0b4546b704a9.png)'
- en: Take a look at the `location` HTTP response header. The HTTP status code is
    important as well. We will use the plane ID `5a6a6c636798a63817bed8b4`, created
    just now, to create a new flight.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下 `location` HTTP 响应头。HTTP 状态码同样重要。我们将使用刚刚创建的飞机 ID `5a6a6c636798a63817bed8b4`
    来创建一个新的航班。
- en: We can find the list of HTTP status code at *W3 Org* ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)). Keep
    this in mind, as it is very important to follow the correct status code. It is
    considered a best practice when we are creating REST APIs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *W3 Org*（[https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)）找到
    HTTP 状态码列表。请记住这一点，因为它非常重要，遵循正确的状态码。当我们创建 REST API 时，这被认为是一种最佳实践。
- en: 'The Flight Collection can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection.](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection) There
    is a Create Flight request we want to execute, but before that, we need to change
    our plane ID created previously. Take a look at the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Flight Collection 可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection)。我们想要执行一个创建航班的请求，但在那之前，我们需要更改之前创建的飞机
    ID。查看以下截图：
- en: '![](img/7cb4f809-352a-4159-87a4-3c27279de042.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cb4f809-352a-4159-87a4-3c27279de042.png)'
- en: 'The plane ID has changed to that of our plane previously created. Now we can
    execute the request. The `flights` microservices has the same behavior as a `planes`
    microservice. It will return the location response with the new flight ID. In
    my case, the new ID generated is like the following image:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 飞机 ID 已经变更为之前创建的飞机 ID。现在我们可以执行请求。`flights` 微服务与 `planes` 微服务具有相同的行为。它将返回带有新航班
    ID 的位置响应。在我的情况下，生成的新 ID 如下所示：
- en: '![](img/4364b1a9-f2a6-4c11-b823-1804bb6ce2a7.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4364b1a9-f2a6-4c11-b823-1804bb6ce2a7.png)'
- en: 'Now, we can find the flight by ID. The request can be found at Flight Collection*;* the
    name is Flight by Id. We can execute this request, and the result should be like
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过 ID 查找航班。请求可以在 Flight Collection 中找到；名称为 Flight by Id。我们可以执行这个请求，结果应该如下所示：
- en: '![](img/e8f8a66f-921b-49d8-9377-262e0007328f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8f8a66f-921b-49d8-9377-262e0007328f.png)'
- en: Take a look at the `plane` JSON node. We don't have any data about a plane in
    the `flight` microservice. This information came in from the `planes` microservice.
    We have used service discovery and client load balancing. Well done!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下 `plane` JSON 节点。我们在 `flight` 微服务中没有关于飞机的数据。这些信息来自 `planes` 微服务。我们已经使用了服务发现和客户端负载均衡。做得好！
- en: 'Let''s take a look at the debug provided by the IDE. We want to see the plane
    service address:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 IDE 提供的调试信息。我们想要查看飞机服务地址：
- en: '![](img/bf33f5c5-78ea-4539-896a-37e3236509b2.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf33f5c5-78ea-4539-896a-37e3236509b2.png)'
- en: On the Variables panel, we can see the address variable. The value came in from
    service discovery and client load balancing. It is the **Service IP** or **Domain**
    **Name**. Now we are able to call the requested service transforming the URL.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量面板上，我们可以看到地址变量。其值来自服务发现和客户端负载均衡。它是 **服务 IP** 或 **域名**。现在我们能够通过转换 URL 来调用所需的服务。
- en: Awesome, our infrastructure works very well, now we are able to find services
    using the infrastructure, but there is something important to pay attention to.
    We will discover it in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的基础设施工作得非常好，现在我们能够使用基础设施查找服务，但有一些重要的事情需要注意。我们将在下一节中找到它。
- en: When the services fail, hello Hystrix
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当服务失败时，hello Hystrix
- en: Sometimes the infrastructure can fail, especially the network. It can cause
    some problems in microservices architecture because in general there are many
    connections between services. It means at runtime that the microservices depend
    on other microservices. Normally these connections are done using the REST APIs
    through the HTTP protocol.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时基础设施可能会失败，尤其是网络。它可能会在微服务架构中引起一些问题，因为通常服务之间存在许多连接。这意味着在运行时，微服务依赖于其他微服务。通常这些连接是通过
    HTTP 协议通过 REST API 完成的。
- en: 'It can cause a behavior called **cascade failure**; that is, when one part
    of the microservices system fails, it can trigger the other microservices failure,
    because of the dependencies. Let''s illustrate this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能导致一种称为 **级联失败** 的行为；也就是说，当微服务系统的一部分失败时，它可能会触发其他微服务的失败，因为存在依赖关系。让我们举例说明：
- en: '![](img/f1e43b89-aee2-4e59-9731-eb74a060b52b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1e43b89-aee2-4e59-9731-eb74a060b52b.png)'
- en: If **Service Y** fails, **Service A** and **Service M** potentially can fail
    as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **服务 Y** 失败，**服务 A** 和 **服务 M** 可能也会失败。
- en: 'We have a pattern to help us when this happens: the Circuit Breaker.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个模式可以帮助我们处理这种情况：电路断路器。
- en: Hystrix in a nutshell
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hystrix 简述
- en: '`Hystrix` is a library that helps developers to manage interactions between
    services. The project is open source, maintained by the community, and is under
    the Netflix GitHub.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hystrix` 是一个帮助开发者管理服务之间交互的库。该项目是开源的，由社区维护，并位于 Netflix GitHub 上。'
- en: 'The Circuit Breaker pattern is a pattern that helps to control the system integrations.
    The idea is quite simple: we will wrap the remote call in a function or object,
    and we will monitor these calls to keep track of the failures. If the calls reach
    the limit, the circuit will open. The behavior is like that of an electrical circuit
    breaker, and the idea is the same—protect something to avoid breaking the electrical
    system:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器模式是一种帮助控制系统集成模式的模式。这个想法相当简单：我们将远程调用封装在函数或对象中，并将监控这些调用以跟踪失败。如果调用达到限制，电路将打开。其行为类似于电路断路器，其想法相同——保护某物以避免破坏电气系统：
- en: '![](img/26cfb6de-0d7d-4a13-8611-f9b5a2c373c5.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26cfb6de-0d7d-4a13-8611-f9b5a2c373c5.png)'
- en: '`Hystrix` implements the Circuit Breaker pattern and has some interesting behaviors,
    such as fallback options. `Hystrix` provides resilience for our applications.
    We are able to provide a fallback, stop cascading failures, and give the operational
    control.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hystrix` 实现了电路断路器模式，并有一些有趣的行为，例如回退选项。`Hystrix` 为我们的应用程序提供弹性。我们能够提供回退，停止级联失败，并给出操作控制。'
- en: The library provides high-level configurations and it can be configured through
    an annotation if we are using `Spring Cloud Hystrix`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供高级配置，如果我们使用 `Spring Cloud Hystrix`，则可以通过注解进行配置。
- en: The Circuit Breaker pattern was described by Martin Fowler. You can find more
    information about it on Martin Fowler's Page at [https://martinfowler.com/bliki/CircuitBreaker.html](https://martinfowler.com/bliki/CircuitBreaker.html)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器模式由 Martin Fowler 描述。您可以在 Martin Fowler 的页面 [https://martinfowler.com/bliki/CircuitBreaker.html](https://martinfowler.com/bliki/CircuitBreaker.html)
    上找到更多关于它的信息。
- en: Spring Cloud Hystrix
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Hystrix
- en: As we expected, Spring Boot integrates with `Netflix Hystrix.` The integration
    can be done using a couple of annotations and by configuring the annotations with
    Hystrix properties. We will protect the `planes` microservice interactions we
    are coding in the `flight` service. We now have a method that tries to get the
    plane's data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，Spring Boot 与 `Netflix Hystrix` 集成。集成可以通过几个注解完成，并通过配置注解与 Hystrix 属性进行配置。我们将保护在
    `flight` 服务中编码的 `planes` 微服务交互。我们现在有一个尝试获取飞机数据的函数。
- en: 'Let''s take a look at that method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那个方法：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are some configurations for this command. The first configuration is `commandKey.` The
    basic idea here is to create a name for the command. It will be useful for panel
    control. The second one, `groupKey`, is the command used to group the commands.
    It also helps in grouping commands data together on dashboards. There is the concept
    of a rolling window. The idea is to group the request in a gap of time; it is
    used to enable metrics and statistics.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个命令有一些配置。第一个配置是`commandKey.`这里的想法是为命令创建一个名称。这对于面板控制将很有用。第二个是`groupKey`，这是用于分组命令的命令。它也有助于在仪表板上将命令数据分组在一起。有一个滚动窗口的概念。其想法是在时间间隔内分组请求；它用于启用指标和统计。
- en: '`circuitBreaker.requestVolumeThreshold` configures the number of requests in
    a rolling window that will trip at the circuit. For example, if we have a rolling
    window configured to be open for 10 seconds, if we have nine requests in a gap
    of 10 seconds, the circuit will not open because we have configured it to 10 in
    our command. Another configuration is `circuitBreaker.sleepWindowInMilliseconds`,
    where the basic idea is to give an amount of time, after tripping the circuit,
    to reject requests before trying again to allow attempts.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`circuitBreaker.requestVolumeThreshold`配置了在滚动窗口中触发的请求数量。例如，如果我们配置的滚动窗口为10秒开放，如果在10秒的间隔内有九个请求，则电路不会打开，因为我们已经在我们的命令中将其配置为10。另一个配置是`circuitBreaker.sleepWindowInMilliseconds`，其基本思想是在触发电路后给予一定的时间，在此期间拒绝请求，然后再尝试允许尝试。'
- en: The last one is `execution.isolation.thread.timeoutInMilliseconds.` This property
    configures the timeout for the command. It means that if the time configured is
    reached, the circuit breaker system will perform a fallback logic and mark the
    command as a timeout.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是`execution.isolation.thread.timeoutInMilliseconds.`这个属性配置了命令的超时时间。这意味着如果达到配置的时间，断路器系统将执行回退逻辑，并将命令标记为超时。
- en: The `Hystrix` library is highly customizable, and there are a lot of properties
    to use. The full documentation can be found at [https://github.com/Netflix/Hystrix/wiki/configuration.](https://github.com/Netflix/Hystrix/wiki/configuration) We
    can use these properties for different use cases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hystrix`库高度可定制，有很多属性可以使用。完整的文档可以在[https://github.com/Netflix/Hystrix/wiki/configuration.](https://github.com/Netflix/Hystrix/wiki/configuration)找到。我们可以根据不同的用例使用这些属性。'
- en: Spring Boot Admin
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot Admin
- en: The Spring Boot Admin project is a tool that helps developers in production
    environments. The tool shows Spring Boot application metrics in an organized dashboard,
    and it makes it extremely easy to see application metrics and much more information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Admin项目是一个帮助生产环境中开发者的工具。该工具以有组织的仪表板显示Spring Boot应用程序指标，并且使查看应用程序指标和更多信息变得极其容易。
- en: The tool uses the data from the Spring Boot Actuator as an information source.
    The project is open source and has a lot of contributors and is an active project
    in the community as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 工具使用Spring Boot Actuator的数据作为信息源。该项目是开源的，有很多贡献者，并且在社区中也是一个活跃的项目。
- en: Running Spring Boot Admin
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Spring Boot Admin
- en: It is a piece of cake to set up the application. We will need a new Spring Boot
    application, and to connect this new application with our service discovery implementation.
    Let's do it right now.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 设置应用程序非常简单。我们需要一个新的Spring Boot应用程序，并将其与我们的服务发现实现连接。让我们现在就做吧。
- en: We can find the code on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin).
    If you want to create a new application, go ahead; the process is similar to what
    we did in the previous chapters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GitHub上找到代码[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin)。如果你想创建一个新的应用程序，请继续；过程与我们在前面的章节中所做的是相似的。
- en: 'The project is a Spring Boot regular application, with two new dependencies:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是一个Spring Boot常规应用，包含两个新的依赖项：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These dependencies are about `admin-server` and `admin-server-ui`. The project
    does not support Spring Boot 2 yet, but this is not a problem as we do not need
    reactive stuff for this; it is a monitoring tool.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项是关于`admin-server`和`admin-server-ui`的。该项目目前不支持Spring Boot 2，但这不是问题，因为我们不需要对此使用响应式功能；它是一个监控工具。
- en: 'We have configured our mandatory dependencies. We will need a service discovery
    because we have one in our infrastructure. We need it to provide the service discovery
    feature, and minimize the configurations for our Spring Boot Admin application.
    Let''s add the Eureka client dependency:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了我们的必需依赖项。由于我们在基础设施中有一个服务发现，我们需要它来提供服务发现功能，并最小化我们对Spring Boot Admin应用程序的配置。让我们添加Eureka客户端依赖项：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Awesome, our dependencies are configured properly. Then we can create our main
    class. The main class should be like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的依赖项配置正确。然后我们可以创建我们的主类。主类应该是这样的：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The main difference here is that `@EnableAdminServer` will configure the Spring
    Boot Admin application and set up the server for us. As we expected, we will use
    the Config Server application to store our `application.yaml`. In order to achieve
    this, we need to create our `bootstrap.yaml`, which should be like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于`@EnableAdminServer`将配置Spring Boot Admin应用程序并为我们设置服务器。正如我们所预期的那样，我们将使用配置服务器应用程序来存储我们的`application.yaml`。为了实现这一点，我们需要创建我们的`bootstrap.yaml`，它应该是这样的：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: No difference at all,  `bootstrap.yaml` is configured to look up the configuration
    file from the Config Server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何区别，`bootstrap.yaml`被配置为从配置服务器查找配置文件。
- en: Time to create our `application.yaml` file, to which we need to add some configuration
    to set the new health check URL, since the actuator on Spring Boot 2 was moved,
    prefixed by *actuator*. Our new health check URL should be `/actuator/health`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的`application.yaml`文件了，我们需要添加一些配置来设置新的健康检查URL，因为Spring Boot 2中的actuator被移动，并以前缀*actuator*开头。我们新的健康检查URL应该是`/actuator/health`。
- en: 'Our configuration file should be like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置文件应该是这样的：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have configured the Eureka server address and set the health check URL.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了Eureka服务器地址并设置了健康检查URL。
- en: Now we can run our main class called `AdminApplication.` We can use the Java
    command line or IDE; there is no difference at all.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们称为`AdminApplication`的主类。我们可以使用Java命令行或IDE；两者之间没有任何区别。
- en: Run it!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它！
- en: 'We should see the following line at the log file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在日志文件中看到以下行：
- en: '![](img/1c8e76dd-dd5c-41f4-8180-52587573730b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c8e76dd-dd5c-41f4-8180-52587573730b.png)'
- en: 'Awesome, our application is ready to use. Now we can go to the main page. Go
    to `http://localhost:50015/#/` (main page), then we can see the following page:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的应用程序已经准备好使用。现在我们可以进入主页。访问`http://localhost:50015/#/`（主页），然后我们可以看到以下页面：
- en: '![](img/fe35b8f6-a74e-48e6-9d9c-389c824e2d8b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe35b8f6-a74e-48e6-9d9c-389c824e2d8b.png)'
- en: Look how it is easier to see any outage or strange behaviors in our microservices.
    Remember the key point in microservices architecture is monitoring. It is really
    necessary in order to have a good environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这如何更容易地看到我们的微服务中的任何故障或异常行为。记住，微服务架构中的关键点是监控。为了有一个良好的环境，这真的是必要的。
- en: Spring Cloud Zuul
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Zuul
- en: The Spring Cloud Gateway is the natural choice when we adopt the microservices
    architecture, but nowadays the Spring Cloud Gateway does not have support enabled
    for service discovery features, such as the Eureka server. It means we will have
    to configure it route by route. This does not sound good.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们采用微服务架构时，Spring Cloud Gateway是自然的选择，但如今Spring Cloud Gateway并没有启用对服务发现功能的支持，例如Eureka服务器。这意味着我们不得不逐个配置路由。这听起来并不好。
- en: We have the Zuul proxy as a gateway for our microservices environment, but keep
    in mind the Spring Cloud Gateway is the best choice when the project has support
    for service discovery.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有Zuul代理作为我们的微服务环境的网关，但请记住，当项目支持服务发现时，Spring Cloud Gateway是最好的选择。
- en: Let's create the Zuul proxy project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建Zuul代理项目。
- en: Understanding the EDGE service project
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解EDGE服务项目
- en: The EDGE service is a service that provides dynamic routing, monitoring, resiliency,
    and security. The basic idea here is to create a reverse proxy for our microservices.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: EDGE服务是一个提供动态路由、监控、弹性和安全性的服务。基本思想是为我们的微服务创建一个反向代理。
- en: This service will act as a proxy for our microservices and will be exposed as
    a central access point. The Spring Cloud Zuul integrates with the Eureka server.
    It will increase our resiliency because we will use the service discovery feature
    provided by the Eureka server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务将作为我们的微服务的代理，并作为中央访问点公开。Spring Cloud Zuul与Eureka服务器集成。它将提高我们的弹性，因为我们将使用Eureka服务器提供的服务发现功能。
- en: 'The following image demonstrates how we will use the **Edge Service** in our
    architecture:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了我们如何在我们的架构中使用**Edge服务**：
- en: '![](img/c3e92e86-ea33-4eaa-8516-b7c2bafbbd53.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3e92e86-ea33-4eaa-8516-b7c2bafbbd53.png)'
- en: As we can see, the **Zuul Server** will connect to the service discovery server,
    to get the list of available services. After that the Zuul service will redirect
    to the requested service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**Zuul 服务器**将连接到服务发现服务器，以获取可用服务的列表。之后，Zuul 服务将重定向到请求的服务。
- en: Look at the diagram. There is no interaction with the clients, that is, **Mobile**
    and **Browser**, and our microservices.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个图。它与客户端没有交互，也就是说，**移动**和**浏览器**以及我们的微服务。
- en: 'Spring Cloud Zuul also supports interesting features, such as:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Zuul 还支持一些有趣的功能，例如：
- en: '**pre**: This can be used to set some data in`RequestContext`; it is executed
    before the request is routed'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pre**：这可以用来在 `RequestContext` 中设置一些数据；它在请求被路由之前执行'
- en: '**route**: This handles the request routing'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**route**：这个处理请求路由'
- en: '**post**: This filters which one acts after the request is routed'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**post**：这个过滤器在请求被路由后执行'
- en: '**error**: When some errors happen, we can use the error feature to handle
    the request'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error**：当发生某些错误时，我们可以使用错误功能来处理请求'
- en: We will not use these features, but keep in mind that they can be very useful.
    Remember, our Zuul server is our gateway to the internet.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会使用这些功能，但请记住，它们可能非常有用。记住，我们的 Zuul 服务器是通向互联网的网关。
- en: Creating the EDGE server
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 EDGE 服务器
- en: We will use the Zuul server to act as an API gateway for our applications. Now
    it's time to create our project. As there is no relevant difference involved in
    creating this project, we will take a look at specific Zuul parts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Zuul 服务器作为我们应用程序的 API 网关。现在是我们创建项目的时候了。由于创建此项目没有涉及任何相关的差异，我们将查看特定的 Zuul
    部分。
- en: 'The dependency required is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的依赖项是：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It will configure for us the Zuul server dependencies.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它将为我们配置 Zuul 服务器依赖项。
- en: 'Now we can add the project''s main class. The class should be like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加项目的主类。这个类应该是这样的：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The new thing here is `@EnableZuulProxy`. It will set up a Zuul server endpoint
    and configure reverse proxy filters. Then we will be able to forward a request
    to microservices applications. Zuul integrates with the Eureka server, so we do
    not need to configure it manually. The auto-configuration will find the services
    at the time of the discovery client implementation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新功能是 `@EnableZuulProxy`。它将设置 Zuul 服务器端点并配置反向代理过滤器。然后，我们将能够将请求转发到微服务应用程序。Zuul
    与 Eureka 服务器集成，因此我们不需要手动配置它。自动配置将在发现客户端实现时找到服务。
- en: We can run the application via the command line or IDE, it is up to you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过命令行或 IDE 运行应用程序，这取决于你。
- en: 'Then we can see the routes configured. Go to `http://localhost:8888/routes`
    and we will able to see the routes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到配置的路由。转到 `http://localhost:8888/routes`，我们将能够看到路由：
- en: '![](img/7d7729e9-8590-4edd-bb95-c73b78c437d7.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d7729e9-8590-4edd-bb95-c73b78c437d7.png)'
- en: 'We have some routes configured. We did this using the `application.yaml` file.
    The file should be like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了一些路由。我们使用 `application.yaml` 文件来完成这项工作。文件应该是这样的：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's understand this configuration. We have created a node called `planes`.
    This node configures a `path` (that is the URI) and configures the service name,
    by `serviceId`, registered in the Eureka server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个配置。我们创建了一个名为 `planes` 的节点。这个节点配置了一个 `path`（即 URI）并配置了通过 `serviceId` 在
    Eureka 服务器上注册的服务名称。
- en: 'Let''s do a simple test. We will:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个简单的测试。我们将：
- en: Configure the new URL path for the planes service
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为飞机服务配置新的 URL 路径
- en: Test the request using the Zuul server
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Zuul 服务器测试请求
- en: Open the `PlaneResource` class located in the `planes` microservice project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `planes` 微服务项目中的 `PlaneResource` 类。
- en: 'The `RequestMapping` is configured like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestMapping` 的配置如下：'
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change it to something like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember we can use the Zuul server as a router, so we do not need this information
    anymore. With the URI path on the source code, we are able to use the configuration
    file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们可以使用 Zuul 服务器作为路由器，因此我们不再需要这些信息了。在源代码的 URI 路径上，我们能够使用配置文件。
- en: 'Run the `planes` microservice again. The following services need to be running:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `planes` 微服务。以下服务需要运行：
- en: Config Server
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器
- en: Eureka server
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka 服务器
- en: Planes microservice
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞机微服务
- en: API Edge
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API Edge
- en: 'Then we can call the `planes` microservices using the Zuul proxy. Let''s do
    it using cURL:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 Zuul 代理调用 `planes` 微服务。让我们使用 cURL 来做这件事：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s understand this a little bit. The port `8888` points to the **Zuul Server**,
    and we have configured it in `application.yaml`. When the path is `/api/v1/planes/**`,
    the **Zuul Server** will redirect to the `planes` microservices. The basic flow
    is:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微了解一下。端口 `8888` 指向 **Zuul 服务器**，我们在 `application.yaml` 中进行了配置。当路径是 `'/api/v1/planes/**'`
    时，**Zuul 服务器** 将重定向到 `planes` 微服务。基本流程是：
- en: '![](img/39a82733-8ff4-48c2-8304-5a6551a105f9.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39a82733-8ff4-48c2-8304-5a6551a105f9.png)'
- en: 'The request is coming to the **Zuul Server**, and then the **Zuul Server**
    will redirect it to the requested microservice. The result should be like this;
    in my case, I have some planes in the database:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将到达 **Zuul 服务器**，然后 **Zuul 服务器** 将将其重定向到请求的微服务。结果应该像这样；在我的情况下，数据库中有些飞机：
- en: '![](img/32018be4-666f-4285-afd8-a67409a980b1.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32018be4-666f-4285-afd8-a67409a980b1.png)'
- en: Awesome, our API Gateway is fully operational. We will use it for all services
    in the same port, and only the URI will be changed to point to the desired `serviceId`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的 API 网关完全运行正常。我们将使用它来处理同一端口的全部服务，只需更改 URI 以指向所需的 `serviceId`。
- en: We can configure the port like in other Spring Boot applications. We chose the
    `8888` port in this case.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在其他 Spring Boot 应用程序中一样配置端口。在这种情况下，我们选择了 `8888` 端口。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about some important microservice patterns
    and how they can help us to deliver a fault-tolerant, resilient, and error-prone
    application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一些重要的微服务模式和它们如何帮助我们交付具有容错性、弹性和易于出错的程序。
- en: We have practiced how to use the service discovery feature provided by the Spring
    Framework and how it works at the application runtime, and we made some debug
    tasks to help us to understand how it works under the hood.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们练习了如何使用 Spring 框架提供的服务发现功能以及它在应用程序运行时的运作方式，我们还进行了一些调试任务，以帮助我们理解它在底层是如何工作的。
- en: The Hystrix project, hosted by Netflix, can increase our application's resilience
    and fault tolerance. When working with remote calls, in this section, we made
    some Hystrix commands and understood how Hystrix is a useful implementation of
    the Circuit Breaker pattern.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Netflix 托管的 Hystrix 项目可以提高我们应用程序的弹性和容错性。在本节中，当处理远程调用时，我们创建了一些 Hystrix 命令，并了解了
    Hystrix 是断路器模式的有用实现。
- en: At the end of the chapter, we are able to understand the microservices drawbacks
    and how to solve the common problems in a distributed environment.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们能够理解微服务的缺点以及如何在分布式环境中解决常见问题。
- en: Now we know how to solve the common problems of microservices architectural
    style using the Spring Framework.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 Spring 框架解决微服务架构风格中的常见问题。
- en: In the next chapter, we will finish our *Airline Ticket System*, using the configured
    tools to monitoring the microservices' health and look at how it helps developers
    during the operation time when the microservices are running in the production
    stage.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完成我们的 *航空票务系统*，使用配置的工具监控微服务的健康状态，并查看它在微服务在生产阶段运行时的操作时间如何帮助开发者。
- en: See you there.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 那里见。
