- en: Circuit Breakers and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器和安全
- en: In the previous chapter, we configured the microservices that will act in our
    infrastructure, and we created a Eureka server to work as a service discovery
    for our solution. Also, we have created a Config Server application that will
    serve as the configurations for our microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们配置了将在我们的基础设施中运行的微服务，并创建了一个 Eureka 服务器作为我们解决方案的服务发现。此外，我们还创建了一个 Config
    Server 应用程序，它将为我们的微服务提供服务配置。
- en: In this chapter, we will create microservices to interact with our previous
    infrastructure. We will discover how to apply service discovery features for our
    business microservices and understand how the Circuit Breaker pattern can help
    us to bring resilience to our applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建微服务来与我们的先前基础设施交互。我们将发现如何为我们的业务微服务应用服务发现功能，并了解断路器模式如何帮助我们为应用程序带来弹性。
- en: During the chapter, we will understand how the microservices can communicate
    with other services through the HTTP asynchronous call powered by the Spring WebFlux
    client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解微服务如何通过由 Spring WebFlux 客户端提供的 HTTP 异步调用来与其他服务进行通信。
- en: 'By the end of this chapter, we will have learned how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学会如何：
- en: Connect microservices with service discovery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务发现连接微服务
- en: Pull the configuration from the configuration server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置服务器拉取配置
- en: Understand how `Hystrix` brings resilience to microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `Hystrix` 如何为微服务带来弹性
- en: Show the Edge API strategy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示边缘 API 策略
- en: Present the Spring Boot Admin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示 Spring Boot Admin
- en: Understanding the service discovery power
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务发现的力量
- en: We will create our first microservice with business requirements. We will create
    a `planes` microservice, which will maintain data about company planes, such as
    characteristics, model, and some other attributes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据业务需求创建我们的第一个微服务。我们将创建一个 `planes` 微服务，该微服务将维护有关公司飞机的数据，例如特性、型号和其他属性。
- en: The `planes` microservice will be used to serve plane characteristics for our
    second microservice, the `flights` microservice. It needs to get some plane information
    to be able to create a flight, such as the number of seats.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`planes` 微服务将被用来为我们第二个微服务，即 `flights` 微服务，提供飞机特性。它需要获取一些飞机信息以便能够创建航班，例如座位数。'
- en: The `planes` microservice is an excellent candidate to start with because there
    is no business-related dependency to be created.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`planes` 微服务是一个很好的起点，因为没有需要创建与业务相关的依赖项。'
- en: Our `planes` microservice will be useful soon. Time to create it. Let's go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `planes` 微服务很快就会变得有用。是时候创建它了。让我们开始吧。
- en: Creating the planes microservice
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `planes` 微服务
- en: 'As we have been doing in the previous chapters, we will use the Spring Initializr
    for that purpose. The following dependencies should be selected, as shown in the
    following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中所做的那样，我们将使用 Spring Initializr 来实现这个目的。以下是一些应该选择的依赖项，如以下截图所示：
- en: '![](img/f843a799-fdab-4014-bfe5-b58fb1578a55.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f843a799-fdab-4014-bfe5-b58fb1578a55.png)'
- en: There are some necessary dependencies. The Stream Binder Rabbit and Sleuth Stream
    dependencies are necessary to enable us to the send data spans, and to enable
    application trace, across to the RabbitMQ message broker. We will use MongoDB
    to act as a database for this specific application, so we need Reactive MongoDB
    for that. Config Client is mandatory for all microservices present in the solution.
    We will not have any application configuration on the classpath. The Actuator
    provides production-ready metrics and information about the running application;
    it's an essential characteristic of the microservice's architectural style. Moreover, Zuul
    will be essential to enable us to connect the application with our Edge API. We
    will learn more about it during the course of the chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些必要的依赖项。Stream Binder Rabbit 和 Sleuth Stream 依赖项是必要的，使我们能够发送数据跨度，并启用应用程序跟踪，通过
    RabbitMQ 消息代理。我们将使用 MongoDB 作为此特定应用程序的数据库，因此我们需要 Reactive MongoDB。Config Client
    对于解决方案中存在的所有微服务都是强制性的。我们不会在类路径上有任何应用程序配置。Actuator 提供了生产就绪的指标和关于运行应用程序的信息；这是微服务架构风格的一个基本特征。此外，Zuul
    将是连接应用程序与我们的边缘 API 的关键。我们将在本章的学习过程中了解更多关于它的信息。
- en: We can now press the Generate Project button to download the project. Open the
    project on the IDE.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按下“生成项目”按钮来下载项目。在 IDE 中打开项目。
- en: The `planes` microservice will be created using the Spring Boot 2 framework
    because we are interested in implementing the reactive foundation for our plane
    service.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need to include one more dependency, and it can be done using the
    following snippet on our `pom.xml`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `spring-cloud-starter-netflix-eureka-client` enables the service discovery,
    powered by the Eureka server in our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Coding the planes microservice
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add some features on the application. For this specific application,
    we will create CRUD functionalities with Spring Reactive WebFlux.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Plane` class represents the plane model in our microservices and the class
    should be like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interesting point is the `@Document` annotation. It enables us to configure
    the name of  the MongoDB collection for our domain. The `@Builder` annotation
    creates an implementation of the Builder pattern using the annotated method. The `Project Lombok` library
    provides this feature ([https://projectlombok.org](https://projectlombok.org)).
    Also, the project has some exciting features, such as `@Data`, which creates `getters/setters`,
    `equals`, and `hashCode` implementation automatically for the annotated class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are some domain models in this class. These models do not
    need explanation here, and the full source code can be found in the GitHub project
    at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-planes).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The reactive repository
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Plane` class needs a repository to persist the data to a database. We
    will use a reactive repository for MongoDB provided by the Spring Reactive MongoDB
    implementation. We will use the `ReactiveCrudRepository` as it makes our repositories
    reactive. Our repository should be like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The implementation is the same as it was in the previous Spring Data versions,
    except for the new reactive interface. Now, we can create our service layer in
    the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Plane service
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `PlaneService` will be responsible for creating a kind of glue between
    the `PlaneRepository` and `PlaneResource`; the latter one we will create in the
    next section. The implementation should be like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is nothing special in this class, and the `PlaneService` will invoke the
    `PlaneRepository` to persist the `Plane` in a database. As we can see, we have
    used lambdas extensively. Java 8 is a requirement to run Spring Boot 2 applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at how the Builder pattern enables us to write clean code. It is
    much easier to read this code; we did it using the `chaining` method provided
    by Lombok.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The REST layer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Spring WebFlux to expose our REST endpoints, and then we need to
    return `Mono` or `Flux` in our methods. The REST implementation should be like
    this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Take a look at the `plane` method. When `planeService.plane(id)` returns the
    empty Mono, the REST endpoint will return `notFound` like this implementation: `ResponseEntity.notFound().build()`.
    It makes the code extremely easy to understand.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: On the `newPlane` method, we will return the `location` HTTP header with the
    new entity ID recently created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Running the plane microservice
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we run the plane microservice, we will create the `plane` microservice''s `main`
    class. It will be responsible for starting the application. To do that, we need
    to include a couple of Spring Annotations. The class implementation can be like
    this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Spring Annotations will be connected with the Zuul proxy. Also, we need
    to connect the application with the Eureka server and configure the application
    automatically. These behaviors can be done using `@EnableZuulProxy`, `@EnableEurekaClient`,
    and `@SpringBootApplication`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a `bootstrap.yaml` file to instruct the Spring Framework
    to search the configuration file on the Config Server, created in the previous
    chapter. The file should be like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have configured the Config Server address; it was a piece of cake.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add the `application.yaml` file on the GitHub repository, because
    the Config Server will try to find the file in the repository.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The file can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/flights.yaml).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: We can run the application on the IDE or via the command line; it is up to you.
    Check that the Config Server, Eureka, MongoDB, and RabbitMQ are up and running
    before trying to run it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Docker compose file located on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-infra-full.yaml)). It
    contains RabbitMQ, Config Server, Eureka, MongoDB, MySQL, Redis, and Zipkin containers
    ready to use. If you are using it, run it using the following command: `docker-compose
    -f docker-compose-infra-full.yaml up -d`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the output. We can check it in different ways: on a console, and
    on the Eureka server. Let''s do it.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the console. Let''s try to find a line about `DiscoveryClient`. The `planes` microservice
    is trying to connect to the Eureka server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e16ec109-87eb-440a-9e6d-18831ce17433.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: There is some important information on the log files here. The first line indicates
    which application is trying to register with the Eureka server. The next four
    lines are about Sleuth. The Sleuth framework is registering the RabbitMQ queues
    and channels.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find the following line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also, we can check the Eureka server, and we can see the PLANES application
    there, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d99adcbd-ebe3-4e58-a3bb-511982067efb.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Awesome, our plane microservice is operational.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的飞机微服务已经上线。
- en: We can try our microservices using Postman. This application enables us to call
    our APIs using the intuitive IDE to interact with our microservice. The application
    permits us to group some HTTP calls into collections. The planes collection can
    be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Postman 尝试我们的微服务。这个应用程序使我们能够使用直观的 IDE 调用我们的 API，并与我们的微服务进行交互。该应用程序允许我们将一些
    HTTP 调用分组到集合中。飞机集合可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/planes.postman_collection)。
- en: We have finished our first microservices. In the next section, we will create
    our `flights` microservice, which will consume the plane's data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的第一个微服务。在下一节中，我们将创建我们的 `flights` 微服务，它将消费飞机的数据。
- en: Flights microservice
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞行微服务
- en: Our plane's microservices are up and running. It will be important for now because
    the flight's microservice needs to get the plane's data to create the flight's
    entities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的飞机微服务已经启动并运行。现在这很重要，因为飞行微服务需要获取飞机的数据来创建飞行实体。
- en: We will introduce the Netflix Ribbon, which will act as a client load balancer for
    our applications, and we will consume the service discovery to look up the service's
    address from the service registry.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍 Netflix Ribbon，它将作为我们的应用程序的客户端负载均衡器，我们将使用服务发现来从服务注册表中查找服务的地址。
- en: Cloning the Flight microservice project
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆飞行微服务项目
- en: We did this task many times in the previous chapter. We can download the project
    source code on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights).
    In the next section, we will dive deep into Ribbon and how it can help us on distributed
    systems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中多次执行了这个任务。我们可以在 GitHub 上下载项目源代码，地址为 [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/airline-flights)。在下一节中，我们将深入了解
    Ribbon 以及它如何帮助我们解决分布式系统问题。
- en: Netflix Ribbon
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix Ribbon
- en: The Ribbon is an open source project created and maintained by the Netflix company.
    The project is licensed under Apache 2.0 and can be used for commercial purposes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon 是由 Netflix 公司创建和维护的开源项目。该项目采用 Apache 2.0 许可，可用于商业目的。
- en: The Ribbon provides a client-side software load balancing algorithm for the
    **IPC** (**Inter-Process Communication**). The project supports most popular protocols,
    such as TCP, UDP, and HTTP in an asynchronous manner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon 为 **IPC**（**进程间通信**）提供客户端软件负载均衡算法。该项目以异步方式支持大多数流行的协议，如 TCP、UDP 和 HTTP。
- en: There are more interesting features, such as service discovery integration,
    which enables integration in dynamic and elastic environments such as the cloud.
    For this purpose, we will look at our Eureka server. Both projects are maintained
    by the Netflix team. It fits well for our use case.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多有趣的功能，例如服务发现集成，这使得在动态和弹性的环境中（如云）进行集成成为可能。为此，我们将查看我们的 Eureka 服务器。这两个项目都由
    Netflix 团队维护。它非常适合我们的用例。
- en: Another interesting feature is fault tolerance. The Ribbon client can find the
    live servers on the configured list and send the request. Also, the down servers
    will not receive any request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能是容错性。Ribbon 客户端可以在配置的列表中找到活动服务器并发送请求。此外，下线服务器将不会收到任何请求。
- en: 'The following diagram explains how the Ribbon works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图解说明了 Ribbon 的工作原理：
- en: '![](img/820f3ed5-dfd1-4004-b1be-db2802b3ad48.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/820f3ed5-dfd1-4004-b1be-db2802b3ad48.png)'
- en: As we can see, the **Ribbon Client** can communicate with Eureka and then redirect
    the request for the desired microservice. In our case, the `flights` microservice
    will use the Ribbon client and get the service registry from Eureka and redirect
    the call to a live `planes` microservice instance. It sounds like an amazing solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**Ribbon 客户端**可以与 Eureka 通信，然后重定向对所需微服务的请求。在我们的案例中，`flights` 微服务将使用 Ribbon
    客户端，从 Eureka 获取服务注册表，并将调用重定向到活动的 `planes` 微服务实例。这听起来像是一个令人惊叹的解决方案。
- en: Understanding the discovery client
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解发现客户端
- en: Now, we will learn about service discovery and how it works in complex and dynamic
    environments. The basic idea of service discovery is to maintain the services
    repository and provide service addresses for the callers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将了解服务发现以及它在复杂和动态环境中的工作方式。服务发现的基本思想是维护服务存储库并为调用者提供服务地址。
- en: 'It requires some complex tasks to achieve this goal. There are two main behaviors
    to understand:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个目标需要一些复杂的工作。有两个主要的行为需要理解：
- en: The first one is the register. As we know, the service discovery needs to store
    the services information, such as the address and name, and then during the service
    bootstrap, it needs to send the information to the service registry.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是要注册。正如我们所知，服务发现需要存储服务信息，例如地址和名称，然后在服务引导期间，它需要将信息发送到服务注册表。
- en: In the the second operation, the service discovery clients need to query the
    service registry, asking for the desired service name, for instance. Then the
    service registry will send the service information to the client.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个操作中，服务发现客户端需要查询服务注册表，请求所需的服务名称，例如。然后服务注册表将向客户端发送服务信息。
- en: 'Now we understand the basics, as illustrated in the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，如下面的图所示：
- en: '![](img/d4083209-d7bd-4c6b-b3cd-40d9a729d7e6.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4083209-d7bd-4c6b-b3cd-40d9a729d7e6.png)'
- en: 'As you can see in the preceding diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示：
- en: The first part is the service registration.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一部分是服务注册。
- en: At the second stage, the service client will get the service address from the
    Eureka server.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段，服务客户端将从Eureka服务器获取服务地址。
- en: Then the client can call based on the service information.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，客户端可以根据服务信息进行调用。
- en: Let's do it in the code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中实现它。
- en: Service discovery and load balancing in practice
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际中的服务发现和负载均衡
- en: Now we will write some code to interact with our service discovery and load
    balance infrastructure. Now we know how it works, it will help us to understand
    the source code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一些代码来与我们的服务发现和负载均衡基础设施进行交互。现在我们知道了它是如何工作的，这将帮助我们理解源代码。
- en: 'We will create a `DiscoveryService` class which will discover the addresses
    from a requested service name. The class code should be like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`DiscoveryService`类，该类将根据请求的服务名称发现地址。类代码应该如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see, we inject two objects: the `LoadBalanceClient`, which acts as
    a client load balancer, that is, Netflix Ribbon; and the `DiscoveryClient`, which
    will find the instance from a requested service.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们注入了两个对象：`LoadBalanceClient`，它充当客户端负载均衡器，即Netflix Ribbon；以及`DiscoveryClient`，它将找到请求的服务实例。
- en: We use the lambda `Flux.defer()` to organize the flow, and then we will look
    up the service instances from Eureka server. We use `this.dClient.getInstances(service)`
    for that. It will return a list of service names after we look up the service
    URI from the load balancing. This will be done using `this.lbClient.choose(service).` Then
    we will return the `Flux` of service instances addresses.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用lambda `Flux.defer()`来组织流程，然后我们将从Eureka服务器中查找服务实例。我们使用`this.dClient.getInstances(service)`来做这件事。在从负载均衡中查找服务URI之后，它将返回一个服务名称列表。这将是使用`this.lbClient.choose(service).`完成的。然后我们将返回服务实例地址的`Flux`。
- en: 'It is time to see how the client code can use the `DiscoveryService` object.
    The client code can be like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看客户端代码如何使用`DiscoveryService`对象了。客户端代码可能如下所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code can be found in the `PlaneService` class on the project. Remember
    the `serviceAddressFor()` method returns a `Flux` of service addresses. We will
    get the first one, using the `next()` method. Then we are able to transform the
    service address to a valid address to reach the plane microservice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在项目的`PlaneService`类中找到。记住`serviceAddressFor()`方法返回一个服务地址的`Flux`。我们将使用`next()`方法获取第一个，然后我们能够将服务地址转换为一个有效的地址，以到达飞机微服务。
- en: 'Now, we will test the service connections. We need to do the following tasks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试服务连接。我们需要完成以下任务：
- en: Run the Config Server, Eureka, the `planes` microservice, and the `flights` microservice
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行配置服务器、Eureka、`planes`微服务和`flights`微服务
- en: Create a `plane` entity on the `planes` microservice
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`planes`微服务上创建一个`plane`实体
- en: Create a `flight` entity on the `flights` microservice
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`flights`微服务上创建一个`flight`实体
- en: 'Check whether all services listed previously are up and running. Then we will
    create a `plane` entity using the following JSON:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 检查之前列出的所有服务是否都在运行。然后我们将使用以下JSON创建一个`plane`实体：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to call the `planes` microservice in `http://localhost:50001/planes`
    using the HTTP `POST` method. We can find the request to create planes in the `Planes
    Collection` on Postman. When we have called the create plane API, we will get
    a new plane ID. It can be found in the HTTP response headers, as shown in the
    following image, on Postman:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Postman is a tool that helps developers to test APIs. Postman provides a friendly
    **GUI** ( **Graphic User Interface** ) to make requests. Also, the tool supports
    environments and it can be helpful to test different environments, such as development,
    test, and production.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b53de5d-bfbf-47e9-b94f-0b4546b704a9.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Take a look at the `location` HTTP response header. The HTTP status code is
    important as well. We will use the plane ID `5a6a6c636798a63817bed8b4`, created
    just now, to create a new flight.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: We can find the list of HTTP status code at *W3 Org* ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)). Keep
    this in mind, as it is very important to follow the correct status code. It is
    considered a best practice when we are creating REST APIs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flight Collection can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection.](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection) There
    is a Create Flight request we want to execute, but before that, we need to change
    our plane ID created previously. Take a look at the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb4f809-352a-4159-87a4-3c27279de042.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'The plane ID has changed to that of our plane previously created. Now we can
    execute the request. The `flights` microservices has the same behavior as a `planes`
    microservice. It will return the location response with the new flight ID. In
    my case, the new ID generated is like the following image:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4364b1a9-f2a6-4c11-b823-1804bb6ce2a7.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can find the flight by ID. The request can be found at Flight Collection*;* the
    name is Flight by Id. We can execute this request, and the result should be like
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8f8a66f-921b-49d8-9377-262e0007328f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Take a look at the `plane` JSON node. We don't have any data about a plane in
    the `flight` microservice. This information came in from the `planes` microservice.
    We have used service discovery and client load balancing. Well done!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the debug provided by the IDE. We want to see the plane
    service address:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf33f5c5-78ea-4539-896a-37e3236509b2.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: On the Variables panel, we can see the address variable. The value came in from
    service discovery and client load balancing. It is the **Service IP** or **Domain**
    **Name**. Now we are able to call the requested service transforming the URL.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, our infrastructure works very well, now we are able to find services
    using the infrastructure, but there is something important to pay attention to.
    We will discover it in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的基础设施工作得非常好，现在我们能够使用基础设施查找服务，但有一些重要的事情需要注意。我们将在下一节中找到它。
- en: When the services fail, hello Hystrix
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当服务失败时，hello Hystrix
- en: Sometimes the infrastructure can fail, especially the network. It can cause
    some problems in microservices architecture because in general there are many
    connections between services. It means at runtime that the microservices depend
    on other microservices. Normally these connections are done using the REST APIs
    through the HTTP protocol.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时基础设施可能会失败，尤其是网络。它可能会在微服务架构中引起一些问题，因为通常服务之间存在许多连接。这意味着在运行时，微服务依赖于其他微服务。通常这些连接是通过
    HTTP 协议通过 REST API 完成的。
- en: 'It can cause a behavior called **cascade failure**; that is, when one part
    of the microservices system fails, it can trigger the other microservices failure,
    because of the dependencies. Let''s illustrate this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能导致一种称为 **级联失败** 的行为；也就是说，当微服务系统的一部分失败时，它可能会触发其他微服务的失败，因为存在依赖关系。让我们举例说明：
- en: '![](img/f1e43b89-aee2-4e59-9731-eb74a060b52b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1e43b89-aee2-4e59-9731-eb74a060b52b.png)'
- en: If **Service Y** fails, **Service A** and **Service M** potentially can fail
    as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **服务 Y** 失败，**服务 A** 和 **服务 M** 可能也会失败。
- en: 'We have a pattern to help us when this happens: the Circuit Breaker.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个模式可以帮助我们处理这种情况：电路断路器。
- en: Hystrix in a nutshell
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hystrix 简述
- en: '`Hystrix` is a library that helps developers to manage interactions between
    services. The project is open source, maintained by the community, and is under
    the Netflix GitHub.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hystrix` 是一个帮助开发者管理服务之间交互的库。该项目是开源的，由社区维护，并位于 Netflix GitHub 上。'
- en: 'The Circuit Breaker pattern is a pattern that helps to control the system integrations.
    The idea is quite simple: we will wrap the remote call in a function or object,
    and we will monitor these calls to keep track of the failures. If the calls reach
    the limit, the circuit will open. The behavior is like that of an electrical circuit
    breaker, and the idea is the same—protect something to avoid breaking the electrical
    system:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器模式是一种帮助控制系统集成模式的模式。这个想法相当简单：我们将远程调用封装在函数或对象中，并将监控这些调用以跟踪失败。如果调用达到限制，电路将打开。其行为类似于电路断路器，其想法相同——保护某物以避免破坏电气系统：
- en: '![](img/26cfb6de-0d7d-4a13-8611-f9b5a2c373c5.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26cfb6de-0d7d-4a13-8611-f9b5a2c373c5.png)'
- en: '`Hystrix` implements the Circuit Breaker pattern and has some interesting behaviors,
    such as fallback options. `Hystrix` provides resilience for our applications.
    We are able to provide a fallback, stop cascading failures, and give the operational
    control.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hystrix` 实现了电路断路器模式，并有一些有趣的行为，例如回退选项。`Hystrix` 为我们的应用程序提供弹性。我们能够提供回退，停止级联失败，并给出操作控制。'
- en: The library provides high-level configurations and it can be configured through
    an annotation if we are using `Spring Cloud Hystrix`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供高级配置，如果我们使用 `Spring Cloud Hystrix`，则可以通过注解进行配置。
- en: The Circuit Breaker pattern was described by Martin Fowler. You can find more
    information about it on Martin Fowler's Page at [https://martinfowler.com/bliki/CircuitBreaker.html](https://martinfowler.com/bliki/CircuitBreaker.html)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器模式由 Martin Fowler 描述。您可以在 Martin Fowler 的页面 [https://martinfowler.com/bliki/CircuitBreaker.html](https://martinfowler.com/bliki/CircuitBreaker.html)
    上找到更多关于它的信息。
- en: Spring Cloud Hystrix
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Hystrix
- en: As we expected, Spring Boot integrates with `Netflix Hystrix.` The integration
    can be done using a couple of annotations and by configuring the annotations with
    Hystrix properties. We will protect the `planes` microservice interactions we
    are coding in the `flight` service. We now have a method that tries to get the
    plane's data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，Spring Boot 与 `Netflix Hystrix` 集成。集成可以通过几个注解完成，并通过配置注解与 Hystrix 属性进行配置。我们将保护在
    `flight` 服务中编码的 `planes` 微服务交互。我们现在有一个尝试获取飞机数据的函数。
- en: 'Let''s take a look at that method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那个方法：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are some configurations for this command. The first configuration is `commandKey.` The
    basic idea here is to create a name for the command. It will be useful for panel
    control. The second one, `groupKey`, is the command used to group the commands.
    It also helps in grouping commands data together on dashboards. There is the concept
    of a rolling window. The idea is to group the request in a gap of time; it is
    used to enable metrics and statistics.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个命令有一些配置。第一个配置是`commandKey.`这里的想法是为命令创建一个名称。这对于面板控制将很有用。第二个是`groupKey`，这是用于分组命令的命令。它也有助于在仪表板上将命令数据分组在一起。有一个滚动窗口的概念。其想法是在时间间隔内分组请求；它用于启用指标和统计。
- en: '`circuitBreaker.requestVolumeThreshold` configures the number of requests in
    a rolling window that will trip at the circuit. For example, if we have a rolling
    window configured to be open for 10 seconds, if we have nine requests in a gap
    of 10 seconds, the circuit will not open because we have configured it to 10 in
    our command. Another configuration is `circuitBreaker.sleepWindowInMilliseconds`,
    where the basic idea is to give an amount of time, after tripping the circuit,
    to reject requests before trying again to allow attempts.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`circuitBreaker.requestVolumeThreshold`配置了在滚动窗口中触发的请求数量。例如，如果我们配置的滚动窗口为10秒开放，如果在10秒的间隔内有九个请求，则电路不会打开，因为我们已经在我们的命令中将其配置为10。另一个配置是`circuitBreaker.sleepWindowInMilliseconds`，其基本思想是在触发电路后给予一定的时间，在此期间拒绝请求，然后再尝试允许尝试。'
- en: The last one is `execution.isolation.thread.timeoutInMilliseconds.` This property
    configures the timeout for the command. It means that if the time configured is
    reached, the circuit breaker system will perform a fallback logic and mark the
    command as a timeout.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是`execution.isolation.thread.timeoutInMilliseconds.`这个属性配置了命令的超时时间。这意味着如果达到配置的时间，断路器系统将执行回退逻辑，并将命令标记为超时。
- en: The `Hystrix` library is highly customizable, and there are a lot of properties
    to use. The full documentation can be found at [https://github.com/Netflix/Hystrix/wiki/configuration.](https://github.com/Netflix/Hystrix/wiki/configuration) We
    can use these properties for different use cases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hystrix`库高度可定制，有很多属性可以使用。完整的文档可以在[https://github.com/Netflix/Hystrix/wiki/configuration.](https://github.com/Netflix/Hystrix/wiki/configuration)找到。我们可以根据不同的用例使用这些属性。'
- en: Spring Boot Admin
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot Admin
- en: The Spring Boot Admin project is a tool that helps developers in production
    environments. The tool shows Spring Boot application metrics in an organized dashboard,
    and it makes it extremely easy to see application metrics and much more information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Admin项目是一个帮助生产环境中开发者的工具。该工具以有组织的仪表板显示Spring Boot应用程序指标，并且使查看应用程序指标和更多信息变得极其容易。
- en: The tool uses the data from the Spring Boot Actuator as an information source.
    The project is open source and has a lot of contributors and is an active project
    in the community as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 工具使用Spring Boot Actuator的数据作为信息源。该项目是开源的，有很多贡献者，并且在社区中也是一个活跃的项目。
- en: Running Spring Boot Admin
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Spring Boot Admin
- en: It is a piece of cake to set up the application. We will need a new Spring Boot
    application, and to connect this new application with our service discovery implementation.
    Let's do it right now.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 设置应用程序非常简单。我们需要一个新的Spring Boot应用程序，并将其与我们的服务发现实现连接。让我们现在就做吧。
- en: We can find the code on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin).
    If you want to create a new application, go ahead; the process is similar to what
    we did in the previous chapters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GitHub上找到代码[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter08/admin)。如果你想创建一个新的应用程序，请继续；过程与我们在前面的章节中所做的是相似的。
- en: 'The project is a Spring Boot regular application, with two new dependencies:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是一个Spring Boot常规应用，包含两个新的依赖项：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These dependencies are about `admin-server` and `admin-server-ui`. The project
    does not support Spring Boot 2 yet, but this is not a problem as we do not need
    reactive stuff for this; it is a monitoring tool.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项是关于`admin-server`和`admin-server-ui`的。该项目目前不支持Spring Boot 2，但这不是问题，因为我们不需要对此使用响应式功能；它是一个监控工具。
- en: 'We have configured our mandatory dependencies. We will need a service discovery
    because we have one in our infrastructure. We need it to provide the service discovery
    feature, and minimize the configurations for our Spring Boot Admin application.
    Let''s add the Eureka client dependency:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Awesome, our dependencies are configured properly. Then we can create our main
    class. The main class should be like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The main difference here is that `@EnableAdminServer` will configure the Spring
    Boot Admin application and set up the server for us. As we expected, we will use
    the Config Server application to store our `application.yaml`. In order to achieve
    this, we need to create our `bootstrap.yaml`, which should be like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: No difference at all,  `bootstrap.yaml` is configured to look up the configuration
    file from the Config Server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Time to create our `application.yaml` file, to which we need to add some configuration
    to set the new health check URL, since the actuator on Spring Boot 2 was moved,
    prefixed by *actuator*. Our new health check URL should be `/actuator/health`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Our configuration file should be like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have configured the Eureka server address and set the health check URL.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run our main class called `AdminApplication.` We can use the Java
    command line or IDE; there is no difference at all.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Run it!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'We should see the following line at the log file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c8e76dd-dd5c-41f4-8180-52587573730b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Awesome, our application is ready to use. Now we can go to the main page. Go
    to `http://localhost:50015/#/` (main page), then we can see the following page:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe35b8f6-a74e-48e6-9d9c-389c824e2d8b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Look how it is easier to see any outage or strange behaviors in our microservices.
    Remember the key point in microservices architecture is monitoring. It is really
    necessary in order to have a good environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Zuul
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Cloud Gateway is the natural choice when we adopt the microservices
    architecture, but nowadays the Spring Cloud Gateway does not have support enabled
    for service discovery features, such as the Eureka server. It means we will have
    to configure it route by route. This does not sound good.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We have the Zuul proxy as a gateway for our microservices environment, but keep
    in mind the Spring Cloud Gateway is the best choice when the project has support
    for service discovery.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the Zuul proxy project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the EDGE service project
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The EDGE service is a service that provides dynamic routing, monitoring, resiliency,
    and security. The basic idea here is to create a reverse proxy for our microservices.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: This service will act as a proxy for our microservices and will be exposed as
    a central access point. The Spring Cloud Zuul integrates with the Eureka server.
    It will increase our resiliency because we will use the service discovery feature
    provided by the Eureka server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image demonstrates how we will use the **Edge Service** in our
    architecture:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3e92e86-ea33-4eaa-8516-b7c2bafbbd53.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: As we can see, the **Zuul Server** will connect to the service discovery server,
    to get the list of available services. After that the Zuul service will redirect
    to the requested service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Look at the diagram. There is no interaction with the clients, that is, **Mobile**
    and **Browser**, and our microservices.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Zuul also supports interesting features, such as:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**pre**: This can be used to set some data in`RequestContext`; it is executed
    before the request is routed'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**route**: This handles the request routing'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**post**: This filters which one acts after the request is routed'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**error**: When some errors happen, we can use the error feature to handle
    the request'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not use these features, but keep in mind that they can be very useful.
    Remember, our Zuul server is our gateway to the internet.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EDGE server
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Zuul server to act as an API gateway for our applications. Now
    it's time to create our project. As there is no relevant difference involved in
    creating this project, we will take a look at specific Zuul parts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency required is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It will configure for us the Zuul server dependencies.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add the project''s main class. The class should be like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The new thing here is `@EnableZuulProxy`. It will set up a Zuul server endpoint
    and configure reverse proxy filters. Then we will be able to forward a request
    to microservices applications. Zuul integrates with the Eureka server, so we do
    not need to configure it manually. The auto-configuration will find the services
    at the time of the discovery client implementation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We can run the application via the command line or IDE, it is up to you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can see the routes configured. Go to `http://localhost:8888/routes`
    and we will able to see the routes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d7729e9-8590-4edd-bb95-c73b78c437d7.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'We have some routes configured. We did this using the `application.yaml` file.
    The file should be like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's understand this configuration. We have created a node called `planes`.
    This node configures a `path` (that is the URI) and configures the service name,
    by `serviceId`, registered in the Eureka server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a simple test. We will:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Configure the new URL path for the planes service
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the request using the Zuul server
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the `PlaneResource` class located in the `planes` microservice project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RequestMapping` is configured like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change it to something like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember we can use the Zuul server as a router, so we do not need this information
    anymore. With the URI path on the source code, we are able to use the configuration
    file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `planes` microservice again. The following services need to be running:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Config Server
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eureka server
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planes microservice
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Edge
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then we can call the `planes` microservices using the Zuul proxy. Let''s do
    it using cURL:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s understand this a little bit. The port `8888` points to the **Zuul Server**,
    and we have configured it in `application.yaml`. When the path is `/api/v1/planes/**`,
    the **Zuul Server** will redirect to the `planes` microservices. The basic flow
    is:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39a82733-8ff4-48c2-8304-5a6551a105f9.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: 'The request is coming to the **Zuul Server**, and then the **Zuul Server**
    will redirect it to the requested microservice. The result should be like this;
    in my case, I have some planes in the database:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32018be4-666f-4285-afd8-a67409a980b1.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: Awesome, our API Gateway is fully operational. We will use it for all services
    in the same port, and only the URI will be changed to point to the desired `serviceId`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We can configure the port like in other Spring Boot applications. We chose the
    `8888` port in this case.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about some important microservice patterns
    and how they can help us to deliver a fault-tolerant, resilient, and error-prone
    application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We have practiced how to use the service discovery feature provided by the Spring
    Framework and how it works at the application runtime, and we made some debug
    tasks to help us to understand how it works under the hood.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The Hystrix project, hosted by Netflix, can increase our application's resilience
    and fault tolerance. When working with remote calls, in this section, we made
    some Hystrix commands and understood how Hystrix is a useful implementation of
    the Circuit Breaker pattern.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we are able to understand the microservices drawbacks
    and how to solve the common problems in a distributed environment.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to solve the common problems of microservices architectural
    style using the Spring Framework.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finish our *Airline Ticket System*, using the configured
    tools to monitoring the microservices' health and look at how it helps developers
    during the operation time when the microservices are running in the production
    stage.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: See you there.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
