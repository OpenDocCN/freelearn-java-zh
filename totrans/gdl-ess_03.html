<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Building a Web Application"><div class="book" id="MSDG2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Building a Web Application</h1></div></div></div><p class="calibre8">Now that we have seen the ease of using Gradle for building a command-line Java application, we shouldn't be surprised to know that building web applications based on Java servlet specification is also equally easy with Gradle.</p><p class="calibre8">In this chapter, we will build a simple web application first, which is distributed as a <code class="literal">WAR</code> file that can be deployed to any servlet container. Then, we will take a look at how dependencies and repositories are configured in a build file.</p></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Building a Web Application">
<div class="book" title="Building a simple Java web project"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec17" class="calibre1"/>Building a simple Java web project</h1></div></div></div><p class="calibre8">Again, we <a id="id71" class="calibre1"/>will keep our application as minimal as possible and create a web-enabled version of the application, which we developed in the last chapter. The application will provide the user a form to input their name and a <span class="strong"><strong class="calibre9">Submit</strong></span> button. When the user clicks on the <span class="strong"><strong class="calibre9">Submit</strong></span> button, the greeting will be displayed.</p><p class="calibre8">The application will be based on Servlet 3.1 specification. We will reuse the <code class="literal">GreetService</code> that we developed in the previous chapter. The form will be served by a static HTML file, which can post data to our servlet. The servlet will create a greeting message and forward it to a JSP for rendering.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">For more details <a id="id72" class="calibre1"/>on Servlet specification 3.1, go to <a class="calibre1" href="https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html">https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html</a>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Building a Web Application">
<div class="book" title="Building a simple Java web project">
<div class="book" title="Creating source files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec25" class="calibre1"/>Creating source files</h2></div></div></div><p class="calibre8">Let's <a id="id73" class="calibre1"/>create the root of the project as <code class="literal">hello-web</code>. The structure is similar to what we had seen for a simple Java application, with one addition, which is the web app root. The Web app root, by default, is located at <code class="literal">src/main/webapp</code>. Those who are familiar with Maven will immediately notice that it's the same path used by Maven as well.</p><p class="calibre8">The Web app root (<code class="literal">webapp</code>) contains all the public resources required to run a web application, which includes dynamic pages such as JSPs or the files required for other view template <a id="id74" class="calibre1"/>engines such as Thymeleaf, FreeMarker, Velocity, and so on; as well as static resources such as HTML, CSS, JavaScript, and image files; and other configuration files such as <code class="literal">web.xml</code> in the special directory called <code class="literal">WEB-INF</code>. The files stored in <code class="literal">WEB-INF</code> are not directly accessible to the client; hence, it is a perfect place to store protected files.</p><p class="calibre8">We will begin with creating the directory structure for what the final application should look like:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">hello-web</strong></span>
<span class="strong"><strong class="calibre9">├── build.gradle</strong></span>
<span class="strong"><strong class="calibre9">└── src</strong></span>
<span class="strong"><strong class="calibre9">    └── main</strong></span>
<span class="strong"><strong class="calibre9">        ├── java// source root</strong></span>
<span class="strong"><strong class="calibre9">        │ └── com</strong></span>
<span class="strong"><strong class="calibre9">        │     └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">        │         └── ge</strong></span>
<span class="strong"><strong class="calibre9">        │             └── hello</strong></span>
<span class="strong"><strong class="calibre9">        │                 ├── GreetingService.java</strong></span>
<span class="strong"><strong class="calibre9">        │                 └── GreetingServlet.java</strong></span>
<span class="strong"><strong class="calibre9">        └── webapp// web-app root</strong></span>
<span class="strong"><strong class="calibre9">            ├── WEB-INF</strong></span>
<span class="strong"><strong class="calibre9">            │ └── greet.jsp</strong></span>
<span class="strong"><strong class="calibre9">            └── index.html</strong></span>
</pre></div><p class="calibre8">Then, perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Let's first add the familiar <code class="literal">GreetingService</code> from the last chapter to our sources. We might notice that copying the Java source file is not a right way to reuse. There are much better ways to organize such dependencies. One such way is with multimodule projects. We will see this in <a class="calibre1" title="Chapter 5. Multiprojects Build" href="part0035_split_000.html#11C3M1-e78ecbb3ac0544f19c59f96d594821c0">Chapter 5</a>, <span class="strong"><em class="calibre10">Multiprojects Build</em></span>.</li><li class="listitem" value="2">Now, add the following content to the <code class="literal">index.html</code> file:<div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello Web&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form action="greet" method="post"&gt;
      &lt;input type="text" name="name"/&gt;
      &lt;input type="submit"/&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre25">This file starts with an HTML 5 <code class="literal">doctype</code> declaration, which is the most simple <code class="literal">doctype</code> we can use. Then, we create a form that will post to <code class="literal">greet</code> endpoint (it is a relative path to the page).</p></li><li class="listitem" value="3">Now, at<a id="id75" class="calibre1"/> the heart of this application, there is the <code class="literal">GreetServlet</code> that responds to the post request:<div class="informalexample"><pre class="programlisting">package com.packtpub.ge.hello;

import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.io.IOException;

@WebServlet("/greet")
public class GreetingServlet extends HttpServlet {

  GreetingService service = new GreetingService();

  @Override
  public void doPost(HttpServletRequest request,
                     HttpServletResponse response)
    throws ServletException, IOException {

    String name = request.getParameter("name");
    String message = service.greet(name);
    request.setAttribute("message", message);

    RequestDispatcher dispatcher = getServletContext()
      .getRequestDispatcher("/WEB-INF/greet.jsp");

    dispatcher.forward(request, response);
  }

}</pre></div><p class="calibre25">In the preceding code , the <code class="literal">WebServlet</code> annotation's value maps this servlet to the <code class="literal">/greet</code> path relative to the context of the application. Then, an instance of <code class="literal">GreetService</code> is made available in this servlet. The overridden method <code class="literal">doPost</code> extracts the name from the <code class="literal">request</code> object, generates the greeting message, sets this message back in the <code class="literal">request</code> as an attribute so that it's accessible in the JSP, and then finally forwards the request to the <code class="literal">greet.jsp</code> file that is located at <code class="literal">/WEB-INF/greet.jsp</code>.</p></li><li class="listitem" value="4">This <a id="id76" class="calibre1"/>brings us to the <code class="literal">greet.jsp</code> file, which is kept in <code class="literal">WEB-INF</code> so that it's not directly accessible and the request has to always come through the servlet that sets the right request attributes:<div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello Web&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;${requestScope.message}&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre25">This JSP just prints the <code class="literal">message</code> that is available in the request attribute.</p></li></ol><div class="calibre15"/></div></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Building a Web Application">
<div class="book" title="Building a simple Java web project">
<div class="book" title="Creating a build file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec26" class="calibre1"/>Creating a build file</h2></div></div></div><p class="calibre8">Finally, let's <a id="id77" class="calibre1"/>create the file we've been waiting for—the <code class="literal">build.gradle</code> file —in the root of the project:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'war'

repositories {
    mavenCentral()
}

dependencies {
    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'
}</pre></div><p class="calibre8">Let's try to understand this file now:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first line applies the <code class="literal">war</code> plugin to the project. This plugin adds a <code class="literal">war</code> task to the project. One might wonder why we don't need to apply the <code class="literal">java</code> plugin to compile the classes. This is because the <code class="literal">war</code> plugin extends the <code class="literal">java</code> plugin; so all the tasks that were available when we applied the <code class="literal">java</code> plugin are still available to us in addition to the <code class="literal">war</code> task.</li><li class="listitem">Next, comes the <code class="literal">repositories</code> section that configures our build to look for all the dependencies in the Maven central repository.</li></ul></div><p class="calibre8">Lastly, in<a id="id78" class="calibre1"/> the <code class="literal">dependencies</code> block, we add <code class="literal">servlet-api</code> to the <code class="literal">providedCompile</code> configuration (scope). This tells Gradle not to package the servlet API with the application, as it will already be available on the container where the application will be deployed. The <code class="literal">providedCompile</code> configuration is added by the <code class="literal">war</code> plugin (it also adds <code class="literal">providedRuntime</code>). If we had any other dependency that needs to be packaged with our application, it would have been declared using the compile configuration. For example, if our app depends on the Spring Framework, then the dependencies section might have looked as follows:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile 'org.springframework:spring-context:4.0.6.RELEASE'
    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'
}</pre></div><p class="calibre8">Don't worry if it feels like the details on <code class="literal">repositories</code>, <code class="literal">configurations</code> and <code class="literal">dependencies </code>are a bit sketchy. We will soon see them again, in more detail, later in this chapter.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Building a Web Application">
<div class="book" title="Building a simple Java web project">
<div class="book" title="Building the artifact"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec27" class="calibre1"/>Building the artifact</h2></div></div></div><p class="calibre8">Now <a id="id79" class="calibre1"/>that our source files are ready with the build file, we must build the deployable WAR file. Let's verify the tasks available for our build using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle tasks --all</strong></span>
<span class="strong"><strong class="calibre9">…</strong></span>
<span class="strong"><strong class="calibre9">war - Generates a war archive with all the compiled classes, the web-app content and the libraries. [classes]</strong></span>
<span class="strong"><strong class="calibre9">…</strong></span>
</pre></div><p class="calibre8">We will notice the <code class="literal">war</code> task there, which depends on <code class="literal">classes</code> (task). We don't need to explicitly compile and build the Java sources, which is automatically taken care of by the <code class="literal">classes</code> task. So all that we need to do now is, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle war</strong></span>
</pre></div><p class="calibre8">Once the build is complete, we will see the directory's structure similar to following structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">hello-web</strong></span>
<span class="strong"><strong class="calibre9">├── build</strong></span>
<span class="strong"><strong class="calibre9">│ ├── classes</strong></span>
<span class="strong"><strong class="calibre9">│ │ └── main</strong></span>
<span class="strong"><strong class="calibre9">│ │     └── com</strong></span>
<span class="strong"><strong class="calibre9">│ │         └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">│ │             └── ge</strong></span>
<span class="strong"><strong class="calibre9">│ │                 └── hello</strong></span>
<span class="strong"><strong class="calibre9">│ │                     ├── GreetService.class</strong></span>
<span class="strong"><strong class="calibre9">│ │                     └── GreetServlet.class</strong></span>
<span class="strong"><strong class="calibre9">│ ├── dependency-cache</strong></span>
<span class="strong"><strong class="calibre9">│ ├── libs</strong></span>
<span class="strong"><strong class="calibre9">│ │ └── hello-web.war</strong></span>
<span class="strong"><strong class="calibre9">│ └── tmp</strong></span>
<span class="strong"><strong class="calibre9">│     └── war</strong></span>
<span class="strong"><strong class="calibre9">│         └── MANIFEST.MF</strong></span>
<span class="strong"><strong class="calibre9">…</strong></span>
</pre></div><p class="calibre8">The war file <a id="id80" class="calibre1"/>is created at <code class="literal">/build/libs/hello-web.war</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">A <code class="literal">war</code> file is nothing but a ZIP file with a different file extension. The same holds true for an <code class="literal">.ear</code> or <code class="literal">.jar</code> file for that matter. We can use the standard zip/unzip tools too or use the JDK's <code class="literal">jar</code> utility to perform various operations on these files. To list the contents of WAR, use <code class="literal">jar -tf build/libs/hello-web.war</code>.</p></div><p class="calibre8">Let's check the content of this WAR file once:</p><p class="calibre8">…</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">├── META-INF</strong></span>
<span class="strong"><strong class="calibre9">│ └── MANIFEST.MF</strong></span>
<span class="strong"><strong class="calibre9">├── WEB-INF</strong></span>
<span class="strong"><strong class="calibre9">│ ├── classes</strong></span>
<span class="strong"><strong class="calibre9">│ │ └── com</strong></span>
<span class="strong"><strong class="calibre9">│ │     └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">│ │         └── ge</strong></span>
<span class="strong"><strong class="calibre9">│ │             └── hello</strong></span>
<span class="strong"><strong class="calibre9">│ │                 ├── GreetService.class</strong></span>
<span class="strong"><strong class="calibre9">│ │                 └── GreetServlet.class</strong></span>
<span class="strong"><strong class="calibre9">│ └── greet.jsp</strong></span>
<span class="strong"><strong class="calibre9">└── index.html</strong></span>
</pre></div><p class="calibre8">Perfect. The compiled classes landed into the <code class="literal">WEB-INF/classes</code> directory. The servlet API's JAR is not included as it was in the <code class="literal">providedCompile</code> scope.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre9">Exercise</strong></span>
</p><p class="calibre8">Add <code class="literal">compile 'org.springframework:spring-context:4.0.6.RELEASE'</code> in the <code class="literal">dependencies</code> section and then do a <code class="literal">gradle war</code> file and see the content of the created WAR.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Building a Web Application">
<div class="book" title="Building a simple Java web project">
<div class="book" title="Running the web application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec28" class="calibre1"/>Running the web application</h2></div></div></div><p class="calibre8">We have <a id="id81" class="calibre1"/>come a long way in creating the web-app. However, to use it, it must be deployed to a servlet container. It can be classically deployed to a servlet container by copying the <code class="literal">.war</code> file in the servlet container's designated directory (such as <code class="literal">webapps</code> in the case of Tomcat). Alternatively, a more recent technique can be used to embed a Servlet container into a Java app, which is packaged as a <code class="literal">.jar</code> and is run as any other <code class="literal">java –jar</code> command.</p><p class="calibre8">Web apps are typically run in three modes, development, functional testing, and production. The key characteristics of all the three modes differ as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The key characteristics of running web in development mode is faster deployment (preferably hot reloads), quick server start and shutdown, very low server footprint, and so on.</li><li class="listitem">While in functional testing, we typically deploy <code class="literal">web-app</code> once for the entire test suite's run. We need to mimic production-like behavior of an app as much as possible. We need to set up and destroy the web-app's state (such as databases), using lightweight databases (preferably in-memory) for all tests. We also need to mock external services.</li><li class="listitem">Whereas, in production deployments, the app-servers' (whether standalone or embedded) configuration, security, optimization of app, caches, and so on, takes more precedence, features such as hot reloading deployments are rarely used; faster startup time takes lesser precedence.</li></ul></div><p class="calibre8">We will only cover the development scenario in this chapter. We will start with the traditional way to highlight its problems and then move on to Gradle's way.</p><p class="calibre8">Now, if we need to deploy the war in a manual way. We can choose any Java servlet container such as Jetty or Tomcat to run our web-app. In this example, let's use Tomcat. Assuming Tomcat is installed at<code class="literal">~/tomcat</code> or <code class="literal">C:\tomcat</code> (based on the OS that we are using):</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">If the server is running, ideally we should stop it.</li><li class="listitem" value="2">Copy the WAR file to the Tomcat's <code class="literal">webapp</code> (<code class="literal">~/tomcat/webapps</code>) directory.</li><li class="listitem" value="3">Then, start the Tomcat server using <code class="literal">~/tomcat/bin/startup.sh</code> or <code class="literal">C:\tomcat\bin\startup.bat</code>.</li></ol><div class="calibre15"/></div><p class="calibre8">However, this kind of deployment feels outdated in Gradle's age. Especially, while developing<a id="id82" class="calibre1"/> the web-app, we have to constantly package the application as a <code class="literal">war</code>, copy the latest version to the container, and restart the container to get the latest code running. When we say build automation, it implicitly means that no manual intervention should be expected and things should work in one click (or one command in Gradle's case). Also, luckily, there are many options to achieve this level of automation.</p><div class="book" title="Plugins to the rescue"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec07" class="calibre1"/>Plugins to the rescue</h3></div></div></div><p class="calibre8">Out of <a id="id83" class="calibre1"/>the box, Gradle has no support for modern servlet containers. However, this is the beauty of Gradle's architecture. Innovation and/or implementation does not have to come from a selected few who are creating Gradle. With the help of plugins API, anyone can create functionally rich plugins. We are going to use a plugin called Gretty for our web-app's development time deployment, but you should also check out others to see what works the best for you.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">There is a <code class="literal">jetty</code> plugin available, which is shipped with Gradle. However, it has not been actively updated; hence, it officially supports only Jetty 6.x (as of this writing). So we can use it if our web application is based on Servlet 2.5 specification or lower.</p></div><p class="calibre8">A Gretty plugin can be found at a Gradle plugin portal (look at the references below). This plugin adds numerous tasks to the build and supports various versions of Tomcat and Jetty. Installing it cannot be any easier. The code for this uses the same <code class="literal">hello-web</code> source from the last section, but updates the <code class="literal">build.gradle</code> file. An entire source code for this example can be found in the <code class="literal">chapter-03/hello-gretty </code>directory of the book's sample code.</p><p class="calibre8">Just include the following at the first line of <code class="literal">build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">plugins {</strong></span>
<span class="strong"><strong class="calibre9">  id "org.akhikhl.gretty" version "1.2.4"</strong></span>
<span class="strong"><strong class="calibre9">}</strong></span>
</pre></div><p class="calibre8">That's it—we are done. This is relatively a new syntax for applying plugins to builds, which was added in Gradle 2.1. This is especially useful for applying third-party plugins. Unlike calling the <code class="literal">apply</code> method to apply the plugin, we start with the plugin block on the first line. Then, we specify the plugin's ID. For applying an external plugin, we must use the fully qualified plugin ID and version. We can include the <code class="literal">war</code> plugin's application inside this block. For internal plugins, we don't need to specify a version. It will look as follows:</p><div class="informalexample"><pre class="programlisting">plugins {
  id "org.akhikhl.gretty" version "1.2.4"
  id "war"
}</pre></div><p class="calibre8">If we run <code class="literal">gradle tasks</code> now, we must have an <code class="literal">appRun</code> task under the <code class="literal">Gretty</code> group. There are many more tasks in this group, which are added by the Gretty plugin. If we run the <code class="literal">appRun</code> task, without configuring the plugin explicitly, then by default a Jetty 9 will be run on <code class="literal">http://localhot:8080</code>. We can open the browser and verify.</p><p class="calibre8">There are many <a id="id84" class="calibre1"/>configurations exposed by the plugin, in order to control aspects such as server version, port number, and many more. Add a <code class="literal">gretty</code> block to the <code class="literal">build.gradle </code>files as follows<code class="literal">:</code>
</p><div class="book"><ul class="itemizedlist"><li class="listitem">If we want to use Tomcat 8 on port 8080, we'll add the following lines of code:<div class="informalexample"><pre class="programlisting">gretty {
  servletContainer = 'tomcat8'
  port = 8080
}</pre></div></li><li class="listitem">If we want to use Jetty 9 on 9080, we'll add the following lines of code:<div class="informalexample"><pre class="programlisting">gretty {
  servletContainer = 'jetty9'
  port = 9080
}</pre></div></li></ul></div><p class="calibre8">There are many more configuration options available in Gretty; we would recommend you to check Gretty's online documentation. See the link to Gretty in the references section.</p><p class="calibre8">Here is how the running application looks like:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Plugins to the rescue" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Once<a id="id85" class="calibre1"/> the <span class="strong"><strong class="calibre9">Submit</strong></span> button is pressed, we'll get the following result:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Plugins to the rescue" class="calibre11"/></div><p class="calibre12"> </p></div></div></div></div>
<div class="book" title="References" id="NQU21-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec18" class="calibre1"/>References</h1></div></div></div><p class="calibre8">For <a id="id86" class="calibre1"/>Gradle, refer to the following URL:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Gradle plugin portal: <a class="calibre1" href="https://plugins.gradle.org/">https://plugins.gradle.org/</a></li></ul></div><p class="calibre8">For <a id="id87" class="calibre1"/>Gretty, refer to the following URL:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Gretty plugin: <a class="calibre1" href="https://plugins.gradle.org/plugin/org.akhikhl.gretty">https://plugins.gradle.org/plugin/org.akhikhl.gretty</a></li><li class="listitem">Gretty documentation: <a class="calibre1" href="http://akhikhl.github.io/gretty-doc/">http://akhikhl.github.io/gretty-doc/</a></li></ul></div><p class="calibre8">There are various plugins available to automate the deployment. Some of them are listed here:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Cargo plugin: <a class="calibre1" href="https://github.com/bmuschko/gradle-cargo-plugin">https://github.com/bmuschko/gradle-cargo-plugin</a></li><li class="listitem">Arquillian plugin: <a class="calibre1" href="https://github.com/arquillian/arquillian-gradle-plugin">https://github.com/arquillian/arquillian-gradle-plugin</a></li><li class="listitem">Tomcat plugin: <a class="calibre1" href="https://github.com/bmuschko/gradle-tomcat-plugin">https://github.com/bmuschko/gradle-tomcat-plugin</a></li></ul></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Project dependencies"><div class="book" id="OPEK2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>Project dependencies</h1></div></div></div><p class="calibre8">In real<a id="id88" class="calibre1"/> life, we work on a lot more complex applications than what we have just seen. Such applications rely on other specialized components to provide some functionality. For example, an Enterprise Java application's build may depend on various components such as open source libraries in Maven central, libraries developed and hosted in-house, and (maybe) even on another subprojects. Such dependencies are, themselves, located at various locations like, local intranet, local filesystem, and so on. They need to be resolved, downloaded, and brought into the appropriate configuration (such as <code class="literal">compile</code>, <code class="literal">testCompile</code>, and so on) of the build.</p><p class="calibre8">Gradle does an excellent job in locating and making dependencies available in the appropriate <code class="literal">classpath</code> and packaging if required. Let's begin with the most common kind of dependencies—external libraries.</p></div>

<div class="book" title="Project dependencies">
<div class="book" title="External libraries"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec29" class="calibre1"/>External libraries</h2></div></div></div><p class="calibre8">Almost<a id="id89" class="calibre1"/> all real-world projects depend on external libraries<a id="id90" class="calibre1"/> for reusing the proven and tested components. Such dependencies include language utilities, database drivers, web frameworks, XML/JSON serialization libraries, ORMs, logging utilities, and many more.</p><p class="calibre8">The dependencies of a project are declared in the <code class="literal">dependencies</code> section in the build file.</p><p class="calibre8">Gradle provides an extremely succinct syntax for declaring the coordinates of an artifact. It usually takes a form of <code class="literal">group:name:version</code>. Note that each value is separated by a colon (<code class="literal">:</code>).</p><p class="calibre8">For example, Spring Framework's core library can be referenced using the following code:</p><div class="informalexample"><pre class="programlisting">dependencies {
  compile 'org.springframework:spring-core:4.0.6.RELEASE'
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre8">For those who don't enjoy terseness, dependencies can be referred in a more descriptive format (called map format).</p><div class="informalexample"><pre class="programlisting">compile group:'org.springframework', name:'spring-core', version:'4.0.6.RELEASE'</pre></div></div><p class="calibre8">We can also specify multiple dependencies as follows:</p><div class="informalexample"><pre class="programlisting">configurationName dep1, dep2, dep3…. </pre></div><p class="calibre8">Where <code class="literal">configurationName</code> represents the configuration such as <code class="literal">compile</code>, <code class="literal">testCompile</code> and so on, we are soon going to see what configuration is in this context.</p><div class="book" title="The dynamic version"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec08" class="calibre1"/>The dynamic version</h3></div></div></div><p class="calibre8">The <a id="id91" class="calibre1"/>version of our dependencies keep on updating every now and then. Also, when we are in the development phase, we don't want keep on checking manually whether a new version is available.</p><p class="calibre8">In such situations, we can add a <code class="literal">+</code> to denote the version mentioned above, given the number of artifacts. For example, <code class="literal">org.slf4j:slf4j-nop:1.7+</code> declares any version of SLF4J that is above 1.7. Let's include this in a <code class="literal">build.gradle</code> file and check what Gradle brings in for us.</p><p class="calibre8">We run the following code in our <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">runtime 'org.slf4j:slf4j-nop:1.7+'</pre></div><p class="calibre8">Then, we run the <code class="literal">dependencies</code> task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle dependencies</strong></span>
<span class="strong"><strong class="calibre9">…</strong></span>
<span class="strong"><strong class="calibre9">+--- org.slf4j:slf4j-nop:1.7+ -&gt; 1.7.7</strong></span>
<span class="strong"><strong class="calibre9">|    \--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong class="calibre9">…</strong></span>
</pre></div><p class="calibre8">We see that Gradle chose the 1.7.7 version, as it's the latest version available as of the writing of this book. If you observe the second line, it tells us that <code class="literal">slf4j-nop</code> depends on <code class="literal">slf4j-api</code>; hence, it's a transitive dependency for our project.</p><p class="calibre8">A word of caution here is, always use <code class="literal">+</code> for only minor version upgrades (such as <code class="literal">1.7+</code> in the preceding example). Letting the major version automatically update (for example, just image is spring automatically updates from 3 to 4, <code class="literal">compile 'org.springframework:spring-core:+'</code>) is nothing but a gamble. A dynamic dependency resolution is a nice feature, but it should be used with care. It should ideally only be used at the development stage of the project and not for releases candidates.</p><p class="calibre8">We get a flaky build whenever the dependency's version updates to some incompatible version with our app. We should target for reproducible builds, such a build should produce the exact same artifact, be it today or one year down the line.</p></div><div class="book" title="Transitive dependencies"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec09" class="calibre1"/>Transitive dependencies</h3></div></div></div><p class="calibre8">By <a id="id92" class="calibre1"/>default, Gradle resolves transitive dependencies quite intelligently, giving preference to the latest conflicting versions, if any. However, for some reason, if we want to disable transitive dependencies, all we need to provide is an extra block to our dependency declaration:</p><div class="informalexample"><pre class="programlisting">    runtime ('org.slf4j:slf4j-nop:1.7+') {
        transitive = false
    }</pre></div><p class="calibre8">Now, if we check the output of the <code class="literal">dependencies</code> task, we see that no other dependency is included anymore:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">\--- org.slf4j:slf4j-nop:1.7.2</strong></span>
</pre></div><p class="calibre8">We can also <a id="id93" class="calibre1"/>force a given version of the library so that, even if the same artifacts, the later version comes through the transitive dependency; the version we forced will win:</p><div class="informalexample"><pre class="programlisting">    runtime ('org.slf4j:slf4j-nop:1.7.2') {
        force = true  
    }</pre></div><p class="calibre8">Running dependencies task now will produce:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">+--- org.slf4j:slf4j-api:1.7.2</strong></span>
<span class="strong"><strong class="calibre9">\--- org.slf4j:slf4j-nop:1.7.7</strong></span>
<span class="strong"><strong class="calibre9">     \--- org.slf4j:slf4j-api:1.7.7 -&gt; 1.7.2</strong></span>
</pre></div><p class="calibre8">This shows the older version of <code class="literal">slf4j-api</code> won, even though a later version could have been fetched by the transitive dependency.</p></div></div></div>

<div class="book" title="Project dependencies">
<div class="book" title="Dependency configurations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec30" class="calibre1"/>Dependency configurations</h2></div></div></div><p class="calibre8">Gradle <a id="id94" class="calibre1"/>provides a very elegant way to <a id="id95" class="calibre1"/>declare dependencies that are required for building different groups of sources in various stages of a project build.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre8">These groups of sources are known as <a id="id96" class="calibre1"/>
<span class="strong"><strong class="calibre9">source sets</strong></span>. The simplest and well-understood examples of source sets are <code class="literal">main</code> and <code class="literal">test</code>. The <code class="literal">main</code> source set contains files that will be compiled and built as a JAR file and will be deployed somewhere or published to some repository. The <code class="literal">test</code> source set, on the other hand, contains files that will be executed by a testing tool such as JUnit, but will not make it to production. Now, both the source sets have different requirements for the dependencies, building, packaging, and execution. We will see how to add new source sets in <a class="calibre1" title="Chapter 7. Testing and Reporting with Gradle" href="part0045_split_000.html#1AT9A1-e78ecbb3ac0544f19c59f96d594821c0">Chapter 7</a>, <span class="strong"><em class="calibre10">Testing and Reporting with Gradle</em></span>, for integration testing.</p></div><p class="calibre8">As we have defined the group of related sources in a source set, dependencies are also defined as a group called <a id="id97" class="calibre1"/>
<span class="strong"><strong class="calibre9">configuration</strong></span>. Each configuration has its name such as <code class="literal">compile</code>, <code class="literal">testCompile</code>, and so on. Dependencies included in various configurations also differ. Configurations are grouped by the characteristics of dependencies. For example, the following are configurations that are added by the <code class="literal">java</code> and <code class="literal">war</code> plugins:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">compile</code>: This is <a id="id98" class="calibre1"/>added by the <code class="literal">java</code> plugin. Adding a dependency to this configuration implies that the dependency is required to compile the source. In the case of <code class="literal">war</code>, these will also get copied in <code class="literal">WEB-INF/lib</code>. Examples of such dependencies are libraries such as Spring Framework, Hibernate, and so on.</li><li class="listitem"><code class="literal">runtime</code>: This is<a id="id99" class="calibre1"/> added by the <code class="literal">java</code> plugin. This includes the <code class="literal">compile</code> dependencies by default. Dependencies in this group are required at runtime for the compiled source code, but they are not required to compile it. Dependencies such as JDBC drivers are runtime dependencies only. We do not need them on our classpath to compile the source code as we code against the standard JDBC API interfaces available in JDK. However, for our application to run properly, we need a specific driver implementation at run time. For example, <code class="literal">runtime 'mysql:mysql-connector-java:5.1.37'</code> includes the MySQL driver.</li><li class="listitem"><code class="literal">testCompile</code>: This<a id="id100" class="calibre1"/> is added by the <code class="literal">java</code> plugin. This includes the <code class="literal">compile</code> dependencies by default. Dependencies added to this configuration are only available to test sources. Examples are testing libraries such as JUnit, TestNG, and so on, or any libraries that are exclusively used by test source such as Mockito. They are neither required to compile, nor required at runtime for the main source set. They do not get included in <code class="literal">war</code> in the case of building a <code class="literal">web-app</code>.</li><li class="listitem"><code class="literal">testRuntime</code>: This <a id="id101" class="calibre1"/>is added by the <code class="literal">java</code> plugin. This includes <code class="literal">testCompile</code> and <code class="literal">runtime</code> dependencies by default. Dependencies in this configuration are only required to test sources at the runtime (that is, while running tests). Hence, they are not included in the compilation classpath of tests. This is just like the runtime configuration, but only for test sources.</li><li class="listitem"><code class="literal">providedCompile</code>: This<a id="id102" class="calibre1"/> is added by the <code class="literal">war</code> plugin. Dependencies such as servlet APIs are provided by application servers and hence need not be packaged in our <code class="literal">war</code>. Anything that we expect to be already included in the server runtime can be added to this configuration. However, it has to be present at the time of compilation of the source code. Hence, we can declare such dependencies as <code class="literal">providedCompile</code>. Examples are servlet API and any Java EE implementations that are available at server runtime. Such dependencies are not included in <code class="literal">war</code>.</li><li class="listitem"><code class="literal">providedRuntime</code>: This<a id="id103" class="calibre1"/> is added by the <code class="literal">war</code> plugin. Dependencies that will be made available at application runtime by the server and application do not need to be included while compiling because there is no direct reference to the implementation. Such libraries can be added to this configuration. Such dependencies will not be included in <code class="literal">war</code>. Hence, we should make sure to have implementation available in the application runtime.</li></ul></div><p class="calibre8">As we know, when <a id="id104" class="calibre1"/>we apply the <code class="literal">war</code> plugin, the <code class="literal">java</code> plugin also gets applied. That's why all six configurations are available when we are building a web application. More configurations can be added by plugins, or we can declare them ourselves in our build script.</p><p class="calibre8">Interestingly, configuration does not just include dependencies, but also the artifacts produced by this configuration.</p></div></div>

<div class="book" title="Project dependencies">
<div class="book" title="Repositories"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec31" class="calibre1"/>Repositories</h2></div></div></div><p class="calibre8">The <a id="id105" class="calibre1"/>repositories section configures the repositories where Gradle will look for dependencies. Gradle downloads the dependencies into its own cache so that the download doesn't need to happen every time Gradle is run. We can configure multiple repositories as follows:</p><div class="informalexample"><pre class="programlisting">repositories {
  mavenCentral()  // shortcut to maven central
  mavenLocal()    // shortcut to maven local (typically ~/.m2)
  jcenter()       // shortcut to jcenter
  maven {
    url "http://repo.company.com/maven"
  }
  ivy {
    url "http://repo.company.com/ivy"
  }
  flatDir {       // jars kept on local file system
    dirs 'libDir'
  }
}</pre></div><p class="calibre8">Repositories such as Maven, Ivy, and flat directory (filesystem) are supported for dependency resolution and uploading artifacts. There are some more specific convenience methods available for commonly used Maven repositories such as <code class="literal">mavenCentral()</code>, <code class="literal">jcenter()</code>, and <code class="literal">mavenLocal()</code>. However, more Maven repos can be easily configured using the following syntax:</p><div class="informalexample"><pre class="programlisting">maven {
  url"http://intranet.example.com/repo"
}</pre></div><p class="calibre8">Before the central repositories, projects used to manage the libraries on filesystem, which were mostly checked in along with the source code. Some projects still do it; although we discourage this, people have their reasons to do so and Gradle has no reason to not support that.</p><p class="calibre8">It is important to remember that Gradle does not automatically assume any repository to search and <a id="id106" class="calibre1"/>download dependencies from. We have to explicitly configure at least one repository in the <code class="literal">repositories</code> block where Gradle <a id="id107" class="calibre1"/>will search for artifacts.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre9">Exercise</strong></span>
</p><p class="calibre8">Include Apache Commons Lang library to convert the message to title case using the following method:</p><div class="informalexample"><pre class="programlisting">WordUtils.capitalize(String str)</pre></div><p class="calibre8">Capitalize all the whitespace-separated words in a string.</p></div></div></div>
<div class="book" title="Summary" id="PNV61-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we first developed a web application using Gradle. We generated the WAR artifact by building the application and then deployed it to a local Tomcat. Then, we learned a few basics about dependency management, configurations, and supported repositories in Gradle.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">The reader should spend some more time reading these concepts in detail at Gradle's official documentation at <a class="calibre1" href="https://docs.gradle.org/current/userguide/userguide">https://docs.gradle.org/current/userguide/userguide</a>
.</p></div><p class="calibre8">For now, we should be good to build the most common type of Java applications with Gradle. In the next chapter, we will try to understand the Groovy DSL that Gradle provides and also understand the basic project model.</p></div></body></html>