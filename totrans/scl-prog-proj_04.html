<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Advanced Features</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to explore the more advanced features of Scala. As with any programming language, some advanced constructs might be seldom used in practice or can obfuscate code.</p>
<p>We will aim to only explain features that we have encountered in real projects that have been deployed to production. Some features are used <span>more</span><span> </span><span>in libraries or in the SDK than in a typical project, but it is important to understand them in order to be able to use a library effectively.</span></p>
<p>As these features are varied and cover a large spectrum, we found it easier to explain them using ad hoc code examples rather than a complete project. You can, therefore, jump directly to any section of this chapter if you are already familiar with some of these concepts.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Strictness and laziness, and their impact on performance</li>
<li>Covariance and contravariance</li>
<li>Currying and partially applied functions</li>
<li>Implicit usage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project setup</h1>
                </header>
            
            <article>
                
<p>All the examples of this chapter have been committed to the following Git repository:</p>
<ul>
<li class="mce-root"><a href="https://github.com/PacktPublishing/Scala-Programming-Projects">https://github.com/PacktPublishing/Scala-Programming-Projects</a></li>
</ul>
<p class="mce-root">If you want to run the code examples in this chapter, you need to clone this repository and import the project into IntelliJ. Each section has a corresponding Scala worksheet file—for instance, the next section's examples are in the <kbd>lazyness.sc</kbd> file.</p>
<p>The solutions to the exercises are given in these worksheets, and so it would be more profitable to you if you do not read them completely until you have tried to do the exercises.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strictness and laziness</h1>
                </header>
            
            <article>
                
<p>Scala's default evaluation strategy is strict. This means that if you don't do anything special, any variable declaration or arguments of a function call are immediately evaluated. The opposite of a strict evaluation strategy is a lazy evaluation strategy, which means that evaluation is performed only when needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strict val</h1>
                </header>
            
            <article>
                
<p>The following is a strict variable declaration:</p>
<pre class="western"><span><span><span><span>class </span>StrictDemo {</span></span></span>
<span>  <span><span><span>val </span></span></span><span><span><span>strictVal </span></span></span><span><span>= {</span></span></span>
<span>    <span><span>println</span></span><span><span>(</span></span><span><span><span>"Evaluating strictVal"</span></span></span><span><span>)</span></span></span>
<span>    <span><span><span>"Hello"</span></span></span></span>
<span>  <span><span>}</span></span></span>
<span><span><span>}</span></span></span>
<span><span><span><span>val </span>strictDemo = <span>new </span>StrictDemo</span></span></span>
<span><span><span>//Evaluating strictVal</span></span></span>
<span><span><span>//strictDemo: StrictDemo = StrictDemo@32fac009</span></span></span></pre>
<p>We can see that <kbd>println</kbd> is called immediately. This means that the block at the right side of the assignment is evaluated as soon as the <kbd>StrictDemo</kbd> class is instantiated. If we want to delay the block's evaluation, we have to use the <kbd>lazy </kbd><span>prefix</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">lazy val</h1>
                </header>
            
            <article>
                
<p>When we use the <kbd>lazy</kbd> <span>prefix</span><span> </span><span>in front of </span><kbd>val</kbd> <span>or</span> <kbd>var</kbd><span> (as shown in the following code), it is evaluated only when needed:</span></p>
<pre class="western"><span><span><span><span>class </span>LazyDemo {</span></span></span>
<span>  <span><span><span>lazy val </span></span></span><span><span><span>lazyVal </span></span></span><span><span>= {</span></span></span>
<span>    <span><span>println</span></span><span><span>(</span></span><span><span><span>"Evaluating lazyVal"</span></span></span><span><span>)</span></span></span>
<span>    <span><span><span>"Hello"</span></span></span></span>
<span>  <span><span>}</span></span></span>
<span><span><span>}</span></span></span>
<span><span><span><span>val </span>lazyDemo = <span>new </span>LazyDemo</span></span></span>
<span><span><span>//lazyDemo: LazyDemo = LazyDemo@13ca84d5</span></span></span></pre>
<p>When we instantiate the class, the block at the right side of the assignment is not evaluated. It will only get evaluated when we use the variable, as shown in the following code:</p>
<pre class="western"><span><span><span>lazyDemo.<span>lazyVal </span>+ <span>" World"</span></span></span></span>
<span><span><span>//Evaluating lazyVal</span></span></span>
<span><span><span>//res0: String = Hello World</span></span></span></pre>
<p>This mechanism allows you to defer the evaluation of computationally expensive operations. For instance, you could use it to start an application quickly and run the initialization code only when the first user needs it. Scala guarantees that the evaluation will be performed only once, even if there are multiple threads trying to use the variable at the same time.</p>
<p>You can have chains of <kbd>lazy</kbd> values, which will get evaluated only when the last element of the chain is required, as shown in the following code:</p>
<pre class="western"><span><span><span><span>class </span>LazyChain {</span></span></span>
<span>  <span><span><span>lazy val </span></span></span><span><span><span>val1 </span></span></span><span><span>= {</span></span></span>
<span>    <span><span>println</span></span><span><span>(</span></span><span><span><span>"Evaluating val1"</span></span></span><span><span>)</span></span></span>
<span>    <span><span><span>"Hello"</span></span></span></span>
<span>  <span><span>}</span></span></span>
<span>  <span><span><span>lazy val </span></span></span><span><span><span>val2 </span></span></span><span><span>= {</span></span></span>
<span>    <span><span>println</span></span><span><span>(</span></span><span><span><span>"Evaluating val2"</span></span></span><span><span>)</span></span></span>
<span>    <span><span><span>val1 </span></span></span><span><span>+ </span></span><span><span><span>" lazy"</span></span></span></span>
<span>  <span><span>}  </span></span></span>
<span>  <span><span><span>lazy val </span></span></span><span><span><span>val3 </span></span></span><span><span>= {</span></span></span>
<span>    <span><span>println</span></span><span><span>(</span></span><span><span><span>"Evaluating val3"</span></span></span><span><span>)</span></span></span>
<span>    <span><span><span>val2 </span></span></span><span><span>+ </span></span><span><span><span>" chain"</span></span></span></span>
<span>  <span><span>}</span></span></span>
<span><span><span>}</span></span></span>
<span><span><span><span>val </span>lazyChain = <span>new </span>LazyChain</span></span></span>
<span><span><span>// lazyChain: LazyChain = LazyChain@4ca51fa</span></span></span></pre>
<p>When we require <kbd>val3</kbd>, the three values get evaluated, as shown in the following code:</p>
<pre class="western"><span><span><span>lazyChain.<span>val3</span></span></span></span>
<span><span><span>// Evaluating val3</span></span></span>
<span><span><span>// Evaluating val2</span></span></span>
<span><span><span>// Evaluating val1</span></span></span>
<span><span><span>// res1: String = Hello lazy chain</span></span></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">By-name parameters</h1>
                </header>
            
            <article>
                
<p>We can go a bit further and delay the evaluation of function arguments. A by-name parameter is like a function that does not take any argument. This way, it only <span>gets</span><span> </span><span>evaluated when the function's body requires it.</span></p>
<p>Say that you have an application that loads its configuration from a file or a database. You want the application to start as fast as possible, and so you decide to use <kbd>lazy val</kbd> to load a greeting message on demand, as shown in the following code:</p>
<pre class="western"><span><span><span><span>object </span>AppConfig {</span></span></span>
<span>  <span><span><span>lazy val </span></span></span><span><span><span>greeting</span></span></span><span><span>: </span></span><span><span><span>String </span></span></span><span><span>= {</span></span></span>
<span>    <span><span>println</span></span><span><span>(</span></span><span><span><span>"Loading greeting"</span></span></span><span><span>)</span></span></span>
<span>    <span><span><span>"Hello "</span></span></span></span>
<span>  <span><span>}</span></span></span>
<span><span><span>}</span></span></span></pre>
<p>Note that for the sake of brevity we haven't actually loaded anything here—just imagine that we did.</p>
<p>If we then want to use the greeting variable in a function but keep delaying its evaluation, we can use a by-name parameter:</p>
<pre class="western"><span><span><span><span>def </span>greet(name: <span>String</span>, greeting: =&gt; <span>String</span>): <span>String </span>= {</span></span></span>
<span>  <span><span><span>if </span></span></span><span><span>(name == </span></span><span><span><span>"Mikael"</span></span></span><span><span>)</span></span></span>
<span>    <span><span>greeting + name</span></span></span>
<span>  <span><span><span>else</span></span></span></span>
<span>    <span><span><span>s"I don't know you </span></span></span><span><span><span>$</span></span></span><span><span>name</span></span><span><span><span>"</span></span></span></span>
<span><span><span>}</span></span></span>
<span><span><span>greet(<span>"Bob"</span>, AppConfig.<span>greeting</span>)</span></span></span>
<span><span><span>// res2: String = I don't know you Bob</span></span></span>
<span><span><span>greet(<span>"Mikael"</span>, AppConfig.<span>greeting</span>)</span></span></span>
<span><span><span>// Loading greeting</span></span></span>
<span><span><span>// res3: String = Hello Mikael</span></span></span></pre>
<p>The <kbd>AppConfig.greeting</kbd> phrase is not evaluated the first time we call <kbd>greet</kbd> with <kbd>"Bob"</kbd>, because the body of the function did not require it. It is only evaluated when we call <kbd>greet</kbd> with <kbd>"Mikael"</kbd>.</p>
<p>In some cases, using by-name parameters can enhance the performance of a program, because the evaluation of an expensive operation can be skipped if it is not required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lazy data structures</h1>
                </header>
            
            <article>
                
<p>Here is a function definition that calls the strict methods of <kbd>Vector</kbd>:</p>
<pre><span>def </span>evenPlusOne(xs: <span>Vector</span>[Int]): <span>Vector</span>[Int] =<br/>  xs.filter { x =&gt; <span>println</span>(<span>s"filter </span><span>$</span>x<span>"</span>); x % <span>2 </span>== <span>0 </span>}<br/>    .map    { x =&gt; <span>println</span>(<span>s"map </span><span>$</span>x<span>"</span>);    x + <span>1      </span>}<br/><br/>evenPlusOne(<span>Vector</span>(<span>0</span>, <span>1</span>, <span>2</span>))</pre>
<p>It prints the following on the console:</p>
<pre class="western">filter 0<br/>filter 1<br/>filter 2<br/>map 0<br/>map 2<br/>res4: Vector[Int] = Vector(1, 3)</pre>
<p>We can see that <kbd>Vector</kbd> is iterated twice: once for <kbd>filter</kbd>, and once for <kbd>map</kbd>. But our <kbd>evenPlusOne</kbd> <span>function</span><span> </span><span>would be faster if it could iterate only once. One way to do this would be to change the implementation and use</span> <kbd>collect</kbd><span>. Another way would be to use the non-strict</span> <kbd>withFilter</kbd> <span>method, as shown in the following code:</span></p>
<pre><span>def </span>lazyEvenPlusOne(xs: <span>Vector</span>[Int]): <span>Vector</span>[Int] =<br/>  xs.<strong>withFilter</strong> { x =&gt; <span>println</span>(<span>s"filter </span><span>$</span>x<span>"</span>); x % <span>2 </span>== <span>0 </span>}<br/>    .map        { x =&gt; <span>println</span>(<span>s"map </span><span>$</span>x<span>"</span>)   ; x + <span>1      </span>}<br/><br/>lazyEvenPlusOne(<span>Vector</span>(<span>0</span>, <span>1</span>, <span>2</span>))</pre>
<p>The <kbd>withFilter</kbd> method prints the following:</p>
<pre>filter 0<br/>map 0<br/>filter 1<br/>filter 2<br/>map 2<br/>res5: Vector[Int] = Vector(1, 3)</pre>
<p>This time, <kbd>Vector</kbd> is iterated only once. Each element is filtered and then mapped one by one. This is because <kbd>withFilter</kbd> is a lazy operation—it does not immediately create a new filtered <kbd>Vector</kbd>, but instead creates a new <kbd>withFilter</kbd> <span>object</span><span> </span><span>that will store the filter's predicate. This SDK collection</span> <kbd>withFilter </kbd><span>type</span><span> </span><span>has a special implementation of</span> <kbd>map</kbd> <span>that will call the filter's predicate before calling the function passed to</span> <kbd>map</kbd><span>.</span></p>
<p>This works pretty well as long as you only have one <kbd>map</kbd> or <kbd>flatMap</kbd> operation, or if you further refine your <kbd>filter</kbd> with another call to <kbd>withFilter</kbd>. However, if you call another <kbd>map</kbd> operation, the collection will be iterated twice, as shown in the following code:</p>
<pre><span>def </span>lazyEvenPlusTwo(xs: <span>Vector</span>[Int]): <span>Vector</span>[Int] =<br/>  xs.withFilter { x =&gt; <span>println</span>(<span>s"filter </span><span>$</span>x<span>"</span>); x % <span>2 </span>== <span>0 </span>}<br/>    .map        { x =&gt; <span>println</span>(<span>s"map </span><span>$</span>x<span>"</span>)   ; x + <span>1      </span>}<br/>    .map        { x =&gt; <span>println</span>(<span>s"map2 </span><span>$</span>x<span>"</span>)  ; x + <span>1      </span>}<br/><br/>lazyEvenPlusTwo(Vector(0, 1, 2))</pre>
<p>The preceding code prints the following:</p>
<pre>filter 0<br/>map 0<br/>filter 1<br/>filter 2<br/>map 2<br/>map2 1<br/>map2 3<br/>res6: Vector[Int] = Vector(2, 4)</pre>
<p>We can see that the calls to <kbd>map2</kbd> are made at the end, which means that we iterated a second time over <kbd>Vector(1, 3)</kbd>. We need a lazier data structure that will not iterate until we actually need each element.</p>
<p>In the Scala SDK, this collection type is <kbd>Stream</kbd>. If we replace <kbd>Vector</kbd> with <kbd>Stream</kbd> in our <kbd>lazyEvenPlusTwo</kbd><span> function</span><span>, then we get the desired behavior, as shown in the following code:</span></p>
<pre><span>def </span>lazyEvenPlusTwoStream(xs: <span>Stream</span>[Int]): <span>Stream</span>[Int] =<br/>  xs.filter { x =&gt; <span>println</span>(<span>s"filter </span><span>$</span>x<span>"</span>)    ; x % <span>2 </span>== <span>0 </span>}<br/>    .map        { x =&gt; <span>println</span>(<span>s"map </span><span>$</span>x<span>"</span>)   ; x + <span>1      </span>}<br/>    .map        { x =&gt; <span>println</span>(<span>s"map2 </span><span>$</span>x<span>"</span>)  ; x + <span>1      </span>}<br/><br/>lazyEvenPlusTwoStream(<span>Stream</span>(<span>0</span>, <span>1</span>, <span>2</span>)).toVector</pre>
<p>After the call to our function, we convert the resulting <kbd>Stream</kbd> to <kbd>Vector</kbd>. It is this call to <kbd>toVector</kbd> that materializes the elements of the stream and calls the anonymous functions passed to <kbd>filter</kbd> and <kbd>map</kbd>. The following code is what gets printed on the console:</p>
<pre>filter 0<br/>map 0<br/>map2 1<br/>filter 1<br/>filter 2<br/>map 2<br/>map2 3<br/>res7: Vector[Int] = Vector(2, 4)</pre>
<p>We can see that <kbd>Stream</kbd> is iterated only once. For each element, we call <kbd>filter</kbd>, then <kbd>map</kbd> and <kbd>map2</kbd>.</p>
<p>But there is more to it. Since <kbd>Stream</kbd> is lazy, it can be used to represent infinite collections. The following code shows how we can get a <kbd>Stream</kbd> of all the positive even integers:</p>
<pre><span>val </span>evenInts: <span>Stream</span>[Int] = <span>0 </span>#:: <span>2 </span>#:: evenInts.tail.map(_ + <span>2</span>)<br/>evenInts.take(<span>10</span>).toVector<br/><span>// res8: Vector[Int] = Vector(0, 2, 4, 6, 8, 10, 12, 14, 16, 18)<br/></span></pre>
<p>We use the <kbd>Stream</kbd> operator <kbd>#::</kbd>, which builds <kbd>Stream</kbd> with a head element and a tail. It works the same way as the <kbd>List</kbd> operator <kbd>::</kbd>, but in a lazy way. The following steps show how it works: </p>
<ol>
<li>We build <kbd>Stream 0 #:: 2</kbd>, which has <kbd>0</kbd> as its head and a tail with one element, <kbd>2</kbd>.</li>
<li>The third element will be <kbd>(0 #:: 2).tail.map(_ + 2)</kbd>. At this stage, the tail is only <kbd>Stream(2)</kbd>, and so the third element will be <kbd>4</kbd>.</li>
<li>The fourth element will be <kbd>(0 #:: 2 #:: 4).tail.map(_ + 2)</kbd>. The same process repeats for all subsequent elements.</li>
</ol>
<p>Since our <kbd>Stream</kbd> is infinite, we cannot convert all of it to <kbd>Vector</kbd>, as this would go on forever. We just take the first 10 elements with <kbd>take(10)</kbd> and then convert them to <kbd>Vector</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Covariance and contravariance</h1>
                </header>
            
            <article>
                
<p>When an <kbd>F</kbd><span> type </span><span>accepts a type parameter of </span><kbd>A</kbd><span>, we can add a</span> <kbd>+</kbd> <span>or</span> <kbd>-</kbd> <span>sign in front of the parameter declaration to indicate the</span> <strong>variance</strong> <span>of</span> <kbd>F</kbd> on <kbd>A</kbd><span>:</span></p>
<ul>
<li><kbd>F[+A]</kbd> makes <kbd>F</kbd> <strong>covariant</strong> on <kbd>A</kbd>. This means that if <kbd>B &lt;:&lt; A</kbd> (where <kbd>B</kbd> extends <kbd>A</kbd>), then <kbd>F[B] &lt;:&lt; F[A]</kbd>.</li>
<li><kbd>F[-A]</kbd> makes <kbd>F</kbd> <strong>contravariant</strong> on <kbd>A</kbd>. If <kbd>B &lt;:&lt; A</kbd>, then <kbd>F[A]  &lt;:&lt; F[B]</kbd>.</li>
<li><kbd>F[A]</kbd> makes <kbd>F</kbd> <strong>invariant</strong> on <kbd>A</kbd>. If <kbd>B &lt;:&lt; A</kbd>, then there is no relationship between <kbd>F[A]</kbd> and <kbd>F[B]</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">InvariantDecoder</h1>
                </header>
            
            <article>
                
<p>We are now going to explore this variance concept with an example. Let's start with a simple class hierarchy, as shown in the following code:</p>
<pre><span>trait </span>Animal<br/><span>case class </span>Cat(name: <span>String</span>) <span>extends </span>Animal<br/><span>case class </span>Dog(name: <span>String</span>) <span>extends </span>Animal</pre>
<p>With this hierarchy, I can declare a variable of an <kbd>Animal</kbd> <span>type</span><span> </span><span>and assign it to an instance of a</span> <kbd>Cat</kbd> <span>or</span> <kbd>Dog</kbd><span> type</span><span>. The following code will compile:</span></p>
<pre><span>val </span>animal1: Animal = <span>Cat</span>(<span>"Max"</span>)<br/><span>val </span>animal2: Animal = <span>Dog</span>(<span>"Dolly"</span>)<br/><span>implicitly</span>[Dog &lt;:&lt; Animal]</pre>
<p>More generally, the assignment <kbd>val a: A = b: B</kbd> compiles if <kbd>B &lt;:&lt; A</kbd>.</p>
<div class="packt_tip">You can check that type <kbd>B</kbd> extends type <kbd>A</kbd> with the expression <kbd>implicitly[B &lt;:&lt; A]</kbd>; if it compiles, then <kbd>B</kbd> is a subtype of <kbd>A</kbd>.</div>
<p>Then, we define an <kbd>InvariantDecoder</kbd> trait that has a single <kbd>decode</kbd> method. There is no <kbd>+</kbd> or <kbd>-</kbd> sign, and so <kbd>InvariantDecoder</kbd> is invariant on <kbd>A</kbd>, as shown in the following code:</p>
<pre><span>trait </span>InvariantDecoder[<span>A</span>] {<br/>  <span>def </span>decode(s: <span>String</span>): Option[<span>A</span>]<br/>}</pre>
<p>After this, we implement <kbd>InvariantDecoder</kbd> for <kbd>Cat</kbd>, as shown in the following code:</p>
<pre><span>object </span>InvariantCatDecoder <span>extends </span>InvariantDecoder[Cat] {<br/>  <span>val </span><span>CatRegex </span>= <span>"""Cat\((\w+\))"""</span>.r<br/>  <span>def </span>decode(s: <span>String</span>): Option[Cat] = s <span>match </span>{<br/>    <span>case </span>CatRegex(name) =&gt; <span>Some</span>(<span>Cat</span>(name))<br/>    <span>case </span>_ =&gt; None<br/>  }<br/>}<br/><br/>InvariantCatDecoder.<span>decode</span>(<span>"Cat(Max)"</span>)<br/><span>// res0: Option[Cat] = Some(Cat(Max)))</span></pre>
<p>When we call <kbd>decode</kbd> with a string that matches the <kbd>CatRegex</kbd> regular expression, we obtain a <kbd>Cat</kbd> instance wrapped in an <kbd>Option</kbd> instance.</p>
<p>But what if we declare a variable of the <kbd>InvariantDecoder[Animal] </kbd><span>type?</span><span> Can we assign our</span> <kbd>InvariantCatDecoder</kbd> <span>to it? Let's try it:</span></p>
<pre><span>val </span>invariantAnimalDecoder: InvariantDecoder[Animal] = InvariantCatDecoder</pre>
<p>The preceding code does not compile, but the compiler is very helpful in this case. The following code is the error you will get:</p>
<pre>error: type mismatch;<br/>  found   : InvariantCatDecoder.type<br/>  required: InvariantDecoder[Animal]<br/>     Note: Cat &lt;: Animal (and InvariantCatDecoder.type &lt;: <br/>     InvariantDecoder[Cat]), but trait InvariantDecoder is invariant in     <br/>     type A.<br/>     You may wish to define A as +A instead. (SLS 4.5)<br/>        val invariantAnimalDecoder: InvariantDecoder[Animal] = <br/>        InvariantCatDecoder<br/>                                                               ^</pre>
<p>It tells us that if we want to make this line compile, we have to make <kbd>InvariantDecoder</kbd> covariant in type <kbd>A</kbd>. To do so, we have to add a <kbd>+</kbd> sign in front of the <kbd>A</kbd> <span>parameter</span><span> </span><span>in</span> <kbd>InvariantDecoder</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CovariantDecoder</h1>
                </header>
            
            <article>
                
<p>Let's follow the compiler's advice and create a new <kbd>CovariantDecoder[+A]</kbd>, along with a <kbd>CovariantCatDecoder</kbd><span> instance</span><span> </span><span>that extends it, as shown in the following code:</span></p>
<pre><span>trait </span>CovariantDecoder[<span>+A</span>] {<br/>  <span>def </span>decode(s: <span>String</span>): Option[<span>A</span>]<br/>}<br/><span>object </span>CovariantCatDecoder <span>extends </span>CovariantDecoder[Cat] {<br/> (...)<br/>}</pre>
<p>We do not show the implementation of <kbd>decode</kbd> in <kbd>CovariantCatDecoder</kbd>; it is the same as in <kbd>InvariantCatDecoder</kbd>. With this covariant parameter, the following relationship is verified:</p>
<pre><span>implicitly</span>[CovariantDecoder[Cat] &lt;:&lt; CovariantDecoder[Animal]]</pre>
<p>This time, we can assign the <kbd>CovariantCatDecoder</kbd> to an instance of <kbd>CovariantDecoder[Animal]</kbd>, as shown in the following code:</p>
<pre><span>val </span>covariantAnimalDecoder: CovariantDecoder[Animal] = CovariantCatDecoder<br/>covariantAnimalDecoder.decode(<span>"Cat(Ulysse)"</span>)<br/><span>// res0: Option[Animal] = Some(Cat(Ulysse)))</span></pre>
<p>When we call <kbd>decode</kbd> on it, we get back an <kbd>Option[Animal]</kbd>.</p>
<p>At first, glance, having <kbd>CovariantDecoder</kbd> seems natural—if my decoder can produce <kbd>Cat</kbd>, and <kbd>Cat</kbd> is an <kbd>Animal</kbd>, my decoder should also be a decoder of <kbd>Animal</kbd>. On the other hand, if I have an instance of <kbd>Decoder[Animal]</kbd>, I would expect it to be able to decode any <kbd>Animal</kbd>—not only <kbd>Cat</kbd>, but also <kbd>Dog</kbd> instances—and this is not the case for our earlier <kbd>covariantAnimalDecoder</kbd>.</p>
<p>There is no right or wrong design here; this is just a matter of taste. In general, I would advise you to use invariant type parameters first, and if you then experience some limitations with it, you can decide to make them covariant or contravariant.</p>
<p>The full covariant implementation for getting <kbd>Cat</kbd> and <kbd>Dog</kbd> would be the following:</p>
<pre><span>object </span>CovariantCatAndDogDecoder <span>extends </span>CovariantDecoder[Animal] {<br/>  <span>val </span><span>CatRegex </span>= <span>"""Cat\((\w+\))"""</span>.r<br/>  <span>val </span><span>DogRegex </span>= <span>"""Dog\((\w+\))"""</span>.r<br/>  <span>def </span><span>decode</span>(s: <span>String</span>): Option[Animal] = s <span>match </span>{<br/>    <span>case </span>CatRegex(name) =&gt; <span>Some</span>(<span>Cat</span>(name))<br/>    <span>case </span>DogRegex(name) =&gt; <span>Some</span>(<span>Dog</span>(name))<br/>    <span>case </span>_ =&gt; None<br/>  }<br/>}<br/><br/><span>val </span>covariantCatsAndDogsDecoder = CovariantCatAndDogDecoder<br/><br/>covariantCatsAndDogsDecoder.<span>decode</span>(<span>"Cat(Garfield)"</span>)<br/>// res4: Option[Animal] = Some(Cat(Garfield)))<br/>covariantCatsAndDogsDecoder.<span>decode</span>(<span>"Dog(Aiko)"</span>)<br/>// res5: Option[Animal] = Some(Dog(Aiko)))</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Contravariant encoder</h1>
                </header>
            
            <article>
                
<p>Now, we would like to model the opposite of decoding a string to an object—encoding an object to a string! We make our <kbd>Encoder</kbd> contravariant by adding a <kbd>-</kbd> sign in front of the <kbd>A</kbd><span> type parameter, as shown in the following code</span><span>:</span></p>
<pre><span>trait </span>Encoder[<span>-A</span>] {<br/>  <span>def </span>encode(a: <span>A</span>): <span>String<br/></span>}</pre>
<p>The following code is an instance of this <kbd>Encoder</kbd>:</p>
<pre><span>object </span>AnimalEncoder <span>extends </span>Encoder[Animal] {<br/>  <span>def </span>encode(a: Animal): <span>String </span>= a.toString<br/>}</pre>
<p>We have the <kbd>Cat &lt;:&lt; Animal </kbd><span>relationship</span><span>, and</span> <kbd>Encoder</kbd> <span>is contravariant on its argument. This implies that</span> <kbd>Encoder[Animal] &lt;:&lt; Encoder[Cat]</kbd><span>, and I can, therefore, assign </span><kbd>Encoder[Animal]</kbd> <span>to a variable of type</span> <kbd>Encoder[Cat]</kbd>, as shown in the following code:</p>
<pre><span>val </span>catEncoder: Encoder[Cat] = AnimalEncoder<br/>catEncoder.encode(<span>Cat</span>(<span>"Luna"</span>))<br/><span>// res1: String = Cat(Luna)</span></pre>
<p>Similar to the covariant decoder, the contravariance of the encoder seems natural—if I can encode any <kbd>Animal</kbd>, I can also encode <kbd>Cat</kbd>.</p>
<p>However, if we wanted to create a single <kbd>Codec</kbd> <span>trait</span><span> </span><span>that can encode and decode, we would be in trouble. The type parameter cannot be covariant and contravariant at the same time.</span></p>
<p>The only way to make it work would be to make the type parameter invariant, as in the following implementation:</p>
<pre><span>object </span>CatAndDogCodec <span>extends </span>Codec[Animal] {<br/>  <span>val </span><span>CatRegex </span>= <span>"""Cat\((\w+\))"""</span>.r<br/>  <span>val </span><span>DogRegex </span>= <span>"""Dog\((\w+\))"""</span>.r<br/><br/>  <span>override def </span><span>encode</span>(a: Animal) = a.toString<br/><br/>  <span>override def </span><span>decode</span>(s: <span>String</span>): Option[Animal] = s <span>match </span>{<br/>    <span>case </span>CatRegex(name) =&gt; <span>Some</span>(<span>Cat</span>(name))<br/>    <span>case </span>DogRegex(name) =&gt; <span>Some</span>(<span>Dog</span>(name))<br/>    <span>case </span>_ =&gt; None<br/>  }<br/>}</pre>
<p>But let's see what happens if we attempt to use a covariance. The compiler would return the following error:</p>
<pre><span>trait Codec[+A] {<br/></span><span>  def encode(a: A): String<br/></span><span>  def decode(s: String): Option[A]<br/></span><span>}<br/></span><span> Error:(55, 15) covariant type A occurs in contravariant position in <br/>    type A of value a<br/></span><span>    def encode(a: A): String<br/></span><span>     ^</span></pre>
<p>The compiler complains about the <kbd>A</kbd> <span>type</span><span> </span><span>being in a contravariant position. This is because in functions, the parameters are always in a contravariant position, and the result is always in a covariant position. For instance, if you open</span> <kbd>scala.Function3</kbd><span>, you will see the following declaration:</span></p>
<pre><span>trait </span>Function3[<span>-T1</span>, <span>-T2</span>, <span>-T3</span>, <span>+R</span>] <span>extends </span>AnyRef { self =&gt;</pre>
<p>This implies the following two things:</p>
<ul>
<li>If you declare a type parameter as covariant with <kbd>+A</kbd>, then the <kbd>A </kbd>type can only appear in the <strong>result</strong> of a method</li>
<li>If you declare a type parameter as contravariant with <kbd>-A</kbd>, then the <kbd>A</kbd> type can only appear in the <strong>parameters</strong> of a method</li>
</ul>
<p>In our <kbd>decode</kbd> method, <kbd>A</kbd> appears in the result and hence is in a covariant position. This is why we could make the decoder covariant on A by using <kbd>+A</kbd> in <kbd>CovariantDecoder</kbd>.</p>
<p>Conversely, in our <kbd>encode</kbd> method, <kbd>A</kbd> appears in the parameters, and hence it is in a contravariant position. This is why we could make the encoder contravariant on <kbd>A</kbd> by using <kbd>-A</kbd> in <kbd>Encoder</kbd>.</p>
<p>Another way to implement our <kbd>Codec</kbd> would be to use a type class. This is explained in <a href="d2e776f6-4446-4cb8-ba6d-f474cde4ff6f.xhtml" target="_blank">Chapter 5</a>, <em>Type Classes</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Covariance in collections</h1>
                </header>
            
            <article>
                
<p>Most collection types in the SDK are covariant. For instance, if you open the <kbd>Vector</kbd> class, you will see the following:</p>
<pre><span>final class </span>Vector[<span>+A</span>] (...)</pre>
<p>This allows us to assign <kbd>Vector[B]</kbd> to a variable of <kbd>Vector[A] if B &lt;:&lt;A </kbd><span>type, as shown in the following code</span><span>:</span></p>
<pre><span>val </span>cats: <span>Vector</span>[Cat] = <span>Vector</span>(<span>Cat</span>(<span>"Max"</span>))<br/><span>val </span>animals: <span>Vector</span>[Animal] = cats</pre>
<p>Now here is a bit of magic:</p>
<pre><span>val </span>catsAndDogs = cats :+ <span>Dog</span>(<span>"Medor"</span>)<br/><span>// catsAndDogs: Vector[Product with Serializable with Animal] = <br/>// Vector(Cat(Max), Dog(Medor))</span></pre>
<p>Scala not only allows us to add <kbd>Dog</kbd> to <kbd>Vector[Cat]</kbd>, but it also automatically infers the new collection to be of a <kbd>Vector[Product with Serializable with Animal] </kbd><span>type</span><span>.</span></p>
<p>We saw earlier that the parameters of a function are in contravariant position. Therefore, it should not even be possible to have a <kbd>:+(a: A)</kbd><span>method</span><span> </span><span>that can add elements to the</span> <kbd>Vector</kbd> <span>class, because</span> <kbd>Vector</kbd> <span>is covariant on</span> <kbd>A</kbd><span>! But there is a trick. If you look in the Vector source code at the definition of</span> <kbd>:+</kbd><span>, the following code is what you will see:</span></p>
<pre><span>override def </span>:+[<span>B </span>&gt;: <span>A</span>, <span>That</span>](elem: <span>B</span>)(<span>implicit </span>bf: CanBuildFrom[Vector[<span>A</span>], <span>B</span>, <span>That</span>]): <span>That</span></pre>
<p>The method takes a <kbd>B </kbd><span>type parameter </span><span>with the constraint that</span> <kbd>B</kbd> <span>must be a supertype of</span> <kbd>A</kbd><span>. In our previous example, the</span> <kbd>A </kbd><span>type</span><span> </span><span>was</span> <kbd>Cat</kbd> <span>and our</span> <kbd>elem</kbd><span> </span><span>argument</span><span> </span><span>was of the</span> <kbd>Dog </kbd><span>type</span><span>. The Scala compiler automatically inferred the</span> <kbd>B</kbd><span> </span><span>type</span><span> </span><span>to be the closest common supertype of</span> <kbd>Dog</kbd> <span>and</span> <kbd>Cat</kbd><span>, which is </span><kbd>Product with Serializable with Animal</kbd><span>.</span></p>
<p>If we add <kbd>String</kbd> to this <kbd>Vector</kbd>, the resulting type will be the next common supertype between <kbd>Animal</kbd> and <kbd>String</kbd>, which is <kbd>Serializable</kbd>, as shown in the following code:</p>
<pre><span>val </span>serializables = catsAndDogs :+ <span>"string"<br/></span><span>// serializables: Vector[Serializable] = Vector(Cat(Max), Dog(Medor), <br/>// string)<br/></span><span>val </span>anys = serializables :+ <span>1<br/></span><span>// anys: Vector[Any] = Vector(Cat(Max), Dog(Medor), string, 1)</span></pre>
<p>Then, when we add an <kbd>Int</kbd> to the <kbd>Vector</kbd> class, the next common supertype between <kbd>Serializable</kbd> and <kbd>Int</kbd> is <kbd>Any</kbd>.</p>
<div class="packt_tip">If you have a class that has a covariant <kbd>MyClass[+A]</kbd> <span>type parameter</span><span>, and you need to implement a method with a parameter of an </span><kbd>A</kbd><span> type</span><span>, then you can define it with a</span> <kbd>B &gt;: A </kbd><span>type parameter</span><span>, written as</span> <kbd>def myMethod[B &gt;: A](b: B) = ...</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Currying and partially applied functions</h1>
                </header>
            
            <article>
                
<p>The name <em>currying</em> is a reference to the mathematician and logician Haskell Curry. The process of currying consists of transforming a function that takes multiple arguments into a sequence of functions, each with a single argument.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function value</h1>
                </header>
            
            <article>
                
<p>Before we start currying functions, we need to understand the difference between a function and a function value.</p>
<p>You are already familiar with functions—they begin with the keyword <kbd>def</kbd>, take one or several parameter lists between <kbd>()</kbd> symbols, optionally declare a return type after a <kbd>:</kbd> sign, and have a defined body after the <kbd>=</kbd> sign, as shown in the following example:</p>
<pre><span>def </span>multiply(x: Int, y: Int): Int = x * y<br/><span>// multiply: multiply[](val x: Int,val y: Int) =&gt; Int</span></pre>
<p>A function value (also called a <strong>function literal</strong>) is similar to any other value, such as <kbd>"hello": String</kbd>, <kbd>3: Int</kbd>, or <kbd>true: Boolean</kbd>. As with other values, you can pass a function value as an argument to a function, or assign it to a variable using the <kbd>val</kbd> keyword.</p>
<p>You can declare function values directly, as shown in the following code:</p>
<pre><span>val </span>multiplyVal = (x: Int, y: Int) =&gt; x * y<br/><span>// multiplyVal: (Int, Int) =&gt; Int = ...</span></pre>
<p>Or you can transform a function into a function value by adding a <kbd>_</kbd> character at the end of the function's name, as shown in the following code:</p>
<pre><span>val </span>multiplyVal2 = multiply _<br/><span>// multiplyVal2: (Int, Int) =&gt; Int = ...<br/></span></pre>
<p>When it comes to applying arguments to a function, the syntax is the same whether we call a function or a function value, as shown in the following code:</p>
<pre>multiply(<span>2</span>, <span>3</span>)<br/>multiplyVal(<span>2</span>, <span>3</span>)<br/>multiplyVal2(<span>2</span>, <span>3</span>)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Currying</h1>
                </header>
            
            <article>
                
<p>A curried function is a function that takes one parameter and returns another function that takes one parameter. You can convert a function value into a curried function value by calling the <kbd>.curried </kbd><span>method, as shown in the following code</span><span>:</span></p>
<pre><span>val </span>multiplyCurried = multiplyVal.curried<br/><span>// multiplyCurried: Int =&gt; (Int =&gt; Int) = ...</span></pre>
<p>The call to <kbd>.curried</kbd> transforms the function value's type from <kbd>(Int, Int) =&gt; Int</kbd> to <kbd>Int =&gt; (Int =&gt; Int)</kbd>. <span>The</span><span> </span><kbd>multiplyVal</kbd><span> takes</span> two integers as parameters and returns an integer<span>. </span>The <kbd>multiplyCurried</kbd><span> takes one</span> <kbd>Int</kbd> <span>and returns a function that takes</span> <kbd>Int</kbd> <span>and returns</span> <kbd>Int</kbd><span>. The two function values have exactly the same functionality—the difference lies in the way we call them, as shown in the following code:</span></p>
<pre>multiplyVal(<span>2</span>, <span>3</span>)<br/><span>// res3: Int = 6<br/></span>multiplyCurried(<span>2</span>)<br/><span>// res4: Int =&gt; Int = ...<br/></span>multiplyCurried(<span>2</span>)(<span>3</span>)<br/><span>// res5: Int = 6</span></pre>
<p>When we call <kbd>multiplyCurried(2)</kbd>, we apply only the first argument, and this returns a <kbd>Int =&gt; Int</kbd><span> function</span><span>. At this stage, the function is not completely applied—it is a</span> <strong>partially applied</strong> <span>function. If we want to obtain the final result, we have to apply the second argument by calling</span> <kbd>multiplyCurried(2)(3)</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Partially applied functions</h1>
                </header>
            
            <article>
                
<p>In practice, there is no need to call <kbd>.curried</kbd> to define curried functions. You can declare curried functions directly with multiple parameter lists. Here is a curried function that calculates a discount to an <kbd>Item</kbd> class:</p>
<pre><span>case class </span>Item(description: <span>String</span>, price: Double)<br/><br/><span>def </span>discount(percentage: Double)(item: Item): Item =<br/>  item.copy(price = item.price * (<span>1 </span>- percentage / <span>100</span>))</pre>
<p>We can <strong>fully apply</strong> the function if we provide two argument lists, as follows:</p>
<pre>discount(<span>10</span>)(<span>Item</span>(<span>"Monitor"</span>, <span>500</span>))<br/><span>// res6: Item = Item(Monitor,450.0)</span></pre>
<p>But we can also partially apply the function if we just provide the first argument list and add a <kbd>_</kbd> character to indicate that we want a function value, as shown in the following code:</p>
<pre><span>val </span>discount10 = discount(<span>10</span>) _<br/><span>// discount10: Item =&gt; Item = ...<br/></span>discount10(<span>Item</span>(<span>"Monitor"</span>, <span>500</span>))<br/><span>// res7: Item = Item(Monitor,450.0)</span></pre>
<p>The <kbd>discount10</kbd> <span>function value </span><span>is a partially applied function that takes</span> <kbd>Item</kbd> <span>and returns</span> <kbd>Item</kbd><span>. We can then call it with an </span><kbd>Item</kbd> <span>instance to fully apply it.</span></p>
<p>A partially applied function is especially useful when we need to pass anonymous functions to higher order functions (functions that accept functions as arguments), such as <kbd>map</kbd> or <kbd>filter</kbd>, as shown in the following code:</p>
<pre><span>val </span>items = <span>Vector</span>(<span>Item</span>(<span>"Monitor"</span>, <span>500</span>), <span>Item</span>(<span>"Laptop"</span>, <span>700</span>))<br/>items.map(discount(<span>10</span>))<br/><span>// res8: Vector[Item] = Vector(Item(Monitor,450.0), Item(Laptop,630.0))<br/></span></pre>
<p>In this example, the <kbd>map</kbd> function expects an argument of a <kbd>Item =&gt; B</kbd><span> type</span><span>. We pass the</span> <kbd>discount(10)</kbd><span>argument</span><span>, which is a partially applied function of a</span> <kbd>Item =&gt; Item</kbd><span> type.</span><span> Thanks to partially applied functions, we managed to apply a discount to a collection of items without having to define a new function.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicits</h1>
                </header>
            
            <article>
                
<p>As its name indicates, the Scala keyword <kbd>implicit</kbd> can be used to <span>implicitly</span><span> </span><span>add </span><span>some extra code to the compiler. For instance, an implicit parameter in a function definition allows you to omit this parameter when you call the function. As a result, you do not have to pass this parameter explicitly.</span></p>
<p>There are different kinds of implicit in Scala that we will cover in this section:</p>
<ul>
<li>An implicit parameter is declared in a function definition</li>
<li>An implicit value is passed as an argument to a function that has an implicit parameter</li>
<li>An implicit conversion converts one type to another type</li>
</ul>
<p>This is an extremely powerful feature that can feel a bit like magic sometimes. I<span>n this section,</span><span> w</span><span>e will see how it can help writing more concise code and also how to use it to validate some constraints at compile time. In the next chapter, we will use them to define another powerful concept: type classes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit parameters</h1>
                </header>
            
            <article>
                
<p>In a function definition, the last parameter list can be marked as <kbd>implicit</kbd>. Such a function can then be invoked without passing the corresponding arguments. When you omit the implicit arguments, the Scala compiler will try to find implicit values of the same type in the current scope and will use them as arguments to the function.</p>
<p>Here is an illustration of this mechanism that you can type into a Scala worksheet:</p>
<pre><span>case class </span>AppContext(message: <span>String</span>)<br/><span>implicit val myA</span>ppCtx: AppContext = <span>AppContext</span>(<span>"implicit world"</span>)<br/><br/><span>def </span><span>greeting</span>(prefix: <span>String</span>)(<span>implicit </span>appCtx: AppContext): <span>String </span>=<br/>  prefix + appCtx.message<br/><br/>greeting(<span>"hello "</span>)<br/>// res0: String = hello implicit world</pre>
<p>We first declare a new <kbd>AppContext</kbd> <span>class</span><span> </span><span>and assign a new instance of this class to an</span> <kbd>implicit val</kbd><span>. The</span> <kbd>val myAppCtx</kbd> <span>can be used like a normal</span> <kbd>val</kbd><span>, but in addition, the</span> <kbd>implicit</kbd> <span>keyword indicates to the compiler that this</span> <kbd>val</kbd> <span>is a candidate for</span> <strong>implicit resolution</strong><span>.</span></p>
<p>The definition of the <kbd>greeting</kbd> function has an <kbd>implicit</kbd> marker on its last parameter list. When we call it without passing the <kbd>appCtx</kbd> argument, the compiler tries to resolve this implicit parameter. This implicit resolution tries to find an implicit value of an <kbd>AppContext</kbd><span> type</span><span> </span><span>in the current scope. The only implicit value with this type is</span> <kbd>myAppCtx</kbd><span>, and hence this is the argument that is used for</span> <kbd>appCtx</kbd><span>.</span></p>
<p>Note that the implicit resolution is performed at compile time. If the compiler cannot resolve the implicit parameter, it will raise an error. Also, if there are several implicit values of the same type in the current scope, the compiler will be unable to decide which one to pick, and will raise an error because of ambiguous implicit values.</p>
<p>In a large code base, it can <span>sometimes</span><span> </span><span>be difficult to know what implicit value is chosen on a given function call. Fortunately, IntelliJ can show this to you. Position your cursor on the</span> <kbd>greeting("hello ")</kbd> <span>line and go to</span> <span class="packt_screen">View</span> <span>|</span> <span class="packt_screen">Implicit parameters</span><span>, or press </span><em>Ctrl </em><span>+</span> <em>Shift </em><span>+ </span><em>P</em> <span>(Linux/Windows) or</span> <em>Meta </em><span>+</span> <em>Shift +</em><span> </span><em>P</em> <span>(macOS). You should see the following tooltip, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6c1fc20e-91f7-4df6-8faf-559c84bce872.png" style="width:39.00em;height:12.58em;"/></p>
<p>You can then click on the parameter shown in the tooltip. IntelliJ will jump to the declaration of the implicit value.</p>
<p>The arguments for the implicit parameter list can also be passed explicitly. The following call is equivalent to the previous one:</p>
<pre>greeting(<span>"hello "</span>)(myAppCtx)<br/>// res0: String = hello implicit world</pre>
<p>When you pass the implicit arguments explicitly, the implicit resolution mechanism does not kick in.</p>
<div class="mce-root packt_tip">
<p>An implicit parameter should have a type that has very few instances. It would not make sense to have an implicit parameter of a type string; there would be too many candidates for resolving it. This would make the code difficult to understand.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit parameter usage</h1>
                </header>
            
            <article>
                
<p>Implicit parameters are useful when you have to repeatedly pass the same argument to many functions. This happens frequently for configuration parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing a timeout</h1>
                </header>
            
            <article>
                
<p>Imagine that you implemented a <kbd>PriceService</kbd> trait that calls an external website to get the price of a product. You defined its interface as follows:</p>
<pre><span>import cats.data.ValidatedNel<br/>case class </span>Timeout(millis: <span>Int</span>)<br/><br/><span>trait </span>PriceService {<br/>  <span>def </span><span>getPrice</span>(productName: <span>String</span>)(<span>implicit </span>timeout: Timeout): <br/>  ValidatedNel[<span>String</span><span>, Double</span>]<br/>}</pre>
<p>The external website might not be responsive, and so our service has to wait a certain amount of time before giving up, indicated by the parameter <kbd>timeout</kbd><span>. As we have seen in</span> <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml" target="_blank">Chapter 3</a>,<a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml" target="_blank"/><span> </span><em>Handling Errors</em><span>, the service would return </span><kbd>Invalid[NonEmptyList[String]]</kbd> <span>if there were any problem getting the price, or </span><kbd>Valid[Double]</kbd> <span>if we can obtain the price.</span></p>
<p>In a large application, you could have many more services defined like this. Using an implicit parameter allows you to call these functions without having to pass the <kbd>timeout</kbd> argument each time. Furthermore, if you need to add other configuration parameters, you could add more implicit parameters without having to change all your function calls.</p>
<p>When you want to call the service, you would need to have <kbd>implicit val timeout: Timeout</kbd> in your scope. This gives you a good amount of flexibility, as you have total control over where you define this <kbd>timeout</kbd> and how you bring it to the current scope. The following list shows some options for this:</p>
<ul>
<li>You could define it only once in a <kbd>object AppConfig { implicit val defaultTimeout: Timeout = ??? }</kbd> singleton for the whole application. In this object, you could hard code its value or read it from a configuration file. When you need to call a service, all you have to do is <kbd>import AppConfig.defaultTimeout</kbd> to bring it to the current scope.</li>
<li>You could use one value for production code and a different one for test code.</li>
<li>You could have one part of your application using one value, say for fast services, and another part using a different value for slow services.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing an application context</h1>
                </header>
            
            <article>
                
<p>If you have many other configuration parameters to pass to your functions, it can be more convenient to put them in an <kbd>ApplicationContext</kbd> class and declare an implicit parameter of this class in your functions. The added benefit is that this context can not only store configuration parameters, but it can also hold references to commonly used service classes. This mechanism can effectively replace dependency injection frameworks, such as Spring or Guice, that you might have used with Java.</p>
<p>For instance, say that we have an application that implements a <kbd>DataService</kbd> trait. It has two methods that can load and save <kbd>Product</kbd> objects from a database, as shown in the following code:</p>
<pre><span>case class </span>Product(name: <span>String</span><span>, </span>price: <span>Double</span>)<br/><br/><span>trait </span>DataService {<br/>  <span>def </span><span>getProduct</span>(name: <span>String</span>): ValidatedNel[<span>String</span><span>, </span>Product]<br/>  <span>def </span><span>saveProduct</span>(product: Product): ValidatedNel[<span>String</span><span>, Unit</span>]<br/>}</pre>
<p>We would typically have two implementations of this trait:</p>
<ul>
<li>One in the production code that will interact with a real database.</li>
<li>One in the test code that will save a <kbd>Product</kbd> in memory for the duration of the test. This will allow us to run tests more quickly and to keep the tests independent from any external system.</li>
</ul>
<p>We can then define an <kbd>AppContext</kbd> class, as follows:</p>
<pre><span>class </span>AppContext(<span>implicit val </span>defaultTimeout: Timeout<span>,<br/></span><span>                 </span><span>val </span>priceService: PriceService<span>,<br/></span><span>                 </span><span>val </span>dataService: DataService)</pre>
<p>This context would have different implementations for the production and the test code. This will let you implement complex functions without having to connect to the database or to an external service when running your tests. For instance, we can implement an <kbd>updatePrice</kbd> function using an <kbd>implicit appContext</kbd> parameter:</p>
<pre><span>import </span>cats.implicits._<br/><span>def </span><span>updatePrice</span>(productName: <span>String</span>)(<strong><span>implicit </span>appContext: AppContext</strong>)<br/>: ValidatedNel[<span>String</span><span>, Double</span>] = {<br/>  <span>import </span>appContext._<br/>  (dataService.getProduct(productName)<span>, <br/>  </span>priceService.getPrice(productName)).tupled.andThen {<br/>    <span>case </span>(product<span>, </span>newPrice) =&gt;<br/>      dataService.saveProduct(product.copy(price = newPrice)).map(_ =&gt;<br/>        newPrice<br/>      )<br/>  }<br/>}</pre>
<p>This function loads a product from the database, obtains its new price by calling the <kbd>priceService</kbd>, and saves the product with the updated price. It will return a <kbd>Valid[Double]</kbd> containing the new price, or <kbd>Invalid[NonEmptyList[String]]</kbd> containing the errors if any of the services go wrong. When writing the unit test for this function, we would pass <kbd>AppContext</kbd>, which holds fake implementations of <kbd>PriceService</kbd> and <kbd>DataService</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examples in the SDK</h1>
                </header>
            
            <article>
                
<p>The <strong>Scala Development Kit</strong> (<strong>SDK</strong>) makes use of implicit parameters in various places. We will explore some common uses that you will encounter as a more experienced Scala developer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">breakOut</h1>
                </header>
            
            <article>
                
<p>The definition of several methods on the Scala collection API, such as <kbd>map</kbd>, has an implicit parameter of a <kbd>CanBuildFrom </kbd><span>type</span><span>. This type is used to build a collection of the same type as the input type.</span></p>
<p>For instance, when you call <kbd>map</kbd> on a <kbd>Vector</kbd>, the return type will still be a <kbd>Vector</kbd>, as shown in the following code run in the REPL:</p>
<pre><span>val </span>vec = <span>Vector</span>(<span>"hello"</span><span>, </span><span>"w</span><span>orld"</span>).map(s =&gt; s -&gt; s.length)<br/>// vec: scala.collection.immutable.<strong>Vector</strong>[(String, Int)] = <br/>// Vector((hello,5), (world,5))</pre>
<p>When you position your cursor in IntelliJ at the <kbd>map</kbd> method and press cmd + left-click, you will see that <kbd>map</kbd> is declared in <kbd>TraversableLike</kbd>, as follows:</p>
<pre><span>def </span><span>map</span>[<span>B</span><span>, </span><span>That</span>](f: <span>A </span>=&gt; <span>B</span>)(<span>implicit </span>bf: <strong>CanBuildFrom[<span>Repr</span><span>, </span><span>B</span><span>, </span><span>That</span>]</strong>): <span>That </span>= {...}</pre>
<p>The <kbd>TraversableLike</kbd> trait is a super trait of many Scala collections, such as <kbd>Vector</kbd>, <kbd>List</kbd>, <kbd>HashSet</kbd>, and many more. It implements many methods that are common to all these collections. In many of these methods, the <kbd>bf: CanBuildFrom</kbd> parameter is used to build a collection of the same type as the original collection. If you jump to the definition of <kbd>CanBuildFrom</kbd>, you will see that it has three type parameters, as shown in the following code:</p>
<pre><span>trait </span>CanBuildFrom[<span>-From</span><span>, </span><span>-Elem</span><span>, </span><span>+To</span>]</pre>
<p>The first parameter, <kbd>From</kbd>, is the type of the original collection (<kbd>Vector</kbd>, <kbd>List</kbd>, and many more). The second parameter, <kbd>Elem</kbd>, is the type of the elements contained in the collection. The third parameter, <kbd>To</kbd>, is the type of the target collection.</p>
<p>Going back to our example, this means that when we called <kbd>.map</kbd> on our <kbd>Vector</kbd>, an implicit parameter of the <kbd>CanBuildFrom</kbd> type was passed. We can see where it is declared by once more positioning our cursor at the <kbd>map</kbd> method, and going to <span class="packt_screen">View</span> | <span class="packt_screen">Implicit parameters</span>, or pressing cmd + s<em>hift</em> + <em>P</em>. If we then click on the tooltip text, we will jump to this definition in <kbd>Vector.scala</kbd>, as shown in the following code:</p>
<pre><span>object </span>Vector <span>extends </span>IndexedSeqFactory[Vector] {<br/>...<br/>  implicit def canBuildFrom[A]: CanBuildFrom[Coll, A, Vector[A]] = ...</pre>
<p>We can see that the <kbd>To</kbd> target parameter in <kbd>CanBuildFrom</kbd> is of the <kbd>Vector[A]</kbd><span> type</span><span>. This explains why the</span> <kbd>vec</kbd> <span>variable in our example is of the</span> <kbd>Vector[(String, Int)]</kbd><span> type</span><span>.</span></p>
<p>This mechanism is quite complicated, but you do not have to understand it in detail unless you want to implement your own collection types. The SDK does a good job of hiding these details when you are just a user of the library.</p>
<p>However, one thing that is useful to remember is that you can pass a different <kbd>CanBuildFrom</kbd> parameter to avoid unnecessary transformations. For instance, imagine that we want to build <kbd>Map[String, Int]</kbd>, where the key is a string and the value is the length of that string. Going back to our example, the most immediate way would be to call <kbd>.toMap</kbd>, as shown in the following code:</p>
<pre><span>val </span>vec = <span>Vector</span>(<span>"hello"</span>, <span>"world"</span>).map(s =&gt; s -&gt; s.length)<br/>vec.toMap<br/>// res0: scala.collection.immutable.Map[String,Int] = Map(hello -&gt; 5,  world -&gt; 5)</pre>
<p>The problem with this approach is that it will iterate twice through the elements of the <kbd>Vector</kbd> class: once for mapping the elements, and once for building <kbd>Map</kbd>. On a small collection, this is not an issue, but on large collections, the performance can be affected.</p>
<p>Fortunately, we can build our <kbd>Map</kbd> in one iteration. If we pass the special <kbd>breakOut </kbd><span>object</span><span> </span><span>when calling</span> <kbd>map</kbd><span>, the target type of</span> <kbd>CanBuildFrom</kbd> <span>will be the type of the receiving variable, as shown in the following code:</span></p>
<pre><span>import </span>scala.collection.<span>breakOut<br/></span><span>val </span>map: <span>Map</span>[<span>String</span>, Int] = <span>Vector</span>(<span>"hello"</span>, <span>"world"</span>).map(s =&gt; s -&gt; s.length)(<span>breakOut</span>)<br/>// map: Map[String,Int] = Map(hello -&gt; 5, world -&gt; 5)</pre>
<p>This simple trick can improve the performance of your application, and does not degrade the readability.</p>
<div class="packt_tip">Collection transformation operations, such as <kbd>.toMap</kbd>, <kbd>toVector</kbd>, and many more, can often be removed. Try to pass <kbd>breakOut</kbd> in the previous transformation; it will save one iteration.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">executionContext</h1>
                </header>
            
            <article>
                
<p>The <kbd>Future</kbd> class in the Scala SDK allows you to run computations asynchronously. We will explore this in more detail in <a href="3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml" target="_blank">Chapter 6</a>, <em>Online Shopping – Persistence</em>, but in this section, we will explore how it makes use of implicit parameters to provide an execution context.</p>
<p>Open a Scala console and enter the following code. It should create a <kbd>Future</kbd> computation that will print the name of the current thread when it gets executed:</p>
<pre>scala&gt; import scala.concurrent.Future<br/>import scala.concurrent.Future<br/>scala&gt; <strong>Future(println(Thread.currentThread().getName))</strong></pre>
<p>Since we are missing an implicit in our scope, you should see the following error:</p>
<pre>&lt;console&gt;:13: error: Cannot find an implicit ExecutionContext. You might pass<br/>an (implicit ec: ExecutionContext) parameter to your method<br/>or import scala.concurrent.ExecutionContext.Implicits.global.<br/>       Future(println(Thread.currentThread().getName))</pre>
<p>The compiler tells us that we must have an <kbd>implicit ExecutionContext</kbd> in scope. An <kbd>ExecutionContext</kbd> is a class that can execute some computations asynchronously, typically using a thread pool. As suggested by the compiler, we can use the default execution context by importing <kbd>scala.concurrent.ExecutionContext.Implicits.global</kbd>, as shown in the following code:</p>
<pre>scala&gt; import scala.concurrent.ExecutionContext.Implicits.global<br/>import scala.concurrent.ExecutionContext.Implicits.global<br/>scala&gt; import scala.concurrent.Future<br/>import scala.concurrent.Future<br/><br/>scala&gt; Future(println(Thread.currentThread().getName))<strong><br/></strong>scala-execution-context-global-11<br/>res1: scala.concurrent.Future[Unit] = Future(Success(()))</pre>
<div class="packt_infobox">In the previous snippet, the value of <kbd>res1</kbd> could be as: <br/>
<br/>
<kbd>res1: scala.concurrent.Future[Unit] = Future(&lt;not completed&gt;)</kbd><strong><br/>
<br/></strong> As this is <kbd>Future</kbd>, we don't know when it's going to finish; it will depend on your machine.</div>
<p>We can see that the name of the thread used to execute our <kbd>println</kbd> statement was <kbd>scala-execution-context-global-11</kbd>. If we want to run our computation using a different thread pool, we can declare a new <kbd>ExecutionContext</kbd>. Restart the Scala console and enter the following code:</p>
<pre>scala&gt; import scala.concurrent.Future<br/>import scala.concurrent.Future<br/><br/>scala&gt; import java.util.concurrent.Executors<br/>import java.util.concurrent.Executors<br/><br/>scala&gt; import scala.concurrent.{ExecutionContext, Future}<br/><em>i</em>mport scala.concurrent.{ExecutionContext, Future}<br/><br/>scala&gt; implicit val myThreadPool: ExecutionContext = ExecutionContext.fromExecutor<strong>(Executors.newFixedThreadPool(2))</strong><br/>myThreadPool: scala.concurrent.ExecutionContext = scala.concurrent.impl.ExecutionContextImpl@7f3c0399<br/><br/>scala&gt; Future(println(Thread.currentThread().getName))<br/><strong>pool-1-thread-1</strong><br/>res0: scala.concurrent.Future[Unit] = Future(&lt;not completed&gt;)</pre>
<p class="mce-root"/>
<p>We can observe that the thread used to run our code is now coming from a different thread pool. Many methods on <kbd>Future</kbd> have an implicit <kbd>ExecutionContext</kbd> parameter. By changing the implicit in scope, you can control how the asynchronous computations get executed.</p>
<p>This is especially useful when using some database drivers—you would typically use a separate thread pool to query the database, with one thread per database connection. On the other hand, CPU-bound computations can use the default thread pool, which will be initialized with the number of CPU cores available on your machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit conversion</h1>
                </header>
            
            <article>
                
<p>An implicit conversion converts a source type to a target type. This allows you to do the following:</p>
<ul>
<li>Use methods of the target type as if they were declared on the source type</li>
<li>Pass the source type as an argument in functions that accept the target type</li>
</ul>
<p>For instance, we could treat the <kbd>String</kbd> type as if it were <kbd>LocalDate</kbd> using the following code:</p>
<pre><span>import </span>java.time.LocalDate<br/><span><br/></span><span>implicit def </span>stringToLocalDate(s: <span>String</span>): LocalDate = LocalDate.<span>parse</span>(s)</pre>
<p>Note that IntelliJ highlights a yellow warning <kbd>Advanced language feature: implicit conversion</kbd> on the <kbd>implicit</kbd> keyword.</p>
<p>If you want to get rid of this warning, you can position the cursor on the <kbd>implicit</kbd> keyword, then press <em>Alt</em> + <em>Enter</em>, and choose to <span class="packt_screen">Enable implicit conversion</span>.</p>
<p>After this declaration, if we have a <kbd>String</kbd> object that can be parsed into a <kbd>LocalDate</kbd>, we can call any of the methods normally available on <kbd>LocalDate</kbd>, as shown in the following code:</p>
<pre><span>"2018-09-01"</span>.getDayOfWeek<br/>// res0: java.time.DayOfWeek = SATURDAY<br/><span><br/>"2018-09-01"</span>.getYear<br/>// res1: Int = 2018</pre>
<p>We can also call functions that accept <kbd>LocalDate</kbd> using normal strings as arguments, as shown in the following code:</p>
<pre><span>import </span>java.time.temporal.ChronoUnit.<span>DAYS<br/></span><span>DAYS</span>.between(<span>"2018-09-01"</span>, <span>"2018-10-10"</span>)<br/>// res2: Long = 39</pre>
<p>This looks a bit like magic, and it is indeed not easy to spot that there is an implicit conversion happening when reading the code. Fortunately, IntelliJ can help us.</p>
<p>First, you might notice that the <kbd>getDayOfWeek</kbd> and <kbd>getYear</kbd> <span>methods</span><span> </span><span>are underlined. This is to show that the method is defined on an implicitly converted type.</span></p>
<p>IntelliJ can also help us find where the implicit conversion is defined. Position your cursor on one of the strings and press c<em>trl</em> <em>+</em> <em>Q</em> on macOS (or click on <span class="packt_screen">Navigate</span> | <span class="packt_screen">Implicit conversion</span>). You should see the following popup:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/726d9aad-a975-4cad-8734-32fa52500e5d.png" style="width:44.25em;height:16.92em;"/></p>
<p>The popup highlights the implicit conversion function that is applied. You can then click on it to jump to its declaration. Note that IntelliJ also shows some other possible implicit conversions coming from the SDK.</p>
<p>This conversion to <kbd>LocalDate</kbd> may appear to be quite nice; however, if we use a string that cannot be parsed, the code will throw exceptions at runtime, as shown in the following code. As we have seen in <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml" target="_blank">Chapter 3</a><a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml" target="_blank"/>, <em>Handling Errors</em>, this is best avoided:</p>
<pre><span>"2018"</span>.getMonth<br/>// java.time.format.DateTimeParseException: Text '2018' could not be parsed at index 4</pre>
<p>This example of implicit conversion was for illustrative purposes only.</p>
<p>Since our conversion can throw exceptions, it would make the code unsafe if we were to use it in production code. It can, however, be useful for writing more concise unit tests.</p>
<div class="packt_tip">Implicit conversions are very powerful, and with great power comes great responsibility! It is not recommended that you define implicit conversions from common types of the SDK (<kbd>String</kbd>, <kbd>Int</kbd>, and many more) to other SDK types. It can quickly make your code difficult to read.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit class</h1>
                </header>
            
            <article>
                
<p>Implicit conversions are often used to add additional methods to an existing type. This is called the <strong>pimp my library</strong> pattern. For instance, if we want to add a <kbd>square </kbd><span>method</span><span> </span><span>on the</span> <kbd>Int</kbd> <span>type, we can proceed as follows. Type the following code in a Scala console:</span></p>
<pre><span>scala&gt;<br/><strong>class </strong></span><strong>IntOps(val i: Int) extends AnyVal {</strong><br/><strong>  <span>def </span>square: Int = i * i</strong><br/>}<br/><span>scala&gt;</span><strong><span> implicit def </span>intToIntOps(i: Int): IntOps = <span>new </span>IntOps(i)</strong><br/>intToIntOps: (i: Int)IntOps<br/><span>scala</span><span>&gt;</span><strong><span> 5</span>.square</strong><br/>res0: Int = 25</pre>
<p>The <kbd>5</kbd> gets implicitly converted to <kbd>IntOps</kbd>, which provides the <kbd>square</kbd> method.</p>
<p>Note that <kbd>IntOps</kbd> extends <kbd>AnyVal</kbd>. This extension makes it a <strong>value class</strong>. The benefit of a value class is that the compiler will avoid allocating a new object when we call the <kbd>square</kbd> method. The produced bytecode will be as efficient as if <kbd>square</kbd> was defined directly inside the <kbd>Int</kbd> class. The compile-time type is <kbd>IntOps</kbd>, but the runtime type will be <kbd>Int</kbd>.</p>
<div class="packt_infobox">One of the limitations of value classes is that they must be defined in the top level of a file or inside an object. If you try to run the preceding code in a Scala worksheet, you will get a <kbd>Value class may not be a member of another class</kbd><span> compilation error</span><q>. </q><span>This is a consequence of the way Scala worksheets are evaluated—the code inside a worksheet belongs to a non-static object.</span></div>
<p>This pimp my library pattern is very useful whenever you want to add new capabilities to classes you cannot change, such as the following:</p>
<ul>
<li>Classes that are part of the SDK or that come from a third-party library.</li>
<li>For your own classes, you can make some methods accessible from a server module, but not from a client module.</li>
</ul>
<p>Scala offers some syntactic sugar to make this pattern more concise. We can rewrite the preceding code with an implicit class definition as follows:</p>
<pre>scala&gt; <br/><strong>implicit class</strong> IntOps(val i: Int) extends AnyVal {<br/>  def square: Int = i * i<br/>}<br/><br/>scala&gt;5.square<br/>res0: Int = 25</pre>
<p>The compiler transforms an implicit class declaration into a class and implicit conversion. The two forms are equivalent.</p>
<p>This pattern is commonly used in the SDK, especially for "pimping" classes coming from the Java Development Kit.</p>
<p>For instance, <kbd>java.lang.String</kbd> can be pimped by <kbd>scala.collection.immutable.StringOps</kbd>, as shown in the following code:</p>
<pre><span>"abcd"</span>.reverse<br/><span>val </span>abcd: StringOps = Predef.<span>augmentString</span>(<span>"abcd"</span>)<br/>abcd.reverse</pre>
<p>In the first line, we call the <kbd>reverse</kbd> method, which is a pimped method coming from <kbd>StringOps</kbd>. By underlining the <kbd>reverse </kbd><span>method</span><span>, IntelliJ shows you that it is not a method defined on</span> <kbd>java.lang.String</kbd><span>. If you move your cursor to the first string, </span><kbd>"abcd"</kbd><span>, and press </span><em>Ctrl</em> <span>+</span> <em>Shift</em> <span>+</span> <em>Q</em><span>, you should see a pop-up window showing you that</span> <kbd>"abcd"</kbd> <span>is implicitly converted to</span> <kbd>StringOps</kbd> <span>using</span> <kbd>Predef.augmentString</kbd><span>.</span></p>
<p>In lines 2 and 3, we are showing you how we could explicitly convert our string to <kbd>StringOps</kbd> and call the same method. This is for illustrative purposes; in a real project, you would only rely on the implicit conversion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How are implicits resolved?</h1>
                </header>
            
            <article>
                
<p>So far, we have declared implicit values and implicit conversions in the same scope as where they were used. But we can define them in other files too.</p>
<p>The Scala compiler has a set of rules to find implicit parameters or implicit conversions. The compiler goes through the following steps and adheres to the following rules:</p>
<ol>
<li>Look at the current scope as follows:</li>
</ol>
<ul>
<li style="padding-left: 30px"><strong>Implicits defined in the current scope:</strong> These should be in the same function or class or object. This is how we defined it in the previous section.</li>
<li style="padding-left: 30px"><strong>Explicit import:</strong> You can define an implicit value <kbd>implValue</kbd> in an object <kbd>myObj</kbd>, and bring it to the current scope with the statement <kbd>import myObj.implValue</kbd>.</li>
<li style="padding-left: 30px"><strong>Wildcard import:</strong> <kbd>import myObj._</kbd>.</li>
</ul>
<ol start="2">
<li>Look at the associated types:</li>
</ol>
<ul>
<li style="padding-left: 30px"><strong>Companion object of the source type:</strong> For instance, in the companion object of <kbd>Option</kbd>, there is an implicit conversion to <kbd>Iterable</kbd>. This allows you to call any method of <kbd>Iterable</kbd> on an <kbd>Option</kbd> instance. Also, if a function expects an <kbd>Iterable</kbd> parameter, you can pass an <kbd>Option</kbd> instance.</li>
<li style="padding-left: 30px"><strong>Companion object of a parameter's type:</strong> For instance, if you call <kbd>List(1, 2, 3).sorted</kbd>, the <kbd>sorted </kbd>method actually takes an implicit parameter of the <kbd>Ordering[Int]</kbd>type. This implicit value can be found in the companion object of <kbd>Ordering</kbd>.</li>
<li style="padding-left: 30px"><strong>Companion object of a parameter's type parameter:</strong> When a function's parameter has an <kbd>A </kbd>type parameter, for instance, <kbd>Ordering[A]</kbd>, the companion object of <kbd>A</kbd> is searched for implicits. Here is an example:</li>
</ul>
<pre style="padding-left: 60px"><span>case class </span>Person(name: <span>String</span>, age: Int)<br/><span>object </span>Person {<br/>  <span>implicit val </span><span>ordering</span>: <span>Ordering</span>[Person] = <span>Ordering</span>.<span>by</span>(_.age)<br/>}<br/><br/><span>List</span>(<span>Person</span>(<span>"Omer"</span>, <span>40</span>), <span>Person</span>(<span>"Bart"</span>, <span>10</span>)).sorted</pre>
<p style="padding-left: 60px"/>
<p class="mce-root"/>
<p style="padding-left: 60px"/>
<p style="padding-left: 60px">In this example, the <kbd>sorted</kbd> <span>method</span><span> </span><span>expects an implicit parameter of an</span> <kbd>Ordering[Person]</kbd><span> type</span><span>, which can be found in the companion object of the </span><kbd>Person </kbd><span>type parameter</span><span>.</span></p>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have covered quite a lot of material in this chapter. You learned how to improve performance using the <kbd>lazy</kbd> variable, and learned about covariance and contravariance. You also learned how to partially apply functions using currying techniques, and finally, we went through all the different ways of using implicit in Scala. Some concepts, such as currying, are also used in other functional programming languages, such as Haskell.</p>
<p>In the next chapter, we are going to go deeper into type theory by introducing the type classes. Type classes is the concept of grouping the same types sharing a common behavior.</p>


            </article>

            
        </section>
    </body></html>