<html><head></head><body>
<div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.2.1">Refactoring Techniques</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We’re now getting into the meat of the subject: how to do refactoring. </span><span class="koboSpan" id="kobo.3.2">It would be a bit silly to think we can cram all the refactoring techniques ever known into one chapter. </span><span class="koboSpan" id="kobo.3.3">So, we’ve decided to focus on the most common and more interesting ones. </span><span class="koboSpan" id="kobo.3.4">Our main source of wisdom comes from Martin Fowler’s fantastic work in his book, </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Refactoring: Improving the Design of Existing Code</span></em><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">He teamed up with Kent Beck to explain, step by step, how to do refactoring, from the simplest to the trickiest cases. </span><span class="koboSpan" id="kobo.5.3">For each one, they provide a kind of </span><em class="italic"><span class="koboSpan" id="kobo.6.1">how-to</span></em><span class="koboSpan" id="kobo.7.1"> guide so that you won’t mess things up. </span><span class="koboSpan" id="kobo.7.2">Here, we’re offering a selection of the most important refactoring techniques, an importance that we consider based largely on our </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">own experience.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.9.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.10.1">For those who don’t know, Martin Fowler and Kent Beck are influential figures in software development. </span><span class="koboSpan" id="kobo.10.2">Martin Fowler is known for his contributions to software design, refactoring, and agile </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.11.1">methodologies, while Kent Beck is the creator of </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Extreme Programming</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">XP</span></strong><span class="koboSpan" id="kobo.15.1">) and the JUnit testing framework. </span><span class="koboSpan" id="kobo.15.2">Both have had a significant impact on shaping agile practices and improving software </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">development processes.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">We’ve tried to simplify even more what Fowler wrote and sprinkle in a bit of our own work background. </span><span class="koboSpan" id="kobo.17.2">If you haven’t already, we suggest you read the chapter on code smells (</span><a href="B20912_03.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.19.1">) before you dive </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">into this.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we’ll cover </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Techniques for making </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">well-structured methods</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Moving features from one object </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">to another</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Making your data </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">more organized</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Simplifying those tricky </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">-</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1"> blocks</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Cleaning up your </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">method calls</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Some tips on </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">using generalization</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">A nudge to use enums when they </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">make sense</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">But let’s cut to the chase, starting with the basics: </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">composing methods.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.42.1">Writing better methods</span></h1>
<p><span class="koboSpan" id="kobo.43.1">Composing methods is a fundamental skill that should be a part of every developer’s refactoring toolkit. </span><span class="koboSpan" id="kobo.43.2">To put it simply, almost bluntly, it’s about breaking your code into smaller pieces, each of </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.44.1">which does just one thing in a very readable way, in a very procedural manner; you could almost think of it as a recipe (please forgive me; I’m Italian, so I always bring everything back to food). </span><span class="koboSpan" id="kobo.44.2">The details are hidden in the methods beneath the composed method; this allows us to read our logic, our code, at a high level – I dare say, almost “</span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">in prose.”</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">When refactoring your code, the process typically involves extracting code from the original method. </span><span class="koboSpan" id="kobo.46.2">If you find it challenging to come up with meaningful names for the extracted methods, it’s a clear sign that the code chunk you were about to extract may be too extensive. </span><span class="koboSpan" id="kobo.46.3">Another case I’ve come across is when someone (sometimes myself) suggested naming a method that contained the conjunctions “and” or “or”... </span><span class="koboSpan" id="kobo.46.4">also in this situation, it’s clear that the method we are working on has too many responsibilities and is doing too many things. </span><span class="koboSpan" id="kobo.46.5">In such cases, try to identify a smaller, more focused portion for extraction. </span><span class="koboSpan" id="kobo.46.6">Often, in longer methods, you may notice that certain sections are already marked with comments; these labeled sections can frequently be refactored into </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">new methods.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">You might find yourself, after applying this refactoring technique, having many short methods within the same class; this, in itself, is already an improvement. </span><span class="koboSpan" id="kobo.48.2">However, at this point, it might be desirable to further shorten the class by extracting a </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">dedicated one.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Here are some </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.51.1">guidelines you can follow when you have to </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">compose methods:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">The shorter, the better</span></strong><span class="koboSpan" id="kobo.54.1">: Lean toward brevity and conciseness in your code. </span><span class="koboSpan" id="kobo.54.2">Smaller functions and code blocks are generally preferred, as they enhance readability </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">and maintainability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Minimize redundancy</span></strong><span class="koboSpan" id="kobo.57.1">: When employing the composing method pattern, pay close attention to eliminating duplicate code fragments. </span><span class="koboSpan" id="kobo.57.2">This practice not only trims down your code base but also prevents inconsistencies and simplifies </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">future updates.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Show your purpose</span></strong><span class="koboSpan" id="kobo.60.1">: To foster code clarity and adopt a naming convention that leaves no room for ambiguity. </span><span class="koboSpan" id="kobo.60.2">Every variable, method, and parameter should be named in a way that succinctly conveys its role </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">and function.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.62.1">Strive for simplification</span></strong><span class="koboSpan" id="kobo.63.1">: Simplification is a guiding principle in code improvement. </span><span class="koboSpan" id="kobo.63.2">It entails the removal of unnecessary complexities, streamlining logic, and adhering </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.64.1">to best practices. </span><span class="koboSpan" id="kobo.64.2">Simplified code is not only more elegant but also </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">more maintainable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">Maintain consistent detail levels</span></strong><span class="koboSpan" id="kobo.67.1">: When applying the composing method pattern, it’s essential to harmonize the complexity level of the methods you call. </span><span class="koboSpan" id="kobo.67.2">Avoid mixing simple, straightforward getters with functions that perform resource-intensive computations. </span><span class="koboSpan" id="kobo.67.3">Consistency in detail levels fosters code cohesion </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">and comprehension.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.69.1">There are many ways to achieve these goals; next, we will see some </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">of them.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.71.1">Extract Method</span></h2>
<p><span class="koboSpan" id="kobo.72.1">We have already seen something about it in the previous chapters, but I would like to delve a bit deeper. </span><span class="koboSpan" id="kobo.72.2">In my opinion, this is the refactoring that we do (or should do) most often. </span><span class="koboSpan" id="kobo.72.3">It is quite </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.73.1">simply taking a very long method – too long – and breaking it down into smaller methods. </span><span class="koboSpan" id="kobo.73.2">How long can a method be at most? </span><span class="koboSpan" id="kobo.73.3">Obviously, there is no general rule; it depends on your sensitivity and that of the team. </span><span class="koboSpan" id="kobo.73.4">Let’s say that I have to scroll with the mouse to read it all; this is already a small </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.74.1">indicator of excessive length. </span><span class="koboSpan" id="kobo.74.2">I like to follow what Martin Fowler has taught us once again and try to limit the lines of my methods as much as possible; it sometimes happens that I have methods that are only two or three lines long. </span><span class="koboSpan" id="kobo.74.3">In addition to the code length for which I perform method extraction, sometimes I also consider the reusability of the code I am extracting, as it’s important to avoid copy-paste. </span><span class="koboSpan" id="kobo.74.4">However, I agree with Fowler (and of course I do!) in saying that methods should be written with their </span><em class="italic"><span class="koboSpan" id="kobo.75.1">intent</span></em><span class="koboSpan" id="kobo.76.1"> in mind; that is </span><em class="italic"><span class="koboSpan" id="kobo.77.1">what</span></em><span class="koboSpan" id="kobo.78.1"> those methods are supposed to do, and not </span><em class="italic"><span class="koboSpan" id="kobo.79.1">how</span></em><span class="koboSpan" id="kobo.80.1"> they’re gonna do it: isolate all the code needed to do a certain thing in a single method, no matter how small. </span><span class="koboSpan" id="kobo.80.2">The method’s name should then be based on “what” the method does and not “how” it </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">does it.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Let’s illustrate these concepts with a very simple example. </span><span class="koboSpan" id="kobo.82.2">Suppose we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">following method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.84.1">
public void calculate(int num1, int num2) {
    int sum = num1 + num2;
    System.out.println("Sum: " + sum);
    int difference = num1 - num2;
    System.out.println("Difference: " + difference);
}</span></pre> <p><span class="koboSpan" id="kobo.85.1">As you can see, the method is very simple: it is a method that calculates the sum and difference </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.86.1">of two numbers and prints them. </span><span class="koboSpan" id="kobo.86.2">Of course, the reality is much </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.87.1">more complex than that, but the principles do not change. </span><span class="koboSpan" id="kobo.87.2">We refactor the code </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.89.1">
public void calculate(int num1, int num2) {
    int sum = addNumbers(num1, num2);
    printResult("Sum", sum);
    int difference = subtractNumbers(num1, num2);
    printResult("Difference", difference);
}
private static void printResult(String operationName, int result) {
    System.out.printf("Result of %s: %d%n", operationName, result);
}
public static int addNumbers(int a, int b) {
    return a + b;
}
public static int subtractNumbers(int a, int b) {
    return a - b;
}</span></pre> <p><span class="koboSpan" id="kobo.90.1">We have </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.91.1">extracted three methods: one that sums up the numbers, a second that makes the difference, and a third that prints the result on the </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.92.1">screen to avoid repetition. </span><span class="koboSpan" id="kobo.92.2">Don’t be fooled by the length of this specific piece of code; again, it’s just one example to illustrate the concept – in reality, you have to think of sum and difference operations as longer methods that implement perhaps more complex logic. </span><span class="koboSpan" id="kobo.92.3">Another reflection we can make here is that extracting methods promotes code reuse because the logic thus extracted can be invoked in many </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">different points.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.94.1">Inline Method</span></h2>
<p><span class="koboSpan" id="kobo.95.1">This is exactly the opposite of extracting methods. </span><span class="koboSpan" id="kobo.95.2">It may seem strange, after having insisted so </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.96.1">much on the extraction of methods, on short methods, to suggest that sometimes it is appropriate, instead, to inline the method. </span><span class="koboSpan" id="kobo.96.2">This little refactoring can be very useful when you have a very short method (typically a line of code or two) that is never reused and that already expresses very well what </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.97.1">it does; in this case, isolation in a method with the sole purpose of “explaining,” through the name of the method itself, what the method does may </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">be excessive.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">I’ll provide you with a very trivial example of what method inlining is. </span><span class="koboSpan" id="kobo.99.2">Let’s suppose we have the following three methods in </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">a class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
public int add(int a, int b) {
    return a + b;
}
public int multiply(int a, int b) {
    return a * b;
}
public int calculate(int x, int y) {
    int sum = add(x, y);
    int result = multiply(sum, 2);
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.102.1">As you can easily see, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">calculate</span></strong><span class="koboSpan" id="kobo.104.1"> method that takes two integers as input and performs a </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.105.1">series of operations on them. </span><span class="koboSpan" id="kobo.105.2">The operations are represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">add</span></strong><span class="koboSpan" id="kobo.107.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">multiply</span></strong><span class="koboSpan" id="kobo.109.1"> methods, which, of course, make the sum and the product </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.110.1">of the two integers they take as input. </span><span class="koboSpan" id="kobo.110.2">These methods are used only once and are very simple: in fact, only one line. </span><span class="koboSpan" id="kobo.110.3">So, let’s take the opportunity to perform method inlining and make the code shorter and </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">more readable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
public int calculate(int x, int y) {
    int sum = x + y;
    int result = sum * 2;
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.113.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">add</span></strong><span class="koboSpan" id="kobo.115.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">multiply</span></strong><span class="koboSpan" id="kobo.117.1"> methods disappeared, and their implementation, consisting of a single line of code, replaced them where they were invoked. </span><span class="koboSpan" id="kobo.117.2">We could further refactor the code by returning directly the result of the last operation, avoiding the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">result</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.119.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
public int calculate(int x, int y) {
    int sum = x + y;
    return sum * 2;
}</span></pre> <p><span class="koboSpan" id="kobo.121.1">This example may seem contradictory to what we wrote in the previous chapter (in fact, we are now </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.122.1">inling something that before we isolated), but it’s just for the sake of providing a very </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">simple example.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">To sum up, what you </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.125.1">have to do to perform an “Inline Method” refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">is this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.127.1">Check that the method hasn’t been changed in subclasses. </span><span class="koboSpan" id="kobo.127.2">If it has been modified, avoid using </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">this technique.</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">Hunt down all the places where the method is called, then replace those calls with the actual code from </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the method.</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">Go ahead and delete </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">the method.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.133.1">Of course, since we are talking about refactoring, the behavior must never change; to be sure, there’s no other way than to include testing in the little recipe written previously. </span><span class="koboSpan" id="kobo.133.2">Be sure to always carry out a test before eliminating a method that you have inlined. </span><span class="koboSpan" id="kobo.133.3">We’ll get to </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.134.1">that later in the book, but most modern </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">integrated development</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.136.1">environments</span></strong><span class="koboSpan" id="kobo.137.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.138.1">IDEs</span></strong><span class="koboSpan" id="kobo.139.1">) offer tools to do this refactoring with a simple click of </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">the mouse.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Use Inline </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.142.1">Method refactoring in the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">following cases:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.144.1">When the method’s implementation is straightforward</span></strong><span class="koboSpan" id="kobo.145.1">: If the method’s logic is simple and direct, as demonstrated in the preceding example, consider employing this refactoring technique to </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">eliminate it.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.147.1">When you want to eliminate unnecessary delegation</span></strong><span class="koboSpan" id="kobo.148.1">: At times, you may transfer the method’s implementation to another method or class, introducing unnecessary indirection in the code. </span><span class="koboSpan" id="kobo.148.2">To streamline the code and remove this extra layer of delegation, use the Inline </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">Method technique.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.150.1">As a foundation for subsequent refactorings</span></strong><span class="koboSpan" id="kobo.151.1">: The process of refactoring is not always a linear one, and there are various ways to refactor the same code. </span><span class="koboSpan" id="kobo.151.2">For instance, you can employ extract method refactoring to isolate different code segments. </span><span class="koboSpan" id="kobo.151.3">However, if the refactoring path you initially chose does not yield improved code, you can use the inline method to reintegrate previously extracted code back into its original method and then explore alternative </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">refactoring approaches.</span></span></li>
</ul>
<h2 id="_idParaDest-117"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.153.1">Extract and inline variables</span></h2>
<p><span class="koboSpan" id="kobo.154.1">We summarize these two refactoring techniques in a single section since – in our humble </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.155.1">opinion – they are very similar to the Extract Method and Inline Method techniques but applied to a </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">single variable.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">The main motivation – perhaps the only one – to introduce (extract) a variable instead of an </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.158.1">expression is when the latter could be difficult to understand (not so much and not only on a technical level; we talk here about the motivation behind the expression itself). </span><span class="koboSpan" id="kobo.158.2">Let’s try to explain ourselves better with </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
if (transport.getEquipment().toUpperCase().equals("PLN") || transport.getEquipment().toUpperCase().equals("TRN")) {
    //do something
} else {
    //do something else
}</span></pre> <p><span class="koboSpan" id="kobo.161.1">In this code snippet, we analyze a field of a generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">transport</span></strong><span class="koboSpan" id="kobo.163.1"> object that represents a means of transport; among its various fields, the object also has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">equipment</span></strong><span class="koboSpan" id="kobo.165.1"> object that tells us what means of transport it is. </span><span class="koboSpan" id="kobo.165.2">Unfortunately, this field is a string (see </span><a href="B20912_03.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.166.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.167.1">, </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Primitive Obsession</span></em><span class="koboSpan" id="kobo.169.1">), and we are forced to write an </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">if</span></strong><span class="koboSpan" id="kobo.171.1"> statement to understand what type it is, whether plane or train. </span><span class="koboSpan" id="kobo.171.2">The code snippet is a bit clearer if we insert the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">equals</span></strong><span class="koboSpan" id="kobo.173.1"> within a couple of variables with a </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">self-explanatory name:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
boolean isPlane = transport.getEquipment().toUpperCase().equals("PLN");
boolean isTrain = transport.getEquipment().toUpperCase().equals("TRN");
if (isPlane || isTrain) {
    //do something
} else {
    //do something else
}</span></pre> <p><span class="koboSpan" id="kobo.176.1">Someone would be tempted to simply insert a comment to explain what those cryptic strings </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">"PLN"</span></strong><span class="koboSpan" id="kobo.178.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">"TRN"</span></strong><span class="koboSpan" id="kobo.180.1"> refer to, but personally, we find this kind of approach more effective. </span><span class="koboSpan" id="kobo.180.2">You could also use enums instead of plain strings so that a possible typo would be caught </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.181.1">by the compiler. </span><span class="koboSpan" id="kobo.181.2">By introducing these “intermediate parts” formed by the variables, the code is made more understandable. </span><span class="koboSpan" id="kobo.181.3">The drawback is… that your code contains more variables. </span><span class="koboSpan" id="kobo.181.4">As always in life, it is a </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.182.1">problem of balance! </span><span class="koboSpan" id="kobo.182.2">The choice </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">is yours.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The technique of “inline variable,” on the other hand, is so similar to that of the </span><em class="italic"><span class="koboSpan" id="kobo.185.1">inline method</span></em><span class="koboSpan" id="kobo.186.1"> that it is worth explaining it directly through an example that is practically the same as the one seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">relative section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
int sum = num1 + num2;
printResult("Sum", sum);</span></pre> <p><span class="koboSpan" id="kobo.189.1">In this case, assigning to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">sum</span></strong><span class="koboSpan" id="kobo.191.1"> variable the result of the addition – and then never using it again after printing it – does not add much to the understanding of the code compared to the expression itself. </span><span class="koboSpan" id="kobo.191.2">It is therefore better to inline the variable directly in the only point where it is used, eliminating the first line of </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
printResult("Sum", num1 + num2);</span></pre> <h2 id="_idParaDest-118"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.194.1">Combining a function into a class</span></h2>
<p><span class="koboSpan" id="kobo.195.1">As the last notable example of refactoring that reorganizes code by “recomposing” methods, we propose </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.196.1">one that combines several methods within a single class. </span><span class="koboSpan" id="kobo.196.2">This technique is used when we have several methods that have in common one (or more) input parameters; that is, that – in practice – go to act on the same classes. </span><span class="koboSpan" id="kobo.196.3">Again, let’s go directly to show an example that should better clarify the concept. </span><span class="koboSpan" id="kobo.196.4">Suppose we have this set </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">of methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.198.1">
String getLocalizedName(Location location) { ... </span><span class="koboSpan" id="kobo.198.2">}
Collection&lt;Location&gt; getAdjacentLocations(Location location) { ... </span><span class="koboSpan" id="kobo.198.3">}
Coordinates getCoordinates(Location location) { ... </span><span class="koboSpan" id="kobo.198.4">}</span></pre> <p><span class="koboSpan" id="kobo.199.1">All of these methods take a single parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">Location</span></strong><span class="koboSpan" id="kobo.201.1"> type. </span><span class="koboSpan" id="kobo.201.2">It would be better to enclose </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.202.1">all the logic concerning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">Location</span></strong><span class="koboSpan" id="kobo.204.1"> parameter in a single point. </span><span class="koboSpan" id="kobo.204.2">For this, we create a class that contains all </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">the logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
public class LocationHandler {
    private final Location location;
    public LocationHandler(Location location) {
        this.location = location;
    }
   String getLocalizedName() { ...}
   Collection&lt;Location&gt; getAdjacentLocations() { ...}
    Coordinates getCoordinates() { ...}
}</span></pre> <p><span class="koboSpan" id="kobo.207.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Location</span></strong><span class="koboSpan" id="kobo.209.1"> instance is passed only once, in the constructor. </span><span class="koboSpan" id="kobo.209.2">From the signatures of the methods we then removed the parameter; now, you no longer need to pass it. </span><span class="koboSpan" id="kobo.209.3">Of course, consider carefully whether to refactor this way; if your </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Location</span></strong><span class="koboSpan" id="kobo.211.1"> instance changes </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.212.1">often, such as for each method call, using such a pattern might not be the best idea, because you should instantiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">LocationHandler</span></strong><span class="koboSpan" id="kobo.214.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">each call.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.216.1">Moving features between objects</span></h1>
<p><span class="koboSpan" id="kobo.217.1">As we have already mentioned several times, and as those who have been in this profession </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.218.1">for more than a few years know organizing our code is perhaps one of the most challenging parts. </span><span class="koboSpan" id="kobo.218.2">Personally, I believe I have never managed to get the design of a software project right on the first try. </span><span class="koboSpan" id="kobo.218.3">But, once again, the software is fortunately (or unfortunately!) malleable, so with the right limits and a good amount of refactoring, we can move methods and fields from one class to another without too much difficulty. </span><span class="koboSpan" id="kobo.218.4">We can decide to extract a class or remove one and inline it. </span><span class="koboSpan" id="kobo.218.5">Above all, we can eliminate the so-called </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.219.1">dead code. </span><span class="koboSpan" id="kobo.219.2">But let’s start </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">showing something.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.221.1">Moving a method or field</span></h2>
<p><span class="koboSpan" id="kobo.222.1">This refactoring is quite basic (Martin Fowler calls it the “bread and butter” of refactorings), but it is one of the most frequently performed ones. </span><span class="koboSpan" id="kobo.222.2">This is because, as we have already mentioned, it is good practice to maintain a certain modularity in your software </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.223.1">project so that classes, packages, and so on are grouped coherently based on the context in which they operate. </span><span class="koboSpan" id="kobo.223.2">For example, in one package, we may </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.224.1">place all classes responsible for managing user information, while in another, we may gather all clients for external services. </span><span class="koboSpan" id="kobo.224.2">There is no single criterion, but rather, often, a certain subjectivity. </span><span class="koboSpan" id="kobo.224.3">This is why it can often happen that methods or individual fields are moved from one class to another. </span><span class="koboSpan" id="kobo.224.4">This movement, guided by the principle of keeping related things together and separating things that should be separate, simplifies </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">This is one of those cases where doing something is simpler and more intuitive than explaining it, but I’ll try to give you Martin Fowler’s “recipe” for it, perhaps simplifying it </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">a bit.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Transferring a method from the source class to the target class involves several steps that must be followed to ensure a successful </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">refactoring process:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.230.1">Examine the dependencies and other class members that the method utilizes. </span><span class="koboSpan" id="kobo.230.2">Determine if it’s necessary to relocate them to the new class </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">as well.</span></span></li>
<li><span class="koboSpan" id="kobo.232.1">Check whether the method is referenced by a superclass or subclass. </span><span class="koboSpan" id="kobo.232.2">If it’s being used by these classes, it may not be feasible to move </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the method.</span></span></li>
<li><span class="koboSpan" id="kobo.234.1">Establish the </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.235.1">method in the target class and replicate </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.236.1">existing code into it. </span><span class="koboSpan" id="kobo.236.2">If the relocated method relies on an instance of the original class, you can pass it as a </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">method parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">Delete the code within the old method and direct the call to the new method. </span><span class="koboSpan" id="kobo.238.2">(This is optional; you could </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.239.1">also use a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.240.1">feature toggle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">.)</span></span></li>
<li><span class="koboSpan" id="kobo.242.1">Optionally, make a decision about whether to eliminate the old method entirely and directly invoke the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">new method.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.244.1">Feature toggle</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.245.1">Feature toggles</span></strong><span class="koboSpan" id="kobo.246.1">, also </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.247.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">feature flags</span></strong><span class="koboSpan" id="kobo.249.1">, are a technique that allows us to activate or deactivate specific functionalities without directly modifying the source code. </span><span class="koboSpan" id="kobo.249.2">This approach brings benefits such as continuous deployment, simplified testing in real-world conditions, efficient issue management, gradual feature rollouts for risk management, and the ability to compare feature variants for </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">informed decision-making.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.251.1">In the most abstract sense, a feature toggle would work like this in a </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">Java method:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">public void </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">applyLogic() {</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">    if (</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">newFeatureEnabled) {</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">        </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">applyNewLogic();</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">    } </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">else {</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">        </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">applyCurrentLogic();</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">    }</span></strong></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">}</span></strong></p>
<p><span class="koboSpan" id="kobo.265.1">In the end, it is advisable to execute your test suite. </span><span class="koboSpan" id="kobo.265.2">It’s essential to bear in mind, even though it should be implicit when </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">discussing refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">With a single field, the process is very similar. </span><span class="koboSpan" id="kobo.267.2">We have a field that is used by another class more than the class in which it is defined. </span><span class="koboSpan" id="kobo.267.3">The context is not respected; therefore, we move the field to that other class, subsequently changing all points where that field </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">is used.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Fields are often moved around </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.270.1">when applying the </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">Extract Class</span></strong><span class="koboSpan" id="kobo.272.1"> technique, and deciding which </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.273.1">class should keep a particular field can </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.274.1">be a bit tricky. </span><span class="koboSpan" id="kobo.274.2">Here’s a practical rule of thumb: put the field in the same class as the methods that use it the most, or in the class where you find most of these methods. </span><span class="koboSpan" id="kobo.274.3">This rule can also prove beneficial in scenarios where a field is clearly situated in an </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">inappropriate location.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Once again, let’s present the methodology as described </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">by Fowler:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.278.1">When dealing with a public field, refactoring becomes significantly more manageable by converting it into a private field and providing public access methods (you can </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.279.1">utilize the </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">Encapsulate Field</span></strong><span class="koboSpan" id="kobo.281.1"> technique for this purpose, as explained in the </span><em class="italic"><span class="koboSpan" id="kobo.282.1">Field </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.283.1">encapsulation</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1"> section).</span></span></li>
<li><span class="koboSpan" id="kobo.285.1">Establish the same field within the receiving class along with its corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">access methods.</span></span></li>
<li><span class="koboSpan" id="kobo.287.1">Determine how you will access the receiving class. </span><span class="koboSpan" id="kobo.287.2">You may already possess a field or method that yields the required object. </span><span class="koboSpan" id="kobo.287.3">If not, you’ll need to create a new method or field to store the object associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">receiving class.</span></span></li>
<li><span class="koboSpan" id="kobo.289.1">Substitute all occurrences where the old field is referenced with appropriate method calls in the receiving class. </span><span class="koboSpan" id="kobo.289.2">If the field is not private, address this in both the superclass and any subclasses </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">as necessary.</span></span></li>
<li><span class="koboSpan" id="kobo.291.1">Eliminate the field from the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">original class.</span></span></li>
</ol>
<h2 id="_idParaDest-121"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.293.1">Moving statements into/from methods</span></h2>
<p><span class="koboSpan" id="kobo.294.1">Repeated code is one of the most common problems in our code base; the temptation to copy and paste is sometimes too strong. </span><span class="koboSpan" id="kobo.294.2">This can be seen before calling a certain method, a certain </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.295.1">line of code; it can also </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.296.1">happen that the same line of code is repeated before each call to that method. </span><span class="koboSpan" id="kobo.296.2">At this point, you will have understood that the best alternative is to take that statement and move it directly inside </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">that method.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">On the contrary, there may be a statement within the code that doesn’t fit well with the context of the method; perhaps it makes sense in one execution flow but not in another. </span><span class="koboSpan" id="kobo.298.2">In this case, make the opposite move to the previous one and move the statement outside of the method, to the point where it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">truly needed.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">I consider this technique very common but quite straightforward. </span><span class="koboSpan" id="kobo.300.2">For a deeper exploration of the “mechanics” of how it works, I refer you to the </span><em class="italic"><span class="koboSpan" id="kobo.301.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.302.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.303.1"> section.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.304.1">Hiding delegates</span></h2>
<p><span class="koboSpan" id="kobo.305.1">This refactoring </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.306.1">technique is applied when a class (referred to as the client) obtains an object of type </span><em class="italic"><span class="koboSpan" id="kobo.307.1">B</span></em><span class="koboSpan" id="kobo.308.1"> (referred to as the delegate) through another class of type </span><em class="italic"><span class="koboSpan" id="kobo.309.1">A</span></em><span class="koboSpan" id="kobo.310.1"> (referred to as the server). </span><span class="koboSpan" id="kobo.310.2">When client code calls a method defined on an object within a server object’s field, it establishes a direct dependency on that delegate object. </span><span class="koboSpan" id="kobo.310.3">Consequently, if the delegate object’s interface undergoes changes, all clients of the server relying on that delegate are affected. </span><span class="koboSpan" id="kobo.310.4">To eliminate this dependency, one can introduce a straightforward delegation method within the server, effectively hiding the delegate. </span><span class="koboSpan" id="kobo.310.5">Any subsequent modifications made to the delegate’s interface will then only impact the server itself, shielding clients from </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">these changes.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">An example will clarify a bit what we just said. </span><span class="koboSpan" id="kobo.312.2">Let’s suppose to have </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">two classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
public class Itinerary {
    private final String departureAirport;
    private final String arrivalAirport;
    //constructor, getters...
</span><span class="koboSpan" id="kobo.314.2">}
public class Flight {
    private final Itinerary itinerary;
//constructor, getter...
</span><span class="koboSpan" id="kobo.314.3">}</span></pre> <p><span class="koboSpan" id="kobo.315.1">If we </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.316.1">want to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">departureAirport</span></strong><span class="koboSpan" id="kobo.318.1">, but we have an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Flight</span></strong><span class="koboSpan" id="kobo.320.1">, our code will be something </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
var departureAirport = flight.getItinerary().getDepartureAirport();</span></pre> <p><span class="koboSpan" id="kobo.323.1">This is OK, of course, except for the fact that now we must also be aware of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Itinerary</span></strong><span class="koboSpan" id="kobo.325.1"> class; that is actually useless since we need just </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">departureAirport</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">We don’t want to change our code if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Itinerary</span></strong><span class="koboSpan" id="kobo.329.1"> class changes. </span><span class="koboSpan" id="kobo.329.2">So, we will write something </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
public class Flight {
    private final Itinerary itinerary;
    public String getDepartureAirport(){
        return itinerary.getDepartureAirport();
    }
    //constructor, getter...
</span><span class="koboSpan" id="kobo.331.2">}</span></pre> <p><span class="koboSpan" id="kobo.332.1">So, we just call a method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Flight</span></strong><span class="koboSpan" id="kobo.334.1"> class to get the field we need. </span><span class="koboSpan" id="kobo.334.2">Of course, we will also have to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">client code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
var departureAirport = flight.getDepartureAirport();</span></pre> <p><span class="koboSpan" id="kobo.337.1">The delegate </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.338.1">is now hidden. </span><span class="koboSpan" id="kobo.338.2">We have less code and fewer relations </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">between objects.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">But as a recipe, as Martin Fowler does, here are the steps to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">this refactoring:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.342.1">For every method in the delegate class that the client class calls, generate a corresponding method in the server class that forwards the call to the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">delegate class.</span></span></li>
<li><span class="koboSpan" id="kobo.344.1">Modify the client code to invoke the methods in the server class instead of directly calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">delegate class.</span></span></li>
<li><span class="koboSpan" id="kobo.346.1">If your modifications successfully eliminate the client’s dependency on the delegate class, you can safely remove the access method to the delegate class within the server class (the method originally used to obtain the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">delegate class).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.348.1">One downside is that if you have to generate an excessive number of delegate methods, the server class may end up being an unnecessary intermediary, resulting in an abundance </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">of middlemen.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.350.1">Removing dead code</span></h2>
<p><span class="koboSpan" id="kobo.351.1">Ah, here’s </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.352.1">one of the things that satisfies me the most: deleting unnecessary code! </span><span class="koboSpan" id="kobo.352.2">Dead code refers to parts of the source code that are no longer executed or reachable during the </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">program’s execution.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">Dead code can occur for various reasons, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the following:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.356.1">Code removal or refactoring</span></strong><span class="koboSpan" id="kobo.357.1">: When developers modify a program, they may delete or comment out certain sections of code that are no longer needed. </span><span class="koboSpan" id="kobo.357.2">These leftover code snippets become </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">dead code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.359.1">Conditional branches</span></strong><span class="koboSpan" id="kobo.360.1">: In some cases, code may be written within branches of conditional statements that are never true during execution, making the code within those branches </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">effectively dead.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.362.1">Unused variables or functions</span></strong><span class="koboSpan" id="kobo.363.1">: If variables or functions are defined but not used anywhere in the program, they are considered </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">dead code.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.365.1">You don’t want dead code in your project: it makes it harder to understand, increases maintenance costs, and potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">introduces bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">So, please, if you are </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.368.1">aware of dead code in your project – and modern IDEs now are perfectly capable of doing that – please just remove it. </span><span class="koboSpan" id="kobo.368.2">No – don’t comment it out! </span><span class="koboSpan" id="kobo.368.3">Get rid of it; if you just want to recover it, I bet you’re using a versioning control system (such as Git or Subversion) that will do </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">the trick.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">Watch out </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.371.1">also for so-called </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">dead comments</span></strong><span class="koboSpan" id="kobo.373.1">. </span><span class="koboSpan" id="kobo.373.2">As we mentioned before, our view on comments is that there should be as few as possible and focused on explaining </span><em class="italic"><span class="koboSpan" id="kobo.374.1">why</span></em><span class="koboSpan" id="kobo.375.1"> something is done. </span><span class="koboSpan" id="kobo.375.2">In an ideal and fantastic world, the code itself should be able to explain without needing extra comments. </span><span class="koboSpan" id="kobo.375.3">What often – very often – happens is that comments don’t get updated along with the code, becoming not only irrelevant but also harmful, sometimes misleading. </span><span class="koboSpan" id="kobo.375.4">Even if you’re taught to add lots of comments to code in school (at least, I was), please try to keep it to </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">a minimum.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">What we’ve said about dead code can of course be applied also to modules, services, or even individual features. </span><span class="koboSpan" id="kobo.377.2">It’s quite common to see the proliferation of modules and services deployed in production that are no longer actually used, and their only effect is to consume precious (read: expensive) resources. </span><span class="koboSpan" id="kobo.377.3">Typically, everyone forgets about them until it’s time to update them (for example, due to a discovered vulnerability among their dependencies) or when someone realizes they’re costing a lot of money in hardware resources! </span><span class="koboSpan" id="kobo.377.4">In the case of features, it’s similar: why keep unused features that make the code more complex without any real benefit? </span><span class="koboSpan" id="kobo.377.5">Get rid of them at the first opportunity, and you won’t </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">regret it!</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">We’ve seen a very important part of code refactoring, and we’ve learned some techniques for moving pieces of code without too much disruption. </span><span class="koboSpan" id="kobo.379.2">In addition to being in the right place, features must be well structured and organized. </span><span class="koboSpan" id="kobo.379.3">Let’s see some suggestions </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">about this.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.381.1">Organizing data</span></h1>
<p><span class="koboSpan" id="kobo.382.1">How data is </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.383.1">organized is one of the most important aspects of our profession; coherently aggregating information forms the foundation for building a solid, maintainable, and extensible software project. </span><span class="koboSpan" id="kobo.383.2">Various types of refactoring assist us in this regard, and once again, Fowler helps us navigate them in great detail. </span><span class="koboSpan" id="kobo.383.3">In the upcoming sections, we will present a selection of those we consider to be the most common or </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">potentially misleading.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.385.1">Field encapsulation</span></h2>
<p><span class="koboSpan" id="kobo.386.1">We will group </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.387.1">together in a single section techniques </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.388.1">that we believe are very similar to each other and ultimately concerned with not revealing the internal structure of a class to its users. </span><span class="koboSpan" id="kobo.388.2">This principle is </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.389.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">encapsulation</span></strong><span class="koboSpan" id="kobo.391.1"> and is one of the fundamental concepts of </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.393.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.394.1">OOP</span></strong><span class="koboSpan" id="kobo.395.1">); hiding the internal structure of </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.396.1">a class and providing access methods to its fields is beneficial because it simplifies the use of the class, protects data, improves maintainability, encapsulates behavior, and allows access control. </span><span class="koboSpan" id="kobo.396.2">Data is not separated from the associated behaviors, the modularity of program sections is not compromised, and maintenance is simplified. </span><span class="koboSpan" id="kobo.396.3">To achieve encapsulation starting from a public field, it is sufficient to make the field private and expose so-called </span><em class="italic"><span class="koboSpan" id="kobo.397.1">getter</span></em><span class="koboSpan" id="kobo.398.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.399.1">setter</span></em><span class="koboSpan" id="kobo.400.1"> methods. </span><span class="koboSpan" id="kobo.400.2">For example, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
class Flight {
    public Airport departureAirport;
}</span></pre> <p><span class="koboSpan" id="kobo.403.1">This would become </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
class Flight {
    private Airport departureAirport;
    public Airport getDepartureAirport() {
        return departureAirport;
    }
    public void setDepartureAirport(Airport departureAirport) {
        this.departureAirport = departureAirport;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.406.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">departureAirport</span></strong><span class="koboSpan" id="kobo.408.1"> field has been made private, and we expose two methods that respectively </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.409.1">read and write the field itself. </span><span class="koboSpan" id="kobo.409.2">If you </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.410.1">want to make the class immutable – something we highly recommend in general – you would just need to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">departureAirport</span></strong><span class="koboSpan" id="kobo.412.1"> final, add it to the constructor, and eliminate the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.413.1">setter</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">Someone might argue that this way, we still expose the class’s structure, and... </span><span class="koboSpan" id="kobo.415.2">they would be right! </span><span class="koboSpan" id="kobo.415.3">However, keep in mind that this is a very simple case: for example, it’s not necessary for getters and setters to exist for all fields or that they must exclusively perform read or write operations on the fields – they could also involve some logic (but be cautious about performance in </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">this case!).</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">Another important note: starting from Java 14, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Record</span></strong><span class="koboSpan" id="kobo.419.1"> keyword was introduced – a construct that allows you to define a class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Flight</span></strong><span class="koboSpan" id="kobo.421.1"> in a single line, with less boilerplate. </span><span class="koboSpan" id="kobo.421.2">You can refer to the </span><em class="italic"><span class="koboSpan" id="kobo.422.1">Further reading</span></em><span class="koboSpan" id="kobo.423.1"> section for </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">more details.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">We can also encapsulate the field within the class itself. </span><span class="koboSpan" id="kobo.425.2">Let’s extend our </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Flight</span></strong><span class="koboSpan" id="kobo.427.1"> class a bit, assuming that we also need to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">departureAirport</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.429.1">field internally:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
class Flight {
    private Airport departureAirport;
    // getter and setter
    public String getDepartureAirportCode(){
        return this.departureAirport.getAirportCode();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.431.1">At times, directly accessing a private field within a class may lack the desired flexibility. </span><span class="koboSpan" id="kobo.431.2">You have the option to execute intricate operations when data within the field is set or received – tasks such as </span><em class="italic"><span class="koboSpan" id="kobo.432.1">lazy initialization</span></em><span class="koboSpan" id="kobo.433.1"> and validation of field values can be effortlessly incorporated within the field’s getters and setters. </span><span class="koboSpan" id="kobo.433.2">Other than that, you’d have the ability to override getters and setters </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">in subclasses.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">Flight</span></strong><span class="koboSpan" id="kobo.437.1"> class would look like this (please observe the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">getDepartureAirportCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1"> method):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
class Flight {
    private Airport departureAirport;
    // setter
    public Airport getDepartureAirport() {
        return departureAirport;
    }
    public String getDepartureAirportCode(){
        return this.getDepartureAirport().getAirportCode();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.441.1">Someone </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.442.1">could argue that we gained in flexibility but </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.443.1">lost a bit in readability because of the need to read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">getDepartureAirport</span></strong><span class="koboSpan" id="kobo.445.1"> method; someone else could say that this is untrue, as long as the methods are named well and represent just a getter; we’re also promoting loose coupling. </span><span class="koboSpan" id="kobo.445.2">It’s up to you to choose which path </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">to follow.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">The final case of encapsulation that we want to present concerns collections, and I have indeed seen this problem many times. </span><span class="koboSpan" id="kobo.447.2">In this case, the class contains a field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">Collection</span></strong><span class="koboSpan" id="kobo.449.1"> type, and its getters and setters operate on the entire collection, making it more challenging to interact with it. </span><span class="koboSpan" id="kobo.449.2">Modifying the previous examples slightly, let’s suppose we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Flight</span></strong><span class="koboSpan" id="kobo.451.1"> class that contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">Collection</span></strong><span class="koboSpan" id="kobo.453.1"> field of airports, one for </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">each stopover:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.455.1">
class Flight {
    private List&lt;Airport&gt; itineraryAirports;
    public List&lt;Airport&gt; getItineraryAirports() {
        return itineraryAirports;
    }
    public void setItineraryAirports(List&lt;Airport&gt; itineraryAirports) {
        this.itineraryAirports = itineraryAirports;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.456.1">The protocol for </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.457.1">utilizing these collections differs slightly from that employed by other data types. </span><span class="koboSpan" id="kobo.457.2">It is important to note that the getter method </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.458.1">should not return the actual collection object itself. </span><span class="koboSpan" id="kobo.458.2">Doing so would permit clients to manipulate the contents of the collection without the owner class’s awareness. </span><span class="koboSpan" id="kobo.458.3">Moreover, this would reveal an excessive amount of the object’s internal data structure to clients. </span><span class="koboSpan" id="kobo.458.4">Instead, the method for retrieving collection elements should provide a value that prevents any modifications to the collection and avoids revealing too much information about its structure. </span><span class="koboSpan" id="kobo.458.5">There should be no method for directly assigning a value to a collection. </span><span class="koboSpan" id="kobo.458.6">Instead, the protocol should provide operations for adding and deleting elements. </span><span class="koboSpan" id="kobo.458.7">This approach empowers the owner object to exercise control over the addition and removal of elements within </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the collection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
class Flight {
    private List&lt;Airport&gt; itineraryAirports;
    public List&lt;Airport&gt; getItineraryAirports() {
        return Collections.unmodifiableList(itineraryAirports);
    }
    public void addAirport(Airport itineraryAirport) {
        this.itineraryAirports.add(itineraryAirport);
    }
    public void removeAirport(Airport itineraryAirport) {
        this.itineraryAirports.remove(itineraryAirport);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.461.1">We have </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.462.1">removed the setter method and added two </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.463.1">methods for adding and removing elements from the list. </span><span class="koboSpan" id="kobo.463.2">When we return the list through the getter, we instantiate a new immutable list using Java 17’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">Collections::unmodifiableList</span></strong><span class="koboSpan" id="kobo.465.1"> methods (but we could have used Guava, Apache Commons, </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">or whatever).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.467.1">A couple of disclaimers</span></p>
<p class="callout"><span class="koboSpan" id="kobo.468.1">We are modifying objects, which goes against the concept of immutability that we have advocated for on these pages, so please be cautious. </span><span class="koboSpan" id="kobo.468.2">Also, remember that the type of the collection for which you are performing add and remove operations (in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Airport</span></strong><span class="koboSpan" id="kobo.470.1">) must override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">equals</span></strong><span class="koboSpan" id="kobo.472.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">hashCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1"> methods.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.475.1">Replacing primitives with objects</span></h2>
<p><span class="koboSpan" id="kobo.476.1">This refactoring </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.477.1">comes to our rescue when dealing with the code </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.478.1">smell called </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">Primitive Obsession</span></strong><span class="koboSpan" id="kobo.480.1">, which we encountered in </span><a href="B20912_03.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.481.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.482.1">. </span><span class="koboSpan" id="kobo.482.2">This happens when we use integer, double, string types, and so on, instead of more complex types; these primitives are fine if we only need to print this information without any special logic. </span><span class="koboSpan" id="kobo.482.3">But often, we discover that things are more complicated than that. </span><span class="koboSpan" id="kobo.482.4">Going on with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">Flight</span></strong><span class="koboSpan" id="kobo.484.1"> class, this time, let’s assume that a field containing the service level, also known as “cabin class,” is defined, </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
class Flight {
    private String cabinClass;
    public Flight(String cabinClass) {
        this.cabinClass = cabinClass;
    }
    //getter and toString
}</span></pre> <p><span class="koboSpan" id="kobo.487.1">If we wanted to filter from a list of flights only the most expensive ones, we would have to do something </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
var expensiveFlights = flightList.stream().filter(f -&gt; f.getCabinClass().equals("Business") || f.getCabinClass().equals("First Class")).collect(Collectors.toList());</span></pre> <p><span class="koboSpan" id="kobo.490.1">It’s not ideal. </span><span class="koboSpan" id="kobo.490.2">I need to know what all the possible values for the cabin class are, and I must know </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.491.1">exactly which one is more expensive than the other. </span><span class="koboSpan" id="kobo.491.2">In these cases, it’s better to use a class to replace the primitive type, allowing not only wrapping but also the implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">custom logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
var expensiveFlights = flightList.stream().filter(f -&gt; f.getCabinClass().higherThan(new CabinClass("Economy"))).collect(Collectors.toList());</span></pre> <p><span class="koboSpan" id="kobo.494.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">higherThan</span></strong><span class="koboSpan" id="kobo.496.1"> method allows us to implement a logic that compares our cabin class to another, without worrying about managing and maintaining the </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">logic itself.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">I think it is worth taking a look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">CabinClass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.500.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.501.1">
public class CabinClass {
    private final String name;
    private final int value;
    public CabinClass(String name) {
        this.name = name;
        switch (name) {
            case "Economy":
                value = 1;
                break;
            case "Premium":
                value = 2;
                break;
            case "Business":
                value = 3;
                break;
            case "First":
                value = 4;
                break;
            default:
                throw new IllegalArgumentException();
        }
    }
    //getters
    public boolean higherThan(CabinClass other){
        return this.getValue() &gt; other.getValue();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.502.1">It has a </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.503.1">name and a value; the latter is used to determine the position in the “value scale” of the cabin classes, and it is assigned to the class constructor. </span><span class="koboSpan" id="kobo.503.2">We still have a lot of strings around, but I think we can do better. </span><span class="koboSpan" id="kobo.503.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">go ahead.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.505.1">Replacing type code with subclasses</span></h2>
<p><span class="koboSpan" id="kobo.506.1">Let’s start with the previous example, that of the cabin class. </span><span class="koboSpan" id="kobo.506.2">You may have noticed that defining </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.507.1">the “type” of the cabin class by passing a string in the constructor is not ideal. </span><span class="koboSpan" id="kobo.507.2">In a simple scenario, we could make a typo while writing the type; in reality, the real issue is that we are delegating to the caller knowledge that should be internal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">CabinClass</span></strong><span class="koboSpan" id="kobo.509.1"> class. </span><span class="koboSpan" id="kobo.509.2">When we have a situation such as this, a situation in which our class has a “type,” and the behavior of the class itself can depend on this type, a useful refactoring is to create subclasses. </span><span class="koboSpan" id="kobo.509.3">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">CabinClass</span></strong><span class="koboSpan" id="kobo.511.1"> class would then become </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
public class CabinClass {
    protected final String name;
    protected final int value;
    protected CabinClass(String name, int value) {
        this.name = name;
        this.value = value;
    }
    //getters, toString, and higherThan
}</span></pre> <p><span class="koboSpan" id="kobo.514.1">But we </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.515.1">would also have a series of subclasses defined </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
public class Economy extends CabinClass{
    public Economy() {
        super("Economy", 1);
    }
}
public class Premium extends CabinClass{
    public Premium() {
        super("Premium", 2);
    }
}
public class Business extends CabinClass{
    public Business() {
        super("Business", 3);
    }
}
public class First extends CabinClass{
    public First() {
        super("First", 4);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.518.1">Notice how the parameters are defined within the constructor, and how it is impossible for the caller to modify them. </span><span class="koboSpan" id="kobo.518.2">In this way, among other things, we leverage all the advantages </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.519.1">of OOP, and code readability is also improved as a result. </span><span class="koboSpan" id="kobo.519.2">For completeness, here is a snippet that filters expensive flights, </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">modified accordingly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
var economyClass = new Economy();
var expensiveFlights = flightList.stream().filter(f -&gt; f.getCabinClass().higherThan(economyClass)).toList();</span></pre> <p><span class="koboSpan" id="kobo.522.1">Notice that we simply instantiate an </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">Economy</span></strong><span class="koboSpan" id="kobo.524.1"> class to be used into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">higherThan</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">Organizing data well means, at the end of the day, simplifying things – or at least making them more readable. </span><span class="koboSpan" id="kobo.527.2">One thing that can make code very complicated to read is conditional logic. </span><span class="koboSpan" id="kobo.527.3">Let’s see how you can simplify it </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">a bit.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.529.1">Simplifying conditional logic</span></h1>
<p><span class="koboSpan" id="kobo.530.1">For this section, we will also rely on Martin Fowler and try to explain some of the refactorings </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.531.1">to what we consider to be the most common problems. </span><span class="koboSpan" id="kobo.531.2">The selection is arbitrary and based solely on our experience. </span><span class="koboSpan" id="kobo.531.3">For further details, we refer you to the </span><em class="italic"><span class="koboSpan" id="kobo.532.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.533.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.534.1"> section.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.535.1">Returning a special case instead of null</span></h2>
<p><span class="koboSpan" id="kobo.536.1">Do not return </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">null</span></strong><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">This is a mantra that everyone – even engineers with years of experience – sometimes forgets. </span><span class="koboSpan" id="kobo.538.3">There are cases where a method should return a result but cannot: some error </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.539.1">in the execution flow; some exceptional cases. </span><span class="koboSpan" id="kobo.539.2">Java and many other languages allow returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">null</span></strong><span class="koboSpan" id="kobo.541.1">, but it’s preferable not to do so for obvious reasons – among them, avoiding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">NullPointerException</span></strong><span class="koboSpan" id="kobo.543.1"> in the caller or forcing it to check every time that the method’s result is </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.547.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.548.1">Tony Hoare introduced Null references in </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">ALGOL W</span></strong><span class="koboSpan" id="kobo.550.1"> back in 1965 “simply because it was so easy to implement,” according to him. </span><span class="koboSpan" id="kobo.550.2">Reflecting on that decision, he refers to it as his “billion-dollar mistake”. </span><span class="koboSpan" id="kobo.550.3">More on this in the </span><em class="italic"><span class="koboSpan" id="kobo.551.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.552.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">There are various ways to avoid null references, but one of the most common is to return a so-called </span><strong class="bold"><span class="koboSpan" id="kobo.555.1">Special Case</span></strong><span class="koboSpan" id="kobo.556.1"> object, which is a default object with </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">predefined values.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Take, for example, the following </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.560.1">
CustomerAddress customerAddress = addressRepository.findByCustomerId(customer.getId());
if (customerAddress == null) {
   customerStreet = "Unknown";
   customerCity = "Unknown";
} else {
   customerStreet = customerAddress.getStreet();
   customerCity = customerAddress.getCity();
}</span></pre> <p><span class="koboSpan" id="kobo.561.1">We can notice </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.562.1">how we need to differentiate the logic by checking if the object returned by the repository is </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">null</span></strong><span class="koboSpan" id="kobo.564.1">. </span><span class="koboSpan" id="kobo.564.2">In this case, it wouldn’t even be very useful if the repository method returned an </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Optional</span></strong><span class="koboSpan" id="kobo.566.1"> because we would still need to write an </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">if</span></strong><span class="koboSpan" id="kobo.568.1"> statement; in our opinion, however, it would be better because it would at least make the caller aware that the call may not return the desired result. </span><span class="koboSpan" id="kobo.568.2">One solution, though, is to introduce a Special Case object. </span><span class="koboSpan" id="kobo.568.3">Here is a possible implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">in Java:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
interface CustomerAddress {
    String getStreet();
    String getCity();
}</span></pre> <p><span class="koboSpan" id="kobo.571.1">We introduce an interface that allows us to implement the special case, and then we implement it in </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">two classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.573.1">
class UnknownCustomerAddress implements CustomerAddress {
    @Override
    public String getStreet() {
        return "unknown";
    }
    @Override
    public String getCity() {
        return "unknown";
    }
}
class ActualCustomerAddress implements CustomerAddress {
    String street;
    String city;
   //constructor and getters
}</span></pre> <p><span class="koboSpan" id="kobo.574.1">Notice </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.575.1">how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">ActualCustomerAddress</span></strong><span class="koboSpan" id="kobo.577.1"> class is the actual “real” one, while the other is a kind of “dummy object” used to allow the caller to not change the execution flow when calling the method. </span><span class="koboSpan" id="kobo.577.2">Of course, we have the (small?) disadvantage of creating more classes than there were before; the cleanliness of the code greatly benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">from this.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">In theory, we could </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.580.1">also craft a specific exception for our situation and throw that instead of giving back a fake object. </span><span class="koboSpan" id="kobo.580.2">But, honestly, we don’t see that happening a lot (and we’re not big fans of it!). </span><span class="koboSpan" id="kobo.580.3">Still, it is worth acknowledging this for the sake </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">of completeness.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.582.1">Using polymorphism instead of conditions</span></h2>
<p><span class="koboSpan" id="kobo.583.1">Let’s revisit a code smell discussed in </span><a href="B20912_03.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.584.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.585.1">: repeated switches. </span><span class="koboSpan" id="kobo.585.2">When there is a lot of conditional logic, it’s better to introduce some structure. </span><span class="koboSpan" id="kobo.585.3">When a </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">switch</span></strong><span class="koboSpan" id="kobo.587.1"> statement is repeated </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.588.1">many times in the code, especially around a variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">type</span></strong><span class="koboSpan" id="kobo.590.1">, it’s highly likely that refactoring is a </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">better approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.592.1">
public Long calculateDistance(Itinerary itinerary) {
    Long distance;
    switch (itinerary.getType()) {
        case "TRAIN": {
            var departureLocation = getDepartureStation(itinerary);
            var arrivalLocation = getArrivalStation(itinerary);
            distance = calculateItineraryDistance(departureLocation, arrivalLocation);
            break;
        }
        case "FLIGHT": {
            var departureLocation = getDepartureAirport(itinerary);
            var arrivalLocation = getArrivalAirport(itinerary);
            distance = calculateItineraryDistance(departureLocation, arrivalLocation);
            break;
        }
        default:
            throw new IllegalArgumentException("Unknown type");
    }
    return distance;
}</span></pre> <p><span class="koboSpan" id="kobo.593.1">In this method, which calculates the distance traveled in a travel itinerary – whether it’s by plane </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.594.1">or by train – we encounter several issues. </span><span class="koboSpan" id="kobo.594.2">The caller must be aware of the possible values that </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">type</span></strong><span class="koboSpan" id="kobo.596.1"> can take, implementing different logic at each point in the code where it’s needed. </span><span class="koboSpan" id="kobo.596.2">Furthermore, we anticipate that there will be other points in the code where it needs to behave differently based on the type </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">of itinerary.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">Instead, we can simply </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">utilize polymorphism:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.600.1">
abstract class Itinerary {
    public abstract Long calculateItineraryDistance();
}
final class FlightItinerary extends Itinerary {
    @Override
    public Long calculateItineraryDistance() {
        //calculations for a flight...
</span><span class="koboSpan" id="kobo.600.2">    }
}
final class TrainItinerary extends Itinerary {
    @Override
    public Long calculateItineraryDistance() {
        //calculations for a train...
</span><span class="koboSpan" id="kobo.600.3">    }
}</span></pre> <p><span class="koboSpan" id="kobo.601.1">Polymorphism in </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.602.1">the previous code allows us to treat different types of itineraries (</span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">FlightItinerary</span></strong><span class="koboSpan" id="kobo.604.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">TrainItinerary</span></strong><span class="koboSpan" id="kobo.606.1">) as instances of a common base class (</span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">Itinerary</span></strong><span class="koboSpan" id="kobo.608.1">). </span><span class="koboSpan" id="kobo.608.2">This enables you to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">calculateItineraryDistance</span></strong><span class="koboSpan" id="kobo.610.1"> method on them without knowing their specific types, promoting code flexibility and reuse, and creating two classes that extend the same abstract class. </span><span class="koboSpan" id="kobo.610.2">At this point, the caller will no longer have to worry </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">about anything:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
public Long calculateDistance(Itinerary itinerary) {
    Long distance = itinerary.calculateItineraryDistance();
    return distance;
}</span></pre> <h2 id="_idParaDest-131"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.613.1">Removing duplicated conditions</span></h2>
<p><span class="koboSpan" id="kobo.614.1">It can sometimes happen that identical code is duplicated within the two branches of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">if</span></strong><span class="koboSpan" id="kobo.616.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">else</span></strong><span class="koboSpan" id="kobo.618.1"> block in a </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.619.1">conditional statement. </span><span class="koboSpan" id="kobo.619.2">Why this happens, I honestly couldn’t say; however, I can testify that I’ve seen it more often when methods are very long or as a result of refactoring. </span><span class="koboSpan" id="kobo.619.3">In my humble opinion, it’s usually a simple oversight, but it’s an oversight that happens more often than you might think. </span><span class="koboSpan" id="kobo.619.4">For example, in the previous example, we can observe precisely that </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">calculateItineraryDistance(departureLocation, arrivalLocation);</span></strong><span class="koboSpan" id="kobo.621.1"> is called in two different cases within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">switch</span></strong><span class="koboSpan" id="kobo.623.1"> statement. </span><span class="koboSpan" id="kobo.623.2">In general, when we are in a condition in which the same call is repeated, we can do </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
var result = doCalculations(x, y);
if (doCalculations(x, y) &gt; 5) {
    //do something
    printResult(result);
} else {
    //do something else
    printResult(result);
}</span></pre> <p><span class="koboSpan" id="kobo.626.1">The advice </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.627.1">is simply to take the duplicate call out of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">if</span></strong><span class="koboSpan" id="kobo.629.1"> statement, </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.631.1">
var result = doCalculations(x, y);
if (doCalculations(x, y) &gt; 5) {
    //do something
} else {
    //do something else
}
printResult(result);</span></pre> <p><span class="koboSpan" id="kobo.632.1">Keep in mind that maybe the method in question does not exist yet; however, there is repeated code </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.633.1">that you can put together using the </span><strong class="bold"><span class="koboSpan" id="kobo.634.1">Extract </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.635.1">Method</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.636.1"> technique.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.637.1">Guard clauses</span></h2>
<p><span class="koboSpan" id="kobo.638.1">The last piece </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.639.1">of advice I give you is on simplifying conditional logic concerns’ nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">if </span></strong><span class="koboSpan" id="kobo.641.1">statements; I must admit that I suffer a lot when I find them, with the code moving further and further to the right of the screen, almost forming mandalas that need a really large monitor to be appreciated! </span><span class="koboSpan" id="kobo.641.2">A slope toward </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">the abyss.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">Here is an example of a method that, in addition to being very trivial, has many nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">if</span></strong><span class="koboSpan" id="kobo.645.1"> statements. </span><span class="koboSpan" id="kobo.645.2">It takes </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.646.1">three parameters as input and finds the largest, but none of them must </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">be negative:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
public void printLargestPositive(int x, int y, int z) {
    if (x &gt; 0) {
        if (y &gt; 0) {
            if (z &gt; 0) {
                if (x &gt; y &amp;&amp; x &gt; z) {
                    print("x is the largest.");
                } else if (y &gt; x &amp;&amp; y &gt; z) {
                    print("y is the largest.");
                } else {
                    print("z is the largest.");
                }
            } else {
                print("z is not positive.");
            }
        } else {
            print("y is not positive.");
        }
    } else {
        print("x is not positive.");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.649.1">Understanding the purpose and functionality of each conditional is challenging due to the lack of clarity in a typical code execution flow. </span><span class="koboSpan" id="kobo.649.2">These conditionals suggest a disorganized development process, with each condition added as a temporary solution without considering the optimization of the </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">overall structure.</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">To simplify the situation, separate exceptional cases into distinct conditions that promptly terminate </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.652.1">execution and return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">null</span></strong><span class="koboSpan" id="kobo.654.1"> value if the guard clauses are evaluated as </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">true</span></strong><span class="koboSpan" id="kobo.656.1">. </span><span class="koboSpan" id="kobo.656.2">Essentially, your goal here is to streamline the code structure and make it more linear, </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
public void printLargestPositiveRefactored(int x, int y, int z){
    if (x &lt;= 0) {
        print("x is not positive.");
        return;
    }
    if (y &lt;= 0) {
        print("y is not positive.");
        return;
    }
    if (z &lt;= 0) {
        print("z is not positive.");
        return;
    }
    if (x &gt; y &amp;&amp; x &gt; z) {
        print("x is the largest.");
    } else if (y &gt; x &amp;&amp; y &gt; z) {
        print("y is the largest.");
    } else {
        print("z is the largest.");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.659.1">We know this code could be even more rewritten, but it’s just for explaining the concept. </span><span class="koboSpan" id="kobo.659.2">Some might argue that this method has too many returns within it and that it would be better </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.660.1">to have only one. </span><span class="koboSpan" id="kobo.660.2">I can’t say, honestly, if there are too many, but it’s a good point to observe. </span><span class="koboSpan" id="kobo.660.3">I agree, however, with what Steve McConnell says in his book, </span><em class="italic"><span class="koboSpan" id="kobo.661.1">Code Complete</span></em><span class="koboSpan" id="kobo.662.1">: use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">return</span></strong><span class="koboSpan" id="kobo.664.1"> statement when it makes your code easier to understand. </span><span class="koboSpan" id="kobo.664.2">In some functions, as soon as you have the answer, just give it back to the calling function right away. </span><span class="koboSpan" id="kobo.664.3">If the function doesn’t need any extra cleanup after finding an error, not returning immediately would mean having to write </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">more code.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">Also, if the code is mainly focused on performance, stopping after the most usual condition can skip some extra checks. </span><span class="koboSpan" id="kobo.666.2">This can be really helpful, especially if one or two situations make up the majority, like 80 or 90% of the time </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">it runs.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.668.1">Simplifying method calls</span></h1>
<p><span class="koboSpan" id="kobo.669.1">Method calls are </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.670.1">essential in OOP, as they enable objects to perform specific tasks or actions. </span><span class="koboSpan" id="kobo.670.2">There are many techniques intended to simplify the way objects interact with each other; we’re going to see some of the most </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">interesting ones.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.672.1">Avoiding side effects</span></h2>
<p><span class="koboSpan" id="kobo.673.1">We already discussed the side effects and mutability of objects in </span><a href="B20912_03.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.674.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.675.1">, explaining why they are </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.676.1">not ideal in a software project. </span><span class="koboSpan" id="kobo.676.2">A typical way to cause side effects is when you mix a query, which is a part of the code that simply retrieves information, and a modifier, which is code that performs an action on some data or system, thereby changing its state. </span><span class="koboSpan" id="kobo.676.3">Here’s an example </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">of this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
public Price getTotalItineraryPrice(User user, Itinerary itinerary){
    Price totalPrice = calculateTotalPrice(itinerary);
    emailService.sendPriceRecap(user);
    return totalPrice;
}</span></pre> <p><span class="koboSpan" id="kobo.679.1">In this example, the method calculates the total price for a specific travel itinerary and simultaneously sends a summary email to the customer. </span><span class="koboSpan" id="kobo.679.2">We have several issues here. </span><span class="koboSpan" id="kobo.679.3">First (but this is the least of them), the name is misleading because it is not consistent with the actual </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.680.1">behavior of the method. </span><span class="koboSpan" id="kobo.680.2">Furthermore, the method does more than one thing; particularly, it returns information (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">Price</span></strong><span class="koboSpan" id="kobo.682.1"> instance) on one hand, but on the other hand, it changes the state of things by notifying the user. </span><span class="koboSpan" id="kobo.682.2">It’s better to separate these concerns, </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
public Price getTotalItineraryPrice(Itinerary itinerary) {
    return calculateTotalPrice(itinerary);
}
public void sendEmailRecap(User user) {
    emailService.sendPriceRecap(user);
}</span></pre> <p><span class="koboSpan" id="kobo.685.1">We now have two distinct methods, one that requests information and another that somehow modifies the system’s state. </span><span class="koboSpan" id="kobo.685.2">It’s worth noting that a query method can be called as many times as desired without affecting the system’s state. </span><span class="koboSpan" id="kobo.685.3">The code is cleaner, and we have also removed a parameter from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">getTotalItineraryPrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.687.1"> method.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.688.1">Removing setter methods</span></h2>
<p><span class="koboSpan" id="kobo.689.1">Actually, this section </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.690.1">should almost be a continuation of the previous one. </span><span class="koboSpan" id="kobo.690.2">Removing so-called </span><em class="italic"><span class="koboSpan" id="kobo.691.1">setter</span></em><span class="koboSpan" id="kobo.692.1"> methods, which allow you to set the value of an object’s field, makes them immutable, removing undesirable </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">side effects.</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">We’ve already discussed this in this chapter, but we’d like to go into a bit more detail. </span><span class="koboSpan" id="kobo.694.2">Let’s consider </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.695.1">a very simple class representing a person; let’s include only two fields </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">for simplicity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.697.1">
class Person {
    private String taxCode;
    private String name;
    public String getTaxCode() {
        return taxCode;
    }
    public void setTaxCode(String taxCode) {
        this.taxCode = taxCode;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.698.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">Person</span></strong><span class="koboSpan" id="kobo.700.1"> class is represented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">taxCode</span></strong><span class="koboSpan" id="kobo.702.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">name</span></strong><span class="koboSpan" id="kobo.704.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">taxCode</span></strong><span class="koboSpan" id="kobo.706.1"> is unique and represents the identifier for a person. </span><span class="koboSpan" id="kobo.706.2">As we see, you can instantiate this class and set its fields, </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.708.1">
Person p = new Person();
p.setTaxCode("4598308JKFLD3424243");
p.setName("John Doe");</span></pre> <p><span class="koboSpan" id="kobo.709.1">If we returned </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.710.1">this instance to a calling method, no one would guarantee that its fields would not be modified. </span><span class="koboSpan" id="kobo.710.2">The refactoring in question simply aims to remove setter methods, adding its parameter inside the constructor, </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.712.1">
Person p = new Person("4598308JKFLD3424243");
p.setName("John Doe");</span></pre> <p><span class="koboSpan" id="kobo.713.1">Notice how </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">taxCode</span></strong><span class="koboSpan" id="kobo.715.1"> is passed inside the constructor. </span><span class="koboSpan" id="kobo.715.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">Person</span></strong><span class="koboSpan" id="kobo.717.1"> class, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">taxCode</span></strong><span class="koboSpan" id="kobo.719.1"> field can then </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">become </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">final</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.723.1">True immutability – the builder pattern</span></h3>
<p><span class="koboSpan" id="kobo.724.1">To make an </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.725.1">object truly immutable in each of its fields, we recommend using the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.726.1">builder pattern</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">The builder pattern is a design pattern used to construct complex objects step by step. </span><span class="koboSpan" id="kobo.728.2">It separates the construction of an object from its representation, allowing you to create different representations of the </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">same object.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">Here’s how </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.731.1">the builder pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">typically works:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.733.1">Create a builder class</span></strong><span class="koboSpan" id="kobo.734.1">: First, you create a separate builder class for constructing an object. </span><span class="koboSpan" id="kobo.734.2">This builder class has methods for setting the various attributes of the object you want </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">to create.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.736.1">Set attributes</span></strong><span class="koboSpan" id="kobo.737.1">: You use the methods in the builder class to set the attributes of the object. </span><span class="koboSpan" id="kobo.737.2">Each method typically returns the builder object itself, allowing you to chain method calls (this is known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.738.1">method chaining</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.740.1">Build</span></strong><span class="koboSpan" id="kobo.741.1">: When you’ve set all the desired attributes, you call a </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">build</span></strong><span class="koboSpan" id="kobo.743.1"> method on the builder </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.744.1">object, which constructs and returns the final object with the </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">specified configuration.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.746.1">A builder </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.747.1">class for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">Person</span></strong><span class="koboSpan" id="kobo.749.1"> class would look </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
public final class PersonBuilder {
    private String name;
    private final String taxCode;
    private PersonBuilder(String taxCode) {
        this.taxCode = taxCode;
    }
    public static PersonBuilder builder(String taxCode) {
        return new PersonBuilder(taxCode);
    }
    public PersonBuilder name(String name) {
        this.name = name;
        return this;
    }
    public Person build() {
        Person person = new Person(taxCode);
        person.setName(name);
        return person;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.752.1">You can clearly see a static </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">builder</span></strong><span class="koboSpan" id="kobo.754.1"> method that instantiates the builder itself, taking </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">taxCode</span></strong><span class="koboSpan" id="kobo.756.1"> as its only parameter, which is mandatory. </span><span class="koboSpan" id="kobo.756.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">name</span></strong><span class="koboSpan" id="kobo.758.1"> method is just a setter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">name</span></strong><span class="koboSpan" id="kobo.760.1"> attribute; you can have one setter for each field of your class. </span><span class="koboSpan" id="kobo.760.2">At the end, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">build</span></strong><span class="koboSpan" id="kobo.762.1"> method creates and populates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">Person</span></strong><span class="koboSpan" id="kobo.764.1">. </span><span class="koboSpan" id="kobo.764.2">Using the builder pattern on a </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.765.1">type is meaningful as long as you do not provide any other method to instantiate that type; for example, you can keep the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">Person</span></strong><span class="koboSpan" id="kobo.767.1"> type private and create </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">builder</span></strong><span class="koboSpan" id="kobo.769.1"> as an </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">inner class.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">The usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">PersonBuilder</span></strong><span class="koboSpan" id="kobo.773.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">quite straightforward:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
Person p = PersonBuilder.builder("4598308JKFLD3424243")
        .name("John Doe")
        .build();</span></pre> <p><span class="koboSpan" id="kobo.776.1">Once the object has been built (instantiated), you cannot modify its fields. </span><span class="koboSpan" id="kobo.776.2">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">builder</span></strong><span class="koboSpan" id="kobo.778.1"> method (in this instance, the builder, in fact, and not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">Person</span></strong><span class="koboSpan" id="kobo.780.1"> class) takes as a parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">taxCode</span></strong><span class="koboSpan" id="kobo.782.1">, which </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">is mandatory.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">There are tools to automate the creation of builder classes, which we will discuss later in </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">the book.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.786.1">Using generalization</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.787.1">Generalization</span></strong><span class="koboSpan" id="kobo.788.1"> is one of the </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.789.1">most powerful features of OOP, and it must be used wisely (</span><em class="italic"><span class="koboSpan" id="kobo.790.1">with great power comes great responsibility</span></em><span class="koboSpan" id="kobo.791.1">). </span><span class="koboSpan" id="kobo.791.2">I’ll report here just some of the most interesting refactorings in this area, going fast with the most basic and delving a little bit deeper with </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">the others.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.793.1">Pull up field</span></h2>
<p><span class="koboSpan" id="kobo.794.1">This technique </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.795.1">consists of moving a field (or variable) from a subclass </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.796.1">to a superclass. </span><span class="koboSpan" id="kobo.796.2">This is typically done when multiple subclasses share the same field or when you want to establish a common interface or behavior in the superclass. </span><span class="koboSpan" id="kobo.796.3">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
public class Triangle {
    private Integer sidesNumber;
}
public class Square {
    private Integer sidesNumber;
}</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">Triangle</span></strong><span class="koboSpan" id="kobo.800.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">Square</span></strong><span class="koboSpan" id="kobo.802.1"> have a field </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.803.1">in common; just extract </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.804.1">an interface or an </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">abstract</span></strong><span class="koboSpan" id="kobo.806.1"> class to do </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">the trick:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.808.1">
public abstract class Polygon {
    private Integer sidesNumber;
}
public class Square extends Polygon {
}
public class Triangle extends Polygon{
}</span></pre> <h2 id="_idParaDest-138"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.809.1">Push down field</span></h2>
<p><span class="koboSpan" id="kobo.810.1">This is the </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.811.1">opposite of a pull down field, and it’s used when </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.812.1">you have a field (or attribute) defined in a superclass, but it’s only relevant to a specific subclass or a subset of subclasses. </span><span class="koboSpan" id="kobo.812.2">You just have to move the field from the superclass to the subclass where it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">actually used.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">For example, let’s take a </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">Vehicle</span></strong><span class="koboSpan" id="kobo.816.1"> class containing a single field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">engine</span></strong><span class="koboSpan" id="kobo.818.1">. </span><span class="koboSpan" id="kobo.818.2">We have two subclasses extending </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">from it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.820.1">
public class Vehicle {
    protected EngineType engine;
}
public class Car extends Vehicle{
}
public class Bicycle extends Vehicle{
}</span></pre> <p><span class="koboSpan" id="kobo.821.1">While it makes </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.822.1">sense for a Car to have an engine, of course, it doesn’t </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.823.1">for a Bicycle. </span><span class="koboSpan" id="kobo.823.2">Let’s move the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">engine</span></strong><span class="koboSpan" id="kobo.825.1"> field into the only class it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">be in:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.827.1">
public class Vehicle {
}
public class Car extends Vehicle{
    protected EngineType engine;
}
public class Bicycle extends Vehicle{
}</span></pre> <h2 id="_idParaDest-139"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.828.1">Pull up method</span></h2>
<p><span class="koboSpan" id="kobo.829.1">This consists of moving a method from a subclass to a superclass. </span><span class="koboSpan" id="kobo.829.2">This is typically done when multiple </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.830.1">subclasses share a common behavior, and you </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.831.1">want to establish that behavior in the superclass to promote code reuse. </span><span class="koboSpan" id="kobo.831.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
public class Triangle extends Polygon{
    public Long calculatePerimeter(){
        //calculations...
</span><span class="koboSpan" id="kobo.833.2">    }
}
public class Square extends Polygon {
    public Long calculatePerimeter(){
        //calculations...
</span><span class="koboSpan" id="kobo.833.3">    }
}</span></pre> <p><span class="koboSpan" id="kobo.834.1">It’s worth </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.835.1">pulling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">calculatePerimeter</span></strong><span class="koboSpan" id="kobo.837.1"> method up in </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.838.1">the superclass and removing the method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">Triangle</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.840.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">Square</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.843.1">
public abstract class Polygon {
    private Integer sidesNumber;
    public Long calculatePerimeter(){
        //calculations...
</span><span class="koboSpan" id="kobo.843.2">    }
}
public class Triangle extends Polygon{
}
public class Square extends Polygon {
}</span></pre> <h2 id="_idParaDest-140"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.844.1">Push down method</span></h2>
<p><span class="koboSpan" id="kobo.845.1">This is the opposite of the pull up method, and it is used when you have a method defined </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.846.1">in a superclass, but its behavior is relevant only </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.847.1">to a specific subclass or a subset of subclasses. </span><span class="koboSpan" id="kobo.847.2">You just have to move the method from the superclass to the subclass where it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">actually used.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">For example, let’s take again a </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">Vehicle</span></strong><span class="koboSpan" id="kobo.851.1"> class containing a single method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">fillTank</span></strong><span class="koboSpan" id="kobo.853.1">. </span><span class="koboSpan" id="kobo.853.2">We also have two subclasses extending </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">from it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.855.1">
public class Vehicle {
    protected void fillTank() {
        //method implementation
    }
}
public class Car extends Vehicle{
}
public class Bycicle extends Vehicle{
}</span></pre> <p><span class="koboSpan" id="kobo.856.1">As you can </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.857.1">easily guess, having a </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">fillTank</span></strong><span class="koboSpan" id="kobo.859.1"> method doesn’t </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.860.1">make any sense for a class representing a bicycle, but only for a class representing a car. </span><span class="koboSpan" id="kobo.860.2">So, what we’re gonna do is just push the method down onto the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">Car</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.862.1"> subclass:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.863.1">
public class Vehicle {
}
public class Car extends Vehicle{
    protected void fillTank() {
        //method implementation
    }
}
public class Bycicle extends Vehicle{
}</span></pre> <h2 id="_idParaDest-141"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.864.1">Template method</span></h2>
<p><span class="koboSpan" id="kobo.865.1">It often </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.866.1">happens, when we program, that we have algorithms or processes of some kind to apply to objects in a way that is almost entirely similar </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.867.1">but not exactly the same. </span><span class="koboSpan" id="kobo.867.2">A certain logic may apply generally to an entire category of objects, but these objects may have some specific characteristics that make them different. </span><span class="koboSpan" id="kobo.867.3">In the previous examples, we used the classic example of polygons. </span><span class="koboSpan" id="kobo.867.4">We can say that for a polygon, the calculation of the perimeter always involves summing the lengths of its respective sides. </span><span class="koboSpan" id="kobo.867.5">However, between a triangle and a square, for example, the number of sides changes. </span><span class="koboSpan" id="kobo.867.6">Therefore, it could be useful to have a method in the superclass that is implemented in the subclasses and represents their specific characteristics. </span><span class="koboSpan" id="kobo.867.7">I believe it’s easier to explain this with </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.869.1">
public class Triangle extends Polygon {
    private final Long aLength; //length of side a
    private final Long bLength; //length of side b
    private final Long cLength; //length of side c
    public Triangle(Long aLength, Long bLength, Long cLength) {
        this.aLength = aLength;
        this.bLength = bLength;
        this.cLength = cLength;
    }
    public Long getPerimeter() {
        return aLength + bLength + cLength;
    }
}
public class Square extends Polygon {
    private final Long sideLength;
    public Square(Long sideLength) {
        this.sideLength = sideLength;
    }
    public Long getPerimeter() {
        return sideLength * 4;
    }
}
public abstract class Polygon {
}</span></pre> <p><span class="koboSpan" id="kobo.870.1">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">Triangle</span></strong><span class="koboSpan" id="kobo.872.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">Square</span></strong><span class="koboSpan" id="kobo.874.1"> have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">getPerimeter</span></strong><span class="koboSpan" id="kobo.876.1"> method that basically sums up the length </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.877.1">of their sides; we could not just pull up the method, because the </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.878.1">implementation is different – one has three potentially different sides, and the other has four equal sides. </span><span class="koboSpan" id="kobo.878.2">What we’re going to do is implement a template method, in which we will call another method defined in the subclasses, which just returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">Collection</span></strong><span class="koboSpan" id="kobo.880.1"> field of </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">side lengths:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.882.1">
public class Triangle extends Polygon {
    private final Long aLength; //length of side a
    private final Long bLength; //length of side b
    private final Long cLength; //length of side c
    public Triangle(Long aLength, Long bLength, Long cLength) {
        this.aLength = aLength;
        this.bLength = bLength;
        this.cLength = cLength;
    }
    @Override
    protected Collection&lt;Long&gt; getSideLengths() {
        return List.of(aLength, bLength, cLength);
    }
}
public class Square extends Polygon {
    private final Long sideLength;
    public Square(Long sideLength) {
        this.sideLength = sideLength;
    }
    @Override
    protected Collection&lt;Long&gt; getSideLengths() {
        return List.of(sideLength, sideLength, sideLength, sideLength);
    }
}
public abstract class Polygon {
    public Long getPerimeter() {
        Collection&lt;Long&gt; sideLengths = getSideLengths();
        Long perimeter = 0L;
        for (Long length : sideLengths) {
            perimeter += length;
        }
        return perimeter;
    }
    protected abstract Collection&lt;Long&gt; getSideLengths();
}</span></pre> <p><span class="koboSpan" id="kobo.883.1">We have created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">getSideLengths</span></strong><span class="koboSpan" id="kobo.885.1"> template method that reduces redundancy by consolidating </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.886.1">common algorithmic steps in a superclass </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.887.1">while allowing distinctions to remain in the subclasses. </span><span class="koboSpan" id="kobo.887.2">This is a </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.888.1">vibrant example of the </span><strong class="bold"><span class="koboSpan" id="kobo.889.1">Open/Closed Principle</span></strong><span class="koboSpan" id="kobo.890.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.891.1">OCP</span></strong><span class="koboSpan" id="kobo.892.1">) in practice. </span><span class="koboSpan" id="kobo.892.2">If a new version of the algorithm is introduced, you can simply create a new subclass without needing to modify the </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">existing code.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.894.1">Using enums instead of constants</span></h1>
<p><span class="koboSpan" id="kobo.895.1">At this point, we have seen some of the main refactoring techniques discussed in the literature. </span><span class="koboSpan" id="kobo.895.2">Now, we move on to a final section where we allow ourselves to give you a couple of tips </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.896.1">on how to better organize your code design. </span><span class="koboSpan" id="kobo.896.2">These may seem trivial, but they often lead to considerable annoyance. </span><span class="koboSpan" id="kobo.896.3">The first tip, as the title of this section suggests, concerns the excessive use of constants (a thorough study based solely on my perception and experience undoubtedly shows that these constants will be strings 99% of </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">the time).</span></span></p>
<p><span class="koboSpan" id="kobo.898.1">Let’s suppose we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">following class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.900.1">
public class Itinerary {
    private String transportType;
    private String cabinClass;
    //getters and setters
}</span></pre> <p><span class="koboSpan" id="kobo.901.1">In another class, we </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.902.1">defined the </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">following constants:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
private static final String FLIGHT = "FLIGHT";
private static final String TRAIN = "TRAIN";
private static final String ECONOMY = "ECONOMY";
private static final String FIRSTCLASS = "FIRSTCLASS";</span></pre> <p><span class="koboSpan" id="kobo.905.1">In one method, let’s instantiate our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">Itinerary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.907.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.908.1">
Itinerary itinerary = new Itinerary();
itinerary.setCabinClass(FLIGHT);
itinerary.setTransportType(ECONOMY);</span></pre> <p><span class="koboSpan" id="kobo.909.1">Do you see anything weird? </span><span class="koboSpan" id="kobo.909.2">We accidentally swapped </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">cabinClass</span></strong><span class="koboSpan" id="kobo.911.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">transportType</span></strong><span class="koboSpan" id="kobo.913.1">! </span><span class="koboSpan" id="kobo.913.2">We didn’t even realize it because everything compiles when we’re just dealing with strings. </span><span class="koboSpan" id="kobo.913.3">If we don’t really need to create custom types to represent these concepts, such as the transport type and the cabin class, our suggestion is to </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">use enums.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">In fact, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">introduce enums:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
enum TransportType {FLIGHT, TRAIN}
enum CabinClass {ECONOMY, FIRSTCLASS}</span></pre> <p><span class="koboSpan" id="kobo.918.1">We can then rewrite the code </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
public class Itinerary {
    private TransportType transportType;
    private CabinClass cabinClass;
    public Enums.TransportType getTransportType() {
        return transportType;
    }
    public void setTransportType(Enums.TransportType transportType) {
        this.transportType = transportType;
    }
    public Enums.CabinClass getCabinClass() {
        return cabinClass;
    }
    public void setCabinClass(Enums.CabinClass cabinClass) {
        this.cabinClass = cabinClass;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.921.1">This will then </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.922.1">be used without the possibility </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">of error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.924.1">
Itinerary itinerary = new Itinerary();
itinerary.setCabinClass(CabinClass.ECONOMY);
itinerary.setTransportType(TransportType.FLIGHT);</span></pre> <p><span class="koboSpan" id="kobo.925.1">Using enums is generally better than constants in Java because they offer </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.927.1">Type safety</span></strong><span class="koboSpan" id="kobo.928.1">: Enums are types themselves, meaning they allow you to define a set of distinct </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.929.1">values that are of the same type. </span><span class="koboSpan" id="kobo.929.2">This prevents you from accidentally using incorrect values in your code, reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">runtime errors.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.931.1">Readability</span></strong><span class="koboSpan" id="kobo.932.1">: Enums </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.933.1">provide meaningful names for each of their values, making the code self-documenting. </span><span class="koboSpan" id="kobo.933.2">This improves code readability and comprehension because you can understand the purpose of each value just by looking at </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">its name.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.935.1">IDE support</span></strong><span class="koboSpan" id="kobo.936.1">: IDEs offer </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.937.1">features such as code completion and error checking specific to enums. </span><span class="koboSpan" id="kobo.937.2">When you use constants, you may not get the same level of support, and you might need to remember or look up </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">valid values.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.939.1">Refactoring ease</span></strong><span class="koboSpan" id="kobo.940.1">: When </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.941.1">you need to change or add a value, enums make it easier. </span><span class="koboSpan" id="kobo.941.2">IDEs can automatically update all references to the enum value throughout your code, reducing the chances of errors </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">during maintenance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.943.1">Additional behaviors</span></strong><span class="koboSpan" id="kobo.944.1">: Enums can have methods and fields associated with them, allowing </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.945.1">you to encapsulate behavior related to each enum value. </span><span class="koboSpan" id="kobo.945.2">For example, you can define a method that calculates a specific value or behavior for each enum, improving code organization </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">and maintainability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.947.1">Enum-specific collections</span></strong><span class="koboSpan" id="kobo.948.1">: Java provides specialized data structures such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">EnumSet</span></strong><span class="koboSpan" id="kobo.950.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">EnumMap</span></strong><span class="koboSpan" id="kobo.952.1"> that are highly efficient when working with enums. </span><span class="koboSpan" id="kobo.952.2">These collections </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.953.1">are tailored to work specifically with enum values, making your code more concise </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">and performant.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.955.1">Compile-time checking</span></strong><span class="koboSpan" id="kobo.956.1">: Errors related to incorrect constant values may only surface </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.957.1">at runtime, potentially causing unexpected issues. </span><span class="koboSpan" id="kobo.957.2">In contrast, issues with enums, such as missing values or incorrect references, are caught by the compiler, ensuring that your code is correct before </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">it’s executed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.959.1">Serialization support</span></strong><span class="koboSpan" id="kobo.960.1">: Enums have built-in support for serialization and deserialization, which </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.961.1">simplifies tasks such as saving enum values to a file or transmitting them over </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">a network.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.963.1">Basically, when you use enums in Java, you get a bunch of benefits compared to plain constants. </span><span class="koboSpan" id="kobo.963.2">These perks include making your code safer, easier to read, and simpler to maintain. </span><span class="koboSpan" id="kobo.963.3">Enums also play well with your development tools, making your life easier. </span><span class="koboSpan" id="kobo.963.4">But that’s not to say constants don’t have their uses – they do, especially in specific situations. </span><span class="koboSpan" id="kobo.963.5">However, for most cases where you have a fixed set of values with some extra behavior, enums are the way </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">to go.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.965.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.966.1">Here we are, at the end of this journey through refactoring techniques. </span><span class="koboSpan" id="kobo.966.2">We hope we’ve given you some ideas on how to craft methods better, making them clear and readable. </span><span class="koboSpan" id="kobo.966.3">We’ve explored how it can sometimes be helpful to shuffle features between objects and better organize your data. </span><span class="koboSpan" id="kobo.966.4">We’ve simplified conditional logic (you know – those </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">if</span></strong><span class="koboSpan" id="kobo.968.1"> statements and switches that help us solve problems quickly but can make our code unreadable!). </span><span class="koboSpan" id="kobo.968.2">We’ve simplified method calls, used a bit of good old generalization, and talked briefly about the immutability of objects. </span><span class="koboSpan" id="kobo.968.3">In the next chapter, we’ll dive into how to use automated tools to (hopefully!) make our code </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">even better.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.970.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.971.1">For other examples and use cases: Martin Fowler, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.972.1">Refactoring</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">, Addison-Wesley</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.974.1">Null references: The Billion Dollar </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.975.1">mistake</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">: </span></span><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/"><span class="No-Break"><span class="koboSpan" id="kobo.977.1">https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/</span></span></a></li>
</ul>
</div>
</body></html>