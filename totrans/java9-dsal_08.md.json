["```java\npublic class BinarySearchTree<E extends Comparable<E>> extends BinaryTree<E> {\n\n    protected Node<E> searchValue(E value, Node<E> root){\n        if(root==null){\n            return null;\n        }\n        int comp = root.getValue().compareTo(value);\n        if(comp == 0){\n            return root;\n        }else if(comp>0){\n            return searchValue(value, root.getLeft());\n        }else{\n            return  searchValue(value, root.getRight());\n        }\n    }\n```", "```java\n    public Node<E> searchValue(E value){\n        if(getRoot()==null){\n            return null;\n        }else{\n            return searchValue(value, getRoot());\n        }\n    }\n    …\n\n}\n```", "```java\n    protected Node<E> insertValue(E value, Node<E> node){\n        int comp = node.getValue().compareTo(value);\n        Node<E> child;\n        if(comp<=0){\n            child = node.getRight();\n            if(child==null){\n                return addChild(node,value,false);\n            }else{\n                return insertValue(value, child);\n            }\n        }else if(comp>0){\n            child = node.getLeft();\n            if(child==null){\n                return addChild(node,value,true);\n            }else{\n                return insertValue(value, child);\n            }\n        }else{\n            return null;\n        }\n    }\n```", "```java\n    public Node<E> insertValue(E value){\n        if(getRoot()==null){\n            addRoot(value);\n            return getRoot();\n        }else{\n            return insertValue(value, getRoot());\n        }\n    }\n```", "```java\nBinarySearchTree<Integer> tree = new BinarySearchTree<>();\nfor(int i=0;i<20;i++){\n    int value = (int) (100*Math.random());\n    tree.insertValue(value);\n}\ntree.traverseDepthFirst((x)->System.out.print(\"\"+x), tree.getRoot(), DepthFirstTraversalType.INORDER);\n```", "```java\n    public void deleteNodeWithSubtree(Node<E> node){\n        if(node == null){\n            throw new NullPointerException(\"Cannot delete to null parent\");\n        }else if(node.containerTree != this){\n            throw new IllegalArgumentException(\n                \"Node does not belong to this tree\");\n        }else {\n            if(node==getRoot()){\n                root=null;\n                return;\n            }else{\n                Node<E> partent = node.getParent();\n                if(partent.getLeft()==node){\n                    partent.left = null;\n            }else{\n                partent.right = null;\n            }\n        }\n    }\n}\n```", "```java\n    public void setValue(Node<E> node, E value){\n        if(node == null){\n            throw new NullPointerException(\"Cannot add node to null parent\");\n        }else if(node.containerTree != this){\n            throw new IllegalArgumentException(\n                     \"Parent does not belong to this tree\");\n        }else {\n            node.value = value;\n        }\n    }\n```", "```java\n    public Node<E> setChild(Node<E> parent, Node<E> child, boolean left){\n        if(parent == null){\n            throw new NullPointerException(\"Cannot set node to null parent\");\n        }else if(parent.containerTree != this){\n            throw new IllegalArgumentException(\n                \"Parent does not belong to this tree\");\n        }else {\n            if(left){\n                parent.left = child;\n            }else{\n                parent.right = child;\n            }\n            if(child!=null) {\n                child.parent = parent;\n            }\n            return child;\n        }\n    }\n```", "```java\n    protected Node<E> getLeftMost(Node<E> node){\n        if(node==null){\n            return null;\n        }else if(node.getLeft()==null){\n            return node;\n        }else{\n            return getLeftMost(node.getLeft());\n        }\n    }\n```", "```java\n    private Node<E> deleteNode(Node<E> nodeToBeDeleted) {\n\n        boolean direction;\n        if(nodeToBeDeleted.getParent()!=null\n           && nodeToBeDeleted.getParent().getLeft()==nodeToBeDeleted){\n            direction = true;\n        }else{\n            direction = false;\n        }\n```", "```java\n        if(nodeToBeDeleted.getLeft()==null &&\n            nodeToBeDeleted.getRight()==null){\n            deleteNodeWithSubtree(nodeToBeDeleted);\n            return nodeToBeDeleted;\n        }\n```", "```java\n        else if(nodeToBeDeleted.getLeft()==null){\n            if(nodeToBeDeleted.getParent() == null){\n                root = nodeToBeDeleted.getRight();\n            }else {\n                setChild(nodeToBeDeleted.getParent(),\n                nodeToBeDeleted.getRight(), direction);\n            }\n             return nodeToBeDeleted;\n         }\n```", "```java\n        else if(nodeToBeDeleted.getRight()==null){\n            if(nodeToBeDeleted.getParent() == null){\n                root = nodeToBeDeleted.getLeft();\n            }else {\n                setChild(nodeToBeDeleted.getParent(),\n                nodeToBeDeleted.getLeft(), direction);\n            }\n            return nodeToBeDeleted;\n        }\n```", "```java\n        else{\n         Node<E> nodeToBeReplaced = getLeftMost(nodeToBeDeleted.getRight());\n            setValue(nodeToBeDeleted, nodeToBeReplaced.getValue());\n            deleteNode(nodeToBeReplaced);\n            return nodeToBeReplaced;\n        }\n    }\n```", "```java\nn = 1 + 2 + 4+ … + 2(h-1) = 2h – 1\n=> 2h = (n+1) \n=> h = lg (n+ 1)\n```", "```java\n    protected void rotate(Node<E> node, boolean left){\n```", "```java\n        if(node == null){\n            throw new IllegalArgumentException(\"Cannot rotate null node\");\n        }else if(node.containerTree != this){\n            throw  new IllegalArgumentException(\n                \"Node does not belong to the current tree\");\n        }\n        Node<E> child = null;\n        Node<E> grandchild = null;\n        Node<E> parent = node.getParent();\n        boolean parentDirection;\n```", "```java\n        if(left){\n            child = node.getRight();\n            if(child!=null){\n                grandchild = child.getLeft();\n            }\n        }else{\n            child = node.getLeft();\n            if(child!=null){\n                grandchild = child.getRight();\n            }\n        }\n```", "```java\n        if(node != getRoot()){\n            if(parent.getLeft()==node){\n                parentDirection = true;\n            }else{\n                parentDirection = false;\n            }\n            if(grandchild!=null)\n                deleteNodeWithSubtree(grandchild);\n            if(child!=null)\n                deleteNodeWithSubtree(child);\n                deleteNodeWithSubtree(node);\n            if(child!=null) {\n                setChild(parent, child, parentDirection);\n                setChild(child, node, left);\n            }\n            if(grandchild!=null)\n                setChild(node, grandchild, !left);\n        }else{\n            if(grandchild!=null)\n                deleteNodeWithSubtree(grandchild);\n            if(child!=null)\n                deleteNodeWithSubtree(child);\n                deleteNodeWithSubtree(node);\n            if(child!=null) {\n                root = child;\n                setChild(child, node, left);\n            }\n            if(grandchild!=null)\n                setChild(node, grandchild, !left);\n                root.parent = null;\n        }\n    }\n```", "```java\npublic class AVLTree<E extends Comparable<E>> \n          extends BinarySearchTree<E>{\n    public static class Node<E extends Comparable<E>> \n              extends BinaryTree.Node{\n        protected int height = 0;\n        public Node(BinaryTree.Node parent,\n                    BinaryTree containerTree, E value) {\n            super(parent, containerTree, value);\n        }\n    }\n```", "```java\n    @Override\n    protected BinaryTree.Node<E> newNode(\n      BinaryTree.Node<E> parent, BinaryTree<E> containerTree, E value) {\n        return new Node(parent, containerTree, value);\n    }\n```", "```java\n    private int nullSafeHeight(Node<E> node){\n        if(node==null){\n            return 0;\n        }else{\n            return node.height;\n        }\n    }\n```", "```java\n    private void nullSafeComputeHeight(Node<E> node){\n        Node<E> left = (Node<E>) node.getLeft();\n        Node<E> right = (Node<E>) node.getRight();\n        int leftHeight = left==null? 0 : left.height;\n        int rightHeight = right==null? 0 :right.height;\n        node.height =  Math.max(leftHeight, rightHeight)+1;\n    }\n```", "```java\n    @Override\n    protected void rotate(BinaryTree.Node<E> node, boolean left) {\n        Node<E> n = (Node<E>) node;\n        Node<E> child;\n        if(left){\n            child = (Node<E>) n.getRight();\n        }else{\n            child = (Node<E>) n.getLeft();\n        }\n        super.rotate(node, left);\n        if(node!=null){\n            nullSafeComputeHeight(n);\n        }\n        if(child!=null){\n            nullSafeComputeHeight(child);\n        }\n    }\n```", "```java\n    protected void rebalance(Node<E> node){\n        if(node==null){\n            return;\n        }\n        nullSafeComputeHeight(node);\n        int leftHeight = nullSafeHeight((Node<E>) node.getLeft());\n        int rightHeight = nullSafeHeight((Node<E>) node.getRight());\n        switch (leftHeight-rightHeight){\n            case -1:\n            case 0:\n            case 1:\n                rebalance((Node<E>) node.getParent());\n                break;\n            case 2:\n                int childLeftHeight = nullSafeHeight(\n                        (Node<E>) node.getLeft().getLeft());\n                int childRightHeight = nullSafeHeight(\n                        (Node<E>) node.getLeft().getRight());\n                if(childRightHeight > childLeftHeight){\n                    rotate(node.getLeft(), true);\n                }\n                Node<E> oldParent = (Node<E>) node.getParent();\n                rotate(node, false);\n                rebalance(oldParent);\n                break;\n            case -2:\n                childLeftHeight = nullSafeHeight(\n                        (Node<E>) node.getRight().getLeft());\n                childRightHeight = nullSafeHeight(\n                        (Node<E>) node.getRight().getRight());\n                if(childLeftHeight > childRightHeight){\n                    rotate(node.getRight(), false);\n                }\n                oldParent = (Node<E>) node.getParent();\n                rotate(node, true);\n                rebalance(oldParent);\n                break;\n        }\n    }\n```", "```java\n  @Override\n    public BinaryTree.Node<E> insertValue(E value) {\n        Node<E> node = (Node<E>) super.insertValue(value);\n        if(node!=null)\n            rebalance(node);\n            return node;\n    }\n```", "```java\n@Override\n    public BinaryTree.Node<E> deleteValue(E value) {\n        Node<E> node = (Node<E>) super.deleteValue(value);\n        if(node==null){\n            return null;\n        }\n        Node<E> parentNode = (Node<E>) node.getParent();\n        rebalance(parentNode);\n        return node;\n    }\n```", "```java\nf(h) = f(h-1) + f(h-2) + 1\n```", "```java\nf(h) ≥ Fh where Fh is the hth Fibonacci number.\n```", "```java\nf(h) ≥ C φ h\n=>n ≥ C  φ h\n=> log φn ≥  h +  log φ C\n=> h = O(  log φn) = O(lg n)\n```", "```java\npublic class RedBlackTree<E extends Comparable<E>> extends BinarySearchTree<E>{\n    public static class Node<E> extends BinaryTree.Node<E>{\n        protected int blackHeight = 0;\n        protected boolean black = false;\n        public Node(BinaryTree.Node parent,\n                    BinaryTree containerTree, E value) {\n            super(parent, containerTree, value);\n        }\n    }\n\n    @Override\n    protected  BinaryTree.Node<E> newNode(\n      BinaryTree.Node<E> parent, BinaryTree<E> containerTree, E value) {\n        return new Node(parent, containerTree, value);\n    }\n...\n}\n```", "```java\n    protected boolean nullSafeBlack(Node<E> node){\n        if(node == null){\n            return true;\n        }else{\n            return node.black;\n        }\n    }\n```", "```java\n    protected void rebalanceForInsert(Node<E> node){\n        if(node.getParent() == null){\n            node.black = true;\n        }else{\n            Node<E> parent = (Node<E>) node.getParent();\n            if(parent.black){\n                return;\n            }else{\n                Node<E> grandParent = (Node<E>) parent.getParent();\n                boolean nodeLeftGrandChild = grandParent.getLeft()== parent;\n\n                Node<E> uncle = nodeLeftGrandChild?\n                  (Node<E>) grandParent.getRight()\n                  : (Node<E>) grandParent.getLeft();\n                if(!nullSafeBlack(uncle)){\n                    if(grandParent!=root)\n                        grandParent.black = false;\n                        uncle.black = true;\n                        parent.black = true;\n                        rebalanceForInsert(grandParent);\n                }else{\n                    boolean middleChild = nodeLeftGrandChild?\n                      parent.getRight() == node:parent.getLeft() == node;\n                    if (middleChild){\n                        rotate(parent, nodeLeftGrandChild);\n                        node = parent;\n                        parent = (Node<E>) node.getParent();\n                    }\n                    parent.black = true;\n                    grandParent.black = false;\n                    rotate(grandParent, !nodeLeftGrandChild);\n                }\n            }\n\n        }\n    }\n```", "```java\n    @Override\n    public BinaryTree.Node<E> insertValue(E value) {\n        Node<E> node = (Node<E>) super.insertValue(value);\n        if(node!=null)\n            rebalanceForInsert(node);\n        return node;\n    }\n```", "```java\n    protected void rebalanceForDelete(Node<E> parent, boolean nodeDirectionLeft){\n        if(parent==null){\n            return;\n        }\n        Node<E> node = (Node<E>) (nodeDirectionLeft? parent.getLeft(): parent.getRight());\n        if(!nullSafeBlack(node)){\n            node.black = true;\n            return;\n        }\n\n        Node<E> sibling = (Node<E>) (nodeDirectionLeft? parent.getRight(): parent.getLeft());\n\n        Node<E> nearNephew = (Node<E>) (nodeDirectionLeft?sibling.getLeft():sibling.getRight());\n\n        Node<E> awayNephew = (Node<E>) (nodeDirectionLeft?sibling.getRight():sibling.getLeft());\n\n        if(parent.black){\n            if(sibling.black){\n                if(nullSafeBlack(nearNephew) && nullSafeBlack(awayNephew)){\n                    sibling.black = false;\n                    if(parent.getParent()!=null){\n                        rebalanceForDelete (\n                          (Node<E>) parent.getParent(),\n                          parent.getParent().getLeft() == parent);\n                    }\n                }else if(!nullSafeBlack(awayNephew)){\n                    awayNephew.black = true;\n                    rotate(parent, nodeDirectionLeft);\n                }else{\n                    nearNephew.black = true;\n                    rotate(sibling, !nodeDirectionLeft);\n                    rotate(parent, nodeDirectionLeft);\n                }\n\n            }else{\n                parent.black = false;\n                sibling.black = true;\n                rotate(parent, nodeDirectionLeft);\n                rebalanceForDelete(parent, nodeDirectionLeft);\n            }\n        }else{\n\n            if(nullSafeBlack(nearNephew)){\n                rotate(parent, nodeDirectionLeft);\n            }else{\n                parent.black = true;\n                rotate(sibling, !nodeDirectionLeft);\n                rotate(parent, nodeDirectionLeft);\n            }\n        }\n\n    }\n```", "```java\n    @Override\n    public BinaryTree.Node<E> deleteValue(E value) {\n        Node<E> node = (Node<E>) super.deleteValue(value);\n\n        if(node !=null && node.black && node.getParent()!=null){\n            Node<E> parentsCurrentChild = (Node<E>) (node.getLeft() == null ? node.getRight(): node.getLeft());\n            if(parentsCurrentChild!=null){\n                boolean isLeftChild = parentsCurrentChild.getParent().getLeft() == parentsCurrentChild;\n                rebalanceForDelete(                         (Node<E>) node.getParent(), isLeftChild);\n            }else{\n                boolean isLeftChild = node.getParent().getRight()!=null;\n                rebalanceForDelete(\n                        (Node<E>) node.getParent(), isLeftChild);\n            }\n\n        }\n        return node;\n    }\n```", "```java\nf(l) = f(l-1) + 2 ( 2l-1 – 1) + 2\n=> f(l) = f(l-1) + 2l\n```", "```java\nn = f(l) =  2l+2-2\\. \n=> lg n = lg ( 2l+2-2)   \n=> lg n >  lg ( 2l+1)\n=> lg n > l+1\n=> l + 1< lg n\n=> l < lg n\n=> l = O (lg n)\n```", "```java\npublic int hashCode() {\n    int h = hash;\n     if (h == 0 && value.length > 0) {\n        char val[] = value;\n\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n         hash = h;\n    }\n    return h;\n}\n```", "```java\npublic class HashTable<E> {\n    protected LinkedList<E> [] buckets;\n    protected double maximumLoadFactor;\n    protected int totalValues;\n    public HashTable(int initialSize, double maximumLoadFactor){\n        buckets = new LinkedList[initialSize];\n        this.maximumLoadFactor = maximumLoadFactor;\n    }\n    …\n}\n```", "```java\n    protected boolean insert(E value, int arrayLength,\n                             LinkedList<E>[] array) {\n        int hashCode = value.hashCode();\n        int arrayIndex = hashCode % arrayLength;\n        LinkedList<E> bucket = array[arrayIndex];\n        if(bucket == null){\n            bucket = new LinkedList<>();\n            array[arrayIndex] = bucket;\n        }\n        for(E element: bucket){\n            if(element.equals(value)){\n                return false;\n            }\n        }\n        bucket.appendLast(value);\n        totalValues++;\n        return true;\n    }\n```", "```java\n    protected void rehash(){\n        double loadFactor = ((double)(totalValues))/buckets.length;\n        if(loadFactor>maximumLoadFactor){\n            LinkedList<E> [] newBuckets = new LinkedList[buckets.length*2];\n            totalValues = 0;\n            for(LinkedList<E> bucket:buckets){\n                if(bucket!=null) {\n                    for (E element : bucket) {\n                        insert(element, newBuckets.length, newBuckets);\n                    }\n                }\n            }\n            this.buckets = newBuckets;\n        }\n    }\n```", "```java\n    public boolean insert(E value){\n        int arrayLength = buckets.length;\n        LinkedList<E>[] array = buckets;\n        boolean inserted = insert(value, arrayLength, array);\n        if(inserted)\n            rehash();\n        return inserted;\n    }\n```", "```java\nlg n = R + lg(Bl) .\n=> R = ln n – lg (Bl) = O(lg n)\n```", "```java\npublic E search(E value){\n    int hash = value.hashCode();\n    int index = hash % buckets.length;\n    LinkedList<E> bucket = buckets[index];\n    if(bucket==null){\n        return null;\n    }else{\n        for(E element: bucket){\n            if(element.equals(value)){\n                return element;\n            }\n        }\n        return null;\n    }\n}\n```"]