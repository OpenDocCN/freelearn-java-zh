<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer090">
			</div>
		</div>
		<div class="Content" id="_idContainer091">
			<h1 id="_idParaDest-249"><a id="_idTextAnchor255"/>12. Regular Expressions</h1>
		</div>
		<div class="Content" id="_idContainer104">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter discusses regular expressions and considers both how and why they are so useful in Java. To begin, you will first explore how to construct these expressions in order to search for information in your programâ€”a fundamental skill for any developer. When you have a firm understanding of the nature and function of these regular expressions, you will be able to use them to perform simple full-body matches in your search, and, later in the chapter, to extract substrings from a text using groups and non-capturing groups. In the final exercise, you have to employ all of these skills to perform recursive matches and extract a set of similar elements (i.e. a pattern) from a text.</p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor256"/>Introduction</h1>
			<p>In your career as a developer, you will often find a search for information to be a logical first step to problem-solving: searching for documentation, searching for a specific line of code, or just making a program that extracts information from a given body of text into data that the program can understand.</p>
			<p>A regular expression is a specific language for defining these search rules, much like Java is a language to construct programs. The syntax can be quite complex. When you see a regular expression for the first time, it can be daunting.</p>
			<p>The following is a very basic pattern matcher for an email address construction, with many flaws:</p>
			<p class="source-code">/.+\@.+\..+/</p>
			<p>If you're seeing this for the first time, you might think that it's a typographical error (or that a cat was involved).  However, it's perfectly legitimate code. We'll dive deeper into the construction of this example shortly, but first, let's take a look at a more thorough pattern-matcher that validates an email address' construction:</p>
			<p class="source-code">/[a-zA-Z]+[a-zA-Z0-9]+\@[a-zA-Z0-9]{2,}\.[a-zA-Z]{2,}/</p>
			<p>This looks like even more gibberish to the novice. Perhaps the same cat was making a nest on your keyboard. </p>
			<p>In this chapter, we uncover the logic behind this madness. We will start with decrypting what regular expressions mean, then look at how this will come in handy in Java. </p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor257"/>Decrypting Regular Expressions</h1>
			<p>The way regular expressions are constructed follows some basic rules that are the same on every platform and implementation; however, there are some implementation-specific rules that might vary depending on the platform and implementation the regular expression was constructed for.</p>
			<p>Let's revisit our initial email pattern matching <strong class="source-inline">/.+\@.+\..+/</strong> expression. We can see that it starts with a slash mark like this, <strong class="source-inline">/</strong> and ends with a <strong class="source-inline">/</strong>. These are the opening and closing markers for the expression; anything within these characters belongs to the actual expression.</p>
			<p>Regular expressions are constructed from a few basic components; they are character classes, anchors, groups, and special escape characters. Then, we have the quantifiers that control how many of the preceding characters should be matched. Last but not least, we have the expression flags, which control certain behaviors for the whole expression. Let's look at them in more detail in the upcoming sections.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor258"/>Character Classes</h2>
			<p>Character classes define the sets of characters that the pattern matcher will search for. The set is defined in square brackets.</p>
			<p>The expression <strong class="source-inline">[xyz]</strong> will match an <strong class="source-inline">x</strong>, <strong class="source-inline">a y</strong>, or a <strong class="source-inline">z</strong>. These are case sensitive, so an <strong class="source-inline">X</strong> will not match. If you're matching characters that follow alphabetically, you can replace the expression with a range. Instead of <strong class="source-inline">[xyz]</strong>, you can write <strong class="source-inline">[x-z]</strong>. This is very convenient if you want to cover many characters in your expression:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer092">
					<img alt="Figure 12.1: Regular expressions for character classes&#13;&#10;" src="image/C13927_12_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1: Regular expressions for character classes</p>
			<p>There are also predefined character classes. These allow you to search for specific sets of characters without having to type out the full character set. For example, the dot (<strong class="source-inline">.</strong>) shown earlier will match any character except for line breaks. Written out in full as a set, the expression for this search would look like <strong class="source-inline">[^\n\r]</strong>, so you can see how just using <strong class="source-inline">.</strong> is quicker and easier. You can see in the following tables what the <strong class="source-inline">^</strong>, <strong class="source-inline">\n</strong>, and <strong class="source-inline">\r</strong> symbols represent.</p>
			<p>You can also search using negated sets. This will match everything that is not part of that set.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor259"/>Character Sets</h2>
			<p>A character set matches any character defined in the set. The following figure shows a couple of examples: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer093">
					<img alt="Figure 12.2: Regular expressions for character sets&#13;&#10;" src="image/C13927_12_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: Regular expressions for character sets</p>
			<p>Predefined character sets help you build quick expressions. The following figure lists predefined character sets, which are useful for building quick expressions:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 12.3: Regular expressions for predefined character sets&#13;&#10;" src="image/C13927_12_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3: Regular expressions for predefined character sets</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor260"/>Quantifiers</h2>
			<p>Quantifiers are simple rules that allow you to define how the preceding character sets should be matched. Should only one of the characters be allowed, or a range between one and three? See the following figure for acceptable quantifiers:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer095">
					<img alt="Figure 12.4: Regular expressions for quantifiers&#13;&#10;" src="image/C13927_12_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4: Regular expressions for quantifiers</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor261"/>Anchors</h2>
			<p>Anchors give you one extra dimension of control so you can define the boundaries in a text rather than the text itself:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer096">
					<img alt="Figure 12.5: Regular expressions for anchors&#13;&#10;" src="image/C13927_12_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5: Regular expressions for anchors</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor262"/>Capturing Groups</h2>
			<p>Capturing groups allow you to group tokens in an expression to form sub-strings. Any capturing token can be used within a group, including nesting other groups. They also allow for reuse in the expression using references: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer097">
					<img alt="Figure 12.6: Regular expressions for capturing groups&#13;&#10;" src="image/C13927_12_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6: Regular expressions for capturing groups</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor263"/>Escaped Characters</h2>
			<p>You can use the <strong class="source-inline">\</strong> character to escape characters to match them in the string. It is useful for matching serialized data such as XML and JSON. It is also used to match non-text characters such as a tab and a newline.</p>
			<p>Here are some common escaped characters:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer098">
					<img alt="Figure 12.7: Regular expressions for escaped characters&#13;&#10;" src="image/C13927_12_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7: Regular expressions for escaped characters</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor264"/>Flags</h2>
			<p>Any characters placed directly after the closing marker are called flags. There are five flags, which you may combine in any way, though you may avoid using flags altogether.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer099">
					<img alt="Figure 12.8: Regular expressions for flags&#13;&#10;" src="image/C13927_12_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8: Regular expressions for flags</p>
			<p>Now that you have a basic understanding of how these regular expressions work, let's look at a full-fledged example in the following exercise. </p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor265"/>Exercise 1: Implementing Regular Expressions </h2>
			<p>Using an online regular expression checker, we'll build a regular expression that verifies whether a street address is correctly specified. The format that the address follows is the street name followed by the street number. The street name and the street number are separated by a single whitespace. </p>
			<p>We will check if the following common Swedish addresses are valid or not:</p>
			<ul>
				<li>Strandvagen 1</li>
				<li>Storgatan 2</li>
				<li>Ringvagen3</li>
				<li>Storgatan<p class="callout-heading">Note:</p><p class="callout">We will use <a href="https://packt.live/2MYzyFq">https://packt.live/2MYzyFq</a> for this exercise because of its easy-to-use interface and modern feel. However, the regular expression should work on other platforms as well.</p></li>
			</ul>
			<p>To complete the exercise, perform the following steps: </p>
			<ol>
				<li>Visit <a href="https://packt.live/2MYzyFq">https://packt.live/2MYzyFq</a>.</li>
				<li>Enter three different local addresses of your choice in the space under the title <strong class="source-inline">Text</strong>, at least one should be incorrectly formatted. The addresses I've chosen are <strong class="source-inline">Strandvagen 1</strong>, <strong class="source-inline">Storgatan 2</strong>, and <strong class="source-inline">Ringvagen3</strong>. These are all very common street names in Sweden, the last of which is incorrectly formatted as it is lacking a whitespace between the street name and the number.<div class="IMG---Figure" id="_idContainer100"><img alt="Figure 12.9: Inputting incorrectly formatted text&#13;&#10;" src="image/C13927_12_09.jpg"/></div><p class="figure-caption">Figure 12.9: Inputting incorrectly formatted text</p><p>From the simple rules we defined, we can extract the following:</p><p>the street address must start with a name</p><p>the street address should have a number</p></li>
				<li>Add the first rule. The name is an alphabetic-only word (i.e. contains only letters):<div class="IMG---Figure" id="_idContainer101"><img alt="Figure 12.10: Adding the first rule&#13;&#10;" src="image/C13927_12_10.jpg"/></div><p class="figure-caption">Figure 12.10: Adding the first rule</p></li>
				<li>Let there be, at most, one empty space between the digit and the number. We can already see that one address is incorrectly formatted:<div class="IMG---Figure" id="_idContainer102"><img alt="Figure 12.11: Modifying the rule to consider one empty space between digit and number&#13;&#10;" src="image/C13927_12_11.jpg"/></div><p class="figure-caption">Figure 12.11: Modifying the rule to consider one empty space between digit and number</p></li>
				<li>Add at least one digit to the address. Now one more address has disappeared:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer103">
					<img alt="Figure 12.12: Modifying the rule to add one digit to the address&#13;&#10;" src="image/C13927_12_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.12: Modifying the rule to add one digit to the address</p>
			<p>This example shows a simple procedure to construct a regular expression to validate an address.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor266"/>Activity 1: Regular Expressions to Check If the Entrance is Entered in the Desired Format</h2>
			<p>Add one more rule to the preceding regular expression; allow for one optional character after the number. This will define which entrance to use at an address that has multiple entrancesâ€”for example, <strong class="source-inline">Strandvagen 1a</strong> or <strong class="source-inline">Ringvagen 2b</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 560.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor267"/>Regular Expressions in Java</h1>
			<p>Now that you have an idea of how regular expressions can be used to match patterns, this topic will focus on how regular expressions can be used within Java applications. To use regular expressions in Java, the <strong class="source-inline">java.util.regex</strong> package is available. The two main classes there are called <strong class="source-inline">Pattern</strong> and <strong class="source-inline">Matcher</strong>.</p>
			<p>The <strong class="source-inline">Pattern</strong> class handles the actual pattern; it validates, compiles, and returns a <strong class="source-inline">Pattern</strong> object that you can store and reuse multiple times. It can also be used to perform quick validations against a supplied string.</p>
			<p>The <strong class="source-inline">Matcher</strong> class allows us to extract more information, and to perform different kinds of matching on the supplied text.</p>
			<p>Creating a <strong class="source-inline">Pattern </strong>object is as simple as using the static <strong class="source-inline">compile</strong> method. </p>
			<p>For example, you would like to compile a pattern to ensure that a text contains at least one <strong class="source-inline">a</strong>. Your Java code should be as follows: </p>
			<p class="source-code">Pattern pattern = Pattern.compile("a+");</p>
			<p class="source-code">Matcher matcher = pattern.matcher("How much wood would a woodchuck chuck if a woodchuck could chuck wood?");</p>
			<p class="source-code">Boolean matches = matcher.matches();</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In Java, we shouldn't supply the starting and ending token of the regular expression. With the <strong class="source-inline">Pattern</strong> object, then, you can perform a match on a given string. </p>
			<p>Note that this method will attempt to match the entire string to the regular expression; if only part of the string matches the regular expression, it will return false. </p>
			<p>If, instead, you just wish to make a quick validation, you can use the static <strong class="source-inline">matches</strong> method, which will return a Boolean; it is just a shorthand for doing exactly the same as the previous example:</p>
			<p class="source-code">boolean matches = Pattern.matches("a+", "How much wood would a woodchuck chuck if a woodchuck could chuck wood?");</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor268"/>Exercise 2: Extracting the Domain Using Pattern Matching</h2>
			<p>In this exercise, you will extract every part of a URL and store them in variables, starting with the protocol, then the domain, and then finally the path:</p>
			<ol>
				<li value="1">If IntelliJ IDEA is already started, but no project is open, select <strong class="source-inline">Create New Project</strong>. If IntelliJ already has a project open, select <strong class="source-inline">File</strong> -&gt; <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Project</strong> from the menu.</li>
				<li>In the <strong class="source-inline">New Project</strong> dialog, select a Java project. Click <strong class="source-inline">Next</strong>.</li>
				<li>Check the box to create the project from a template. Select <strong class="source-inline">Command Line App</strong>. Click <strong class="source-inline">Next</strong>.</li>
				<li>Give the new project the name <strong class="source-inline">Chapter12</strong>.</li>
				<li>IntelliJ will provide a default project location. You can enter any other desired location as well.</li>
				<li>Set the package name to <strong class="source-inline">com.packt.java.chapter12</strong>.</li>
				<li>Click <strong class="source-inline">Finish</strong>. Your project will be created with the standard folder structure, and an entry point class for your program.</li>
				<li>Rename this file <strong class="source-inline">Exercise2.java</strong>. When you're done, it should look like this:<p class="source-code">package com.packt.java.chapter12;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">Â Â Â public static void main(String[] args) {</p><p class="source-code">// write your code here</p><p class="source-code">Â Â Â }</p><p class="source-code">}</p></li>
				<li>Declare this book's website <strong class="source-inline">url</strong>, which we'll split into separate parts. If you haven't visited the website yet, you can find it at <a href="https://www.packtpub.com/application-development/mastering-java-9">https://www.packtpub.com/application-development/mastering-java-9</a>:<p class="source-code">package com.packt.java.chapter12;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">Â Â Â Â public static void main(String[] args) {</p><p class="source-code">Â Â Â Â Â Â Â Â String url = "https://www.packtpub.com/application-          development/mastering-java-9";</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>We'll start by finding just the protocol using regular expressions. Declare a string to hold the regular expression and call it <strong class="source-inline">regex</strong>. It should contain at least the letters <strong class="source-inline">http</strong> and an optional <strong class="source-inline">s</strong>. Wrap the whole expression in a group to ensure you can extract it as a substring later:<p class="source-code">package com.packt.java.chapter12;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">Â Â Â Â public static void main(String[] args) {</p><p class="source-code">Â Â Â Â Â Â Â Â String url = "https://www.packtpub.com/application-development/mastering-java-9";</p><p class="source-code">Â Â Â Â Â Â Â Â String regex = "(http[s]?)";</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">This is, of course, just one example of extracting the protocol. You can experiment with finding strings before the first colon or other interesting expressions.</p></li>
				<li>Compile the expression into a <strong class="source-inline">pattern</strong> object. Since we're not performing a global match, we'll not use the shorthand. Instead, we'll create the <strong class="source-inline">Matcher</strong> for later use:<p class="source-code">package com.packt.java.chapter12;</p><p class="source-code">import java.util.regex.Matcher;</p><p class="source-code">import java.util.regex.Pattern;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">Â Â Â Â public static void main(String[] args) {</p><p class="source-code">Â Â Â Â Â Â Â Â String url = "https://www.packtpub.com/application-development/          mastering-java-9";</p><p class="source-code">Â Â Â Â Â Â Â Â String regex = "(http[s]?)";</p><p class="source-code">Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(url);</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Attempt to find the first group, using the <strong class="source-inline">find()</strong> method:<p class="source-code">package com.packt.java.chapter12;</p><p class="source-code">import java.util.regex.Matcher;</p><p class="source-code">import java.util.regex.Pattern;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">Â Â Â Â public static void main(String[] args) {</p><p class="source-code">Â Â Â Â Â Â Â Â String url = "https://www.packtpub.com/application           development/mastering-java-9";</p><p class="source-code">Â Â Â Â Â Â Â Â String regex = "(http[s]?)";</p><p class="source-code">Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(url);</p><p class="source-code">Â Â Â Â Â Â Â Â boolean foundMatches = matcher.find();</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">You can find the number of available groups using the <strong class="source-inline">groupCount()</strong> method. This is very useful if you want to loop through all groups in order.</p></li>
				<li>If any matches were found, start extracting the groups into variables. For now, simply print the variable:<p class="source-code">Â Â Â Â Â Â Â Â String url = "https://www.packtpub.com/application-          development/mastering-java-9";</p><p class="source-code">Â Â Â Â Â Â Â Â String regex = "(http[s]?)";</p><p class="source-code">Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(url);</p><p class="source-code">Â Â Â Â Â Â Â Â boolean foundMatches = matcher.find();</p><p class="source-code">Â Â Â Â Â Â Â Â if (foundMatches) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String protocol = matcher.group(1);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â System.out.println("Protocol: " + protocol);</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Before capturing the domain name, we need to ignore the useless characters between that and the protocolâ€”the <strong class="source-inline">://</strong>. Add a non-capturing group for those characters:<p class="source-code">Â Â Â Â Â Â Â Â String url = "https://www.packtpub.com/application-          development/mastering-java-9";</p><p class="source-code">Â Â Â Â Â Â Â Â String regex = "(http[s])(?:://)";</p><p class="source-code">Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(url);</p><p class="source-code">Â Â Â Â Â Â Â Â boolean foundMatches = matcher.find();</p><p class="source-code">Â Â Â Â Â Â Â Â if (foundMatches) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String protocol = matcher.group(1);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â System.out.println("Protocol: " + protocol);</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Now, add a third group to the regular expression to find the domain. We'll try to find the whole domain, letting the <strong class="source-inline">www</strong> application notation be optional: <p class="source-code">Â Â Â Â Â Â Â Â String regex = "(http[s])(?:://)([w]{0,3}\\.?[a-zA-Z]+\\.[a-zA-         Z]{2,3})";</p><p class="source-code">Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(url);</p><p class="source-code">Â Â Â Â Â Â Â Â boolean foundMatches = matcher.find();</p><p class="source-code">Â Â Â Â Â Â Â Â if (foundMatches) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String protocol = matcher.group(1);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â System.out.println("Protocol: " + protocol);</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Now, collect the domain group and print it:<p class="source-code">Â Â Â Â Â Â Â Â String regex = "(http[s])(?:://)([w]{0,3}\\.?[a-zA-Z]+\\.[a-zA-          Z]{2,3})";</p><p class="source-code">Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(url);</p><p class="source-code">Â Â Â Â Â Â Â Â boolean foundMatches = matcher.find();</p><p class="source-code">Â Â Â Â Â Â Â Â if (foundMatches) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String protocol = matcher.group(1);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String domain = matcher.group(2);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â System.out.println("Protocol: " + protocol);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â System.out.println("domain: " + domain);</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Finally, extract the <strong class="source-inline">path</strong> components and print them to the terminal:</li>
			</ol>
			<p class="source-code-heading">Exercise2.java</p>
			<p class="source-code">1Â Â package com.packt.java.chapter12;</p>
			<p class="source-code">2Â Â </p>
			<p class="source-code">3Â Â import java.util.regex.Matcher;</p>
			<p class="source-code">4Â Â import java.util.regex.Pattern;</p>
			<p class="source-code">5Â Â </p>
			<p class="source-code">6Â Â public class Exercise2 {</p>
			<p class="source-code">7Â Â </p>
			<p class="source-code">8Â Â Â Â Â Â public static void main(String[] args) {</p>
			<p class="source-code">9Â Â </p>
			<p class="source-code">10Â Â Â Â Â Â Â Â Â String url = "https://www.packtpub.com/application-             development/mastering-java-9";</p>
			<p class="source-code">11Â </p>
			<p class="source-code">12Â Â Â Â Â Â Â Â Â String regex = "(http[s])(?:://)([w]{0,3}\\.?[a-zA-Z]+\\.[a-zA-             Z]{2,3})(?:[/])(.*)";</p>
			<p class="source-code">13Â </p>
			<p class="source-code">14Â Â Â Â Â Â Â Â Â System.out.println(regex);</p>
			<p class="source-code-link"><a href="https://packt.live/2J4qn57">https://packt.live/2J4qn57</a></p>
			<p>When running this exercise, you should see the following text in the terminal:</p>
			<p class="source-code">(http[s])(?:://)([w]{0,3}\.?[a-zA-Z]+\.[a-zA-Z]{2,3})(?:[/])(.*)</p>
			<p class="source-code">Protocol: https</p>
			<p class="source-code">domain: www.packtpub.com</p>
			<p class="source-code">Path: application-development/mastering-java-9</p>
			<p>This example shows how to use capturing groups to extract only the vital information from a small string. However, you'll notice that the match is only performed once. In Java, it's easy to do a recursive match on a large body of text using similar techniques to this.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor269"/>Exercise 3: Extracting Links Using Pattern Matching</h2>
			<p>In this exercise, you'll perform a recursive matching on the Packt website to extract all links, then print these links in the terminal. For simplicity, we'll use an already saved dump of the Packt website; of course you can go ahead and download the website on your own using curl, wget, or similar tools depending on the platform you're using. You can also view the source of the website in your favorite browser and copy it to a file.</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Chapter12</strong> project in IntelliJ IDEA if it's not already open.</li>
				<li>Create a new Java class by going to <strong class="source-inline">File</strong> -&gt; <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">Exercise 3</strong> as the name and click <strong class="source-inline">OK</strong>. IntelliJ IDEA will create a new class, which should look something like this:<p class="source-code">package com.packt.java.chapter12;</p><p class="source-code">public class Exercise3 {</p><p class="source-code">}</p></li>
				<li>Create the main entry point for your program â€“ the <strong class="source-inline">static</strong> <strong class="source-inline">main </strong>method:<p class="source-code">public class Exercise3 {</p><p class="source-code">Â Â Â Â public static void main(String[] args) {</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Copy the Packt website dump into your project's <strong class="source-inline">res</strong> folder. If the folder doesn't exist, create it as a sibling to <strong class="source-inline">src</strong>.</li>
				<li>Read the contents of the file into a new string; call it <strong class="source-inline">packtDump</strong>:<p class="source-code">public class Exercise3 {</p><p class="source-code">Â Â Â Â public static void main(String[] args) {</p><p class="source-code">Â Â Â Â Â Â Â Â String filePath = System.getProperty("user.dir") + File.separator           +"res" + File.separator + "packt.txt";</p><p class="source-code">Â Â Â Â Â Â Â Â try {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String packtDump = new               String(Files.readAllBytes(Paths.get(filePath)));</p><p class="source-code">Â Â Â Â Â Â Â Â } catch (IOException e) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â e.printStackTrace();</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Start creating a regular expression for capturing links from a website. They usually look something like this. We need to look for the starting and the ending tokens of the link, and capture anything in between:<p class="source-code">&lt;a href="http://link.to/website"&gt;visible text&lt;/a&gt;</p><p>Start by looking for the opening token, <strong class="source-inline">"&lt;a href=\"</strong>:</p><p class="source-code">Â Â Â Â Â Â Â Â String filePath = System.getProperty("user.dir") + File.separator           +"res" + File.separator + "packt.txt";</p><p class="source-code">Â Â Â Â Â Â Â Â try {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String packtDump = new               String(Files.readAllBytes(Paths.get(filePath)));</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String regex = "(?:&lt;a href=\")";</p><p class="source-code">Â Â Â Â Â Â Â Â } catch (IOException e) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â e.printStackTrace();</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Add another non-capturing group for the ending token. The link ends with the next instance of double quotation marks (<strong class="source-inline">"</strong>):<p class="source-code">Â Â Â Â Â Â Â Â String filePath = System.getProperty("user.dir") + File.separator           +"res" + File.separator + "packt.txt";</p><p class="source-code">Â Â Â Â Â Â Â Â try {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String packtDump = new               String(Files.readAllBytes(Paths.get(filePath)));</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String regex = "(?:&lt;a href=\")(?:\"{1})";</p><p class="source-code">Â Â Â Â Â Â Â Â } catch (IOException e) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â e.printStackTrace();</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Finally, add the only capturing group needed for this regular expressionâ€”the link group:<p class="source-code">Â Â Â Â Â Â Â Â String filePath = System.getProperty("user.dir") + File.separator          + "res" + File.separator + "packt.txt";</p><p class="source-code">Â Â Â Â Â Â Â Â try {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String packtDump = new               String(Files.readAllBytes(Paths.get(filePath)));</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String regex = "(?:&lt;a href=\")([^\"]+)(?:\"{1})";</p><p class="source-code">Â Â Â Â Â Â Â Â } catch (IOException e) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â e.printStackTrace();</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Compile the pattern and match it against the <strong class="source-inline">packtDump</strong> string:<p class="source-code">Â Â Â Â Â Â Â Â String filePath = System.getProperty("user.dir") + File.separator           +Â Â "res" + File.separator + "packt.txt";</p><p class="source-code">Â Â Â Â Â Â Â Â try {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String packtDump = new               String(Files.readAllBytes(Paths.get(filePath)));</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String regex = "(?:&lt;a href=\")([^\"]+)(?:\"{1})";</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(packtDump);</p><p class="source-code">Â Â Â Â Â Â Â Â } catch (IOException e) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â e.printStackTrace();</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Create a list for storing the links:<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â String regex = "(?:&lt;a href=\")([^\"]+)(?:\"{1})";</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(packtDump);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â List&lt;String&gt; links = new ArrayList&lt;&gt;();</p><p class="source-code">Â Â Â Â Â Â Â Â } catch (IOException e) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â e.printStackTrace();</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Finally, loop through all matches and add them to the list. We only have one capturing group here, so there's no need to check the number of groups and loop through them:<p class="source-code">Â Â Â Â Â Â Â Â String regex<a id="_idTextAnchor270"/> = "(?:&lt;a href=\")([^\"]+)(?:\"{1})";</p><p class="source-code">Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p><p class="source-code">Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(packtDump);</p><p class="source-code">Â Â Â Â Â Â Â Â List&lt;String&gt; links = new ArrayList&lt;&gt;();</p><p class="source-code">Â Â Â Â Â Â Â Â while (matcher.find()) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â links.add(matcher.group(1));</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â Â Â Â Â } catch (IOException e) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â e.printStackTrace();</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Now you can wrap the exercise up by printing the list to the terminal:</li>
			</ol>
			<p class="source-code-heading">Exercise3.java</p>
			<p class="source-code">12Â public class Exercise3 {</p>
			<p class="source-code">13Â </p>
			<p class="source-code">14Â Â Â Â Â public static void main(String[] args) {</p>
			<p class="source-code">15Â Â Â Â Â Â Â Â Â String filePath = System.getProperty("user.dir") + File.separator +             "res" + File.separator + "packt.txt";</p>
			<p class="source-code">16Â Â Â Â Â Â Â Â Â try {</p>
			<p class="source-code">17Â Â Â Â Â Â Â Â Â Â Â Â Â String packtDump = new                 String(Files.readAllBytes(Paths.get(filePath)));</p>
			<p class="source-code">18Â Â Â Â Â Â Â Â Â Â Â Â Â String regex = "(?:&lt;a href=\")([^\"]+)(?:\"{1})";</p>
			<p class="source-code">19Â Â Â Â Â Â Â Â Â Â Â Â Â Pattern pattern = Pattern.compile(regex);</p>
			<p class="source-code">20Â Â Â Â Â Â Â Â Â Â Â Â Â Matcher matcher = pattern.matcher(packtDump);</p>
			<p class="source-code">21Â Â Â Â Â Â Â Â Â Â Â Â Â List&lt;String&gt; links = new ArrayList&lt;&gt;();</p>
			<p class="source-code">22Â Â Â Â Â Â Â Â Â Â Â Â Â while (matcher.find()) {</p>
			<p class="source-code">23Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â links.add(matcher.group(1));</p>
			<p class="source-code">24Â Â Â Â Â Â Â Â Â Â Â Â Â }</p>
			<p class="source-code">25Â Â Â Â Â Â Â Â Â Â Â Â Â System.out.println(links);</p>
			<p class="source-code-link"><a href="https://packt.live/35OorYo">https://packt.live/35OorYo</a></p>
			<p>Executing this exercise, you should see a long list of both relative and absolute links in your terminal.</p>
			<p class="source-code">[/account, #, /register, https://account.packtpub.com/, https://www.packtpub.com/account/password, #, /, /all, /tech, /, /books/content/support, https://hub.packtpub.com, ... ]</p>
			<p>You've successfully extracted the links from the Packt website. A real-world application may use this to build site-maps or otherwise document how websites are interconnected. The next step in this program is all up to you. The following steps will let you analyze the content of the Packt website more thoroughly:</p>
			<ol>
				<li value="1">Remove any non-functional links such as <strong class="source-inline">#</strong> and links back to <strong class="source-inline">home /</strong>.</li>
				<li>Also, remove all links that start with <strong class="source-inline">http</strong>; only the relative links should remain.</li>
				<li>The first path of the relative links represents the category of that book. Divide the books on the website into different categories and see which category is the most popular.</li>
			</ol>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor271"/>Summary</h1>
			<p>In this chapter, you've learned how to use regular expressions to search and extract information from large bodies of text. This can be very handy when parsing structured or semi-structured data. Regular expressions are not specific to Java. The Java implementation may differ slightly from other platforms and languages; however, the general syntax remains the same. </p>
			<p>In the next chapter, you'll explore a programming paradigm that is growing in popularity. Functional programming, while not originally intended for Java, can help you to write programs that you can test more easily, which may limit the number of state-changing problems.</p>
		</div>
	</body></html>