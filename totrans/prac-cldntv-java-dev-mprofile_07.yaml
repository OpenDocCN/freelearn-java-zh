- en: '*Chapter 5*: Enhancing Cloud-Native Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：增强云原生应用'
- en: In the previous chapter, [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications,* we learned how to build cloud-native applications.
    However, building cloud-native applications is just the start. The next step is
    to enhance the applications, by making them configurable, resilient, documentable,
    and secure. In this chapter, you will learn how to configure your cloud-native
    applications using MicroProfile Config, make your applications resilient using
    MicroProfile Fault Tolerance, document their APIs using MicroProfile OpenAPI,
    and finally, secure your applications using MicroProfile JWT. After this chapter,
    you should be able to use these technologies to improve the quality of your cloud-native
    applications. To fully comprehend this chapter, you will need some basic knowledge
    of Java, Maven, and Gradle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章[*第四章*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068)，*开发云原生应用*中，我们学习了如何构建云原生应用。然而，构建云原生应用只是开始。下一步是增强应用，使其可配置、具有弹性、可文档化和安全。在本章中，你将学习如何使用MicroProfile
    配置配置你的云原生应用，使用MicroProfile 故障容错使应用具有弹性，使用MicroProfile OpenAPI 文档其API，最后，使用MicroProfile
    JWT 保护应用。在本章之后，你应该能够使用这些技术来提高你云原生应用的质量。为了完全理解本章，你需要具备一些Java、Maven和Gradle的基本知识。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Configuring cloud-native applications using MicroProfile Config
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile 配置配置云原生应用
- en: Making cloud-native applications resilient using MicroProfile Fault Tolerance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile 故障容错使云原生应用具有弹性
- en: Documenting cloud-native applications using MicroProfile OpenAPI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile OpenAPI 文档云原生应用
- en: Securing cloud-native applications using MicroProfile JWT
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile JWT 保护云原生应用
- en: Configuring cloud-native applications using MicroProfile Config
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile 配置配置云原生应用
- en: '**MicroProfile Config** (source code located at [https://github.com/eclipse/microprofile-config](https://github.com/eclipse/microprofile-config))
    is the first specification created by the MicroProfile community. The concept
    of configuration has been around for a decade. You may recall in [*Chapter 1*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021),
    *Cloud-Native Application*, we briefly discussed the **Twelve-Factor App**, in
    which the third factor *III.* *Config* ([https://12factor.net/config](https://12factor.net/config))
    recommends that a twelve-factor app stores its configuration in an environment
    that is separate from the application code. This is because any configuration
    value update will not lead to the application code being rebuilt. But sometimes,
    it is not realistically possible to store all configs such as security credentials
    and much more in that environment. It is also common for some configuration to
    be stored in a database. Since the configuration could be in many different places,
    a mechanism for obtaining the configuration is required. Quite a few libraries
    provide this mechanism, such as Apache *DeltaSpike configuration* ([http://deltaspike.apache.org/documentation/configuration.html](http://deltaspike.apache.org/documentation/configuration.html)),
    *Apache Tamaya* ([http://tamaya.incubator.apache.org/](http://tamaya.incubator.apache.org/)),
    and many more.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile 配置**（源代码位于[https://github.com/eclipse/microprofile-config](https://github.com/eclipse/microprofile-config)）是MicroProfile社区创建的第一个规范。配置的概念已经存在十年了。你可能还记得在[*第一章*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021)，*云原生应用*中，我们简要讨论了**十二要素应用**，其中第三要素*III.*
    *配置* ([https://12factor.net/config](https://12factor.net/config))建议将十二要素应用的配置存储在与应用程序代码分离的环境中。这是因为任何配置值的更新都不会导致应用程序代码的重建。但是，有时在那种环境中存储所有配置，如安全凭证等，在现实中并不现实。将一些配置存储在数据库中也很常见。由于配置可能存在于许多不同的地方，因此需要一个获取配置的机制。许多库都提供了这种机制，例如Apache
    *DeltaSpike 配置* ([http://deltaspike.apache.org/documentation/configuration.html](http://deltaspike.apache.org/documentation/configuration.html))、*Apache
    Tamaya* ([http://tamaya.incubator.apache.org/](http://tamaya.incubator.apache.org/))等。'
- en: MicroProfile Config was created as a standard so you would not need to worry
    about which library to pull into your applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 配置被创建为一个标准，这样你就不必担心将哪个库拉入你的应用程序。
- en: In this section, we will learn how MicroProfile Config defines how configuration
    can be stored and retrieved by cloud-native applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习MicroProfile 配置如何定义云原生应用存储和检索配置的方式。
- en: Storing configuration
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储配置
- en: In MicroProfile Config, the configuration is stored in `ConfigSource` is a place
    where you can put configuration values. Environment variables, system properties,
    property files, databases, ZooKeeper, and much more can all be used as config
    sources. Each `ConfigSource` has an associated ordinal, which is used to indicate
    the importance of the `ConfigSource`. A `ConfigSource` with a higher ordinal means
    the configuration values it specifies will override the `ConfigSource` that specifies
    the same configuration with a lower ordinal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在MicroProfile Config中，配置存储在`ConfigSource`，这是一个您可以放置配置值的地方。环境变量、系统属性、属性文件、数据库、ZooKeeper等都可以用作配置源。每个`ConfigSource`都有一个关联的序号，用于指示`ConfigSource`的重要性。序号较高的`ConfigSource`意味着它指定的配置值将覆盖序号较低的指定相同配置的`ConfigSource`。
- en: For instance, the `customer_name property` is specified in a `ConfigSource`
    (ordinal = 200) with the value of `Bob`, and the same property is specified with
    the value of `Alice` in another `ConfigSource` (ordinal =120). Then when a cloud-native
    application looks up `customer_name`, the value `Bob` should be retrieved. The
    ordinal of a *ConfigSource* can be defined in the corresponding `ConfigSource`
    via the `config_ordinal` property, which indicates the ranking order of the enclosed
    config source. If not specified, the default config ordinal is 100.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`customer_name`属性在序号为200的`ConfigSource`（`ordinal = 200`）中指定为`Bob`，而在另一个序号为120的`ConfigSource`中指定为`Alice`。然后当云原生应用程序查找`customer_name`时，应该检索到`Bob`的值。`ConfigSource`的序号可以通过相应的`ConfigSource`中的`config_ordinal`属性来定义，这表示包含的配置源的排名顺序。如果没有指定，则默认配置序号为100。
- en: 'There are two types of config sources: **default config source** and **custom
    config source**, which we discuss in the next subsections.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的配置源：**默认配置源**和**自定义配置源**，我们将在下一小节中讨论。
- en: Default config sources
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认配置源
- en: '**Default config sources** are the ones mandated by MicroProfile Config and
    all MicroProfile Config implementations must provide them out of the box. MicroProfile
    Config mandates three default config sources to be supported out of the box:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认配置源**是由MicroProfile Config规定的，所有MicroProfile Config实现都必须提供这些配置源。MicroProfile
    Config规定必须支持三个默认配置源：'
- en: System properties with a default ordinal value of 400
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认序号为400的系统属性
- en: Environment variables with a default ordinal value of 300
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认序号为300的环境变量
- en: The property file `META-INF/microprofile-config.properties` found on the classpath
    with a default ordinal value of 100
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类路径上找到的属性文件`META-INF/microprofile-config.properties`，默认序号为100
- en: The ordinal for the default config sources can be overridden by defining the
    property `config_ordinal` inside the config source. For instance, if you want
    to set the ordinal number for environment variables to 500, you can simply define
    an environment variable's `config_ordinal` with the value of `500`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置源的序号可以通过在配置源内部定义属性`config_ordinal`来覆盖。例如，如果您想将环境变量的序号设置为500，您可以简单地定义一个环境变量的`config_ordinal`值为`500`。
- en: Environment variable mapping rules
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 环境变量映射规则
- en: 'Some property names do not qualify as valid environment variables, because
    in some `app.name`) in an environment variable. The search will terminate once
    a match is found from the following list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性名不满足有效环境变量的条件，因为在某些情况下，`app.name`在环境变量中。搜索将在以下列表中找到匹配项后终止：
- en: The exact property name is found, such as `app.name`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确找到的属性名，例如`app.name`。
- en: If the property name contains some characters that are not letters or digits,
    convert these characters to *_* and the transformed property name (`app_name`)
    will be found.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性名包含一些不是字母或数字的字符，将这些字符转换为`_*`，然后转换所有字母为大写，转换后的属性名（`app_name`）将被找到。
- en: If the property name contains some characters that are not letters or digits,
    convert the characters to *_* and then convert all letters to uppercase and the
    transformed property name (`APP_NAME`) will be found.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性名包含一些不是字母或数字的字符，将这些字符转换为`_*`，然后转换所有字母为大写，转换后的属性名（`APP_NAME`）将被找到。
- en: Apart from the out-of-the-box config sources, you can create your own config
    sources using a file, a database, and much more. These config sources are called
    Custom Config Sources, which we discuss next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开箱即用的配置源之外，您可以使用文件、数据库等创建自己的配置源。这些配置源被称为自定义配置源，我们将在下一节中讨论。
- en: Custom config source
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义配置源
- en: '**Custom config source** is a config source that you define in your application
    other than the default config source. To define a custom config source, you can
    follow these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义配置源** 是除了默认配置源之外您在应用程序中定义的配置源。要定义自定义配置源，您可以按照以下步骤操作：'
- en: 'Implement the interface `ConfigSource` as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现 `ConfigSource` 接口：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `getPropertyNames()`, `getValue(String propertyName)`, and `getName()` methods
    are the ones to be implemented.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getPropertyNames()`、`getValue(String propertyName)` 和 `getName()` 方法是需要实现的方法。'
- en: 'Register the implementation of these functions using either of the following
    methods:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任一方法注册这些函数的实现：
- en: a). Create a `META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource`
    file with the fully qualified class name of the custom implementation.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a). 创建一个 `META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource`
    文件，其中包含自定义实现的完全限定类名。
- en: 'b). Add to `ConfigBuilder` programmatically via the following:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b). 通过以下方式程序化地向 `ConfigBuilder` 添加：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sometimes, you have sensitive configuration, and you need to store it somewhere
    safe. You might need to consider using **HashiCorp Vault** ([https://www.vaultproject.io/](https://www.vaultproject.io/)),
    which manages secrets and stores sensitive data. If you store some secret properties
    in *Vault*, you can add *Vault* as a custom config source. Next, we'll look at
    another way of storing configuration using Kubernetes ConfigMaps and Secrets,
    which store configurations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您有敏感的配置，需要将其存储在安全的地方。您可能需要考虑使用 **HashiCorp Vault** ([https://www.vaultproject.io/](https://www.vaultproject.io/))，它管理密钥并存储敏感数据。如果您在
    *Vault* 中存储了一些密钥属性，您可以将 *Vault* 添加为自定义配置源。接下来，我们将探讨另一种使用 Kubernetes ConfigMaps
    和 Secrets 存储配置的方法，它们存储配置。
- en: Kubernetes ConfigMaps and Secrets
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes ConfigMaps 和 Secrets
- en: '**Kubernetes** **ConfigMaps** and **Secrets** are often used to store properties
    for cloud-native applications. You can use the following commands to declare properties
    as Kubernetes ConfigMaps or Secrets:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes** **ConfigMaps** 和 **Secrets** 通常用于存储云原生应用程序的属性。您可以使用以下命令声明 Kubernetes
    ConfigMaps 或 Secrets：'
- en: 'Create a ConfigMap named `app-port`:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `app-port` 的 ConfigMap：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a Secret, `app-credentials`:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `app-credentials` 的 Secret：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command is similar to creating a ConfigMap. The main difference between
    a Secret and ConfigMap is that a Secret only shows a Base64-encoded version of
    the text instead of cleartext.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令类似于创建 ConfigMap。Secret 与 ConfigMap 的主要区别在于，Secret 只显示文本的 Base64 编码版本，而不是明文。
- en: 'After specifying a Kubernetes ConfigMap or Secret, you can map the ConfigMap
    or Secret to environment variables via the `deployment yaml` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定 Kubernetes ConfigMap 或 Secret 后，您可以通过 `deployment yaml` 文件将 ConfigMap 或
    Secret 映射到环境变量：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then use the following code to look up the properties:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码来查找属性：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Based on the defined mapping rules when looking up properties in the environment
    variables, `port` will be searched first, followed by `PORT`. Since the ConfigMap
    property `app_port` is optional, it is not required to be defined in the ConfigMap.
    If it is not found, the default value `9080` will be assigned to the variable
    `port`. As for the other property `app.username`, `app.username` is searched first,
    followed by `app_username`, and then `APP_USERNAME`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在环境变量中查找属性时定义的映射规则，`port` 将首先被搜索，然后是 `PORT`。由于 ConfigMap 属性 `app_port` 是可选的，因此它不需要在
    ConfigMap 中定义。如果未找到，则将默认值 `9080` 分配给变量 `port`。至于其他属性 `app.username`，将首先搜索 `app.username`，然后是
    `app_username`，最后是 `APP_USERNAME`。
- en: So far, we have learned where to store property values, but sometimes, you might
    have to delete a property value. In this next section, we will learn how to erase
    a property.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了属性值的存储位置，但有时您可能需要删除属性值。在下一节中，我们将学习如何删除属性。
- en: Removing properties
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除属性
- en: In order to remove properties, you can simply remove the property entry from
    a config source. However, you might not be able to update a config source. In
    such circumstances, you can define a config source with a higher ordinal and define
    the property with a empty value. This effectively erases the config property.
    Therefore, any lookup for this property will resolve to an exception.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除属性，您只需从配置源中删除属性条目即可。然而，您可能无法更新配置源。在这种情况下，您可以定义一个具有更高序号的配置源，并使用空值定义属性。这实际上会删除配置属性。因此，任何对此属性的查找都将解析为异常。
- en: We have covered where to specify config properties. When we store the config
    property values, they are all expressed via strings. You might want to convert
    the strings to some other types, such as **int**, **float**, and so on. To achieve
    this, we will need some converters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在哪里指定配置属性。当我们存储配置属性值时，它们都是通过字符串表达的。你可能希望将字符串转换为其他类型，如**int**、**float**等。为了实现这一点，我们需要一些转换器。
- en: Converters
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换器
- en: A **converter** converts a string to a target type. If a null value is passed
    to the converter, **NullPointerException** (**NPE**) will be thrown.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换器**将字符串转换为目标类型。如果向转换器传递了null值，将抛出**NullPointerException**（NPE）。'
- en: 'Just as there is more than one type of config source, there are a few types
    of converters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如存在多种配置源一样，也存在几种类型的转换器：
- en: '**Built-in converters**: They can convert strings to primitive and boxed types
    as well as class types.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置转换器**：它们可以将字符串转换为原始类型、包装类型以及类类型。'
- en: '**Array converters**: They can convert a comma-separated string to an array.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组转换器**：它们可以将逗号分隔的字符串转换为数组。'
- en: '`T` is derived from a class where the class contains one of the following:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`是从一个类派生的，该类包含以下之一：'
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If more than one method is found, the method appearing at the top of the aforementioned
    list will be used for conversion.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果找到多个方法，将使用上述列表中顶部的方法进行转换。
- en: '`org.eclipse.microprofile.config.spi.Converter`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.config.spi.Converter`。'
- en: '2) Register the converter by creating a `META-INF/services/org.eclipse.microprofile.config.spi.Converter`
    file with the fully qualified class name of the custom implementation or adding
    to `ConfigBuilder` programmatically via one of the following:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2) 通过创建一个包含自定义实现完全限定类名的`META-INF/services/org.eclipse.microprofile.config.spi.Converter`文件或通过以下方式之一在程序中添加到`ConfigBuilder`来注册转换器：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are several types of converters. There might be multiple converters for
    a given type. But the question arises, which converter will be used to transform
    the config string value to the given type? This is determined by converter priority.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的转换器。对于给定类型可能有多个转换器。但是问题来了，哪个转换器将被用来将配置字符串值转换为给定类型？这由转换器优先级决定。
- en: Converter priority
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换器优先级
- en: '`@javax.annotation.Priority` annotation. If absent, the priority for a custom
    converter will default to 100\. A converter with a higher priority overrides one
    with a lower priority.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`@javax.annotation.Priority`注解。如果不存在，自定义转换器的优先级将默认为100。优先级较高的转换器会覆盖优先级较低的转换器。'
- en: We have covered how to specify the value of a config property with a string
    and then how to convert a string to a particular type. In the next section, we
    will learn how to look up config properties in cloud-native applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何使用字符串指定配置属性的值，然后如何将字符串转换为特定类型。在下一节中，我们将学习如何在云原生应用程序中查找配置属性。
- en: Config lookup
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置查找
- en: 'We have learned that config sources contain properties specified in strings
    and converters can convert strings to a target type. But the question arises,
    how do you retrieve a config property? This can be done either programmatically
    or via injection:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到配置源包含以字符串指定的属性，转换器可以将字符串转换为目标类型。但是问题来了，如何检索配置属性？这可以通过程序化方式或通过注入来完成：
- en: '`customer.age` will be retrieved using the `getValue` method and converted
    to an integer using programmatic lookup:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getValue`方法检索`customer.age`并将它转换为整数，这是通过程序化查找完成的：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`customer.age`:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer.age`：'
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In your cloud-native applications, sometimes different values are specified
    during different project stages. For instance, you might use a different database
    in different project stages. When the project moves through different phases,
    the values associated with those stages will be injected into the corresponding
    config properties. This is called a **config profile**. We will cover this in
    more detail in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的云原生应用程序中，有时在项目不同阶段会指定不同的值。例如，你可能在不同的项目阶段使用不同的数据库。当项目通过不同的阶段时，与这些阶段相关的值将被注入到相应的配置属性中。这被称为**配置配置文件**。我们将在下一节中更详细地介绍这一内容。
- en: Understanding config profiles
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解配置配置文件
- en: Config profiles are an important concept that can be used to indicate project
    phases, such as development, testing, production, and so on. We'll first discuss
    how to define properties that use config profiles and then learn how to activate
    a particular profile.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 配置配置文件是一个重要的概念，可以用来表示项目阶段，如开发、测试、生产等。我们首先将讨论如何定义使用配置配置文件的属性，然后学习如何激活特定的配置文件。
- en: Profile-aware properties
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件感知属性
- en: 'There are two ways to define profile-aware properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 定义配置文件感知属性有两种方式：
- en: Using the naming convention of *%<profile name>.<property name>*, for example,
    defining a property called `%dev.customer.name` in a config source.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名约定*%<profile name>.<property name>*)，例如，在一个配置源中定义一个名为`%dev.customer.name`的属性。
- en: Defining the properties in a `microprofile-config-<profile name>.properties`
    file.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`microprofile-config-<profile name>.properties`文件中定义属性。
- en: Activating a profile
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活配置文件
- en: An active profile is specified using the property `mp.config.profile`, which
    can be included in any config sources. If more than one config source specifies
    this property, the value from the config source with the highest ordinal is used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性`mp.config.profile`指定活动配置文件，该属性可以包含在任何配置源中。如果有多个配置源指定此属性，则使用具有最高序号的配置源的值。
- en: 'Let''s take a look at a few examples. Let''s say we have the following config
    source, containing the following properties:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子。假设我们有一个以下配置源，包含以下属性：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the value of `mp.config.profile` is set to `dev`, the value of the property
    `discount` will resolve to the value of `%dev.discount`, which is `0.1`. Similarly,
    the value of the property `discount` will be `0.2` if the active profile is `live`.
    The value of the property `discount` will be `0.15` if no active profile is defined.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mp.config.profile`的值设置为`dev`，则属性`discount`的值将解析为`%dev.discount`的值，即`0.1`。同样，如果活动配置文件是`live`，则属性`discount`的值将是`0.2`。如果没有定义活动配置文件，则属性`discount`的值将是`0.15`。
- en: 'A config profile also works on the config source file `micorprofile-config.properties`.
    Consider the following `properties` files provided by your application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 配置配置文件也适用于`micorprofile-config.properties`配置源文件。考虑以下由您的应用程序提供的`properties`文件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the value of `mp.config.profile` is set to `dev`, the config file `META-INF\microrpofile-config-dev.properties`
    will be activated. Its content will be merged into `META-INF\microrpofile-config.properties`
    and override the property values for the same properties that exist in both files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mp.config.profile`的值设置为`dev`，则配置文件`META-INF\microrpofile-config-dev.properties`将被激活。其内容将合并到`META-INF\microrpofile-config.properties`中，并覆盖两个文件中存在的相同属性的属性值。
- en: Sometimes the value of one property refers to another property. We call this
    a config reference. We will cover this topic in the next subsection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一个属性的值引用另一个属性。我们称这种引用为配置引用。我们将在下一小节中介绍这个主题。
- en: Config references
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置引用
- en: A property value might reference a value from another property, which is called
    a **Config Reference**, also known as a property expression. The syntax for a
    property expression is *${another.property}*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值可能引用另一个属性的值，这被称为**配置引用**，也称为属性表达式。属性表达式的语法是*${another.property}*。
- en: 'Consider the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value of `customer.name` will be `Bob-Johnson`. A property expression can
    be nested as well, in the format *${a${n}}*. In a nested expression, the inner
    expression will be resolved first.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer.name`的值将是`Bob-Johnson`。属性表达式也可以嵌套，格式为*${a${n}}*。在嵌套表达式中，内部表达式将首先被解析。'
- en: As mentioned previously, a property can be specified in multiple config sources.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个属性可以在多个配置源中指定。
- en: Sometimes you need to identify which config source supplies the value so that
    you can update the effective value if needed. In the next subsection, we will
    learn how to find out which config source is the winning config source.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要确定哪个配置源提供了值，以便在需要时更新有效值。在下一小节中，我们将学习如何找出哪个配置源是获胜的配置源。
- en: Where is my property value from?
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我的属性值从哪里来？
- en: 'Sometimes you might be wondering which config source supplies the value for
    a particular property, since the same property might exist in multiple config
    sources. If you need to update the property value, you need to update the value
    from the winning config source. MicroProfile Config provides an API, `ConfigValue`,
    that enables you to find the winning config source. There are a couple of ways
    to obtain an object of `ConfigValue` for a specified property. You can use the
    following programmatic lookup to look up the config value for the property `host`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想知道特定属性的值是由哪个配置源提供的，因为相同的属性可能存在于多个配置源中。如果你需要更新属性值，你需要更新获胜配置源的值。MicroProfile
    Config提供了一个API，`ConfigValue`，它允许你找到获胜的配置源。有几种方法可以获取指定属性的`ConfigValue`对象。你可以使用以下程序性查找来查找属性`host`的配置值：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can use CDI to obtain the config value for the `host` property`,`
    as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用CDI来获取`host`属性的`config`值，如下所示：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we can use the following method to retrieve some information about the
    winning config source and its value:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下方法来检索有关获胜配置源及其值的一些信息：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Commonly, some properties are related, and they are often looked up together.
    It would be very useful if these properties were aggregated and mapped to a particular
    Java type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一些属性是相关的，并且它们经常一起查找。如果这些属性被聚合并映射到特定的Java类型，这将非常有用。
- en: Aggregate config properties
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合配置属性
- en: When looking up several related properties, it can be tedious to repeat the
    same configuration lookup statements. They might appear in different classes and
    some of the properties might be dynamic while others might be static, which might
    lead to an inconsistent state. In this situation, it is best practice to aggregate
    the related config properties in a CDI bean and annotate the CDI bean with the
    qualifier `@ConfigProperties` so that the property lookup is performed at the
    same time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当查找多个相关属性时，重复相同的配置查找语句可能会很繁琐。它们可能出现在不同的类中，其中一些属性可能是动态的，而另一些可能是静态的，这可能会导致不一致的状态。在这种情况下，将相关的配置属性聚合到一个CDI
    bean中，并使用`@ConfigProperties`注解该CDI bean，以便同时执行属性查找，是一种最佳实践。
- en: 'Let''s take an example to see how `@ConfigProperties` works. The following
    is a custom `ConfigSource`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看`@ConfigProperties`是如何工作的。以下是一个自定义的`ConfigSource`：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To look up the properties related to a particular customer, we can use `@ConfigProperites,`
    as shown next:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找与特定客户相关的属性，我们可以使用`@ConfigProperites`，如下所示：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When looking up the properties, you need to use the annotation `@ConfigProperites(prefix="customer")`.
    The prefix can be omitted if the prefix value is the same as the CDI bean prefix.
    If you specify a different prefix value, the specified prefix value will override
    the value defined on the CDI bean and the specified prefix will be used for looking
    up the properties.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找属性时，您需要使用`@ConfigProperites(prefix="customer")`注解。如果前缀值与CDI bean前缀相同，则可以省略前缀。如果您指定了不同的前缀值，则指定的前缀值将覆盖CDI
    bean上定义的值，并使用指定的前缀来查找属性。
- en: Up till now, the config object has been provided by a Config specification implementation,
    which loads the available config sources and converters. For some advanced use
    cases where you need to control which config sources and converters are used,
    you might want to build the config object yourself. MicroProfile Config also offers
    flexibility for such a use case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`config`对象是由一个配置规范实现提供的，它加载可用的配置源和转换器。对于一些需要控制使用哪些配置源和转换器的先进用例，您可能想自己构建`config`对象。MicroProfile
    Config也为这种用例提供了灵活性。
- en: Building a Config instance yourself
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自己构建Config实例
- en: 'To build a Config instance, you will need to provide config sources and converters.
    MicroProfile Config provides a builder for the config object to be built using
    the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个Config实例，您需要提供配置源和转换器。MicroProfile Config提供了一个构建器，用于构建配置对象，按照以下步骤进行：
- en: 'First, we need to create a builder as shown in the following code snippet by
    creating an instance of `ConfigProviderResolver` and then call the `getBuilder()`
    method to create an instance of a builder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个构建器，如下面的代码片段所示，通过创建`ConfigProviderResolver`的一个实例，然后调用`getBuilder()`方法来创建一个构建器的实例：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then add config sources and converters to the builder and then call the
    `build()` method to build a `config` object as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加配置源和转换器到构建器中，然后调用`build()`方法来构建一个`config`对象，如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to register the `config` object so that we can always supply
    the same `config` object to the same `classloader` object, as shown here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要注册`config`对象，以便我们始终可以向相同的`classloader`对象提供相同的`config`对象，如下所示：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, when we finish using the `config` object, we will need to release
    it, as shown here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们完成对`config`对象的使用后，我们需要将其释放，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If a config object is associated with multiple classloaders, when releasing
    the config object, all occurrences of it will have to be removed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个配置对象与多个类加载器相关联，在释放配置对象时，必须删除它的所有实例。
- en: We have covered the most useful features of MicroProfile Config. To use the
    APIs from MicroProfile Config, you need to specify the Maven or Gradle dependencies.
    We will cover this in more detail in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了MicroProfile Config最有用的功能。要使用MicroProfile Config的API，你需要指定Maven或Gradle依赖项。我们将在下一节中更详细地介绍这一点。
- en: Making the MicroProfile Config API available
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使MicroProfile Config API可用
- en: 'MicroProfile Config API JARs can be made available for either Maven and Gradle
    projects. If you create a Maven project, you can directly add the following to
    your `pom.xml`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Config API JARs可以为Maven和Gradle项目提供。如果你创建了一个Maven项目，你可以直接将以下内容添加到你的`pom.xml`中：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你创建了一个Gradle项目，你需要添加以下依赖项：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You have learned how to configure your cloud-native applications. The next step
    is to make your applications resilient. In the next section, we will cover details
    on how you can make your applications resilient using MicroProfile Fault Tolerance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何配置你的云原生应用。下一步是让你的应用具有弹性。在下一节中，我们将详细介绍如何使用MicroProfile容错性来让你的应用具有弹性。
- en: Making a cloud application resilient using MicroProfile Fault tolerance
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile容错性使云应用具有弹性
- en: Why do you need to care about resilience? For mission-critical applications,
    a very brief downtime might cause you a huge penalty. Besides, your customer satisfaction
    will decrease if your applications are too fragile and aren't resilient. Therefore,
    you should consider building resilient applications, which means they will function
    under all kinds of situations with zero downtime. MicroProfile Fault Tolerance
    (source code at [https://github.com/eclipse/microprofile-fault-tolerance](https://github.com/eclipse/microprofile-fault-tolerance))
    introduces several resilience policies that can help you build a resilient application.
    These policies can be applied to CDI beans. It also provides a way to execute
    method invocations asynchronously via the annotation `@Asynchronous`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你需要关注弹性？对于关键任务应用，非常短暂的中断可能会给你带来巨大的损失。此外，如果你的应用过于脆弱且不具有弹性，客户满意度将会下降。因此，你应该考虑构建具有弹性的应用，这意味着它们将在各种情况下无中断地运行。MicroProfile容错性（源代码位于[https://github.com/eclipse/microprofile-fault-tolerance](https://github.com/eclipse/microprofile-fault-tolerance)）引入了几个弹性策略，可以帮助你构建具有弹性的应用。这些策略可以应用于CDI
    beans。它还提供了一种通过`@Asynchronous`注解异步执行方法调用的方式。
- en: '@Asynchronous'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Asynchronous'
- en: 'The annotation `@Asynchronous` can be placed on a CDI bean class or the methods
    of a CDI bean class. If placed on a class, it means all of the methods declared
    on this class will be executed on a separate thread. Methods annotated with `@Asynchronous`
    must return a `Future` or a `CompletionStage` value, otherwise, `FaultToleranceDefinitionException`
    will be thrown. The following is a code snippet to show its usage:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Asynchronous`注解可以放置在CDI bean类或CDI bean类的方法上。如果放置在类上，这意味着这个类上声明的所有方法都将在一个单独的线程上执行。使用`@Asynchronous`注解的方法必须返回一个`Future`或`CompletionStage`值，否则将抛出`FaultToleranceDefinitionException`。以下是一个代码片段来展示其用法：'
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The aforementioned example means the invocation of `serviceA()` will be executed
    on a different thread and then return with `CompletionStage`. If the method returns
    `Future`, the method call is always considered successful unless the method throws
    an exception. If the method returns `CompletionStage`, the method call is considered
    successful only if `CompletionStage` completes without any exceptions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例意味着`serviceA()`的调用将在不同的线程上执行，然后返回`CompletionStage`。如果方法返回`Future`，方法调用始终被视为成功，除非方法抛出异常。如果方法返回`CompletionStage`，方法调用只有在`CompletionStage`完成且没有任何异常的情况下才被视为成功。
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `@Asynchronous` annotation, it is best practice to return `CompletionStage`,
    which enables other Fault Tolerance policies to be invoked on an abnormal return.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`@Asynchronous`注解时，最佳实践是返回`CompletionStage`，这允许在异常返回时调用其他容错策略。
- en: But what do you do when you hit a temporary network glitch? The first instinct
    is to try it again, which is what this next annotation helps with.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你遇到暂时的网络故障时，你会怎么做？第一反应是再试一次，这正是下一个注解所帮助的。
- en: '@Retry'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Retry'
- en: 'MicroProfile Fault Tolerance offers the retry capability via the annotation
    `@Retry`. When using this annotation, you can specify the following properties:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile容错性通过`@Retry`注解提供重试功能。当使用此注解时，你可以指定以下属性：
- en: '`maxRetries`: This indicates the maximum number of retries.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxRetries`：这表示最大重试次数。'
- en: '`delay`: This indicates the delays between each retry.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`：这表示每次重试之间的延迟。'
- en: '`delayUnit`: This specifies the time unit for the delay.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delayUnit`：这指定了延迟的时间单位。'
- en: '`maxDuration`: This indicates the maximum duration for the overall retries.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxDuration`：这表示整体重试的最大持续时间。'
- en: '`durationUnit`: This specifies the duration unit.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`durationUnit`：这指定了持续时间单位。'
- en: '`jitter`: This indicates the random gap per delay.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jitter`：这表示每个延迟的随机间隔。'
- en: '`jitterDelayUnit`: This specifies the jitter delay unit.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jitterDelayUnit`：这指定了抖动延迟单位。'
- en: '`retryOn`: This indicates the failures that cause the retries.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryOn`：这表示导致重试的失败。'
- en: '`abortOn`: This specifies the failures that skip the retries.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abortOn`：这指定了跳过重试的失败。'
- en: 'You can add the annotation `@Retry` on any class or business method ([https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method](https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method)).
    Let''s take a look at the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何类或业务方法上添加 `@Retry` 注解（[https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method](https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method)）。让我们看看以下示例：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the aforementioned code snippet, the `@Retry` annotation means the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`@Retry` 注解表示以下内容：
- en: An exception other than `IllegalArgumentException` will trigger the `Retry`
    operation.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 `IllegalArgumentException` 之外的异常将触发 `Retry` 操作。
- en: The maximum number of retries is `5` and the maximum duration is `4000` ms (milliseconds).
    The `Retry` operation will terminate when either condition is met.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大重试次数为 `5`，最大持续时间为 `4000` 毫秒（毫秒）。当满足任一条件时，`Retry` 操作将终止。
- en: The delay between the retries is `200` ms (jitter) and `600` ms (delay+jitter).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试之间的延迟是 `200` 毫秒（抖动）和 `600` 毫秒（延迟+抖动）。
- en: Sometimes you may not want to keep on retrying; you might want to fail fast
    and return to the caller within a time constraint, for instance, if the caller
    only assigns a limited waiting time and can't afford to wait till a request returns.
    The `@Timeout annotation` was introduced to force the operation to return within
    the specified period.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能不想不断重试；您可能希望快速失败并在时间限制内返回给调用者，例如，如果调用者只分配了有限的等待时间，无法承担等待请求返回的时间。`@Timeout`
    注解被引入来强制操作在指定期间内返回。
- en: '@Timeout'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Timeout'
- en: 'The `@Timeout` annotation specifies the maximum response time. Without the
    specified time out, an indefinite wait might occur. With the `@Timeout` annotation,
    the affected operation needs to return within the specified time duration otherwise,
    a `TimeoutException` will be thrown. This annotation can be used on a class or
    any business method. Let''s take a look at the following code example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Timeout` 注解指定了最大响应时间。如果没有指定超时时间，可能会发生不确定的等待。使用 `@Timeout` 注解后，受影响的操作需要在指定的时间段内返回，否则将抛出
    `TimeoutException`。此注解可以用于类或任何业务方法。让我们看看以下代码示例：'
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the aforementioned code snippet, the `getServiceName()` operation will either
    return within `700` ms or throw a `TimeoutException` if the operation takes more
    than `700` ms to compute.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`getServiceName()` 操作将在 `700` 毫秒内返回，或者如果操作计算时间超过 `700` 毫秒，将抛出 `TimeoutException`。
- en: If a service is not working, you might not want to wait for the specified timeout
    and then get a `TimeoutException` repeatedly. It would be good to fail fast after
    a certain amount of failure time. Failing fast provides time for the backend to
    recover and the request can get feedback immediately. This is what `@CircuitBreaker`
    does.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务不工作，您可能不想等待指定的超时时间，然后反复得到 `TimeoutException`。在一定的失败时间后快速失败会更好。快速失败为后端恢复提供时间，请求可以立即得到反馈。这正是
    `@CircuitBreaker` 所做的。
- en: '@CircuitBreaker'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@CircuitBreaker'
- en: 'The **Circuit Breaker** pattern helps an invocation fail fast and provides
    time for the backend to recover by preventing requests from reaching the backend.
    How does the Circuit Breaker pattern work? It is very simple. The circuit in the
    Circuit Breaker pattern is like an electrical circuit. If the circuit is open,
    there will be no electricity. A closed circuit means normal service. A circuit
    breaker has three states:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**断路器**模式帮助调用快速失败，并通过防止请求到达后端为后端恢复提供时间。断路器模式是如何工作的？它非常简单。断路器模式中的电路就像一个电路。如果电路是断开的，就没有电。闭合电路意味着正常服务。断路器有三个状态：'
- en: '`failureRatio` within a number of consecutive requests or rolling window, called
    `requestVolumeThredshold`, the circuit breaker will trip. The circuit breaker
    will transition its state from closed to open.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在连续请求或滚动窗口（称为 `requestVolumeThreshold`）中的 `failureRatio` 数量，当断路器跳闸时，断路器将从关闭状态转换为打开状态。
- en: '`CircuitBreakerOpenException`. After a specified delay period, the circuit
    breaker will transition to the half-open state.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CircuitBreakerOpenException`。在指定延迟期后，断路器将转换为半开状态。'
- en: '`successThreshold`, the circuit breaker will transition to the **Closed** state.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `successThreshold` 被满足时，断路器将转换为 **关闭** 状态。
- en: 'The circuit breaker has the following parameters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器有以下参数：
- en: '`requestVolumeThreshold` specifies the size of the rolling window where the
    circuit breaker will be assessed. If the value of `requestVolumeThreshold` is
    10, it means the circuit breaker will only be checked after 10 requests.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestVolumeThreshold` 指定了断路器将被评估的滚动窗口的大小。如果 `requestVolumeThreshold` 的值为
    10，这意味着断路器只有在10次请求之后才会进行检查。'
- en: '`failureRatio` controls the failure rate within the rolling window. If the
    failure rate is equal to or above the `failureRatio` parameter, the circuit breaker
    will trip open.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureRatio` 控制滚动窗口内的失败率。如果失败率等于或高于 `failureRatio` 参数，则断路器将跳闸打开。'
- en: '`successThreshold` specifies the criteria when the circuit breaker transitions
    from half-open to closed. If the value of `successThreshold` is `2`, it means
    after 2 successful requests, the circuit breaker will transition from half-open
    to closed.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successThreshold` 指定了当断路器从半开状态转换为关闭状态时的标准。如果 `successThreshold` 的值为 `2`，这意味着在2次成功请求之后，断路器将从半开状态转换为关闭状态。'
- en: '`delay` and `delayUnit` indicate how long the circuit breaker stays open. The
    circuit breaker will not stay open forever.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay` 和 `delayUnit` 指示断路器保持打开状态的时间。断路器不会永远保持打开。'
- en: '`failOn` specifies the exceptions that are considered to be failures.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failOn` 指定了一些被认为是失败的异常。'
- en: '`skipOn` states the exceptions that are excluded from contributing towards
    the circuit breaker.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipOn` 指定了一些异常，这些异常不会被计入断路器的贡献。'
- en: 'The Circuit Breaker pattern can be specified via the `@CircuitBreaker annotation`.
    The `@CircuitBreaker` annotation can be placed on a class or a business method
    to avoid repeated failures. You can configure the parameters on the annotation,
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `@CircuitBreaker` 注解指定断路器模式。`@CircuitBreaker` 注解可以放置在类或业务方法上，以避免重复失败。您可以在注解上配置参数，如下所示：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the aforementioned code snippet, it means the circuit breaker will trip to
    open if there are 5 or more (10*0.5) failures among `10` (`requestVolumeThreshold`)
    consecutive requests. After 2 seconds, specified by the parameters `delay` and
    `delayUnit`, the circuit will transition to half-open. After 3 (`successThreshold`)
    consecutive successes, the circuit breaker will transition to close.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，这意味着如果连续10次请求中有5次或更多（10*0.5）失败，则断路器将跳闸打开。在参数 `delay` 和 `delayUnit`
    指定的2秒后，电路将转换为半开状态。在3次（`successThreshold`）连续成功之后，断路器将转换为关闭状态。
- en: When deciding whether an invocation should be treated as a failure or not, the
    criteria is that the exception from the invocation must be assignable to `ExceptionA`
    or `ExceptionB` but not assignable to `ExceptionC`. If an exception is assignable
    to `ExceptionC`, this execution will be treated not as a failure but as a success
    when counting towards a circuit breaker.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定一个调用是否应该被视为失败时，标准是调用中抛出的异常必须可以分配给 `ExceptionA` 或 `ExceptionB`，但不能分配给 `ExceptionC`。如果一个异常可以分配给
    `ExceptionC`，那么在计算断路器时，这次执行将被视为成功而不是失败。
- en: Success in Circuit Breaker
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器的成功
- en: The success marked by the annotation `@CircuitBreaker` does not mean the operation
    returns normally. It only means that the return is treated as a success by Circuit
    Breaker. For instance, if a returned exception is assignable to any of the `skipOn`
    exceptions, the exception does not count as a failure but counts as a success
    instead.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `@CircuitBreaker` 注解标记的成功并不意味着操作返回正常。它仅意味着返回被断路器视为成功。例如，如果返回的异常可以分配给 `skipOn`
    中的任何异常，则该异常不计为失败，而是计为成功。
- en: The scope of `@CircuitBreaker` annotation is per class per method, which means
    all instances for a particular class share the same circuit breaker for the same
    method. When applying `@CircuitBreaker` annotation on a CDI bean, it is irrelevant
    what CDI scope the bean has. All invocations for a particular method share the
    same circuit breaker.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`@CircuitBreaker`注解的作用域是每个类每个方法，这意味着特定类的所有实例对于相同的方法共享同一个断路器。当在CDI bean上应用`@CircuitBreaker`注解时，bean的CDI作用域无关紧要。特定方法的调用共享同一个断路器。'
- en: In a mission-critical service, it is important to ensure that the service has
    fault isolation capabilities, preventing faults in one part of the system cascading
    to the entire system. This is known as **the Bulkhead pattern**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个关键任务服务中，确保服务具有故障隔离能力，防止系统某一部分的故障级联到整个系统，这一点非常重要。这被称为**舱壁模式**。
- en: The Bulkhead pattern
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 舱壁模式
- en: 'The Bulkhead pattern is to prevent one failure from cascading, which then brings
    down the whole application. The Bulkhead pattern is achieved by limiting the number
    of concurrent requests accessing a resource. There are two different types of
    bulkhead: **Semaphore** isolation and **Thread Pool** isolation.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 舱壁模式是为了防止一个故障级联，从而导致整个应用程序崩溃。舱壁模式是通过限制访问资源的并发请求数量来实现的。有两种不同的舱壁类型：**信号量**隔离和**线程池**隔离。
- en: Semaphore isolation
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号量隔离
- en: Semaphore isolation limits the number of concurrent requests to a specified
    number. You can directly use `@Bulkhead(n)` to limit the maximum requests where
    `n` is the number of concurrent requests. The extra request `n+1` will fail with
    `BulkheadException`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量隔离限制了并发请求数量到指定的数量。你可以直接使用`@Bulkhead(n)`来限制最大请求，其中`n`是并发请求数量。额外的请求`n+1`将因`BulkheadException`而失败。
- en: However, sometimes you might want to have a waiting queue for the extra requests
    to queue. For this requirement, you will need to use Thread Pool isolation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能希望为额外的请求提供一个等待队列。对于这个需求，你需要使用线程池隔离。
- en: Thread Pool isolation
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程池隔离
- en: Thread Pool isolation also limits a certain number of concurrent requests. It
    dispatches a new thread for method execution. In addition, it also has a waiting
    queue to store the extra requests. Only when the waiting queue is full, `BulkheadException`
    will be thrown.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池隔离也限制了并发请求数量。它为方法执行分配一个新的线程。此外，它还有一个等待队列来存储额外的请求。只有当等待队列满时，才会抛出`BulkheadException`异常。
- en: 'To define Thread Pool isolation, you need to use `@Bulkhead` together with
    `@Asynchronous` as shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义线程池隔离，你需要使用`@Bulkhead`与`@Asynchronous`一起使用，如下所示：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The aforementioned code snippet means the size of the bulkhead is `5`, which
    allows 5 concurrent requests accessing the method `serviceA()`. The extra requests
    will be queued in the waiting queue. When the waiting queue is full, the extra
    requests will cause `BulkheadException` to be thrown.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述代码片段所示，舱壁的大小为`5`，允许5个并发请求访问`serviceA()`方法。额外的请求将被排队在等待队列中。当等待队列满时，额外的请求将导致抛出`BulkheadException`异常。
- en: Similar to the `@CircuitBreaker` annotation, the scope of `@Bulkhead` annotation
    is per class per method, which means all instances for a particular class share
    the same bulkhead for the same method. When applying a `@Bulkhead` annotation
    on a CDI bean, it is irrelevant what CDI scope the bean has. All invocations for
    a particular method share the same bulkhead.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与`@CircuitBreaker`注解类似，`@Bulkhead`注解的作用域是每个类每个方法，这意味着特定类的所有实例对于相同的方法共享同一个舱壁。当在CDI
    bean上应用`@Bulkhead`注解时，bean的CDI作用域无关紧要。特定方法的调用共享同一个舱壁。
- en: Apart from Retry, the Fault Tolerance policies we have covered so far are about
    failing gracefully. However, sometimes, you want to return a reasonable response
    to your caller. In these circumstances, you should provide an alternative answer.
    This is what the Fallback policy is for.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重试之外，我们之前讨论的容错策略都是关于优雅地失败。然而，有时你可能想向调用者返回一个合理的响应。在这些情况下，你应该提供一个替代答案。这就是回退策略的作用。
- en: Fallback
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回退
- en: 'The `@Fallback` annotation. The `@Fallback` annotation has the following parameters:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Fallback`注解。`@Fallback`注解具有以下参数：'
- en: '`value`: This specifies a class that implements the `FallbackHandler` interface.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这指定了一个实现`FallbackHandler`接口的类。'
- en: '`fallbackMethod`: This method specifies the fallback method name. The fallback
    method must be defined in the same class as the method applying the `@Fallback`
    annotation.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallbackMethod`：此方法指定回退方法名称。回退方法必须在应用`@Fallback`注解的方法所在的同一类中定义。'
- en: '`applyOn`: This defines the criteria when the Fallback policy should be applied.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applyOn`：这定义了回退策略应该应用的标准。'
- en: '`skipOn`: This defines the criteria when the Fallback policy should be skipped.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipOn`：这定义了回退策略应该跳过的标准。'
- en: The `value` and `fallbackMethod` parameters are mutually exclusive. If you specify
    both on the `@Fallback`, annotation `FaultToleranceDefinitionException` will be
    thrown. To specify the backup operation, you need to either define the `fallbackMethod`
    or `value` parameter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`和`fallbackMethod`参数是互斥的。如果你在`@Fallback`注解上同时指定了这两个参数，将会抛出`FaultToleranceDefinitionException`异常。要指定备份操作，你需要定义`fallbackMethod`或`value`参数之一。'
- en: The `fallbackMethod` signature and return type must match the method that defines
    the Fallback policy. The `value` parameter should be used if you would like to
    define a handler to handle multiple Fallback policies.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`fallbackMethod`签名和返回类型必须与定义回退策略的方法相匹配。如果你想定义一个处理多个回退策略的处理程序，应该使用`value`参数。'
- en: You can use `skipOn` or `applyOn` to specify what exception should trigger the
    fallback operation. As the name says, all exceptions and the subclasses listed
    under `skipOn` will bypass fallback while the exception and their subclasses listed
    by `applyOn` should trigger the fallback operation. When `skipOn` and `applyOn`
    are used together, `skipOn` takes precedence.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`skipOn`或`applyOn`来指定应该触发回退操作的异常。正如其名，所有在`skipOn`下列出的异常及其子类都将绕过回退，而`applyOn`列出的异常及其子类应该触发回退操作。当`skipOn`和`applyOn`一起使用时，`skipOn`具有优先权。
- en: 'Let''s look at the following code snippet for an example of the Fallback policy:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段，以了解回退策略的示例：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the aforementioned code snippet, if the method `callService()` throws an
    exception and if this exception is assignable to `ExceptionAsub`, the exception
    will be rethrown and the fallback method `myFallback` will not be executed. However,
    if the thrown exception is not assignable to `ExceptionAsub` and assignable to
    `ExceptionA` or `ExceptionB`, the fallback method `myFallback` will be triggered.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，如果`callService()`方法抛出异常，并且这个异常可以被赋值给`ExceptionAsub`，那么异常将被重新抛出，回退方法`myFallback`将不会执行。然而，如果抛出的异常不能被赋值给`ExceptionAsub`，但可以被赋值给`ExceptionA`或`ExceptionB`，那么回退方法`myFallback`将被触发。
- en: We have covered all of the Fallback policies so far. You might have realized
    that all of the policies are annotations. Actually, these annotations are CDI
    interceptor bindings, which means they only work on business method invocations
    on CDI beans, as explained at  [https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method](https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了所有的回退策略。你可能已经意识到所有策略都是注解。实际上，这些注解是CDI拦截器绑定，这意味着它们仅在CDI bean的业务方法调用上工作，如[https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method](https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method)中所述。
- en: CDI interceptors have a priority. In Fault Tolerance, some implementations provide
    one interceptor for all the interceptor bindings while others might provide multiple
    interceptors. The Fault Tolerance specification declared the base priority to
    be `Priority.PLATFORM_AFTER (4000)+10`, which is `4010`. If multiple interceptors
    are provided by an implementation, the priority range should be between base priority
    and base priority + 40 so that other application interceptors can define their
    priorities accordingly based on whether they want to be invoked before or after
    Fault Tolerance interceptors. You can update the base priority via the property
    `mp.fault.tolerance.interceptor.priority`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CDI拦截器有优先级。在容错中，一些实现可能为所有拦截器绑定提供一个拦截器，而其他实现可能提供多个拦截器。容错规范声明基本优先级为`Priority.PLATFORM_AFTER
    (4000)+10`，即`4010`。如果实现提供了多个拦截器，优先级范围应在基本优先级和基本优先级+40之间，以便其他应用程序拦截器可以根据它们是否希望在容错拦截器之前或之后调用来相应地定义它们的优先级。你可以通过属性`mp.fault.tolerance.interceptor.priority`更新基本优先级。
- en: A method annotated with Fault Tolerance annotations may also specify any other
    **Interceptor Bindings**. The invocation order on the interceptors will be determined
    by the priority of the interceptors.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 带有容错注解的方法也可以指定任何其他的**拦截器绑定**。拦截器的调用顺序将由拦截器的优先级决定。
- en: So far, we have covered all Fault Tolerance annotations. You might be wondering
    whether you could use these annotations together. Yes, of course. We will discuss
    this in more detail in the next section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了所有的容错注解。你可能想知道是否可以一起使用这些注解。当然可以。我们将在下一节中详细讨论。
- en: Using Fault Tolerance annotations together
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容错注解一起使用
- en: 'It is fine to use annotations together to achieve multiple Fault Tolerance
    capabilities such as setting up for `Retry` and `Timeout` together. Let''s take
    a look at the following example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注解一起实现多个容错能力，例如同时设置`Retry`和`Timeout`，是可行的。让我们看看以下示例：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The aforementioned code snippet means that the operation `doSomething()` applies
    all of the Fault Tolerance policies. If this method throws an exception, the following
    Fault Tolerance policies will be applied in this order:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段表示`doSomething()`操作应用了所有的容错策略。如果此方法抛出异常，将按以下顺序应用以下容错策略：
- en: Check whether the `CircuitBreaker` is open.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`CircuitBreaker`是否开启。
- en: If it is not open, the timer will start recording the time duration.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有开启，计时器将开始记录时间长度。
- en: Try to get a slot in `Bulkhead`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在`Bulkhead`中获取一个槽位。
- en: If there are 10 running tasks already, it will queue up in the waiting queue,
    which has 10 slots. However, if there is no free slot in the waiting queue, a
    `BulkheadException` exception will be thrown. If there is a slot in the waiting
    queue, it will wait to be scheduled. During the waiting, if the timeout duration
    exceeds `200` milliseconds, `TimeoutException` will be thrown. The thrown exception
    will be recorded in the `CircuitBreaker` record and then trigger `Retry`. Go back
    to *step 1* for `Retry`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经有10个正在运行的任务，它将在等待队列中排队，该队列有10个槽位。然而，如果没有空闲槽位在等待队列中，将抛出`BulkheadException`异常。如果有槽位在等待队列中，它将等待被调度。在等待期间，如果超时时间超过`200`毫秒，将抛出`TimeoutException`。抛出的异常将被记录在`CircuitBreaker`记录中，然后触发`Retry`。回到`步骤1`进行`Retry`。
- en: After `Retry` has been exhausted, the Fallback policy will be triggered.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Retry`尝试耗尽后，将触发回退策略。
- en: You might have noticed that the parameters on each annotation have default values.
    You can also specify values on the annotations. Are you wondering whether the
    values are configurable? Let's discuss this in the next section!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到每个注解的参数都有默认值。你还可以在注解上指定值。你在想这些值是否可配置吗？我们将在下一节中讨论这个问题！
- en: Fault Tolerance configuration
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容错配置
- en: The good news is that all of the parameters on the annotations are configurable.
    The values can be overridden either globally or individually. This is achieved
    via **MicroProfile Config**. All of the parameters are properties. Their values
    can be specified in any configured config source.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，注解上的所有参数都是可配置的。这些值可以是全局覆盖或单独覆盖。这是通过**MicroProfile Config**实现的。所有参数都是属性。它们的值可以在任何配置的配置源中指定。
- en: Overriding parameter values
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖参数值
- en: 'To override individual annotation parameters, you can use method-level configuration,
    class-level configuration, or global configuration as explained here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖单个注解参数，你可以使用方法级别配置、类级别配置或全局配置，如这里所述：
- en: '**Method-level configuration**: It is specified using the format *<fully.qualified.class.name>/<method.name>/<annotation.name>/<parameter.name>*.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法级别配置**：使用格式*<完全限定的类名>/<方法名>/<注解名>/<参数名>*进行指定。'
- en: '**Class-level configuration**: It is specified using the format *<fully.qualified.class.name>/<annotation.name>/<parameter.name>*.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类级别配置**：使用格式*<完全限定的类名>/<注解名>/<参数名>*进行指定。'
- en: '**Global configuration**: It is specified using the format *<annotation.name>/<parameter.name>*.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局配置**：使用格式*<注解名>/<参数名>*进行指定。'
- en: 'Let''s take a look at an example to explain further:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来进一步解释：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code snippet sets the `Timeout` to be `500` milliseconds with at most
    `6` retries. To set `Timeout` to `300` milliseconds and at most `10` retries,
    you can specify the following method-level config properties in any config sources:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将`Timeout`设置为`500`毫秒，最多重试`6`次。要设置`Timeout`为`300`毫秒且最多重试`10`次，您可以在任何配置源中指定以下方法级别配置属性：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alternatively, if you would like to update all of the timeout and the maximum
    of retries for this class, you can just omit the method names, which means the
    configurations are appliable to all of the methods with the corresponding annotations
    specified. Then, specify the following class-level configuration in a configured
    config source:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想更新此类的所有超时和最大重试次数，你可以省略方法名称，这意味着配置适用于所有具有相应注解的方法。然后，在配置的配置源中指定以下类级别配置：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Sometimes, you might want to specify the same timeout value for all of the
    classes under one application. It is simple. Just omit the fully qualified class
    name. Therefore, you can use the following global configuration to achieve that:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想为单个应用程序下的所有类指定相同的超时值。这很简单。只需省略完全限定的类名。因此，你可以使用以下全局配置来实现这一点：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sometimes, your cloud infrastructure, such as **Istio**, which we will discuss
    in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146), *MicroProfile
    Ecosystem with Open Liberty, Docker, and Kubernetes*, provides some Fault Tolerance
    capabilities. However, cloud infrastructure will not be able to provide fallback
    capabilities as the infrastructure needs business knowledge. If you prefer to
    use the Fault Tolerance capabilities provided by Istio, you might want to turn
    off some MicroProfile Fault Tolerance capabilities. If you don't, you will get
    both Fault Tolerance functionalities and they will interfere with each other.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的云基础设施，例如**Istio**，我们将在[*第7章*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146)“与Open
    Liberty、Docker和Kubernetes一起的MicroProfile生态系统”中讨论，提供一些容错能力。然而，云基础设施无法提供回退能力，因为基础设施需要业务知识。如果你更喜欢使用Istio提供的容错能力，你可能想关闭一些MicroProfile容错能力。如果不关闭，你将获得两种容错功能，它们将相互干扰。
- en: Disabling Fault Tolerance policies
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用容错策略
- en: 'If you want to use the Fault Tolerance policies provided by Istio, you can
    specify the following property to turn off all of Fault Tolerance policies except
    `Fallback`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用Istio提供的容错策略，你可以指定以下属性来关闭除`Fallback`之外的所有容错策略：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To disable a particular policy on a method, specify the following method-level
    property:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要在方法上禁用特定策略，请指定以下方法级别属性：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the previous example, in order to turn off `Timeout` on the method `invokeService()`,
    specify the following method-level configuration:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，为了在`invokeService()`方法上关闭`Timeout`，请指定以下方法级别配置：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Alternatively, in order to turn off `Timeout` on the class, specify the following
    class-level configuration.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了在类中关闭`Timeout`，请指定以下类级别配置。
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To disable the `Timeout` capability for your cloud-native application, specify
    the following property:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用云原生应用的`Timeout`功能，请指定以下属性：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If multiple configurations are specified, the configuration specified on the
    method level has a higher priority, followed by class-level configuration and
    then global configuration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了多个配置，方法级别的配置具有更高的优先级，其次是类级别配置，然后是全球配置。
- en: So far, you have learned how to apply Fault Tolerance policies to some operations
    and configure the policies. However, these policies are there to be triggered
    under some criteria. It is very possible that none of the policies are utilized.
    You might be keen to find out whether any Fault Tolerance policies are activated.
    In response to this need, we have Fault Tolerance metrics. Let's take a look at
    them in the next section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何将容错策略应用于某些操作并配置策略。然而，这些策略是为了在某些标准下被触发的。很可能没有任何策略被利用。你可能非常想了解是否有任何容错策略被激活。为了满足这一需求，我们有了容错指标。让我们在下一节中看看它们。
- en: Fault Tolerance metrics
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容错指标
- en: MicroProfile Fault Tolerance, when used together with MicroProfile Metrics,
    is able to emit some useful metrics for the Retry, Timeout, CircuitBreaker, Bulkhead,
    and Fallback policies. In the following tables, I have listed all of the relevant
    metrics.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当与MicroProfile Metrics一起使用时，MicroProfile Fault Tolerance能够为Retry、Timeout、CircuitBreaker、Bulkhead和Fallback策略提供一些有用的指标。在以下表格中，我列出了所有相关的指标。
- en: 'The following table shows the general metrics whenever Fault Tolerance is applied:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了应用容错时的一般指标：
- en: '![Table 5.1 – Method invocation metrics'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![表5.1 – 方法调用指标'
- en: '](img/Table_5.1_new.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_5.1_new.jpg)'
- en: Table 5.1 – Method invocation metrics
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 方法调用指标
- en: 'If `@Retry` is used, the metrics for retry will be provided:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`@Retry`，将提供重试的指标：
- en: '![Table 5.2 – Retry metrics'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.2 – 重试指标'
- en: '](img/Table_5.2_new.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.2 – 新表5.2](img/Table_5.2_new.jpg)'
- en: Table 5.2 – Retry metrics
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 – 重试指标
- en: 'If `@Timeout` is used, the following metrics will be provided:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`@Timeout`，将提供以下指标：
- en: '![Table 5.3 – Timeout metrics'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.3 – 超时指标'
- en: '](img/Table_5.3_new.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.3 – 新表5.3](img/Table_5.3_new.jpg)'
- en: Table 5.3 – Timeout metrics
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.3 – 超时指标
- en: 'If `@CircuitBreaker` is used, you will see the following metrics:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`@CircuitBreaker`，您将看到以下指标：
- en: '![Table 5.4 – CircuitBreaker metrics'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.4 – 电路断路器指标'
- en: '](img/Table_5.4_new.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.4 – 新表5.4](img/Table_5.4_new.jpg)'
- en: Table 5.4 – CircuitBreaker metrics
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.4 – 电路断路器指标
- en: 'If `@Bulkhead` is used, you will be able to see the following metrics:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`@Bulkhead`，您将能够看到以下指标：
- en: '![Table 5.5 – Bulkhead metrics'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.5 – 防火墙指标'
- en: '](img/Table_5.5_new.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.5 – 新表5.5](img/Table_5.5_new.jpg)'
- en: Table 5.5 – Bulkhead metrics
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.5 – 防火墙指标
- en: You have learned about all of the functionalities of Fault Tolerance. You might
    be wondering how to start using the APIs provided by Fault Tolerance. We will
    discuss this in the next section.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了所有容错功能。您可能想知道如何开始使用容错提供的API。我们将在下一节中讨论这个问题。
- en: Making the MicroProfile Fault Tolerance API available
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使MicroProfile容错API可用
- en: 'MicroProfile Fault Tolerance API JARs can be made available for either Maven
    and Gradle projects. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile容错API JAR可以为Maven和Gradle项目提供。如果您创建了一个Maven项目，您可以直接将以下内容添加到您的`pom.xml`中：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了一个Gradle项目，您需要添加以下依赖项：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You have now learned how to make your cloud-native applications resilient. The
    next step is to document your applications. You will learn how to document your
    applications using MicroProfile OpenAPI in the next section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学会了如何使您的云原生应用程序具有弹性。下一步是记录您的应用程序。您将在下一节中学习如何使用MicroProfile OpenAPI记录您的应用程序。
- en: Documenting cloud native applications using MicroProfile OpenAPI
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile OpenAPI记录云原生应用程序
- en: As mentioned in [*Chapter 2*](B17377_02_Final_SB_epub.xhtml#_idTextAnchor036),
    *How Does MicroProfile Fit into Cloud-Native Applications?*, you might have difficulties
    remembering what functionalities a particular cloud-native application has when
    you have tens or hundreds of cloud-native applications to manage. You will need
    to provide documentation for them. With documented endpoints, some clients can
    discover and invoke them.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[*第二章*](B17377_02_Final_SB_epub.xhtml#_idTextAnchor036)中提到的，*MicroProfile如何适应云原生应用程序？*，当您管理数十或数百个云原生应用程序时，您可能会难以记住特定云原生应用程序的功能。您将需要为它们提供文档。有了文档化的端点，一些客户端可以发现并调用它们。
- en: '**MicroProfile OpenAPI** (source code at [https://github.com/eclipse/microprofile-open-api/](https://github.com/eclipse/microprofile-open-api/))
    provides a set of annotations and programming models that enable you to document
    cloud-native applications and then produce documents conforming to the **OpenAPI**
    v3 specification ([https://github.com/OAI/OpenAPI-Specification](https://github.com/OAI/OpenAPI-Specification)).
    The OpenAPI v3 specification defines a set of interfaces for documenting and exposing
    RESTful APIs. MicroProfile OpenAPI adopts the OpenAPI Specification and further
    simplifies the OpenAPI model so that it is much easier for Java developers to
    document their cloud-native applications.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile OpenAPI**（源代码位于[https://github.com/eclipse/microprofile-open-api/](https://github.com/eclipse/microprofile-open-api/)）提供了一套注解和编程模型，使您能够记录云原生应用程序，然后生成符合**OpenAPI**
    v3规范的文档（[https://github.com/OAI/OpenAPI-Specification](https://github.com/OAI/OpenAPI-Specification)）。OpenAPI
    v3规范定义了一组用于记录和公开RESTful API的接口。MicroProfile OpenAPI采用了OpenAPI规范，并进一步简化了OpenAPI模型，使得Java开发者更容易记录他们的云原生应用程序。'
- en: 'MicroProfile OpenAPI offers three ways to document cloud-native applications:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI提供了三种方式来记录云原生应用程序：
- en: By applying **MicroProfile OpenAPI** annotations on JAX-RS operations
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在JAX-RS操作上应用**MicroProfile OpenAPI**注解
- en: Using the programming model from **MicroProfile OpenAPI** to provide an **OpenAPI**
    model tree
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**MicroProfile OpenAPI**的编程模型来提供**OpenAPI**模型树
- en: Using pre-generated **OpenAPI** documents
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预先生成的**OpenAPI**文档
- en: In the next section, we will cover these three mechanisms in more detail.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地介绍这三个机制。
- en: Applying MicroProfile OpenAPI annotations on JAX-RS operations
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JAX-RS操作上应用MicroProfile OpenAPI注解
- en: 'The simple way to produce documentation for your JAX-RS operations is to add
    MicroProfile OpenAPI annotations. A few useful and widely used annotations are
    listed here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的 JAX-RS 操作生成文档的简单方法是添加 MicroProfile OpenAPI 注解。以下列出了一些有用且广泛使用的注解：
- en: '![Table 5.6 – MicroProfile OpenAPI annotations'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.6 – MicroProfile OpenAPI annotations'
- en: '](img/Table_5.6.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 5.6.jpg]'
- en: Table 5.6 – MicroProfile OpenAPI annotations
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Table 5.6 – MicroProfile OpenAPI annotations
- en: 'The following is an example of using OpenAPI annotations to document an operation
    in the IBM StockTrader app **Trade-History**:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 IBM StockTrader 应用程序 **Trade-History** 中使用 OpenAPI 注解记录操作的示例：
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The aforementioned code snippet documents two responses with the annotation
    `@APIResponse`: `404` and `200`. The annotation `@Operation` documents the purpose
    of the operation. The OpenAPI document generated with the preceding annotations
    is detailed here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段使用 `@APIResponse` 注解记录了两个响应：`404` 和 `200`。`@Operation` 注解记录了操作的目的。使用前面的注解生成的
    OpenAPI 文档的详细信息如下：
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the aforementioned document, the endpoint path and the `get` operation description
    were explained with the information from the annotation `@Operation`. Further
    on, the responses for `200` and `404` were described from the information provided
    by the `@APIResponse` annotation. As for the response for the return code `200`,
    the schema `Quote` was referenced by the annotation `@Schema`, so `$ref: ''#/components/schemas/Quote`
    was displayed as the schema reference. The reference points to the section `components/
    schemas/Quote`, which displays the details of the schema `Quote`.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述文档中，使用 `@Operation` 注解中的信息解释了端点路径和 `get` 操作描述。进一步地，从 `@APIResponse` 注解提供的信息中描述了
    `200` 和 `404` 的响应。至于返回代码 `200` 的响应，通过 `@Schema` 注解引用了模式 `Quote`，因此 `$ref: ''#/components/schemas/Quote''`
    显示为模式引用。该引用指向 `components/schemas/Quote` 部分，显示了模式 `Quote` 的详细信息。'
- en: 'Without using any MicroProfile OpenAPI annotations, MicroProfile OpenAPI still
    generates an OpenAPI document for all of the JAX-RS endpoints with minimum information.
    The following is the example for the endpoint `latestBuy` if no OpenAPI annotations
    are applied. It only lists the minimum information on the successful return code
    `200`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用任何 MicroProfile OpenAPI 注解的情况下，MicroProfile OpenAPI 仍然为所有 JAX-RS 端点生成 OpenAPI
    文档，并包含最小信息。以下是在未应用 OpenAPI 注解的情况下 `latestBuy` 端点的示例。它只列出了成功返回代码 `200` 的最小信息：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Apart from using MicroProfile OpenAPI annotations, you can use a programming
    model to generate documents. We will discuss this in the next section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 MicroProfile OpenAPI 注解外，您还可以使用编程模型生成文档。我们将在下一节中讨论这个问题。
- en: Using a programming model to generate documentation
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编程模型生成文档
- en: 'Sometimes, it might not be possible to put MicroProfile OpenAPI annotations
    on JAX-RS operations. In this case, you can provide your own implementation of
    **OASModelReader** from MicroProfile OpenAPI. The OASModelReader API provides
    a way for an OpenAPI document to be built from scratch. Follow the steps mentioned
    to build an OpenAPI model tree:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能无法在 JAX-RS 操作上放置 MicroProfile OpenAPI 注解。在这种情况下，您可以从 MicroProfile OpenAPI
    提供自己的 `OASModelReader` 实现。OASModelReader API 提供了一种从头开始构建 OpenAPI 文档的方法。按照提到的步骤构建
    OpenAPI 模型树：
- en: 'Implement the `org.eclipse.microprofile.openapi.OASModelReader` interface.
    You can see an example here: [https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples](https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples).'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `org.eclipse.microprofile.openapi.OASModelReader` 接口。您可以在以下示例中看到：[https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples](https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples)。
- en: Register the implementation using the `mp.openapi.model.reader` configuration
    key and store the configuration in a config source.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mp.openapi.model.reader` 配置键注册实现，并将配置存储在配置源中。
- en: If providing a complete OpenAPI model tree, set the configuration `mp.openap.scan.disabled=true`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提供完整的 OpenAPI 模型树，设置配置 `mp.openap.scan.disabled=true`。
- en: The link [https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples](https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples)
    provides an example of implementing `OASModelReader`. In *step 2* and *step 3*,
    you can specify the properties under `META-INF/microprofile-config.properties`
    or as system properties.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 链接 [https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples](https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples)
    提供了实现 `OASModelReader` 的示例。在 *步骤 2* 和 *步骤 3* 中，您可以在 `META-INF/microprofile-config.properties`
    或作为系统属性中指定属性。
- en: Using pre-generated OpenAPI documents
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预生成的 OpenAPI 文档
- en: Sometimes, you will write OpenAPI documents first by using an editor such as
    the Swagger Editor ([https://editor.swagger.io/](https://editor.swagger.io/)).
    Documents must be named `openapi` with a `yml`, `yaml`, or `json` file extension
    and be placed under the `MEAT-INF` directory. If the document is complete, you
    can set the property `mp.openap.scan.disabled=true`. Otherwise, the scan operation
    will be performed to discover any MicroProfile OpenAPI annotations.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会首先使用像 Swagger Editor（[https://editor.swagger.io/](https://editor.swagger.io/)）这样的编辑器来编写
    OpenAPI 文档。文档必须命名为 `openapi`，并带有 `yml`、`yaml` 或 `json` 文件扩展名，并放置在 `MEAT-INF` 目录下。如果文档完整，您可以设置属性
    `mp.openap.scan.disabled=true`。否则，将执行扫描操作以发现任何 MicroProfile OpenAPI 注解。
- en: So far, we have briefly introduced the three ways to create OpenAPI documents.
    The documents can be viewed using the URL [http://host_name/port_number/openapi](http://host_name/port_number/openapi).
    Open Liberty, which will be discussed in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146),
    *MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes*, has the Swagger
    UI integrated, so you can visit [http://host_name/port_number/openapi/ui](http://host_name/port_number/openapi/ui)
    for a GUI view, where you can supply parameters and then directly invoke the individual
    endpoints. More information on this UI will be covered in [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173),
    *Deployment and Day 2 Operations*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们简要介绍了创建 OpenAPI 文档的三种方法。这些文档可以通过 URL [http://host_name/port_number/openapi](http://host_name/port_number/openapi)
    查看。Open Liberty，将在[*第 7 章*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146)中讨论，即
    *使用 Open Liberty、Docker 和 Kubernetes 的 MicroProfile 生态系统*，集成了 Swagger UI，因此您可以访问
    [http://host_name/port_number/openapi/ui](http://host_name/port_number/openapi/ui)
    以获得图形用户界面视图，在那里您可以提供参数然后直接调用单个端点。有关此 UI 的更多信息将在[*第 9 章*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173)中介绍，即
    *部署和第 2 天操作*。
- en: Cloud-native application developers may wish to remove or update certain elements
    of the OpenAPI document. This is done via a filter, which is invoked once the
    OpenAPI document is created. We will discuss filters in the next section.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud-native 应用程序开发人员可能希望删除或更新 OpenAPI 文档的某些元素。这是通过过滤器完成的，该过滤器在 OpenAPI 文档创建后调用。我们将在下一节中讨论过滤器。
- en: Applying filters to the OpenAPI document
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用过滤器到 OpenAPI 文档
- en: 'If you want to add some information to the OpenAPI document, you can create
    a filter. The filter needs to implement the OASFilter interface, which provides
    a way to update an OpenAPI document. Let''s look at the following filter:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想向 OpenAPI 文档添加一些信息，您可以创建一个过滤器。该过滤器需要实现 OASFilter 接口，它提供了一种更新 OpenAPI 文档的方式。让我们看看以下过滤器：
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the aforementioned code snippet, the `filterOpenAPI()` method filters the
    OpenAPI element. This method is called only once as the last method for a particular
    filter. It provides the `info` and the `servers` elements of the OpenAPI document.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`filterOpenAPI()` 方法过滤 OpenAPI 元素。该方法仅作为特定过滤器的最后一个方法被调用。它提供了 OpenAPI
    文档的 `info` 和 `servers` 元素。
- en: After you have created a filter class, the next step is to specify the configuration
    `mp.openapi.filter=com.acme.MyOASFilter` in a config source, such as `microprofile-config.properties`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建了过滤器类之后，下一步是在配置源中指定配置 `mp.openapi.filter=com.acme.MyOASFilter`，例如 `microprofile-config.properties`。
- en: 'A MicroProfile OpenAPI implementation generates the documents in the following
    sequence:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI 实现按以下顺序生成文档：
- en: The implementation fetches configuration values with the prefix of `mp.openapi`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现通过 `mp.openapi` 前缀检索配置值。
- en: It then invokes `OASModelReader`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它调用 `OASModelReader`。
- en: It fetches static OpenAPI files with the name of `openapi.yml`, `openapi.yaml`,
    or `openapi.json`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检索名为 `openapi.yml`、`openapi.yaml` 或 `openapi.json` 的静态 OpenAPI 文件。
- en: It processes MicroProfile OpenAPI annotations.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它处理 MicroProfile OpenAPI 注解。
- en: Finally, it filters the OpenAPI documentation via `OASFilter`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它通过 `OASFilter` 过滤 OpenAPI 文档。
- en: As mentioned in *step 1*, several configurations with the prefix of `mp.openapi`
    can be defined by MicroProfile OpenAPI. We will go through the configurations
    in the next section.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*步骤 1*]所述，MicroProfile OpenAPI 可以定义带有 `mp.openapi` 前缀的几个配置。我们将在下一节中介绍这些配置。
- en: MicroProfile OpenAPI configuration
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI 配置
- en: 'MicroProfile OpenAPI provides some flexibility for application developers to
    configure the process when generating OpenAPI documents. The configurations are
    listed in the following table:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI为应用程序开发者提供了在生成OpenAPI文档时配置过程的灵活性。配置项列在以下表格中：
- en: '![Table 5.7 – MicroProfile OpenAPI configurations'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![表5.7 – MicroProfile OpenAPI配置'
- en: '](img/Table_5.7.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_5.7.jpg)'
- en: Table 5.7 – MicroProfile OpenAPI configurations
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.7 – MicroProfile OpenAPI配置
- en: Now we have covered how **MicroProfile OpenAPI** works. The implementation of
    MicroProfile OpenAPI will generate an OpenAPI document based on MicroProfile OpenAPI
    policies. Where can you view the fully processed OpenAPI document? In the next
    section, we will discuss where the OpenAPI document can be accessed.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了**MicroProfile OpenAPI**的工作原理。MicroProfile OpenAPI的实现将基于MicroProfile
    OpenAPI策略生成一个OpenAPI文档。你可以在哪里查看完全处理后的OpenAPI文档？在下一节中，我们将讨论OpenAPI文档的访问位置。
- en: Viewing an OpenAPI document
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看OpenAPI文档
- en: The fully processed OpenAPI document must be available at the root URL `/openapi`,
    as an HTTP `Get` operation, such as `http://localhost:9080/openapi`. The default
    format of the document is YAML. Support for the JSON format is required if the
    response contains a `Content-Type` header with a value of `application/json`.
    Open Liberty supports the query parameter format, which allows you to specify
    whether you want YAML or JSON format. For instance, the endpoint `http://localhost:9080/openapi?format=JSON`
    displays the OpenAPI document in JSON format, while the endpoint [http://localhost:9080/openapi?format=YAML](http://localhost:9080/openapi?format=YAML)
    displays an OpenAPI document in YAML format.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 完全处理后的OpenAPI文档必须在根URL `/openapi` 上可用，作为一个HTTP `Get`操作，例如`http://localhost:9080/openapi`。默认的文档格式是YAML。如果响应包含值为`application/json`的`Content-Type`头，则需要支持JSON格式。Open
    Liberty支持查询参数格式，允许你指定你想要YAML还是JSON格式。例如，端点`http://localhost:9080/openapi?format=JSON`以JSON格式显示OpenAPI文档，而端点[http://localhost:9080/openapi?format=YAML](http://localhost:9080/openapi?format=YAML)则以YAML格式显示OpenAPI文档。
- en: Open Liberty provides a UI for OpenAPI documents, where you can invoke the endpoints
    included. The UI is available at the root URL `/openapi/ui`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Open Liberty提供了一个用于OpenAPI文档的UI，你可以调用其中的端点。该UI在根URL `/openapi/ui` 上可用。
- en: You have learned how MicroProfile OpenAPI works and where to find the OpenAPI
    documents. Now, you are ready to use MicroProfile OpenAPI. In the next section,
    we will discuss how to make the APIs available to your Maven and Gradle projects.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了MicroProfile OpenAPI的工作原理以及在哪里可以找到OpenAPI文档。现在，你准备好使用MicroProfile OpenAPI了。在下一节中，我们将讨论如何使API对你的Maven和Gradle项目可用。
- en: Making MicroProfile OpenAPI APIs available
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使MicroProfile OpenAPI API可用
- en: 'To use MicroProfile OpenAPI APIs, you need to make these APIs available to
    your application. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MicroProfile OpenAPI API，你需要使这些API对你的应用程序可用。如果你创建了一个Maven项目，你可以直接将以下内容添加到你的`pom.xml`文件中：
- en: '[PRE46]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你创建了一个Gradle项目，你需要添加以下依赖项：
- en: '[PRE47]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With this, you have learned how to document your cloud-native application. The
    next step is to secure your applications. We will learn how to secure your applications
    with the help of MicroProfile JWT ([https://github.com/eclipse/microprofile-jwt-auth](https://github.com/eclipse/microprofile-jwt-auth)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你已经学会了如何记录你的云原生应用程序。下一步是保护你的应用程序。我们将学习如何借助MicroProfile JWT（[https://github.com/eclipse/microprofile-jwt-auth](https://github.com/eclipse/microprofile-jwt-auth)）来保护你的应用程序。
- en: Securing cloud-native applications using MicroProfile JWT
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile JWT保护云原生应用程序
- en: MicroProfile JWT utilizes **JSON Web Token** (**JWT**) with some additional
    claims for role-based access control of an endpoint to help with securing cloud-native
    applications. Securing cloud-native applications is often the must-have feature.
    It is often the case that cloud-native applications supply sensitive information,
    which should only be accessible to a particular group of users. Without securing
    cloud-native applications, everyone would be able to access the information. **Jakarta
    Security** (source code at [https://github.com/eclipse-ee4j/security-api](https://github.com/eclipse-ee4j/security-api)),
    a specification ([https://jakarta.ee/specifications/security/](https://jakarta.ee/specifications/security/))
    under Jakarta EE, can be used to secure cloud-native applications.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile JWT利用**JSON Web Token**（**JWT**）和一些额外的声明，用于端点的基于角色的访问控制，以帮助保护云原生应用。保护云原生应用通常是必须具备的功能。通常情况下，云原生应用提供敏感信息，这些信息只能由特定用户组访问。如果不保护云原生应用，任何人都可以访问信息。**Jakarta
    Security**（源代码位于[https://github.com/eclipse-ee4j/security-api](https://github.com/eclipse-ee4j/security-api)），是Jakarta
    EE下的一个规范（[https://jakarta.ee/specifications/security/](https://jakarta.ee/specifications/security/)），可用于保护云原生应用。
- en: 'In the following example, the method `checkAccount` is secured via the Jakarta
    Security API `@RolesAllowed`. This method can only be invoked by clients with
    the access group `StockViewer` or `StockTrader`. All other users are denied as
    shown here:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`checkAccount` 方法通过Jakarta Security API的`@RolesAllowed`进行安全保护。此方法只能由具有`StockViewer`或`StockTrader`访问组的客户端调用。所有其他用户都会被拒绝，如下所示：
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, you can use `web.xml` configuration to directly secure the end
    point. In the following code snippet, it defines two roles, `StockViewer` and
    `StockTrader`, and they can access all `GET` operations, where `StockViewer` can
    only access read-only operations and `StockTrader` can access all operations:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`web.xml`配置直接保护端点。在以下代码片段中，它定义了两个角色，`StockViewer`和`StockTrader`，并且它们可以访问所有`GET`操作，其中`StockViewer`只能访问只读操作，而`StockTrader`可以访问所有操作：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After the endpoint is secured, we then need to work out how to get the client
    to invoke the secured backend. To answer this question, we'll first discuss the
    unique aspect of application security for cloud-native applications.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点被保护之后，我们接下来需要考虑如何让客户端调用受保护的后端。为了回答这个问题，我们首先将讨论云原生应用的独特应用安全方面。
- en: Cloud-native application security is different from traditional applications
    as cloud-native applications are often stateless and the server side might not
    be able to persist any states on the clients. Besides, there might be different
    instances of the backend and each subsequent client request might not hit the
    same backend instance. As you can see, storing client data on the backend is problematic.
    Therefore, the recommended approach is to pass on the security-related info via
    each request.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用安全与传统应用不同，因为云原生应用通常是无状态的，服务器端可能无法在客户端持久化任何状态。此外，后端可能有不同的实例，每个后续客户端请求可能不会击中相同的后端实例。正如您所看到的，在后端存储客户端数据是有问题的。因此，建议的方法是通过每个请求传递安全相关信息。
- en: The backend service will then create a security context for each request and
    perform both authentication and authorization checks. This means that the security-related
    info needs to include both authentication and authorization details. In the next
    section, we will look at the technologies used to achieve this goal.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务将为每个请求创建一个安全上下文，并执行认证和授权检查。这意味着安全相关信息需要包括认证和授权的详细信息。在下一节中，我们将探讨实现此目标所使用的技术。
- en: What technologies do we use to secure cloud-native applications?
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们使用什么技术来保护云原生应用？
- en: 'The technologies used for cloud-native application security are based on **OAuth2**,
    **OpenID Connect**, and **JSON Web Token** (**JWT**) standards:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用于云原生应用安全的技术基于**OAuth2**、**OpenID Connect**和**JSON Web Token**（**JWT**）标准：
- en: '**OAuth2**: An authorization framework that controls authorization to a protected
    resource such as a cloud-native application. OAuth2 is about user authorization.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth2**：一个授权框架，用于控制对受保护资源（如云原生应用）的授权。OAuth2是关于用户授权的。'
- en: '**OpenID Connect (OIDC)**: An authentication framework that builds on top of
    the OAuth 2.0 protocol. It allows third-party applications such as Google or Facebook
    to verify the identification of an end user and to obtain some user information.
    OIDC is about user authentication.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JWT**: A compact, URL-safe way to transfer claims between two parties. It
    contains a set of claims, represented as a JSON object, which is base64url-encoded,
    digitally signed (**JWS**), and optionally encrypted (**JWE**).'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT format
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JWT can be used to propagate ID for authentication and user entitlement for
    authorization. It is used by both OAuth2 and OpenID Connect. The most important
    feature of JWT is that the data itself is self-described and verifiable. It provides
    a tamper-resistant way to pass information around. At JWT creation time, the **Issuer**
    signs the JWT with its **Private Key**. Upon receiving the JWT, **Receivers**
    can then use the matching **Public Key** to verify the JWT to ensure that the
    JWT has not been tampered with.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: JWT is a general abstract term. It can be either **signed JWT** or **encrypted
    JWT**. A signed JWT is known as a **JWS** (**JSON Web Signature**) while an encrypted
    JWT is known as **JWE** (**JSON Web Encryption**). A **JSON Web Key** (**JWK**)
    is a JSON object that represents a cryptographic key and is used to decrypt a
    JWE or JWS to validate the signature.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'After a security token – JWT – has been generated, **Token-Based Authentication**
    is normally used to allow systems to make authentication and authorization decisions
    based on a security token. For cloud-native applications, a token-based authentication
    mechanism offers a lightweight way for security controls and security tokens to
    propagate user and entitlement info across cloud-native applications. Since the
    JWT token is used for authentication and authorization purposes, two new claims
    are introduced to the MicroProfile JWT:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '**upn**: This claim specifies the user principal.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**groups**: This claim lists the group names.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There can be many claims included in a JWT. The following claims are required
    for MicroProfile JWT, while the claim for groups are optional from MicroProfile
    JWT Propagation version 1.2 onwards:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`iss`: This claim specifies the token issuer.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`: This claim specifies the time when the token was issued.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp`: This claim indicates the expiration time of the token.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upn` (or `preferred_username` or `sub`): This claim specifies the principal
    name. If `upn` is not present, fall back to `preferred_username`. If `preferred_username`
    is not present, fall back to `sub`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the aforementioned mandatory claims, there are some optional claims
    listed here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '`aud`: The endpoint, which can be assessed by JWT.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jti`: The unique identifier for this JWT'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`: The unique identifier of the principal of this JWT.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preferred_user_name`: The preferred username of this JWT.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are two different types of JWT: JWS and JWE. JWS
    is very popular. We will discuss it in more detail.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: JWS in more detail
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JWS is a prominent format of JWT. A JWS has three parts, which are separated
    by a dot. The following is an example of JWS, where you can find the first dot
    on the first line and the second dot on the seventh line:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The three dot-separated parts are the header, payload, and signature. You can
    paste the preceding encoded form in https://jwt.io/ to retrieve the three parts
    in human-readable text. We are going to review the three parts in more detail
    here:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '`alg` (RS256 or ES256), `enc` (a cryptographic algorithm to encrypt the claims),
    `typ` (JWT), and `kid` (the key that was used to secure the JWT). Here is an example
    of the header. It means `JWT` as the `typ` and `RS256` as the `alg`:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Payload**: This contains a number of claims. Here is an example of the payload:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Signature**: The signature is used to verify that the messages weren''t changed
    during the transmission. It is created using an encoded header, an encoded payload,
    a secret, the algorithm specified in the header, and then signed. The following
    is an example of verifying a signature, which computes the signature based on
    the header and payloader and then compares it with the passed-in signature. If
    they match, it means the token has not been tampered with during transmission:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the next section, we are going to discuss how MicroProfile JWT works.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: How does MicroProfile JWT work?
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned what MicroProfile JWT looks like together with the basic concept
    of MicroProfile JWT. To use JWT, we need to first create a token.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Issuing a MicroProfile JWT token
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A MicroProfile JWT token can be issued by runtimes that support the creation
    of MicroProfile JWT or trusted OpenID Connect providers. MicroProfile JWT can
    be self-issued by a trusted server, where a set of token-issuing APIs are provided.
    Open Liberty, Eclipse Vert.x, and other runtimes have such APIs available. The
    following is an example of using the Open Liberty API to create a JWT token:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This JWT token contains the claims `sub (Claims.SUBJECT)`, `upn`, and `groups`.
    In production, it is common that MicroProfile JWTs are issued by some trusted
    OpenID Connect providers such as Auth0, Keycloak, Azure, Okta, and so on.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The only supported JWT algorithms are RS256 and ES256\. The token will be rejected
    if other algorithms are used.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: JWT generation
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Since MicroProfile JWT has two more claims over JWT, these claims need to be
    manually added as custom claims in the OpenID Connect providers such as Keycloak,
    Okta, and others.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Transferring MicroProfile JWTs from a client to a server
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MicroProfile JWTs are transferred over a HTTP request. They can be passed either
    via an HTTP Authorization header or an HTTP cookie:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '`mp.jwt.token.header` can be used to store the JWT in the following format:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`mp.jwt.token.cookie` can be used to store the JWT in the following format:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Validating MicroProfile JWTs by the server
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MicroProfile JWTs must be signed (JWSes). To decode JWSes, the corresponding
    public key must be specified. The location to the public key can be provided via
    the property `mp.jwt.verify.publickey.location`. Alternatively, the public key
    itself can be provided via the property `mp.jwt.verify.publickey`. The two properties
    are not allowed to be specified together. Otherwise, a `DeploymentException` will
    be thrown.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: The signed JWTs can be further encrypted (JWE). When the server receives MicroProfile
    JWTs, it will validate the JWTs. If the JWT is a JWE, it will need to use the
    corresponding private key to decrypt the JWE. The location of the private key
    can be specified in the property `mp.jwt.decrypt.key.location`. If this property
    is present, the received JWTs must be a JWE. Otherwise, the JWTs will be rejected.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: After the signature of a JWT has been verified or the token has been decrypted,
    some further validations can be performed, such as `iss` and `aud` validation.
    The `mp.jwt.verify.issuer` property specifies the expected `iss` value while the
    property `mp.jwt.verify.audiences` specifies the `aud` value.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: After the JWTs have been verified, the object `JsonWebToken` is made available
    to the cloud-native application as a backend.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Some MicroProfile JWT implementation might also provide additional validation
    mechanisms. In Open Liberty, you can specify the following line in your `server.xml`
    to validate against the `issuer` and `audiences` if the corresponding properties
    are absent:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This mechanism will be used by the **Stock Trader** application, which will
    be covered in more detail in [*Chapter 8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159),
    *Building and Testing Your Cloud-Native Application*.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, when a JWT is received and decoded, its `aud` and
    `iss`  claim will be compared with audiences defined in `${JWT_AUDIENCE}` and
    `${JWT_ISSUER}` correspondingly. If they match, the JWT will be accepted and then
    perform further authentication and authorization checks.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Accessing JsonWebToken
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cloud-native applications can access `JsonWebToken` via the following ways:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Access `JsonWebToken` via `SecurityContext`. The following code snippet demonstrates
    how to retrieve a `JsonWebToken` object from the injected `SecurityContext`:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`JsonWebToken` contains all claims. `JsonWebToken` is a subclass of `Principal`.'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can use CDI injection to inject the whole `JsonWebToken`:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can use CDI injection to inject a particular claim. The following example
    demonstrates assigning the claim `raw_token` string to the `rawToken variable`:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This line is to inject the claim `iat` with the type of `Long` to the `dupIssuedAt
    variable`:'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following line injects the claim `sub` with the type of `ClaimValue` to
    the `optSubject variable`. This lookup is dynamic:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ClaimValue is a representation of a claim in a `JsonWebToken`, which is a wrapper
    class for the specified claim.
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since the JWT is attached to a particular request, it is expected that the
    token is bound to a lifecycle of `RequestScoped`. When injecting `JsonWebToken`
    or `Claims` into a scope with a lifecycle greater than `RequestScoped`, such as
    `ApplicationScoped`,or `SessionScoped`, you should use the type of `Provider`,
    `Instance`, or `ClaimValue` as these are wrappers and will always retrieve the
    JWTs dynamically for the specified request. Generally speaking, you can use the
    following code snippet to retrieve a specified claim, `a_claim`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`<Claim_Type>` can be `String`, `Long`, `long`, `Boolean`, `Set<String>`, `JsonValue.TRUE`,
    `JsonValue.FALSE`, `JsonString`, J`sonNumber`, `JsonArray`, or `JsonObject`. It
    can be optional wrapper of the listed types or `ClaimValue` of the types, including
    `Optional`.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile JWT can be propagated to downstream services if the invocation
    is via the MicroProfile Rest Client (MicroProfile Rest Client has been discussed
    in great detail in [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*.). The propagation will be automatically
    handled by setting the following configuration:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If the JWT is specified as an authorization header, the value will be `Authentication`.
    If the JWT is specified as a cookie, the value will be `Cookie`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Where to find the public key and private key
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to security, you will immediately think about keys. There is
    no exception here. In MicroProfile JWT, you will need a public key to decode a
    JWS and a private key to decrypt JWE. If you received JWE, you will need to use
    your private key to decrypt it first. After the decryption, you will get a JWS.
    Then you will need to use your public key to decode the JWS to verify the signature.
    MicroProfile JWT provides the following configuration for you to retrieve the
    keys:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.8 – MicroProfile JWT configuration'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.8.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.8 – MicroProfile JWT configuration
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: If the `mp.jwt.decrypt.key.location` property is set and either `mp.jwt.verify.publickey.location`
    or `mp.jwt.verify.publickey` are set, only encrypted JWTs can be accepted.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The properties mentioned in the preceding table are regular MicroProfile configurations.
    They can be specified in any of the config sources, such as *META-INF/microprofile-config.properties*,
    *system properties*, *environment variables*, or other custom config sources.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how MicroProfile JWT works. In the next section, we will discuss
    how to make the APIs available to your Maven or Gradle projects.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: How to make MicroProfile JWT available to applications?
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use MicroProfile JWT APIs, you need to make these APIs available to your
    application. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about MicroProfile Config, which enables you
    to externalize your configuration to achieve a flexible and efficient cloud-native
    architecture, which is also highly recommended by the twelve-factor app.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 MicroProfile Config，它使你能够将配置外部化，以实现灵活高效的云原生架构，这也被十二要素应用高度推荐。
- en: We then went forward to explore how to create a resilient cloud-native application
    using MicroProfile Fault Tolerance so that application developers can concentrate
    on their business logic, where MicroProfile Fault Tolerance handles possible failures
    and then performs retries or limits resource consumption, and so on, via simple
    Fault Tolerance annotations.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续探索如何使用 MicroProfile Fault Tolerance 创建一个具有弹性的云原生应用，这样应用开发者就可以专注于他们的业务逻辑，而
    MicroProfile Fault Tolerance 则处理可能出现的故障，然后通过简单的容错性注解执行重试或限制资源消耗等等。
- en: After we covered Fault Tolerance, we then dived into MicroProfile OpenAPI to
    learn how to document your cloud-native applications using MicroProfile OpenAPI.
    We discussed a few ways to generate OpenAPI documents. Some MicroProfile OpenAPI
    implementation, such as Open Liberty, also provides UI integration for you to
    access endpoints directly via the UI.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍了容错性之后，我们接着深入探讨了 MicroProfile OpenAPI，学习如何使用 MicroProfile OpenAPI 记录你的云原生应用。我们讨论了几种生成
    OpenAPI 文档的方法。一些 MicroProfile OpenAPI 实现，如 Open Liberty，还提供了 UI 集成，让你可以通过 UI 直接访问端点。
- en: Finally, we learned about the topic of securing cloud-native applications using
    MicroProfile JWT. We discussed, in general, the unique requirements for securing
    cloud-native applications and then explained how to use MicroProfile JWT to facilitate
    securing cloud-native applications in a portable and interoperable way.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了使用 MicroProfile JWT 保护云原生应用的主题。我们一般讨论了保护云原生应用的独特要求，然后解释了如何使用 MicroProfile
    JWT 以便携和互操作的方式促进云原生应用的安全保护。
- en: Up to now, you have learned about quite a few technologies you need to develop
    your cloud-native applications. The next task is to consider how to improve your
    day 2 operation experience by building a smart and intelligent cloud-native application,
    which means the application can communicate automatically with cloud infrastructures
    when it is ready to receive requests and so on. It will also be beneficial if
    the application can provide some metrics so that day 2 operations can take some
    precautions before it is too late. We all know faults cannot be eliminated completely.
    If something goes wrong, day 2 operations will offer an easy and simple diagnosis
    to identify the failure straightaway. MicroProfile Health, MicroProfile Metrics,
    and MicroProfile OpenTracing are the technologies to fulfill these requirements.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了许多你需要开发云原生应用的技术。接下来的任务是考虑如何通过构建一个智能和智能的云原生应用来改善你的日常运营体验，这意味着当应用准备好接收请求时，它可以自动与云基础设施进行通信等等。如果应用能够提供一些指标，那么在为时已晚之前，日常运营可以采取一些预防措施。我们都知道错误无法完全消除。如果出现问题，日常运营将提供简单直观的诊断方法来立即识别故障。MicroProfile
    Health、MicroProfile Metrics 和 MicroProfile OpenTracing 是满足这些要求的技术。
- en: In the next chapter, we will discuss why and how you should use MicroProfile
    Health, MicroProfile Metrics, and MicroProfile OpenTracing to help with day 2
    operations.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论为什么以及如何使用 MicroProfile Health、MicroProfile Metrics 和 MicroProfile
    OpenTracing 来帮助处理日常运营。
