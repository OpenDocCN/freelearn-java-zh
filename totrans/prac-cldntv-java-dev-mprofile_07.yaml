- en: '*Chapter 5*: Enhancing Cloud-Native Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications,* we learned how to build cloud-native applications.
    However, building cloud-native applications is just the start. The next step is
    to enhance the applications, by making them configurable, resilient, documentable,
    and secure. In this chapter, you will learn how to configure your cloud-native
    applications using MicroProfile Config, make your applications resilient using
    MicroProfile Fault Tolerance, document their APIs using MicroProfile OpenAPI,
    and finally, secure your applications using MicroProfile JWT. After this chapter,
    you should be able to use these technologies to improve the quality of your cloud-native
    applications. To fully comprehend this chapter, you will need some basic knowledge
    of Java, Maven, and Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring cloud-native applications using MicroProfile Config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making cloud-native applications resilient using MicroProfile Fault Tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting cloud-native applications using MicroProfile OpenAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing cloud-native applications using MicroProfile JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring cloud-native applications using MicroProfile Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MicroProfile Config** (source code located at [https://github.com/eclipse/microprofile-config](https://github.com/eclipse/microprofile-config))
    is the first specification created by the MicroProfile community. The concept
    of configuration has been around for a decade. You may recall in [*Chapter 1*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021),
    *Cloud-Native Application*, we briefly discussed the **Twelve-Factor App**, in
    which the third factor *III.* *Config* ([https://12factor.net/config](https://12factor.net/config))
    recommends that a twelve-factor app stores its configuration in an environment
    that is separate from the application code. This is because any configuration
    value update will not lead to the application code being rebuilt. But sometimes,
    it is not realistically possible to store all configs such as security credentials
    and much more in that environment. It is also common for some configuration to
    be stored in a database. Since the configuration could be in many different places,
    a mechanism for obtaining the configuration is required. Quite a few libraries
    provide this mechanism, such as Apache *DeltaSpike configuration* ([http://deltaspike.apache.org/documentation/configuration.html](http://deltaspike.apache.org/documentation/configuration.html)),
    *Apache Tamaya* ([http://tamaya.incubator.apache.org/](http://tamaya.incubator.apache.org/)),
    and many more.'
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Config was created as a standard so you would not need to worry
    about which library to pull into your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how MicroProfile Config defines how configuration
    can be stored and retrieved by cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Storing configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In MicroProfile Config, the configuration is stored in `ConfigSource` is a place
    where you can put configuration values. Environment variables, system properties,
    property files, databases, ZooKeeper, and much more can all be used as config
    sources. Each `ConfigSource` has an associated ordinal, which is used to indicate
    the importance of the `ConfigSource`. A `ConfigSource` with a higher ordinal means
    the configuration values it specifies will override the `ConfigSource` that specifies
    the same configuration with a lower ordinal.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the `customer_name property` is specified in a `ConfigSource`
    (ordinal = 200) with the value of `Bob`, and the same property is specified with
    the value of `Alice` in another `ConfigSource` (ordinal =120). Then when a cloud-native
    application looks up `customer_name`, the value `Bob` should be retrieved. The
    ordinal of a *ConfigSource* can be defined in the corresponding `ConfigSource`
    via the `config_ordinal` property, which indicates the ranking order of the enclosed
    config source. If not specified, the default config ordinal is 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of config sources: **default config source** and **custom
    config source**, which we discuss in the next subsections.'
  prefs: []
  type: TYPE_NORMAL
- en: Default config sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Default config sources** are the ones mandated by MicroProfile Config and
    all MicroProfile Config implementations must provide them out of the box. MicroProfile
    Config mandates three default config sources to be supported out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: System properties with a default ordinal value of 400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables with a default ordinal value of 300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property file `META-INF/microprofile-config.properties` found on the classpath
    with a default ordinal value of 100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ordinal for the default config sources can be overridden by defining the
    property `config_ordinal` inside the config source. For instance, if you want
    to set the ordinal number for environment variables to 500, you can simply define
    an environment variable's `config_ordinal` with the value of `500`.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variable mapping rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some property names do not qualify as valid environment variables, because
    in some `app.name`) in an environment variable. The search will terminate once
    a match is found from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The exact property name is found, such as `app.name`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the property name contains some characters that are not letters or digits,
    convert these characters to *_* and the transformed property name (`app_name`)
    will be found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the property name contains some characters that are not letters or digits,
    convert the characters to *_* and then convert all letters to uppercase and the
    transformed property name (`APP_NAME`) will be found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the out-of-the-box config sources, you can create your own config
    sources using a file, a database, and much more. These config sources are called
    Custom Config Sources, which we discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Custom config source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Custom config source** is a config source that you define in your application
    other than the default config source. To define a custom config source, you can
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the interface `ConfigSource` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getPropertyNames()`, `getValue(String propertyName)`, and `getName()` methods
    are the ones to be implemented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Register the implementation of these functions using either of the following
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a). Create a `META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource`
    file with the fully qualified class name of the custom implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b). Add to `ConfigBuilder` programmatically via the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sometimes, you have sensitive configuration, and you need to store it somewhere
    safe. You might need to consider using **HashiCorp Vault** ([https://www.vaultproject.io/](https://www.vaultproject.io/)),
    which manages secrets and stores sensitive data. If you store some secret properties
    in *Vault*, you can add *Vault* as a custom config source. Next, we'll look at
    another way of storing configuration using Kubernetes ConfigMaps and Secrets,
    which store configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes ConfigMaps and Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Kubernetes** **ConfigMaps** and **Secrets** are often used to store properties
    for cloud-native applications. You can use the following commands to declare properties
    as Kubernetes ConfigMaps or Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a ConfigMap named `app-port`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a Secret, `app-credentials`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command is similar to creating a ConfigMap. The main difference between
    a Secret and ConfigMap is that a Secret only shows a Base64-encoded version of
    the text instead of cleartext.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After specifying a Kubernetes ConfigMap or Secret, you can map the ConfigMap
    or Secret to environment variables via the `deployment yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the following code to look up the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Based on the defined mapping rules when looking up properties in the environment
    variables, `port` will be searched first, followed by `PORT`. Since the ConfigMap
    property `app_port` is optional, it is not required to be defined in the ConfigMap.
    If it is not found, the default value `9080` will be assigned to the variable
    `port`. As for the other property `app.username`, `app.username` is searched first,
    followed by `app_username`, and then `APP_USERNAME`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned where to store property values, but sometimes, you might
    have to delete a property value. In this next section, we will learn how to erase
    a property.
  prefs: []
  type: TYPE_NORMAL
- en: Removing properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to remove properties, you can simply remove the property entry from
    a config source. However, you might not be able to update a config source. In
    such circumstances, you can define a config source with a higher ordinal and define
    the property with a empty value. This effectively erases the config property.
    Therefore, any lookup for this property will resolve to an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered where to specify config properties. When we store the config
    property values, they are all expressed via strings. You might want to convert
    the strings to some other types, such as **int**, **float**, and so on. To achieve
    this, we will need some converters.
  prefs: []
  type: TYPE_NORMAL
- en: Converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **converter** converts a string to a target type. If a null value is passed
    to the converter, **NullPointerException** (**NPE**) will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as there is more than one type of config source, there are a few types
    of converters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Built-in converters**: They can convert strings to primitive and boxed types
    as well as class types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array converters**: They can convert a comma-separated string to an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` is derived from a class where the class contains one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If more than one method is found, the method appearing at the top of the aforementioned
    list will be used for conversion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.config.spi.Converter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2) Register the converter by creating a `META-INF/services/org.eclipse.microprofile.config.spi.Converter`
    file with the fully qualified class name of the custom implementation or adding
    to `ConfigBuilder` programmatically via one of the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are several types of converters. There might be multiple converters for
    a given type. But the question arises, which converter will be used to transform
    the config string value to the given type? This is determined by converter priority.
  prefs: []
  type: TYPE_NORMAL
- en: Converter priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@javax.annotation.Priority` annotation. If absent, the priority for a custom
    converter will default to 100\. A converter with a higher priority overrides one
    with a lower priority.'
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how to specify the value of a config property with a string
    and then how to convert a string to a particular type. In the next section, we
    will learn how to look up config properties in cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Config lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have learned that config sources contain properties specified in strings
    and converters can convert strings to a target type. But the question arises,
    how do you retrieve a config property? This can be done either programmatically
    or via injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`customer.age` will be retrieved using the `getValue` method and converted
    to an integer using programmatic lookup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`customer.age`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In your cloud-native applications, sometimes different values are specified
    during different project stages. For instance, you might use a different database
    in different project stages. When the project moves through different phases,
    the values associated with those stages will be injected into the corresponding
    config properties. This is called a **config profile**. We will cover this in
    more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding config profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Config profiles are an important concept that can be used to indicate project
    phases, such as development, testing, production, and so on. We'll first discuss
    how to define properties that use config profiles and then learn how to activate
    a particular profile.
  prefs: []
  type: TYPE_NORMAL
- en: Profile-aware properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to define profile-aware properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the naming convention of *%<profile name>.<property name>*, for example,
    defining a property called `%dev.customer.name` in a config source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the properties in a `microprofile-config-<profile name>.properties`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activating a profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An active profile is specified using the property `mp.config.profile`, which
    can be included in any config sources. If more than one config source specifies
    this property, the value from the config source with the highest ordinal is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a few examples. Let''s say we have the following config
    source, containing the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the value of `mp.config.profile` is set to `dev`, the value of the property
    `discount` will resolve to the value of `%dev.discount`, which is `0.1`. Similarly,
    the value of the property `discount` will be `0.2` if the active profile is `live`.
    The value of the property `discount` will be `0.15` if no active profile is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'A config profile also works on the config source file `micorprofile-config.properties`.
    Consider the following `properties` files provided by your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If the value of `mp.config.profile` is set to `dev`, the config file `META-INF\microrpofile-config-dev.properties`
    will be activated. Its content will be merged into `META-INF\microrpofile-config.properties`
    and override the property values for the same properties that exist in both files.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the value of one property refers to another property. We call this
    a config reference. We will cover this topic in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Config references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A property value might reference a value from another property, which is called
    a **Config Reference**, also known as a property expression. The syntax for a
    property expression is *${another.property}*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The value of `customer.name` will be `Bob-Johnson`. A property expression can
    be nested as well, in the format *${a${n}}*. In a nested expression, the inner
    expression will be resolved first.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, a property can be specified in multiple config sources.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you need to identify which config source supplies the value so that
    you can update the effective value if needed. In the next subsection, we will
    learn how to find out which config source is the winning config source.
  prefs: []
  type: TYPE_NORMAL
- en: Where is my property value from?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you might be wondering which config source supplies the value for
    a particular property, since the same property might exist in multiple config
    sources. If you need to update the property value, you need to update the value
    from the winning config source. MicroProfile Config provides an API, `ConfigValue`,
    that enables you to find the winning config source. There are a couple of ways
    to obtain an object of `ConfigValue` for a specified property. You can use the
    following programmatic lookup to look up the config value for the property `host`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use CDI to obtain the config value for the `host` property`,`
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use the following method to retrieve some information about the
    winning config source and its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Commonly, some properties are related, and they are often looked up together.
    It would be very useful if these properties were aggregated and mapped to a particular
    Java type.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate config properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When looking up several related properties, it can be tedious to repeat the
    same configuration lookup statements. They might appear in different classes and
    some of the properties might be dynamic while others might be static, which might
    lead to an inconsistent state. In this situation, it is best practice to aggregate
    the related config properties in a CDI bean and annotate the CDI bean with the
    qualifier `@ConfigProperties` so that the property lookup is performed at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example to see how `@ConfigProperties` works. The following
    is a custom `ConfigSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To look up the properties related to a particular customer, we can use `@ConfigProperites,`
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When looking up the properties, you need to use the annotation `@ConfigProperites(prefix="customer")`.
    The prefix can be omitted if the prefix value is the same as the CDI bean prefix.
    If you specify a different prefix value, the specified prefix value will override
    the value defined on the CDI bean and the specified prefix will be used for looking
    up the properties.
  prefs: []
  type: TYPE_NORMAL
- en: Up till now, the config object has been provided by a Config specification implementation,
    which loads the available config sources and converters. For some advanced use
    cases where you need to control which config sources and converters are used,
    you might want to build the config object yourself. MicroProfile Config also offers
    flexibility for such a use case.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Config instance yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a Config instance, you will need to provide config sources and converters.
    MicroProfile Config provides a builder for the config object to be built using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a builder as shown in the following code snippet by
    creating an instance of `ConfigProviderResolver` and then call the `getBuilder()`
    method to create an instance of a builder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add config sources and converters to the builder and then call the
    `build()` method to build a `config` object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to register the `config` object so that we can always supply
    the same `config` object to the same `classloader` object, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, when we finish using the `config` object, we will need to release
    it, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If a config object is associated with multiple classloaders, when releasing
    the config object, all occurrences of it will have to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the most useful features of MicroProfile Config. To use the
    APIs from MicroProfile Config, you need to specify the Maven or Gradle dependencies.
    We will cover this in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making the MicroProfile Config API available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MicroProfile Config API JARs can be made available for either Maven and Gradle
    projects. If you create a Maven project, you can directly add the following to
    your `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You have learned how to configure your cloud-native applications. The next step
    is to make your applications resilient. In the next section, we will cover details
    on how you can make your applications resilient using MicroProfile Fault Tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: Making a cloud application resilient using MicroProfile Fault tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do you need to care about resilience? For mission-critical applications,
    a very brief downtime might cause you a huge penalty. Besides, your customer satisfaction
    will decrease if your applications are too fragile and aren't resilient. Therefore,
    you should consider building resilient applications, which means they will function
    under all kinds of situations with zero downtime. MicroProfile Fault Tolerance
    (source code at [https://github.com/eclipse/microprofile-fault-tolerance](https://github.com/eclipse/microprofile-fault-tolerance))
    introduces several resilience policies that can help you build a resilient application.
    These policies can be applied to CDI beans. It also provides a way to execute
    method invocations asynchronously via the annotation `@Asynchronous`.
  prefs: []
  type: TYPE_NORMAL
- en: '@Asynchronous'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The annotation `@Asynchronous` can be placed on a CDI bean class or the methods
    of a CDI bean class. If placed on a class, it means all of the methods declared
    on this class will be executed on a separate thread. Methods annotated with `@Asynchronous`
    must return a `Future` or a `CompletionStage` value, otherwise, `FaultToleranceDefinitionException`
    will be thrown. The following is a code snippet to show its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned example means the invocation of `serviceA()` will be executed
    on a different thread and then return with `CompletionStage`. If the method returns
    `Future`, the method call is always considered successful unless the method throws
    an exception. If the method returns `CompletionStage`, the method call is considered
    successful only if `CompletionStage` completes without any exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using the `@Asynchronous` annotation, it is best practice to return `CompletionStage`,
    which enables other Fault Tolerance policies to be invoked on an abnormal return.
  prefs: []
  type: TYPE_NORMAL
- en: But what do you do when you hit a temporary network glitch? The first instinct
    is to try it again, which is what this next annotation helps with.
  prefs: []
  type: TYPE_NORMAL
- en: '@Retry'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MicroProfile Fault Tolerance offers the retry capability via the annotation
    `@Retry`. When using this annotation, you can specify the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maxRetries`: This indicates the maximum number of retries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`: This indicates the delays between each retry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delayUnit`: This specifies the time unit for the delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxDuration`: This indicates the maximum duration for the overall retries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`durationUnit`: This specifies the duration unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jitter`: This indicates the random gap per delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jitterDelayUnit`: This specifies the jitter delay unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryOn`: This indicates the failures that cause the retries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abortOn`: This specifies the failures that skip the retries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can add the annotation `@Retry` on any class or business method ([https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method](https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method)).
    Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the aforementioned code snippet, the `@Retry` annotation means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An exception other than `IllegalArgumentException` will trigger the `Retry`
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum number of retries is `5` and the maximum duration is `4000` ms (milliseconds).
    The `Retry` operation will terminate when either condition is met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delay between the retries is `200` ms (jitter) and `600` ms (delay+jitter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes you may not want to keep on retrying; you might want to fail fast
    and return to the caller within a time constraint, for instance, if the caller
    only assigns a limited waiting time and can't afford to wait till a request returns.
    The `@Timeout annotation` was introduced to force the operation to return within
    the specified period.
  prefs: []
  type: TYPE_NORMAL
- en: '@Timeout'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@Timeout` annotation specifies the maximum response time. Without the
    specified time out, an indefinite wait might occur. With the `@Timeout` annotation,
    the affected operation needs to return within the specified time duration otherwise,
    a `TimeoutException` will be thrown. This annotation can be used on a class or
    any business method. Let''s take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code snippet, the `getServiceName()` operation will either
    return within `700` ms or throw a `TimeoutException` if the operation takes more
    than `700` ms to compute.
  prefs: []
  type: TYPE_NORMAL
- en: If a service is not working, you might not want to wait for the specified timeout
    and then get a `TimeoutException` repeatedly. It would be good to fail fast after
    a certain amount of failure time. Failing fast provides time for the backend to
    recover and the request can get feedback immediately. This is what `@CircuitBreaker`
    does.
  prefs: []
  type: TYPE_NORMAL
- en: '@CircuitBreaker'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Circuit Breaker** pattern helps an invocation fail fast and provides
    time for the backend to recover by preventing requests from reaching the backend.
    How does the Circuit Breaker pattern work? It is very simple. The circuit in the
    Circuit Breaker pattern is like an electrical circuit. If the circuit is open,
    there will be no electricity. A closed circuit means normal service. A circuit
    breaker has three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`failureRatio` within a number of consecutive requests or rolling window, called
    `requestVolumeThredshold`, the circuit breaker will trip. The circuit breaker
    will transition its state from closed to open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CircuitBreakerOpenException`. After a specified delay period, the circuit
    breaker will transition to the half-open state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`successThreshold`, the circuit breaker will transition to the **Closed** state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The circuit breaker has the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`requestVolumeThreshold` specifies the size of the rolling window where the
    circuit breaker will be assessed. If the value of `requestVolumeThreshold` is
    10, it means the circuit breaker will only be checked after 10 requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failureRatio` controls the failure rate within the rolling window. If the
    failure rate is equal to or above the `failureRatio` parameter, the circuit breaker
    will trip open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`successThreshold` specifies the criteria when the circuit breaker transitions
    from half-open to closed. If the value of `successThreshold` is `2`, it means
    after 2 successful requests, the circuit breaker will transition from half-open
    to closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay` and `delayUnit` indicate how long the circuit breaker stays open. The
    circuit breaker will not stay open forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failOn` specifies the exceptions that are considered to be failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipOn` states the exceptions that are excluded from contributing towards
    the circuit breaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Circuit Breaker pattern can be specified via the `@CircuitBreaker annotation`.
    The `@CircuitBreaker` annotation can be placed on a class or a business method
    to avoid repeated failures. You can configure the parameters on the annotation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code snippet, it means the circuit breaker will trip to
    open if there are 5 or more (10*0.5) failures among `10` (`requestVolumeThreshold`)
    consecutive requests. After 2 seconds, specified by the parameters `delay` and
    `delayUnit`, the circuit will transition to half-open. After 3 (`successThreshold`)
    consecutive successes, the circuit breaker will transition to close.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding whether an invocation should be treated as a failure or not, the
    criteria is that the exception from the invocation must be assignable to `ExceptionA`
    or `ExceptionB` but not assignable to `ExceptionC`. If an exception is assignable
    to `ExceptionC`, this execution will be treated not as a failure but as a success
    when counting towards a circuit breaker.
  prefs: []
  type: TYPE_NORMAL
- en: Success in Circuit Breaker
  prefs: []
  type: TYPE_NORMAL
- en: The success marked by the annotation `@CircuitBreaker` does not mean the operation
    returns normally. It only means that the return is treated as a success by Circuit
    Breaker. For instance, if a returned exception is assignable to any of the `skipOn`
    exceptions, the exception does not count as a failure but counts as a success
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of `@CircuitBreaker` annotation is per class per method, which means
    all instances for a particular class share the same circuit breaker for the same
    method. When applying `@CircuitBreaker` annotation on a CDI bean, it is irrelevant
    what CDI scope the bean has. All invocations for a particular method share the
    same circuit breaker.
  prefs: []
  type: TYPE_NORMAL
- en: In a mission-critical service, it is important to ensure that the service has
    fault isolation capabilities, preventing faults in one part of the system cascading
    to the entire system. This is known as **the Bulkhead pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: The Bulkhead pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Bulkhead pattern is to prevent one failure from cascading, which then brings
    down the whole application. The Bulkhead pattern is achieved by limiting the number
    of concurrent requests accessing a resource. There are two different types of
    bulkhead: **Semaphore** isolation and **Thread Pool** isolation.'
  prefs: []
  type: TYPE_NORMAL
- en: Semaphore isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semaphore isolation limits the number of concurrent requests to a specified
    number. You can directly use `@Bulkhead(n)` to limit the maximum requests where
    `n` is the number of concurrent requests. The extra request `n+1` will fail with
    `BulkheadException`.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes you might want to have a waiting queue for the extra requests
    to queue. For this requirement, you will need to use Thread Pool isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Thread Pool isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thread Pool isolation also limits a certain number of concurrent requests. It
    dispatches a new thread for method execution. In addition, it also has a waiting
    queue to store the extra requests. Only when the waiting queue is full, `BulkheadException`
    will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define Thread Pool isolation, you need to use `@Bulkhead` together with
    `@Asynchronous` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned code snippet means the size of the bulkhead is `5`, which
    allows 5 concurrent requests accessing the method `serviceA()`. The extra requests
    will be queued in the waiting queue. When the waiting queue is full, the extra
    requests will cause `BulkheadException` to be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `@CircuitBreaker` annotation, the scope of `@Bulkhead` annotation
    is per class per method, which means all instances for a particular class share
    the same bulkhead for the same method. When applying a `@Bulkhead` annotation
    on a CDI bean, it is irrelevant what CDI scope the bean has. All invocations for
    a particular method share the same bulkhead.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from Retry, the Fault Tolerance policies we have covered so far are about
    failing gracefully. However, sometimes, you want to return a reasonable response
    to your caller. In these circumstances, you should provide an alternative answer.
    This is what the Fallback policy is for.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@Fallback` annotation. The `@Fallback` annotation has the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: This specifies a class that implements the `FallbackHandler` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fallbackMethod`: This method specifies the fallback method name. The fallback
    method must be defined in the same class as the method applying the `@Fallback`
    annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applyOn`: This defines the criteria when the Fallback policy should be applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipOn`: This defines the criteria when the Fallback policy should be skipped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `value` and `fallbackMethod` parameters are mutually exclusive. If you specify
    both on the `@Fallback`, annotation `FaultToleranceDefinitionException` will be
    thrown. To specify the backup operation, you need to either define the `fallbackMethod`
    or `value` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `fallbackMethod` signature and return type must match the method that defines
    the Fallback policy. The `value` parameter should be used if you would like to
    define a handler to handle multiple Fallback policies.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `skipOn` or `applyOn` to specify what exception should trigger the
    fallback operation. As the name says, all exceptions and the subclasses listed
    under `skipOn` will bypass fallback while the exception and their subclasses listed
    by `applyOn` should trigger the fallback operation. When `skipOn` and `applyOn`
    are used together, `skipOn` takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code snippet for an example of the Fallback policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code snippet, if the method `callService()` throws an
    exception and if this exception is assignable to `ExceptionAsub`, the exception
    will be rethrown and the fallback method `myFallback` will not be executed. However,
    if the thrown exception is not assignable to `ExceptionAsub` and assignable to
    `ExceptionA` or `ExceptionB`, the fallback method `myFallback` will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered all of the Fallback policies so far. You might have realized
    that all of the policies are annotations. Actually, these annotations are CDI
    interceptor bindings, which means they only work on business method invocations
    on CDI beans, as explained at  [https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method](https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method).
  prefs: []
  type: TYPE_NORMAL
- en: CDI interceptors have a priority. In Fault Tolerance, some implementations provide
    one interceptor for all the interceptor bindings while others might provide multiple
    interceptors. The Fault Tolerance specification declared the base priority to
    be `Priority.PLATFORM_AFTER (4000)+10`, which is `4010`. If multiple interceptors
    are provided by an implementation, the priority range should be between base priority
    and base priority + 40 so that other application interceptors can define their
    priorities accordingly based on whether they want to be invoked before or after
    Fault Tolerance interceptors. You can update the base priority via the property
    `mp.fault.tolerance.interceptor.priority`.
  prefs: []
  type: TYPE_NORMAL
- en: A method annotated with Fault Tolerance annotations may also specify any other
    **Interceptor Bindings**. The invocation order on the interceptors will be determined
    by the priority of the interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered all Fault Tolerance annotations. You might be wondering
    whether you could use these annotations together. Yes, of course. We will discuss
    this in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Fault Tolerance annotations together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is fine to use annotations together to achieve multiple Fault Tolerance
    capabilities such as setting up for `Retry` and `Timeout` together. Let''s take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned code snippet means that the operation `doSomething()` applies
    all of the Fault Tolerance policies. If this method throws an exception, the following
    Fault Tolerance policies will be applied in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the `CircuitBreaker` is open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not open, the timer will start recording the time duration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to get a slot in `Bulkhead`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are 10 running tasks already, it will queue up in the waiting queue,
    which has 10 slots. However, if there is no free slot in the waiting queue, a
    `BulkheadException` exception will be thrown. If there is a slot in the waiting
    queue, it will wait to be scheduled. During the waiting, if the timeout duration
    exceeds `200` milliseconds, `TimeoutException` will be thrown. The thrown exception
    will be recorded in the `CircuitBreaker` record and then trigger `Retry`. Go back
    to *step 1* for `Retry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After `Retry` has been exhausted, the Fallback policy will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the parameters on each annotation have default values.
    You can also specify values on the annotations. Are you wondering whether the
    values are configurable? Let's discuss this in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Fault Tolerance configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The good news is that all of the parameters on the annotations are configurable.
    The values can be overridden either globally or individually. This is achieved
    via **MicroProfile Config**. All of the parameters are properties. Their values
    can be specified in any configured config source.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding parameter values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To override individual annotation parameters, you can use method-level configuration,
    class-level configuration, or global configuration as explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method-level configuration**: It is specified using the format *<fully.qualified.class.name>/<method.name>/<annotation.name>/<parameter.name>*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class-level configuration**: It is specified using the format *<fully.qualified.class.name>/<annotation.name>/<parameter.name>*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global configuration**: It is specified using the format *<annotation.name>/<parameter.name>*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example to explain further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet sets the `Timeout` to be `500` milliseconds with at most
    `6` retries. To set `Timeout` to `300` milliseconds and at most `10` retries,
    you can specify the following method-level config properties in any config sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you would like to update all of the timeout and the maximum
    of retries for this class, you can just omit the method names, which means the
    configurations are appliable to all of the methods with the corresponding annotations
    specified. Then, specify the following class-level configuration in a configured
    config source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you might want to specify the same timeout value for all of the
    classes under one application. It is simple. Just omit the fully qualified class
    name. Therefore, you can use the following global configuration to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, your cloud infrastructure, such as **Istio**, which we will discuss
    in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146), *MicroProfile
    Ecosystem with Open Liberty, Docker, and Kubernetes*, provides some Fault Tolerance
    capabilities. However, cloud infrastructure will not be able to provide fallback
    capabilities as the infrastructure needs business knowledge. If you prefer to
    use the Fault Tolerance capabilities provided by Istio, you might want to turn
    off some MicroProfile Fault Tolerance capabilities. If you don't, you will get
    both Fault Tolerance functionalities and they will interfere with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Fault Tolerance policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to use the Fault Tolerance policies provided by Istio, you can
    specify the following property to turn off all of Fault Tolerance policies except
    `Fallback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable a particular policy on a method, specify the following method-level
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, in order to turn off `Timeout` on the method `invokeService()`,
    specify the following method-level configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, in order to turn off `Timeout` on the class, specify the following
    class-level configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the `Timeout` capability for your cloud-native application, specify
    the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If multiple configurations are specified, the configuration specified on the
    method level has a higher priority, followed by class-level configuration and
    then global configuration.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have learned how to apply Fault Tolerance policies to some operations
    and configure the policies. However, these policies are there to be triggered
    under some criteria. It is very possible that none of the policies are utilized.
    You might be keen to find out whether any Fault Tolerance policies are activated.
    In response to this need, we have Fault Tolerance metrics. Let's take a look at
    them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Fault Tolerance metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MicroProfile Fault Tolerance, when used together with MicroProfile Metrics,
    is able to emit some useful metrics for the Retry, Timeout, CircuitBreaker, Bulkhead,
    and Fallback policies. In the following tables, I have listed all of the relevant
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the general metrics whenever Fault Tolerance is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.1 – Method invocation metrics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.1_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1 – Method invocation metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'If `@Retry` is used, the metrics for retry will be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.2 – Retry metrics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.2_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.2 – Retry metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'If `@Timeout` is used, the following metrics will be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.3 – Timeout metrics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.3_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.3 – Timeout metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'If `@CircuitBreaker` is used, you will see the following metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.4 – CircuitBreaker metrics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.4_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.4 – CircuitBreaker metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'If `@Bulkhead` is used, you will be able to see the following metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.5 – Bulkhead metrics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.5_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.5 – Bulkhead metrics
  prefs: []
  type: TYPE_NORMAL
- en: You have learned about all of the functionalities of Fault Tolerance. You might
    be wondering how to start using the APIs provided by Fault Tolerance. We will
    discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making the MicroProfile Fault Tolerance API available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MicroProfile Fault Tolerance API JARs can be made available for either Maven
    and Gradle projects. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You have now learned how to make your cloud-native applications resilient. The
    next step is to document your applications. You will learn how to document your
    applications using MicroProfile OpenAPI in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting cloud native applications using MicroProfile OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 2*](B17377_02_Final_SB_epub.xhtml#_idTextAnchor036),
    *How Does MicroProfile Fit into Cloud-Native Applications?*, you might have difficulties
    remembering what functionalities a particular cloud-native application has when
    you have tens or hundreds of cloud-native applications to manage. You will need
    to provide documentation for them. With documented endpoints, some clients can
    discover and invoke them.
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroProfile OpenAPI** (source code at [https://github.com/eclipse/microprofile-open-api/](https://github.com/eclipse/microprofile-open-api/))
    provides a set of annotations and programming models that enable you to document
    cloud-native applications and then produce documents conforming to the **OpenAPI**
    v3 specification ([https://github.com/OAI/OpenAPI-Specification](https://github.com/OAI/OpenAPI-Specification)).
    The OpenAPI v3 specification defines a set of interfaces for documenting and exposing
    RESTful APIs. MicroProfile OpenAPI adopts the OpenAPI Specification and further
    simplifies the OpenAPI model so that it is much easier for Java developers to
    document their cloud-native applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile OpenAPI offers three ways to document cloud-native applications:'
  prefs: []
  type: TYPE_NORMAL
- en: By applying **MicroProfile OpenAPI** annotations on JAX-RS operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the programming model from **MicroProfile OpenAPI** to provide an **OpenAPI**
    model tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pre-generated **OpenAPI** documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will cover these three mechanisms in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Applying MicroProfile OpenAPI annotations on JAX-RS operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simple way to produce documentation for your JAX-RS operations is to add
    MicroProfile OpenAPI annotations. A few useful and widely used annotations are
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.6 – MicroProfile OpenAPI annotations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.6 – MicroProfile OpenAPI annotations
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of using OpenAPI annotations to document an operation
    in the IBM StockTrader app **Trade-History**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned code snippet documents two responses with the annotation
    `@APIResponse`: `404` and `200`. The annotation `@Operation` documents the purpose
    of the operation. The OpenAPI document generated with the preceding annotations
    is detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the aforementioned document, the endpoint path and the `get` operation description
    were explained with the information from the annotation `@Operation`. Further
    on, the responses for `200` and `404` were described from the information provided
    by the `@APIResponse` annotation. As for the response for the return code `200`,
    the schema `Quote` was referenced by the annotation `@Schema`, so `$ref: ''#/components/schemas/Quote`
    was displayed as the schema reference. The reference points to the section `components/
    schemas/Quote`, which displays the details of the schema `Quote`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without using any MicroProfile OpenAPI annotations, MicroProfile OpenAPI still
    generates an OpenAPI document for all of the JAX-RS endpoints with minimum information.
    The following is the example for the endpoint `latestBuy` if no OpenAPI annotations
    are applied. It only lists the minimum information on the successful return code
    `200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Apart from using MicroProfile OpenAPI annotations, you can use a programming
    model to generate documents. We will discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a programming model to generate documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, it might not be possible to put MicroProfile OpenAPI annotations
    on JAX-RS operations. In this case, you can provide your own implementation of
    **OASModelReader** from MicroProfile OpenAPI. The OASModelReader API provides
    a way for an OpenAPI document to be built from scratch. Follow the steps mentioned
    to build an OpenAPI model tree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `org.eclipse.microprofile.openapi.OASModelReader` interface.
    You can see an example here: [https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples](https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the implementation using the `mp.openapi.model.reader` configuration
    key and store the configuration in a config source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If providing a complete OpenAPI model tree, set the configuration `mp.openap.scan.disabled=true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The link [https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples](https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples)
    provides an example of implementing `OASModelReader`. In *step 2* and *step 3*,
    you can specify the properties under `META-INF/microprofile-config.properties`
    or as system properties.
  prefs: []
  type: TYPE_NORMAL
- en: Using pre-generated OpenAPI documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you will write OpenAPI documents first by using an editor such as
    the Swagger Editor ([https://editor.swagger.io/](https://editor.swagger.io/)).
    Documents must be named `openapi` with a `yml`, `yaml`, or `json` file extension
    and be placed under the `MEAT-INF` directory. If the document is complete, you
    can set the property `mp.openap.scan.disabled=true`. Otherwise, the scan operation
    will be performed to discover any MicroProfile OpenAPI annotations.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have briefly introduced the three ways to create OpenAPI documents.
    The documents can be viewed using the URL [http://host_name/port_number/openapi](http://host_name/port_number/openapi).
    Open Liberty, which will be discussed in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146),
    *MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes*, has the Swagger
    UI integrated, so you can visit [http://host_name/port_number/openapi/ui](http://host_name/port_number/openapi/ui)
    for a GUI view, where you can supply parameters and then directly invoke the individual
    endpoints. More information on this UI will be covered in [*Chapter 9*](B17377_09_Final_SB_epub.xhtml#_idTextAnchor173),
    *Deployment and Day 2 Operations*.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native application developers may wish to remove or update certain elements
    of the OpenAPI document. This is done via a filter, which is invoked once the
    OpenAPI document is created. We will discuss filters in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying filters to the OpenAPI document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to add some information to the OpenAPI document, you can create
    a filter. The filter needs to implement the OASFilter interface, which provides
    a way to update an OpenAPI document. Let''s look at the following filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code snippet, the `filterOpenAPI()` method filters the
    OpenAPI element. This method is called only once as the last method for a particular
    filter. It provides the `info` and the `servers` elements of the OpenAPI document.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created a filter class, the next step is to specify the configuration
    `mp.openapi.filter=com.acme.MyOASFilter` in a config source, such as `microprofile-config.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A MicroProfile OpenAPI implementation generates the documents in the following
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation fetches configuration values with the prefix of `mp.openapi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then invokes `OASModelReader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It fetches static OpenAPI files with the name of `openapi.yml`, `openapi.yaml`,
    or `openapi.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It processes MicroProfile OpenAPI annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it filters the OpenAPI documentation via `OASFilter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned in *step 1*, several configurations with the prefix of `mp.openapi`
    can be defined by MicroProfile OpenAPI. We will go through the configurations
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenAPI configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MicroProfile OpenAPI provides some flexibility for application developers to
    configure the process when generating OpenAPI documents. The configurations are
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.7 – MicroProfile OpenAPI configurations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.7 – MicroProfile OpenAPI configurations
  prefs: []
  type: TYPE_NORMAL
- en: Now we have covered how **MicroProfile OpenAPI** works. The implementation of
    MicroProfile OpenAPI will generate an OpenAPI document based on MicroProfile OpenAPI
    policies. Where can you view the fully processed OpenAPI document? In the next
    section, we will discuss where the OpenAPI document can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing an OpenAPI document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fully processed OpenAPI document must be available at the root URL `/openapi`,
    as an HTTP `Get` operation, such as `http://localhost:9080/openapi`. The default
    format of the document is YAML. Support for the JSON format is required if the
    response contains a `Content-Type` header with a value of `application/json`.
    Open Liberty supports the query parameter format, which allows you to specify
    whether you want YAML or JSON format. For instance, the endpoint `http://localhost:9080/openapi?format=JSON`
    displays the OpenAPI document in JSON format, while the endpoint [http://localhost:9080/openapi?format=YAML](http://localhost:9080/openapi?format=YAML)
    displays an OpenAPI document in YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: Open Liberty provides a UI for OpenAPI documents, where you can invoke the endpoints
    included. The UI is available at the root URL `/openapi/ui`.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how MicroProfile OpenAPI works and where to find the OpenAPI
    documents. Now, you are ready to use MicroProfile OpenAPI. In the next section,
    we will discuss how to make the APIs available to your Maven and Gradle projects.
  prefs: []
  type: TYPE_NORMAL
- en: Making MicroProfile OpenAPI APIs available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use MicroProfile OpenAPI APIs, you need to make these APIs available to
    your application. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With this, you have learned how to document your cloud-native application. The
    next step is to secure your applications. We will learn how to secure your applications
    with the help of MicroProfile JWT ([https://github.com/eclipse/microprofile-jwt-auth](https://github.com/eclipse/microprofile-jwt-auth)).
  prefs: []
  type: TYPE_NORMAL
- en: Securing cloud-native applications using MicroProfile JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile JWT utilizes **JSON Web Token** (**JWT**) with some additional
    claims for role-based access control of an endpoint to help with securing cloud-native
    applications. Securing cloud-native applications is often the must-have feature.
    It is often the case that cloud-native applications supply sensitive information,
    which should only be accessible to a particular group of users. Without securing
    cloud-native applications, everyone would be able to access the information. **Jakarta
    Security** (source code at [https://github.com/eclipse-ee4j/security-api](https://github.com/eclipse-ee4j/security-api)),
    a specification ([https://jakarta.ee/specifications/security/](https://jakarta.ee/specifications/security/))
    under Jakarta EE, can be used to secure cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the method `checkAccount` is secured via the Jakarta
    Security API `@RolesAllowed`. This method can only be invoked by clients with
    the access group `StockViewer` or `StockTrader`. All other users are denied as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `web.xml` configuration to directly secure the end
    point. In the following code snippet, it defines two roles, `StockViewer` and
    `StockTrader`, and they can access all `GET` operations, where `StockViewer` can
    only access read-only operations and `StockTrader` can access all operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After the endpoint is secured, we then need to work out how to get the client
    to invoke the secured backend. To answer this question, we'll first discuss the
    unique aspect of application security for cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native application security is different from traditional applications
    as cloud-native applications are often stateless and the server side might not
    be able to persist any states on the clients. Besides, there might be different
    instances of the backend and each subsequent client request might not hit the
    same backend instance. As you can see, storing client data on the backend is problematic.
    Therefore, the recommended approach is to pass on the security-related info via
    each request.
  prefs: []
  type: TYPE_NORMAL
- en: The backend service will then create a security context for each request and
    perform both authentication and authorization checks. This means that the security-related
    info needs to include both authentication and authorization details. In the next
    section, we will look at the technologies used to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: What technologies do we use to secure cloud-native applications?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The technologies used for cloud-native application security are based on **OAuth2**,
    **OpenID Connect**, and **JSON Web Token** (**JWT**) standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth2**: An authorization framework that controls authorization to a protected
    resource such as a cloud-native application. OAuth2 is about user authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenID Connect (OIDC)**: An authentication framework that builds on top of
    the OAuth 2.0 protocol. It allows third-party applications such as Google or Facebook
    to verify the identification of an end user and to obtain some user information.
    OIDC is about user authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JWT**: A compact, URL-safe way to transfer claims between two parties. It
    contains a set of claims, represented as a JSON object, which is base64url-encoded,
    digitally signed (**JWS**), and optionally encrypted (**JWE**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JWT can be used to propagate ID for authentication and user entitlement for
    authorization. It is used by both OAuth2 and OpenID Connect. The most important
    feature of JWT is that the data itself is self-described and verifiable. It provides
    a tamper-resistant way to pass information around. At JWT creation time, the **Issuer**
    signs the JWT with its **Private Key**. Upon receiving the JWT, **Receivers**
    can then use the matching **Public Key** to verify the JWT to ensure that the
    JWT has not been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: JWT is a general abstract term. It can be either **signed JWT** or **encrypted
    JWT**. A signed JWT is known as a **JWS** (**JSON Web Signature**) while an encrypted
    JWT is known as **JWE** (**JSON Web Encryption**). A **JSON Web Key** (**JWK**)
    is a JSON object that represents a cryptographic key and is used to decrypt a
    JWE or JWS to validate the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a security token – JWT – has been generated, **Token-Based Authentication**
    is normally used to allow systems to make authentication and authorization decisions
    based on a security token. For cloud-native applications, a token-based authentication
    mechanism offers a lightweight way for security controls and security tokens to
    propagate user and entitlement info across cloud-native applications. Since the
    JWT token is used for authentication and authorization purposes, two new claims
    are introduced to the MicroProfile JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '**upn**: This claim specifies the user principal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**groups**: This claim lists the group names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There can be many claims included in a JWT. The following claims are required
    for MicroProfile JWT, while the claim for groups are optional from MicroProfile
    JWT Propagation version 1.2 onwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iss`: This claim specifies the token issuer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`: This claim specifies the time when the token was issued.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp`: This claim indicates the expiration time of the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upn` (or `preferred_username` or `sub`): This claim specifies the principal
    name. If `upn` is not present, fall back to `preferred_username`. If `preferred_username`
    is not present, fall back to `sub`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the aforementioned mandatory claims, there are some optional claims
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aud`: The endpoint, which can be assessed by JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jti`: The unique identifier for this JWT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`: The unique identifier of the principal of this JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preferred_user_name`: The preferred username of this JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are two different types of JWT: JWS and JWE. JWS
    is very popular. We will discuss it in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: JWS in more detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JWS is a prominent format of JWT. A JWS has three parts, which are separated
    by a dot. The following is an example of JWS, where you can find the first dot
    on the first line and the second dot on the seventh line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The three dot-separated parts are the header, payload, and signature. You can
    paste the preceding encoded form in https://jwt.io/ to retrieve the three parts
    in human-readable text. We are going to review the three parts in more detail
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alg` (RS256 or ES256), `enc` (a cryptographic algorithm to encrypt the claims),
    `typ` (JWT), and `kid` (the key that was used to secure the JWT). Here is an example
    of the header. It means `JWT` as the `typ` and `RS256` as the `alg`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Payload**: This contains a number of claims. Here is an example of the payload:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Signature**: The signature is used to verify that the messages weren''t changed
    during the transmission. It is created using an encoded header, an encoded payload,
    a secret, the algorithm specified in the header, and then signed. The following
    is an example of verifying a signature, which computes the signature based on
    the header and payloader and then compares it with the passed-in signature. If
    they match, it means the token has not been tampered with during transmission:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next section, we are going to discuss how MicroProfile JWT works.
  prefs: []
  type: TYPE_NORMAL
- en: How does MicroProfile JWT work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned what MicroProfile JWT looks like together with the basic concept
    of MicroProfile JWT. To use JWT, we need to first create a token.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing a MicroProfile JWT token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A MicroProfile JWT token can be issued by runtimes that support the creation
    of MicroProfile JWT or trusted OpenID Connect providers. MicroProfile JWT can
    be self-issued by a trusted server, where a set of token-issuing APIs are provided.
    Open Liberty, Eclipse Vert.x, and other runtimes have such APIs available. The
    following is an example of using the Open Liberty API to create a JWT token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This JWT token contains the claims `sub (Claims.SUBJECT)`, `upn`, and `groups`.
    In production, it is common that MicroProfile JWTs are issued by some trusted
    OpenID Connect providers such as Auth0, Keycloak, Azure, Okta, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The only supported JWT algorithms are RS256 and ES256\. The token will be rejected
    if other algorithms are used.
  prefs: []
  type: TYPE_NORMAL
- en: JWT generation
  prefs: []
  type: TYPE_NORMAL
- en: Since MicroProfile JWT has two more claims over JWT, these claims need to be
    manually added as custom claims in the OpenID Connect providers such as Keycloak,
    Okta, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring MicroProfile JWTs from a client to a server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MicroProfile JWTs are transferred over a HTTP request. They can be passed either
    via an HTTP Authorization header or an HTTP cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mp.jwt.token.header` can be used to store the JWT in the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`mp.jwt.token.cookie` can be used to store the JWT in the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Validating MicroProfile JWTs by the server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MicroProfile JWTs must be signed (JWSes). To decode JWSes, the corresponding
    public key must be specified. The location to the public key can be provided via
    the property `mp.jwt.verify.publickey.location`. Alternatively, the public key
    itself can be provided via the property `mp.jwt.verify.publickey`. The two properties
    are not allowed to be specified together. Otherwise, a `DeploymentException` will
    be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The signed JWTs can be further encrypted (JWE). When the server receives MicroProfile
    JWTs, it will validate the JWTs. If the JWT is a JWE, it will need to use the
    corresponding private key to decrypt the JWE. The location of the private key
    can be specified in the property `mp.jwt.decrypt.key.location`. If this property
    is present, the received JWTs must be a JWE. Otherwise, the JWTs will be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: After the signature of a JWT has been verified or the token has been decrypted,
    some further validations can be performed, such as `iss` and `aud` validation.
    The `mp.jwt.verify.issuer` property specifies the expected `iss` value while the
    property `mp.jwt.verify.audiences` specifies the `aud` value.
  prefs: []
  type: TYPE_NORMAL
- en: After the JWTs have been verified, the object `JsonWebToken` is made available
    to the cloud-native application as a backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some MicroProfile JWT implementation might also provide additional validation
    mechanisms. In Open Liberty, you can specify the following line in your `server.xml`
    to validate against the `issuer` and `audiences` if the corresponding properties
    are absent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This mechanism will be used by the **Stock Trader** application, which will
    be covered in more detail in [*Chapter 8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159),
    *Building and Testing Your Cloud-Native Application*.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, when a JWT is received and decoded, its `aud` and
    `iss`  claim will be compared with audiences defined in `${JWT_AUDIENCE}` and
    `${JWT_ISSUER}` correspondingly. If they match, the JWT will be accepted and then
    perform further authentication and authorization checks.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing JsonWebToken
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cloud-native applications can access `JsonWebToken` via the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access `JsonWebToken` via `SecurityContext`. The following code snippet demonstrates
    how to retrieve a `JsonWebToken` object from the injected `SecurityContext`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`JsonWebToken` contains all claims. `JsonWebToken` is a subclass of `Principal`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can use CDI injection to inject the whole `JsonWebToken`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use CDI injection to inject a particular claim. The following example
    demonstrates assigning the claim `raw_token` string to the `rawToken variable`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line is to inject the claim `iat` with the type of `Long` to the `dupIssuedAt
    variable`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following line injects the claim `sub` with the type of `ClaimValue` to
    the `optSubject variable`. This lookup is dynamic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ClaimValue is a representation of a claim in a `JsonWebToken`, which is a wrapper
    class for the specified claim.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since the JWT is attached to a particular request, it is expected that the
    token is bound to a lifecycle of `RequestScoped`. When injecting `JsonWebToken`
    or `Claims` into a scope with a lifecycle greater than `RequestScoped`, such as
    `ApplicationScoped`,or `SessionScoped`, you should use the type of `Provider`,
    `Instance`, or `ClaimValue` as these are wrappers and will always retrieve the
    JWTs dynamically for the specified request. Generally speaking, you can use the
    following code snippet to retrieve a specified claim, `a_claim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`<Claim_Type>` can be `String`, `Long`, `long`, `Boolean`, `Set<String>`, `JsonValue.TRUE`,
    `JsonValue.FALSE`, `JsonString`, J`sonNumber`, `JsonArray`, or `JsonObject`. It
    can be optional wrapper of the listed types or `ClaimValue` of the types, including
    `Optional`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile JWT can be propagated to downstream services if the invocation
    is via the MicroProfile Rest Client (MicroProfile Rest Client has been discussed
    in great detail in [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*.). The propagation will be automatically
    handled by setting the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If the JWT is specified as an authorization header, the value will be `Authentication`.
    If the JWT is specified as a cookie, the value will be `Cookie`.
  prefs: []
  type: TYPE_NORMAL
- en: Where to find the public key and private key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to security, you will immediately think about keys. There is
    no exception here. In MicroProfile JWT, you will need a public key to decode a
    JWS and a private key to decrypt JWE. If you received JWE, you will need to use
    your private key to decrypt it first. After the decryption, you will get a JWS.
    Then you will need to use your public key to decode the JWS to verify the signature.
    MicroProfile JWT provides the following configuration for you to retrieve the
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.8 – MicroProfile JWT configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_5.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.8 – MicroProfile JWT configuration
  prefs: []
  type: TYPE_NORMAL
- en: If the `mp.jwt.decrypt.key.location` property is set and either `mp.jwt.verify.publickey.location`
    or `mp.jwt.verify.publickey` are set, only encrypted JWTs can be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: The properties mentioned in the preceding table are regular MicroProfile configurations.
    They can be specified in any of the config sources, such as *META-INF/microprofile-config.properties*,
    *system properties*, *environment variables*, or other custom config sources.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how MicroProfile JWT works. In the next section, we will discuss
    how to make the APIs available to your Maven or Gradle projects.
  prefs: []
  type: TYPE_NORMAL
- en: How to make MicroProfile JWT available to applications?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use MicroProfile JWT APIs, you need to make these APIs available to your
    application. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about MicroProfile Config, which enables you
    to externalize your configuration to achieve a flexible and efficient cloud-native
    architecture, which is also highly recommended by the twelve-factor app.
  prefs: []
  type: TYPE_NORMAL
- en: We then went forward to explore how to create a resilient cloud-native application
    using MicroProfile Fault Tolerance so that application developers can concentrate
    on their business logic, where MicroProfile Fault Tolerance handles possible failures
    and then performs retries or limits resource consumption, and so on, via simple
    Fault Tolerance annotations.
  prefs: []
  type: TYPE_NORMAL
- en: After we covered Fault Tolerance, we then dived into MicroProfile OpenAPI to
    learn how to document your cloud-native applications using MicroProfile OpenAPI.
    We discussed a few ways to generate OpenAPI documents. Some MicroProfile OpenAPI
    implementation, such as Open Liberty, also provides UI integration for you to
    access endpoints directly via the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the topic of securing cloud-native applications using
    MicroProfile JWT. We discussed, in general, the unique requirements for securing
    cloud-native applications and then explained how to use MicroProfile JWT to facilitate
    securing cloud-native applications in a portable and interoperable way.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, you have learned about quite a few technologies you need to develop
    your cloud-native applications. The next task is to consider how to improve your
    day 2 operation experience by building a smart and intelligent cloud-native application,
    which means the application can communicate automatically with cloud infrastructures
    when it is ready to receive requests and so on. It will also be beneficial if
    the application can provide some metrics so that day 2 operations can take some
    precautions before it is too late. We all know faults cannot be eliminated completely.
    If something goes wrong, day 2 operations will offer an easy and simple diagnosis
    to identify the failure straightaway. MicroProfile Health, MicroProfile Metrics,
    and MicroProfile OpenTracing are the technologies to fulfill these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss why and how you should use MicroProfile
    Health, MicroProfile Metrics, and MicroProfile OpenTracing to help with day 2
    operations.
  prefs: []
  type: TYPE_NORMAL
