- en: An Application to View Countries and their GDP using JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As time has passed, changing business functions have required delivery teams
    to produce high-quality software products at a rapid pace. To meet this expectation,
    the IT industry has become focused on making the software development process
    streamlined and automated. As a result, many new platforms are emerging, with
    the aim of generating the code to prepare production-ready applications in no
    time.
  prefs: []
  type: TYPE_NORMAL
- en: We started our journey with a simple application developed in Spring Framework
    that showed the **gross domestic product** (**GDP**) information of various countries
    with the World Bank API, in [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml),
    *Creating an Application to List World Countries with their GDP*. The Spring Framework
    provides a comprehensive way to develop an enterprise-ready application with ease.
  prefs: []
  type: TYPE_NORMAL
- en: With the birth of Spring Boot framework, development with Spring Framework has
    become far quicker and smarter than ever before. In subsequent chapters, we moved
    on to Spring Boot and explored its capabilities, specifically for integration
    with other Spring and third-party libraries and modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore another framework, named JHipster, which is
    one step ahead in making Spring-based applications with just a few clicks, and
    makes Spring development joyful. We will utilize JHipster to develop the application
    from [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml), *Creating an Application
    to List World Countries with their GDP, *showing the GDP information of various
    countries and showcasing how the development process is streamlined and automated.
    We will cover the following interesting topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JHipster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling and creation of the entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the GDP application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to add customization in JHipster application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other features of JHipster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JHipster** is, in brief, a code generating tool, built on top of large collections
    of development, build, test, and deployment frameworks and platforms. It is a
    modern web application development platform, used to build all layers of a comprehensive
    Java-based web application, from the frontend to the database. JHipster supports
    various frameworks under the hood, giving the user options to choose from when
    starting application development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JHipster is a free and open source platform aimed at greatly simplifying the
    process of generating, developing, and deploying monolithic and microservices-based
    applications on Spring Framework and Angular or React technologies. Before building
    an application in JHipster, a user will be asked various questions, in order to
    generate a production-ready application based on the options chosen by the user.
    JHipster provides the application with support for the following tools and frameworks,
    out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build tool:** Maven, Gradle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development platform:** Spring Framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security framework:** Spring Security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templating:** Thymeleaf'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices:** Netflix OSS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RDBMS:** H2, MySQL, Oracle, PostgreSQL, MS SQL, MariaDB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data streaming:** Kafka'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DB tracker:** Liquibase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NoSQL:** MonboDB, Cassandra, Couchbase, Hazelcast'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache implementation:** Infinispan, Ehcache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search engine:** Elasticsearch and **Elasticsearch, Logstash, and Kibana** stack
    (**ELK**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring:** Prometheus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORM:** Hibernate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing framework:** Cucumber, Browsersync, Jest, Protractor test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load testing:** Gatling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI:** Bootstrap, HTML5, CSS3, SaaS, Redux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript framework: **Angular, Typescript, React, Webpack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment:** Docker, Kubernetes, Boxfuse, Rancher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud support:** Heroku, Cloud Foundry, AWS, OpenShift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD:** Jenkins, Travis CI, GitLab CI, CircleCI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code generated by JHipster is as per industry standards, best practices,
    and quality compliance. Along with autogenerating application code, JHipster also
    supports automated testing and the continuous integration and delivery of the
    application in a more streamlined way. This can bring great benefits to an organization,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application with various platforms and frameworks in a uniform and
    controlled way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the boilerplate code is generated automatically, so a developer can
    focus on the implementation of business requirements. This will increase developer
    productivity and greatly improve the overall project delivery timeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy integration of changes throughout the application, from the frontend to
    the database table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved code quality of the application, overall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different projects in the organization can share common artifacts with ease.
    Consequently, the overall productivity of the project teams will be improved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JHipster recommends that normal users install with `npm`. The `npm` is a package
    manager from `Node.js`, used to install various software. It is the world's largest
    software repository, where you will find thousands of pieces of open source software,
    in the form of packages. If `npm` is not installed, just go to the Downloads section
    of the Node site ([https://nodejs.org/en/download](https://nodejs.org/en/download))
    and install the latest 64-bit **Long Term Support** (**LTS**) version, because
    the non-LTS version is not supported by JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `npm` is installed, run the following command to install the JHipster
    package from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: JHipster uses another tool, named **Yeoman** ([http://yeoman.io/](http://yeoman.io/)),
    to generate the application code, which is installed along with the JHipster Node
    package. After creating an application, JHipster provides an option to build it
    with either Maven or Gradle. For this, JHipster will install the required wrappers
    for Maven and Gradle, so nothing is required explicitly, especially for building
    an app.
  prefs: []
  type: TYPE_NORMAL
- en: Local installation of JHipster can also be done with Yarn, another package manager
    for installing software. The process of installing JHipster with Yarn is almost
    identical to that of `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After installing JHipster, the next step is to create an application. Create
    a project directory with an appropriate name in your local machine, select this
    directory from Command Prompt, and execute the following command. The name of
    the project directory is given as `gdp`, but it can be any valid name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Soon after hitting this command, JHipster will start to ask a series of questions,
    and will decide what has to be generated based on the answers given by the user,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Which type of application would you like to create? **There are four possible
    options to choose from, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monolithic application:** This option is used to create a self-contained
    application. This is the recommended option to create a simple application, so
    we will choose this option.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice application:** If you want to design an application based on
    a microservices architecture, you can choose this option.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice gateway:** The microservice gateway is used to build a microservice-based
    application with the UI. By default, microservice applications do not have a UI.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JHipster UAA server:** JHipster supports creating applications with **User
    Authentication and Authorization** *(***UAA**).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is the base name of your application?** You need to give your application
    a name. By default, it takes the same name as the project directory. If you want,
    you can give it another name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is your default Java package name?** Next, you need to give a Java package
    name. You can give an appropriate name (it will be considered as a base package,
    and all other Java source files will be generated in their respective packages
    relative to this package).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want to use the JHipster Registry to configure, monitor, and scale
    your application?** This question concerns using the JHipster Registry in our
    application. The registry is extensively used in microservice-based applications,
    for registering various services. For a monolithic application, we can still use
    it because although it is a kind of registry, it concerns the health of the application,
    which helps us to monitor the application. It comes as a `Docker` image. For simplicity,
    we are not going to use it, so choose No and go ahead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which type of authentication would you like to use?** Next up is the authentication
    mechanism. It provides three options to choose from, as follows. We will select
    the third option (HTTP session authentication):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**JWT Authentication:** **JSON Web Token** (**JWT**), which is an open standard
    for transmitting information between two parties in form of JSON. Authentication
    is the most common use case of JWT.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OAuth2/OIDC Authentication:** JHipster provides complete support for OAuth2
    with Keycloak and **OpenID Connect** (**OIDC**), which is generated by default when
    we select this option. Keyclock is an open source identity brokering and access
    management solution. **Open ID Connect** (**OIDC**), which is a simple identity
    layer on top of the OAuth2 protocol.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**HTTP session authentication:** This authenticates users based on sessions. This
    is the most commonly used option.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which type of database would you like to use?** Next, it will ask the type
    of database, we would like to use in our application. JHipster supports various
    SQL databases. It also supports three NoSQL databases—MongoDB, Couchbase, and
    Cassandra, which has a Spring data backend. We will select SQL.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which production/development database would you like to use?** You will be
    asked separate questions to select specific databases for production and development.
    JHipster maintains various profiles for various environments (such as development,
    production, and so on). It will configure the databases based on your selected
    options. In our case, we will select MySQL for both production and development.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want to use the Spring cache abstraction?** Moving further, it will
    ask about the type of caching mechanism, such as Ehcache, Hazelcase, Memcached,
    or no cache at all; Spring cache abstraction will be used to plug any of them.
    We can select any of them, based on our particular business needs and the underlying
    hardware architecture (single node, multi-node, distributed, and so on). We will
    choose Ehcache (which is selected by default).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want to use Hibernate second level cache?** Here, we have the option
    to use Hibernate''s second-level cache. Select Yes for this option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Would you like to use Maven or Gradle for building the backend?** You will
    be asked to choose either Maven or Gradle as a build tool. We will select Maven.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which other technologies would you like to use?** Towards the end, JHipster
    will ask to add a few additional technologies, such as Elasticsearch, WebSocket,
    asynchronous messaging with Kafka, and API-first development with the OpenAPI
    generator. API-first is an approach to designing an application with the API first,
    and developing web or mobile applications on top of those APIs. Nowadays, many
    companies are adopting this approach, and JHipster supports it out of the box.
    To make the thing simple and straightforward, we will not select either of them.
    Since this is a multiple choice selector, you can just press *Enter* to move further
    without selecting any of them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which Framework would you like to use for the client?** The next question
    asks you to select a frontend framework, either Angular or React. Select Angular
    and press *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Would you like to enable Sass stylesheet preprocessor?** Next, it will ask
    you whether to use the **syntactically awesome style sheets** *(***Sass**) stylesheet
    preprocessor. Select Yes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Would you like to enable internationalization support?** If you wish to add
    support for internationalization, select a native language. Select English as
    an answer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Please choose additional languages to install:** Along with your native language,
    you can add support for additional languages. JHipster supports around 30 languages.
    To make things simple, we will not add any additional language.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Besides JUnit and Jest, which testing frameworks would you like to use?** You
    will be asked to select unit testing frameworks on this screen. JHipster supports
    the Gatling, Cucumber, and Protractor frameworks, as well as the default JUnit
    for unit testing. Select none of them and move to the next step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Would you like to install other generators from the JHipster Marketplace?** The
    last question will ask you whether to add additional modules from the JHipster
    marketplace. This is a collection of third-party generators that work on top of
    the core JHipster, with access to its variables and functions and acts like sub-generators.
    You can use them in your application by downloading them from the JHipster Marketplace
    ([https://www.jhipster.tech/modules/marketplace](https://www.jhipster.tech/modules/marketplace)).
    We will select No for this option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, sit back and relax, and JHipster will start to create an application based
    on the options we selected. At this moment, JHipster will generate the code and
    project structure of our application. In brief, JHipster generates the following
    things to make an application ready to run:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular JS application (at the frontend)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liquibase changelog file (used for database table **Data Definition Language**
    (**DDL**) manipulation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can configure an **integrated development environment** (**IDE**) for further
    development once the application has been created. JHipster supports a wide range
    of IDEs, including Eclipse, IntelliJ IDEA, and Visual Studio Code. You can read
    more about this topic at [https://www.jhipster.tech/configuring-ide](https://www.jhipster.tech/configuring-ide).
    The application structure looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a829a4fe-b517-4e16-904a-460778640e35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at each Java package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`com.nilangpatel.aop.logging`: This contains **Aspect-Oriented Programming**
    (**AOP**) advice for logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.config`: This package contains various configurations for
    properties, cache, database, profile, Liquibase, logging, Spring Security, metrics,
    web, locale, and so on, along with constants used across the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.config.audit`: JHipster provides auditing features out of
    the box. This package contains configurations specifically for auditing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.domain`: This contains all of the model objects for the custom
    entities that we created, along with other core model objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.domain.enumeration`: This contains enumerations that we declared
    in the **JHipster Domain Language** (**JDL**). We will discuss JDL more in the
    upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.repository`: Spring Data **Java Persistence API** (**JPA**)
    repositories for each custom and out-of-the-box entities, are stored here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.security`: All security-related classes, such as constants
    for `Roles`, `UserDetail` service, and so on, are stored in this package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.service`: This contains service-layer interfaces for out-of-the-box
    and custom entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.service.dto`: The **data transfer objects** (**DTOs**), used
    to transfer between the controller and the service, are kept here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.service.mapper`: Mapper classes that are used to map model
    objects with DTOs will be stored in this package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.service.util`: This package contains some utility classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.web.rest`: All **Representational State Transfer** (**REST**)
    controllers for each entity are generated under this package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.web.rest.error`: Exceptions specific to REST calls are available
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.web.rest.util`: This contains some utility classes that are
    used in REST calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.nilangpatel.web.rest.vm`: This contains view models, which are mainly
    used in the Administration tab in the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with Java classes and packages, JHipster also generates certain resources
    in the `src/main/resource` folder. The details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config`: This contains various configuration files, such as `application.properties` for
    Spring Boot with various profiles, some Liquibase configuration files, along with
    `changelog` files and keystore files for importing and configuring certificates
    for HTTPS configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i18`: This contains property files for various languages that we selected
    during application creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: This folder contains various mail templates, such as activation,
    account creation, and password reset, along with error templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is time to run an application. JHipster provides the following command to
    build an application with Maven. Make sure that you are at the project directory
    in the Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with building an application, this command will deploy it on the embedded
    web server (which ships with Spring Boot by default). It can be accessed at `http://localhost:8080`,
    and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76273649-fcea-4793-bc5e-fadd4347a8ed.png)'
  prefs: []
  type: TYPE_IMG
- en: If an application needs to be deployed on any application server, JHipster provides
    a way to generate an executable WAR file, with the command `mvnw -Pprod package`for
    Maven and `gradlew -Pprod bootWar` for Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster generates a set of pages and a few users accounts to start with. Click
    on Account | Sign in to login into the application. By default, `Admin` users
    can log in with credentials as `admin/admin`, and normal users can log in with
    `user/user`. The `Admin` user has access to the Administration menu, from where
    they can perform various admin functions.
  prefs: []
  type: TYPE_NORMAL
- en: Entity creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web application has some sort of database interaction, covering basic **Create,
    Read, Update, and Delete** (**CRUD**) operations, as a bare minimum. It requires
    a good amount of effort when done manually. The following tasks need to be completed,
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating database tables, along with their relations and constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a model entity and building the **data access**** object** (**DAO**)
    layer to provide the data interface with the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a service layer to encapsulate business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the web controller and frontend layer, along with all validations,
    to store the data in the respective entity table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from this, additional effort may be required to accommodate future changes
    on any layer. JHipster provides an ingenious solution to this problem. After creating
    an application, we need to build a data access layer, and JHipster makes this
    whole process automatic.
  prefs: []
  type: TYPE_NORMAL
- en: 'A concept in JHipster called **entity generation** makes this happen. Entities
    are the building elements of JHipster applications. The entity generation process
    covers various tasks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating database tables and maintaining their changes (through configuration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a JPA model class, along with a Spring Data JPA repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an optional service layer to accommodate business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating REST controllers supporting basic CRUD operations and frontend side
    Angular router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component and service along with HTML view including integration and performance
    tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isn't it cool? Let's witness the process of making an entity and generating
    the code automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an entity with the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the process of creating an entity in JHipster, we will first
    create a simple entity, called **Owner**, with one attribute, called **name**. The
    way that JHipster allows for entity creation, along with data access, the service
    layer, controller, and frontend layer for that entity is identical to the process
    of generating application code that we saw in the previous section. Both can be
    done with the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For entity generation, JHipster uses the Yeoman tool internally to generate
    the code. Let''s create our first entity. Execute the following command to create
    an entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Owner` is the name of an entity. This command will create an entity for
    `Owner`, and will launch a wizard that asks a few questions of the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you want to add a field to your entity?** If you wish to add a field for
    your entity, select *y*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the name of your field?** You can give the name of the attribute
    here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the type of your field?** You need to provide the type of attribute.
    JHipster supports various attribute types, including `string`, `integer`, `long`,
    `float`, `double`, `BigDecimal`, and `LocalDate`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want to add validation rules to your field?** This concerns whether
    you wish to add any constraints on an attribute of the entity. Select *y*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which validation rules do you want to add?** JHipster also allows you to
    add various constraints, including `required`, `unique`, `min` value, `max` value,
    and regular expression patterns, to validate the input. You can select more than
    one constraint here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding process of adding attributes can be repeated to add further attributes
    to its type and constraints. We will create the `Owner` entity with the `name`
    attribute of the `String` type, with the `required` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster also allows you to define a relation with another entity. Once we have
    finished adding attributes, it will ask us to add a relationship. Since we have
    created only the `Owner` entity, we will add the relationship after we add another
    entity. We will see how to add a relationship later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, just say no (*n*) to adding a relationship, and JHipster will
    show the next set of questions related to the service and controller layer, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you want to use a separate service class for your business logic?** In
    this question, we have been asked if we wish to add a service layer, and the possible
    options are as follows. We will select the third option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, the REST controller should use the repository directly; the REST controller
    will make a direct call to the repository. No service layer is added.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, generate a separate service class; the service layer is added with a service
    class only. The REST controller will call this class for any database interaction.
    We can write additional business logic in the service class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, generate a separate service interface and implementation; in this case,
    the service layer is added with both interface and implementation. The clear advantage
    of this design is we can provide another implementation of the service interface
    without changing other code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want to use a** **DTO****?** The next question is related to DTO.
    JHipster provides an option to create a DTO for each entity. It uses MapStruct,
    another code generator tool used to map Java entities to generate DTOs. Basically,
    it is used to map the values from DTO to the model entity, and vice versa. The
    options for this question are as follows. We will select the second option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, use the entity directly; an entity object is used to pass the data throughout
    all of the layers.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, generate a DTO with MapStruct; this will generate a DTO corresponding to
    each entity. The controller will create an instance of DTO and pass it to the
    service layer. The service class will map the DTO to the entity and call the repository
    to interact with a database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want to add filtering?** This will provide a dynamic filtering option
    to search for specific entities. It uses a JPA static meta-model for filtering
    option. JHipster will create complete code, from the presentation to the DAO,
    if we choose Yes. Though it is quite useful to have the filter option, we will
    select No for this question, for the sake of simplicity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want pagination on your entity?** The next question is about pagination
    patterns. JHipster supports the following patterns for pagination. We will select
    the second option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; this will mean no pagination. All of the records will be visible in a single
    page. This will create performance issues for large datasets.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, with pagination links; this shows the pagination with links to move between
    pages. This is the most common pagination style.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, with infinite scroll; this uses infinite scroll to display the data. The
    scroll will serve the purpose of pagination.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, JHipster will start to create the entity, and will ask to override certain
    files wherever it finds some conflicts. This is because JHipster will start to
    generate the code again. Keep saying yes (y) and pressing *Enter* for all of the
    prompts, and finally, you will see a message saying that the entity has been created.
    Next, let's create another entity, called `Car`, with the attributes of `name`,
    `model`, and `manufacture year`. Follow the previous steps to create the `Car`
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster provides an option to build a relationship during the time of entity
    creation. So, if you have just added a single entity and are trying to create
    a relationship with another entity, you will get an error, saying something like
    the other entity has not been found. So, when building a relationship with another
    entity, make sure that it has been created first.
  prefs: []
  type: TYPE_NORMAL
- en: 'After step five, it will ask about adding a relationship. We already added
    an `Owner` entity and we want to establish a many-to-one relation (many `Cars`
    can be associated with one `Owner`). The following is a set of questions that
    will be asked specifically about the relationship, after step five:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you want to add a relationship to another entity? **Choose Y here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the name of the other entity?** This refers to the name of the entity
    with which we want to set up the relationship. Give the name of the entity as
    `Owner` here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the name of the relationship?** The default is `owner` (this is the
    relationship name that you want to give. By default, system will give lowercase
    name of other side entity name. If you wish, you can change it).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the type of the relationship?** The possible options are one-to-many,
    many-to-one, many-to-many, and one-to-one. They are quite straightforward. We
    will select many-to-one, as we are establishing a relationship with the `Car` entity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**When you display** **this relationship on the client side, which field from**
    `Owner` **do you want to use?** This question asks whether the column name of
    the `Owner` entity should be displayed while showing or adding `Car` data. Internally,
    JHipster always uses ID columns to set the relationships between tables. Give
    the `name` as the answer to this question, as `Owner` has just one column(`name`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do you want to add any validation rules to this relationship?** This basically
    adds validation to the foreign key column.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which validation rules do you want to add?** The possible validation is required.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, it will start to ask questions from the step 6\. Complete it till
    step 9 to add the `Car` entity. At this moment, we have two entities—`Owner` and
    `Car`—with a relation between them, along with the source code of the frontend,
    controller, and service layers, and the DAO layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to build our application. The `**mvnw**` Maven command will
    not only build the application, but will deploy and run it on the embedded server.
    After generating the entities, when we build and deploy the application with this
    command, JHipster will create/update the database table corresponding to each
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: Before building the application, make sure that you set the database credentials
    as per your local MySQL configuration in the `application-prod.yml` file, in the `src/main/resources/config`
    folder. The names of the properties are `spring:datasource:username` and `spring:datasource:password`*.*
    In the absence of this, you will get an error while running the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add some data for our entities. Log in with admin credentials (`admin`/`admin`),
    and go to Entities | Owner to add the owner data first. The Create a new Owner
    button will be used to insert an owner record. Similarly, we can add data for
    the `Car` entity. Since we have created a many-to-one relationship from `Car` to `Owner`
    (that is, many `Car` instances are associated with one `Owner`), you will see
    a field where you can select an `Owner` value while adding a `Car` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The record for the `Car` entity, along with the reference to the `Owner` entity,
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18d57ab2-fc3e-4c16-93cc-0678886ad8b2.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of the `name` attribute of the `Owner` entity is visible as a reference
    here, which we selected when we created the relationship. This page also shows
    pagination of the link type, which we selected during the `Car` entity creation,
    out of the box. Apart from this, you can perform CRUD operations for each individual
    entity without writing a single line of code yourself. This is definitely a cool
    feature that saves lots of development time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: By default, JHipster creates an ID column as the primary key for each entity
    table. Defining a custom column as primary key is not supported out of the box
    for the autogeneration of code. However, if the specific column is required as
    the primary key, you will need to modify the generated source code before running
    it with the `mvnw` command.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how JHipster speeds up development by automating many things.
    Modeling an entity in an application previously required many activities including
    table generation; the creation of the DAO, services, and a presentation layer;
    and validations and a user interface for each individual entity.
  prefs: []
  type: TYPE_NORMAL
- en: Although Spring Boot provides great help in terms of writing boilerplate code,
    the developer still has to write a lot of code to see something happening. This
    is a quite tedious and logically repetitive job. You have seen how JHipster greatly
    helps in this scenario, by providing autogenerating code to build a fully functional
    Spring Boot application without writing a single line of code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an entity with complete working code is just a matter of providing
    certain information to JHipster. At first glance, this looks great, but there
    is another side to the coin. Think about a scenario wherein you need to incorporate
    more than five dozen entities with the JHipster CLI, which is quite possible when
    you write an enterprise application. Sometimes, the total entities reach beyond
    a hundred.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, writing each entity with the CLI and providing all metadata,
    along with relationships with other entities, is painful. As a workaround, JHipster
    provides a graphical tool, where we can design all of the entities in one go.
    The aim is to simplify the process of defining a relationship with the visual
    tool, rather than doing it the classical way, with questions and answers. There
    are two options to visually model the entities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling with **Unified Modeling Language** (**UML**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling with JDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling with UML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this option, we need to design all of the entities as a class diagram, and
    then import it into JHipster to generate the code for all of them in one go. So,
    the whole process is divided into two parts that work independently, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a class diagram of entities with a visual tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting the class diagram and importing it into JHipster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the early phase of application development, the class diagram is mainly
    used to design domain models. Showing the attributes and operations of a class,
    along with its relationship with other classes, the class diagram describes a
    static view of an application. The classes used in the class diagram are directly
    mapped to the object-oriented language, and are also used to model the database
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'JHipster has provided the benefit of this process in the generation of application
    code. A separate tool, called JHipster UML, has been designed; it reads the class
    diagram to generate the entity structure. It can be installed from the Git repository,
    or as a separate `npm` package, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the tools that are available today allow for exporting the class diagram
    into an XMI format. JHipster UML reads XMI files and generates entities. Since
    this tool generates entities in JHipster from class diagrams, the attribute type
    selection is limited to the list of JHipster-supported types. The list of JHipster-supported
    attribute types, along with possible validation rules for each attribute type,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **No.** | **Attribute type** | **Possible validations** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `string` | `required`, `minlength`, `maxlength`, `pattern` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `integer` | `required`, `min`, `max` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `long` | `required`, `min`, `max` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `BigDecimal` | `required`, `min`, `max` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `float` | `required`, `min`, `max` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `double` | `required`, `min`, `max` |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `enum` | `required` |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `Boolean` | `required` |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | `LocalDate` | `required` |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | `ZonedDateTime` | `required` |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | `blob` | `required`, `minbytes`, `maxbytes` |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | `AnyBlob` | `required`, `minbytes`, `maxbytes` |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | `ImageBlob` | `required`, `minbytes`, `maxbytes` |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | `TextBlob` | `required`, `minbytes`, `maxbytes` |'
  prefs: []
  type: TYPE_TB
- en: 'First, we need to design the class diagram for each domain model, along with
    the relationships between them. JHipster recommends using the following tools
    to generate a class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: Modelio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GenMyModel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Out of these, the first two are completely open source, Eclipse-based graphical
    tools, and can be downloaded from their respective sites, while the third is a
    browser-based free tool and can be used directly on the web (with certain limitations).
    Once the class diagram is ready, export it to an XMI file and execute the following
    command in Command Prompt to generate the entity structure. Make sure that you
    are at the project directory when you execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the entity structure. JHipster UML also provides various
    options to specify the pagination pattern, such as whether you want to use DTO
    or add service classes for each of your entities. It can be given along with the
    previous command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the options that you have provided, JHipster UML generates entities
    and other source code. Finally, you need to execute the `mvnw` command, so that
    it will create/modify the required entity tables in the database, along with the
    Liquibase changelog file, and deploy the application to the server. While defining
    the relationships between the classes in a class diagram, you need to make sure
    that they are allowed in JHipster. The supported relationships are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A bidirectional one-to-many relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unidirectional many-to-one relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A many-to-many relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bidirectional one-to-one relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unidirectional one-to-one relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the box, a unidirectional one-to-many relationship is not supported by
    the JHipster code generator. JHipster recommends using a bidirectional one-to-many
    relationship instead.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling with JHipster Domain Language studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing the domain models as a class diagram and then generating the source
    code based on that is a pretty quick way to create entities in JHipster. Consequently,
    it saves time, compared to creating them one by one with the CLI. However, you
    still need to rely on third-party applications to work with JHipster. There is
    the chance that JHipster has very limited support for a specific version, or,
    in the worst case, is totally incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: As a solution, JHipster provides a separate tool, called **JDL studio**. It
    is an online tool to create entities and build relationships between them. The
    clear benefit of using JDL studio is that it has been designed and maintained
    by the JHipster team, so there is almost no chance of version incompatibility
    and other issues. You can be confident when using the stable version. In case
    of any issues, you can easily get updates or support from the official JHipster
    issue tracker.
  prefs: []
  type: TYPE_NORMAL
- en: Creating entities with JDL studio is even more simple than modeling the entities
    with UML. **JHipster Domain Language** (**JDL**), it is a domain language that's
    used to construct entities with pretty simple and easy-to-use syntax in a single
    file (or sometimes, multiple files).
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to work with JDL. You can use either the JHipster IDE or
    the online JDL-Studio ([https://start.jhipster.tech/jdl-studio](https://start.jhipster.tech/jdl-studio)).
    The JHipster IDE is a plugin or extension for well-known IDEs, including Eclipse,
    Visual Studio, and Atom. The online JDL-Studio is a browser-based IDE, with which
    you can construct entities and their relationship in script form, which is written
    in JDL. You can relate it with writing SQL script for creating a database table
    and their relationship.
  prefs: []
  type: TYPE_NORMAL
- en: For sake of simplicity, we will look at a simple example of creating an entity
    with the online JDL-Studio. While writing a definition for each entity, JDL-Studio
    draws the entity diagram with their relationships side by side. When opening the
    online JDL-Studio, you will see some sample entities, along with their relationships
    and other parameters, by default, to give you some ideas on how to start working
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `School` and `Teacher` entities, along with their relationship
    (one-to-many), in the online JDL-Studio. Open the URL and add the definition of
    these entities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entity can be defined with the `entity` keyword, along with its attributes
    and data type. We can also define certain validations on each attribute. These
    validations not only impose the respective constraints at the database table level,
    but also at the frontend side. The `maxlength` validation denotes the maximum
    column length of the given attribute. The `min` and `max` validations describe
    the minimum and maximum values to be entered. The relationship between the entities
    can be defined with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `relationship` can be used with various options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(OneToMany | ManyToOne | OneToOne | ManyToMany)`: The possible types of relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OWNER entity`: The owner entity of the relationship. It can also be described
    as the source of the relationship. The owning side entity must be on the left
    side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DESTINATION entity`: This is the other-side entity where the relationship
    ends, the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Relationship name`: This is the name of the field that represents the other-side
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Display field`: While adding records for the entity, JHipster shows an other-side
    entity drop-down menu on the screen. This attribute shows the field name of the
    other-side entity that would be displayed in the drop-down menu. By default, it
    is the ID (primary key) of the other-side entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required`: This determines whether the other-side entity is required to be
    selected in the drop-down menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `paginate`, `dto`, and `service` keywords are used to define the configuration
    options for the pagination pattern, whether DTO needs to be generated, and whether a
    service layer with the implementation should be generated, respectively. They
    are quite straightforward and you can relate it to the respective options while
    creating the entity with the CLI. JHipster also supports mass (with `*`) and exclude
    options (with the `except` keyword), which are quite powerful and convenient.
    In short, various entity sub-generator features, like the field type, validations,
    relationships, DTOs, services, enumeration, and so on, are supported. JDL-Studio
    generates a diagram based on the definition of our entities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33f9fd8b-cf14-4061-85c7-5bfc4034b784.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we have defined a bidirectional relationship. If a unidirectional
    relationship is required, you just need to remove the name or relationship on
    both sides. For example, the unidirectional relationship between the `School`
    and `Teacher` entities can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JHipster does not support a unidirectional, one-to-many relationship, but this
    is what it looks like. While defining the relationship, you need to aware of the
    relationships supported by JHipster, which we discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Along with generating the entity code, JDL is also used to create applications
    from scratch, along with the deployment options. So, instead of using the question-and-answer-based
    approach with the CLI, you can define all of the configuration options in a single
    JDL file and create an application in one shot.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an entity using a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have defined the entities in JDL studio. Now, we will instruct JHipster
    to generate entities, along with database tables and source code. This process
    involves the following two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the entity definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a JDL file to generate the required artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From JDL-Studio, you can export the definitions as a JDL (`.jh`) file. JHipster
    provides a sub-generator that will be used to import the JDL file, with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Needless to say, you need to execute this command under the JHipster project
    directory. Upon successful build and deployment, you will see the `School` and
    `Teacher` entities from the Entities menu. You can also verify that the respective
    tables are generated. If an application has a large number of entities, it is
    quite difficult to put all of them in a single JDL file. If there is an error
    in one entity, the entire process of generating entities will not work properly.
    In the worst case, if multiple teams are working, then it will create maintenance
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster has addressed this issue by allowing multiple JDL files, so that related
    entities can be grouped into individual JDL files. The `import-jdl` sub-generator
    allows importing multiple files separated by spaces. Upon executing this command
    for the first time, it will generate entities and all of the source code. You
    need to build and deploy the application with the `mvnw` command so that the necessary
    database changes will be reflected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second and subsequently, `import-jdl` will only regenerate the entities that
    have changed. If you wish to generate all of the entities from scratch again,
    you will need to add the `- force` option. Please be aware that this option will
    erase all customization applied to the entities. Certain validations are caught
    at the time that we build and deploy the application with the `mvnw` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `maxlength` and `minlength` validations are not allowed on columns of type
    `integer`, `long`, `BigDecimal`, `LocalDate`, `Boolean`, `enum`, `double`, and
    so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the service layer is escaped for a given entity, then JHipster shows a warning
    if the DTO option with `mapstruct` is selected for that entity. In this situation,
    the application may not work properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While adding a single-line comment, you need to put one space after `//`, or
    else JHipster will show errors and the entities will not be generated properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the national gross domestic product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an idea about how to create an application and model the entities,
    we will start creating an application that shows the GDP of various countries
    with JHipster. We'll do this to showcase the ability to apply customization in
    auto-generated code by JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: Application and entity creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Create an Application* section to create a new application, naming
    it `gdp`. We are going to build an application with similar functionality to that
    which we created with Spring Framework in [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml),
    *Creating an Application to List World Countries with their GDP*. To show the
    GDP data of various countries, we took the reference of a sample country, city
    and country language data from MySQL databases ([https://dev.mysql.com/doc/index-other.html](https://dev.mysql.com/doc/index-other.html))
    and used a REST service to fetch the GDP data for a given country through the
    World Bank API ([https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries)).
    We will use the same reference to build an application with JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it simple, we will use columns which are necessary to fulfill the purpose
    of the application. It is important to understand the table structure first. The
    database tables and their relationship details will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bef82c37-c2d0-4ecd-bfdd-2c6bf417b7d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s define the entities first. JHipster recommends JDL for entity and code
    generation so we will use it to create our entity structure and generate our service
    layer, REST controllers, and DTO, along with a set of components for the frontend
    layer. The JDL script would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This script contains the entity definition for respective tables, along with
    `enum` for `Continent` and `TrueFalse`. We also defined a pagination pattern,
    DTO structure, and service layer with the `Service` class and interface (`serviceImpl`),
    along with a type of relationship. The `Country` will have one-to-many relationships
    with both `City` and `CountryLanguage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `country(name)` in the relationship, on the other side it will show the
    country name as a reference, instead of the default `ID` of the country. Give
    special attention to the last option—`filter`. This declares the `filter` option
    for the `Country` entity, which is used to apply various filtering criteria while
    fetching records for the entity. We will explore this in more detail in the *Developing
    custom screens* section. The JDL diagram should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0bc985b-b705-49ba-80c6-8600ee143d69.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we have omitted a few columns in each table provided by MySQL, the required
    changes also need to be made in the respective insert script of these tables.
    You will find the modified insert script in the `download` folder of the project
    structure. At this moment, you have to apply the insert script before moving further.
  prefs: []
  type: TYPE_NORMAL
- en: Handling enumeration data with a database in JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll run the application and verify that JHipster has created three
    entities and that they are available in the Entities menu to perform various CRUD
    operations. The first time we run the application, we will get an error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This error occurs while fetching continent data and trying to map it with the `Continent`
    enum data type.  The root cause is that we have defined the type of the `continent`
    column of the `Country` entity as a `Continent` enum. The actual value in that
    column, which is added through an insert script (from the MySQL site) is not exactly
    the same as the `Continent` enum values.  For example, the actual value in the
    database is `Asia`, while the corresponding enum is `ASIA`.
  prefs: []
  type: TYPE_NORMAL
- en: Another value of the `continent` column is `North America`, while the corresponding
    enum is `NORTH_AMERICA`. Because of the limitations of enum in Java, we can't
    put a space in the middle of the value, and that is the reason we kept the values
    as `NORTH_AMERICA`, `SOUTH_AMERICA`, and so on. Because of this limitation, along
    with the case difference, you will get the previous exception while running the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a workaround, we need to provide some sort of mapping of actual values in
    the database column, to enum values in Java. For this, we will use the JPA attribute
    converter mechanism. It is basically used to define a method to convert database
    values to Java representations of an attribute and vice versa. Open the `Country.java`
    class at the `com.nilangpatel.domain` package and update the annotation declaration
    for the `continent` attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Originally, it was defined as `@Enumerated(EnumType.STRING)`, which was commented
    out with an added `@Convert` annotation. This annotation requires implementation
    of the `javax.persistence.AttributeConverter` interface. The implementation is
    provided by the `ContinentEnumConvertor` custom class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These two methods will convert the values between the database and the corresponding
    enum value in Java. We also need to do necessary changes in the `Continent` enum
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the application, and you will see the entities and JHipster allows to perform
    CRUD operation to only logged in user. However you will still see that the continent
    values are rendered as enum values, such as `ASIA`, `NORTH_AMERICA`, and so on, instead
    of the actual database column values.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that, when enabling internationalization support at the
    time of application creation, JHipster generates the display value for various
    labels, error messages, and various enumerations. It nicely creates the key-value
    pair in a separate file for each artifact. These files are generated for each
    language-specific folder, under the `src/main/webapp/i18n` folder. For example,
    the language keys and their value for the `Country` entity are created in the `src/main/webapp/i18n/en/country.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our application only has one language, `English`, the language keys are
    only generated for the `English` language, under the `en` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c191091e-0820-4a1f-8179-e321890ce937.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The keys and values are created in a JSON format. To understand its structure,
    open the `country.json` file, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The title is accessible with the `gdpApp.country.home.title` key. This will
    be used in the HTML template. Open the `country.component.html` file under the `/src/main/webapp/app/entities/country`
    folder, and you will see the following code to use this key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: JHipster has created various modules to support validations, enums, reading
    and parsing JSON, and so on. One of them, `translation`, supports internationalization.
    These are installed during JHipster installation as a `jhipster-core` package,
    under the `node_modules` folder created under the project directory. If you need
    to add further labels, you can place the key in the respective JSON file and use
    `jhiTranslate` to render the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to our problem of showing the enum values on the screen for the `Country`
    entity, instead of the actual database value. This happens because the translation
    in `continent.json` is generated with an enum value, by default. You can change
    it as follows in order to show correct continent values on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Everything should work as expected now. The admin is able to see all three entities,
    and can perform CRUD operations properly. We will now develop custom screens to
    show the GDP data by country.
  prefs: []
  type: TYPE_NORMAL
- en: Filter provision in service, persistence, and the REST controller layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recall that, while creating the entities with JDL, we set the filter option
    for the `Country` entity in the JDL script, at the end. Let's look at how this
    makes a difference to the service, persistence, and REST controller layers.
  prefs: []
  type: TYPE_NORMAL
- en: The persistence layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we add a filter option for any entity, JHipster makes the necessary changes
    to the repository interface corresponding to that entity. In our case, the `CountryRepository` is
    now extending the `JpaSpecificationExecutor` interface, which is used to add `Specification`
    capabilities to the repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Spring Data JPA provides a `Specification` interface to execute the criteria
    query, which is used to retrieve values from the database with various criteria
    on database columns.
  prefs: []
  type: TYPE_NORMAL
- en: The service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the service layer, JHipster generates a separate class as `xxxQueryService`,
    under the service package. For the `Country` entity, a new service class, `CountryQueryService`,
    is created. The purpose of this class is to retrieve the data with the filtering
    criteria, so it contains only fetch methods, which look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: JHipster generates a **Plain Old Java Object** (**POJO**) class for each entity
    that is declared with the filter option. This is used to pass the filter values
    from the frontend to the service layer. In our case, JHipster generates a `CountryCriteria`
    class that serves this purpose for the `Country` entity. This class contains various
    filters for each corresponding field in the domain object. If filters are not
    applied, this will bring all of the entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'JHipster has created various filter types, corresponding to each wrapper class
    type. For any custom type, it creates an inner class that extends the `io.github.jhipster.service.filter.Filter`
    class. The `CountryCriteria` class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `continent` attribute in the `Country` domain class is of the enum type,
    so JHipster has created an inner filter class of `ContinentFilter`, and for other
    attributes of the type wrapper class, it uses corresponding filters. From the
    frontend, you need to pass search text as a request parameter in a specific way,
    based on the type of the attribute as follows. Consider the attribute name as
    `abc`*:*
  prefs: []
  type: TYPE_NORMAL
- en: 'If attribute `abc` is of the string type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.contains=<seach_text>`: List down all entities where the value of `abc`
    contains `search_text`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If attribute `abc` is of any number type (float, long, double, integer) or
    the date:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.greaterThan=<search_text>`: List down all entities where the value of `abc`is
    greater than `search_text`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.lessThan=<search_text>`: List down all the entities where the value of
    `abc`is less than `search_text`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.greaterOrEqualThan=<search_text>`:List down all the entities where the
    value of `abc`is greater than or equals to `search_text`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.lessOrEqualThan=<search_text>`:List down all the entities where the value
    of `abc`is less than or equal to `search_text`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If attribute `abc` is of a custom type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.equals=<search_text>`: List down all of the entities where the value of `abc`
    is exactly similar to `search_text`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.in=<comma separated search_text values>`: List down all of the entities
    where a value of `abc`is within the list of `search_text`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.specified=true`: List down all of the entities where the value of `abc`is
    not null, which means specified.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abc.specified=false`: List down all entities where the value of `abc`is null,
    which means not specified.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules can be combined for more than one attributes to form a complex query.
  prefs: []
  type: TYPE_NORMAL
- en: The REST controller layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When applying the filter option, JHipster also makes necessary changes to the
    REST controller. For example, all `get` methods of REST controller `CountryResouce`
    for entity `Country` are now taking `CountryCriteria` as a parameter to support
    filtering operations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the filter option impacts the persistence, service, and REST controller
    layer code generation. With single-filter configuration, JHipster makes all of
    the necessary changes. However, the REST controllers generated for each entity
    are protected with Spring Security, by default. You can verify this in the `config()`
    method of the `com.nilangpatel.config.SecurityConfiguration` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the register, activate, authenticate, and reset password operations,
    all other URLs (`/api/**`) are restricted to logged-in users. But, in our case,
    we want to show the country GDP data to regular users, without logins. For this,
    we need to create a custom REST controller with a different URL pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method is similar to what it has auto-generated in `CountryResource`.
    The second method will be used to show the GDP data, and we will use it while
    creating that screen. The URL pattern map to this controller is `/api/open`. The
    purpose of creating a separate REST controller is to make it accessible without
    a login, by configuring its URL pattern with Spring Security in the `configure`
    method of `SecurityConfiguration`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This controller is now accessible publicly. We will use the controller methods
    while constructing a frontend layer with Angular in the *Develop custom screens*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a filter option to existing entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the entities are already generated without the filter option, and you want
    to add it later on, you will need to perform certain steps. The following are
    two possible approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Command Prompt, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the entity's JSON file under the `.jhipster` folder, inside of the project
    directory. For example, for a `Country` entity, you will see a file named `Country.json`
    inside of the `.jhipster` folder.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of the `service` key is `no`, change it to either `serviceClass`
    or `serviceImpl`*.* The service layer option has to be enabled for the filtering
    option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the value of the key `jpaMetamodelFiltering` to `true`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Regenerate the entity with the `jhipster entity <entity_name>` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With JDL, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a line containing `filter <entity_name>`to the JDL script file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-import the definition with the `jhipster jhipster-jdl <jdl_file>` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In both of these scenarios, the customization will be reverted while regenerating
    the entities, so make a proper back-up before performing this task.
  prefs: []
  type: TYPE_NORMAL
- en: Developing custom screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, JHipster only shows the entities to logged-in users. The aim of
    our application is to show the GDP data of a given country to the end user. To
    achieve this, the country data must be visible publicly. In other words, it must
    be accessible without a login. To make it more user-friendly, we will design the
    flow in two different screens.
  prefs: []
  type: TYPE_NORMAL
- en: The first screen will list all the countries available in the system. Selecting
    any of them will show the actual GDP of that country on the second screen, with
    a graphical presentation. These are the custom screens that we need to develop
    from scratch and plug into the JHipster project structure, which we will do in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: The search country screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this screen, we will list of all of the countries available in the system
    with pagination. It is identical to the *Country* entity screen but available
    to all users (without login). For better user experience, we will add filters
    to find a specific country on this screen. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bec5ea1-5a09-4947-8ad2-73df7292f760.png)'
  prefs: []
  type: TYPE_IMG
- en: This screen has two filters. The first filter will match the search text in
    the country name (`contains` criteria), while the second will compare the selected
    continent (`equals` criteria). These filters help the user to find their desired
    country instantly. To make it simpler, we have added just a few columns of information
    about each country, which seems appropriate for this screen. At the end of each
    country record, the View button will navigate a user to the second screen, where
    it shows the GDP information of that country.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster provides either **Angular** or **React** as an option to develop the
    frontend. We have chosen Angular to create this application. Consequently, all
    of our out-of-the-box screens are generated with the Angular framework. Since
    this is a custom screen, we need to use various Angular artifacts to develop it.
    Create a `gdp` folder inside of the `/src/webapp/app` folder, and, in the next
    subsection, we'll create Angular artifacts inside of it, to construct custom screens.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular is a modular framework wherein we write many components, each for a
    specific purpose. Many times, we are in need of some common functionalities shared
    across multiple components. Additionally, we may need to fetch records from the
    database with a REST call. This is where creating an Angular service makes perfect
    sense. For our GDP application, we need to fetch country data in the Angular service
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `query` method is used to fetch all of the countries with various request
    parameters sent by the `search-country` component. The second method, `find`,
    is used to fetch a specific country, based on a given `id` value. This service
    class uses the `HttpClient` module, which is provided by the Angular framework
    out of the box, to make a REST call to the newly created REST controller.
  prefs: []
  type: TYPE_NORMAL
- en: The `api/open/search-countries` and `api/open/show-gdp` URLs are used to make
    calls to the REST controller methods, `getAllCountriesForGdp()` and `getCountryDetails()`,
    respectively. However, the `find()` method of service component is dynamically passing
    the `id` value into the URL with the `${this.showGDPUrl}/${id}` expression. This
    service class is common for both of the screens.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next artifact is the Angular router. The Angular router is used to manage
    application navigation and routing between various components. The Angular router uses
    a browser URL to map it to a specific component. It does various types of processing
    on the browser URL, such as parsing to verify that the URL is valid; doing a redirect
    if that option is given; matching the component against the URL segment; validating
    if the given URL is accessible with the set of guards; running the associate resolves
    to dynamically add the data; and finally, activating the component and performing
    navigation. We will write the Angular router as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It comprises a `resolve` class (`CountryGDPResolve`) and a route array. The
    `resolve` class fetches the full country model data, based on a country ID when
    a user clicks on View button to initiate a transition to the second screen. It
    uses a service component to make a REST call and fetch country information. The
    router array holds the configuration mapping of components and the URLs by which
    they will be triggered. This Angular router is also common for both screens.
  prefs: []
  type: TYPE_NORMAL
- en: Angular modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, Angular is a modular framework. A module in Angular is used to
    group related components, pipes, directives, and services, to form an independent
    unit, which can be combined with other modules to form a complete application.
    A **module** can control which components, services, and other artifacts are hidden
    and visible to other modules, in much the same way that a Java class has public
    and private methods. We will use a single module called `CountryGDPModule`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It defines all of the components and routers that are necessary to be part of
    this module. It is common for both screens.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular component to show the country list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will write a component to show the country list on the first screen.
    A component is a basic building block with which we create our Angular application.
    Every Angular application has at least one component. The component holds application
    data and logic to show the data in the HTML template associated with it. We will
    write a separate component for each of the screens in our application. For the
    first screen, we will write a `search-country` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: An Angular component can be created with the `@component()` decorator. The `SearchCountryComponent`
    class represents the `search-country` component. It is defined with certain variables
    that are used for pagination and filtering purposes. The object of `CountryGDPService` is
    injected into the component class through a constructor, which will be used in
    other methods to fetch country data. The constructor is initialized with pagination
    variables, which are used to handle pagination on the first screen.
  prefs: []
  type: TYPE_NORMAL
- en: Soon after the component class is initialized with the constructor, Angular
    will call the `ngOnInit()` method. In this method, we are initializing a few parameters
    and making a call to other methods with `loadAll()`. This method calls the `query()`
    method of the `countryGDPService` object to fetch the country info.
  prefs: []
  type: TYPE_NORMAL
- en: The `query()` method takes various pagination and filtering parameters. The
    `page`, `size`, and `sort` are pagination parameters, while `name.contains` and
    `continent.equals` are filtering parameters. They are eventually submitted to
    the REST controller through `CountryGDPService`.
  prefs: []
  type: TYPE_NORMAL
- en: The `name.contains` filtering parameter is used to filter the country data,
    based on the `name` attribute. Since it is of the type `String`, we have used
    the `contains` criteria. Similarly, the other filtering parameter, `continent.equals`,
    is used to filter the data for the `continent` attribute. Since it is of the type
    `enum`, we are using the `equals` criteria. This is what we have seen in the *Service
    layer* section, under the *Filter provision in service, persistence, and the REST
    controller layer* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The other functions, like `searchCountries()`, `trackId()`, `loadPage()`, and
    so on, are called from the HTML template directly associated with the `search-country`
    component. You can see it in the source code of the chapter from GitHub at [https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04](https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Angular template to show the country list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we need an HTML template to render the country data on the screen.
    Each Angular component has one HTML template associated with a `@Component` decorator.
    For our first screen to show the list of countries, the HTML template looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The HTML `form` is used to render the filtering options, with the country name
    as a text field and the continent as a drop-down menu. After the filter form,
    it shows the countries in a tabular format, with the pagination at the bottom.
    The last column of each row has a View button, which opens the next screen using
    the `/showGDP` URL and passing the `id` of the current country.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the GDP screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This screen shows the basic data of a selected country, along with the GDP
    data, in a graphical representation. We will use the World Bank API to fetch the
    information in a JSON format and supply it to a chart module to render a graph
    of the GDP data. This screen looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff24ec52-92a5-4f89-8c02-abab43bf5ecd.png)'
  prefs: []
  type: TYPE_IMG
- en: This screen uses the same service, router, and module artifacts that we created
    for the first screen, but will use a separate component and HTML template, as
    you will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: An Angular component to show country GDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `show-gdp` component takes the country data from the first screen, makes
    a call to the World Bank API, and fetches the data in a JSON format, before finally
    sending it to the chart module to render the graph. This component looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor of this component, we are getting the selected country from
    the Angular router. In the `resolve()` method of the `CountryGDPResolve` class,
    we are fetching the country object from the `ID` parameter in the URL, and this
    object is then available to this component through the router, because we have
    provided a resolve configuration to this component in `countryGDPRoute`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get the country information, we will make our calls to the World Bank
    API. The URL for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://api.worldbank.org/v2/countries/**IND**/indicators/NY.GDP.MKTP.CD?format=json&per_page=10](http://api.worldbank.org/v2/countries/IND/indicators/NY.GDP.MKTP.CD?format=json&per_page=10).'
  prefs: []
  type: TYPE_NORMAL
- en: In this URL, the country code is inserted dynamically, from the country data
    that is given by the router. The `per_page` attribute returns the GDP data for
    that many numbers of years. The preceding example shows the last ten years' worth
    of GDP data for the country India. After getting the JSON data, we are iterating
    and preparing two arrays, `year` and `gdp`, and passing them to the chart module
    to generate a chart on the screen. The chart module can be installed as a node
    module, with the `npm install chart.js` command.
  prefs: []
  type: TYPE_NORMAL
- en: Angular template to show country GDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the template for the `show-gdp` component will render the chart and
    show the country GDP data. The template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It shows a few details about the selected country, followed by a placeholder
    for the chart. The `noDataAvailale` variable is used to show a message, in the
    case that there is no GDP data available for the selected country. It is set in
    the `show-gdp` component while making the World Bank API call.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking the GDP module into AppModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything is done now. Our GDP module is ready for execution. The last step
    is to plug it into the JHipster project structure. You have seen that a module
    is comprised of multiple artifacts, such as components, pipes, services, and routers.
    Multiple modules are grouped together to form an application.
  prefs: []
  type: TYPE_NORMAL
- en: Every Angular application has at least one module, known as a root module, and
    it is used to bootstrap the application. Usually, this module is known as `AppModule`,
    by convention. Since the frontend of our application is built on top of Angular,
    there is an `AppModule`. The `app.module.ts` file under the `/src/main/webapp/app`
    folder represents an `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to configure our custom module in `AppModule` to make it in action.
    This can be achieved by adding our module to the `imports` declaration under `@NgModule`,
    in the `app.module.ts` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Upon adding entities into an application, JHipster generates a common module
    called `XXXEntityModule`, that holds the references of all the artifacts related
    to all entities. Soon after the entities are generated, JHipster adds this module
    entry to the import array inside of `@NgModule`. We have added another entry for
    the GDP module (`CountryGDPModule`). This is how any custom module can be plugged
    into `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our module is ready, and is also plugged into `AppModule`, to put it into action.
    However, one small thing is still missing, which is to locate the navigation to
    launch the GDP module. The best option is to put the navigation link into the
    navigation bar at the top of the page. JHipster provides a navigation bar as a
    separate module out of the box, and it shows various links. A few of them are
    publicly visible, and others are only for logged-in and `Admin` users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the link, we need to modify the navigation template file, `navbar.component.html`,
    under the `/src/main/webapp/app/layouts/navbar` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added HTML code, highlighted in bold, to show the Countries menu item
    in the navigation bar. This looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfe81b78-3808-4a2a-8b98-6ec49ceea2f8.png)'
  prefs: []
  type: TYPE_IMG
- en: The path for `routerLink` is defined as Countries, which ultimately triggers
    the `t=the search-country` component to show the country list with the filter
    option on the first screen. This is how you can add custom screens in JHipster
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Other JHipster features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have seen how to create fully-fledged and production-ready applications
    with JHipster. You have seen how to create entities and define a relationship
    between them. We have also added custom screens and developed various artifacts,
    so that you could learn how to add customized code to an application generated
    by the JHipster ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: These are some of the great features that not only make the developer's life
    easier, but also more productive, by automating lots of processes. We will look
    at these now.
  prefs: []
  type: TYPE_NORMAL
- en: IDE support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, you saw how to create an application with
    the JHipster CLI by answering various questions. This is more than sufficient
    to start working with JHipster. However, to become more productive, it is recommended
    to use an IDE for development. JHipster supports a wide range of IDEs, including
    Eclipse, Visual Studio Code, IntelliJ IDEA, and so on. While working with an IDE
    (or a simple text editor), you need to make sure to exclude a certain folder from
    doing indexing, like `node_modules`, `build`, and `target`, to reduce the initial
    loading time of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting screens out of the box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JHipster provides several screens out of the box. Broadly, they can be categorized
    into three different groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Home and login screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home and login screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon starting, JHipster shows the home screen with a welcome message. This
    is the default home page and you can change it as per your application needs.
    In local development, by default, the `dev` profile is selected, so you will see
    a development tab at the top-left corner. On the top section of the page, you
    will see a navigation menu. Without have logged in, it will show the following
    menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Home: A link to show a home page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language: This is conditional. This menu will be only visible if you have selected
    more than one language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Account: This shows child menu items, such as Sign in and Register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upon clicking on the Sign in option, you will see a login page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42169da4-3411-4be0-a3f6-debe10692372.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This screen covers Remember me, Did you forget forget your password?, and Register
    a new account features. The forgotten password feature requires email verification.
    For this, you need to configure SMTP with JHipster in the application properties
    file. By default, JHipster creates the following two users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Administrator**: Username—`admin`, Password—`admin`, role—`admin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: Username—`user`, Password—`user`, role—`user`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JHipster facilitates login features out of the box. It also incorporates account
    management with this. The account screen provided by JHipster supports various
    actions in the form of child menus, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Settings**: This screen allows for updating the user account details, such
    as the first and last name, email address, and language. The language drop-down
    menu shows all available languages in the system, which are configured during
    the creation of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: This screen is used to update the currently logged-in user''s
    password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registration**: This screen is used to register new users into the system.
    It is only available when a user is not logged in. Soon after a user is created,
    an activation flow will be started, with an activation email and verification.
    The SMTP configuration needs to be done in the application properties for sending
    an email. Please note that if OAuth is selected as an authentication mechanism
    during the application creation, JHipster will not show this screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Upon signing in with administrator credentials, you will see a navigation menu
    with the Administration option. It covers various modules used to manage the whole
    application. It is useful for development, as well as monitoring the application.
  prefs: []
  type: TYPE_NORMAL
- en: It comprises various child menus, as described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: User management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a one-stop screen that's used to manage the registered users of the
    application. You can add a new user and modify, delete, or activate/deactivate
    existing users from this screen. It also shows the list of users with various
    attributes, such as `ID`, `username`, `email`, `Activate/Deactivate`, `Language`,
    `Roles`, `Created date`, `Modify by`, and `Modify date with pagination support`.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JHipster provides various screens to analyze the performance of the application
    and other metrics, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JVM Metrics**: This shows JVM-specific statistics, like memory utilization,
    thread counts, thread dump, and garbage collection details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP requests**: Aggregated details of HTTP requests, with their status code
    is shown for this metric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service statistics**: Details of the execution time of various out-of-the-box
    and custom services are shown here. It is useful to see the usage of various services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache statistics**: The details of the entity cache are covered in this metric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataSource statistics**: The data source details will be shown here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Refresh button is given to update the metrics with the latest value.
  prefs: []
  type: TYPE_NORMAL
- en: Health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This screen shows various pieces of information related to application health,
    such as the underlying database and disk space. It is used make decisions about
    data storage well in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This screen shows the current configuration applied to the application. It is
    especially useful for troubleshooting an application in case of any issue arising,
    or to check for the possibility of further performance improvement. It covers
    Spring Framework specific configurations, server configurations, system environment
    configurations, and application properties. Since this involves sensitive data,
    only the administrator can see it, by default.
  prefs: []
  type: TYPE_NORMAL
- en: Audit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JHipster provides an audit log for user authentication. Since authentication
    is done by Spring Security in JHipster, it captures security-specific events specifically
    for authentication, and stores them in a database at the separate Spring data
    repository. They are useful from a security point of view. This screen shows all
    of this data in tabular format, with pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This screen shows, various application log levels, such as `TRACE`, `DEBUG`,
    `INFO`, `WARN`, `ERROR`, and `OFF` at runtime, for classes and packages. It also
    allows for updating the log level for individual classes and packages. This is
    helpful while troubleshooting the application.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JHipster uses Swagger, a framework used to describe the structure of APIs. As
    you have seen, JHipster supports entity creation, and also exposes the REST API.
    It uses Swagger to document the entity REST API. JHipster also provides a user
    interface to interact with the API using sample data, and returns the output.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining code quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JHipster generates lots of boilerplate code while creating an application and
    entities. It follows best practices while generating the code, in order to maintain
    the quality. However, JHipster just creates the application code the first time,
    and the user must add custom code based on the business needs later on.
  prefs: []
  type: TYPE_NORMAL
- en: To maintain the code quality even after adding the customized code, JHipster
    allows analyzing the complete application code with Sonar—a tool designed specifically
    for monitoring code quality. The code is analyzed using **SonarCloud***—*the cloud
    version of the Sonar. For this, you must commit the code in Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also can analyze the code on a local Sonar server. For this, you must set
    up and run the Sonar server locally. The default port on which the Sonar server
    runs is `9000`, so you need to make sure that the Sonar port configured in `pom.xml`
    (if the build type is Maven) is the same. Execute the `mvnw test sonar:sonar`
    command, and you will see the code analysis in Sonar, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c03dcee-921f-4fbc-9805-2cb2b2a2f6b5.png)'
  prefs: []
  type: TYPE_IMG
- en: This helps to maintain the code quality even after adding custom code to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a monolithic application using JHipster. However,
    it also allows users to create microservice-based applications. The microservice-based
    architecture splits the whole monolithic application (both the frontend and backend)
    into small and independent modular services. It is a unique way of doing software
    development that has grown rapidly in the last couple of years.
  prefs: []
  type: TYPE_NORMAL
- en: Each modular service can interact with other services through a unique and simple
    API. The microservice architecture has many advantages over a monolithic design,
    such as independent development and deployment, managing fail-over with ease,
    the fact that developers can work in the independent team, making continuous delivery,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a microservice architecture does not have any frontend layer, but
    JHipster supports a microservice gateway with a frontend to handle web traffic.
    It works as a proxy microservice for the end user. In short, a user can interact
    with a microservice through a gateway. The JHipster microservice model is comprised
    of one gateway service, one registry, and at least one or more microservice applications
    that we can create with JHipster with a backend code, which can be accessed with
    an API.
  prefs: []
  type: TYPE_NORMAL
- en: Docker support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is an open source software platform that supports containers, making
    application deployment portable and self-contained. It is used to package the
    entire application (including SQL and NoSQL databases, Sonar configuration, and
    so on) and its dependencies together as a single container image, to deploy and
    test on any environment.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster provides support for Docker out of the box for monolithic and microservice-based
    applications. Docker was developed for Linux, but has separate versions for macOS
    and Windows. JHipster only creates a Dockerfile at the time of application generation.
    The Dockerfile holds the set of instructions used by Docker containers to build
    a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster also supports pulling Docker images from the Docker Hub. This is an
    online registry that's used to publish public and private Docker images. This
    greatly helps in using third-party tools without local installation, as Docker
    images can be pulled and run on a local container.
  prefs: []
  type: TYPE_NORMAL
- en: Profile management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The profile is a set of configurations for a specific environment, like development,
    testing, production, and so on. JHipster supports profile management, and comes
    with two profiles—`dev` and `prod`—out of the box. By default, it uses the `dev`
    profile. JHipster provides a separate application properties file for each profile.
  prefs: []
  type: TYPE_NORMAL
- en: In production, you need to enable the production profile with the `./mvnw -Pprod`
    command for Maven and the `./gradlew -Pprod` command for Gradle. If you need to
    export an executable WAR file in production, you can use the command `./mvnw -Pprod
    package` for Maven, and `./gradlew -Pprod package` for Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Live reload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most challenging factors in the software development process, in
    terms of time management, is recompiling the code, deploying it, and restarting
    the server to see the changes you made. Generally, the frontend code written in
    JavaScript does not require compilation, and can immediately reflect the changes
    upon browser refresh. Nevertheless, the latest frontend frameworks require some
    sort of transpilation after making changes in the script file.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, for any single code change, typically, you need to build,
    deploy, and restart the server. This will badly impact developer productivity.
    To avoid this, JHipster supports a mechanism called **live reload**. JHipster
    generates a Spring Boot-based application with the `DevTools` module to refresh
    the changes on the server without doing a cold restart. This is enabled by default,
    so whenever any Java code changes occur, it will automatically refresh them on
    the server. The live reloads for any frontend code can be achieved through **BrowserSync**,
    which can be started with the `npm start` command, and is accessible at `http://localhost:9000`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Testing support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an integral part of any software development process. It provides
    quality assurance of the application or product. While creating an application
    and entities, JHipster creates various automated unit test cases for both the
    frontend and backend (or the server side).
  prefs: []
  type: TYPE_NORMAL
- en: The server-side unit test cases are generated in the `/src/test/java` folder.
    They cover various layers of the application, such as the repository, service,
    security, REST API, and pagination. They are grouped in respective packages. You
    can run individual test cases from the IDE, or run all test cases from the Command
    Prompt with the `mvnw test` command. Make sure that you are in the application
    directory when you execute this command. In the case of Gradle, you will need
    to execute the `gradle test` command.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend (or client-side) unit testing can be executed with the `npm test` command.
    This will execute various JavaScript test cases for the typescript residing in
    the `/src/test/javascript/spec` folder. JHipster also supports end-to-end client-side
    test cases with the Jest framework, by default. Optionally, other frameworks,
    such as **Gatling**, **Cucumber**, and **Protractor**, can also be used for client-side
    end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike other frameworks, upgrading JHipster is a painless process. A subgenerator
    called **JHipster upgrade** is used to upgrade an existing application for the
    new version, without removing any custom changes that have been added since the
    application was created the first time. This is quite useful, especially when
    a new version of JHipster is released with known bug fixes and security patches.
    JHipster upgrades can be executed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the whole upgrade process automated, JHipster take the help of Git
    with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command checks whether a new version of JHipster is available,
    unless the `--force` flag is given explicitly. If this option is given, the upgrade
    sub-generator will be triggered, irrespective of the latest version being installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole upgrade process depends on Git, so if an application is not initialized
    with Git (if Git is not installed), JHipster will initialize Git and commit the
    current code to the master branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JHipster will check for any uncommitted local code. The upgrade process fails
    if the code is not committed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it will check if a `jhipster_upgrade` branch is available in Git. If not,
    this will be created. This branch is dedicated to the JHipster upgrade process,
    so it should never be updated manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JHipster will check out the `jhipster_upgrade` branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, JHipster is upgraded with the latest version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current project directory is cleaned and the application is generated from
    scratch, with the entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated code will then be committed to the `jhipster_upgrade` branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `jhipster_upgrade` branch will be merged with the original branch
    from which the `jhipster_upgrade` command was launched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of any conflicts, you will need to resolve and commit them manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing greatly helps in making the system bug-free, even after adding
    new functionalities. JHipster creates unit and integration test cases for generated
    code that will be helpful up to some extent. In a real scenario, we need to add
    further unit test cases targeted for custom business implementations; for example,
    you might have added few custom screens, controller and service layer for which
    you need to write additional unit test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need to add integration test cases for newly introduced APIs. Apart
    from that, we also need to add client-side test cases for frontend customization.
  prefs: []
  type: TYPE_NORMAL
- en: Presently, testing and continuous integration have become an integral part of
    the software development process. Testing will help to produce a quality product,
    while continuous integration is nothing but constantly merging and testing newly
    introduced code changes, which assists in identifying potential bugs. This happens
    with the combination of executing automated units, integration, and end-to-end
    test cases against the code. A classic example is triggering the automated test
    suite on every commit on Git; or, more efficiently, running it as per a predefined
    schedule.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of an automated testing model can be achieved by putting a continuous
    integration process in place, to make sure that new code changes do not introduce
    regressions to the stable version. This assures the merging of new changes and
    deploying to production with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: The continuous testing, integration, and continuous deployment results in a
    concept called **Continuous Integration/Continuous Deployment** (**CI/CD**), which performs
    continuous integration, testing, and deploying the code. Continuous delivery can
    be achieved through various CI/CD tools. JHipster provides elegant support for
    well known CI/CD tools available in the market today, such as Jenkins, Travis
    CI, GitLab CI, and Circle CI.
  prefs: []
  type: TYPE_NORMAL
- en: Community support and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how good a software framework or product is, its popularity comes
    from how easily users can get help from documentation and the community. JHipster
    has very nice documentation on their official site, which is more than sufficient
    to start working with it.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the official GitHub forum, there are plenty of other resources and
    forums available, in which you can easily get help with any issue or problem while
    working with JHipster. Additionally, the developers provide professional help
    in terms of answering questions on time and providing bug fixes as a priority.
    This really helps to attract developers and organizations to start to work with
    JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: The JHipster Marketplace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Who doesn't like to use reusable components or modules that fit business requirements?
    This would greatly save development time. As an open source software, the JHipster
    team not only produces a great masterpiece in the form of the framework, but also
    maintains a repository of reusable modules, called the **Marketplace**.
  prefs: []
  type: TYPE_NORMAL
- en: You can download various modules, as per your needs, and plug them directly
    in your application. You can contribute your module back to the Marketplace, so
    that other community users can get the benefit of that module. This is a great
    platform provided by JHipster to share a piece of reusable code with the community.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has really been a great journey, exploring a new framework for building
    a powerful web application. JHipster is a really great tool for crafting a modern
    and production-ready application in no time. With lots of things happening automatically,
    JHipster not only makes a developer's job easier, but also improves the overall
    project delivery schedule.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we explored the basics of JHipster as a framework,
    along with an installation guide. Moving forward, you learned how JHipster generates
    application code with a question-and-answer approach. It uses another tool, called
    **Yeoman**, to generate application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing domain objects as entities and supporting complete CRUD operations
    is the most important part of any application. In the next step, we learned how
    JHipster provides support for modeling domain objects through entity generation.
    Entity generation can be done with three options: the classic Yeoman-based option,
    the UML approach, and by using JDL-Studio. We have looked at all of them in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: After covering these features, we started to create an application to show GDP
    information by country. This required us to build custom screens, and we discovered
    how to add customization in an application generated with JHipster. We also collected
    a few details of generated code in various layers, including the persistence,
    service, REST controller, and frontend layer, which will help us to accommodate
    any future customization.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end, we looked at some unseen features that demonstrate what a robust
    platform JHipster is, and how it allows us to build a Spring-based, enterprise-grade
    application with ease. In the next chapter, you will learn how to create a Spring-based
    application with a microservice architecture, and how this is different and can
    be beneficial, as compared to a monolithic application.
  prefs: []
  type: TYPE_NORMAL
