- en: An Application to View Countries and their GDP using JHipster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JHipster 查看国家和它们的 GDP 的应用程序
- en: As time has passed, changing business functions have required delivery teams
    to produce high-quality software products at a rapid pace. To meet this expectation,
    the IT industry has become focused on making the software development process
    streamlined and automated. As a result, many new platforms are emerging, with
    the aim of generating the code to prepare production-ready applications in no
    time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，不断变化的企业功能要求交付团队以快速的速度交付高质量的软件产品。为了满足这一期望，IT 行业已经专注于使软件开发流程更加流畅和自动化。因此，许多新的平台正在涌现，旨在在极短的时间内生成准备就绪的应用程序代码。
- en: We started our journey with a simple application developed in Spring Framework
    that showed the **gross domestic product** (**GDP**) information of various countries
    with the World Bank API, in [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml),
    *Creating an Application to List World Countries with their GDP*. The Spring Framework
    provides a comprehensive way to develop an enterprise-ready application with ease.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从开发的一个简单应用程序开始，该应用程序使用 Spring 框架和世界银行 API 展示了各国**国内生产总值**（**GDP**）信息，如[第 1
    章](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml)中所述，*创建一个列出世界各国及其 GDP 的应用程序*。Spring
    框架提供了一种简单的方法来轻松开发企业级应用程序。
- en: With the birth of Spring Boot framework, development with Spring Framework has
    become far quicker and smarter than ever before. In subsequent chapters, we moved
    on to Spring Boot and explored its capabilities, specifically for integration
    with other Spring and third-party libraries and modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Spring Boot 框架的诞生，使用 Spring 框架的开发变得比以往任何时候都要快和智能。在随后的章节中，我们转向了 Spring Boot
    并探讨了其功能，特别是与其他 Spring 和第三方库和模块的集成。
- en: 'In this chapter, we will explore another framework, named JHipster, which is
    one step ahead in making Spring-based applications with just a few clicks, and
    makes Spring development joyful. We will utilize JHipster to develop the application
    from [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml), *Creating an Application
    to List World Countries with their GDP, *showing the GDP information of various
    countries and showcasing how the development process is streamlined and automated.
    We will cover the following interesting topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨另一个名为 JHipster 的框架，它只需点击几下就能在 Spring 基础上创建应用程序，使 Spring 开发变得愉快。我们将利用
    JHipster 从[第 1 章](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml)，*创建一个列出世界各国及其 GDP
    的应用程序*开始开发，展示如何展示各国 GDP 信息以及开发流程是如何被简化和自动化的。在本章中，我们将涵盖以下有趣的主题：
- en: Introducing JHipster
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 JHipster
- en: Installation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装
- en: Application creation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序创建
- en: Modeling and creation of the entity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体的建模和创建
- en: Creating the GDP application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 GDP 应用程序
- en: Learn how to add customization in JHipster application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在 JHipster 应用程序中添加自定义功能
- en: Other features of JHipster
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JHipster 的其他功能
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下 GitHub 链接下载：[https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05)。代码可以在任何操作系统上执行，尽管它只在
    Windows 上进行了测试。
- en: Introducing JHipster
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 JHipster
- en: '**JHipster** is, in brief, a code generating tool, built on top of large collections
    of development, build, test, and deployment frameworks and platforms. It is a
    modern web application development platform, used to build all layers of a comprehensive
    Java-based web application, from the frontend to the database. JHipster supports
    various frameworks under the hood, giving the user options to choose from when
    starting application development.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**JHipster** 是一个代码生成工具，它建立在大量的开发、构建、测试和部署框架和平台之上。它是一个现代的 Web 应用程序开发平台，用于构建基于
    Java 的全面 Web 应用程序的所有层，从前端到数据库。JHipster 在底层支持各种框架，为用户提供了在开始应用程序开发时进行选择的机会。
- en: 'JHipster is a free and open source platform aimed at greatly simplifying the
    process of generating, developing, and deploying monolithic and microservices-based
    applications on Spring Framework and Angular or React technologies. Before building
    an application in JHipster, a user will be asked various questions, in order to
    generate a production-ready application based on the options chosen by the user.
    JHipster provides the application with support for the following tools and frameworks,
    out of the box:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 是一个免费的开源平台，旨在极大地简化在 Spring Framework 和 Angular 或 React 技术上生成、开发和部署单体和微服务应用程序的过程。在
    JHipster 中构建应用程序之前，用户将被询问各种问题，以便根据用户选择的选项生成一个生产就绪的应用程序。JHipster 为应用程序提供以下工具和框架的支持，无需额外安装：
- en: '**Build tool:** Maven, Gradle'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建工具:** Maven, Gradle'
- en: '**Development platform:** Spring Framework'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发平台:** Spring Framework'
- en: '**Security framework:** Spring Security'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全框架:** Spring Security'
- en: '**Templating:** Thymeleaf'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板化:** Thymeleaf'
- en: '**Microservices:** Netflix OSS'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务:** Netflix OSS'
- en: '**RDBMS:** H2, MySQL, Oracle, PostgreSQL, MS SQL, MariaDB'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系型数据库管理系统（RDBMS）:** H2, MySQL, Oracle, PostgreSQL, MS SQL, MariaDB'
- en: '**Data streaming:** Kafka'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据流处理:** Kafka'
- en: '**DB tracker:** Liquibase'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库跟踪器:** Liquibase'
- en: '**NoSQL:** MonboDB, Cassandra, Couchbase, Hazelcast'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NoSQL:** MonboDB, Cassandra, Couchbase, Hazelcast'
- en: '**Cache implementation:** Infinispan, Ehcache'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存实现:** Infinispan, Ehcache'
- en: '**Search engine:** Elasticsearch and **Elasticsearch, Logstash, and Kibana** stack
    (**ELK**)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索引擎:** Elasticsearch 和 **Elasticsearch, Logstash, and Kibana** 堆栈（**ELK**）'
- en: '**Monitoring:** Prometheus'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控:** Prometheus'
- en: '**ORM:** Hibernate'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象关系映射（ORM）:** Hibernate'
- en: '**Testing framework:** Cucumber, Browsersync, Jest, Protractor test'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试框架:** Cucumber, Browsersync, Jest, Protractor 测试'
- en: '**Load testing:** Gatling'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试:** Gatling'
- en: '**UI:** Bootstrap, HTML5, CSS3, SaaS, Redux'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面:** Bootstrap, HTML5, CSS3, SaaS, Redux'
- en: '**JavaScript framework: **Angular, Typescript, React, Webpack'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript 框架:** Angular, TypeScript, React, Webpack'
- en: '**Deployment:** Docker, Kubernetes, Boxfuse, Rancher'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署:** Docker, Kubernetes, Boxfuse, Rancher'
- en: '**Cloud support:** Heroku, Cloud Foundry, AWS, OpenShift'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云支持:** Heroku, Cloud Foundry, AWS, OpenShift'
- en: '**CI/CD:** Jenkins, Travis CI, GitLab CI, CircleCI'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD:** Jenkins, Travis CI, GitLab CI, CircleCI'
- en: 'The code generated by JHipster is as per industry standards, best practices,
    and quality compliance. Along with autogenerating application code, JHipster also
    supports automated testing and the continuous integration and delivery of the
    application in a more streamlined way. This can bring great benefits to an organization,
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 生成的代码符合行业标准、最佳实践和质量规范。除了自动生成应用程序代码外，JHipster 还支持更流畅的应用程序自动化测试和持续集成与交付。这对组织来说可以带来巨大的好处，如下所示：
- en: Creating an application with various platforms and frameworks in a uniform and
    controlled way.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以统一和受控的方式在各种平台和框架上创建应用程序。
- en: Most of the boilerplate code is generated automatically, so a developer can
    focus on the implementation of business requirements. This will increase developer
    productivity and greatly improve the overall project delivery timeline.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分样板代码都是自动生成的，因此开发者可以专注于业务需求的实现。这将提高开发者的生产效率，并大大缩短整体项目交付时间表。
- en: Easy integration of changes throughout the application, from the frontend to
    the database table.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从前端到数据库表的整个应用程序中轻松集成更改。
- en: Improved code quality of the application, overall.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的整体代码质量得到提升。
- en: Different projects in the organization can share common artifacts with ease.
    Consequently, the overall productivity of the project teams will be improved.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织中的不同项目可以轻松共享通用工件。因此，项目团队的整体生产率将得到提高。
- en: Installing JHipster
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 JHipster
- en: JHipster recommends that normal users install with `npm`. The `npm` is a package
    manager from `Node.js`, used to install various software. It is the world's largest
    software repository, where you will find thousands of pieces of open source software,
    in the form of packages. If `npm` is not installed, just go to the Downloads section
    of the Node site ([https://nodejs.org/en/download](https://nodejs.org/en/download))
    and install the latest 64-bit **Long Term Support** (**LTS**) version, because
    the non-LTS version is not supported by JHipster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 推荐普通用户使用 `npm` 进行安装。`npm` 是来自 `Node.js` 的包管理器，用于安装各种软件。它是世界上最大的软件仓库，在这里你可以找到成千上万的开源软件包。如果未安装
    `npm`，只需访问 Node 网站的下载部分（[https://nodejs.org/en/download](https://nodejs.org/en/download)）并安装最新的
    64 位 **长期支持（LTS**）版本，因为 JHipster 不支持非 LTS 版本。
- en: 'Once `npm` is installed, run the following command to install the JHipster
    package from the command line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`npm`，运行以下命令从命令行安装JHipster包：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JHipster uses another tool, named **Yeoman** ([http://yeoman.io/](http://yeoman.io/)),
    to generate the application code, which is installed along with the JHipster Node
    package. After creating an application, JHipster provides an option to build it
    with either Maven or Gradle. For this, JHipster will install the required wrappers
    for Maven and Gradle, so nothing is required explicitly, especially for building
    an app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster使用另一个名为**Yeoman** ([http://yeoman.io/](http://yeoman.io/))的工具来生成应用程序代码，该工具与JHipster
    Node包一起安装。创建应用程序后，JHipster提供了一个选项，可以使用Maven或Gradle构建它。为此，JHipster将安装Maven和Gradle所需的包装器，因此不需要明确安装，特别是对于构建应用程序。
- en: Local installation of JHipster can also be done with Yarn, another package manager
    for installing software. The process of installing JHipster with Yarn is almost
    identical to that of `npm`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster也可以使用Yarn进行本地安装，Yarn是另一种用于安装软件的包管理器。使用Yarn安装JHipster的过程几乎与`npm`相同。
- en: Creating an application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'After installing JHipster, the next step is to create an application. Create
    a project directory with an appropriate name in your local machine, select this
    directory from Command Prompt, and execute the following command. The name of
    the project directory is given as `gdp`, but it can be any valid name:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装JHipster之后，下一步是创建一个应用程序。在您的本地机器中创建一个具有适当名称的项目目录，从命令提示符中选择此目录，并执行以下命令。项目目录的名称为`gdp`，但可以是任何有效的名称：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Soon after hitting this command, JHipster will start to ask a series of questions,
    and will decide what has to be generated based on the answers given by the user,
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此命令后不久，JHipster将开始提出一系列问题，并根据用户给出的答案决定需要生成的内容，如下所示：
- en: '**Which type of application would you like to create? **There are four possible
    options to choose from, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想创建哪种类型的应用程序？** 有四种可能的选择，如下所示：'
- en: '**Monolithic application:** This option is used to create a self-contained
    application. This is the recommended option to create a simple application, so
    we will choose this option.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单体应用程序**：此选项用于创建一个自包含的应用程序。这是创建简单应用程序的推荐选项，因此我们将选择此选项。'
- en: '**Microservice application:** If you want to design an application based on
    a microservices architecture, you can choose this option.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务应用程序**：如果您想基于微服务架构设计应用程序，您可以选择此选项。'
- en: '**Microservice gateway:** The microservice gateway is used to build a microservice-based
    application with the UI. By default, microservice applications do not have a UI.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务网关**：微服务网关用于构建具有UI的基于微服务应用程序。默认情况下，微服务应用程序没有UI。'
- en: '**JHipster UAA server:** JHipster supports creating applications with **User
    Authentication and Authorization** *(***UAA**).'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JHipster UAA服务器**：JHipster支持创建带有**用户身份验证和授权** (*UAA*) 的应用程序。'
- en: '**What is the base name of your application?** You need to give your application
    a name. By default, it takes the same name as the project directory. If you want,
    you can give it another name.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您的应用程序的基本名称是什么？** 您需要给您的应用程序起一个名字。默认情况下，它采用与项目目录相同的名称。如果您愿意，可以给它另一个名称。'
- en: '**What is your default Java package name?** Next, you need to give a Java package
    name. You can give an appropriate name (it will be considered as a base package,
    and all other Java source files will be generated in their respective packages
    relative to this package).'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您的默认Java包名是什么？** 接下来，您需要提供一个Java包名。您可以提供一个合适的名称（它将被视为基本包，并且所有其他Java源文件都将相对于此包生成）。'
- en: '**Do you want to use the JHipster Registry to configure, monitor, and scale
    your application?** This question concerns using the JHipster Registry in our
    application. The registry is extensively used in microservice-based applications,
    for registering various services. For a monolithic application, we can still use
    it because although it is a kind of registry, it concerns the health of the application,
    which helps us to monitor the application. It comes as a `Docker` image. For simplicity,
    we are not going to use it, so choose No and go ahead.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用JHipster Registry来配置、监控和扩展您的应用程序吗？** 这个问题涉及到在我们的应用程序中使用JHipster Registry。该注册器在基于微服务应用程序中广泛使用，用于注册各种服务。对于单体应用程序，我们仍然可以使用它，因为尽管它是一种注册器，但它关注应用程序的健康状况，这有助于我们监控应用程序。它以`Docker`镜像的形式提供。为了简单起见，我们不会使用它，所以选择“否”并继续。'
- en: '**Which type of authentication would you like to use?** Next up is the authentication
    mechanism. It provides three options to choose from, as follows. We will select
    the third option (HTTP session authentication):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用哪种身份验证类型？** 接下来是身份验证机制。它提供了三个选项供您选择，如下所示。我们将选择第三个选项（HTTP会话身份验证）：'
- en: '**JWT Authentication:** **JSON Web Token** (**JWT**), which is an open standard
    for transmitting information between two parties in form of JSON. Authentication
    is the most common use case of JWT.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**JWT身份验证：** **JSON Web Token**（JWT），是一种用于在两个实体之间以JSON形式传输信息的开放标准。身份验证是JWT最常见的使用场景。'
- en: '**OAuth2/OIDC Authentication:** JHipster provides complete support for OAuth2
    with Keycloak and **OpenID Connect** (**OIDC**), which is generated by default when
    we select this option. Keyclock is an open source identity brokering and access
    management solution. **Open ID Connect** (**OIDC**), which is a simple identity
    layer on top of the OAuth2 protocol.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**OAuth2/OIDC身份验证：** JHipster为Keycloak和**OpenID Connect**（OIDC）提供了完整的OAuth2支持，当我们选择此选项时，它将默认生成。Keycloak是一个开源的身份代理和访问管理解决方案。**OpenID
    Connect**（OIDC）是OAuth2协议之上的简单身份层。'
- en: '**HTTP session authentication:** This authenticates users based on sessions. This
    is the most commonly used option.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTP会话身份验证：** 这通过会话来验证用户。这是最常用的选项。'
- en: '**Which type of database would you like to use?** Next, it will ask the type
    of database, we would like to use in our application. JHipster supports various
    SQL databases. It also supports three NoSQL databases—MongoDB, Couchbase, and
    Cassandra, which has a Spring data backend. We will select SQL.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用哪种数据库？** 接下来，它会询问我们希望在应用程序中使用哪种类型的数据库。JHipster支持各种SQL数据库。它还支持三种NoSQL数据库——MongoDB、Couchbase和Cassandra，后者具有Spring数据后端。我们将选择SQL。'
- en: '**Which production/development database would you like to use?** You will be
    asked separate questions to select specific databases for production and development.
    JHipster maintains various profiles for various environments (such as development,
    production, and so on). It will configure the databases based on your selected
    options. In our case, we will select MySQL for both production and development.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用哪种生产/开发数据库？** 您将被询问分别选择特定数据库用于生产和开发。JHipster为各种环境（如开发、生产等）维护了各种配置文件。它将根据您的选择配置数据库。在我们的案例中，我们将选择MySQL用于生产和开发。'
- en: '**Do you want to use the Spring cache abstraction?** Moving further, it will
    ask about the type of caching mechanism, such as Ehcache, Hazelcase, Memcached,
    or no cache at all; Spring cache abstraction will be used to plug any of them.
    We can select any of them, based on our particular business needs and the underlying
    hardware architecture (single node, multi-node, distributed, and so on). We will
    choose Ehcache (which is selected by default).'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用Spring缓存抽象吗？** 进一步操作时，它会询问您想使用的缓存机制类型，例如Ehcache、Hazelcast、Memcached或者完全不使用缓存；Spring缓存抽象将用于连接任何一种。我们可以根据特定的业务需求和底层硬件架构（单节点、多节点、分布式等）选择任何一种。我们将选择Ehcache（默认选择）。'
- en: '**Do you want to use Hibernate second level cache?** Here, we have the option
    to use Hibernate''s second-level cache. Select Yes for this option.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用Hibernate二级缓存吗？** 在这里，我们有使用Hibernate二级缓存的选项。选择是此选项。'
- en: '**Would you like to use Maven or Gradle for building the backend?** You will
    be asked to choose either Maven or Gradle as a build tool. We will select Maven.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用Maven还是Gradle来构建后端？** 您将被要求选择Maven或Gradle作为构建工具。我们将选择Maven。'
- en: '**Which other technologies would you like to use?** Towards the end, JHipster
    will ask to add a few additional technologies, such as Elasticsearch, WebSocket,
    asynchronous messaging with Kafka, and API-first development with the OpenAPI
    generator. API-first is an approach to designing an application with the API first,
    and developing web or mobile applications on top of those APIs. Nowadays, many
    companies are adopting this approach, and JHipster supports it out of the box.
    To make the thing simple and straightforward, we will not select either of them.
    Since this is a multiple choice selector, you can just press *Enter* to move further
    without selecting any of them.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用哪些其他技术？** 在最后，JHipster将询问添加一些额外的技术，例如Elasticsearch、WebSocket、使用Kafka的异步消息传递以及使用OpenAPI生成器的API-first开发。API-first是一种首先设计API的应用程序设计方法，然后在这些API之上开发Web或移动应用程序。如今，许多公司都在采用这种方法，而JHipster默认支持它。为了使事情简单直接，我们不会选择它们中的任何一个。由于这是一个多选选择器，您只需按*Enter*键继续，而不选择任何选项。'
- en: '**Which Framework would you like to use for the client?** The next question
    asks you to select a frontend framework, either Angular or React. Select Angular
    and press *Enter*.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想为客户端使用哪个框架？** 下一个问题将询问您选择一个前端框架，即Angular或React。选择Angular并按*Enter*键。'
- en: '**Would you like to enable Sass stylesheet preprocessor?** Next, it will ask
    you whether to use the **syntactically awesome style sheets** *(***Sass**) stylesheet
    preprocessor. Select Yes.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想启用Sass样式表预处理程序吗？** 接下来，它将询问您是否要使用**语法上令人惊叹的样式表**（***Sass**）样式表预处理程序。选择“是”。'
- en: '**Would you like to enable internationalization support?** If you wish to add
    support for internationalization, select a native language. Select English as
    an answer.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想启用国际化支持吗？** 如果您想添加国际化支持，请选择一种本地语言。选择英语作为答案。'
- en: '**Please choose additional languages to install:** Along with your native language,
    you can add support for additional languages. JHipster supports around 30 languages.
    To make things simple, we will not add any additional language.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请选择要安装的附加语言：** 除了您的母语外，您还可以添加对其他语言的支持。JHipster支持大约30种语言。为了简化流程，我们不会添加任何附加语言。'
- en: '**Besides JUnit and Jest, which testing frameworks would you like to use?** You
    will be asked to select unit testing frameworks on this screen. JHipster supports
    the Gatling, Cucumber, and Protractor frameworks, as well as the default JUnit
    for unit testing. Select none of them and move to the next step.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**除了JUnit和Jest，您还想使用哪些测试框架？** 在此屏幕上，您将被要求选择单元测试框架。JHipster支持Gatling、Cucumber和Protractor框架，以及默认的JUnit进行单元测试。选择它们中的任何一个，然后继续下一步。'
- en: '**Would you like to install other generators from the JHipster Marketplace?** The
    last question will ask you whether to add additional modules from the JHipster
    marketplace. This is a collection of third-party generators that work on top of
    the core JHipster, with access to its variables and functions and acts like sub-generators.
    You can use them in your application by downloading them from the JHipster Marketplace
    ([https://www.jhipster.tech/modules/marketplace](https://www.jhipster.tech/modules/marketplace)).
    We will select No for this option.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想从JHipster市场安装其他生成器吗？** 最后一个问题将询问您是否要从JHipster市场添加额外的模块。这是一个第三方生成器的集合，它们在JHipster核心之上工作，可以访问其变量和函数，并充当子生成器。您可以通过从JHipster市场下载它们来在您的应用程序中使用它们（[https://www.jhipster.tech/modules/marketplace](https://www.jhipster.tech/modules/marketplace)）。我们将为这个选项选择“否”。'
- en: Project structure
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'Now, sit back and relax, and JHipster will start to create an application based
    on the options we selected. At this moment, JHipster will generate the code and
    project structure of our application. In brief, JHipster generates the following
    things to make an application ready to run:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请放松并休息，JHipster将开始根据我们选择的选项创建应用程序。在这个时候，JHipster将生成我们应用程序的代码和项目结构。简而言之，JHipster生成以下内容以使应用程序准备好运行：
- en: Spring Boot application
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot应用程序
- en: Angular JS application (at the frontend)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular JS应用程序（在前端）
- en: Liquibase changelog file (used for database table **Data Definition Language**
    (**DDL**) manipulation)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liquibase变更日志文件（用于数据库表**数据定义语言**（**DDL**）操作）
- en: Other configuration files
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他配置文件
- en: 'We can configure an **integrated development environment** (**IDE**) for further
    development once the application has been created. JHipster supports a wide range
    of IDEs, including Eclipse, IntelliJ IDEA, and Visual Studio Code. You can read
    more about this topic at [https://www.jhipster.tech/configuring-ide](https://www.jhipster.tech/configuring-ide).
    The application structure looks as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序创建完成，我们可以配置一个**集成开发环境**（**IDE**）以进行进一步的开发。JHipster支持广泛的IDE，包括Eclipse、IntelliJ
    IDEA和Visual Studio Code。您可以在[https://www.jhipster.tech/configuring-ide](https://www.jhipster.tech/configuring-ide)了解更多关于这个主题的信息。应用程序的结构如下所示：
- en: '![](img/a829a4fe-b517-4e16-904a-460778640e35.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a829a4fe-b517-4e16-904a-460778640e35.png)'
- en: 'Let''s look at each Java package, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次查看每个Java包，如下所示：
- en: '`com.nilangpatel.aop.logging`: This contains **Aspect-Oriented Programming**
    (**AOP**) advice for logging.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.aop.logging`: 这包含了**面向切面编程**（**AOP**）的日志建议。'
- en: '`com.nilangpatel.config`: This package contains various configurations for
    properties, cache, database, profile, Liquibase, logging, Spring Security, metrics,
    web, locale, and so on, along with constants used across the application.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.config`: 这个包包含了属性、缓存、数据库、配置文件、Liquibase、日志、Spring Security、度量、Web、区域设置等各种配置，以及跨应用程序使用的常量。'
- en: '`com.nilangpatel.config.audit`: JHipster provides auditing features out of
    the box. This package contains configurations specifically for auditing.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.config.audit`: JHipster提供了开箱即用的审计功能。这个包包含了专门用于审计的配置。'
- en: '`com.nilangpatel.domain`: This contains all of the model objects for the custom
    entities that we created, along with other core model objects.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.domain`: 这包含了我们所创建的自定义实体的所有模型对象，以及其他核心模型对象。'
- en: '`com.nilangpatel.domain.enumeration`: This contains enumerations that we declared
    in the **JHipster Domain Language** (**JDL**). We will discuss JDL more in the
    upcoming section.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.domain.enumeration`: 这包含了我们在**JHipster域语言**（**JDL**）中声明的枚举。我们将在下一节中进一步讨论JDL。'
- en: '`com.nilangpatel.repository`: Spring Data **Java Persistence API** (**JPA**)
    repositories for each custom and out-of-the-box entities, are stored here.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.repository`: 每个自定义和开箱即用的实体的Spring Data **Java持久性API**（**JPA**）存储库都存储在这里。'
- en: '`com.nilangpatel.security`: All security-related classes, such as constants
    for `Roles`, `UserDetail` service, and so on, are stored in this package.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.security`: 所有与安全相关的类，例如`Roles`常量、`UserDetail`服务等，都存储在这个包中。'
- en: '`com.nilangpatel.service`: This contains service-layer interfaces for out-of-the-box
    and custom entities.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.service`: 这包含了服务层的接口，用于开箱即用和自定义实体。'
- en: '`com.nilangpatel.service.dto`: The **data transfer objects** (**DTOs**), used
    to transfer between the controller and the service, are kept here.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.service.dto`: 用于在控制器和服务之间传输的**数据传输对象**（**DTOs**）保存在这里。'
- en: '`com.nilangpatel.service.mapper`: Mapper classes that are used to map model
    objects with DTOs will be stored in this package.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.service.mapper`: 用于将模型对象映射到DTOs的映射器类将存储在这个包中。'
- en: '`com.nilangpatel.service.util`: This package contains some utility classes.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.service.util`: 这个包包含了一些实用类。'
- en: '`com.nilangpatel.web.rest`: All **Representational State Transfer** (**REST**)
    controllers for each entity are generated under this package.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.web.rest`: 每个实体的所有**表示状态转移**（**REST**）控制器都生成在这个包下。'
- en: '`com.nilangpatel.web.rest.error`: Exceptions specific to REST calls are available
    here.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.web.rest.error`: 这里提供了针对REST调用的特定异常。'
- en: '`com.nilangpatel.web.rest.util`: This contains some utility classes that are
    used in REST calls.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.web.rest.util`: 这个包包含了一些在REST调用中使用的实用类。'
- en: '`com.nilangpatel.web.rest.vm`: This contains view models, which are mainly
    used in the Administration tab in the UI.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.nilangpatel.web.rest.vm`: 这包含了视图模型，主要用于UI中的管理标签页。'
- en: 'Along with Java classes and packages, JHipster also generates certain resources
    in the `src/main/resource` folder. The details are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java类和包之外，JHipster还在`src/main/resource`文件夹中生成某些资源。具体如下：
- en: '`config`: This contains various configuration files, such as `application.properties` for
    Spring Boot with various profiles, some Liquibase configuration files, along with
    `changelog` files and keystore files for importing and configuring certificates
    for HTTPS configuration.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`: 这包含了各种配置文件，例如用于Spring Boot的`application.properties`文件，包含各种配置文件，一些Liquibase配置文件，以及用于导入和配置HTTPS配置证书的`changelog`文件和keystore文件。'
- en: '`i18`: This contains property files for various languages that we selected
    during application creation.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i18`: 这包含我们在应用程序创建期间选择的多种语言的属性文件。'
- en: '`templates`: This folder contains various mail templates, such as activation,
    account creation, and password reset, along with error templates.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`: 这个文件夹包含各种邮件模板，如激活、账户创建和密码重置，以及错误模板。'
- en: 'It is time to run an application. JHipster provides the following command to
    build an application with Maven. Make sure that you are at the project directory
    in the Command Prompt:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行应用程序了。JHipster提供了以下命令来使用Maven构建应用程序。确保你在命令提示符中的项目目录：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Along with building an application, this command will deploy it on the embedded
    web server (which ships with Spring Boot by default). It can be accessed at `http://localhost:8080`,
    and looks as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建应用程序，此命令还会将其部署到嵌入式网络服务器（默认情况下与Spring Boot一起提供）。它可以通过`http://localhost:8080`访问，如下所示：
- en: '![](img/76273649-fcea-4793-bc5e-fadd4347a8ed.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76273649-fcea-4793-bc5e-fadd4347a8ed.png)'
- en: If an application needs to be deployed on any application server, JHipster provides
    a way to generate an executable WAR file, with the command `mvnw -Pprod package`for
    Maven and `gradlew -Pprod bootWar` for Gradle.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序需要在任何应用服务器上部署，JHipster提供了一种生成可执行WAR文件的方法，对于Maven使用命令`mvnw -Pprod package`，对于Gradle使用`gradlew
    -Pprod bootWar`。
- en: JHipster generates a set of pages and a few users accounts to start with. Click
    on Account | Sign in to login into the application. By default, `Admin` users
    can log in with credentials as `admin/admin`, and normal users can log in with
    `user/user`. The `Admin` user has access to the Administration menu, from where
    they can perform various admin functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster生成一组页面和一些用户账户以开始。点击“账户”|“登录”以登录到应用程序。默认情况下，“管理员”用户可以使用凭证`admin/admin`登录，普通用户可以使用`user/user`登录。`管理员`用户可以访问“管理”菜单，从那里可以执行各种管理功能。
- en: Entity creation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体创建
- en: 'A web application has some sort of database interaction, covering basic **Create,
    Read, Update, and Delete** (**CRUD**) operations, as a bare minimum. It requires
    a good amount of effort when done manually. The following tasks need to be completed,
    in this case:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络应用程序有一些数据库交互，至少包括基本的**创建、读取、更新和删除**（**CRUD**）操作。如果手动完成，则需要大量的努力。在这种情况下，需要完成以下任务：
- en: Creating database tables, along with their relations and constraints
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库表，以及它们的关联和约束
- en: Constructing a model entity and building the **data access**** object** (**DAO**)
    layer to provide the data interface with the database
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模型实体和构建**数据访问**对象（**DAO**）层以提供与数据库的数据接口
- en: Generating a service layer to encapsulate business logic
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个服务层来封装业务逻辑
- en: Preparing the web controller and frontend layer, along with all validations,
    to store the data in the respective entity table
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备网络控制器和前端层，包括所有验证，以将数据存储在相应的实体表中
- en: Apart from this, additional effort may be required to accommodate future changes
    on any layer. JHipster provides an ingenious solution to this problem. After creating
    an application, we need to build a data access layer, and JHipster makes this
    whole process automatic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，可能还需要额外的努力来适应任何层的未来变化。JHipster为此问题提供了一个巧妙的解决方案。在创建应用程序后，我们需要构建一个数据访问层，JHipster使整个过程自动化。
- en: 'A concept in JHipster called **entity generation** makes this happen. Entities
    are the building elements of JHipster applications. The entity generation process
    covers various tasks, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster中一个称为**实体生成**的概念使这一切成为可能。实体是JHipster应用程序的构建元素。实体生成过程包括以下各种任务：
- en: Creating database tables and maintaining their changes (through configuration)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库表并维护其更改（通过配置）
- en: Constructing a JPA model class, along with a Spring Data JPA repository
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个JPA模型类，以及一个Spring Data JPA仓库
- en: Creating an optional service layer to accommodate business rules
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可选的服务层以适应业务规则
- en: Creating REST controllers supporting basic CRUD operations and frontend side
    Angular router
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建支持基本CRUD操作和前端Angular路由的REST控制器
- en: Component and service along with HTML view including integration and performance
    tests
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和服务以及HTML视图，包括集成和性能测试
- en: Isn't it cool? Let's witness the process of making an entity and generating
    the code automatically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这不酷吗？让我们见证创建实体和自动生成代码的过程。
- en: Adding an entity with the CLI
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI添加实体
- en: To demonstrate the process of creating an entity in JHipster, we will first
    create a simple entity, called **Owner**, with one attribute, called **name**. The
    way that JHipster allows for entity creation, along with data access, the service
    layer, controller, and frontend layer for that entity is identical to the process
    of generating application code that we saw in the previous section. Both can be
    done with the CLI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示在JHipster中创建实体的过程，我们首先创建一个简单的实体，称为**Owner**，它有一个属性，称为**name**。JHipster允许创建实体以及数据访问、服务层、控制器和该实体的前端层的方式与我们在上一节中看到的生成应用程序代码的过程相同。两者都可以使用CLI完成。
- en: 'For entity generation, JHipster uses the Yeoman tool internally to generate
    the code. Let''s create our first entity. Execute the following command to create
    an entity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实体生成，JHipster内部使用Yeoman工具生成代码。让我们创建我们的第一个实体。执行以下命令以创建实体：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Owner` is the name of an entity. This command will create an entity for
    `Owner`, and will launch a wizard that asks a few questions of the user, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Owner` 是一个实体的名称。此命令将为 `Owner` 创建一个实体，并将启动一个向用户提出几个问题的向导，如下所示：'
- en: '**Do you want to add a field to your entity?** If you wish to add a field for
    your entity, select *y*.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你想要在你的实体中添加一个字段吗？** 如果你希望为你的实体添加一个字段，请选择 *y*。'
- en: '**What is the name of your field?** You can give the name of the attribute
    here.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的字段名称是什么？** 你可以在这里给出属性名称。'
- en: '**What is the type of your field?** You need to provide the type of attribute.
    JHipster supports various attribute types, including `string`, `integer`, `long`,
    `float`, `double`, `BigDecimal`, and `LocalDate`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的字段类型是什么？** 你需要提供属性的类型。JHipster支持各种属性类型，包括 `string`、`integer`、`long`、`float`、`double`、`BigDecimal`
    和 `LocalDate`。'
- en: '**Do you want to add validation rules to your field?** This concerns whether
    you wish to add any constraints on an attribute of the entity. Select *y*.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你想要在你的字段中添加验证规则吗？** 这关系到你是否希望在实体的属性上添加任何约束。选择 *y*。'
- en: '**Which validation rules do you want to add?** JHipster also allows you to
    add various constraints, including `required`, `unique`, `min` value, `max` value,
    and regular expression patterns, to validate the input. You can select more than
    one constraint here.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你想要添加哪些验证规则？** JHipster还允许你添加各种约束，包括 `required`、`unique`、`min` 值、`max` 值和正则表达式模式，以验证输入。你可以选择多个约束。'
- en: The preceding process of adding attributes can be repeated to add further attributes
    to its type and constraints. We will create the `Owner` entity with the `name`
    attribute of the `String` type, with the `required` constraint.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加属性的前一个过程中，可以重复此过程以添加更多属性到其类型和约束。我们将创建具有 `name` 属性的 `Owner` 实体，该属性为 `String`
    类型，并带有 `required` 约束。
- en: JHipster also allows you to define a relation with another entity. Once we have
    finished adding attributes, it will ask us to add a relationship. Since we have
    created only the `Owner` entity, we will add the relationship after we add another
    entity. We will see how to add a relationship later on.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster还允许你定义与另一个实体的关系。一旦我们完成添加属性，它将要求我们添加一个关系。由于我们只创建了 `Owner` 实体，我们将在添加另一个实体后添加关系。我们将在稍后看到如何添加关系。
- en: 'At the moment, just say no (*n*) to adding a relationship, and JHipster will
    show the next set of questions related to the service and controller layer, as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只是说“不”（*n*）添加关系，JHipster将显示与服务和控制器层相关的下一组问题，如下所示：
- en: '**Do you want to use a separate service class for your business logic?** In
    this question, we have been asked if we wish to add a service layer, and the possible
    options are as follows. We will select the third option:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你想要为你的业务逻辑使用一个单独的服务类吗？** 在这个问题中，我们被问及是否希望添加服务层，可能的选项如下。我们将选择第三个选项：'
- en: No, the REST controller should use the repository directly; the REST controller
    will make a direct call to the repository. No service layer is added.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，REST控制器应该直接使用存储库；REST控制器将直接调用存储库。不需要添加服务层。
- en: Yes, generate a separate service class; the service layer is added with a service
    class only. The REST controller will call this class for any database interaction.
    We can write additional business logic in the service class.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，生成一个单独的服务类；服务层仅通过服务类添加。REST控制器将调用此类进行任何数据库交互。我们可以在服务类中编写额外的业务逻辑。
- en: Yes, generate a separate service interface and implementation; in this case,
    the service layer is added with both interface and implementation. The clear advantage
    of this design is we can provide another implementation of the service interface
    without changing other code.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是，生成单独的服务接口和实现；在这种情况下，服务层添加了接口和实现。这种设计的明显优势是我们可以在不更改其他代码的情况下提供服务接口的另一个实现。
- en: '**Do you want to use a** **DTO****?** The next question is related to DTO.
    JHipster provides an option to create a DTO for each entity. It uses MapStruct,
    another code generator tool used to map Java entities to generate DTOs. Basically,
    it is used to map the values from DTO to the model entity, and vice versa. The
    options for this question are as follows. We will select the second option:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想使用DTO吗？** 下一个问题与DTO相关。JHipster提供了一个为每个实体创建DTO的选项。它使用MapStruct，另一个代码生成工具，用于将Java实体映射到生成DTO。基本上，它用于将DTO的值映射到模型实体，反之亦然。此问题的选项如下。我们将选择第二个选项：'
- en: No, use the entity directly; an entity object is used to pass the data throughout
    all of the layers.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，直接使用实体；实体对象用于在所有层之间传递数据。
- en: Yes, generate a DTO with MapStruct; this will generate a DTO corresponding to
    each entity. The controller will create an instance of DTO and pass it to the
    service layer. The service class will map the DTO to the entity and call the repository
    to interact with a database.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是，使用MapStruct生成DTO；这将为每个实体生成相应的DTO。控制器将创建DTO的实例并将其传递到服务层。服务类将DTO映射到实体并调用存储库与数据库交互。
- en: '**Do you want to add filtering?** This will provide a dynamic filtering option
    to search for specific entities. It uses a JPA static meta-model for filtering
    option. JHipster will create complete code, from the presentation to the DAO,
    if we choose Yes. Though it is quite useful to have the filter option, we will
    select No for this question, for the sake of simplicity.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想添加过滤功能吗？** 这将提供动态过滤选项以搜索特定实体。它使用JPA静态元模型进行过滤选项。如果我们选择是，JHipster将为从表示层到DAO的完整代码创建代码。尽管过滤选项非常有用，但为了简单起见，我们将选择否。'
- en: '**Do you want pagination on your entity?** The next question is about pagination
    patterns. JHipster supports the following patterns for pagination. We will select
    the second option:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想在实体上使用分页吗？** 下一个问题涉及到分页模式。JHipster支持以下分页模式。我们将选择第二个选项：'
- en: No; this will mean no pagination. All of the records will be visible in a single
    page. This will create performance issues for large datasets.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不；这意味着没有分页。所有记录将显示在单个页面上。这将为大数据集创建性能问题。
- en: Yes, with pagination links; this shows the pagination with links to move between
    pages. This is the most common pagination style.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是，使用分页链接；这显示了带有跳转页面的分页链接。这是最常见的分页样式。
- en: Yes, with infinite scroll; this uses infinite scroll to display the data. The
    scroll will serve the purpose of pagination.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是，使用无限滚动；这使用无限滚动来显示数据。滚动将起到分页的作用。
- en: Now, JHipster will start to create the entity, and will ask to override certain
    files wherever it finds some conflicts. This is because JHipster will start to
    generate the code again. Keep saying yes (y) and pressing *Enter* for all of the
    prompts, and finally, you will see a message saying that the entity has been created.
    Next, let's create another entity, called `Car`, with the attributes of `name`,
    `model`, and `manufacture year`. Follow the previous steps to create the `Car`
    entity.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JHipster将开始创建实体，并在发现冲突时要求覆盖某些文件。这是因为JHipster将开始再次生成代码。对于所有提示，请继续说“是”（y）并按*Enter*键，最后，您将看到一个消息说实体已创建。接下来，让我们创建另一个实体，称为`Car`，具有`name`、`model`和`manufacture
    year`属性。按照之前的步骤创建`Car`实体。
- en: JHipster provides an option to build a relationship during the time of entity
    creation. So, if you have just added a single entity and are trying to create
    a relationship with another entity, you will get an error, saying something like
    the other entity has not been found. So, when building a relationship with another
    entity, make sure that it has been created first.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster提供了一个在创建实体时建立关系的选项。因此，如果您刚刚添加了一个实体并尝试与另一个实体建立关系，您将收到一个错误，例如说另一个实体未找到。所以，在与其他实体建立关系时，请确保它已经创建。
- en: 'After step five, it will ask about adding a relationship. We already added
    an `Owner` entity and we want to establish a many-to-one relation (many `Cars`
    can be associated with one `Owner`). The following is a set of questions that
    will be asked specifically about the relationship, after step five:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步之后，它将询问添加关系。我们已添加了一个`Owner`实体，并想建立多对一的关系（多个`Car`可以与一个`Owner`相关联）。以下是在第5步之后将具体询问关系的几个问题：
- en: '**Do you want to add a relationship to another entity? **Choose Y here.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想添加另一个实体的关系吗？** 在这里选择Y。'
- en: '**What is the name of the other entity?** This refers to the name of the entity
    with which we want to set up the relationship. Give the name of the entity as
    `Owner` here.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**其他实体的名称是什么？** 这指的是我们想要建立关系的实体的名称。在这里，请将实体的名称作为`Owner`给出。'
- en: '**What is the name of the relationship?** The default is `owner` (this is the
    relationship name that you want to give. By default, system will give lowercase
    name of other side entity name. If you wish, you can change it).'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关系的名称是什么？** 默认为`owner`（这是您想要给出的关系名称。默认情况下，系统将给出另一侧实体名称的小写形式。如果您愿意，您可以更改它）。'
- en: '**What is the type of the relationship?** The possible options are one-to-many,
    many-to-one, many-to-many, and one-to-one. They are quite straightforward. We
    will select many-to-one, as we are establishing a relationship with the `Car` entity.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关系的类型是什么？** 可能的选项有一对多、多对一、多对多和一对一。它们相当直接。我们将选择多对一，因为我们正在与`Car`实体建立关系。'
- en: '**When you display** **this relationship on the client side, which field from**
    `Owner` **do you want to use?** This question asks whether the column name of
    the `Owner` entity should be displayed while showing or adding `Car` data. Internally,
    JHipster always uses ID columns to set the relationships between tables. Give
    the `name` as the answer to this question, as `Owner` has just one column(`name`).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当您在客户端显示此关系时，您想使用`Owner`中的哪个字段？** 这个问题询问在显示或添加`Car`数据时，是否应该显示`Owner`实体的列名。内部上，JHipster始终使用ID列来设置表之间的关系。将`name`作为此问题的答案，因为`Owner`只有一个列（`name`）。'
- en: '**Do you want to add any validation rules to this relationship?** This basically
    adds validation to the foreign key column.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想为此关系添加任何验证规则吗？** 这基本上是对外键列添加验证。'
- en: '**Which validation rules do you want to add?** The possible validation is required.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您想添加哪些验证规则？** 必须进行可能的验证。'
- en: After this, it will start to ask questions from the step 6\. Complete it till
    step 9 to add the `Car` entity. At this moment, we have two entities—`Owner` and
    `Car`—with a relation between them, along with the source code of the frontend,
    controller, and service layers, and the DAO layer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，它将开始从第6步提问。完成第9步以添加`Car`实体。此时，我们有两个实体——`Owner`和`Car`——它们之间存在关系，以及前端、控制器、服务层和DAO层的源代码。
- en: Now, it is time to build our application. The `**mvnw**` Maven command will
    not only build the application, but will deploy and run it on the embedded server.
    After generating the entities, when we build and deploy the application with this
    command, JHipster will create/update the database table corresponding to each
    entity.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建我们的应用程序了。`**mvnw**` Maven命令不仅会构建应用程序，还会在嵌入式服务器上部署和运行它。在生成实体后，当我们使用此命令构建和部署应用程序时，JHipster将为每个实体创建/更新相应的数据库表。
- en: Before building the application, make sure that you set the database credentials
    as per your local MySQL configuration in the `application-prod.yml` file, in the `src/main/resources/config`
    folder. The names of the properties are `spring:datasource:username` and `spring:datasource:password`*.*
    In the absence of this, you will get an error while running the application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序之前，请确保您已在`application-prod.yml`文件中设置数据库凭据，位于`src/main/resources/config`文件夹中，按照您本地的MySQL配置。属性名称为`spring:datasource:username`和`spring:datasource:password`*.*
    如果没有这些设置，运行应用程序时将会出现错误。
- en: Let's add some data for our entities. Log in with admin credentials (`admin`/`admin`),
    and go to Entities | Owner to add the owner data first. The Create a new Owner
    button will be used to insert an owner record. Similarly, we can add data for
    the `Car` entity. Since we have created a many-to-one relationship from `Car` to `Owner`
    (that is, many `Car` instances are associated with one `Owner`), you will see
    a field where you can select an `Owner` value while adding a `Car` entity.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的实体添加一些数据。使用管理员凭据（`admin`/`admin`）登录，然后转到实体 | 拥有者，首先添加拥有者数据。将使用创建新拥有者按钮来插入拥有者记录。同样，我们也可以为
    `Car` 实体添加数据。由于我们已经从 `Car` 到 `Owner` 创建了一个多对一的关系（即许多 `Car` 实例与一个 `Owner` 相关联），你将看到一个字段，可以在添加
    `Car` 实体时选择 `Owner` 值。
- en: 'The record for the `Car` entity, along with the reference to the `Owner` entity,
    will look as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car` 实体的记录，以及指向 `Owner` 实体的引用，将如下所示：'
- en: '![](img/18d57ab2-fc3e-4c16-93cc-0678886ad8b2.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18d57ab2-fc3e-4c16-93cc-0678886ad8b2.png)'
- en: The value of the `name` attribute of the `Owner` entity is visible as a reference
    here, which we selected when we created the relationship. This page also shows
    pagination of the link type, which we selected during the `Car` entity creation,
    out of the box. Apart from this, you can perform CRUD operations for each individual
    entity without writing a single line of code yourself. This is definitely a cool
    feature that saves lots of development time and effort.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Owner` 实体的 `name` 属性值在此处作为引用可见，这是我们创建关系时选择的。此页面还显示了链接类型的分页，这是我们创建 `Car` 实体时默认选择的。除此之外，你可以为每个单独的实体执行
    CRUD 操作，而无需自己编写任何代码。这绝对是一个节省大量开发时间和精力的酷特性。'
- en: By default, JHipster creates an ID column as the primary key for each entity
    table. Defining a custom column as primary key is not supported out of the box
    for the autogeneration of code. However, if the specific column is required as
    the primary key, you will need to modify the generated source code before running
    it with the `mvnw` command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JHipster 为每个实体表创建一个 ID 列作为主键。对于代码自动生成，不支持将自定义列定义为主键。然而，如果特定的列需要作为主键，你需要在运行
    `mvnw` 命令之前修改生成的源代码。
- en: Modeling the entity
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体建模
- en: You have seen how JHipster speeds up development by automating many things.
    Modeling an entity in an application previously required many activities including
    table generation; the creation of the DAO, services, and a presentation layer;
    and validations and a user interface for each individual entity.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 JHipster 如何通过自动化许多事情来加速开发。在应用程序中建模一个实体以前需要许多活动，包括表生成；创建 DAO、服务和表示层；以及每个实体的验证和用户界面。
- en: Although Spring Boot provides great help in terms of writing boilerplate code,
    the developer still has to write a lot of code to see something happening. This
    is a quite tedious and logically repetitive job. You have seen how JHipster greatly
    helps in this scenario, by providing autogenerating code to build a fully functional
    Spring Boot application without writing a single line of code yourself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Spring Boot 在编写样板代码方面提供了很大的帮助，但开发者仍然需要编写大量代码才能看到一些效果。这是一项相当繁琐且逻辑上重复的工作。你已经看到了
    JHipster 如何在这个场景中提供帮助，通过自动生成代码来构建一个完全功能的 Spring Boot 应用程序，而无需你自己编写任何代码。
- en: Designing an entity with complete working code is just a matter of providing
    certain information to JHipster. At first glance, this looks great, but there
    is another side to the coin. Think about a scenario wherein you need to incorporate
    more than five dozen entities with the JHipster CLI, which is quite possible when
    you write an enterprise application. Sometimes, the total entities reach beyond
    a hundred.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整工作代码设计实体只是向 JHipster 提供某些信息的问题。乍一看，这似乎很棒，但硬币的另一面也有问题。考虑一下这样一个场景，你需要使用 JHipster
    CLI 集成超过五六十个实体，这在编写企业应用程序时是完全可能的。有时，实体的总数会超过一百个。
- en: 'In this scenario, writing each entity with the CLI and providing all metadata,
    along with relationships with other entities, is painful. As a workaround, JHipster
    provides a graphical tool, where we can design all of the entities in one go.
    The aim is to simplify the process of defining a relationship with the visual
    tool, rather than doing it the classical way, with questions and answers. There
    are two options to visually model the entities, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 CLI 编写每个实体并提供所有元数据，以及与其他实体的关系，是痛苦的。作为解决方案，JHipster 提供了一个图形工具，我们可以一次性设计所有实体。目的是通过可视化工具简化定义关系的流程，而不是通过经典的方式，即问答。有两种选项可以用于可视化建模实体，如下所示：
- en: Modeling with **Unified Modeling Language** (**UML**)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **统一建模语言**（**UML**）进行建模
- en: Modeling with JDL
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDL 进行建模
- en: Modeling with UML
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UML 进行建模
- en: 'In this option, we need to design all of the entities as a class diagram, and
    then import it into JHipster to generate the code for all of them in one go. So,
    the whole process is divided into two parts that work independently, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此选项中，我们需要将所有实体设计为类图，然后将其导入 JHipster 以一次性生成所有实体的代码。因此，整个过程分为两个独立工作的部分，如下所示：
- en: Designing a class diagram of entities with a visual tool
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可视化工具设计实体的类图
- en: Exporting the class diagram and importing it into JHipster
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出类图并将其导入 JHipster
- en: During the early phase of application development, the class diagram is mainly
    used to design domain models. Showing the attributes and operations of a class,
    along with its relationship with other classes, the class diagram describes a
    static view of an application. The classes used in the class diagram are directly
    mapped to the object-oriented language, and are also used to model the database
    tables.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发的早期阶段，类图主要用于设计领域模型。通过展示类的属性和操作，以及与其他类的关系，类图描述了应用程序的静态视图。类图中所用的类直接映射到面向对象的语言，并用于建模数据库表。
- en: 'JHipster has provided the benefit of this process in the generation of application
    code. A separate tool, called JHipster UML, has been designed; it reads the class
    diagram to generate the entity structure. It can be installed from the Git repository,
    or as a separate `npm` package, with the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 在生成应用程序代码的过程中提供了这一过程的便利。已经设计了一个名为 JHipster UML 的独立工具；它读取类图以生成实体结构。可以从
    Git 仓库安装，或作为单独的 `npm` 包，以下命令：
- en: '[PRE4]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Most of the tools that are available today allow for exporting the class diagram
    into an XMI format. JHipster UML reads XMI files and generates entities. Since
    this tool generates entities in JHipster from class diagrams, the attribute type
    selection is limited to the list of JHipster-supported types. The list of JHipster-supported
    attribute types, along with possible validation rules for each attribute type,
    is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数今天可用的工具都允许将类图导出为 XMI 格式。JHipster UML 读取 XMI 文件并生成实体。由于此工具从类图中生成 JHipster
    的实体，因此属性类型的选择仅限于 JHipster 支持的类型列表。以下列出了 JHipster 支持的属性类型，以及每个属性类型的可能验证规则：
- en: '| **No.** | **Attribute type** | **Possible validations** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **No.** | **Attribute type** | **Possible validations** |'
- en: '| 1 | `string` | `required`, `minlength`, `maxlength`, `pattern` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `string` | `required`, `minlength`, `maxlength`, `pattern` |'
- en: '| 2 | `integer` | `required`, `min`, `max` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `integer` | `required`, `min`, `max` |'
- en: '| 3 | `long` | `required`, `min`, `max` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `long` | `required`, `min`, `max` |'
- en: '| 4 | `BigDecimal` | `required`, `min`, `max` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `BigDecimal` | `required`, `min`, `max` |'
- en: '| 5 | `float` | `required`, `min`, `max` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `float` | `required`, `min`, `max` |'
- en: '| 6 | `double` | `required`, `min`, `max` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `double` | `required`, `min`, `max` |'
- en: '| 7 | `enum` | `required` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `enum` | `required` |'
- en: '| 8 | `Boolean` | `required` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `Boolean` | `required` |'
- en: '| 9 | `LocalDate` | `required` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 9 | `LocalDate` | `required` |'
- en: '| 10 | `ZonedDateTime` | `required` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `ZonedDateTime` | `required` |'
- en: '| 11 | `blob` | `required`, `minbytes`, `maxbytes` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `blob` | `required`, `minbytes`, `maxbytes` |'
- en: '| 12 | `AnyBlob` | `required`, `minbytes`, `maxbytes` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `AnyBlob` | `required`, `minbytes`, `maxbytes` |'
- en: '| 13 | `ImageBlob` | `required`, `minbytes`, `maxbytes` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `ImageBlob` | `required`, `minbytes`, `maxbytes` |'
- en: '| 14 | `TextBlob` | `required`, `minbytes`, `maxbytes` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 14 | `TextBlob` | `required`, `minbytes`, `maxbytes` |'
- en: 'First, we need to design the class diagram for each domain model, along with
    the relationships between them. JHipster recommends using the following tools
    to generate a class diagram:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为每个领域模型设计类图，以及它们之间的关系。JHipster 推荐使用以下工具生成类图：
- en: Modelio
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Modelio
- en: UML Designer
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UML Designer
- en: GenMyModel
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GenMyModel
- en: 'Out of these, the first two are completely open source, Eclipse-based graphical
    tools, and can be downloaded from their respective sites, while the third is a
    browser-based free tool and can be used directly on the web (with certain limitations).
    Once the class diagram is ready, export it to an XMI file and execute the following
    command in Command Prompt to generate the entity structure. Make sure that you
    are at the project directory when you execute this command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些工具中，前两个是完全开源的基于Eclipse的图形工具，可以从各自的网站下载，而第三个是基于浏览器的免费工具，可以直接在网络上使用（存在某些限制）。一旦类图准备就绪，将其导出为XMI文件，然后在命令提示符中执行以下命令以生成实体结构。确保在执行此命令时位于项目目录中：
- en: '[PRE5]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will generate the entity structure. JHipster UML also provides various
    options to specify the pagination pattern, such as whether you want to use DTO
    or add service classes for each of your entities. It can be given along with the
    previous command, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成实体结构。JHipster UML还提供了各种选项来指定分页模式，例如是否要使用DTO或为每个实体添加服务类。这些选项可以与之前的命令一起使用，如下所示：
- en: '[PRE6]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Based on the options that you have provided, JHipster UML generates entities
    and other source code. Finally, you need to execute the `mvnw` command, so that
    it will create/modify the required entity tables in the database, along with the
    Liquibase changelog file, and deploy the application to the server. While defining
    the relationships between the classes in a class diagram, you need to make sure
    that they are allowed in JHipster. The supported relationships are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你提供的选项，JHipster UML生成实体和其他源代码。最后，你需要执行`mvnw`命令，这样它就会在数据库中创建/修改所需的实体表，以及Liquibase变更日志文件，并将应用程序部署到服务器。在定义类图中的类之间的关系时，你需要确保它们在JHipster中是被允许的。支持的关系如下：
- en: A bidirectional one-to-many relationship
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向一对多关系
- en: A unidirectional many-to-one relationship
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向多对一关系
- en: A many-to-many relationship
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多关系
- en: A bidirectional one-to-one relationship
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向一对一关系
- en: A unidirectional one-to-one relationship
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向一对一关系
- en: Out of the box, a unidirectional one-to-many relationship is not supported by
    the JHipster code generator. JHipster recommends using a bidirectional one-to-many
    relationship instead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JHipster代码生成器不支持单向一对多关系。JHipster建议使用双向一对多关系。
- en: Modeling with JHipster Domain Language studio
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JHipster领域语言（JDL）建模
- en: Designing the domain models as a class diagram and then generating the source
    code based on that is a pretty quick way to create entities in JHipster. Consequently,
    it saves time, compared to creating them one by one with the CLI. However, you
    still need to rely on third-party applications to work with JHipster. There is
    the chance that JHipster has very limited support for a specific version, or,
    in the worst case, is totally incompatible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将领域模型设计为类图，然后基于该图生成源代码是JHipster中创建实体的一种快速方法。因此，与逐个使用CLI创建它们相比，它可以节省时间。然而，你仍然需要依赖第三方应用程序来使用JHipster。有可能JHipster对特定版本的支持非常有限，或者，在最坏的情况下，完全不兼容。
- en: As a solution, JHipster provides a separate tool, called **JDL studio**. It
    is an online tool to create entities and build relationships between them. The
    clear benefit of using JDL studio is that it has been designed and maintained
    by the JHipster team, so there is almost no chance of version incompatibility
    and other issues. You can be confident when using the stable version. In case
    of any issues, you can easily get updates or support from the official JHipster
    issue tracker.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决方案，JHipster提供了一个名为**JDL studio**的独立工具。它是一个在线工具，用于创建实体并在它们之间建立关系。使用JDL studio的明显优势是它由JHipster团队设计和维护，因此几乎不存在版本不兼容和其他问题。你可以使用稳定版本时充满信心。如果出现任何问题，你可以轻松地从官方JHipster问题跟踪器获取更新或支持。
- en: Creating entities with JDL studio is even more simple than modeling the entities
    with UML. **JHipster Domain Language** (**JDL**), it is a domain language that's
    used to construct entities with pretty simple and easy-to-use syntax in a single
    file (or sometimes, multiple files).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JDL studio创建实体比使用UML建模实体更加简单。**JHipster领域语言**（**JDL**）是一种用于在单个文件（有时是多个文件）中构建实体的领域语言，语法简单且易于使用。
- en: There are two ways to work with JDL. You can use either the JHipster IDE or
    the online JDL-Studio ([https://start.jhipster.tech/jdl-studio](https://start.jhipster.tech/jdl-studio)).
    The JHipster IDE is a plugin or extension for well-known IDEs, including Eclipse,
    Visual Studio, and Atom. The online JDL-Studio is a browser-based IDE, with which
    you can construct entities and their relationship in script form, which is written
    in JDL. You can relate it with writing SQL script for creating a database table
    and their relationship.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与JDL一起工作有两种方式。你可以使用JHipster IDE或在线JDL-Studio（[https://start.jhipster.tech/jdl-studio](https://start.jhipster.tech/jdl-studio)）。JHipster
    IDE是针对知名IDE的插件或扩展，包括Eclipse、Visual Studio和Atom。在线JDL-Studio是一个基于浏览器的IDE，你可以用它以脚本形式构建实体及其关系，这些脚本是用JDL编写的。你可以将其与编写创建数据库表及其关系的SQL脚本联系起来。
- en: For sake of simplicity, we will look at a simple example of creating an entity
    with the online JDL-Studio. While writing a definition for each entity, JDL-Studio
    draws the entity diagram with their relationships side by side. When opening the
    online JDL-Studio, you will see some sample entities, along with their relationships
    and other parameters, by default, to give you some ideas on how to start working
    with it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将通过在线JDL-Studio创建实体的简单示例。在为每个实体编写定义时，JDL-Studio会同时绘制实体图及其关系。当打开在线JDL-Studio时，你将默认看到一些示例实体，包括它们的关系和其他参数，以给你一些如何开始使用它的想法。
- en: 'Let''s create `School` and `Teacher` entities, along with their relationship
    (one-to-many), in the online JDL-Studio. Open the URL and add the definition of
    these entities, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在在线JDL-Studio中创建`School`和`Teacher`实体，以及它们之间的关系（一对一）。打开URL并添加这些实体的定义，如下所示：
- en: '[PRE7]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each entity can be defined with the `entity` keyword, along with its attributes
    and data type. We can also define certain validations on each attribute. These
    validations not only impose the respective constraints at the database table level,
    but also at the frontend side. The `maxlength` validation denotes the maximum
    column length of the given attribute. The `min` and `max` validations describe
    the minimum and maximum values to be entered. The relationship between the entities
    can be defined with the following syntax:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体都可以用`entity`关键字定义，包括其属性和数据类型。我们还可以为每个属性定义某些验证。这些验证不仅对数据库表级别施加相应的约束，而且在前端侧也施加约束。`maxlength`验证表示给定属性的列最大长度。`min`和`max`验证描述了要输入的最小和最大值。实体之间的关系可以用以下语法定义：
- en: '[PRE8]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `relationship` can be used with various options, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`relationship`可以使用以下选项进行使用：'
- en: '`(OneToMany | ManyToOne | OneToOne | ManyToMany)`: The possible types of relationship.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(一对一 | 多对一 | 一对一 | 多对多)`: 关系的可能类型。'
- en: '`OWNER entity`: The owner entity of the relationship. It can also be described
    as the source of the relationship. The owning side entity must be on the left
    side.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OWNER 实体`: 关系的拥有者实体。也可以将其描述为关系的来源。拥有方实体必须在左侧。'
- en: '`DESTINATION entity`: This is the other-side entity where the relationship
    ends, the destination.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DESTINATION 实体`: 这是关系结束的另一端实体，即目标实体。'
- en: '`Relationship name`: This is the name of the field that represents the other-side
    type.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`关系名称`: 这是表示另一端类型的字段名称。'
- en: '`Display field`: While adding records for the entity, JHipster shows an other-side
    entity drop-down menu on the screen. This attribute shows the field name of the
    other-side entity that would be displayed in the drop-down menu. By default, it
    is the ID (primary key) of the other-side entity.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`显示字段`: 在为实体添加记录时，JHipster会在屏幕上显示另一端实体下拉菜单。此属性显示将在下拉菜单中显示的另一端实体的字段名。默认情况下，它是另一端实体的ID（主键）。'
- en: '`required`: This determines whether the other-side entity is required to be
    selected in the drop-down menu.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`: 这确定是否必须在下拉菜单中选择另一端实体。'
- en: 'The `paginate`, `dto`, and `service` keywords are used to define the configuration
    options for the pagination pattern, whether DTO needs to be generated, and whether a
    service layer with the implementation should be generated, respectively. They
    are quite straightforward and you can relate it to the respective options while
    creating the entity with the CLI. JHipster also supports mass (with `*`) and exclude
    options (with the `except` keyword), which are quite powerful and convenient.
    In short, various entity sub-generator features, like the field type, validations,
    relationships, DTOs, services, enumeration, and so on, are supported. JDL-Studio
    generates a diagram based on the definition of our entities, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`paginate`、`dto`和`service`关键字分别用于定义分页模式的配置选项、是否需要生成DTO以及是否需要生成带有实现的服务层。它们相当直观，你可以在使用CLI创建实体时将其与相应的选项联系起来。JHipster还支持使用`*`进行大量操作和排除选项（使用`except`关键字），这些功能非常强大且方便。简而言之，JDL-Studio根据我们实体的定义生成以下图表：'
- en: '![](img/33f9fd8b-cf14-4061-85c7-5bfc4034b784.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33f9fd8b-cf14-4061-85c7-5bfc4034b784.png)'
- en: 'In this example, we have defined a bidirectional relationship. If a unidirectional
    relationship is required, you just need to remove the name or relationship on
    both sides. For example, the unidirectional relationship between the `School`
    and `Teacher` entities can be defined as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个双向关系。如果需要单向关系，你只需在两边删除名称或关系即可。例如，`School`和`Teacher`实体之间的单向关系可以定义如下：
- en: '[PRE9]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JHipster does not support a unidirectional, one-to-many relationship, but this
    is what it looks like. While defining the relationship, you need to aware of the
    relationships supported by JHipster, which we discussed in the previous section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster不支持单向的一对多关系，但它的样子是这样的。在定义关系时，你需要意识到JHipster支持的关系，我们已经在上一节中讨论过。
- en: Along with generating the entity code, JDL is also used to create applications
    from scratch, along with the deployment options. So, instead of using the question-and-answer-based
    approach with the CLI, you can define all of the configuration options in a single
    JDL file and create an application in one shot.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成实体代码，JDL还用于从头创建应用程序，包括部署选项。因此，你不必使用基于CLI的问答方法，而可以在单个JDL文件中定义所有配置选项，并一次性创建一个应用程序。
- en: Generating an entity using a model
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型生成实体
- en: 'We have defined the entities in JDL studio. Now, we will instruct JHipster
    to generate entities, along with database tables and source code. This process
    involves the following two tasks:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在JDL studio中定义了实体。现在，我们将指导JHipster生成实体，包括数据库表和源代码。这个过程涉及以下两个任务：
- en: Exporting the entity definitions
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出实体定义
- en: Importing a JDL file to generate the required artifacts
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入JDL文件以生成所需的工件
- en: 'From JDL-Studio, you can export the definitions as a JDL (`.jh`) file. JHipster
    provides a sub-generator that will be used to import the JDL file, with the following
    command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDL-Studio，你可以将定义导出为JDL（`.jh`）文件。JHipster提供了一个子生成器，用于导入JDL文件，以下命令：
- en: '[PRE10]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Needless to say, you need to execute this command under the JHipster project
    directory. Upon successful build and deployment, you will see the `School` and
    `Teacher` entities from the Entities menu. You can also verify that the respective
    tables are generated. If an application has a large number of entities, it is
    quite difficult to put all of them in a single JDL file. If there is an error
    in one entity, the entire process of generating entities will not work properly.
    In the worst case, if multiple teams are working, then it will create maintenance
    problems.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，你需要在这个命令下执行此命令。在成功构建和部署后，你将在“实体”菜单中看到`School`和`Teacher`实体。你也可以验证相应的表是否已生成。如果一个应用程序有大量实体，将它们全部放入单个JDL文件中是非常困难的。如果某个实体出现错误，整个生成实体的过程将无法正常工作。在最坏的情况下，如果多个团队正在工作，那么它将创建维护问题。
- en: JHipster has addressed this issue by allowing multiple JDL files, so that related
    entities can be grouped into individual JDL files. The `import-jdl` sub-generator
    allows importing multiple files separated by spaces. Upon executing this command
    for the first time, it will generate entities and all of the source code. You
    need to build and deploy the application with the `mvnw` command so that the necessary
    database changes will be reflected.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster通过允许使用多个JDL文件来解决此问题，以便相关实体可以分组到单独的JDL文件中。`import-jdl`子生成器允许导入由空格分隔的多个文件。在首次执行此命令时，它将生成实体和所有源代码。您需要使用`mvnw`命令构建和部署应用程序，以便必要的数据库更改得到反映。
- en: 'Second and subsequently, `import-jdl` will only regenerate the entities that
    have changed. If you wish to generate all of the entities from scratch again,
    you will need to add the `- force` option. Please be aware that this option will
    erase all customization applied to the entities. Certain validations are caught
    at the time that we build and deploy the application with the `mvnw` command,
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次及以后，`import-jdl`将仅重新生成已更改的实体。如果您希望从头开始重新生成所有实体，则需要添加`- force`选项。请注意，此选项将删除应用于实体的所有自定义。在构建和部署应用程序时，某些验证会在使用`mvnw`命令时捕获，如下所示：
- en: The `maxlength` and `minlength` validations are not allowed on columns of type
    `integer`, `long`, `BigDecimal`, `LocalDate`, `Boolean`, `enum`, `double`, and
    so on.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列类型为`integer`、`long`、`BigDecimal`、`LocalDate`、`Boolean`、`enum`、`double`等情况下，不允许使用`maxlength`和`minlength`验证。
- en: If the service layer is escaped for a given entity, then JHipster shows a warning
    if the DTO option with `mapstruct` is selected for that entity. In this situation,
    the application may not work properly.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对于某个实体，服务层被跳过，那么如果为该实体选择了带有`mapstruct`的DTO选项，JHipster会显示警告。在这种情况下，应用程序可能无法正常工作。
- en: While adding a single-line comment, you need to put one space after `//`, or
    else JHipster will show errors and the entities will not be generated properly.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加单行注释时，需要在`//`之后留一个空格，否则JHipster会显示错误，并且实体将无法正确生成。
- en: Showing the national gross domestic product
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示国家国内生产总值
- en: Now that you have an idea about how to create an application and model the entities,
    we will start creating an application that shows the GDP of various countries
    with JHipster. We'll do this to showcase the ability to apply customization in
    auto-generated code by JHipster.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建应用程序和建模实体，我们将开始使用JHipster创建一个显示各国GDP的应用程序。我们将这样做以展示JHipster在自动生成的代码中应用自定义的能力。
- en: Application and entity creation
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序和实体创建
- en: Refer to the *Create an Application* section to create a new application, naming
    it `gdp`. We are going to build an application with similar functionality to that
    which we created with Spring Framework in [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml),
    *Creating an Application to List World Countries with their GDP*. To show the
    GDP data of various countries, we took the reference of a sample country, city
    and country language data from MySQL databases ([https://dev.mysql.com/doc/index-other.html](https://dev.mysql.com/doc/index-other.html))
    and used a REST service to fetch the GDP data for a given country through the
    World Bank API ([https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries)).
    We will use the same reference to build an application with JHipster.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*创建应用程序*部分来创建一个新的应用程序，命名为`gdp`。我们将构建一个与我们在[第1章](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml)中创建的应用程序具有相似功能的应用程序，即*使用Spring框架创建一个列出世界各国及其GDP的应用程序*。为了展示如何显示各个国家的GDP数据，我们参考了MySQL数据库中的一个示例国家、城市和国家语言数据([https://dev.mysql.com/doc/index-other.html](https://dev.mysql.com/doc/index-other.html))，并使用REST服务通过世界银行API([https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries](https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries))获取特定国家的GDP数据。我们将使用相同的参考来构建一个使用JHipster的应用程序。
- en: 'To make it simple, we will use columns which are necessary to fulfill the purpose
    of the application. It is important to understand the table structure first. The
    database tables and their relationship details will be as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将使用必要的列来完成应用程序的目的。首先理解表结构非常重要。数据库表及其关系细节如下：
- en: '![](img/bef82c37-c2d0-4ecd-bfdd-2c6bf417b7d9.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bef82c37-c2d0-4ecd-bfdd-2c6bf417b7d9.png)'
- en: 'Let''s define the entities first. JHipster recommends JDL for entity and code
    generation so we will use it to create our entity structure and generate our service
    layer, REST controllers, and DTO, along with a set of components for the frontend
    layer. The JDL script would be as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义实体。JHipster推荐使用JDL进行实体和代码生成，因此我们将使用它来创建我们的实体结构并生成我们的服务层、REST控制器和DTO，以及前端层的一组组件。JDL脚本如下所示：
- en: '[PRE11]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This script contains the entity definition for respective tables, along with
    `enum` for `Continent` and `TrueFalse`. We also defined a pagination pattern,
    DTO structure, and service layer with the `Service` class and interface (`serviceImpl`),
    along with a type of relationship. The `Country` will have one-to-many relationships
    with both `City` and `CountryLanguage`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本包含相应表的实体定义，以及用于`Continent`和`TrueFalse`的`enum`。我们还定义了分页模式、DTO结构、服务层（使用`Service`类和接口`serviceImpl`），以及一种关系类型。`Country`将与`City`和`CountryLanguage`都有一对多关系。
- en: 'The `country(name)` in the relationship, on the other side it will show the
    country name as a reference, instead of the default `ID` of the country. Give
    special attention to the last option—`filter`. This declares the `filter` option
    for the `Country` entity, which is used to apply various filtering criteria while
    fetching records for the entity. We will explore this in more detail in the *Developing
    custom screens* section. The JDL diagram should look as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系中的`country(name)`，在另一边它将显示国家名称作为参考，而不是国家默认的`ID`。请特别注意最后一个选项——`filter`。这为`Country`实体声明了`filter`选项，用于在检索实体的记录时应用各种过滤条件。我们将在*开发自定义屏幕*部分更详细地探讨这一点。JDL图应如下所示：
- en: '![](img/e0bc985b-b705-49ba-80c6-8600ee143d69.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0bc985b-b705-49ba-80c6-8600ee143d69.png)'
- en: Since we have omitted a few columns in each table provided by MySQL, the required
    changes also need to be made in the respective insert script of these tables.
    You will find the modified insert script in the `download` folder of the project
    structure. At this moment, you have to apply the insert script before moving further.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在MySQL提供的每个表中省略了一些列，因此还需要在相应表的插入脚本中进行必要的更改。你将在项目结构的`download`文件夹中找到修改后的插入脚本。在此时刻，你必须应用插入脚本才能继续前进。
- en: Handling enumeration data with a database in JHipster
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JHipster中使用数据库处理枚举数据
- en: 'Next, we''ll run the application and verify that JHipster has created three
    entities and that they are available in the Entities menu to perform various CRUD
    operations. The first time we run the application, we will get an error, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行应用程序并验证JHipster是否已创建三个实体，并且它们在实体菜单中可用以执行各种CRUD操作。第一次运行应用程序时，我们将得到一个错误，如下所示：
- en: '[PRE12]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This error occurs while fetching continent data and trying to map it with the `Continent`
    enum data type.  The root cause is that we have defined the type of the `continent`
    column of the `Country` entity as a `Continent` enum. The actual value in that
    column, which is added through an insert script (from the MySQL site) is not exactly
    the same as the `Continent` enum values.  For example, the actual value in the
    database is `Asia`, while the corresponding enum is `ASIA`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误发生在检索大陆数据并尝试将其与`Continent`枚举数据类型映射时。根本原因是我们在`Country`实体的`continent`列中定义了类型为`Continent`枚举。通过插入脚本（从MySQL网站）添加的该列的实际值与`Continent`枚举值并不完全相同。例如，数据库中的实际值是`Asia`，而相应的枚举是`ASIA`。
- en: Another value of the `continent` column is `North America`, while the corresponding
    enum is `NORTH_AMERICA`. Because of the limitations of enum in Java, we can't
    put a space in the middle of the value, and that is the reason we kept the values
    as `NORTH_AMERICA`, `SOUTH_AMERICA`, and so on. Because of this limitation, along
    with the case difference, you will get the previous exception while running the
    application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`continent`列的另一个值是`North America`，而相应的枚举是`NORTH_AMERICA`。由于Java中枚举的限制，我们无法在值中间放置空格，这就是我们保持值为`NORTH_AMERICA`、`SOUTH_AMERICA`等等的原因。由于这种限制，加上大小写差异，你将在运行应用程序时得到之前的异常。'
- en: 'As a workaround, we need to provide some sort of mapping of actual values in
    the database column, to enum values in Java. For this, we will use the JPA attribute
    converter mechanism. It is basically used to define a method to convert database
    values to Java representations of an attribute and vice versa. Open the `Country.java`
    class at the `com.nilangpatel.domain` package and update the annotation declaration
    for the `continent` attribute as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种解决方案，我们需要提供数据库列中实际值到Java枚举值的某种映射。为此，我们将使用JPA属性转换器机制。它基本上用于定义一个方法来将数据库值转换为属性在Java中的表示，反之亦然。打开位于`com.nilangpatel.domain`包下的`Country.java`类，并更新`continent`属性的注解声明如下：
- en: '[PRE13]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Originally, it was defined as `@Enumerated(EnumType.STRING)`, which was commented
    out with an added `@Convert` annotation. This annotation requires implementation
    of the `javax.persistence.AttributeConverter` interface. The implementation is
    provided by the `ContinentEnumConvertor` custom class as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，它被定义为`@Enumerated(EnumType.STRING)`，并添加了注释的`@Convert`注解。这个注解需要实现`javax.persistence.AttributeConverter`接口。实现由`ContinentEnumConvertor`自定义类提供，如下所示：
- en: '[PRE14]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These two methods will convert the values between the database and the corresponding
    enum value in Java. We also need to do necessary changes in the `Continent` enum
    class, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法将在数据库和Java中相应的枚举值之间转换值。我们还需要在`Continent`枚举类中进行必要的更改，如下所示：
- en: '[PRE15]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the application, and you will see the entities and JHipster allows to perform
    CRUD operation to only logged in user. However you will still see that the continent
    values are rendered as enum values, such as `ASIA`, `NORTH_AMERICA`, and so on, instead
    of the actual database column values.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你会看到实体，JHipster允许对仅登录用户执行CRUD操作。然而，你仍然会看到大陆值被渲染为枚举值，例如`ASIA`、`NORTH_AMERICA`等等，而不是实际的数据库列值。
- en: The reason for this is that, when enabling internationalization support at the
    time of application creation, JHipster generates the display value for various
    labels, error messages, and various enumerations. It nicely creates the key-value
    pair in a separate file for each artifact. These files are generated for each
    language-specific folder, under the `src/main/webapp/i18n` folder. For example,
    the language keys and their value for the `Country` entity are created in the `src/main/webapp/i18n/en/country.json`
    file.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，在创建应用程序时启用国际化支持，JHipster会为各种标签、错误消息和各种枚举生成显示值。它很好地为每个工件创建了一个单独的键值对文件。这些文件为每个特定语言的文件夹生成，位于`src/main/webapp/i18n`文件夹下。例如，`Country`实体的语言键及其值在`src/main/webapp/i18n/en/country.json`文件中创建。
- en: 'Since our application only has one language, `English`, the language keys are
    only generated for the `English` language, under the `en` folder, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序只有一种语言，即`English`，因此语言键仅在`en`文件夹下为`English`语言生成，如下所示：
- en: '![](img/c191091e-0820-4a1f-8179-e321890ce937.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c191091e-0820-4a1f-8179-e321890ce937.png)'
- en: 'The keys and values are created in a JSON format. To understand its structure,
    open the `country.json` file, which looks as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 键和值以JSON格式创建。要了解其结构，请打开`country.json`文件，其外观如下：
- en: '[PRE16]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The title is accessible with the `gdpApp.country.home.title` key. This will
    be used in the HTML template. Open the `country.component.html` file under the `/src/main/webapp/app/entities/country`
    folder, and you will see the following code to use this key:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 标题可以通过`gdpApp.country.home.title`键访问。这将在HTML模板中使用。打开位于`/src/main/webapp/app/entities/country`文件夹下的`country.component.html`文件，你会看到以下代码来使用这个键：
- en: '[PRE17]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: JHipster has created various modules to support validations, enums, reading
    and parsing JSON, and so on. One of them, `translation`, supports internationalization.
    These are installed during JHipster installation as a `jhipster-core` package,
    under the `node_modules` folder created under the project directory. If you need
    to add further labels, you can place the key in the respective JSON file and use
    `jhiTranslate` to render the value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster已创建各种模块以支持验证、枚举、读取和解析JSON等。其中之一是`translation`，它支持国际化。这些模块在JHipster安装期间作为`jhipster-core`包安装，位于项目目录下创建的`node_modules`文件夹中。如果你需要添加更多标签，可以将键放在相应的JSON文件中，并使用`jhiTranslate`来渲染值。
- en: 'Now, back to our problem of showing the enum values on the screen for the `Country`
    entity, instead of the actual database value. This happens because the translation
    in `continent.json` is generated with an enum value, by default. You can change
    it as follows in order to show correct continent values on the screen:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们显示`Country`实体屏幕上的枚举值而不是实际数据库值的问题。这是因为`continent.json`中的翻译默认使用枚举值生成。您可以通过以下方式更改它，以便在屏幕上显示正确的洲际值：
- en: '[PRE18]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Everything should work as expected now. The admin is able to see all three entities,
    and can perform CRUD operations properly. We will now develop custom screens to
    show the GDP data by country.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切应该按预期工作。管理员能够看到所有三个实体，并且可以正确地执行CRUD操作。我们现在将开发自定义屏幕，以按国家显示GDP数据。
- en: Filter provision in service, persistence, and the REST controller layer
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务、持久化和REST控制器层中的过滤器提供
- en: Let's recall that, while creating the entities with JDL, we set the filter option
    for the `Country` entity in the JDL script, at the end. Let's look at how this
    makes a difference to the service, persistence, and REST controller layers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下，在用JDL创建实体时，我们在JDL脚本的最后设置了`Country`实体的过滤器选项。让我们看看这如何影响服务、持久化和REST控制器层。
- en: The persistence layer
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化层
- en: 'When we add a filter option for any entity, JHipster makes the necessary changes
    to the repository interface corresponding to that entity. In our case, the `CountryRepository` is
    now extending the `JpaSpecificationExecutor` interface, which is used to add `Specification`
    capabilities to the repository, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为任何实体添加过滤器选项时，JHipster会对相应实体的存储库接口进行必要的更改。在我们的例子中，`CountryRepository`现在扩展了`JpaSpecificationExecutor`接口，该接口用于向存储库添加`Specification`功能，如下所示：
- en: '[PRE19]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Spring Data JPA provides a `Specification` interface to execute the criteria
    query, which is used to retrieve values from the database with various criteria
    on database columns.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA提供了一个`Specification`接口来执行条件查询，该查询用于根据数据库列上的各种条件从数据库中检索值。
- en: The service layer
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务层
- en: 'In the service layer, JHipster generates a separate class as `xxxQueryService`,
    under the service package. For the `Country` entity, a new service class, `CountryQueryService`,
    is created. The purpose of this class is to retrieve the data with the filtering
    criteria, so it contains only fetch methods, which look as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务层，JHipster在服务包下生成一个名为`xxxQueryService`的单独类。对于`Country`实体，创建了一个新的服务类`CountryQueryService`。这个类的作用是检索具有过滤标准的数据，因此它只包含获取方法，如下所示：
- en: '[PRE20]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: JHipster generates a **Plain Old Java Object** (**POJO**) class for each entity
    that is declared with the filter option. This is used to pass the filter values
    from the frontend to the service layer. In our case, JHipster generates a `CountryCriteria`
    class that serves this purpose for the `Country` entity. This class contains various
    filters for each corresponding field in the domain object. If filters are not
    applied, this will bring all of the entities.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster为每个使用过滤器选项声明的实体生成一个**普通Java对象**（**POJO**）类。这用于将前端传递的过滤器值从服务层传递。在我们的例子中，JHipster生成了一个`CountryCriteria`类，为`Country`实体服务此目的。这个类包含域对象中每个相应字段的过滤器。如果没有应用过滤器，这将检索所有实体。
- en: 'JHipster has created various filter types, corresponding to each wrapper class
    type. For any custom type, it creates an inner class that extends the `io.github.jhipster.service.filter.Filter`
    class. The `CountryCriteria` class looks as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster创建了各种过滤器类型，对应于每个包装类类型。对于任何自定义类型，它创建一个内部类，该类扩展了`io.github.jhipster.service.filter.Filter`类。`CountryCriteria`类如下所示：
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `continent` attribute in the `Country` domain class is of the enum type,
    so JHipster has created an inner filter class of `ContinentFilter`, and for other
    attributes of the type wrapper class, it uses corresponding filters. From the
    frontend, you need to pass search text as a request parameter in a specific way,
    based on the type of the attribute as follows. Consider the attribute name as
    `abc`*:*
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Country`域类中的`continent`属性是枚举类型，因此JHipster创建了一个内部过滤器类`ContinentFilter`，对于其他类型的包装类属性，它使用相应的过滤器。从前端，您需要根据属性类型以特定方式传递搜索文本作为请求参数，如下所示。考虑属性名为`abc`：'
- en: 'If attribute `abc` is of the string type:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性`abc`是字符串类型：
- en: '`abc.contains=<seach_text>`: List down all entities where the value of `abc`
    contains `search_text`.'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.contains=<search_text>`：列出所有`abc`的值包含`search_text`的实体。'
- en: 'If attribute `abc` is of any number type (float, long, double, integer) or
    the date:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性`abc`是任何数字类型（float、long、double、integer）或日期：
- en: '`abc.greaterThan=<search_text>`: List down all entities where the value of `abc`is
    greater than `search_text`.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.greaterThan=<search_text>`：列出所有`abc`的值大于`search_text`的实体。'
- en: '`abc.lessThan=<search_text>`: List down all the entities where the value of
    `abc`is less than `search_text`.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.lessThan=<search_text>`：列出所有`abc`的值小于`search_text`的实体。'
- en: '`abc.greaterOrEqualThan=<search_text>`:List down all the entities where the
    value of `abc`is greater than or equals to `search_text`.'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.greaterOrEqualThan=<search_text>`：列出所有`abc`的值大于或等于`search_text`的实体。'
- en: '`abc.lessOrEqualThan=<search_text>`:List down all the entities where the value
    of `abc`is less than or equal to `search_text`.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.lessOrEqualThan=<search_text>`：列出所有`abc`的值小于或等于`search_text`的实体。'
- en: 'If attribute `abc` is of a custom type:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性`abc`是自定义类型：
- en: '`abc.equals=<search_text>`: List down all of the entities where the value of `abc`
    is exactly similar to `search_text`.'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.equals=<search_text>`：列出所有`abc`的值与`search_text`完全相同的实体。'
- en: '`abc.in=<comma separated search_text values>`: List down all of the entities
    where a value of `abc`is within the list of `search_text`.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.in=<comma separated search_text values>`：列出所有`abc`的值在`search_text`列表中的实体。'
- en: '`abc.specified=true`: List down all of the entities where the value of `abc`is
    not null, which means specified.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.specified=true`：列出所有`abc`的值不为null的实体，这意味着已指定。'
- en: '`abc.specified=false`: List down all entities where the value of `abc`is null,
    which means not specified.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abc.specified=false`：列出所有`abc`的值为null的实体，这意味着未指定。'
- en: These rules can be combined for more than one attributes to form a complex query.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可以组合多个属性以形成复杂查询。
- en: The REST controller layer
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST控制器层
- en: 'When applying the filter option, JHipster also makes necessary changes to the
    REST controller. For example, all `get` methods of REST controller `CountryResouce`
    for entity `Country` are now taking `CountryCriteria` as a parameter to support
    filtering operations, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用过滤器选项时，JHipster也会对REST控制器进行必要的更改。例如，对于实体`Country`的REST控制器`CountryResouce`的所有`get`方法现在都接受`CountryCriteria`作为参数以支持过滤操作，如下所示：
- en: '[PRE22]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is how the filter option impacts the persistence, service, and REST controller
    layer code generation. With single-filter configuration, JHipster makes all of
    the necessary changes. However, the REST controllers generated for each entity
    are protected with Spring Security, by default. You can verify this in the `config()`
    method of the `com.nilangpatel.config.SecurityConfiguration` class, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是过滤器选项如何影响持久层、服务层和REST控制器层代码生成。在单过滤器配置下，JHipster会进行所有必要的更改。然而，默认情况下，为每个实体生成的REST控制器都受到Spring
    Security的保护。您可以在`com.nilangpatel.config.SecurityConfiguration`类的`config()`方法中验证这一点，如下所示：
- en: '[PRE23]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Apart from the register, activate, authenticate, and reset password operations,
    all other URLs (`/api/**`) are restricted to logged-in users. But, in our case,
    we want to show the country GDP data to regular users, without logins. For this,
    we need to create a custom REST controller with a different URL pattern, as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注册、激活、认证和重置密码操作外，所有其他URL（`/api/**`）都限制为登录用户。但是，在我们的情况下，我们希望向普通用户展示国家GDP数据，而不需要登录。为此，我们需要创建一个具有不同URL模式的自定义REST控制器，如下所示：
- en: '[PRE24]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first method is similar to what it has auto-generated in `CountryResource`.
    The second method will be used to show the GDP data, and we will use it while
    creating that screen. The URL pattern map to this controller is `/api/open`. The
    purpose of creating a separate REST controller is to make it accessible without
    a login, by configuring its URL pattern with Spring Security in the `configure`
    method of `SecurityConfiguration`, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法与在`CountryResource`中自动生成的方法类似。第二种方法将用于显示GDP数据，我们将在创建该屏幕时使用它。此控制器的URL模式映射为`/api/open`。创建单独的REST控制器的目的是通过在`SecurityConfiguration`的`configure`方法中配置其URL模式，使其无需登录即可访问，如下所示：
- en: '[PRE25]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This controller is now accessible publicly. We will use the controller methods
    while constructing a frontend layer with Angular in the *Develop custom screens*
    section.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器现在公开可访问。我们将在“*开发自定义屏幕*”部分使用控制器方法构建前端层。
- en: Adding a filter option to existing entities
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向现有实体添加过滤器选项
- en: 'If the entities are already generated without the filter option, and you want
    to add it later on, you will need to perform certain steps. The following are
    two possible approaches:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体已经生成而没有过滤选项，并且你想稍后添加它，你需要执行某些步骤。以下有两种可能的方法：
- en: 'With Command Prompt, do the following:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令提示符，执行以下操作：
- en: Open the entity's JSON file under the `.jhipster` folder, inside of the project
    directory. For example, for a `Country` entity, you will see a file named `Country.json`
    inside of the `.jhipster` folder.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录下的 `.jhipster` 文件夹中打开实体的 JSON 文件。例如，对于一个 `Country` 实体，你将在 `.jhipster` 文件夹中看到一个名为
    `Country.json` 的文件。
- en: If the value of the `service` key is `no`, change it to either `serviceClass`
    or `serviceImpl`*.* The service layer option has to be enabled for the filtering
    option.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `service` 键的值是 `no`，则将其更改为 `serviceClass` 或 `serviceImpl`*.* 服务层选项必须启用才能使用过滤选项。
- en: Change the value of the key `jpaMetamodelFiltering` to `true`.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `jpaMetamodelFiltering` 键的值更改为 `true`。
- en: Regenerate the entity with the `jhipster entity <entity_name>` command.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `jhipster entity <entity_name>` 命令重新生成实体。
- en: 'With JDL, do the following:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JDL，执行以下操作：
- en: Add a line containing `filter <entity_name>`to the JDL script file.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JDL 脚本文件中添加一行，包含 `filter <entity_name>`。
- en: Re-import the definition with the `jhipster jhipster-jdl <jdl_file>` command.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `jhipster jhipster-jdl <jdl_file>` 命令重新导入定义。
- en: In both of these scenarios, the customization will be reverted while regenerating
    the entities, so make a proper back-up before performing this task.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，在重新生成实体时，自定义将重置，因此在执行此任务之前请进行适当的备份。
- en: Developing custom screens
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自定义屏幕
- en: By default, JHipster only shows the entities to logged-in users. The aim of
    our application is to show the GDP data of a given country to the end user. To
    achieve this, the country data must be visible publicly. In other words, it must
    be accessible without a login. To make it more user-friendly, we will design the
    flow in two different screens.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JHipster 只向登录用户显示实体。我们应用程序的目标是向最终用户显示给定国家的 GDP 数据。为了实现这一点，国家数据必须公开可见。换句话说，它必须无需登录即可访问。为了使其更用户友好，我们将设计两个不同的屏幕流程。
- en: The first screen will list all the countries available in the system. Selecting
    any of them will show the actual GDP of that country on the second screen, with
    a graphical presentation. These are the custom screens that we need to develop
    from scratch and plug into the JHipster project structure, which we will do in
    this section.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏幕将列出系统中所有可用的国家。选择任何一个国家将在第二个屏幕上显示该国的实际 GDP，并带有图形展示。这些是我们需要从头开始开发并插入到 JHipster
    项目结构中的自定义屏幕，我们将在本节中这样做。
- en: The search country screen
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索国家屏幕
- en: 'In this screen, we will list of all of the countries available in the system
    with pagination. It is identical to the *Country* entity screen but available
    to all users (without login). For better user experience, we will add filters
    to find a specific country on this screen. It looks as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕中，我们将列出系统中所有可用的国家，并使用分页。它与 `Country` 实体屏幕相同，但对所有用户（无需登录）都可用。为了提供更好的用户体验，我们将在该屏幕上添加过滤器以查找特定的国家。它看起来如下：
- en: '![](img/6bec5ea1-5a09-4947-8ad2-73df7292f760.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bec5ea1-5a09-4947-8ad2-73df7292f760.png)'
- en: This screen has two filters. The first filter will match the search text in
    the country name (`contains` criteria), while the second will compare the selected
    continent (`equals` criteria). These filters help the user to find their desired
    country instantly. To make it simpler, we have added just a few columns of information
    about each country, which seems appropriate for this screen. At the end of each
    country record, the View button will navigate a user to the second screen, where
    it shows the GDP information of that country.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕有两个过滤器。第一个过滤器将匹配国家名称中的搜索文本（`contains` 条件），而第二个将比较选定的洲（`equals` 条件）。这些过滤器帮助用户立即找到他们想要的国。为了使其更简单，我们只添加了关于每个国家的一些信息列，这似乎适合这个屏幕。在每条国家记录的末尾，视图按钮将导航到第二个屏幕，显示该国的
    GDP 信息。
- en: JHipster provides either **Angular** or **React** as an option to develop the
    frontend. We have chosen Angular to create this application. Consequently, all
    of our out-of-the-box screens are generated with the Angular framework. Since
    this is a custom screen, we need to use various Angular artifacts to develop it.
    Create a `gdp` folder inside of the `/src/webapp/app` folder, and, in the next
    subsection, we'll create Angular artifacts inside of it, to construct custom screens.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 提供了 **Angular** 或 **React** 作为开发前端的选择。我们选择了 Angular 来创建这个应用程序。因此，我们所有的开箱即用的屏幕都是使用
    Angular 框架生成的。由于这是一个自定义屏幕，我们需要使用各种 Angular 组件来开发它。在 `/src/webapp/app` 文件夹内创建一个
    `gdp` 文件夹，在下一个子节中，我们将在其中创建 Angular 组件，以构建自定义屏幕。
- en: Creating an Angular service
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Angular 服务
- en: 'Angular is a modular framework wherein we write many components, each for a
    specific purpose. Many times, we are in need of some common functionalities shared
    across multiple components. Additionally, we may need to fetch records from the
    database with a REST call. This is where creating an Angular service makes perfect
    sense. For our GDP application, we need to fetch country data in the Angular service
    as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个模块化框架，在其中我们编写许多组件，每个组件都针对特定的目的。很多时候，我们需要一些在多个组件之间共享的通用功能。此外，我们可能还需要通过
    REST 调用来从数据库中获取记录。这就是创建 Angular 服务完美合理的地方。对于我们的 GDP 应用程序，我们需要在 Angular 服务中按如下方式获取国家数据：
- en: '[PRE26]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `query` method is used to fetch all of the countries with various request
    parameters sent by the `search-country` component. The second method, `find`,
    is used to fetch a specific country, based on a given `id` value. This service
    class uses the `HttpClient` module, which is provided by the Angular framework
    out of the box, to make a REST call to the newly created REST controller.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`query` 方法用于获取所有国家，这些请求参数是由 `search-country` 组件发送的。第二个方法 `find` 用于根据给定的 `id`
    值获取特定的国家。这个服务类使用 Angular 框架提供的 `HttpClient` 模块，以对新建的 REST 控制器进行 REST 调用。'
- en: The `api/open/search-countries` and `api/open/show-gdp` URLs are used to make
    calls to the REST controller methods, `getAllCountriesForGdp()` and `getCountryDetails()`,
    respectively. However, the `find()` method of service component is dynamically passing
    the `id` value into the URL with the `${this.showGDPUrl}/${id}` expression. This
    service class is common for both of the screens.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `api/open/search-countries` 和 `api/open/show-gdp` URL 来调用 REST 控制器的 `getAllCountriesForGdp()`
    和 `getCountryDetails()` 方法。然而，服务组件的 `find()` 方法正动态地将 `id` 值传递到 URL 中，使用 `${this.showGDPUrl}/${id}`
    表达式。这个服务类对两个屏幕都是通用的。
- en: Creating the Angular router
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Angular 路由器
- en: 'The next artifact is the Angular router. The Angular router is used to manage
    application navigation and routing between various components. The Angular router uses
    a browser URL to map it to a specific component. It does various types of processing
    on the browser URL, such as parsing to verify that the URL is valid; doing a redirect
    if that option is given; matching the component against the URL segment; validating
    if the given URL is accessible with the set of guards; running the associate resolves
    to dynamically add the data; and finally, activating the component and performing
    navigation. We will write the Angular router as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件是 Angular 路由器。Angular 路由器用于管理应用程序导航和不同组件之间的路由。Angular 路由器使用浏览器 URL 来将其映射到特定的组件。它对浏览器
    URL 进行各种类型的处理，例如解析以验证 URL 是否有效；如果提供了该选项，则进行重定向；将组件与 URL 段进行匹配；验证给定的 URL 是否可以通过设置的安全卫士访问；运行关联的解析器以动态添加数据；最后，激活组件并执行导航。我们将如下编写
    Angular 路由器：
- en: '[PRE27]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It comprises a `resolve` class (`CountryGDPResolve`) and a route array. The
    `resolve` class fetches the full country model data, based on a country ID when
    a user clicks on View button to initiate a transition to the second screen. It
    uses a service component to make a REST call and fetch country information. The
    router array holds the configuration mapping of components and the URLs by which
    they will be triggered. This Angular router is also common for both screens.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一个 `resolve` 类（`CountryGDPResolve`）和路由数组。当用户点击“查看”按钮以启动到第二个屏幕的转换时，`resolve`
    类根据国家 ID 获取完整的国家模型数据。它使用服务组件进行 REST 调用来获取国家信息。路由数组持有组件和它们将通过哪些 URL 触发的配置映射。这个
    Angular 路由器对两个屏幕都是通用的。
- en: Angular modules
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 模块
- en: 'As we know, Angular is a modular framework. A module in Angular is used to
    group related components, pipes, directives, and services, to form an independent
    unit, which can be combined with other modules to form a complete application.
    A **module** can control which components, services, and other artifacts are hidden
    and visible to other modules, in much the same way that a Java class has public
    and private methods. We will use a single module called `CountryGDPModule`, as
    follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Angular 是一个模块化框架。Angular 中的模块用于将相关的组件、管道、指令和服务分组，形成一个独立的单元，可以与其他模块结合形成一个完整的应用程序。**模块**可以控制哪些组件、服务和其他工件对其他模块是隐藏的还是可见的，这与
    Java 类有公共和私有方法的方式非常相似。我们将使用一个名为 `CountryGDPModule` 的单个模块，如下所示：
- en: '[PRE28]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It defines all of the components and routers that are necessary to be part of
    this module. It is common for both screens.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了构成此模块所需的所有组件和路由器。这对两个屏幕都是常见的。
- en: Creating an Angular component to show the country list
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Angular 组件以显示国家列表
- en: 'Next, we will write a component to show the country list on the first screen.
    A component is a basic building block with which we create our Angular application.
    Every Angular application has at least one component. The component holds application
    data and logic to show the data in the HTML template associated with it. We will
    write a separate component for each of the screens in our application. For the
    first screen, we will write a `search-country` component, as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个组件，在第一个屏幕上显示国家列表。组件是我们创建 Angular 应用程序的基本构建块。每个 Angular 应用程序至少有一个组件。组件包含应用程序数据和逻辑，用于在关联的
    HTML 模板中显示数据。我们将为应用程序中的每个屏幕编写一个单独的组件。对于第一个屏幕，我们将编写一个 `search-country` 组件，如下所示：
- en: '[PRE29]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: An Angular component can be created with the `@component()` decorator. The `SearchCountryComponent`
    class represents the `search-country` component. It is defined with certain variables
    that are used for pagination and filtering purposes. The object of `CountryGDPService` is
    injected into the component class through a constructor, which will be used in
    other methods to fetch country data. The constructor is initialized with pagination
    variables, which are used to handle pagination on the first screen.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `@component()` 装饰器创建一个 Angular 组件。`SearchCountryComponent` 类代表 `search-country`
    组件。它通过某些变量定义，这些变量用于分页和过滤目的。`CountryGDPService` 对象通过构造函数注入到组件类中，将在其他方法中用于获取国家数据。构造函数使用分页变量初始化，这些变量用于处理第一个屏幕上的分页。
- en: Soon after the component class is initialized with the constructor, Angular
    will call the `ngOnInit()` method. In this method, we are initializing a few parameters
    and making a call to other methods with `loadAll()`. This method calls the `query()`
    method of the `countryGDPService` object to fetch the country info.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件类通过构造函数初始化后不久，Angular 将调用 `ngOnInit()` 方法。在这个方法中，我们初始化了一些参数，并通过 `loadAll()`
    调用其他方法。此方法调用 `countryGDPService` 对象的 `query()` 方法以获取国家信息。
- en: The `query()` method takes various pagination and filtering parameters. The
    `page`, `size`, and `sort` are pagination parameters, while `name.contains` and
    `continent.equals` are filtering parameters. They are eventually submitted to
    the REST controller through `CountryGDPService`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()` 方法接受各种分页和过滤参数。`page`、`size` 和 `sort` 是分页参数，而 `name.contains` 和 `continent.equals`
    是过滤参数。它们最终通过 `CountryGDPService` 提交给 REST 控制器。'
- en: The `name.contains` filtering parameter is used to filter the country data,
    based on the `name` attribute. Since it is of the type `String`, we have used
    the `contains` criteria. Similarly, the other filtering parameter, `continent.equals`,
    is used to filter the data for the `continent` attribute. Since it is of the type
    `enum`, we are using the `equals` criteria. This is what we have seen in the *Service
    layer* section, under the *Filter provision in service, persistence, and the REST
    controller layer* subsection.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`name.contains` 过滤参数用于根据 `name` 属性过滤国家数据。由于它是 `String` 类型，我们使用了 `contains`
    条件。同样，另一个过滤参数 `continent.equals` 用于过滤 `continent` 属性的数据。由于它是 `enum` 类型，我们使用了 `equals`
    条件。这就是我们在 *Service 层* 部分下，在 *服务、持久化和 REST 控制器层中的过滤提供* 子部分中看到的内容。'
- en: The other functions, like `searchCountries()`, `trackId()`, `loadPage()`, and
    so on, are called from the HTML template directly associated with the `search-country`
    component. You can see it in the source code of the chapter from GitHub at [https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04](https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数，如`searchCountries()`、`trackId()`、`loadPage()`等，直接从与`search-country`组件关联的HTML模板中调用。您可以在GitHub章节的源代码中看到它，网址为[https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04](https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04)。
- en: Angular template to show the country list
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular模板用于显示国家列表
- en: 'Finally, we need an HTML template to render the country data on the screen.
    Each Angular component has one HTML template associated with a `@Component` decorator.
    For our first screen to show the list of countries, the HTML template looks as
    follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个HTML模板来在屏幕上渲染国家数据。每个Angular组件都与一个`@Component`装饰器关联一个HTML模板。对于我们的第一个屏幕，以显示国家列表，HTML模板如下所示：
- en: '[PRE30]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The HTML `form` is used to render the filtering options, with the country name
    as a text field and the continent as a drop-down menu. After the filter form,
    it shows the countries in a tabular format, with the pagination at the bottom.
    The last column of each row has a View button, which opens the next screen using
    the `/showGDP` URL and passing the `id` of the current country.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: HTML `form`用于渲染过滤选项，国家名称作为文本字段，大陆作为下拉菜单。在过滤表单之后，它以表格格式显示国家，底部有分页。每行的最后一列有一个“查看”按钮，该按钮使用`/showGDP`
    URL打开下一个屏幕，并传递当前国家的`id`。
- en: Showing the GDP screen
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示GDP屏幕
- en: 'This screen shows the basic data of a selected country, along with the GDP
    data, in a graphical representation. We will use the World Bank API to fetch the
    information in a JSON format and supply it to a chart module to render a graph
    of the GDP data. This screen looks as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕以图形表示方式显示所选国家的基本数据和GDP数据。我们将使用世界银行API以JSON格式获取信息，并将其提供给图表模块以渲染GDP数据的图表。此屏幕如下所示：
- en: '![](img/ff24ec52-92a5-4f89-8c02-abab43bf5ecd.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff24ec52-92a5-4f89-8c02-abab43bf5ecd.png)'
- en: This screen uses the same service, router, and module artifacts that we created
    for the first screen, but will use a separate component and HTML template, as
    you will see in the next section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕使用与第一个屏幕相同的service、router和module artifacts，但将使用一个单独的组件和HTML模板，您将在下一节中看到。
- en: An Angular component to show country GDP
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于显示国家GDP的Angular组件
- en: 'The `show-gdp` component takes the country data from the first screen, makes
    a call to the World Bank API, and fetches the data in a JSON format, before finally
    sending it to the chart module to render the graph. This component looks as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`show-gdp`组件从第一个屏幕获取国家数据，调用世界银行API，并以JSON格式获取数据，最后将其发送到图表模块进行渲染。此组件如下所示：'
- en: '[PRE31]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the constructor of this component, we are getting the selected country from
    the Angular router. In the `resolve()` method of the `CountryGDPResolve` class,
    we are fetching the country object from the `ID` parameter in the URL, and this
    object is then available to this component through the router, because we have
    provided a resolve configuration to this component in `countryGDPRoute`, as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件的构造函数中，我们从Angular router获取所选国家。在`CountryGDPResolve`类的`resolve()`方法中，我们从URL中的`ID`参数获取国家对象，然后此对象通过router可用，因为我们已在`countryGDPRoute`中为此组件提供了resolve配置，如下所示：
- en: '[PRE32]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we get the country information, we will make our calls to the World Bank
    API. The URL for this is as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取到国家信息，我们将调用世界银行API。此URL如下所示：
- en: '[http://api.worldbank.org/v2/countries/**IND**/indicators/NY.GDP.MKTP.CD?format=json&per_page=10](http://api.worldbank.org/v2/countries/IND/indicators/NY.GDP.MKTP.CD?format=json&per_page=10).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://api.worldbank.org/v2/countries/**IND**/indicators/NY.GDP.MKTP.CD?format=json&per_page=10](http://api.worldbank.org/v2/countries/IND/indicators/NY.GDP.MKTP.CD?format=json&per_page=10)。'
- en: In this URL, the country code is inserted dynamically, from the country data
    that is given by the router. The `per_page` attribute returns the GDP data for
    that many numbers of years. The preceding example shows the last ten years' worth
    of GDP data for the country India. After getting the JSON data, we are iterating
    and preparing two arrays, `year` and `gdp`, and passing them to the chart module
    to generate a chart on the screen. The chart module can be installed as a node
    module, with the `npm install chart.js` command.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个URL中，国家代码是动态插入的，来自路由器提供的国家数据。`per_page`属性返回这么多年的GDP数据。前面的例子显示了印度国家过去十年的GDP数据。在获取JSON数据后，我们正在迭代并准备两个数组，`year`和`gdp`，并将它们传递给图表模块以在屏幕上生成图表。图表模块可以作为node模块安装，使用`npm
    install chart.js`命令。
- en: Angular template to show country GDP
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular模板显示国家GDP
- en: 'Finally, the template for the `show-gdp` component will render the chart and
    show the country GDP data. The template looks as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`show-gdp`组件的模板将渲染图表并显示国家GDP数据。模板如下所示：
- en: '[PRE33]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It shows a few details about the selected country, followed by a placeholder
    for the chart. The `noDataAvailale` variable is used to show a message, in the
    case that there is no GDP data available for the selected country. It is set in
    the `show-gdp` component while making the World Bank API call.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了所选国家的一些详细信息，然后是一个图表的占位符。`noDataAvailale`变量用于显示消息，在所选国家没有GDP数据的情况下。它在`show-gdp`组件中设置，当调用世界银行API时。
- en: Hooking the GDP module into AppModule
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将GDP模块连接到AppModule
- en: Everything is done now. Our GDP module is ready for execution. The last step
    is to plug it into the JHipster project structure. You have seen that a module
    is comprised of multiple artifacts, such as components, pipes, services, and routers.
    Multiple modules are grouped together to form an application.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已完成。我们的GDP模块已准备好执行。最后一步是将它连接到JHipster项目结构。您已经看到，一个模块由多个工件组成，例如组件、管道、服务和路由器。多个模块组合在一起形成一个应用程序。
- en: Every Angular application has at least one module, known as a root module, and
    it is used to bootstrap the application. Usually, this module is known as `AppModule`,
    by convention. Since the frontend of our application is built on top of Angular,
    there is an `AppModule`. The `app.module.ts` file under the `/src/main/webapp/app`
    folder represents an `AppModule`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular应用程序至少有一个模块，称为根模块，它用于启动应用程序。通常，这个模块被称为`AppModule`，这是惯例。由于我们的应用程序前端是基于Angular构建的，因此存在一个`AppModule`。位于`/src/main/webapp/app`文件夹下的`app.module.ts`文件代表了一个`AppModule`。
- en: 'We need to configure our custom module in `AppModule` to make it in action.
    This can be achieved by adding our module to the `imports` declaration under `@NgModule`,
    in the `app.module.ts` file, as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`AppModule`中配置我们的自定义模块以使其生效。这可以通过在`app.module.ts`文件中的`@NgModule`下的`imports`声明中添加我们的模块来实现，如下所示：
- en: '[PRE34]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Upon adding entities into an application, JHipster generates a common module
    called `XXXEntityModule`, that holds the references of all the artifacts related
    to all entities. Soon after the entities are generated, JHipster adds this module
    entry to the import array inside of `@NgModule`. We have added another entry for
    the GDP module (`CountryGDPModule`). This is how any custom module can be plugged
    into `AppModule`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在将实体添加到应用程序后，JHipster生成一个名为`XXXEntityModule`的通用模块，它包含与所有实体相关的所有工件的引用。在实体生成后不久，JHipster将此模块条目添加到`@NgModule`内部的导入数组中。我们已经为GDP模块（`CountryGDPModule`）添加了另一个条目。这就是任何自定义模块如何连接到`AppModule`的方式。
- en: Updating navigation
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新导航
- en: Our module is ready, and is also plugged into `AppModule`, to put it into action.
    However, one small thing is still missing, which is to locate the navigation to
    launch the GDP module. The best option is to put the navigation link into the
    navigation bar at the top of the page. JHipster provides a navigation bar as a
    separate module out of the box, and it shows various links. A few of them are
    publicly visible, and others are only for logged-in and `Admin` users.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义模块已经准备好，并且已经连接到`AppModule`，以使其生效。然而，还有一个小细节需要处理，那就是定位导航以启动GDP模块。最佳选择是将导航链接放在页面顶部的导航栏中。JHipster提供了一个作为单独模块的导航栏，它显示了各种链接。其中一些是公开可见的，而其他一些则仅供登录和`Admin`用户使用。
- en: 'To add the link, we need to modify the navigation template file, `navbar.component.html`,
    under the `/src/main/webapp/app/layouts/navbar` folder as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加链接，我们需要修改位于`/src/main/webapp/app/layouts/navbar`文件夹下的导航模板文件`navbar.component.html`，如下所示：
- en: '[PRE35]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have added HTML code, highlighted in bold, to show the Countries menu item
    in the navigation bar. This looks as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在导航栏中突出显示的HTML代码中添加了粗体，以显示“国家”菜单项。它看起来如下：
- en: '![](img/bfe81b78-3808-4a2a-8b98-6ec49ceea2f8.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfe81b78-3808-4a2a-8b98-6ec49ceea2f8.png)'
- en: The path for `routerLink` is defined as Countries, which ultimately triggers
    the `t=the search-country` component to show the country list with the filter
    option on the first screen. This is how you can add custom screens in JHipster
    project.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink`的路径定义为“国家”，这最终会触发`t=the search-country`组件在第一个屏幕上显示带有筛选选项的国家列表。这就是你如何在JHipster项目中添加自定义屏幕的方式。'
- en: Other JHipster features
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他JHipster功能
- en: So far, you have seen how to create fully-fledged and production-ready applications
    with JHipster. You have seen how to create entities and define a relationship
    between them. We have also added custom screens and developed various artifacts,
    so that you could learn how to add customized code to an application generated
    by the JHipster ecosystem.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何使用JHipster创建完整和可生产的应用程序。你已经看到了如何创建实体并定义它们之间的关系。我们还添加了自定义屏幕并开发了各种工件，这样你就可以学习如何向由JHipster生态系统生成的应用程序添加自定义代码。
- en: These are some of the great features that not only make the developer's life
    easier, but also more productive, by automating lots of processes. We will look
    at these now.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些非常棒的功能，不仅使开发者的生活更轻松，而且通过自动化许多流程，使开发者更加高效。我们现在将探讨这些功能。
- en: IDE support
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE支持
- en: At the beginning of this chapter, you saw how to create an application with
    the JHipster CLI by answering various questions. This is more than sufficient
    to start working with JHipster. However, to become more productive, it is recommended
    to use an IDE for development. JHipster supports a wide range of IDEs, including
    Eclipse, Visual Studio Code, IntelliJ IDEA, and so on. While working with an IDE
    (or a simple text editor), you need to make sure to exclude a certain folder from
    doing indexing, like `node_modules`, `build`, and `target`, to reduce the initial
    loading time of the application.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，你看到了如何通过回答各种问题来使用JHipster CLI创建应用程序。这已经足够开始使用JHipster了。然而，为了提高生产效率，建议使用IDE进行开发。JHipster支持广泛的IDE，包括Eclipse、Visual
    Studio Code、IntelliJ IDEA等等。在使用IDE（或简单的文本编辑器）时，你需要确保排除某些文件夹进行索引，如`node_modules`、`build`和`target`，以减少应用程序的初始加载时间。
- en: Setting screens out of the box
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开箱即用的设置屏幕
- en: 'JHipster provides several screens out of the box. Broadly, they can be categorized
    into three different groups, as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster提供了一些开箱即用的屏幕。大致上，它们可以分为三个不同的组，如下所示：
- en: Home and login screens
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页和登录屏幕
- en: Administration
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理
- en: Account management
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户管理
- en: Home and login screens
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首页和登录屏幕
- en: 'Upon starting, JHipster shows the home screen with a welcome message. This
    is the default home page and you can change it as per your application needs.
    In local development, by default, the `dev` profile is selected, so you will see
    a development tab at the top-left corner. On the top section of the page, you
    will see a navigation menu. Without have logged in, it will show the following
    menu items:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，JHipster显示带有欢迎信息的首页。这是默认的首页，你可以根据应用程序需求进行更改。在本地开发中，默认选择`dev`配置文件，因此你将在左上角看到一个“开发”标签。在页面的顶部部分，你会看到一个导航菜单。在没有登录的情况下，它将显示以下菜单项：
- en: 'Home: A link to show a home page.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页：显示主页的链接。
- en: 'Language: This is conditional. This menu will be only visible if you have selected
    more than one language.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言：这是有条件的。只有当你选择了多个语言时，此菜单才会可见。
- en: 'Account: This shows child menu items, such as Sign in and Register.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户：此部分显示子菜单项，例如“登录”和“注册”。
- en: 'Upon clicking on the Sign in option, you will see a login page, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“登录”选项后，你会看到一个登录页面，如下所示：
- en: '![](img/42169da4-3411-4be0-a3f6-debe10692372.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42169da4-3411-4be0-a3f6-debe10692372.png)'
- en: 'This screen covers Remember me, Did you forget forget your password?, and Register
    a new account features. The forgotten password feature requires email verification.
    For this, you need to configure SMTP with JHipster in the application properties
    file. By default, JHipster creates the following two users:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕涵盖了“记住我”、“忘记密码了吗？”以及“注册新账户”等功能。忘记密码功能需要电子邮件验证。为此，你需要在应用程序属性文件中配置SMTP。默认情况下，JHipster创建了以下两个用户：
- en: '**Administrator**: Username—`admin`, Password—`admin`, role—`admin`.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员**：用户名—`admin`，密码—`admin`，角色—`admin`。'
- en: '**User**: Username—`user`, Password—`user`, role—`user`.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：用户名—`user`，密码—`user`，角色—`user`。'
- en: Account management
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户管理
- en: 'JHipster facilitates login features out of the box. It also incorporates account
    management with this. The account screen provided by JHipster supports various
    actions in the form of child menus, as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster自带登录功能。它还结合了账户管理。JHipster提供的账户屏幕支持以下形式的子菜单中的各种操作：
- en: '**Settings**: This screen allows for updating the user account details, such
    as the first and last name, email address, and language. The language drop-down
    menu shows all available languages in the system, which are configured during
    the creation of the application.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：此屏幕允许更新用户账户详情，例如姓名、电子邮件地址和语言。语言下拉菜单显示了系统中的所有可用语言，这些语言是在应用程序创建期间配置的。'
- en: '**Password**: This screen is used to update the currently logged-in user''s
    password.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：此屏幕用于更新当前登录用户的密码。'
- en: '**Registration**: This screen is used to register new users into the system.
    It is only available when a user is not logged in. Soon after a user is created,
    an activation flow will be started, with an activation email and verification.
    The SMTP configuration needs to be done in the application properties for sending
    an email. Please note that if OAuth is selected as an authentication mechanism
    during the application creation, JHipster will not show this screen.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册**：此屏幕用于将新用户注册到系统中。仅在用户未登录时才可用。用户创建后不久，将启动一个激活流程，包括激活邮件和验证。发送电子邮件需要在应用程序属性中完成SMTP配置。请注意，如果在应用程序创建期间选择OAuth作为认证机制，JHipster将不会显示此屏幕。'
- en: Administration
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理
- en: Upon signing in with administrator credentials, you will see a navigation menu
    with the Administration option. It covers various modules used to manage the whole
    application. It is useful for development, as well as monitoring the application.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管理员凭据登录后，您将看到一个包含“管理”选项的导航菜单。它涵盖了用于管理整个应用程序的各种模块。这对于开发和监控应用程序都很有用。
- en: It comprises various child menus, as described in the following sections.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含以下各节中描述的各种子菜单。
- en: User management
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理
- en: This is a one-stop screen that's used to manage the registered users of the
    application. You can add a new user and modify, delete, or activate/deactivate
    existing users from this screen. It also shows the list of users with various
    attributes, such as `ID`, `username`, `email`, `Activate/Deactivate`, `Language`,
    `Roles`, `Created date`, `Modify by`, and `Modify date with pagination support`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一站式屏幕，用于管理应用程序的注册用户。您可以从此屏幕添加新用户，修改、删除或激活/停用现有用户。它还显示了具有各种属性的用户列表，例如`ID`、`用户名`、`电子邮件`、`激活/停用`、`语言`、`角色`、`创建日期`、`修改者`和`修改日期`，并支持分页。
- en: Metrics
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标
- en: 'JHipster provides various screens to analyze the performance of the application
    and other metrics, as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster提供各种屏幕来分析应用程序性能和其他指标，如下所示：
- en: '**JVM Metrics**: This shows JVM-specific statistics, like memory utilization,
    thread counts, thread dump, and garbage collection details.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM度量**：此部分显示了JVM特定的统计信息，如内存利用率、线程计数、线程转储和垃圾回收详细信息。'
- en: '**HTTP requests**: Aggregated details of HTTP requests, with their status code
    is shown for this metric.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP请求**：此指标显示了HTTP请求的聚合详情，包括其状态码。'
- en: '**Service statistics**: Details of the execution time of various out-of-the-box
    and custom services are shown here. It is useful to see the usage of various services.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务统计信息**：此处显示了各种内置和自定义服务的执行时间详情。查看各种服务的使用情况很有用。'
- en: '**Cache statistics**: The details of the entity cache are covered in this metric.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存统计信息**：此指标涵盖了实体缓存的详细信息。'
- en: '**DataSource statistics**: The data source details will be shown here.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据源统计信息**：此处将显示数据源详情。'
- en: The Refresh button is given to update the metrics with the latest value.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了刷新按钮以更新指标的最新值。
- en: Health
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康状况
- en: This screen shows various pieces of information related to application health,
    such as the underlying database and disk space. It is used make decisions about
    data storage well in advance.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕显示了与应用程序健康相关的各种信息，例如底层数据库和磁盘空间。它用于提前做出关于数据存储的决定。
- en: Configuration
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: This screen shows the current configuration applied to the application. It is
    especially useful for troubleshooting an application in case of any issue arising,
    or to check for the possibility of further performance improvement. It covers
    Spring Framework specific configurations, server configurations, system environment
    configurations, and application properties. Since this involves sensitive data,
    only the administrator can see it, by default.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕显示了应用于应用程序的当前配置。在出现任何问题或检查进一步性能改进的可能性时，特别有用。它涵盖了Spring框架特定配置、服务器配置、系统环境配置和应用程序属性。由于这涉及敏感数据，默认情况下只有管理员才能看到。
- en: Audit
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计
- en: JHipster provides an audit log for user authentication. Since authentication
    is done by Spring Security in JHipster, it captures security-specific events specifically
    for authentication, and stores them in a database at the separate Spring data
    repository. They are useful from a security point of view. This screen shows all
    of this data in tabular format, with pagination.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster为用户认证提供审计日志。由于在JHipster中认证是通过Spring Security完成的，它专门捕获与认证相关的安全事件，并将它们存储在独立的Spring数据仓库的数据库中。从安全角度来看，这些信息非常有用。此屏幕以表格格式显示所有这些数据，并具有分页功能。
- en: Logs
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: This screen shows, various application log levels, such as `TRACE`, `DEBUG`,
    `INFO`, `WARN`, `ERROR`, and `OFF` at runtime, for classes and packages. It also
    allows for updating the log level for individual classes and packages. This is
    helpful while troubleshooting the application.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕显示了运行时各种应用程序日志级别，例如`TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`和`OFF`，以及类和包。它还允许更新单个类和包的日志级别。这在解决应用程序问题时非常有用。
- en: API
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API
- en: JHipster uses Swagger, a framework used to describe the structure of APIs. As
    you have seen, JHipster supports entity creation, and also exposes the REST API.
    It uses Swagger to document the entity REST API. JHipster also provides a user
    interface to interact with the API using sample data, and returns the output.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster使用Swagger，这是一个用于描述API结构的框架。正如您所看到的，JHipster支持实体创建，并公开REST API。它使用Swagger来记录实体REST
    API。JHipster还提供了一个用户界面，使用示例数据与API交互，并返回输出。
- en: Maintaining code quality
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护代码质量
- en: JHipster generates lots of boilerplate code while creating an application and
    entities. It follows best practices while generating the code, in order to maintain
    the quality. However, JHipster just creates the application code the first time,
    and the user must add custom code based on the business needs later on.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster在创建应用程序和实体时生成大量的样板代码。它在生成代码时遵循最佳实践，以保持代码质量。然而，JHipster第一次只是创建应用程序代码，用户必须在之后根据业务需求添加自定义代码。
- en: To maintain the code quality even after adding the customized code, JHipster
    allows analyzing the complete application code with Sonar—a tool designed specifically
    for monitoring code quality. The code is analyzed using **SonarCloud***—*the cloud
    version of the Sonar. For this, you must commit the code in Git.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了即使在添加自定义代码后也能保持代码质量，JHipster允许使用Sonar分析整个应用程序代码——Sonar是一款专门用于监控代码质量的工具。代码分析使用**SonarCloud**——Sonar的云版本。为此，您必须在Git中提交代码。
- en: 'You also can analyze the code on a local Sonar server. For this, you must set
    up and run the Sonar server locally. The default port on which the Sonar server
    runs is `9000`, so you need to make sure that the Sonar port configured in `pom.xml`
    (if the build type is Maven) is the same. Execute the `mvnw test sonar:sonar`
    command, and you will see the code analysis in Sonar, as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在本地Sonar服务器上分析代码。为此，您必须在本地设置和运行Sonar服务器。Sonar服务器运行的默认端口是`9000`，因此您需要确保在`pom.xml`中配置的Sonar端口（如果构建类型是Maven）相同。执行`mvnw
    test sonar:sonar`命令，您将在Sonar中看到代码分析，如下所示：
- en: '![](img/4c03dcee-921f-4fbc-9805-2cb2b2a2f6b5.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c03dcee-921f-4fbc-9805-2cb2b2a2f6b5.png)'
- en: This helps to maintain the code quality even after adding custom code to the
    application.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于在添加自定义代码到应用程序后仍保持代码质量。
- en: Microservice support
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务支持
- en: In this chapter, we created a monolithic application using JHipster. However,
    it also allows users to create microservice-based applications. The microservice-based
    architecture splits the whole monolithic application (both the frontend and backend)
    into small and independent modular services. It is a unique way of doing software
    development that has grown rapidly in the last couple of years.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用JHipster创建了一个单体应用程序。然而，它也允许用户创建基于微服务应用程序。基于微服务的架构将整个单体应用程序（包括前端和后端）拆分为小型且独立的模块化服务。这是软件开发的一种独特方式，在过去几年中迅速发展。
- en: Each modular service can interact with other services through a unique and simple
    API. The microservice architecture has many advantages over a monolithic design,
    such as independent development and deployment, managing fail-over with ease,
    the fact that developers can work in the independent team, making continuous delivery,
    and so on.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块化服务都可以通过一个独特且简单的API与其他服务交互。与单体设计相比，微服务架构具有许多优势，例如独立开发和部署、轻松管理故障转移、开发人员可以在独立团队中工作、实现持续交付等。
- en: Generally, a microservice architecture does not have any frontend layer, but
    JHipster supports a microservice gateway with a frontend to handle web traffic.
    It works as a proxy microservice for the end user. In short, a user can interact
    with a microservice through a gateway. The JHipster microservice model is comprised
    of one gateway service, one registry, and at least one or more microservice applications
    that we can create with JHipster with a backend code, which can be accessed with
    an API.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，微服务架构没有前端层，但JHipster支持带有前端微服务网关以处理网络流量。它作为代理微服务为最终用户提供服务。简而言之，用户可以通过网关与微服务交互。JHipster微服务模型由一个网关服务、一个注册表以及至少一个或多个我们可以使用JHipster创建的微服务应用程序组成，这些应用程序可以通过后端代码访问，并使用API进行访问。
- en: Docker support
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker支持
- en: Docker is an open source software platform that supports containers, making
    application deployment portable and self-contained. It is used to package the
    entire application (including SQL and NoSQL databases, Sonar configuration, and
    so on) and its dependencies together as a single container image, to deploy and
    test on any environment.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个支持容器化的开源软件平台，它使得应用程序的部署变得便携和自包含。它可以将整个应用程序（包括SQL和NoSQL数据库、Sonar配置等）及其依赖项打包成一个单一的容器镜像，以便在任何环境中进行部署和测试。
- en: JHipster provides support for Docker out of the box for monolithic and microservice-based
    applications. Docker was developed for Linux, but has separate versions for macOS
    and Windows. JHipster only creates a Dockerfile at the time of application generation.
    The Dockerfile holds the set of instructions used by Docker containers to build
    a Docker image.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster为单体和基于微服务的应用程序提供了开箱即用的Docker支持。Docker是为Linux开发的，但为macOS和Windows提供了单独的版本。JHipster在应用程序生成时创建Dockerfile。Dockerfile包含Docker容器用于构建Docker镜像的指令集。
- en: JHipster also supports pulling Docker images from the Docker Hub. This is an
    online registry that's used to publish public and private Docker images. This
    greatly helps in using third-party tools without local installation, as Docker
    images can be pulled and run on a local container.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster还支持从Docker Hub拉取Docker镜像。这是一个在线注册表，用于发布公共和私有Docker镜像。这极大地帮助了在不进行本地安装的情况下使用第三方工具，因为Docker镜像可以被拉取并在本地容器上运行。
- en: Profile management
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件管理
- en: The profile is a set of configurations for a specific environment, like development,
    testing, production, and so on. JHipster supports profile management, and comes
    with two profiles—`dev` and `prod`—out of the box. By default, it uses the `dev`
    profile. JHipster provides a separate application properties file for each profile.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件是一组针对特定环境的配置，如开发、测试、生产等。JHipster支持配置文件管理，并自带两个配置文件——`dev`和`prod`。默认情况下，它使用`dev`配置文件。JHipster为每个配置文件提供单独的应用程序属性文件。
- en: In production, you need to enable the production profile with the `./mvnw -Pprod`
    command for Maven and the `./gradlew -Pprod` command for Gradle. If you need to
    export an executable WAR file in production, you can use the command `./mvnw -Pprod
    package` for Maven, and `./gradlew -Pprod package` for Gradle.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您需要使用`./mvnw -Pprod`命令为Maven和`./gradlew -Pprod`命令为Gradle启用生产配置文件。如果您需要在生产中导出可执行的WAR文件，可以使用Maven的`./mvnw
    -Pprod package`命令和Gradle的`./gradlew -Pprod package`命令。
- en: Live reload
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时重载
- en: One of the most challenging factors in the software development process, in
    terms of time management, is recompiling the code, deploying it, and restarting
    the server to see the changes you made. Generally, the frontend code written in
    JavaScript does not require compilation, and can immediately reflect the changes
    upon browser refresh. Nevertheless, the latest frontend frameworks require some
    sort of transpilation after making changes in the script file.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发过程中，从时间管理角度来看，最具挑战性的因素之一是重新编译代码、部署并重新启动服务器以查看所做的更改。通常，用JavaScript编写的客户端代码不需要编译，可以在浏览器刷新后立即反映更改。尽管如此，最新的前端框架在修改脚本文件后需要某种形式的转译。
- en: In this situation, for any single code change, typically, you need to build,
    deploy, and restart the server. This will badly impact developer productivity.
    To avoid this, JHipster supports a mechanism called **live reload**. JHipster
    generates a Spring Boot-based application with the `DevTools` module to refresh
    the changes on the server without doing a cold restart. This is enabled by default,
    so whenever any Java code changes occur, it will automatically refresh them on
    the server. The live reloads for any frontend code can be achieved through **BrowserSync**,
    which can be started with the `npm start` command, and is accessible at `http://localhost:9000`*.*
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于任何单个代码更改，通常需要构建、部署和重新启动服务器。这将严重影响开发者的生产力。为了避免这种情况，JHipster支持一种称为**实时重新加载**的机制。JHipster生成一个基于Spring
    Boot的应用程序，并包含`DevTools`模块，以在服务器上刷新更改而不进行冷启动。默认情况下，这是启用的，所以每当发生任何Java代码更改时，它将自动在服务器上刷新它们。任何前端代码的实时重新加载都可以通过**BrowserSync**实现，可以使用`npm
    start`命令启动，并且可以通过`http://localhost:9000`访问*.*。
- en: Testing support
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试支持
- en: Testing is an integral part of any software development process. It provides
    quality assurance of the application or product. While creating an application
    and entities, JHipster creates various automated unit test cases for both the
    frontend and backend (or the server side).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何软件开发过程中的一个重要组成部分。它为应用程序或产品提供质量保证。在创建应用程序和实体时，JHipster会为前端和后端（或服务器端）创建各种自动化的单元测试用例。
- en: The server-side unit test cases are generated in the `/src/test/java` folder.
    They cover various layers of the application, such as the repository, service,
    security, REST API, and pagination. They are grouped in respective packages. You
    can run individual test cases from the IDE, or run all test cases from the Command
    Prompt with the `mvnw test` command. Make sure that you are in the application
    directory when you execute this command. In the case of Gradle, you will need
    to execute the `gradle test` command.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端单元测试用例生成在`/src/test/java`文件夹中。它们涵盖了应用程序的各个层次，如存储库、服务、安全、REST API和分页。它们被分组在相应的包中。您可以从IDE中运行单个测试用例，或者使用`mvnw
    test`命令从命令提示符中运行所有测试用例。确保在执行此命令时您位于应用程序目录中。在Gradle的情况下，您需要执行`gradle test`命令。
- en: Frontend (or client-side) unit testing can be executed with the `npm test` command.
    This will execute various JavaScript test cases for the typescript residing in
    the `/src/test/javascript/spec` folder. JHipster also supports end-to-end client-side
    test cases with the Jest framework, by default. Optionally, other frameworks,
    such as **Gatling**, **Cucumber**, and **Protractor**, can also be used for client-side
    end-to-end testing.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 前端（或客户端）单元测试可以使用`npm test`命令执行。这将执行位于`/src/test/javascript/spec`文件夹中的typescript的各种JavaScript测试用例。JHipster默认还支持使用Jest框架进行端到端客户端测试用例。可选地，还可以使用其他框架，如**Gatling**、**Cucumber**和**Protractor**，进行客户端端到端测试。
- en: Upgrading JHipster
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级JHipster
- en: 'Unlike other frameworks, upgrading JHipster is a painless process. A subgenerator
    called **JHipster upgrade** is used to upgrade an existing application for the
    new version, without removing any custom changes that have been added since the
    application was created the first time. This is quite useful, especially when
    a new version of JHipster is released with known bug fixes and security patches.
    JHipster upgrades can be executed with the following command:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他框架不同，升级JHipster是一个痛苦的过程。一个名为**JHipster升级**的子生成器用于升级现有应用程序到新版本，而不会删除自应用程序首次创建以来添加的任何自定义更改。这非常有用，尤其是在JHipster的新版本发布时，其中包含已知的错误修复和安全补丁。可以使用以下命令执行JHipster升级：
- en: '[PRE36]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To make the whole upgrade process automated, JHipster take the help of Git
    with the following steps:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使整个升级过程自动化，JHipster借助以下步骤使用Git：
- en: The preceding command checks whether a new version of JHipster is available,
    unless the `--force` flag is given explicitly. If this option is given, the upgrade
    sub-generator will be triggered, irrespective of the latest version being installed.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole upgrade process depends on Git, so if an application is not initialized
    with Git (if Git is not installed), JHipster will initialize Git and commit the
    current code to the master branch.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JHipster will check for any uncommitted local code. The upgrade process fails
    if the code is not committed.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it will check if a `jhipster_upgrade` branch is available in Git. If not,
    this will be created. This branch is dedicated to the JHipster upgrade process,
    so it should never be updated manually.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JHipster will check out the `jhipster_upgrade` branch.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, JHipster is upgraded with the latest version.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current project directory is cleaned and the application is generated from
    scratch, with the entities.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated code will then be committed to the `jhipster_upgrade` branch.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `jhipster_upgrade` branch will be merged with the original branch
    from which the `jhipster_upgrade` command was launched.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of any conflicts, you will need to resolve and commit them manually.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration support
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing greatly helps in making the system bug-free, even after adding
    new functionalities. JHipster creates unit and integration test cases for generated
    code that will be helpful up to some extent. In a real scenario, we need to add
    further unit test cases targeted for custom business implementations; for example,
    you might have added few custom screens, controller and service layer for which
    you need to write additional unit test cases.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need to add integration test cases for newly introduced APIs. Apart
    from that, we also need to add client-side test cases for frontend customization.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Presently, testing and continuous integration have become an integral part of
    the software development process. Testing will help to produce a quality product,
    while continuous integration is nothing but constantly merging and testing newly
    introduced code changes, which assists in identifying potential bugs. This happens
    with the combination of executing automated units, integration, and end-to-end
    test cases against the code. A classic example is triggering the automated test
    suite on every commit on Git; or, more efficiently, running it as per a predefined
    schedule.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of an automated testing model can be achieved by putting a continuous
    integration process in place, to make sure that new code changes do not introduce
    regressions to the stable version. This assures the merging of new changes and
    deploying to production with confidence.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: The continuous testing, integration, and continuous deployment results in a
    concept called **Continuous Integration/Continuous Deployment** (**CI/CD**), which performs
    continuous integration, testing, and deploying the code. Continuous delivery can
    be achieved through various CI/CD tools. JHipster provides elegant support for
    well known CI/CD tools available in the market today, such as Jenkins, Travis
    CI, GitLab CI, and Circle CI.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Community support and documentation
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how good a software framework or product is, its popularity comes
    from how easily users can get help from documentation and the community. JHipster
    has very nice documentation on their official site, which is more than sufficient
    to start working with it.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the official GitHub forum, there are plenty of other resources and
    forums available, in which you can easily get help with any issue or problem while
    working with JHipster. Additionally, the developers provide professional help
    in terms of answering questions on time and providing bug fixes as a priority.
    This really helps to attract developers and organizations to start to work with
    JHipster.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The JHipster Marketplace
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Who doesn't like to use reusable components or modules that fit business requirements?
    This would greatly save development time. As an open source software, the JHipster
    team not only produces a great masterpiece in the form of the framework, but also
    maintains a repository of reusable modules, called the **Marketplace**.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: You can download various modules, as per your needs, and plug them directly
    in your application. You can contribute your module back to the Marketplace, so
    that other community users can get the benefit of that module. This is a great
    platform provided by JHipster to share a piece of reusable code with the community.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has really been a great journey, exploring a new framework for building
    a powerful web application. JHipster is a really great tool for crafting a modern
    and production-ready application in no time. With lots of things happening automatically,
    JHipster not only makes a developer's job easier, but also improves the overall
    project delivery schedule.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we explored the basics of JHipster as a framework,
    along with an installation guide. Moving forward, you learned how JHipster generates
    application code with a question-and-answer approach. It uses another tool, called
    **Yeoman**, to generate application code.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing domain objects as entities and supporting complete CRUD operations
    is the most important part of any application. In the next step, we learned how
    JHipster provides support for modeling domain objects through entity generation.
    Entity generation can be done with three options: the classic Yeoman-based option,
    the UML approach, and by using JDL-Studio. We have looked at all of them in detail.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: After covering these features, we started to create an application to show GDP
    information by country. This required us to build custom screens, and we discovered
    how to add customization in an application generated with JHipster. We also collected
    a few details of generated code in various layers, including the persistence,
    service, REST controller, and frontend layer, which will help us to accommodate
    any future customization.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完这些特性后，我们开始创建一个应用，用于展示按国家划分的GDP信息。这要求我们构建自定义界面，并发现了如何在JHipster生成的应用中添加自定义功能。我们还收集了在不同层次（包括持久层、服务层、REST控制器和前端层）生成的代码的一些细节，这将帮助我们适应任何未来的自定义需求。
- en: Towards the end, we looked at some unseen features that demonstrate what a robust
    platform JHipster is, and how it allows us to build a Spring-based, enterprise-grade
    application with ease. In the next chapter, you will learn how to create a Spring-based
    application with a microservice architecture, and how this is different and can
    be beneficial, as compared to a monolithic application.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在接近尾声时，我们查看了一些未见过的特性，展示了JHipster是一个多么稳健的平台，以及它如何使我们能够轻松地构建基于Spring的企业级应用。在下一章中，你将学习如何创建一个基于Spring的微服务架构应用，以及这与单体应用相比有何不同，以及它可能带来的好处。
