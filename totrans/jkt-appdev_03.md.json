["```java\npackage com.ensode.jakartaeebook.jakartarestintro.service;\n//imports omitted for brevity\n@Path(\"customer\")\npublic class CustomerResource {\n  private static final Logger LOG =\n      Logger.getLogger(CustomerResource.class.getName());\n  @GET\n  @Produces(MediaType.APPLICATION_JSON)\n  public String getCustomer() {\n    LOG.log(Level.INFO, \"{0}.getCustomer() invoked\",\n        this.getClass().getCanonicalName());\n    return \"\"\"\n              {\n                \"customer\": {\n                  \"id\": 123,\n                  \"firstName\": \"Joseph\",\n                  \"middleName\": \"William\",\n                  \"lastName\": \"Graystone\"\n                }\n              }\n              \"\"\";\n  }\n  @PUT\n  @Consumes(MediaType.APPLICATION_JSON)\n  public void createCustomer(String customerJson) {\n    LOG.log(Level.INFO, \"{0}.createCustomer() invoked\",\n        this.getClass().getCanonicalName());\n    LOG.log(Level.INFO, \"customerJson = {0}\", customerJson);\n  }\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  public void updateCustomer(String customerJson) {\n    LOG.log(Level.INFO, \"{0}.updateCustomer() invoked\",\n      this.getClass().getCanonicalName());\n    LOG.log(Level.INFO, \"customerJson = {0}\", customerJson);\n  }\n}\n```", "```java\nhttp://example.com:8080/jakartarestintro/resources/customer\n```", "```java\n  @GET\n  @Produces(MediaType.TEXT_PLAIN)\n  @Path(\"customername\")\n  public String getCustomerName() {\n    return \"Joseph Graystone\";\n  }\n```", "```java\npackage com.ensode.jakartaeebook.jakartarestintro.service.config;\n//imports omitted for brevity\n@ApplicationPath(\"resources\")\npublic class JakartaRestConfig extends Application {\n}\n```", "```java\ncurl -XGET http://localhost:8080/jakartarestintro/resources/customer\n```", "```java\n{\n  \"customer\": {\n    \"id\": 123,\n    \"firstName\": \"Joseph\",\n    \"middleName\": \"William\",\n    \"lastName\": \"Graystone\"\n  }\n}\n```", "```java\ncurl http://localhost:8080/jakartarestintro/resources/customer\n```", "```java\ncom.ensode.jakartaeebook.jakartarestintro.service.CustomerResource.getCustomer() invoked|#]\n```", "```java\ncurl -XPUT -HContent-type:application/json --data \"{\n  \"customer\": {\n    \"id\": 321,\n    \"firstName\": \"Amanda\",\n    \"middleName\": \"Zoe\",\n    \"lastName\": \"Adams\"\n  }\n}\" http://localhost:8080/jakartarestintro/resources/customer\n```", "```java\ncom.ensode.jakartaeebook.jakartarestintro.service.CustomerResource.createCustomer() invoked|#]\n  customerJson = {\n  customer: {\n    id: 321,\n    firstName: Amanda,\n    middleName: Zoe,\n    lastName: Adams\n  }\n}|#]\n```", "```java\ncurl -XPOST -HContent-type:application/json --data \"{\n  \"customer\": {\n    \"id\": 321,\n    \"firstName\": \"Amanda\",\n    \"middleName\": \"Tamara\",\n    \"lastName\": \"Adams\"\n  }\n}\" http://localhost:8080/jakartarestintro/resources/customer\n```", "```java\ncom.ensode.jakartaeebook.jakartarestintro.service.CustomerResource.updateCustomer() invoked|#]\n  customerJson = {\n  customer: {\n    id: 321,\n    firstName: Amanda,\n    middleName: Tamara,\n    lastName: Adams\n  }\n}|#]\n```", "```java\npackage com.ensode.jakartaeebook.jakartarestintroclient;\n//imports omitted for brevity\npublic class App {\n  public static void main(String[] args) {\n    App app = new App();\n    app.insertCustomer();\n  }\n  public void insertCustomer() {\n    String customerJson = \"\"\"\n                          {\n                            \"customer\": {\n                              \"id\": 234,\n                              \"firstName\": \"Tamara\",\n                              \"middleName\": \"Adeline\",\n                              \"lastName\": \"Graystone\"\n                            }\n                          }\n                          \"\"\";\n        Client client = ClientBuilder.newClient();\n        client.target(\n          \"http://localhost:8080/\" +\n          \"jakartarestintro/resources/customer\").\n          request().put(\n            Entity.entity(customerJson,\n              MediaType.APPLICATION_JSON),\n              String.class);\n    }\n}\n```", "```java\npackage com.ensode.jakartaeebook.javajson.entity;\npublic class Customer {\n  private Long id;\n  private String firstName;\n  private String middleName;\n  private String lastName;\n  public Customer() {\n  }\n  public Customer(Long id, String firstName,\n    String middleName, String lastName) {\n    //constructor body omitted for brevity\n  }\n  //getters,setters and toString() method omitted for brevity\n}\n```", "```java\npackage com.ensode.jakartaeebook.javajson.service;\n//imports omitted for brevity\n@Path(\"customer\")\npublic class CustomerResource {\n  private static final Logger LOG =\n    Logger.getLogger(CustomerResource.class.getName());\n  private final Customer customer;\n  public CustomerResource() {\n    customer = new Customer(1L, \"David\",\n      \"Raymond\", \"Heffelfinger\");\n  }\n  @GET\n  @Produces(MediaType.APPLICATION_JSON)\n  public Customer getCustomer() {\n    LOG.log(Level.INFO, \"{0}.getCustomer() invoked\",\n      this.getClass().getCanonicalName());\n    return customer;\n  }\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  public void updateCustomer(Customer customer) {\n    LOG.log(Level.INFO, \"got the following customer: {0}\",\n      customer);\n  }\n  @PUT\n  @Consumes(MediaType.APPLICATION_JSON)\n  public void createCustomer(Customer customer) {\n    LOG.log(Level.INFO, \"customer = {0}\", customer);\n  }\n}\n```", "```java\ncurl -XPUT -HContent-type:application/json --data '{\n  \"id\": 1,\n  \"firstName\": \"Bruce\",\n  \"middleName\": \"Arnold\",\n  \"lastName\": \"Stallone\"\n}' http://localhost:8080/jakartarestjavajson/resources/customer\n```", "```java\n  com.ensode.jakartaeebook.javajson.service.CustomerResource.createCustomer() invoked|#]\n  toString() method of our Customer class, illustrating that the createCustomer(Customer customer) method in our service was invoked, and it seamlessly populated its customer parameter with the raw JSON data we sent it with our curl command.\nWhen using non-Java clients, such as `curl`, or RESTful web service clients written in languages other than Java, we need to send raw JSON data to our service from the client side, as illustrated in our example. When writing clients in Java, we can take advantage of the Jakarta REST client API, which allows seamless conversion from Java to JSON on the client side as well. The following example illustrates how to do this:\n\n```", "```java\n\n In this updated client, we simply create an instance of our `Customer` class. Then we can pass it as a parameter to the static `entity()` method of the `Entity` class, and pass the corresponding type (`Customer.class`, in our example) to the `put()` method.\nAfter running our client code, we can see the following output in the application server log:\n\n```", "```java\n\n Our client seamlessly converted our `Customer` instance to a JSON string, and invoked our RESTful web service, which in turn converted the sent JSON back to a `Customer` instance; all behind the scenes, saving us a lot of drudge work.\nSo far, in all of our examples, we have been passing a JSON string (either directly or indirectly) as a body to the HTTP requests we have been sending to our RESTful web services. It is also possible to pass parameters to our RESTful web services. The following section illustrates how to do that.\nQuery and path parameters\nIn our previous examples, we have been working with a RESTful web service to manage a single customer object. In real life, this would obviously not be very helpful. The common case is to develop a RESTful web service to handle a collection of objects (customers, in our example). To determine what specific object in the collection we are working with, we can pass parameters to our RESTful web services. There are two types of parameters we can use: **query** and **path** parameters.\nQuery parameters\nWe can add parameters to methods that will handle HTTP requests in our web service. Parameters decorated with the `@QueryParam` annotation will be retrieved from the request URL.\nThe following example illustrates how to use query parameters in RESTful web services using Jakarta REST:\n\n```", "```java\n\n In our updated example, we added a parameter to the `getCustomer()` method, which, as we may recall, is decorated with the `@GET` annotation so that it is invoked when our RESTful web service receives an HTTP GET request. We annotated the parameter with the `@QueryParam` annotation; the value of this annotation (`id` in our example) is the name of the parameter to use when sending a request to our service.\nWe can pass a query parameter to the web service’s URL just like we pass query parameters to any URL. For HTTP GET requests, we could simply type our RESTful web service’s URL into the browser, or we could use `curl` as follows:\n\n```", "```java\n\n Either way, we should see the corresponding output in the application server log:\n\n```", "```java\n\n Plus, we should see the following response from our RESTful web service:\n\n```", "```java\n\n Notice the response is a JSON representation of the `Customer` object we return in our `getCustomer()` object. We didn’t have to explicitly create the JSON data; Jakarta REST took care of it for us.\nWe added a `deleteCustomer()` method to our RESTful web service, and we annotated this method with `@DELETE` so that it responds to HTTP DELETE requests. Just like with `getCustomer()`, we added a parameter to this method and annotated it with the `@``QueryParam` annotation.\nWe can send our RESTful web service using `curl` as follows:\n\n```", "```java\n\n Our `deleteCustomer()` will be invoked as expected, as evidenced by the output in the application server log:\n\n```", "```java\n\n Sending query parameters via the Jakarta REST client API\nThe Jakarta REST client API provides a straightforward way of sending query parameters to RESTful web services. The following example illustrates how to do this:\n\n```", "```java\n\n As we can see, all we need to do to pass a parameter is to invoke the `queryParam()` method on the `jakarta.ws.rs.client.WebTarget` instance returned by the `target()` method invocation on our `Client` instance. The first argument to this method is the parameter name and must match the value of the `@QueryParam` annotation on the web service. The second parameter is the value that we need to pass to the web service. If our web service accepts multiple parameters, we can chain `queryParam()` method invocations, using one for each parameter our RESTful web service expects.\nPath parameters\nAnother way we can pass parameters to our RESTful web services is via path parameters. The following example illustrates how to develop a Jakarta REST web service that accepts path parameters:\n\n```", "```java\n\n Any method that accepts a path parameter must be annotated with the `@Path` annotation. The value attribute of this annotation must be formatted as `\"{paramName}/\"`, where `paramName` is the parameter the method expects to receive. Additionally, method parameters must be decorated with the `@PathParam` annotation. The value of this annotation must match the parameter name declared in the `@Path` annotation for the method.\nWe can pass path parameters from the command line by adjusting our web service’s URI as appropriate; for example, to pass an id parameter of `1` to the `getCustomer()` method (which handles HTTP GET requests), we could do it from the command line as follows:\n\n```", "```java\n\n This returns the expected output of a JSON representation of the `Customer` object returned by the `getCustomer()` method, as seen in the following:\n\n```", "```java\n\n Sending path parameters via the Jakarta REST client API\nSending path parameters to a web service via the Jakarta REST client API is straightforward; all we need to do is add a couple of method invocations to specify the path parameter and its value. The following example illustrates how to do this:\n\n```", "```java\n\n In this example, we invoke the `path()` method on the `WebTarget` instance returned by `client.target()`; this method appends the specified path to our `WebTarget` instance. The value of this method must match the value of the `@Path` annotation in our RESTful web service.\nAfter invoking the `path()` method on our `WebTarget` instance, we then need to invoke `resolveTemplate()`. The first parameter for this method is the name of the parameter (without the curly braces), and the second parameter is the value we wish to pass as a parameter to our RESTful web service.\nIf we need to pass more than one parameter to one of our web services, we simply need to use the following format for the `@Path` parameter at the method level:\n\n```", "```java\n\n Then annotate the corresponding method arguments with the `@PathParam` annotation as follows:\n\n```", "```java\n\n The web service can then be invoked by modifying the web service’s URI to pass the parameters in the order specified in the `@Path` annotation. For example, the following URI would pass the values `1` and `2` for `paramName1` and `paramName2`:\nhttp://localhost:8080/contextroot/resources/customer/1/2\nThis URI will work either from the command line or through a web service client we develop with the Jakarta REST client API.\nAll examples we’ve seen so far involve RESTful web services responding to an HTTP request from the client. We can have our RESTful web services send data to clients without necessarily having to respond to a request; this can be achieved via server-sent events.\nServer-sent events\nTypically, every interaction between a web service and its client is initiated by the client. The client sends a request (typically GET, POST, PUT, or DELETE), and then receives a response from the server. Server-sent events technology allows RESTful web services to “take the initiative” to send messages to clients; that is, to send data that is not a response to a client request. Server-sent events are useful for sending data continuously to a client for applications such as stock tickers, newsfeeds, and sports scores.\nThe following example illustrates how to implement this functionality into our Jakarta REST web services:\n\n```", "```java\n\n The preceding example simulates sending stock prices for a fictitious company to the client.  To send server-sent events to the client, we need to utilize instances of the `SseEventSink` and `Sse` classes, as illustrated in our example.\nWe can inject an instance of `Sse` by creating a setter method and annotating it with the `@Context` annotation. We never invoke this setter method directly; instead, the Jakarta EE runtime invokes it, passing an instance of `Sse` we can use to send our events. We then invoke `newEventBuilder()` and `newBroadCaster()` methods on the injected `Sse` instance to obtain `OutboundSseEvent.Builder` and `SseBroadcaster` instances, which we will need to create and broadcast events.\nIn order to receive events, clients need to register with our Jakarta REST service; we implemented an endpoint in the `subscribe()` method of our example for this purpose. This endpoint has a “subscribe” path; clients sending an HTTP GET request to this endpoint will be subscribed to receive events from our service. Notice we annotated the `SseEventSink` parameter in our `subscribe()` method with `@Context`; this results in the Jakarta EE runtime injecting an `SseEventSink` instance we can use to register the client. We accomplish this by invoking the `broadcast()` method on our `SseBroadCaster` instance, and passing the injected `SseEventSink` instance as a parameter.\nTo broadcast an event, we first need to build an instance of `OutboundSseEvent` via our instance of `OutboundSseEvent.Builder`.\nWe give our event a name by invoking the `name()` method on our `OutboundSseEvent.Builder` instance, then set the data to send to the client via its `data()` method. The `data()` method takes two arguments; the first one is the type of data we are sending to the client (`String`, in our case), and the second one is the actual data we send to the client.\nOnce we have set our event’s name and data via the corresponding method, we build an `OutboundSseEvent` instance by invoking the `build()` method on `OutboundSseEvent.Builder`.\nOnce we have built our `OutboundSseEvent` instance, we send it to the client by passing it as a parameter to the `broadcast()` method of `SseBroadcaster`. In our example, we calculate a new value for the simulated stock price (for simplicity, we simply increase the value by 0.9), and broadcast a new event with the updated value every five seconds.\nTesting server-sent events\nWe can make sure our server-sent events are working properly by using `curl`; we can simply send an HTTP GET request to the endpoint we created for clients to subscribe to our events as follows:\n\n```", "```java\n\n As soon as we run this, we should see the output in the application server log confirming that the `subscribe()` method was invoked:\n\n```", "```java\n\n Within five seconds, we should start seeing output from `curl` indicating it is receiving events:\n\n```", "```java\n\n The value next to the `event` label is the name we gave to our event. `data` is the actual value we sent from our service as the event data.\nBy testing our server-sent events code with `curl`, we can rest assured that our server-side code is working properly. That way, if things are not working properly when developing a client, we can eliminate the server as a “suspect” when debugging our code.\nDeveloping a server-sent events client\nThe Jakarta REST client API provides a way to consume server-sent events. The following example illustrates how to do this:\n\n```", "```java\n\n First, we need to obtain a `jakarta.ws.rs.client.Client` instance by invoking the static  `ClientBuilder.newClient()` method.\nWe then obtain an instance of `jakarta.ws.rs.client.WebTarget` by invoking the `target()` method on the `Client` instance we retrieved in the previous step, and passing the URI of the endpoint we created for clients to subscribe as a parameter.\nThe next step is to obtain an `SseEventSource.Builder` instance by invoking the static `SseEventSource.target()` method, and passing our `WebTarget` instance as a parameter.\nWe then get an `SseEventSource` instance by invoking the `build()` method on our instance of `SseEventSource.Builder`.\nNext, we register our client by invoking the `register()` method on our `sseEventSource` instance. This method takes an implementation of the functional interface `java.util.function.Consumer` as a parameter; for convenience, we implement this interface inline as a lambda expression. In our example, we simply output the event name and data we received to the console, via simple `System.out.println()` invocations.\nFinally, we open the connection to our RESTful web service by invoking the `open()` method on our `SseEventSource` instance.\nWhen we run our client, we see the expected output:\n\n```", "```java\n\n For simplicity, our example is a stand-alone Java application we can run on the command line; the same principles apply when developing RESTful web services that act as clients for other RESTful web services.\nJavaScript server-sent events client\nSo far, all of our client examples have either used the `curl` command-line utility or the Jakarta REST client API. It is very common to use JavaScript code running on a browser as a RESTful web service; therefore, in this section, we will take that approach. The following example illustrates an HTML/JavaScript client receiving server-sent events:\n\n```", "```java\n\n The `getStockTickerValues()` JavaScript function creates an `EventSource` object. This constructor takes a `String` representing the URL used to subscribe to receive events as a parameter. In our case, we used a relative URL since the preceding HTML/JavaScript code is hosted in the same server as the server code; if this wasn’t the case, we would have needed to use a complete URL.\nWe implement the functionality to be executed when the client receives an event by adding an event listener to our `EventSource` instance via its `addEventListener()` function. This function takes the event name (notice that the value matches the name we sent in the Java code for our RESTful web service), and a function to be executed when an event is received. In our example, we simply update the contents of a `<span>` tag with the data of the received message.\nSummary\nIn this chapter, we discussed how to easily develop RESTful web services using Jakarta REST.\nWe covered the following topics:\n\n*   How to develop a RESTful web service by adding a few simple annotations to our code\n*   How to automatically generate JSON data\n*   How to automatically parse JSON data it receives as a request\n*   How to pass parameters to our RESTful web services via the `@PathParam` and `@``QueryParam` annotations\n*   How to implement server-sent events and server-sent event clients\n\nRESTful web services have become immensely popular in recent years; they are now the preferred way of developing web applications and are also heavily used when developing applications utilizing a microservices architecture. As seen in this chapter, Jakarta EE allows us to implement RESTful web services by adding a few simple annotations to our Java classes.\n\n```"]