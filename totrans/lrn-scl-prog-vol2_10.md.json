["```java\ndef toInt(str: String): Int = str.toInt \n```", "```java\nprintln(toInt(\"121\")) \nprintln(toInt(\"-199\")) \n```", "```java\n121 \n-199 \n```", "```java\nprintln(toInt(\"+ -199\")) \n```", "```java\nException in thread \"main\" java.lang.NumberFormatException: For input string: \"+ -199\" \n   at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) \n```", "```java\nimport java.lang.Exception \n\nobject Main extends App { \n\n  def toInt(str: String): Int = \n    try{ \n      str.toInt \n    } catch { \n      case exp: Exception => \n        println(\"Something unexpected happened, you may want to check the string you passed for conversion.\") \n\n        println(\"WARN: Overriding the usual behavior, returning Zero!\") \n        0 \n    } \n\n  println(toInt(\"121\")) \n  println(toInt(\"-199\")) \n  println(toInt(\"+ -199\")) \n} \n```", "```java\n121 \n-199 \n```", "```java\nWARN: Overriding the usual behavior, returning Zero! \n0 \ntry block and also prepared what should be the behavior in case something went wrong. That change gave us a synthetic result, along with a pretty warning message.\n```", "```java\ndef toInt(str: String): Option[Int] = Try(str.toInt) match { \n  case Success(value) => Some(value) \n  case Failure(_) => None \n}\n```", "```java\nsealed abstract class Try[+T] extends Product with Serializable \n\nobject Try { \n  /** Constructs a 'Try' using the by-name parameter.  This \n   * method will ensure any non-fatal exception is caught and a \n   * 'Failure' object is returned. \n   */ \n  def apply[T](r: => T): Try[T] = \n    try Success(r) catch { \n      case NonFatal(e) => Failure(e) \n    } \n} \n\nfinal case class Success[+T](value: T) extends Try[T] \n\nfinal case class Failure[+T](exception: Throwable) extends Try[T] \n```", "```java\ndef getAccountInfo(id: String): Option[AccountInfo] \n\ndef makeTransaction(amt: Double, accountInfo: AccountInfo): Option[Double] \n\ncase class AccountInfo(id: String, balance: Double) \n```", "```java\nimport scala.util.Try \n\nobject BankApp extends App { \n\n  val accountHolders = Map( \n    \"1234\" -> AccountInfo(\"Albert\", 1000), \n    \"2345\" -> AccountInfo(\"Bob\", 3000), \n    \"3456\" -> AccountInfo(\"Catherine\", 9000), \n    \"4567\" -> AccountInfo(\"David\", 7000) \n  ) \n\n  def getAccountInfo(id: String): Option[AccountInfo] = Try(accountHolders(id)).toOption \n\n  def makeTransaction(amt: Double, accountInfo: AccountInfo): Option[Double] = Try(accountInfo.balance - amt).toOption \n\n  println(getAccountInfo(\"1234\").flatMap(actInfo => makeTransaction(100, actInfo))) \n\n  println(getAccountInfo(\"12345\").flatMap(actInfo => makeTransaction(100, actInfo))) \n} \n\ncase class AccountInfo(id: String, balance: Double) \n```", "```java\nSome(900.0) \nNone \n```", "```java\nimport java.lang.Exception \nimport scala.util.{Failure, Success, Try} \n\nobject Main extends App { \n\n  def toInt(str: String): Either[String, Int] = Try(str.toInt) match { \n    case Success(value) => Right(value) \n    case Failure(exp) => Left(s\"${exp.toString} occurred,\" + \n      s\" You may want to check the string you passed.\") \n  } \n\n  println(toInt(\"121\")) \n  println(toInt(\"-199\")) \n  println(toInt(\"+ -199\")) \n} \n```", "```java\nRight(121) \nRight(-199) \nLeft(java.lang.NumberFormatException: For input string: \"+ -199\" occurred, You may want to check the string you passed.) \n```", "```java\nsealed abstract class Either[+A, +B] extends Product with Serializable \nfinal case class Right[+A, +B](value: B) extends Either[A, B] \nfinal case class Left[+A, +B](value: A) extends Either[A, B] \n```", "```java\nEither[String, Int] \n```", "```java\nimport scala.util.{Failure, Success, Try} \n\nobject BankApp extends App { \n\n  val accountHolders = Map( \n    \"1234\" -> AccountInfo(\"Albert\", 1000), \n    \"2345\" -> AccountInfo(\"Bob\", 3000), \n    \"3456\" -> AccountInfo(\"Catherine\", 9000), \n    \"4567\" -> AccountInfo(\"David\", 7000) \n  ) \n\n  def getAccountInfo(id: String): Either[String, AccountInfo] = Try(accountHolders(id)) match { \n    case Success(value) => Right(value) \n    case Failure(excep) => Left(\"Couldn't fetch the AccountInfo, Please Check the id passed or try again!\") \n  } \n\n  def makeTransaction(amount: Double, accountInfo: AccountInfo): Either[String, Double] = Try { \n    if(accountInfo.balance < amount) throw new Exception(\"Not enough account balance!\") else accountInfo.balance - amount \n  } match { \n\n    case Success(value) => Right(value) \n    case Failure(excep) => Left(excep.getMessage) \n  }\n\n  println(getAccountInfo(\"1234\").flatMap(actInfo => makeTransaction(100, actInfo))) \n\n  println(getAccountInfo(\"1234\").flatMap(actInfo => makeTransaction(10000, actInfo))) \n\n  println(getAccountInfo(\"12345\").flatMap(actInfo => makeTransaction(100, actInfo))) \n} \n\ncase class AccountInfo(id: String, balance: Double) \n```", "```java\nRight(900.0) \nLeft(Not enough account balance!) \nLeft(Couldn't fetch the AccountInfo, Please Check the id passed or try again!) \n```", "```java\ndef flatMap[A, B](someValue: Option[A])(functionToPerfom: A => Option[B]): Option[B] = \n  if (someValue.isEmpty) None else functionToPerfom(someValue.get) \n```", "```java\nimport scala.concurrent.Future \n\nobject FuturesApp extends App { \n\n  val futureComp = Future { \n     1 + 1 \n  } \n\n  println(s\"futureComp: $futureComp\") \n\n  futureComp.map(result => println(s\"futureComp: $result\")) \n} \nFuture block and that we are then printing out this Future instance. After that, we're extracting the computation's result out of the Future value and printing it. Looks like it should work fine. Let's run this. We will get the following result:\n```", "```java\nError:(7, 27) Cannot find an implicit ExecutionContext. You might pass \nan (implicit ec: ExecutionContext) parameter to your method \nor import scala.concurrent.ExecutionContext.Implicits.global. \n  val futureComp = Future { \n\nError:(7, 27) not enough arguments for method apply: (implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[Int] in object Future. \nUnspecified value parameter executor. \n  val futureComp = Future { \n```", "```java\ndef apply[T](body: =>T)(implicit executor: ExecutionContext): Future[T] \n```", "```java\nimport scala.concurrent.Future \n\nobject FuturesApp extends App { \n\n  implicit val ctx = scala.concurrent.ExecutionContext.Implicits.global \n\n  val futureComp = Future { \n     1 + 1 \n  } \n\n  println(s\"futureComp: $futureComp\") \n\n  futureComp.map(result => println(s\"futureComp: $result\")) \n} \n```", "```java\nfutureComp: Future(Success(2)) \nfutureComp: 2 \n```", "```java\nimport java.time.{LocalDateTime} \n\nobject ImplicitParameter extends App { \n\n  implicit val dateNow = LocalDateTime.now() \n\n  def showDateTime(implicit date: LocalDateTime) = println(date) \n\n  //Calling functions! \n  showDateTime \n} \n```", "```java\n2017-11-17T10:06:12.321 \n```", "```java\ndef implicitly[T](implicit e: T) = e \n```", "```java\nimport java.time.{LocalDateTime} \n\nobject ImplicitParameter extends App { \n\n  implicit val dateNow = LocalDateTime.now() \n\n  def showDateTime(implicit date: LocalDateTime) = println(date) \n\n  val ldt = implicitly[LocalDateTime] \n\n  println(s\"ldt value from implicit scope: $ldt\") \n} \n```", "```java\nldt value from implicit scope: 2017-12-17T10:47:13.846 \nimplicitly, along with the type, returned us the value available—as we already know, it's the current date-time value.\n```", "```java\nscala> import java.time.LocalDate \nimport java.time.LocalDate \n\nscala> val ld = LocalDate.now \nld: java.time.LocalDate = 2017-12-17 \n\nscala> ld.plusDays(1) \nres0: java.time.LocalDate = 2017-12-18 \n\nscala> ld.plusWeeks(1) \nres1: java.time.LocalDate = 2017-12-24 \n\nscala> ld.plusMonths(1) \nres2: java.time.LocalDate = 2018-01-17 \n\nscala> ld.plusYears(1) \nres3: java.time.LocalDate = 2018-12-17 \n```", "```java\nimport java.time.LocalDate \n\ncase class CustomDate(date: LocalDate) { \n  def +(days: Day): CustomDate = CustomDate(this.date.plusDays(days.num)) \n  def -(days: Day): CustomDate = CustomDate(this.date.minusDays(days.num)) \n\n  def +(weeks: Week): CustomDate = CustomDate(this.date.plusWeeks(weeks.num)) \n  def -(weeks: Week): CustomDate = CustomDate(this.date.minusWeeks(weeks.num)) \n\n  def +(months: Month): CustomDate = CustomDate(this.date.plusMonths(months.num)) \n  def -(months: Month): CustomDate = CustomDate(this.date.minusMonths(months.num)) \n\n  def +(years: Year): CustomDate = CustomDate(this.date.plusYears(years.num)) \n  def -(years: Year): CustomDate = CustomDate(this.date.minusYears(years.num)) \n\n  def till(endDate: CustomDate): CustomDateRange = if(this.date isBefore endDate.date) \n    CustomDateRange(this, endDate) \n  else { \n    throw new IllegalArgumentException(\"Can't create a DateRange with given start and end dates.\") \n  } \n\n  override def toString: String = s\"Date: ${this.date}\" \n} \n\ncase class Day(num: Int) \ncase class Week(num: Int) \ncase class Month(num: Int) \ncase class Year(num: Int) \n\ncase class CustomDateRange(sd: CustomDate, ed: CustomDate){ \n  override def toString: String = s\"$sd till $ed \" \n} \n```", "```java\nimport java.time.LocalDate \n\nobject BeautifulDateApp extends App { \n\n  val today = CustomDate(LocalDate.now()) \n  val tomorrow = today + Day(1) \n  val yesterday = today - Day(1) \n\n  println(today) \n  println(tomorrow) \n  println(today + Year(1)) \n\n  val dateRange = today till tomorrow + Day(20) \n  println(dateRange) \n\n} \n```", "```java\nDate: 2017-12-17 \nDate: 2017-12-18 \nDate: 2018-12-17 \nDate: 2017-12-17 till Date: 2018-01-07 \nLocalDate gives us the feeling that this syntax isn't a part of the standard library we have. So for this, implicits come into the picture. We're going to do a similar syntax hack using the implicit class.\n```", "```java\ncase class Day(num: Int) \ncase class Week(num: Int) \ncase class Month(num: Int) \ncase class Year(num: Int) \n\ncase class CustomDateRange(sd: CustomDate, ed:CustomDate){ \n  override def toString: String = s\"$sd till $ed \" \n} \n\nobject LocalDateOps { \n  implicit class CustomDate(val date: LocalDate) { \n\n    def +(days: Day): CustomDate = CustomDate(this.date.plusDays(days.num)) \n    def -(days: Day): CustomDate = CustomDate(this.date.minusDays(days.num)) \n\n    def +(weeks: Week): CustomDate = CustomDate(this.date.plusWeeks(weeks.num)) \n    def -(weeks: Week): CustomDate = CustomDate(this.date.minusWeeks(weeks.num)) \n\n    def +(months: Month): CustomDate = CustomDate(this.date.plusMonths(months.num)) \n    def -(months: Month): CustomDate = CustomDate(this.date.minusMonths(months.num)) \n\n    def +(years: Year): CustomDate = CustomDate(this.date.plusYears(years.num)) \n    def -(years: Year): CustomDate = CustomDate(this.date.minusYears(years.num)) \n\n    def till(endDate: CustomDate): CustomDateRange = if(this.date isBefore endDate.date) \n      CustomDateRange(this, endDate) \n    else { \n      throw new IllegalArgumentException(\"Can't create a DateRange with given start and end dates.\") \n    } \n\n    override def toString: String = s\"Date: ${this.date}\" \n  } \n} \n```", "```java\nimport java.time.LocalDate \nimport LocalDateOps._ \n\nobject BeautifulDateApp extends App { \n\n  val today = LocalDate.now() \n  val tomorrow = today + Day(1) \n  val yesterday = today - Day(1) \n\n  println(today) \n  println(tomorrow) \n  println(today + Year(1)) \n\n  val dateRange = today till tomorrow + Day(20) \n  println(dateRange) \n} \n```", "```java\n2017-12-17 \nDate: 2017-12-18 \nDate: 2018-12-17 \nDate: 2017-12-17 till Date: 2018-01-07 \n```", "```java\n  val today = LocalDate.now() \n```", "```java\nval tomorrow = today + Day(1) \n```", "```java\nimport scala.concurrent.Future \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nobject FuturesApp extends App { \n\n  val futureComp = Future { \n     1 + 1 \n  } \n\n  println(s\"futureComp: $futureComp\") \n\n  futureComp.map(result => println(s\"futureComp: $result\")) \n} \n```", "```java\nfutureComp: Future(Success(2)) \nfutureComp: 2 \n```", "```java\nimport scala.concurrent.ExecutionContext.Implicits._ \n```", "```java\nimport scala.concurrent.Future \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nobject FuturesApp extends App { \n\n  implicit val ctx = scala.concurrent.ExecutionContext.Implicits.global \n\n  val futureComp = Future { \n     1 + 1 \n  } \n\n  println(s\"futureComp: $futureComp\") \n\n  futureComp.map(result => println(s\"futureComp: $result\")) \n} \n```", "```java\nError:(10, 27) ambiguous implicit values: \n both lazy value global in object Implicits of type => scala.concurrent.ExecutionContext \n and value ctx in object FuturesApp of type => scala.concurrent.ExecutionContext \n match expected type scala.concurrent.ExecutionContext \n  val futureComp = Future { \n```", "```java\ntrait CSVEncoder[T]{ \n  def encode(value: T): List[String] \n} \n```", "```java\ncase class Person(name: String) \n\nCSVEncoder.toCSV(Person(\"Max\")) \n```", "```java\nPerson(\"Caroline\").toCSV \n```", "```java\nobject CSVEncoder { \n\n def toCSV[T](list: List[T])(implicit encoder: CSVEncoder[T]): String = \n  list.map(mem => encoder.encode(mem).mkString(\", \")).mkString(\", \") \n\n} \n```", "```java\nimplicit val personEncoder: CSVEncoder[Person] = new CSVEncoder[Person] { \n  def encode(person: Person) = List(person.name) \n} \n```", "```java\nobject EncoderApp extends App { \n  import CSVEncoder.personEncoder \n\n  println(CSVEncoder.toCSV(List(Person(\"Max Black\"), Person(\"Caroline Channing\")))) \n\n} \n```", "```java\nMax Black, Caroline Channing \n```", "```java\ntrait CSVEncoder[T]{ \n  def encode(value: T): List[String] \n} \n\nobject CSVEncoder { \n\n  def toCSV[T](list: List[T])(implicit encoder: CSVEncoder[T]): String = \n    list.map(mem => encoder.encode(mem).mkString(\", \")).mkString(\", \") \n\n  implicit val personEncoder: CSVEncoder[Person] = new CSVEncoder[Person] {\n     def encode(person: Person) = List(person.name) \n  } \n\n} \n\ncase class Person(name: String) \n\nobject EncoderApp extends App { \n  import CSVEncoder._ \n  import CSVEncoderOps._ \n\n  println(CSVEncoder.toCSV(List(Person(\"Max Black\"), Person(\"Caroline Channing\")))) \n\n  println(List(Person(\"Max Black\"), Person(\"Caroline Channing\")).toCSV) \n} \n\nobject CSVEncoderOps { \n  implicit class CSVEncoderExt[T](list: List[T]) { \n    def toCSV(implicit encoder: CSVEncoder[T]) : String = \n      list.map(mem => encoder.encode(mem).mkString(\", \")).mkString(\", \") \n  } \n} \n```", "```java\nMax Black, Caroline Channing \nMax Black, Caroline Channing \ntoCSV function as a method:\n```", "```java\nList(Person(\"Max Black\"), Person(\"Caroline Channing\")).toCSV \n```", "```java\nimplicit class CSVEncoderExt[T](list: List[T]) { \n    def toCSV(implicit encoder: CSVEncoder[T]) : String = \n      list.map(mem => encoder.encode(mem).mkString(\", \")).mkString(\", \") \n  } \n```"]