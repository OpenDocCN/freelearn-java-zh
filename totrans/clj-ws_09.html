<html><head></head><body>
		<div>
			<div id="_idContainer112" class="Content">
			</div>
		</div>
		<div id="_idContainer113" class="Content">
			<h1 id="_idParaDest-197"><a id="_idTextAnchor235"/>9. Host Platform Interoperability with Java and JavaScript</h1>
		</div>
		<div id="_idContainer166" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will look at interoperability between Clojure and both Java and JavaScript. Clojure runs on top of platforms provided by Java and JavaScript. Clojure was designed to use libraries provided by Java or JavaScript. We will learn how to access Java and JavaScript objects and methods in Clojure. We will also learn how to convert data between Clojure and Java or JavaScript and back. After learning how to access Java and JavaScript from Clojure, we will investigate how to perform Input-Output (I/O) operations like reading and writing to files using Java classes. We will then learn how to deal with errors and exceptions in our code.</p>
			<p class="callout">By the end of this chapter, you will be able to work with the appropriate syntax and semantics to access Java and JavaScript objects and methods from Clojure, and deal with Java exceptions and JavaScript errors.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor236"/>Introduction</h1>
			<p>In the previous chapter, we learned how to create a Leiningen project. A project gives a structure for organizing our code. We structure our project around namespaces. We created new namespaces and we imported external Clojure libraries in order to use them in our code.</p>
			<p>Now that you are familiar with using namespaces and creating Clojure projects, it is time to become more comfortable with working on projects that use Java and JavaScript.</p>
			<p>As we learned in <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL!</em>, Clojure compiles to Java bytecode and operates on the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>). The JVM is a host platform. Any programming language that compiles to Java bytecode can run on the JVM. Because Clojure compiles to Java bytecode and runs on the JVM, we call it a hosted language. Java dates from the 1990s and is now one of the most popular backend languages. We can leverage existing Java libraries instead of writing a lot of code on our own. This helps us deliver new features faster.</p>
			<p>As we will see, importing Java classes in Clojure is a bit different than using Clojure libraries. In this chapter, we will learn how to import and call Java classes in Clojure by writing an application that performs I/O operations—reading and writing from a file.</p>
			<p>In the second part of this chapter, we will look into ClojureScript and JavaScript interoperability. JavaScript is a scripting language that runs in browsers. It is the most popular frontend language at the moment. ClojureScript compiles to JavaScript. In ClojureScript, we can use JavaScript libraries. This gives us access to a huge amount of code written by other developers. A great boost to our productivity.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor237"/>Using Java in Clojure</h1>
			<p>Any code written by a developer needs to be converted to code that is understood by a machine. An interpreter uses code from a developer and compiles it into machine code. Each operating system is different, hence the need for platform-specific compilers and interpreters. One of the reasons why Java is so successful is that it provides the JVM, which takes human-understandable code and converts it into machine code. Developers are not usually interested in the JVM. They can focus on writing code in Java without interacting with the underlying operating system. This job is done by the JVM.</p>
			<p>Clojure is a hosted language. It means that it uses the JVM instead of creating a new runtime environment. Clojure cleverly reuses facilities provided by the JVM. This is a very powerful approach. Things such as garbage collection, threading, concurrency, IO operations (all of which will be explained in the following paragraphs) are JVM battle-tested technologies that Clojure relies on.</p>
			<p>Java garbage collection is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a JVM. When Java programs run on a JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory. We could have a vector with usernames in our program. The usernames are strings. Each string will occupy some space in memory. When we display a list of users on a page, we need this list. When we click on a user and display her profile, we do not need information about other users. We could remove this information from memory so the memory is available for other data.</p>
			<p>In concurrent computing several computations and  operations are executed during overlapping time periods. This is in contrast with sequential programming, where one operation must finish before other operations can start. In sequential computing, an operation to capitalize a vector of usernames must finish before the second operation that finds only admin users can start. In concurrent computing, execution of both operations overlaps. We do not need to wait for one to finish before the second can start.</p>
			<p>A thread is a lightweight process on the JVM. When a computing program uses two or more threads, it runs concurrently. Each part of a program is a separate thread. In our usernames example, one thread will filter usernames for admins while the other thread will capitalize names.</p>
			<p>IO operations are processes that deal with reading from a source, such as a keyboard, and writing to a destination, such as a monitor. Java provides support for a number of sources and destinations. We can read from a text file and write to a printer. Java IO will be covered in this chapter.</p>
			<p>As Clojure developers, we have access to an ecosystem of JVM libraries. Because Java is one of the most popular languages, by targeting JVM, we join a big community. This gives us the benefit of using many well-tested and optimized libraries.</p>
			<p>In order to use existing Java code, we need to import it to our project. Clojure gives us tools to import and operate with Java.</p>
			<p>In the next sections, we will explore tasks such as:</p>
			<ul>
				<li>Importing Java classes</li>
				<li>Creating new instances of Java classes</li>
			</ul>
			<p>We will start with importing Java classes. Clojure provides an <strong class="source-inline">import</strong> function to do this job. This function can import a single class or a number of classes.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor238"/>Exercise 9.01: Importing a Single Java Class in Clojure</h2>
			<p>As we learned in the previous chapter, Clojure code is organized into namespaces. Java organizes its code into packages that contain classes. In this exercise, we will learn how to import packages and Java classes.</p>
			<p>We will explore Java interoperability using a REPL.</p>
			<ol>
				<li>Open a Terminal and add the following command to start the REPL:<p class="source-code">lein repl</p><p>In order to use a Java class, we need to import it. First, we will import a single class. We will start with <strong class="source-inline">BigDecimal</strong> class, which allows us to store very large decimal numbers.</p></li>
				<li>Call the <strong class="source-inline">import</strong> function with the <strong class="source-inline">BigDecimal</strong> class:<p class="source-code">(import 'java.math.BigDecimal)</p><p>This will let us know that the class has been imported: </p><p class="source-code">java.math.BigDecimal</p><p>In Java, we construct an instance of a class using the <strong class="source-inline">new</strong> keyword:</p><p class="source-code">BigDecimal big_number = new BigDecimal("100000");</p><p>Similarly, in Clojure, we can construct an object from the <strong class="source-inline">BigDecimal</strong> class.</p></li>
				<li>Call the <strong class="source-inline">new</strong> function on the <strong class="source-inline">BigDecimal</strong> class to create an instance of it:<p class="source-code">(new BigDecimal "100000")</p><p>Executing the preceding statement in the REPL returns a <strong class="source-inline">BigDecimal</strong> value:</p><p class="source-code">100000M</p></li>
				<li>Often, we want to use a value many times. Storing the value in a variable is a good choice:<p class="source-code">(def big-num (new BigDecimal "100000"))</p><p>Calling an instance of the variable in the REPL will give us the value stored in <strong class="source-inline">BigDecimal</strong>:</p><div id="_idContainer114" class="IMG---Figure"><img src="image/B14502_09_01.jpg" alt="Figure 9.1: Printing the value stored in BigDecimal&#13;&#10;"/></div><p class="figure-caption">Figure 9.1: Printing the value stored in BigDecimal</p><p>Clojure provides a special shorthand symbol for constructing class instances using a dot, <strong class="source-inline">.</strong>. We place a dot after a class name. In these cases, Clojure assumes that we want to construct an instance of a class.</p><p>The preceding example with <strong class="source-inline">BigDecimal</strong> could have been written using dot notation.</p></li>
				<li>Construct a <strong class="source-inline">BigDecimal</strong> instance using dot notation:<p class="source-code">(def big-num (BigDecimal. "100000"))</p><p>Notice the dot after the <strong class="source-inline">BigDecimal</strong> class name:</p><div id="_idContainer115" class="IMG---Figure"><img src="image/B14502_09_02.jpg" alt="Figure 9.2: Printing the BigDecimal value&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.2: Printing the BigDecimal value</p>
			<p>We have seen how to import a class and create an instance of it. Very often, you would want to import more than one class. In the next exercise, we will investigate how to import more than one Java class.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor239"/>Working with Time in Java</h2>
			<p>The Java standard library provides the <strong class="source-inline">java.time</strong> and <strong class="source-inline">java.util</strong> packages, which contain classes that are useful for working with time. Two useful classes are:</p>
			<ul>
				<li><strong class="source-inline">Locale</strong>: A class representing a specific geographical region such as <strong class="source-inline">US</strong> (United States), <strong class="source-inline">FR</strong> (France).</li>
				<li><strong class="source-inline">LocalTime</strong>: A class representing time in the current locale. The local time for Eastern Europe is two hours ahead of Universal time (London).</li>
			</ul>
			<p>In this chapter, we will see examples of manipulating time in Java and Clojure.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor240"/>Exercise 9.02: Importing Multiple Java Classes in Clojure</h2>
			<p>Importing more than one class can be divided into two actions:</p>
			<ul>
				<li>Importing classes from the same package</li>
				<li>Importing classes from different packages</li>
			</ul>
			<p>In order to import more than one class from the same Java package, we will use a vector import:</p>
			<ol>
				<li value="1">Call the <strong class="source-inline">import</strong> function with two classes in a vector:<p class="source-code">(import '[java.math BigDecimal BigInteger])</p><p>Once they are imported, we can use both classes like we have.</p></li>
				<li>Create an instance of the <strong class="source-inline">BigInteger</strong> class:<p class="source-code">(BigInteger. "10000")</p><p>We will see a new <strong class="source-inline">BigInteger</strong> instance created in the REPL:</p><p class="source-code">10000</p></li>
				<li>Create an instance of the <strong class="source-inline">BigDecimal</strong> class:<p class="source-code">(BigDecimal. 100000.5)</p><p>We will see a new <strong class="source-inline">BigInteger</strong> instance created in the REPL:</p><p class="source-code">100000.5M</p><p>If we want to import classes from different packages, we specify their full names, including the package names.</p></li>
				<li>Import the <strong class="source-inline">LocalTime</strong> class from the <strong class="source-inline">time</strong> package and the <strong class="source-inline">Locale</strong> class from the <strong class="source-inline">util</strong> package:<p class="source-code">(import 'java.time.LocalTime 'java.util.Locale)</p><p>Once they are imported, we can construct these classes as we did before.</p></li>
				<li>Create an instance of the <strong class="source-inline">Locale</strong> class using dot notation:<p class="source-code">(L<a id="_idTextAnchor241"/>ocale. "pl")</p><p>The output is as follows:</p><p class="source-code">#object[java.util.Locale 0x50e7be4d "pl"]</p><p>The <strong class="source-inline">LocalTime</strong> class provides static methods to obtain the current time. A static method is a class method. We call it on a class and not on an instance of the class that we create. In Java, we call the class name followed by the method name when we want to use a static method. The static <strong class="source-inline">now</strong> method returns the current time:</p><p class="source-code">LocalTime time = LocalTime.now();</p><p class="source-code">System.out.println(time);</p><p>Here, the static <strong class="source-inline">now</strong> method is called on the <strong class="source-inline">LocalTime</strong> class. The <strong class="source-inline">now</strong> method is a static method in the <strong class="source-inline">LocalTime</strong> class. The <strong class="source-inline">now</strong> method returns the current time. The time is in the format <strong class="source-inline">hour:minutes:seconds.miliseconds</strong>. Since we can run the code at any time, the output will differ in each execution of the code:</p><div id="_idContainer116" class="IMG---Figure"><img src="image/B14502_09_03.jpg" alt="Figure 9.3: Printing the local time&#13;&#10;"/></div><p class="figure-caption">Figure 9.3: Printing the local time</p><p>We can also access static methods from the <strong class="source-inline">LocalTime</strong> class in Clojure. This is done by stating the class followed by a slash and a method name.</p></li>
				<li>Call the static <strong class="source-inline">now</strong> method from the <strong class="source-inline">LocalTime</strong> class using slash notation:<p class="source-code">(LocalTime/now)</p><p>The output is similar to the following:</p><p class="source-code">#object[java.time.LocalTime 0x355f5f59 "23:10:29.761"]</p><p>A Java class can have static fields—fields that belong to a class and not an instance of a class. In Java, we access class fields using a dot. The <strong class="source-inline">LocalTime</strong> class has class fields corresponding to the times of the day: the <strong class="source-inline">NOON</strong> field indicates the middle of the day, 12:00, and the <strong class="source-inline">MIDNIGHT</strong> field indicates the middle of the night, 00:00.</p><p>In order to get the <strong class="source-inline">NOON</strong> field for <strong class="source-inline">LocalTime</strong>, we would write the following:</p><p class="source-code">LocalTime.NOON</p><p>This would give us the following </p><div id="_idContainer117" class="IMG---Figure"><img src="image/B14502_09_04.jpg" alt="Figure 9.4: Printing the NOON value&#13;&#10;"/></div><p class="figure-caption">Figure 9.4: Printing the NOON value</p><p>When we run the code, we are accessing the <strong class="source-inline">NOON</strong> field. In the output, we see that noon is at <strong class="source-inline">12:00</strong>. In Clojure, we use the form with a slash, as we have just seen when we accessed the static <strong class="source-inline">now</strong> method.</p></li>
				<li>Access the static <strong class="source-inline">MIDNIGHT</strong> field from the <strong class="source-inline">LocalTime</strong> class using slash notation:<p class="source-code">(LocalTime/MIDNIGHT)</p><p>The output is as follows:</p><p class="source-code">#object[java.time.LocalTime 0x2712e99d "00:00"]</p><p>When we run the code, we are accessing the <strong class="source-inline">MIDNIGHT</strong> field. In the output, we see that midnight is at <strong class="source-inline">00:00</strong>.</p><p>As we have just seen, accessing static fields and methods with a slash uses the same syntax as the dot.</p><p>If we want to access instance methods, we use the dot operator with a function name. In the following example, we will use the <strong class="source-inline">negate</strong> method on <strong class="source-inline">BigDecimal</strong>, which negates the value of <strong class="source-inline">BigDecimal</strong>.</p></li>
				<li>Call the <strong class="source-inline">negate</strong> function on the <strong class="source-inline">BigDecimal</strong> instance:<p class="source-code">(.negate big-num)</p><p>The output is as follows:</p><p class="source-code">-100000M</p><p>This was an example of calling a function without any arguments. In the following example, we will see how to call an instance method that accepts arguments. The <strong class="source-inline">BigDecimal</strong> class provides an exponentiation method, <strong class="source-inline">pow</strong>, that raises the base to the specified power. In order to calculate the product of the exponentiation of a <strong class="source-inline">BigDecimal</strong> instance, we pass to the power method an integer. </p><p>In Java, we use the <strong class="source-inline">pow</strong> method, as shown in the next step.</p></li>
				<li>First, we will create a <strong class="source-inline">BigDecimal</strong> instance:<p class="source-code">BigDecimal big_num = new BigDecimal("100000");</p></li>
				<li>Then, we will call the <strong class="source-inline">pow</strong> method:<p class="source-code">big_num.pow(2);</p><p>If we printed the call to <strong class="source-inline">pow</strong> method, we would get the following output:</p><p class="source-code">10000000000</p><p>In Clojure, we can also use the <strong class="source-inline">pow</strong> method.</p></li>
				<li>Call the <strong class="source-inline">pow</strong> method on a <strong class="source-inline">BigDecimal</strong> instance:<p class="source-code">(.pow big-num 2)</p><p>This gives us the following:</p><p class="source-code">10000000000M</p></li>
			</ol>
			<p>In t<a id="_idTextAnchor242"/>his exercise, we imported a number of classes from Java packages. We also saw how to call static and instance methods. This allows us to import and use any Java classes that we might need.</p>
			<p>In the next exercise, we will learn about macros, which help us use Java classes in Clojure. Syntax in Clojure is very concise. Code written in Clojure is shorter than code written in Java. One common pattern in Java is calling multiple methods on class instances. The methods are chained together, each operating on the result of the previous method call. Clojure provides macros that simplify this method chaining. We will learn more about macros in <em class="italic">Chapter 11</em>, <em class="italic">Macros</em>. For the purpose of this chapter and learning about Java interoperability, we can think about macros as functions on steroids. One macro that we have used a lot so far is <strong class="source-inline">let</strong>. With <strong class="source-inline">let</strong>, we can create a local variable:</p>
			<p class="source-code">(let [num 2]</p>
			<p class="source-code">  (+ 3 num))</p>
			<p>In this example, <strong class="source-inline">let</strong> allows us to define a variable, <strong class="source-inline">num</strong>, with a value of <strong class="source-inline">2</strong>. The plus function adds <strong class="source-inline">3</strong> to our variable. Both <strong class="source-inline">let</strong> and <strong class="source-inline">+</strong> are the first elements in their lists. We can see that the use of the <strong class="source-inline">let</strong> macro and the plus function is similar.</p>
			<p>Clojure macros help us simplify code. We will learn about macros in depth in <em class="italic">Chapter 11</em>, <em class="italic">Macros</em>. In the meantime, we will see what macros we can use to simplify Java interoperability. </p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor243"/>Exercise 9.03: Macros That Help Us Use Java in Clojure</h2>
			<p>In this exercise, we will find out the difference in seconds between our time zone and the target zone in London (UTC). In order to do this, we will use two Java classes from the <strong class="source-inline">time</strong> package. We will chain method calls to get the result.</p>
			<p>The <strong class="source-inline">ZonedDateTime</strong> class contains information about the date and time in specific time zones. If we live in India, this class allows us to get the current date and time in India as opposed to the current time in London (UTC).</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">ZonedDateTime</strong> class:<p class="source-code">(import 'java.time.ZonedDateTime)</p></li>
				<li>Get an instance of <strong class="source-inline">ZonedDateTime</strong>: <p class="source-code">(ZonedDateTime/now)</p><p>The output is as follows:</p><p class="source-code">#object[java.time.ZonedDateTime 0x1572c67a "2019-10-05T18:00:27.814+02:00[Europe/Warsaw]"]</p><p>In this example, the time zone is in Central Europe in Warsaw.</p></li>
				<li>Use <strong class="source-inline">getOffset</strong> from <strong class="source-inline">ZonedDateTime</strong>. This will tell us the time difference between our time zone and the UTC zone:<p class="source-code">(. (ZonedDateTime/now) getOffset)</p><p>The output is as follows:</p><p class="source-code">#object[java.time.ZoneOffset 0x362c5bf1 "+02:00"]</p><p>Please note that the preceding statement can be written as follows:</p><p class="source-code">(.getOffset (ZonedDateTime/now))</p><p>The statements are equivalent. It is a matter of preference regarding which one to use. Most Clojure code uses the <strong class="source-inline">.getOffset</strong> function call, though it is good to know the other form in case you ever see it. The time difference between Central Europe and London (UTC) is two hours (+2).</p></li>
				<li>Now that we know the time difference between the zones, we can get this value in seconds:<p class="source-code">(. (. (ZonedDateTime/now) getOffset) getTotalSeconds)</p><p>The output is as follows:</p><p class="source-code">7200</p><p>In the output, we see that the time difference between Central Europe and London is 7,200 seconds. Depending on where you live, the output might differ. What is important here is that the method chaining looks verbose. We have two dot operators and some parentheses. This already looks confusing, and with more method chaining, it will be even more confusing. Luckily, Clojure provides a convenience <strong class="source-inline">..</strong> (dot-dot) macro for method chaining.</p><p>This example can be rewritten using the dot-dot macro.</p></li>
				<li>Get the time difference in seconds from <strong class="source-inline">ZonedDateTime</strong> using the dot-dot macro:<p class="source-code">(.. (ZonedDateTime/now) getOffset getTotalSeconds)</p><p>The output is as follows:</p><p class="source-code">7200</p><p>The output is the same. The method calls are much easier to read. Whenever you need to chain methods on Java objects, the dot-dot macro will simplify the code.</p><p>This was an example of calling methods on different objects. Clojure provides a <strong class="source-inline">doto</strong> macro for situations where we want to call methods on the same instance of a Java class.</p><p>It is common in Java to write a code where it is necessary to make a lot of modifications to strings of characters. Consider a situation where we have an auto finder on a website. Whenever we type a new character, we need to create a new string. With constant typing, this would mean creating many string objects. Such objects would occupy lots of memory space. With <strong class="source-inline">StringBuffer</strong>, we create one instance and we can add characters to this instance. This saves a lot of memory compared to having string objects.</p><p>In Java, we could use <strong class="source-inline">StringBuffer</strong> in the following way:</p><p class="source-code">StringBuffer string = new StringBuffer("quick");</p><p class="source-code">        string.append("brown");</p><p class="source-code">        string.append("fox");</p><p class="source-code">        string.append("jumped");</p><p class="source-code">        string.append("over");</p><p class="source-code">        string.append("the");</p><p class="source-code">        string.append("lazy");</p><p class="source-code">        string.append("dog");</p></li>
				<li>In Clojure, a sentence can be constructed by calling the append method on the <strong class="source-inline">StringBuffer</strong> class as follows:<p class="source-code">(let [string (StringBuffer. "quick")]</p><p class="source-code">     (.append string " brown")</p><p class="source-code">     (.append string " fox")</p><p class="source-code">     (.append string " jumped")</p><p class="source-code">     (.append string " over")</p><p class="source-code">     (.append string " the")</p><p class="source-code">     (.append string " lazy")</p><p class="source-code">     (.append string " dog")</p><p class="source-code">     (.toString string))</p><p>The output we get is a sentence:</p><p class="source-code">"quick brown fox jumped over the lazy dog"</p><p>There is a repetition of the word <strong class="source-inline">string</strong>. The <strong class="source-inline">doto</strong> macro eliminates this duplication. The <strong class="source-inline">doto</strong> macro will implicitly call functions on instances that we specify. The preceding code can be rewritten using <strong class="source-inline">doto</strong>.</p></li>
				<li>Construct a sentence using <strong class="source-inline">StringBuffer</strong> and the <strong class="source-inline">doto</strong> macro:<p class="source-code"> (let [string (StringBuffer. "quick")]</p><p class="source-code">     (doto string</p><p class="source-code">           (.append " brown")</p><p class="source-code">           (.append " fox")</p><p class="source-code">           (.append " jumped")</p><p class="source-code">           (.append " over")</p><p class="source-code">           (.append " the")</p><p class="source-code">           (.append " lazy")</p><p class="source-code">           (.append " dog"))</p><p class="source-code">     (.toString string))</p><p>The output is the following sentence:</p><p class="source-code">"quick brown fox jumped over the lazy dog"</p><p>In this example, we eliminated code duplication. With the <strong class="source-inline">doto</strong> macro, we called methods on an instance of <strong class="source-inline">StringBuffer</strong>. Once we were done, we converted the instance to a string.</p></li>
			</ol>
			<p>In this exercise, we looked at two helpful macros for situations when we need to work with Java classes. Often, we call many methods. The <strong class="source-inline">doto</strong> and <strong class="source-inline">dot-dot</strong> macros allow us to simplify code that has multiple method calls.</p>
			<p>In the next topic, we will use our new knowledge of calling Java classes in Clojure. We will look into Java IO operations. Then, we will create a coffee-ordering application that performs file manipulations.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor244"/>Working with Java I/O</h1>
			<p>I/O deals with reading data from a source and writing data to a destination. These are some of the most common activities that programs do. Source and destination are very broad concepts. You could read from a file or a keyboard and display data on a monitor. You could read from a database and write to an API serving data. Java provides classes for many sources and destinations for reading and writing data.</p>
			<p>In this topic, we will look at the most common I/O cases:</p>
			<ul>
				<li>Reading and writing to a file</li>
				<li>Reading from a keyboard and writing to a monitor</li>
			</ul>
			<p>We have already worked with I/O without realizing it. Whenever we start the REPL and type on the keyboard, we perform write operations. Similarly, all function calls in the REPL print to the monitor, performing output operations.</p>
			<p>I/O is a huge and difficult topic. Even the people that created Java did not get it right in the beginning, as we can see from the number of classes and packages for I/O. We have the <strong class="source-inline">java.io</strong> package and the <strong class="source-inline">java.nio</strong> (new IO) package. The <strong class="source-inline">java.io</strong> package contains classes for working with input and output in Java. This package has methods for reading from sources such as the keyboard and displaying to destinations such as a printer or a screen. While the <strong class="source-inline">java.io</strong> package contains many useful classes, it is considered complicated. In order to write I/O code, we have to use many classes. The newer package, <strong class="source-inline">java.nio</strong> (new I/O), introduces new I/O classes that simplify working with input and output in Java.</p>
			<p>Java has many I/O classes because there are many scenarios for using input and output. We will see the <strong class="source-inline">PushbackReader</strong> class in action. This class allows us to read ahead a few characters to see what is coming, before we determine how to interpret the current character. This is useful when we want to read and interpret data by taking into account what other data is in the file.</p>
			<p>Luckily for us, Clojure is a very pragmatic language and provides tools to work with I/O. Clojure has a <strong class="source-inline">with-open</strong> macro that helps us to work with files. Opening a file, or, to be more precise, any stream of data, uses computer resources such as CPU and RAM. After finishing reading from a file, we want to free these resources so they are available for other tasks. The <strong class="source-inline">with-open</strong> macro closes the opened stream, thus freeing up the resources. Closing resources is done automatically, and we do not need to think about closing resources ourselves. This prevents our application from slowing down or even crashing if we have many opened resources that are not used.</p>
			<h2 id="_idParaDest-205">Immu<a id="_idTextAnchor245"/>tability in Clojure</h2>
			<p>In <em class="italic">Chapter 2</em>, <em class="italic">Data Types and Immutability</em>, we learned about immutability. Clojure defaults to immutability. We do not alter data structures but create new structures based on existing data. For example, information about employees that is stored in a map is updated by creating a new map of employees with the necessary changes. The original map of employees is intact and available if we need it. As we have learned, this approach prevents many bugs in Clojure when we want to access one data structure from many places. </p>
			<p>There are times, however, when we want to mutate data. We want to run an application by default and stop it when the user selects the exit option. Ref is one of Clojure's concurrency primitives. We will learn more about concurrency in Clojure in <em class="italic">Chapter 12</em>, <em class="italic">Concurrency</em>. Now, all we need to know is that with <strong class="source-inline">ref</strong> we can change the value of data. We will use ref to control the state of an application that we will shortly create.</p>
			<p>In the next two exercises, we will create a coffee-ordering app. During the development process, we will have the opportunity to work with I/O operations such as file reading and writing. We will start by creating a new Leiningen project for the frontend part of the application. We will display the coffee menu and handle user choices.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor246"/>Exercise 9.04: Coffee-Ordering Application – Displaying a Menu</h2>
			<p>In this chapter, we have seen how to use Java classes in Clojure. The aim of this exercise is to extend our knowledge of Clojure and Java. We will create a coffee-ordering app. </p>
			<p>The app will have the following features:</p>
			<ul>
				<li>Display the coffee menu</li>
				<li>Be able to order coffee (type and quantity)</li>
				<li>Display order confirmation</li>
			</ul>
			<p>Once we finish the application, we will be able to place orders and display them:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B14502_09_05.jpg" alt="Figure 9.5: The coffee application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5: The coffee application</p>
			<ol>
				<li value="1">Open the Terminal and create a new Leiningen project:<p class="source-code">lein new app coffee-app</p><p>This will create a Leiningen project that's similar to the one we investigated in the previous chapter.</p><p>In this application, we will get user input from a keyboard. To help us, we will use a Java class called <strong class="source-inline">Scanner</strong> from the <strong class="source-inline">java.util</strong> package.</p></li>
				<li>Import namespaces to the <strong class="source-inline">core.clj</strong> file:<p class="source-code">(ns coffee-app.core</p><p class="source-code">    (:require [coffee-app.utils :as utils])</p><p class="source-code">    (:import [java.util Scanner])</p><p class="source-code">    (:gen-class))</p><p>We have imported the <strong class="source-inline">Scanner</strong> class. This class allows us to get input from a keyboard. In order to use methods from <strong class="source-inline">Scanner</strong>, we need to create an instance of this class.</p><p>We also imported the <strong class="source-inline">coffee-app.utils</strong> namespace, where we will have utility functions.</p></li>
				<li>We will store the menu in a hash. A hash is a Clojure collection that we learned about in <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL</em> ! In the hash, we use a coffee type such as <strong class="source-inline">:latte</strong> as the key. The value of the key is the price:<p class="source-code">(def ^:const price-menu {:latte 0.5 :mocha 0.4})</p><p>In the price menu, the price for <strong class="source-inline">mocha</strong> is <strong class="source-inline">0.4</strong>.</p></li>
				<li>Create an instance of the <strong class="source-inline">Scanner</strong> class:<p class="source-code">(def input (Scanner. System/in))</p><p>We will call methods on this class instance when we want to get input from a user. The <strong class="source-inline">Scanner</strong> class needs to know the source of the input. In our case, we use the default in source from the <strong class="source-inline">System</strong> class – keyboard. When a user runs the application, they should see a menu with options. The options are displaying and ordering coffees, listing orders, and exiting the application:</p><div id="_idContainer119" class="IMG---Figure"><img src="image/B14502_09_06.jpg" alt="Figure 9.6: Options of the coffee application&#13;&#10;"/></div><p class="figure-caption">Figure 9.6: Options of the coffee application</p></li>
				<li>Add the code for displaying the menu and handling user choices:<p class="source-code">(defn- start-app []</p><p class="source-code">       "Displaying main menu and processing user choices."</p><p class="source-code">       (let [run-application (ref true)]</p><p class="source-code">            (while (deref run-application)</p><p class="source-code">                   (println "\n|     Coffee app         |")</p><p class="source-code">                   (println "| 1-Menu 2-Orders 3-Exit |\n")</p><p class="source-code">                   (let [choice (.nextInt input)]</p><p class="source-code">                        (case choice</p><p class="source-code">                              1 (show-menu)</p><p class="source-code">                              2 (show-orders)</p><p class="source-code">                              3 (dosync (ref-set run-application false)))))))</p></li>
				<li>In the <strong class="source-inline">start-app</strong> function, we set the application to run by default:<p class="source-code">run-application (ref true)</p><p class="source-code">(while (deref run-application)</p><p>Concurrency primitives are special. In order to get the values stored in them, we use the <strong class="source-inline">deref</strong> function. </p></li>
				<li>Inside the <strong class="source-inline">while</strong> block, the application runs until the user chooses the exit option. In this case, we will update the value of <strong class="source-inline">ref</strong>:<p class="source-code">(dosync (ref-set run-application false))</p><p>After updating, <strong class="source-inline">ref</strong> is false. The <strong class="source-inline">while</strong> block will stop when the value of ref is <strong class="source-inline">false</strong> and our application will exit.</p></li>
				<li>When our application runs, the user can choose options from the menu:<p class="source-code">(println "\n|     Coffee app         |")</p><p class="source-code">(println "| 1-Menu 2-Orders 3-Exit |\n")</p><p>This will display the following menu:</p><div id="_idContainer120" class="IMG---Figure"><img src="image/B14502_09_07.jpg" alt="Figure 9.7: Choosing the options&#13;&#10;"/></div><p class="figure-caption">Figure 9.7: Choosing the options</p><p>We are able to display the initial menu. We can work on handling user choices from the menu.</p></li>
				<li>In order to get the user response, we call the <strong class="source-inline">nextInt</strong> method from the <strong class="source-inline">Scanner</strong> instance:<p class="source-code">choice (.nextInt input)</p></li>
				<li>Finally, once we get the user input, we check which option from the menu should be executed:<p class="source-code">(case choice</p><p class="source-code">        1 (show-menu)</p><p class="source-code">        2 (show-orders))</p><p>We now know the logic in the main application menu when we start the app. It is time to dig deeper and see the code for the <strong class="source-inline">show-menu</strong> function.</p></li>
				<li>Display the menu:<p class="source-code">(defn- show-menu []</p><p class="source-code">       (println "| Available coffees |")</p><p class="source-code">       (println "|1. Latte   2.Mocha |")</p><p class="source-code">       (let [choice (.nextInt input)]</p><p class="source-code">            (case choice</p><p class="source-code">                  1 (buy-coffee :latte)</p><p class="source-code">                  2 (buy-coffee :mocha))))</p></li>
				<li>In the <strong class="source-inline">show-menu</strong> function, we let the user know about the two available coffees, latte and mocha: <p class="source-code">(println "| Available coffees |")</p><p class="source-code">(println "|1. Latte   2.Mocha |")</p><p>This will display the coffee menu:</p><div id="_idContainer121" class="IMG---Figure"><img src="image/B14502_09_08.jpg" alt="Figure 9.8: Displaying the coffee menu&#13;&#10;"/></div><p class="figure-caption">Figure 9.8: Displaying the coffee menu</p><p>We need to respond to the user's coffee choice now.</p></li>
				<li>We use a <strong class="source-inline">Scanner</strong> instance to get the user input:<p class="source-code">choice (.nextInt input)</p></li>
				<li>Finally, we proceed to buying the coffee that the user chose:<p class="source-code">(case choice</p><p class="source-code">       1 (buy-coffee :latte)</p><p class="source-code">       2 (buy-coffee :mocha))</p><p>The <strong class="source-inline">show-menu</strong> function is not long. Its purpose is to display the available coffees and get the user input. Once the user has chosen, we call the <strong class="source-inline">buy-coffee</strong> function to handle buying the selected coffee.</p></li>
				<li>Ask the user how many coffees they want:<p class="source-code">(defn- buy-coffee [type]</p><p class="source-code">       (println "How many coffees do you want to buy?")</p><p class="source-code">       (let [choice (.nextInt input)</p><p class="source-code">             price (utils/calculate-coffee-price price-menu type choice)]</p><p class="source-code">            (utils/display-bought-coffee-message type choice price)))</p><p>The <strong class="source-inline">buy-coffee</strong> function asks how many coffees user wants to buy. Again, we use an instance of the Scanner class – <strong class="source-inline">input</strong> – to get the user's choice. Next, the function calls two utility functions to process buying. The functions are responsible for calculating the coffee price and displaying a feedback message to the user.</p><p>All the functions will be placed in the <strong class="source-inline">utils.clj</strong> file. Instead of having all the functions in one big file, it is a good practice to split functions into various namespaces. A common namespace name is <strong class="source-inline">utils</strong>. We can keep any useful functions that operate on data there.</p></li>
				<li>Create the <strong class="source-inline">utils</strong> namespace:<p class="source-code">(ns coffee-app.utils) </p><p>Because the methods that we place in this namespace perform I/O operations, we could have called this namespace <strong class="source-inline">coffee-app.io</strong>. In our case, both names for namespaces, <strong class="source-inline">utils</strong> and <strong class="source-inline">io</strong>, are valid. In much bigger applications, it is common to split the <strong class="source-inline">utils</strong> namespace into different namespaces.</p></li>
				<li> Calculate the coffee price:<p class="source-code">(defn calculate-coffee-price [coffees coffee-type number]</p><p class="source-code">      (-&gt;</p><p class="source-code">        (get coffees coffee-type)</p><p class="source-code">        (* number)</p><p class="source-code">        float))</p><p>Our first utility function calculates the coffee price. It uses the get function to check the <strong class="source-inline">coffees</strong> hash for the passed coffee type. The hash was defined in the core namespace. The value obtained from the hash is then multiplied by the number of coffee cups that the user ordered. Finally, we convert the number to a float. This allows us to convert numbers such as <strong class="source-inline">1.2000000000000002</strong> to <strong class="source-inline">1.2</strong>.</p><p>The last utility function used when we handle buying coffee is the <strong class="source-inline">display-bought-coffee-message</strong> function.</p></li>
				<li>Display a message to the user after buying coffee:<p class="source-code">(ns coffee-app.utils)</p><p class="source-code">(defn display-bought-coffee-message [type number total]</p><p class="source-code">      (println "Buying" number (name type) "coffees for total:€" total))</p><p>The <strong class="source-inline">display-bought-coffee-message</strong> function takes an order map and constructs a string message for a user based on the data from a map. The user is informed that they have bought a certain number of coffee cups for a specified price.</p><p>With this function, we can control the information passed back to the user after completing the order:</p><p class="source-code">Buying 2 latte coffees for total:€ 1.0</p><p>The second option from the main menu allows us to see placed orders:</p><div id="_idContainer122" class="IMG---Figure"><img src="image/B14502_09_09.jpg" alt="Figure 9.9: Option 2 to see placed orders&#13;&#10;"/></div><p class="figure-caption">Figure 9.9: Option 2 to see placed orders</p><p>The function responsible for displaying orders is <strong class="source-inline">show-orders</strong> from the <strong class="source-inline">coffee-app.core</strong> namespace.</p></li>
				<li>Display placed orders:<p class="source-code">(ns coffee-app.core)</p><p class="source-code">(defn- show-orders []</p><p class="source-code">       (println "\n")</p><p class="source-code">       (println "Display orders here"))</p><p>This function displays the coffee orders placed. In this exercise, we inform the user that orders will be displayed here. In the following exercise, we will implement saving and displaying orders:</p><p class="source-code">Display orders here</p><p>When we run the application and buy two cups of latte, we will see the following output:</p><div id="_idContainer123" class="IMG---Figure"><img src="image/B14502_09_10.jpg" alt="Figure 9.10: Output displaying placed orders&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.10: Output displaying placed orders</p>
			<p>In this exercise, we learned how to work with I/O and Java in Clojure. We created a coffee-ordering application that allowed us to see the coffee menu and order coffees. </p>
			<p>In the next exercise, we will extend this application and implement saving coffee orders and retrieving orders.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor247"/>Exercise 9.05: Coffee-Ordering Application – Saving and Loading Orders</h2>
			<p>The aim of this exercise is to extend our I/O knowledge. We will learn how to save and read from files. We will extend the coffee-ordering application to save data to a file and read data from a file.</p>
			<p>The application will have the following features:</p>
			<ul>
				<li>Saving orders</li>
				<li>Retrieving orders</li>
				<li>Displaying saved orders</li>
			</ul>
			<p>Once we finish the application, we will be able to display orders:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B14502_09_11.jpg" alt="Figure 9.11: Output for placed orders&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11: Output for placed orders</p>
			<p>The main features of this application are saving and loading orders. We will create utility functions for this purpose:</p>
			<ol>
				<li value="1">In order to work with file I/O, we need to import I/O namespaces:<p class="source-code">(ns coffee-app.utils</p><p class="source-code">    (:require [clojure.java.io :as io])</p><p class="source-code">    (:import [java.io PushbackReader]))</p><p>We will use the <strong class="source-inline">PushbackReader</strong> Java class to read a file. We will also use utilities from the Clojure I/O library.</p></li>
				<li>The first function that we will implement will save data to a file:<p class="source-code">(defn save-to [location data]</p><p class="source-code">      (spit location data :append true))</p><p>The <strong class="source-inline">spit</strong> function is a Clojure I/O function that writes to a specified file location. With the <strong class="source-inline">:append</strong> keyword set to true, data that we want to store will be appended to existing data. Otherwise, every time we save data, new data will override the existing file content. After saving a file, we want to retrieve data from it.</p></li>
				<li>In order to retrieve data from a file, we need to make sure that the file exists:<p class="source-code">(defn file-exists? [location]</p><p class="source-code">      (.exists (io/as-file location)))</p><p>The <strong class="source-inline">file-exists?</strong> function calls an I/O function, <strong class="source-inline">as-file</strong>, that returns <strong class="source-inline">java.io.File</strong>. Then, we call the <strong class="source-inline">exists</strong> function to check whether we have a file in the requested location. The return value of the <strong class="source-inline">file-exists</strong> function is a Boolean value. If a file exists, we get <strong class="source-inline">true</strong>:</p><div id="_idContainer125" class="IMG---Figure"><img src="image/B14502_09_12.jpg" alt="Figure 9.12: Function output as true for file_exists?&#13;&#10;"/></div><p class="figure-caption">Figure 9.12: Function output as true for file_exists?</p><p>If the file does not exist, we get <strong class="source-inline">false</strong>:</p><div id="_idContainer126" class="IMG---Figure"><img src="image/B14502_09_13.jpg" alt="Figure 9.13: Function output as false for file_exists?&#13;&#10;"/></div><p class="figure-caption">Figure 9.13: Function output as false for file_exists?</p><p>Once we know that a file exists, we can load the saved orders.</p></li>
				<li>We will need to load orders from a file:<p class="source-code"> (defn load-orders</p><p class="source-code">  "Reads a sequence of orders stored in file."</p><p class="source-code">  [file]</p><p class="source-code">  (if (file-exists? file)</p><p class="source-code">    (with-open [r (PushbackReader. (io/reader file))]</p><p class="source-code">                      (binding [*read-eval* false]</p><p class="source-code">                       (doall (take-while #(not= ::EOF %) (repeatedly #(read-one-order r))))))</p><p class="source-code">  []))</p><p>The <strong class="source-inline">load-orders</strong> function takes a filename as a parameter. We call the <strong class="source-inline">file-exists?</strong> function to check whether we have a file in the requested location. The return value of the <strong class="source-inline">file-exists?</strong> function is used in an <strong class="source-inline">if</strong> block in the <strong class="source-inline">load-orders</strong> function. If we do not have a file, we return an empty vector. If we have a file, we will read its content.</p><p>We use the <strong class="source-inline">with-open</strong> macro to read from a file. The macro will automatically handle closing a file once we finish reading. This will free up computer resources for us. We use the <strong class="source-inline">PushbackReader</strong> class to read from a file. This class allows us to read ahead a few characters to see what is coming before you can determine how to interpret the current character. Our plan is to read orders until we reach the end of the file, marked by the <strong class="source-inline">::EOF</strong> keyword. We repeatedly read one order.</p><p>We have changed the binding for <strong class="source-inline">read-eval</strong> to <strong class="source-inline">false</strong>. It is not secure to read from a file that we do not know. By default, <strong class="source-inline">read-eval</strong> is set to <strong class="source-inline">true</strong>. This means that any data that we read can be evaluated. User data or files sent over a network should never be trusted. The data that we work with can contain malicious code.  When we manipulate data in Clojure, the data should always be read without evaluating the content of the data.</p></li>
				<li>We will use the <strong class="source-inline">read</strong> function from the <strong class="source-inline">clojure.java.io</strong> namespace to read each line in the orders file:<p class="source-code"> (defn read-one-order [r]</p><p class="source-code">  (try</p><p class="source-code">    (read r)</p><p class="source-code">  (catch java.lang.RuntimeException e</p><p class="source-code">    (if (= "EOF while reading" (.getMessage e))</p><p class="source-code">      ::EOF</p><p class="source-code">      (throw e)))))</p><p>Once we reach the end of the file, a Java error is thrown and we catch this error. Upon catching the error, we return the <strong class="source-inline">::EOF</strong> keyword, which instructs our while loop to stop reading from the file. We will learn more about exceptions in Java later on in this chapter. We have our utility functions to save and load data to a file. We are ready to use these functions.</p></li>
				<li>Save the coffee order. The <strong class="source-inline">save-to</strong> function is used to save a coffee order:<p class="source-code"> (defn save-coffee-order [orders-file type number price]</p><p class="source-code">  (save-to orders-file {:type type :number number :price price}))</p><p>The <strong class="source-inline">save-coffee-order</strong> function takes the names of files in which to save data, the coffee type, the number of cups of coffee, and the price of the order as parameters.</p><p>Using this data, we construct a map that we pass to the <strong class="source-inline">save-to</strong> function. The <strong class="source-inline">save-to</strong> function will save data to the file that we specify.</p><p>After implementing the ability to save coffee orders, we can use this function when we handle buying coffee.</p></li>
				<li>Handle buying coffee. The <strong class="source-inline">buy-coffee</strong> function will be responsible for calculating the coffee price, saving the coffee order, and displaying the feedback message to the user:<p class="source-code">(ns coffee-app.core)</p><p class="source-code">(defn buy-coffee [type]</p><p class="source-code">       (println "How many coffees do you want to buy?")</p><p class="source-code">       (let [choice (.nextInt input)</p><p class="source-code">             price (utils/calculate-coffee-price price-menu type choice)]</p><p class="source-code">            (utils/save-coffee-order orders-file type choice price)</p><p class="source-code">            (utils/display-bought-coffee-message type choice price)))</p><p>In the <strong class="source-inline">buy-coffee</strong> function, we ask how many coffees the user wants to buy. We use an instance of the Scanner class – <strong class="source-inline">input</strong> – to get the user's choice. Next, the function calls three utility functions to process buying.</p><p>After we calculate the order price, we save the order and finally display information to the user about the order placed. After placing an order, we are ready to load orders in order to display them in the menu.</p></li>
				<li>We will show orders using the <strong class="source-inline">show-orders</strong> function:<p class="source-code">(def ^:const orders-file "orders.edn")</p><p class="source-code">(defn show-orders []</p><p class="source-code">       (println "\n")</p><p class="source-code">       (doseq [order (utils/load-orders orders-file)]</p><p class="source-code">              (println (utils/display-order order))))</p><p>In the <strong class="source-inline">show-orders</strong> function, we get orders from the orders file. We iterate over a sequence of orders using <strong class="source-inline">doseq</strong>. With <strong class="source-inline">doseq</strong>, for each order, we will call the <strong class="source-inline">display-order</strong> function.</p></li>
				<li>Data for displaying an order is constructed from an order passed as a parameter to the <strong class="source-inline">display-order</strong> function:<p class="source-code">(defn display-order [order]</p><p class="source-code">      (str "Bought " (:number order) " cups of " (name (:type order)) " for €" (:price order)))</p><p>The <strong class="source-inline">display-order</strong> function creates a string from an order map. We access information about the number of cups bought, the type of coffee bought, and the price of the order.</p><p>After ordering two coffees, we will have the following output:</p><div id="_idContainer127" class="IMG---Figure"><img src="image/B14502_09_14.jpg" alt="Figure 9.14: Output for the display-order function&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.14: Output for the display-order function</p>
			<p>In this exercise, we extended our coffee-ordering application. We added functionality to save orders to a file and load data from the file. While implementing these features, we learned more about Java I/O. These features improved our coffee-ordering application.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor248"/>Working with Java Data Types</h2>
			<p>A data type refers to how data is classified. Any variable or object in Java has a specific type. In this book, we have seen types such as strings ("<strong class="source-inline">Paris</strong>"), Booleans (<strong class="source-inline">true</strong>, <strong class="source-inline">false</strong>), numbers (<strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>) and collections (<strong class="source-inline">[:one :two :three]</strong>).</p>
			<p>Clojure reuses some of the most common Java data types, such as strings and numbers. This is a good approach because Java types have been tested by many developers in their code since Java was created in the 90s. This gives us confidence when using Java data types. There are some types that are not directly present in Clojure. In such cases, we use Java interoperability in Clojure to access Java data types.</p>
			<p>When writing applications in Clojure, we can use the data types that we have learned about in this book. We can also use data types if we know them from Java. In the previous exercises, we learned how to use access methods in Java classes. We know how to work with classes now.</p>
			<p>In the next exercise, we will learn how to work with Java collections in Clojure. Java provides collections such as <strong class="source-inline">ArrayList</strong> and <strong class="source-inline">HashMap</strong>:</p>
			<ul>
				<li><strong class="source-inline">ArrayList</strong> is like a Clojure vector. Elements in an <strong class="source-inline">ArrayList</strong> are stored in sequential order.</li>
				<li><strong class="source-inline">HashMap</strong> is like a Clojure hash. Elements in a <strong class="source-inline">HashMap</strong> are stored as key/value pairs.</li>
			</ul>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor249"/>Exercise 9.06: Java Data Types</h2>
			<p>The aim of this exercise is to learn how to work with Java data types in Clojure. Often, when we work in Clojure we rely on external libraries. There are many Java libraries. Knowing how to use Java data types will help us to use Java libraries efficiently. In this exercise, we will work on a part of a geography application. The application stores information such as countries, capitals, and rivers as Java collections. We will write code to convert between Java and Clojure collections:</p>
			<ol>
				<li value="1">Start the REPL using the following command:<p class="source-code">lein repl</p><p>It will start as follows:</p><div id="_idContainer128" class="IMG---Figure"><img src="image/B14502_09_15.jpg" alt="Figure 9.15: Output for the REPL&#13;&#10;"/></div><p class="figure-caption">Figure 9.15: Output for the REPL</p></li>
				<li>We will create a vector containing some capitals:<p class="source-code">(def capitals ["Berlin" "Oslo" "Warszawa" "Belgrad"])</p></li>
				<li>Check the <strong class="source-inline">capitals</strong> vector:<p class="source-code">capitals</p><p>The output is as follows:</p><p class="source-code">["Berlin" "Oslo" "Warszawa" "Belgrad"]</p></li>
				<li>We can check the class of our <strong class="source-inline">capitals</strong> vector:<p class="source-code">(class capitals)</p><p>The output is as follows:</p><p class="source-code">clojure.lang.PersistentVector</p><p>We see that <strong class="source-inline">capitals</strong> is a <strong class="source-inline">PersistentVector</strong> from Clojure.</p></li>
				<li>Using Clojure's vector, we can create an <strong class="source-inline">ArrayList</strong> in Java:<p class="source-code">(def destinations (java.util.ArrayList. capitals))</p><p>We created an <strong class="source-inline">ArrayList</strong> from a vector. We can check it as follows:</p><p class="source-code">destinations</p><p>The output is as follows:</p><p class="source-code">["Berlin" "Oslo" "Warszawa" "Belgrad"]</p></li>
				<li>We can check the class for our <strong class="source-inline">destinations</strong> array:<p class="source-code">(class destinations)</p><p>The output is as follows:</p><p class="source-code">java.util.ArrayList</p><p>The destinations variable has the <strong class="source-inline">ArrayList</strong> class from Java. We just converted from Clojure to Java. We converted the <strong class="source-inline">capitals</strong> vector to the <strong class="source-inline">destinations</strong> <strong class="source-inline">ArrayList</strong>.</p></li>
				<li>We can also convert the other way. We can convert from Java to Clojure as follows:<p class="source-code">(vec destinations)</p><p>The <strong class="source-inline">vec</strong> function from the Clojure core library allows us to convert from <strong class="source-inline">ArrayList</strong> to a vector.</p></li>
				<li>We can check the class of our newly converted data:<p class="source-code">(class (vec destinations))</p><p>The output is as follows:</p><p class="source-code">clojure.lang.PersistentVector</p><p>When we convert from <strong class="source-inline">ArrayList</strong> to a vector, we get the <strong class="source-inline">PersistentVector</strong> class in Clojure.</p></li>
				<li>We were able to convert back and forth from Java to Clojure using an ArrayList and a vector. Clojure has another collection type that stores data. A hash stores data in a key/value pair:<p class="source-code">(def fluss {"Germany" "Rhein" "Poland" "Vistula" })</p></li>
				<li>We defined a hash containing countries and rivers (fluss in German) in those countries:<p class="source-code">fluss</p><p>The output is as follows:</p><p class="source-code">{"Germany" "Rhein" "Poland" "Vistula" }</p></li>
				<li>We can check the <strong class="source-inline">fluss</strong> variable's class:<p class="source-code">(class fluss)</p><p>The output is as follows:</p><p class="source-code">clojure.lang.PersistentArrayMap</p><p>The <strong class="source-inline">fluss</strong> variable is a <strong class="source-inline">PersistentArrayMap</strong> from Clojure.</p></li>
				<li>Using Clojure's hash, we can create a HashMap using Java:<p class="source-code">(def rivers (java.util.HashMap. fluss))</p></li>
				<li>We create a HashMap from Java using a hash from Clojure.<p class="source-code">rivers</p><p>The output is as follows:</p><p class="source-code">{"Poland" "Vistula" "Germany" "Rhein"}</p><p>The <strong class="source-inline">rivers</strong> variable contains countries and the rivers in those countries.</p></li>
				<li>We can check the class of the <strong class="source-inline">rivers</strong> variable as follows:<p class="source-code">(class rivers)</p><p>The output is as follows:</p><p class="source-code">java.util.HashMap</p><p>We can see that <strong class="source-inline">rivers</strong> is a HashMap from Java.</p></li>
				<li>Using HashMap from Java, we can create a hash in Clojure:<p class="source-code">(into {} rivers)</p><p>The output is as follows:</p><p class="source-code">{"Poland" "Vistula" "Germany" "Rhein"}</p><p>In the preceding code we used the <strong class="source-inline">into</strong> function from Clojure's core library. The <strong class="source-inline">into</strong> function takes the destination collection and the source collection as the two arguments.</p><p>Our destination collection is a hash from Clojure. Remember that we define a hash in Clojure using curly brackets, <strong class="source-inline">{}</strong>. We put the content of the <strong class="source-inline">rivers</strong> HashMap from Java into a hash <strong class="source-inline">{}</strong> from Clojure.</p></li>
				<li>We can check the class of our newly converted hash:<p class="source-code">(class (into {} rivers))</p><p>The output is as follows:</p><p class="source-code">clojure.lang.PersistentArrayMap</p><p>The class of our converted data is a <strong class="source-inline">PersistentArrayMap</strong> from Clojure.</p></li>
			</ol>
			<p>In this exercise, we extended our knowledge of Java's interoperability with Clojure. We learned how to convert data from Java to Clojure and back again. In the following activity, you will use your knowledge of Java interoperability to create an application that performs I/O operations.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor250"/>Activity 9.01: Book-Ordering Application</h2>
			<p>In this activity, we will apply our new knowledge about I/O and Java to create a book-ordering application. A media company has decided to create an app that allows users to order books. A user can select a year and titles from a list in the application. Once a book order has been placed, we should be able to see the orders grouped by year.</p>
			<p>Once you complete the activity, you should have output similar to the following.</p>
			<p>Initial menu:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B14502_09_16.jpg" alt="Figure 9.16: Menu display&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16: Menu display</p>
			<p>Listing years:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B14502_09_17.jpg" alt="Figure 9.17: Available books by year&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17: Available books by year</p>
			<p>Books in one year:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B14502_09_18.jpg" alt="Figure 9.18: Books purchased in 2019&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18: Books purchased in 2019</p>
			<p>Asking how many books the user wants to buy:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B14502_09_19.jpg" alt="Figure 9.19: Asking for the number of books to be bought&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19: Asking for the number of books to be bought</p>
			<p>Order confirmation message:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B14502_09_20.jpg" alt="Figure 9.20: Order confirmation message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20: Order confirmation message</p>
			<p>Listing purchased books:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B14502_09_21.jpg" alt="Figure 9.21: List of purchased books&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21: List of purchased books</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Create a new project.</li>
				<li>Import the necessary namespace.</li>
				<li>Create a map to hold books by year.</li>
				<li>Create a variable for a file that stores orders.</li>
				<li>Create an initial menu with options to order a book and list orders.</li>
				<li>Create a menu to display books by year.</li>
				<li>Create the application's <strong class="source-inline">main</strong> method.</li>
				<li>Create a function to save data to a file.</li>
				<li>Create a function to save an order.</li>
				<li>Create a function to calculate the <strong class="source-inline">book price</strong>.</li>
				<li>Create a function to display an order confirmation message.</li>
				<li>Create a function to display the bought order.</li>
				<li>Create a function to read a single order.</li>
				<li>Create a function to check whether a file exists.</li>
				<li>Create a function to load orders from a file.</li>
				<li>Create a submenu to order a book.</li>
				<li>Create a function to buy a book by year.</li>
				<li>Create a function to show orders by year.</li>
				<li>Create a submenu to list orders.<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 712.</p></li>
			</ol>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor251"/>Using JavaScript in ClojureScript</h1>
			<p>ClojureScript allows us to use JavaScript constructs. We can call JavaScript methods and functions like any other in ClojureScript. When we called Java from Clojure we used operators such as <strong class="source-inline">.</strong> dot or <strong class="source-inline">\</strong> slash. Using JavaScript in ClojureScript will also require us to learn a new syntax. </p>
			<p>While Java operates on classes a lot, in JavaScript we operate on objects. Two JavaScript constructs that we want to use on objects are:</p>
			<ul>
				<li>Methods</li>
				<li>Fields</li>
			</ul>
			<p>In order to access a method from a JavaScript object, we place <strong class="source-inline">.</strong> (a dot) followed by a method name. Accessing a field of an object is very similar. We use <strong class="source-inline">.-</strong> (a dot and a hyphen) before the field name. You might wonder why accessing a function uses slightly different syntax than accessing a field. In JavaScript, an object can have a method and a field with the same name. In ClojureScript, we need a way to distinguish between a function call and a field access.</p>
			<p>In JavaScript, the code looks as follows:</p>
			<p class="source-code">var string = "JavaScript string"</p>
			<p class="source-code">var string_length = string.length;</p>
			<p class="source-code">var shout = string.toUpperCase();</p>
			<p>In ClojureScript, the code looks as follows:</p>
			<p class="source-code">(def string "JavaScript string")</p>
			<p class="source-code">(def string_length (.-length string))</p>
			<p class="source-code">(def shout (.toUpperCase string))</p>
			<p>Let's take a minute to appreciate the design of ClojureScript. We learned at the beginning of the book about ClojureScript functions and how to call them. Essentially, it is the same syntax as in Clojure. Unless we have a sequence, the first position in a list is treated as a function:</p>
			<p class="source-code">(range 1 10)</p>
			<p>Calling <strong class="source-inline">range</strong> will return a sequence of numbers from 1 to 10:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B14502_09_22.jpg" alt="Figure 9.22: Output for calling range&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.22: Output for calling range</p>
			<p>Here, <strong class="source-inline">range</strong> is in the first position and the ClojureScript compiler rightly treats <strong class="source-inline">range</strong> as a function. We have just seen how to call JavaScript methods and fields. With the addition of a dot or a hyphen, nothing changes in the syntax. This uniformity of placing method calls in the first position in ClojureScript reduces the mental burden on developers. We do not need to learn a lot of special syntax for JavaScript interoperability.</p>
			<p>We will see this uniformity when we compare using the <strong class="source-inline">range</strong> function and checking the length of a string.</p>
			<p>We call the <strong class="source-inline">range</strong> function in this way:</p>
			<p class="source-code">(range 1 10)</p>
			<p>It will work as follows:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B14502_09_23.jpg" alt="Figure 9.23: Calling the range function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.23: Calling the range function</p>
			<p>Checking the length of a string is done in the following way:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B14502_09_24.jpg" alt="Figure 9.24: Checking the length of a string&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.24: Checking the length of a string</p>
			<p>The <strong class="source-inline">range</strong> function and accessing the length field of a JavaScript string are both placed in the first position in a statement.</p>
			<p>What is even more amazing is that ClojureScript improves on JavaScript. In JavaScript, there is no concept of a namespace. When we define a function or a variable, it belongs to a global namespace. This poses a problem when two or more libraries use the same name for a variable or a method. This causes a conflict and gives us errors. Library designers use JavaScript objects as modules/namespaces and place functions in their objects. This is, however, only a workaround and not a language design. In ClojureScript, namespaces are first-class citizens designed in the language.</p>
			<p>We should pay attention to one namespace. ClojureScript uses the <strong class="source-inline">js</strong> namespace to refer to the global scope of a program. Core JavaScript objects such as <strong class="source-inline">Number</strong>, <strong class="source-inline">String</strong>, and <strong class="source-inline">Date</strong> are accessed in ClojureScript using the <strong class="source-inline">js</strong> namespace. In this namespace, we will also find browser-defined objects such as <strong class="source-inline">window</strong>.</p>
			<p>In order to construct a JavaScript object, we use the object's name followed by a dot. This is the same syntax we used to construct an instance of a Java class in Clojure.</p>
			<p>In JavaScript, the code looks as follows:</p>
			<p class="source-code">var num = new Number(123);</p>
			<p>In ClojureScript, the code looks as follows:</p>
			<p class="source-code">(def num (js/Number. 123))</p>
			<p>Notice that we use the <strong class="source-inline">js</strong> namespace. As was mentioned in this section, core JavaScript objects such as Number are accessed through this namespace.</p>
			<p>ClojureScript takes advantage of JavaScript data types. ClojureScript does not invent new data types but reuses existing JavaScript data types. The following table presents ClojureScript data types and their JavaScript origin:</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B14502_09_25.jpg" alt="Figure 9.25: ClojureScript data types with their origins&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.25: ClojureScript data types with their origins</p>
			<p>As we can see, data types often used in ClojureScript are based on JavaScript data types.</p>
			<p>We have seen how to access JavaScript in ClojureScript. In the next exercise, we will learn how to work with JavaScript data types in ClojureScript.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor252"/>Exercise 9.07: Working with JavaScript Data Types</h2>
			<p>The aim of this exercise is to learn how to work with JavaScript data types in ClojureScript. We will learn how to convert ClojureScript data to JavaScript objects. Later, we will learn the reverse process of how to convert JavaScript objects to ClojureScript data:</p>
			<ol>
				<li value="1">We will create a new project for our code:<p class="source-code">lein new mies js-interop</p><p>This command creates a basic ClojureScript project called <strong class="source-inline">js-interop</strong>.</p></li>
				<li>We will start the REPL with the following command.<p class="source-code">scripts/repl</p><p>The output is as follows:</p><div id="_idContainer139" class="IMG---Figure"><img src="image/B14502_09_26.jpg" alt="Figure 9.26: Output of the REPL&#13;&#10;"/></div><p class="figure-caption">Figure 9.26: Output of the REPL</p></li>
				<li>ClojureScript provides the <strong class="source-inline">js-obj</strong> function for creating a JavaScript object from ClojureScript data:<p class="source-code">(js-obj "Austria" "Donau")</p><p>The output is as follows:</p><p class="source-code">#js {:Austria "Donau"}</p><p>Calling the <strong class="source-inline">js-obj</strong> function created a new JavaScript object. Notice the <strong class="source-inline">#js</strong> in the REPL. This symbol in the REPL informs us that the following expression is a JavaScript object.</p></li>
				<li>Frequently, we use nested structures where one object contains another object:<p class="source-code">(def rivers-map-js (js-obj "country" {"river" "Donau"}))</p><p>The output is as follows:</p><div id="_idContainer140" class="IMG---Figure"><img src="image/B14502_09_27.jpg" alt="Figure 9.27: Nested structures&#13;&#10;"/></div><p class="figure-caption">Figure 9.27: Nested structures</p><p>The <strong class="source-inline">rivers-map-js</strong> object is a nested structure. It contains a country key, the value of which is another object with some river details.</p></li>
				<li>We can access fields in the <strong class="source-inline">rivers-map-js</strong> object:<p class="source-code">(.-country rivers-map-js)</p><p>The output is as follows:</p><p class="source-code">{"river" "Donau"}</p></li>
				<li>After accessing country, we got nested data about rivers. We will try to access this nested data:<p class="source-code">(.-river (.-country rivers-map-js))</p><p>The output is as follows:</p><p class="source-code">nil</p><p>When we try to get information about a river, we get <strong class="source-inline">nil</strong>. It turns out that we cannot access data using JavaScript interoperability. The reason is because the <strong class="source-inline">js-obj</strong> function is shallow. It does not transform nested data structures to JavaScript objects. If we want to transfer nested ClojureScript data to JavaScript objects we need to use some other method.</p></li>
				<li>In order to transform all nested data, we need to use the <strong class="source-inline">clj-&gt;js</strong> function:<p class="source-code">(def rivers-map-js-converted (clj-&gt;js {"country" {"river" "Donau"}}))</p><p>The output is as follows:</p><p class="source-code">#cljs.user/rivers-map-js-converted</p></li>
				<li>With the <strong class="source-inline">clj-&gt;js</strong> function, we are able to convert nested ClojureScript data:<p class="source-code">rivers-map-js-converted</p><p>The output is as follows:</p><p class="source-code">#js {:country #js {:river "Donau"}}</p><p>Notice the two <strong class="source-inline">#js</strong> symbols. Each symbol informs us that we have a JavaScript object. The first object contains the name of a country. Inside this country object, we have another JavaScript object with the name of a river.</p></li>
				<li>When we have nested JavaScript objects, we can access data from them using JavaScript interoperability:<p class="source-code">(.-river (.-country rivers-map-js-converted))</p><p>The output is as follows:</p><p class="source-code">"Donau"</p><p>We were able to access nested JavaScript objects using JavaScript interoperability.</p></li>
				<li>So far, we have converted from ClojureScript to JavaScript. It is possible to convert the other way, from JavaScript to ClojureScript:<p class="source-code">(js-&gt;clj #js {:river "Donau"})</p><p>The output is as follows:</p><p class="source-code">{"river" "Donau"}</p><p>Using the <strong class="source-inline">#js</strong> symbol, we converted a JavaScript object to ClojureScript data.</p></li>
				<li>Convert nested JavaScript objects to ClojureScript data:<p class="source-code">(js-&gt;clj #js {:country #js {:river "Donau"}})</p><p>The output is as follows:</p><p class="source-code">{"country" {"river" "Donau"}}</p><p>Using the <strong class="source-inline">js-&gt;clj</strong> function, we again converted from JavaScript objects to ClojureScript data. Notice that we used the <strong class="source-inline">#js</strong> symbol twice. Every time we have a JavaScript object, we have to mark it using the <strong class="source-inline">#js</strong> symbol. This instructs ClojureScript to treat the following data as a JavaScript object.</p><p>In this exercise, we learned how to convert ClojureScript data to JavaScript objects. Then we saw how to reverse the process and convert from JavaScript objects to ClojureScript data.</p></li>
			</ol>
			<p>We are ready to start building ClojureScript applications. In <em class="italic">Chapter 8</em>, <em class="italic">Namespaces, Libraries, and Leiningen</em>, we learned about structuring projects and using Leiningen to create Clojure projects. We can use Leiningen to create ClojureScript projects as well. Using Leiningen templates to create ClojureScript applications will create the necessary configuration for working in ClojureScript. One of the most common ClojureScript templates is the Figwheel template. We will learn about this template in the next topic.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor253"/>Figwheel Template</h2>
			<p>Figwheel is a tool that compiles ClojureScript code. One of the selling points of Figwheel is hot-code reloading. When we make changes to ClojureScript files, the code will be recompiled and a page in a browser will be updated. This helps to speed up the development process by giving quick feedback to programmers.</p>
			<p>Figwheel not only reloads our code, but is intelligent with code reloading. Figwheel gives us compiler errors when we make changes in our code that result in faulty code.</p>
			<p>If we try to use a function that is not declared, Figwheel will inform us:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B14502_09_28.jpg" alt="Figure 9.28: Message from Figwheel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.28: Message from Figwheel</p>
			<p>Figwheel informed us that on line 42 in the <strong class="source-inline">core.cljs</strong> file we tried to call a <strong class="source-inline">handle-sort-finish</strong> function without declaring it. </p>
			<p>With this concise and high-quality feedback from Figwheel, we can develop ClojureScript applications faster than if we had to dig through errors in stack traces. Or worse, our application runs but gives unexpected results.</p>
			<p>Figwheel supports an interactive programming style. Changes made in our code base are recompiled and displayed in a web browser. We learned in <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL!</em>, that Clojure uses immutable data structures by default. You can reload function definitions all day long. They are side-effect free and not tied to the local state of a running system. This means that running the same function many times does not change the state of an application. Recompiling and reloading is thus safe.</p>
			<p>Figwheel encourages using React to develop applications. React is a web tool that allows us to manipulate elements on a page. React allows you to write functions that express what the state of such elements should be given the current application state.</p>
			<p>In the next section, we will learn about Rum. Rum is a library used to create HTML elements on a page using application state.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor254"/>Reactive Web Programming Using Rum</h1>
			<p>Many websites allow users to interact with web pages. Users can click, drag, and sort elements. These pages are dynamic – they respond to user actions. A programming page that reacts to user interactions is called reactive programming.</p>
			<p>HTML provides a structure of elements on a page. The <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) is a representation of HTML in JavaScript. JavaScript allows us to operate on DOM elements that are finally displayed as HTML elements on a web page.</p>
			<p>One way to make a page react to user actions is to render (display) that whole page again. Rendering a whole page consumes computer resources. If only a small part of the page needs re-rendering, we waste precious resources re-rendering the entire page. Fortunately for us, there is a solution that allows us to re-render only the parts of a page that have changed.</p>
			<p>React.js is a JavaScript library that supports reactive programming. The basic block of React.js is a component. In React.js, we define what components should look like and how they should behave. With React.js, we can create components based on the current application state. Changes in state result in re-rendering components that require a change. React internally checks which parts of the application state have changed and which components rely on these parts of state. As a result, React re-renders only those components that used parts of the application state that have changed. </p>
			<p>Rum is a Clojure library for creating HTML elements on a web page. Rum is based on React.js. We often have some state in a ClojureScript application. A state could be a list of users. We can manipulate a list of users by adding or removing users, and based on our actions a web page should update. In Rum, it is possible to define page elements such as a user entry that will react to changes to the list of users. Adding a new user will result in a page displaying an updated list of users.</p>
			<p>In the next exercise, we will create a Figwheel project that uses Rum and explore what benefits Figwheel and Rum provide for developers.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor255"/>Exercise 9.08: Investigating Figwheel and Rum </h2>
			<p>The aim of this exercise is to learn about Figwheel and Rum. Figwheel will create a ClojureScript project structure for us. Rum will allow us to build HTML components that respond to user actions:</p>
			<ol>
				<li value="1">Create the Figwheel and Rum project:<p class="source-code">lein new figwheel-main hello-clojurescript.core -- --rum</p><p>We use Leiningen to call the <strong class="source-inline">fighwheel-main</strong> template. This template will create a new ClojureScript project with a main namespace called <strong class="source-inline">hello-clojuresript.core</strong>.</p><p>We want to use Rum, so we pass the <strong class="source-inline">--rum</strong> command-line parameter to add Rum support to the project:</p><div id="_idContainer142" class="IMG---Figure"><img src="image/B14502_09_29.jpg" alt="Figure 9.29: Creating a Figwheel and Rum project&#13;&#10;"/></div><p class="figure-caption">Figure 9.29: Creating a Figwheel and Rum project</p><p>Leiningen downloads the template and creates a ClojureScript project for us.</p></li>
				<li>We will move to the project to the command line:<p class="source-code">cd hello-clojurescript.core/</p><p>This will change the directory to <strong class="source-inline">hello-clojurescript.core</strong>:</p><div id="_idContainer143" class="IMG---Figure"><img src="image/B14502_09_30.jpg" alt="Figure 9.30: Changing directory&#13;&#10;"/></div><p class="figure-caption">Figure 9.30: Changing directory</p><p>We are ready to run our application. In order to run our ClojureScript application, we need to build it.</p></li>
				<li>Figwheel provides an automatic build configuration that allows us to run a newly-created ClojureScript application:<p class="source-code">lein fig:build</p><p>Calling this command will build a ClojureScript application. First, Figwheel will download any necessary dependencies:</p><div id="_idContainer144" class="IMG---Figure"><img src="image/B14502_09_31.jpg" alt="Figure 9.31: Building a ClojureScript application&#13;&#10;"/></div><p class="figure-caption">Figure 9.31: Building a ClojureScript application</p><p>Here, Figwheel downloads three dependencies:</p><ul><li>Rum </li><li><strong class="source-inline">Figwheel-main</strong> library</li><li>ClojureScript  <p>Second, Figwheel will check our configuration:</p><div id="_idContainer145" class="IMG---Figure"><img src="image/B14502_09_32.jpg" alt="Figure 9.32: Figwheel checking configuration&#13;&#10;"/></div></li></ul></li>
			</ol>
			<p class="figure-caption">Figure 9.32: Figwheel checking configuration</p>
			<p>Because we have not changed the default configuration, there are no problems with our project's configuration. We will see what the default configuration looks like shortly.</p>
			<p>Third, Figwheel will compile our code and output a main file that is run:</p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B14502_09_33.jpg" alt="Figure 9.33: Compiling code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.33: Compiling code</p>
			<ol>
				<li value="4">After Figwheel builds our application, it will launch a server that will serve our application:<div id="_idContainer147" class="IMG---Figure"><img src="image/B14502_09_34.jpg" alt="Figure 9.34: Starting the server&#13;&#10;"/></div><p class="figure-caption">Figure 9.34: Starting the server</p><p>The server runs locally. If we navigate to <strong class="source-inline">http://localhost:9500</strong>, we will see an initial page created by Figwheel:</p><div id="_idContainer148" class="IMG---Figure"><img src="image/B14502_09_35.jpg" alt="Figure 9.35: Initial page created by Figwheel&#13;&#10;"/></div><p class="figure-caption">Figure 9.35: Initial page created by Figwheel</p><p>The page contains welcome information. We can also see that we can edit the <strong class="source-inline">core.clsj</strong> file and see the changes on the web page. Seeing the changes is possible because Figwheel is set up to watch both the source and test directories for any changes.</p><p class="source-code">[Figwheel] Watching paths: ("test" "src") to compile build – dev</p><p>Any changes that we make in source files will result in recompilation of the code and our application being updated in the web browser.</p><p>We will investigate the core source file now.</p></li>
				<li>Figwheel will import two namespaces for us in the <strong class="source-inline">core.cjs</strong> file:<p class="source-code">(ns ^:figwheel-hooks hello-clojurescript.core</p><p class="source-code">  (:require [goog.dom :as gdom]</p><p class="source-code">                [rum.core :as rum]))</p><p>The first namespace is the Google <strong class="source-inline">dom</strong> namespace, which allows us to manipulate DOM elements. The second namespace is <strong class="source-inline">rum</strong>, which was imported because we set our application to use Rum. Remember that we passed the <strong class="source-inline">--rum</strong> command-line parameter when we created the application.</p><p>In the namespace, we have defined the <strong class="source-inline">^:figwheel-hooks</strong> keyword. This is autogenerated by Figwheel and instructs Figwheel that it needs to auto-compile this file.</p></li>
				<li>The Google DOM namespace allows us to manipulate DOM elements on the page:<p class="source-code">(defn get-app-element []</p><p class="source-code">  (gdom/getElement "app"))</p><p>The <strong class="source-inline">getElement</strong> function will search a page for an element with an ID of <strong class="source-inline">app</strong>. By default, Figwheel will create an index page with a <strong class="source-inline">div</strong>. This <strong class="source-inline">div</strong> will have an ID of <strong class="source-inline">app</strong>.</p></li>
				<li>Figwheel creates a default index file in the <strong class="source-inline">resources/public</strong> folder:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;link href="css/style.css" rel="stylesheet" type="text/css"&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;div id="app"&gt;&lt;/div&gt;</p><p class="source-code">    &lt;script src="cljs-out/dev-main.js" type="text/javascript"&gt;&lt;/script&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>The main things that interest us in the index file are importing styles from the <strong class="source-inline">css/style.css</strong> file, creating the <strong class="source-inline">div</strong> with app <strong class="source-inline">id</strong> where we will mount our application, and adding our compiled code as a script from the <strong class="source-inline">dev-main.js</strong> file.</p></li>
				<li>Reactive applications need to manage state to react to user interactions. The state is defined as an atom:<p class="source-code">(defonce app-state (atom {:text "Hello world!" :counter 0}))</p><p>n the state, we store a hash with a <strong class="source-inline">:text </strong>key that has a value of <strong class="source-inline">"Hello world!"</strong> and a <strong class="source-inline">:counter</strong> key with a value of zero. The state is defined using <strong class="source-inline">defonce</strong>. This is because we do not want to redefine the state when Figwheel reloads the code. This way, we preserve application state during page reload.</p></li>
				<li>Rum components are defined using the <strong class="source-inline">defc</strong> macro:<p class="source-code">(rum/defc hello-world []</p><p class="source-code">  [:div</p><p class="source-code">   [:h1 (:text (deref app-state))]</p><p class="source-code">   [:h3 "Edit this in src/hello_clojurescript/core.cljs and watch it change!"]])</p><p>The <strong class="source-inline">hello-world</strong> component constructs an HTML <strong class="source-inline">div</strong> element. Inside the <strong class="source-inline">div</strong>, we have an <strong class="source-inline">h1</strong> HTML element and an <strong class="source-inline">h3</strong> HTML element.</p><p>The <strong class="source-inline">h1</strong> element will display text stored in the application state. Because the application state is an atom, if we want to access values, we need to dereference it. Dereferencing is an action that returns a value stored in an atom.</p><p>The <strong class="source-inline">h3</strong> element informs us that we can edit the <strong class="source-inline">core.cljs</strong> file and see the changes on the web page.</p><p>Defined components need to be mounted on the page.</p></li>
				<li>In order to see the components on the page, we need to mount them:<p class="source-code">(defn mount [el]</p><p class="source-code">  (rum/mount (hello-world) el))</p><p class="source-code">(defn mount-app-element []</p><p class="source-code">  (when-let [el (get-app-element)]</p><p class="source-code">    (mount el)))</p><p>The <strong class="source-inline">rum/mount</strong> function will mount the <strong class="source-inline">hello-world</strong> component to the DOM element. This element is returned by the <strong class="source-inline">get-app-element</strong> function that we investigated earlier.</p><p>Once the component is mounted to the DOM element, it will be displayed on the page:</p><div id="_idContainer149" class="IMG---Figure"><img src="image/B14502_09_36.jpg" alt="Figure 9.36: Initial page after mounting the component to the DOM element&#13;&#10;"/></div><p class="figure-caption">Figure 9.36: Initial page after mounting the component to the DOM element</p><p>Our <strong class="source-inline">hello-world</strong> component displays two headers. First is an <strong class="source-inline">h1</strong> header with saying <strong class="source-inline">Hello world!</strong>. Then is an <strong class="source-inline">h3</strong> header with information about editing the <strong class="source-inline">core.cljs</strong> file.</p></li>
				<li>Rum allows us to define reactive components. A reactive component is a component that reacts to changes in the application state. When a change happens, the component is re-rendered on the page with a new value taken from the application state:<p class="source-code">(rum/defc hello-world &lt; rum/reactive []</p><p class="source-code">          [:div {}</p><p class="source-code">           (band "Metallica" (:counter (rum/react app-state)))])</p><p>We marked the component to be reactive by using Rum's <strong class="source-inline">&lt; rum/reactive</strong> syntax. The <strong class="source-inline">&lt;</strong> symbol tells Rum that a component is a special type. In our case, it is a reactive component. Rum will react to changes to <strong class="source-inline">app-state</strong>.</p><p>The <strong class="source-inline">hello-world</strong> component will call a band component and pass the band name together with <strong class="source-inline">:counter</strong>, which is defined in the application state. </p><p>Whenever the <strong class="source-inline">app-state</strong> is updated, Rum will react to the change and re-render the band component.</p></li>
				<li>In the <strong class="source-inline">hello-world</strong> component, we will display a band:<p class="source-code">(rum/defc band [name likes]</p><p class="source-code">          [:div {:class "band"</p><p class="source-code">                 :on-click #(increment-likes)}</p><p class="source-code">           (str name " is liked " likes " times")])</p><p>The<strong class="source-inline"> band </strong>component takes two band names and the number of likes as the parameters.</p><p>The component will display the band name and the number of likes:</p></li>
			</ol>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B14502_09_37.jpg" alt="Figure 9.37: Displaying the band name in the hello-world component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.37: Displaying the band name in the hello-world component</p>
			<p>Inside the component, we use the <strong class="source-inline">:on-click</strong> DOM attribute.</p>
			<p>The <strong class="source-inline">on-click</strong> attribute allows us to attach a function that is called when a user clicks on an element on a web page:</p>
			<p class="source-code">(defn increment-likes []</p>
			<p class="source-code">      (swap! app-state update-in [:counter] inc))</p>
			<p>The function updates a <strong class="source-inline">:counter</strong> key inside the <strong class="source-inline">app-state </strong>hash. The update is done by incrementing the value of the counter using Clojure's <strong class="source-inline">inc</strong> function:</p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B14502_09_38.jpg" alt="Figure 9.38: Incrementing likes for the band name&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.38: Incrementing likes for the band name</p>
			<p>Clicking three times on the page element will update the counter. Updating the counter will trigger the re-rendering of the component with a new value.</p>
			<p>In this exercise, we updated the <strong class="source-inline">hello-world</strong> component. After code changes, the component was displayed in the browser. We did not have to recompile the code. The code was recompiled by Figwheel. When we run Figwheel, it starts to watch our files for changes:</p>
			<p class="source-code">[Figwheel] Watching paths: ("test" "src") to compile build - dev</p>
			<p>Thanks to Figwheel, we were able to focus on coding without worrying about recompiling our code. This is done automatically by Figwheel. </p>
			<p>In this section, we learned about Figwheel. It creates a template for ClojureScript projects. The main feature of Figwheel is hot-code reloading. Changes in our source files are automatically recompiled and re-displayed in the browser.</p>
			<p>We also learned about Rum. Rum is a library that helps to create reactive components. The components react to changes in application state and are redisplayed on the web pages.</p>
			<p>In the next topic, we will delve deeper into JavaScript interoperability.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor256"/>Drag and Drop</h2>
			<p>One of the most common use cases in web pages is using drag and drop. It is so common that we rarely even notice it nowadays. The jQuery UI library provides functions to code drag and drop functionality. With this library, we can mark HTML elements as draggable and droppable.</p>
			<p>The library has a number of options that allow us to alter how dragging and dropping behaves. We can:</p>
			<ul>
				<li>Constrain the movement of draggable elements to certain areas on a web page</li>
				<li>Specify if the element returns to the original position after dragging</li>
				<li>Specify if the element auto-aligns to other elements</li>
				<li>Give visual aids while dragging, such as transparency or animation</li>
				<li>Accept only one droppable element in a page area</li>
				<li>Allow or deny reverting after dropping</li>
				<li>Give visual feedback once an element has been dropped</li>
			</ul>
			<p>Using jQuery's draggable and droppable functionality, we can create a truly interactive page.</p>
			<p>We have seen the syntax for JavaScript interoperability. It is now time to put our knowledge into practice. In the next exercise, we will create a drag and drop application using JavaScript interoperability. The application will be based on the Figwheel template and use Rum for reactive behavior.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor257"/>Exercise 9.09: JavaScript Interoperability with Drag and Drop </h2>
			<p>The aim of this exercise is to get comfortable with JavaScript interoperability in ClojureScript. We will create a frontend application that allows users to drag and drop elements. When coding dragging and dropping behavior, we will use objects and functions from JavaScript. JavaScript's jQuery UI library has drag and drop methods. We will use methods from this library.</p>
			<p>The application will be based on a Figwheel template that helps build ClojureScript applications. One of its main features is hot-code reloading. Any changes in source files are recompiled and updated in a browser. This helps to speed up the development process by giving quick feedback to programmers:</p>
			<ol>
				<li value="1">Create a new ClojureScript application based on the <strong class="source-inline">figwheel</strong> template:<p class="source-code">lein new figwheel-main hello-drag-and-drop -- --rum</p><p>The REPL will display information saying that a new project based on the <strong class="source-inline">figwheel</strong> template has been created:</p><div id="_idContainer152" class="IMG---Figure"><img src="image/B14502_09_39.jpg" alt="Figure 9.39: REPL output&#13;&#10;"/></div><p class="figure-caption">Figure 9.39: REPL output</p><p>In the project, we will use the <strong class="source-inline">jayq</strong> external library. <strong class="source-inline">jayq</strong> is a ClojureScript wrapper for jQuery.</p></li>
				<li>Add external ClojureScript dependencies in <strong class="source-inline">project.clj</strong>. In <strong class="source-inline">project.clj</strong>, add the <strong class="source-inline">jayq</strong> library in the <strong class="source-inline">:dependencies</strong> section:<p class="source-code">[jayq "2.5.4"]</p><p>The <strong class="source-inline">dependencies</strong> section in <strong class="source-inline">project.clj</strong> should look like the following:</p><div id="_idContainer153" class="IMG---Figure"><img src="image/B14502_09_40.jpg" alt="Figure 9.40: Output for dependencies &#13;&#10;"/></div><p class="figure-caption">Figure 9.40: Output for dependencies </p></li>
				<li>Now that we have dependencies configured in <strong class="source-inline">project.clj</strong>, we can import them in the <strong class="source-inline">hello-drag-and-drop.core</strong> namespace:<p class="source-code">(ns ^:figwheel-hooks hello-drag-and-drop.core</p><p class="source-code">  (:require [jayq.core :as jayq :refer [$]]</p><p class="source-code">            [goog.dom :as gdom]</p><p class="source-code">            [rum.core :as rum]))</p><p>The libraries will help us create drag and drop elements on a page. Drag and drop implementation will be based on a component from jQuery UI. We need to import these JavaScript libraries in the <strong class="source-inline">index.html</strong> file.</p></li>
				<li>Open the <strong class="source-inline">resources/public/index.html</strong> file and, inside the <strong class="source-inline">&lt;head&gt;</strong> tag, add imports for jQuery and jQuery UI:<p class="source-code">&lt;script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"&gt;&lt;/script&gt;</p><p class="source-code"> &lt;script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"&gt;&lt;/script&gt;</p></li>
				<li>After importing the necessary libraries, we will launch Figwheel. In Terminal, type the following:<p class="source-code">lein fig:build</p><p>This will launch Figwheel for us:</p><div id="_idContainer154" class="IMG---Figure"><img src="image/B14502_09_41.jpg" alt="Figure 9.41: Launching Figwheel&#13;&#10;"/></div><p class="figure-caption">Figure 9.41: Launching Figwheel</p><p>Figwheel will compile ClojureScript code and launch a server for us. The server will automatically open a web browser displaying the content from the <strong class="source-inline">index.html</strong> file:</p><div id="_idContainer155" class="IMG---Figure"><img src="image/B14502_09_42.jpg" alt="Figure 9.42: Content from index.html&#13;&#10;"/></div><p class="figure-caption">Figure 9.42: Content from index.html</p><p>One of the selling points of Figwheel is code reloading. When we make changes to ClojureScript files, the code will be recompiled and a page in the browser will be updated.</p><p>In our app, we will implement drag and drop functionality. We will move draggable cards into droppable tiles. We start by defining a tile component.</p></li>
				<li>Inside <strong class="source-inline">hello-clojurescript.core</strong>, add a definition for a tile:<p class="source-code">(rum/defc tile [text number]</p><p class="source-code">  [:div {:class "tile" :id number} text])</p><p>Here, a tile is a <strong class="source-inline">rum</strong> component that is basically an HTML block. We define a component using the <strong class="source-inline">defc</strong> method from <strong class="source-inline">rum</strong>. A tile accepts two arguments: text and a number. Inside it, a hash that allows us to set properties on an element number parameter is used to set an ID for the tile div. Text will be displayed inside the div element. We also set a "<strong class="source-inline">tile</strong>" class for styling.</p></li>
				<li>Inside <strong class="source-inline">resources/public/css/styles.css</strong>, add a CSS definition. CSS stands for Cascading Style Sheets. Style sheets allow us to style HTML elements on a web page. Cascading means that if an HTML element has some styles, any HTML elements inside this element will inherit the same styling:<p class="source-code">.tile {</p><p class="source-code">    border: 1px solid green;</p><p class="source-code">    display: inline-block;</p><p class="source-code">    height: 100px;</p><p class="source-code">    width: 200px;</p><p class="source-code">}</p><p>Here, we define the style for a tile component with a solid green border. The border's width should be 1 pixel, the height should be 100 pixels, the width should be 200 pixels, and the component is displayed inline, meaning that it is on the same line as other elements. When we render the tiles, they will look as follows:</p><div id="_idContainer156" class="IMG---Figure"><img src="image/B14502_09_43.jpg" alt="Figure 9.43: Defining the tile component&#13;&#10;"/></div><p class="figure-caption">Figure 9.43: Defining the tile component</p><p>We have two tiles on the same line. Each tile has a green border.</p></li>
				<li>This styling will help us to see each tile clearly. We have a solid green line to distinguish between the tiles. We are going to create a component that holds tiles:<p class="source-code">(rum/defc tiles []</p><p class="source-code">  [:.tiles {}</p><p class="source-code">    (tile "first" 1)</p><p class="source-code">    (tile "second" 2)])</p><p>We create a component that is a <strong class="source-inline">div</strong> holding two <strong class="source-inline">tile</strong> components. We mark them as first and second. Notice that we did not write a <strong class="source-inline">div</strong> tag directly. When we omit the <strong class="source-inline">div</strong> tag and provide a class or an ID, Rum will implicitly create a <strong class="source-inline">div</strong> element. Here, we used a shorthand notation for a class and gave the component class <strong class="source-inline">tiles</strong>.</p></li>
				<li>We want to inform a user that an element was dropped. We will store information about dropping elements in an <strong class="source-inline">atom</strong>:<p class="source-code">(defonce is-element-dropped? (atom false))</p><p>When the application starts, we set the value to <strong class="source-inline">false</strong>. We do not want Figwheel to redefine the atom when it reloads the page, so we define it once.</p></li>
				<li>The component will display information if an element was dropped:<p class="source-code">(rum/defc dropped-message &lt; rum/reactive []</p><p class="source-code">          [:div {}</p><p class="source-code">           (str "Was element dropped? " (rum/react is-element-dropped?))])</p><p>We use the <strong class="source-inline">reactive</strong> directive from Rum. This directive instructs Rum that the component will <strong class="source-inline">react</strong> to changes in <strong class="source-inline">application state</strong>. In our case, any changes to the <strong class="source-inline">is-element-dropped?</strong> atom will cause the component to be rerendered with a new value. We have three components already, but they are not visible in the web browser yet. We need to write code that will mount our components on the page. We will have a top-level component that will contain all the HTML for our application.</p></li>
				<li>We will put all our components into one <strong class="source-inline">main</strong> component. This <strong class="source-inline">main</strong> component will contain cards that we drag and tiles where we drop elements:<p class="source-code">(rum/defc content []</p><p class="source-code">  [:div {}</p><p class="source-code">    (tiles)</p><p class="source-code">    (dropped-message)])</p></li>
				<li>After defining our <strong class="source-inline">main</strong> component, we are ready to tell Rum how to mount this component:<p class="source-code">(defn mount [el]</p><p class="source-code">  (rum/mount (content) el))</p><p>We tell Rum that we want to mount a component called <strong class="source-inline">content</strong>. The mount point is an element with an ID of <strong class="source-inline">app</strong>. When we check the web browser, we can see the changes applied:</p><div id="_idContainer157" class="IMG---Figure"><img src="image/B14502_09_44.jpg" alt="Figure 9.44: Changes in the tile component&#13;&#10;"/></div><p class="figure-caption">Figure 9.44: Changes in the tile component</p><p>We did not have to compile the code ourselves. All this was done by Figwheel. After creating droppable elements, it is time to create elements that we can drag.</p></li>
				<li> We will create a new <strong class="source-inline">rum</strong> component – a <strong class="source-inline">card</strong>:<p class="source-code"> (rum/defc card [number]</p><p class="source-code">  [:.card {:data-number number :id number}])</p><p>The card component will accept one argument, a number. This argument is used twice inside the properties hash. We will set an ID for this component using the number. We will also set a data property with the number.</p></li>
				<li>Once we have the card component, we can create a component that will hold a number of cards:<p class="source-code">(rum/defc cards []</p><p class="source-code">  [:.cards {}</p><p class="source-code">    (card 1)</p><p class="source-code">    (card 2)])</p></li>
				<li>In this example, we create two cards. Finally, we need to place our cards somewhere. A good place is our <strong class="source-inline">main </strong>component. It should look like this now:<p class="source-code">(rum/defc content []</p><p class="source-code">  [:div {}</p><p class="source-code">          (tiles)</p><p class="source-code">          (cards)</p><p class="source-code">          (dropped-message)])</p></li>
				<li>The main content consists of cards and tiles. Even if we went to the web browser, we would not see any cards yet. We have to add some styling:<p class="source-code">.card {</p><p class="source-code">    border: 1px solid red;</p><p class="source-code">    display: inline-block;</p><p class="source-code">    height: 50px;</p><p class="source-code">    width: 50px;</p><p class="source-code">}</p><p>After adding styling for a card, the web browser will show us new content:</p><div id="_idContainer158" class="IMG---Figure"><img src="image/B14502_09_45.jpg" alt="Figure 9.45: Styled cards&#13;&#10;"/></div><p class="figure-caption">Figure 9.45: Styled cards</p><p>Besides two big green tiles, we have two small red cards. The draggable and droppable elements are now placed. We are ready to implement the dragging and dropping behavior.</p></li>
				<li>We will add dragging to cards. We will use the <strong class="source-inline">draggable</strong> function from jQuery UI. Add code for dragging cards to <strong class="source-inline">hello-clojurescript.core</strong>:<p class="source-code">(defn make-draggable []</p><p class="source-code">  (.draggable ($ ".card") (attrs {:revert true :cursor "move"})))</p></li>
				<li>We find HTML elements with the <strong class="source-inline">card</strong> class and use the <strong class="source-inline">$</strong> function from the <strong class="source-inline">jayq</strong> library that we imported at the beginning of the section. The <strong class="source-inline">$</strong> function will create a jQuery object. We call the <strong class="source-inline">draggable</strong> method on this object, passing attributes. Attributes are constructed using a new function, <strong class="source-inline">attrs</strong>:<p class="source-code">(defn attrs [a]</p><p class="source-code">  (c<a id="_idTextAnchor258"/>lj-&gt;js (sablono.util/html-to-dom-attrs a)))</p><p>The <strong class="source-inline">attrs</strong> function takes attributes as arguments. We use <strong class="source-inline">sablono</strong>'s <strong class="source-inline">html-to-dom-attrs</strong> function to convert all HTML attributes to their DOM equivalents. We convert from HTML attributes to DOM attributes because jQuery manipulates the DOM, not HTML.</p></li>
				<li>We need to import the <strong class="source-inline">sablono</strong> library to the <strong class="source-inline">hello-drag-and-drop.core</strong> namespace:<p class="source-code">(ns ^:figwheel-hooks hello-drag-and-drop.core</p><p class="source-code">  (:require [goog.dom :as gdom]</p><p class="source-code">            [jayq.core :as jayq :refer [$]]</p><p class="source-code">            [rum.core :as rum]</p><p class="source-code">            [sablono.util]))</p><p>The <strong class="source-inline">clj-&gt;js</strong> function will recursively transform ClojureScript values to JavaScript. Sets/vectors/lists become arrays, keywords and symbols become strings, and maps become objects. We can code in ClojureScript, and when we need to use JavaScript construct <strong class="source-inline">clj-&gt;js</strong> will convert the necessary constructs from ClojureScript to JavaScript.</p></li>
				<li>The last step is to call <strong class="source-inline">make-draggable</strong> in the <strong class="source-inline">on-reload</strong> function:<p class="source-code">(defn ^:after-load on-reload []</p><p class="source-code">  (mount-app-element)</p><p class="source-code">  (make-draggable))</p><p>Figwheel will compile and reload code in the web browser. We can drag the red cards now:</p><div id="_idContainer159" class="IMG---Figure"><img src="image/B14502_09_46.jpg" alt="Figure 9.46: Dragging the red cards&#13;&#10;"/></div><p class="figure-caption">Figure 9.46: Dragging the red cards</p><p>The last piece in our application is implementing the dropping behavior for tiles. A <strong class="source-inline">tile</strong> should accept a dragged card.</p></li>
				<li>For the dropping behavior, we will use the <strong class="source-inline">droppable</strong> function from the jQuery UI library:<p class="source-code">(defn make-droppable []</p><p class="source-code">  (.droppable ($ (str ".tile"))</p><p class="source-code">                     (attrs {:hoverClass "hovered-tile" :drop handle-drop :activate start-dragging})))</p><p>Similar to the <strong class="source-inline">make-draggable</strong> function, we use the <strong class="source-inline">$</strong> function to construct jQuery objects using the <strong class="source-inline">tile</strong> CSS class. Next, we call the <strong class="source-inline">droppable</strong> function from the jQuery UI library passing attributes as arguments. </p></li>
				<li>We set two attributes. The first one is <strong class="source-inline">:hoverClass</strong>, which takes a value of <strong class="source-inline">hovered-tile</strong>. This attribute allows us to add styling when an element is hovered over with the mouse. In <strong class="source-inline">styles.css</strong>, add the following declaration:<p class="source-code">.hovered-tile {</p><p class="source-code">    background-color: cornflowerblue;</p><p class="source-code">}</p><p>When we hover over a tile during dragging, its background color will change to a shade of blue.</p></li>
				<li>For the second attribute, <strong class="source-inline">:drop</strong>, we assign the <strong class="source-inline">handle-drop</strong> function:<p class="source-code">(defn handle-drop [event ui]</p><p class="source-code">  (let [draggable-id (jayq/data (.-draggable ui) "number")]</p><p class="source-code">    (println "Dropping element with id" draggable-id)</p><p class="source-code">    (reset! is-element-dropped? true)</p><p class="source-code">    (.draggable (.-draggable ui) "disable")</p><p class="source-code">    (.droppable ($ (str "#" (.-id (.-target event)))) "disable")</p><p class="source-code">    (.position (.-draggable ui) </p><p class="source-code">                    (attrs {:of ($ (str "#" (.-id (.-target event)))) :my "left top" :at "left top"}))))</p><p>Inside the <strong class="source-inline">handle-drop</strong> function, we specify the behavior when an element is dropped. There are a few things happening in the function. We access the <strong class="source-inline">draggable</strong> field on the <strong class="source-inline">ui</strong> element using JavaScript interoperability with  <strong class="source-inline">.-</strong> (dot and hyphen). This field is passed to the <strong class="source-inline">data</strong> function from the <strong class="source-inline">jayq</strong> library to access the <strong class="source-inline">data-number</strong> HTML attribute. We print the ID of the dragged element. We reset the atom informing that an element has been dropped. We disable the dragged element. This will add the <strong class="source-inline">ui-draggable-disabled</strong> CSS class to the element. We disable the element into which we dropped, preventing dropping more elements. Finally, we set the position of the dropped element to the top left of the droppable container</p><p>The <strong class="source-inline">handle-drop</strong> function is a good example of using JavaScript interoperability. We call functions on JavaScript objects and access fields from these objects.</p></li>
				<li>The droppable widget allows us to add a function that is called when an element is being dragged:<p class="source-code">(defn start-dragging [event ui]</p><p class="source-code">      (reset! is-element-dropped? false))</p><p>In our implementation, we set the <strong class="source-inline">is-element-dropped?</strong> atom to <strong class="source-inline">false</strong>.</p></li>
				<li>We need to add styling to the element that we dropped. In <strong class="source-inline">styles.css</strong>, add the following declaration:<p class="source-code">.card.ui-draggable-disabled {</p><p class="source-code">    background-color: yellow;</p><p class="source-code">}</p><p>This will set the background color of dropped elements to yellow.</p></li>
				<li>Finally, we will call the <strong class="source-inline">make-droppable</strong> function on <strong class="source-inline">on-js-reload</strong>. It should look as follows:<p class="source-code">(defn ^:after-load on-reload []</p><p class="source-code">  (mount-app-element)</p><p class="source-code">  (make-draggable)</p><p class="source-code">  (make-droppable))</p><p>When we drop an element in the web browser, we will see the following result:</p><div id="_idContainer160" class="IMG---Figure"><img src="image/B14502_09_47.jpg" alt="Figure 9.47: Dropping an element&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.47: Dropping an element</p>
			<p>In this exercise, we have created a drag and drop application. We used JavaScript interoperability to access functions, objects, and fields from JavaScript.</p>
			<p>We did not have any problems when coding this application. There are situations when our application does not operate as expected. In the next section, we will look at exception and error handling in Clojure.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor259"/>Exceptions and Errors in Clojure </h1>
			<p>In an ideal world, every program runs without any problems. In the real world, mistakes happen and programs do not run as planned. Errors and exceptions in Java and Clojure are a mechanism for informing developers when such unexpected situations occur. </p>
			<p>An error indicates a serious problem that an application should not try to catch or handle. An exception indicates conditions that an application might want to catch. To put it another way, errors are situations from which an application cannot recover. Such conditions could be running out of disk space or memory. If an application runs out of disk space to save data, there is no possibility that this application can serve its purpose. Unless we provide more disk space, the application cannot run successfully. Exceptions are conditions from which an application can recover. Such a condition could be trying to access a list from a database before a connection to the database has been established, or trying to use arithmetic operations on strings instead of numbers.</p>
			<p>Both errors and exceptions are subclasses of the <strong class="source-inline">Throwable</strong> class. This class indicates a Java object that can be thrown. Throwing means raising an alert such as an error or an exception. Java provides four constructs to deal with errors and exceptions:</p>
			<ul>
				<li><strong class="source-inline">throw</strong></li>
				<li><strong class="source-inline">try</strong></li>
				<li><strong class="source-inline">catch</strong></li>
				<li><strong class="source-inline">finally</strong></li>
			</ul>
			<p><strong class="source-inline">throw</strong> allows a developer to raise an exception. We could have a web application that accepts user input such as their age. In this application, we could have a feature where we check for the user's age before showing age-restricted content. When we perform an arithmetic operation on input, we expect a number from a user. If a user puts a string instead, the application cannot carry out such calculations. Throwing an error in such a situation will alert the application of an input that is not correct. Once we raise an exception or throw an error, we can deal with them using the remaining three Java constructs.</p>
			<p><strong class="source-inline">try</strong> is a Java reserved word that allows a developer to write a block of code that can potentially result in a <strong class="source-inline">Throwable</strong> object appearing. This code is scoped within a <strong class="source-inline">try</strong> block and guarded against errors. Going back to our application, an age check will be placed inside a <strong class="source-inline">try</strong> block. When we encounter an error or exception, we can handle it. The third construct will help us with that.</p>
			<p><strong class="source-inline">catch</strong> is a reserved word in Java that allows a developer to handle and deal with exceptions and errors. The block of code under catch is executed when the specified exception or error is encountered. In our example, when we try to manipulate an age string such as a number, an exception is thrown and the <strong class="source-inline">catch</strong> block is executed. In this block, we could return a message to the user that they need to input numbers.</p>
			<p><strong class="source-inline">finally</strong> is the last reserved word for dealing with exceptions and errors in Java. The block of code under <strong class="source-inline">finally</strong> is always executed. There are situations when we want to execute code regardless of whether we have encountered an exception or not. An example is I/O operations. Opening a file could raise an error if a file is not present. If a file is present, an error is not thrown. Opening a file uses computer resources such as RAM that we want to free up after we finishing reading the file. Closing a file after reading the <strong class="source-inline">finally</strong> block is a common practice. It is so common that Clojure provides the <strong class="source-inline">with-open</strong> macro that we saw in action in the I/O section of this chapter.</p>
			<p>The most common example of a <strong class="source-inline">try-catch-finally</strong> block is reading or writing to a file. Inside the <strong class="source-inline">try</strong> block, we have an operation to read or write to a file. The <strong class="source-inline">catch</strong> block would guard against IO exceptions such as file not present. In the <strong class="source-inline">finally</strong> block, we would have code to close the file. Closing the file releases computer resources for other tasks.</p>
			<p>The following table presents the most common exceptions and errors in Java:</p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B14502_09_48.jpg" alt="Figure 9.48: Common exceptions and errors in Java&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.48: Common exceptions and errors in Java</p>
			<p>In the next exercise, we will learn how to use <strong class="source-inline">throw</strong>, <strong class="source-inline">try</strong>, <strong class="source-inline">catch</strong>, and <strong class="source-inline">finally</strong> in Clojure. </p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor260"/>Exercise 9.10: Handling Errors and Exceptions in Clojure</h2>
			<p>The aim of this exercise is to learn how exceptions and errors in Clojure are handled. It is common that in Clojure we work with data from Java. In this exercise, we will create a function that takes a Java <strong class="source-inline">ArrayList</strong> instance and an index. The <strong class="source-inline">ArrayList</strong> class is like a vector in Clojure, which we saw in <em class="italic">Chapter 2</em>, <em class="italic">Data Types and Immutability</em>. The <strong class="source-inline">ArrayList</strong> class stores data. We can access elements from the <strong class="source-inline">ArrayList </strong>class using the index, the same as we do with vectors in Clojure. Accessing elements from <strong class="source-inline">ArrayList</strong> can cause exceptions. While designing our function, we will handle the exceptions raised:</p>
			<ol>
				<li value="1">Open Terminal and start the REPL:<p class="source-code">lein repl</p><p>After opening the REPL, we will define an <strong class="source-inline">ArrayList</strong> instance.</p></li>
				<li>We will create an <strong class="source-inline">ArrayList</strong> containing three numbers:<p class="source-code">(def three-numbers-array (java.util.ArrayList. [0 1 2]))</p></li>
				<li>We have an array that contains three numbers, zero to two:<p class="source-code">three-numbers-array</p><p>The output is as follows:</p><p class="source-code">[0 1 2]</p><p>We will create a function that allows us to access elements from an array.</p></li>
				<li>The <strong class="source-inline">array-list-getter</strong> function will allow us to access elements from an array:<p class="source-code"><a id="_idTextAnchor261"/>(defn array-list-getter [array index]</p><p class="source-code"><a id="_idTextAnchor262"/>      (.get array index))</p><p>The <strong class="source-inline">array-list-getter</strong> function takes two arguments: an array and an index. We access an element from the array using the passed index.</p></li>
				<li>When we access the element that is present in the array, we get it back:<p class="source-code">(array-list-getter three-numbers-array 1)</p><p>The output is as follows:</p><p class="source-code">1</p><p>We wanted to get the element at index 1, and we got it back.</p></li>
				<li>When we try to access an element that is not present, Clojure complains:<p class="source-code">(array-list-getter three-numbers-array 5)</p><p>The output is as follows:</p><p class="source-code">IndexOutOfBoundsException Index: 5, Size: 3 java.util.Arraylist.rangeCheck (ArrayList.java:657)</p><p>Our array has only three elements. When we try to access the element at index <strong class="source-inline">5</strong>, Clojure raises <strong class="source-inline">IndexOutOfBoundsException</strong>.</p></li>
				<li>We can catch errors thrown by our code:<p class="source-code">(defn array-list-getter [array index]</p><p class="source-code">      (try</p><p class="source-code">        (.get array index)</p><p class="source-code">        (catch IndexOutOfBoundsException ex</p><p class="source-code">          (str "No element at index " index))))</p></li>
				<li>The new definition of <strong class="source-inline">array-list-getter </strong>catches the <strong class="source-inline">IndexOutOfBoundsException</strong>:<p class="source-code">(array-list-getter three-numbers-array 5)</p><p>The output is as follows:</p><p class="source-code">"No element at index 5"</p><p>In the <strong class="source-inline">catch</strong> block, we specify what error or exception we want to catch and how to handle it. Here, we return information that the array does not have an element in the passed index. </p></li>
				<li>If our code does not throw an exception, the <strong class="source-inline">catch</strong> block is not executed:<p class="source-code">(array-list-getter three-numbers-array 1)</p><p>The output is as follows:</p><p class="source-code">1</p><p>We have an element at index <strong class="source-inline">1</strong>. The <strong class="source-inline">array-list-getter </strong>function returns this number for us. No exception is thrown.</p></li>
				<li>Code in the <strong class="source-inline">finally</strong> block is always executed just before the <strong class="source-inline">try</strong> block finishes. This happens even if no exception has been thrown:<p class="source-code">(defn array-list-getter [array index]</p><p class="source-code">      (try</p><p class="source-code">        (.get array index)</p><p class="source-code">        (catch IndexOutOfBoundsException ex</p><p class="source-code">          (str "No element at index " index))</p><p class="source-code">        (finally (println "Login usage of array-list-getter"))))</p></li>
				<li>Executing this correct code returns the expected result and prints a message that this code always gets executed:<p class="source-code">(array-list-getter three-numbers-array 1)</p><p>The output is as follows:</p><p class="source-code">Login usage of array-list-getter:</p><p class="source-code">1</p><p>We see that when code does not throw any errors or exceptions, only the <strong class="source-inline">finally</strong> block is executed and not the <strong class="source-inline">catch</strong> block.</p></li>
				<li>When our code will throw an error situation, the <strong class="source-inline">catch</strong> and <strong class="source-inline">finally</strong> blocks are executed:<p class="source-code">(array-list-getter three-numbers-array 5)</p><p>This time, we try to access an element that is not present. This code will raise an exception and execute the <strong class="source-inline">finally</strong> block. Instead of getting a number, we see two messages in the REPL. One is from the <strong class="source-inline">catch</strong> block and the other from the <strong class="source-inline">finally</strong> block.</p><p>In this exercise, we have learned about errors and exceptions. Clojure reuses these constructs from Java. Code that can throw errors or exceptions is protected by a <strong class="source-inline">try </strong>block. When exceptions are thrown, code in the <strong class="source-inline">catch</strong> block is executed. For situations when some code needs to be run regardless of exceptions raised, the <strong class="source-inline">finally </strong>block is used.</p></li>
			</ol>
			<p>Like in Java, errors happen in JavaScript as well. In the final section of this chapter, we will learn about errors in JavaScript and how to deal with them in ClojureScript.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor263"/>Errors in JavaScript</h1>
			<p>In the previous section, we learned about errors and exceptions in Java and how to handle them in Clojure. Unexpected situations that lead to problems in JavaScript applications also happen. This results in a need to handle errors. JavaScript does not distinguish between errors and exceptions, so any situations in which code causes the application not to run as expected are errors.</p>
			<p>Like in Java, in JavaScript, we have tools to deal with errors. JavaScript provides four constructs:</p>
			<ul>
				<li><strong class="source-inline">throw</strong></li>
				<li><strong class="source-inline">try</strong></li>
				<li><strong class="source-inline">catch</strong></li>
				<li><strong class="source-inline">finally</strong></li>
			</ul>
			<p>They are the same as we saw in the previous section. JavaScript reuses error handling concepts known from other languages, such as Java. Because JavaScript is not Java, the way we deal with errors in ClojureScript is not 100% the same as in Clojure. It's very close, but code pasted from Clojure to ClojureScript will not work straight away. In the next exercise, we will see how to deal with JavaScript errors in ClojureScript and examine the small syntax differences with error handling in Clojure.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor264"/>ClojureScript Leiningen Templates</h2>
			<p>We have used Leiningen to create projects for us. When we create a new project, we use a project template. Template developers can publish project templates on the internet and other developers (like us) can create projects using such templates.</p>
			<p>So far, we have used Figwheel to create ClojureScript projects. As we have learned, Figwheel provides a lot of default configuration for us. A new Figwheel project comes with features such as hot-code reloading, a REPL, and tests.</p>
			<p>There are situations where we do not need all these nice things from Figwheel. We want a simple ClojureScript setup. For such cases, we can use a <strong class="source-inline">mies</strong> project template. The <strong class="source-inline">mies</strong> template creates a basic project structure for ClojureScript.</p>
			<p>To reiterate, for most situations when we want to develop a website application, we would use Figwheel. On rare occasions when we want a minimal ClojureScript project setup, we will use <strong class="source-inline">mies</strong>.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor265"/>Exercise 9.11: Handling Errors in ClojureScript</h2>
			<p>The aim of this exercise is to learn how ClojureScript handles JavaScript errors. In this exercise, we will write a function that abbreviates programming language names. When a programming language is not supported, we will throw an error to inform the user that this language is not supported:</p>
			<ol>
				<li value="1">Create the project:<p class="source-code">lein new mies error-handling</p><p>This command will create a new project for us. </p></li>
				<li>We will run the ClojureScript REPL from the command line:<p class="source-code">scripts/repl</p><p>This launches the REPL.</p><div id="_idContainer162" class="IMG---Figure"><img src="image/B14502_09_49.jpg" alt="Figure 9.49: Output for the REPL&#13;&#10;"/></div><p><a id="_idTextAnchor266"/></p><p class="figure-caption">Figure 9.49: Output for the REPL</p><p>With REPL launched, we can investigate error handling in ClojureScript.</p></li>
				<li>In our code, we will support the following languages:<p class="source-code">(def languages {:Clojure "CLJ"</p><p class="source-code">                          :ClojureScript "CLJS"</p><p class="source-code">                          :JavaScript "JS"})</p></li>
				<li>We will implement a function that abbreviates a programming language name:<p class="source-code">(defn language-abbreviator [language]</p><p class="source-code">  (if-let [lang (get languages language)]</p><p class="source-code">          lang</p><p class="source-code"> <a id="_idTextAnchor267"/>         (throw (js/Error. "Language not supported"))))</p><p>The function will try to get a short version of a language from a language hash defined earlier.</p><p>If the language is not found, we will throw an error. The syntax of <strong class="source-inline">throw</strong> in ClojureScript is very similar to syntax that we have seen in Clojure. Here, instead of Java classes, we have an <strong class="source-inline">Error</strong> object that we access from the <strong class="source-inline">js</strong> namespace. </p></li>
				<li>When a function is called with a valid argument, it returns the abbreviated name of a programming language:<p class="source-code">(language-abbreviator :JavaScript)</p><p>The output is as follows:</p><p class="source-code">"JS"</p><p>We see that a short name for JavaScript is <strong class="source-inline">JS</strong>.</p></li>
				<li>When we call a function with an invalid argument, it will throw an error:<p class="source-code">(language-abbreviator :Ruby)</p><p>This will return an error as follows:</p><p class="source-code">Execution error (Error) at (&lt;cljs repl&gt;:1)</p><p class="source-code">Language not supported</p><p>We see that Ruby is not a supported language and calling the <strong class="source-inline">language-abbreviator </strong>function with Ruby as the argument throws an error. We know how to throw errors in ClojureScript. We will see how to catch them now.</p></li>
				<li>We will create a function that returns the language of the week:<p class="source-code">(defn get-language-of-the-week [languages]</p><p class="source-code">      (let [lang-of-the-week (rand-nth languages)]</p><p class="source-code">           (try</p><p class="source-code">             (str "The language of the week is: " (language-abbreviator lang-of-the-week))</p><p class="source-code">             (catch js/Error e</p><p class="source-code">               (str lang-of-the-week " is not a supported language")))))</p><p>The function uses Clojure's <strong class="source-inline">rand-nth </strong>function to randomly pick an element from a sequence. Using this language, we try to get an abbreviated version of a language. If the language is not supported and an error is thrown, we catch the error and inform the user that the language is not supported.</p></li>
				<li>Calling the <strong class="source-inline">get-language-of-the-week</strong> function with unsupported languages will result in errors:<p class="source-code">(get-language-of-the-week [:Ruby :Kotlin :Go])</p><p>The output is as follows:</p><p class="source-code">"Go is not a supported language"</p><p>The <strong class="source-inline">Go</strong> language was picked as the language of the week. Sadly, we do not have an abbreviated name for <strong class="source-inline">Go</strong>. The <strong class="source-inline">language-abbreviator</strong> function threw an error that was caught by the <strong class="source-inline">catch</strong> block in the <strong class="source-inline">get-language-of-the-week</strong> function.</p></li>
				<li>We will call the <strong class="source-inline">get-language-of-the-week</strong> function with supported languages:<p class="source-code">(get-language-of-the-week [:Clojure :JavaScript :ClojureScript])</p><p>The output is as follows:</p><p class="source-code">"The language of the week is: CLJS"</p><p>When we call the <strong class="source-inline">get-language-of-the-week</strong> function with supported languages, we get an abbreviated name for the picked language.</p></li>
				<li>We will extend our language of the week function to include the <strong class="source-inline">finally</strong> block:<p class="source-code">(defn get-language-of-the-week [languages]</p><p class="source-code">      (let [lang-of-the-week (rand-nth languages)]</p><p class="source-code">           (try</p><p class="source-code">             (str "The language of the week is: " (language-abbreviator lang-of-the-week))</p><p class="source-code">             (catch js/Error e</p><p class="source-code">               (str lang-of-the-week " is not a supported language"))</p><p class="source-code">             (finally (println lang-of-the-week "was chosen as the language of the week")))))</p><p>With the <strong class="source-inline">finally</strong> block, we can execute any code we want to run regardless of errors thrown in our code.</p></li>
				<li>We will choose a language of the week from the supported languages:<p class="source-code">(get-language-of-the-week [:Clojure :JavaScript :ClojureScript])</p><p>The output is as follows:</p><p class="source-code">ClojureScript was chosen as the language of the week</p><p class="source-code">"The language of the week is: ClojureScript"</p><p>ClojureScript was chosen as the language of the week. The <strong class="source-inline">get-language-of-the-week</strong> function returned the abbreviated name of the chosen language and a message from the <strong class="source-inline">finally </strong>block.</p></li>
				<li>We will choose the language of the week from the languages that are not supported:<p class="source-code">(get-language-of-the-week [:Ruby :Kotlin :Go])</p><p>The output is as follows:</p><p class="source-code">:Kotlin was chosen as the language of the week</p><p class="source-code">":Kotlin is not a supported language"</p><p>Kotlin was chosen as the language of the week. The <strong class="source-inline">get-language-of-the-week</strong> function returned two messages: the message from the <strong class="source-inline">catch </strong>block that Kotlin is not a supported language and the message from the <strong class="source-inline">finally </strong>block.</p></li>
			</ol>
			<p>We have just seen how <strong class="source-inline">try-catch-finally</strong> blocks are used in ClojureScript. Using these constructs will help us write code that can deal with many unexpected situations.</p>
			<p>We now know how to handle exceptions in Clojure and ClojureScript. We have seen how to use interoperability between JavaScript and ClojureScript. It is time to put our knowledge to use. We will write a ClojureScript application that uses JavaScript interoperability.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor268"/>Activity 9.02: Creating a Support Desk</h2>
			<p>The aim of this activity is to write a web application that uses external JavaScript libraries. We will create a support desk application that manages issues raised in the support desk. The application allows us to sort issues and resolve them when they are done. By sorting the issues, we can raise the priority of individual issues.</p>
			<p>The application will have the following features:</p>
			<ul>
				<li>Display how many times the list has been sorted:<p>less than three: few times</p><p>less than six: medium times</p><p>more than six: many times</p></li>
				<li>Filter the list of issues by priority, such as only displaying issues above priority 3.</li>
				<li>Sort the list of issues.</li>
				<li>Resolve an issue.</li>
			</ul>
			<p>The following steps will help you complete the activity:</p>
			<ol>
				<li value="1">Create a new project.</li>
				<li>Add the <strong class="source-inline">jayq</strong> and <strong class="source-inline">cuerdas</strong> libraries as dependencies in <strong class="source-inline">project.clj</strong>.</li>
				<li>Create the <strong class="source-inline">utils</strong> function to filter the issues list by priority.</li>
				<li>Create the <strong class="source-inline">utils</strong> function to get the sorted issues list.</li>
				<li>Create the <strong class="source-inline">utils</strong> function to get the sorted messages by issue count.</li>
				<li>Create the <strong class="source-inline">utils</strong> function to delete issues from a list.</li>
				<li>Create the <strong class="source-inline">utils</strong> function that's called when sorting is finished.</li>
				<li>Add jQuery and jQuery UI to <strong class="source-inline">index.html</strong>.</li>
				<li>Import <strong class="source-inline">jayq</strong> ,<strong class="source-inline">cuerdas</strong> and <strong class="source-inline">utils</strong> to the core namespace.</li>
				<li>Define the priorities list.</li>
				<li>Define app state.</li>
				<li>Define the counter Rum component.</li>
				<li>Create the issue on <strong class="source-inline">click</strong> function.</li>
				<li>Define the issue item Rum component.</li>
				<li>Define the reactive issue items component.</li>
				<li>Define the reactive page content component.</li>
				<li>Make item components sortable.</li>
				<li>Mount the page component.</li>
				<li>Call the mount function.</li>
				<li>Call the sortable function.</li>
				<li>Run the application.</li>
			</ol>
			<p>The initial issues list will look as follows:</p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B14502_09_50.jpg" alt="Figure 9.50: Initial issue list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.50: Initial issue list</p>
			<p>The issues list after sorting will look as follows:</p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B14502_09_51.jpg" alt="Figure 9.51: Issue list after sorting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.51: Issue list after sorting</p>
			<p>The issues list after resolving three issues will look as follows:</p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B14502_09_52.jpg" alt="Figure 9.52: Issue list after resolving issues&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.52: Issue list after resolving issues</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 718.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor269"/>Summary</h1>
			<p>In this chapter, we have learned about the interoperability of Clojure and Java. We saw how to import Java classes in Clojure. We constructed instances of Java classes and called methods on these instances. We have also learned about macros that help us use Java in Clojure.</p>
			<p>Next, we learned about input/output (I/O) operations in Java. We accessed files from a disk, both reading and writing content. We saw how to get input from a user using a keyboard and how to display information back to the user.</p>
			<p>After that, we learned about interoperability in ClojureScript. We created a drag and drop application using objects and methods from JavaScript libraries.</p>
			<p>Finally, we learned about exceptions and errors in Clojure and ClojureScript. We saw how errors are thrown and how to guard against errors using <strong class="source-inline">try-catch</strong> blocks. We investigated the <strong class="source-inline">finally </strong>block and when to use it.</p>
			<p>We finished the chapter by working on a help desk application that allows users to sort a list of items in order of priority.</p>
			<p>In the next chapter, we will investigate testing in Clojure and ClojureScript. We will see why testing is important, what libraries both languages provide for testing, and how to use testing libraries in Clojure and ClojureScript.</p>
		</div>
	</body></html>