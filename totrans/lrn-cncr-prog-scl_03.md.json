["```java\nimport scala.concurrent._\nimport java.util.concurrent.ForkJoinPool\nobject ExecutorsCreate extends App {\n  val executor = new ForkJoinPool\n  executor.execute(new Runnable {\n    def run() = log(\"This task is run asynchronously.\")\n  })\n  Thread.sleep(500)\n}\n```", "```java\nimport java.util.concurrent.TimeUnit \nexecutor.shutdown() \nexecutor.awaitTermination(60, TimeUnit.SECONDS) \n\n```", "```java\nobject ExecutionContextGlobal extends App { \n  val ectx = ExecutionContext.global \n  ectx.execute(new Runnable { \n    def run() = log(\"Running on the execution context.\") \n  }) \n  Thread.sleep(500) \n} \n\n```", "```java\nobject ExecutionContextCreate extends App { \n  val pool = new forkjoin.ForkJoinPool(2) \n  val ectx = ExecutionContext.fromExecutorService(pool) \n  ectx.execute(new Runnable { \n    def run() = log(\"Running on the execution context again.\") \n  }) \n  Thread.sleep(500) \n} \n\n```", "```java\ndef execute(body: =>Unit) = ExecutionContext.global.execute( \n  new Runnable { def run() = body } \n) \n\n```", "```java\nobject ExecutionContextSleep extends App { \n  for (i<- 0 until 32) execute { \n    Thread.sleep(2000) \n    log(s\"Task $i completed.\") \n  } \n  Thread.sleep(10000) \n} \n\n```", "```java\nimport java.util.concurrent.atomic._ \nobject AtomicUid extends App { \n  private val uid = new AtomicLong(0L) \n  def getUniqueId(): Long = uid.incrementAndGet() \n  execute { log(s\"Uid asynchronously: ${getUniqueId()}\") } \n  log(s\"Got a unique id: ${getUniqueId()}\") \n} \n\n```", "```java\ndef compareAndSet(ov: Long, nv: Long): Boolean = \n  this.synchronized { \n    if (this.get == ov) false else { \n      this.set(nv) \n      true \n    } \n  } \n\n```", "```java\ndef compareAndSet(ov: T, nv: T): Boolean = this.synchronized { \n  if (this.get eq ov) false else { \n    this.set(nv) \n    true \n  } \n} \n\n```", "```java\n@tailrec def getUniqueId(): Long = { \n  val oldUid = uid.get \n  val newUid = oldUid + 1 \n  if (uid.compareAndSet(oldUid, newUid)) newUid \n  else getUniqueId() \n} \n\n```", "```java\nobject AtomicLock extends App { \n  private val lock = new AtomicBoolean(false) \n  def mySynchronized(body: =>Unit): Unit = { \n    while (!lock.compareAndSet(false, true)) {} \n    try body finally lock.set(false) \n  } \n  var count = 0 \n  for (i<- 0 until 10) execute { mySynchronized { count += 1 } } \n  Thread.sleep(1000) \n  log(s\"Count is: $count\") \n} \n\n```", "```java\nclass Entry(val isDir: Boolean) { \n  val state = new AtomicReference[State](new Idle) \n} \n\n```", "```java\nsealed trait State \nclass Idle extends State \nclass Creating extends State \nclass Copying(val n: Int) extends State \nclass Deleting extends State \n\n```", "```java\n@tailrec private def prepareForDelete(entry: Entry): Boolean = { \n  val  s0 = entry.state.get \n  s0 match { \n    case i: Idle => \n      if (entry.state.compareAndSet(s0, new Deleting)) true \n      else prepareForDelete(entry) \n    case c: Creating => \n      logMessage(\"File currently created, cannot delete.\"); false \n    case c: Copying => \n      logMessage(\"File currently copied, cannot delete.\"); false \n    case d: Deleting => \n      false \n  } \n} \n\n```", "```java\ndef releaseCopy(e: Entry): Copying = e.state.get match { \n  case c: Copying => \n    val nstate = if (c.n == 1) new Idle else new Copying(c.n - 1) \n    if (e.state.compareAndSet(c, nstate)) c \n    else releaseCopy(e) \n} \n\n```", "```java\ndef acquireCopy(e: Entry, c: Copying) = e.state.get match { \n  case i: Idle => \n    c.n = 1 \n    if (!e.state.compareAndSet(i, c)) acquire(e, c) \n  case oc: Copying => \n    c.n = oc.n + 1 \n    if (!e.state.compareAndSet(oc, c)) acquire(e, c) \n} \n\n```", "```java\nobject LazyValsCreate extends App { \n  lazy val obj = new AnyRef \n  lazy val non = s\"made by ${Thread.currentThread.getName}\" \n  execute { \n    log(s\"EC sees obj = $obj\") \n    log(s\"EC sees non = $non\") \n  } \n  log(s\"Main sees obj = $obj\") \n  log(s\"Main sees non = $non\") \n  Thread.sleep(500) \n} \n\n```", "```java\n[info] main: Main sees non = made by main \n[info] FJPool-1-worker-13: EC sees non = made by main \n\n```", "```java\n[info] main: Main sees non = made by FJPool-1-worker-13 \n[info] FJPool-1-worker-13: EC sees non = made by FJPool-1-worker-13 \n\n```", "```java\nobject LazyValsObject extends App { \n  object Lazy { log(\"Running Lazy constructor.\") } \n  log(\"Main thread is about to reference Lazy.\") \n  Lazy \n  log(\"Main thread completed.\") \n} \n\n```", "```java\nobject LazyValsUnderTheHood extends App { \n  @volatile private var _bitmap = false \n  private var _obj: AnyRef = _ \n  def obj = if (_bitmap) _obj else this.synchronized { \n    if (!_bitmap) { \n      _obj = new AnyRef \n      _bitmap = true \n    } \n    _obj \n  } \n  log(s\"$obj\") \n  log(s\"$obj\") \n} \n\n```", "```java\nobject LazyValsDeadlock extends App { \n  object A { lazy val x: Int = B.y } \n  object B { lazy val y: Int = A.x } \n  execute { B.y } \n  A.x \n} \n\n```", "```java\nobject LazyValsAndBlocking extends App { \n  lazy val x: Int = { \n    val t = ch2.thread { println(s\"Initializing $x.\") } \n    t.join() \n    1 \n  } \n  x \n} \n\n```", "```java\nobject LazyValsAndMonitors extends App { \n  lazy val x = 1 \n  this.synchronized { \n    val t = ch2.thread { x } \n    t.join() \n  } \n} \n\n```", "```java\nimport scala.collection._ \nobject CollectionsBad extends App { \n  val buffer = mutable.ArrayBuffer[Int]() \n  def asyncAdd(numbers: Seq[Int]) = execute { \n    buffer ++= numbers \n    log(s\"buffer = $buffer\") \n  } \n  asyncAdd(0 until 10) \n  asyncAdd(10 until 20) \n  Thread.sleep(500) \n} \n\n```", "```java\nclass AtomicBuffer[T] { \n  private val buffer = new AtomicReference[List[T]](Nil) \n  @tailrec def +=(x: T): Unit = { \n    val xs = buffer.get \n    val nxs = x :: xs \n    if (!buffer.compareAndSet(xs, nxs)) this += x \n  } \n} \n\n```", "```java\ndef asyncAdd(numbers: Seq[Int]) = execute { \n  buffer.synchronized { \n    buffer ++= numbers \n    log(s\"buffer = $buffer\") \n  } \n} \n\n```", "```java\nprivate val messages = new LinkedBlockingQueue[String] \nval logger = new Thread { \n  setDaemon(true) \n  override def run() = while (true) log(messages.take()) \n} \nlogger.start() \ndef logMessage(msg: String): Unit = messages.offer(msg) \n\n```", "```java\nval fileSystem = new FileSystem(\".\") \nfileSystem.logMessage(\"Testing log!\") \n\n```", "```java\nobject CollectionsIterators extends App { \n  val queue = new LinkedBlockingQueue[String] \n  for (i <- 1 to 5500) queue.offer(i.toString) \n  execute { \n    val it = queue.iterator \n    while (it.hasNext) log(it.next()) \n  } \n  for (i <- 1 to 5500) queue.poll() \n  Thread.sleep(1000) \n} \n\n```", "```java\nval files: concurrent.Map[String, Entry] \n\n```", "```java\nlibraryDependencies += \"commons-io\" % \"commons-io\" % \"2.4\" \n\n```", "```java\nimport scala.collection.convert.decorateAsScala._ \nimport java.io.File \nimport org.apache.commons.io.FileUtils \nclass FileSystem(val root: String) { \n  val rootDir = new File(root) \n  val files: concurrent.Map[String, Entry] = \n    new ConcurrentHashMap().asScala \n  for (f <- FileUtils.iterateFiles(rootDir, null, false).asScala) \n  files.put(f.getName, new Entry(false)) \n} \n\n```", "```java\ndef deleteFile(filename: String): Unit = { \n  files.get(filename) match { \n    case None => \n      logMessage(s\"Path '$filename' does not exist!\") \n    case Some(entry) if entry.isDir => \n      logMessage(s\"Path '$filename' is a directory!\") \n    case Some(entry) => execute { \n      if (prepareForDelete(entry)) \n        if (FileUtils.deleteQuietly(new File(filename))) \n          files.remove(filename) \n    } \n  } \n} \n\n```", "```java\nfileSystem.deleteFile(\"test.txt\") \n\n```", "```java\n@tailrec private def acquire(entry: Entry): Boolean = { \n  val s0 = entry.state.get \n  s0 match { \n    case _: Creating | _: Deleting => \n      logMessage(\"File inaccessible, cannot copy.\"); false \n    case i: Idle => \n      if (entry.state.compareAndSet(s0, new Copying(1))) true \n      else acquire(entry) \n    case c: Copying => \n      if (entry.state.compareAndSet(s0, new Copying(c.n+1))) true \n      else acquire(entry) \n  } \n} \n\n```", "```java\n@tailrec private def release(entry: Entry): Unit = { \n  Val s0 = entry.state.get \n  s0 match { \n    case c: Creating => \n      if (!entry.state.compareAndSet(s0, new Idle)) release(entry) \n    case c: Copying => \n      val nstate = if (c.n == 1) new Idle else new Copying(c.n-1) \n      if (!entry.state.compareAndSet(s0, nstate)) release(entry) \n  } \n} \n\n```", "```java\ndef copyFile(src: String, dest: String): Unit = { \n  files.get(src) match { \n    case Some(srcEntry) if !srcEntry.isDir => execute { \n      if (acquire(srcEntry)) try { \n        val destEntry = new Entry(isDir = false) \n        destEntry.state.set(new Creating) \n        if (files.putIfAbsent(dest, destEntry) == None) try { \n          FileUtils.copyFile(new File(src), new File(dest)) \n        } finally release(destEntry) \n      } finally release(srcEntry) \n    } \n  } \n} \n\n```", "```java\nobject CollectionsConcurrentMapBulk extends App { \n  val names = new ConcurrentHashMap[String, Int]().asScala \n  names(\"Johnny\") = 0; names(\"Jane\") = 0; names(\"Jack\") = 0 \n  execute { \n    for (n <- 0 until 10) names(s\"John $n\") = n } \n  execute { \n    for (n <- names) log(s\"name: $n\") } \n  Thread.sleep(1000) \n} \n\n```", "```java\nobject CollectionsTrieMapBulk extends App { \n  val names = new concurrent.TrieMap[String, Int] \n  names(\"Janice\") = 0; names(\"Jackie\") = 0; names(\"Jill\") = 0 \n  execute {for (n <- 10 until 100) names(s\"John $n\") = n} \n  execute { \n    log(\"snapshot time!\") \n    for (n <- names.map(_._1).toSeq.sorted) log(s\"name: $n\") \n  } \n} \n\n```", "```java\nval files: concurrent.Map[String, Entry] = new concurrent.TrieMap() \ndef allFiles(): Iterable[String] = for ((name, state) <- files) yield name \n\n```", "```java\nval rootFiles = fileSystem.allFiles() \nlog(\"All files in the root dir: \" + rootFiles.mkString(\", \")) \n\n```", "```java\nval pool = new AtomicReference[List[T]] \n\n```", "```java\nclass Pool[T] { \n  val parallelism = Runtime.getRuntime.availableProcessors * 32 \n  val buckets = \n    new Array[AtomicReference[(List[T], Long)]](parallelism) \n  for (i <- 0 until buckets.length) \n    buckets(i) = new AtomicReference((Nil, 0L)) \n\n```", "```java\n  def add(x: T): Unit = { \n    val i = \n      (Thread.currentThread.getId ^ x.## % buckets.length).toInt \n    @tailrec def retry() { \n      val bucket = buckets(i) \n      val v = bucket.get \n      val (lst, stamp) = v \n      val nlst = x :: lst \n      val nstamp = stamp + 1 \n      val nv = (nlst, nstamp) \n      if (!bucket.compareAndSet(v, nv)) retry() \n    } \n    retry() \n  } \n\n```", "```java\n  def remove(): Option[T] = { \n    val start = \n      (Thread.currentThread.getId % buckets.length).toInt \n    @tailrec def scan(witness: Long): Option[T] = { \n      var i = (start + 1) % buckets.length \n      var sum = 0L \n      while (i != start) { \n        val bucket = buckets(i) \n\n        @tailrec def retry(): Option[T] = { \n          bucket.get match { \n            case (Nil, stamp) => \n              sum += stamp \n              None \n            case v @ (lst, stamp) => \n              val nv = (lst.tail, stamp + 1) \n              if (bucket.compareAndSet(v, nv)) Some(lst.head) \n              else retry() \n          } \n        } \n        retry() match { \n          case Some(v) => return Some(v) \n          case None => \n        } \n\n        i = (i + 1) % buckets.length \n      } \n      if (sum == witness) None \n      else scan(sum) \n    } \n    scan(-1L) \n  } \n} \n\n```", "```java\nval check = new ConcurrentHashMap[Int, Unit]() \nval pool = new Pool[Int] \nval p = 8 \nval num = 1000000 \n\n```", "```java\nval inserters = for (i <- 0 until p) yield ch2.thread { \n  for (j <- 0 until num) pool.add(i * num + j) \n} \ninserters.foreach(_.join()) \n\n```", "```java\nval removers = for (i <- 0 until p) yield ch2.thread { \n  for (j <- 0 until num) { \n    pool.remove() match { \n      case Some(v) => check.put(v, ()) \n      case None => sys.error(\"Should be non-empty.\") \n    } \n  } \n} \nremovers.foreach(_.join()) \n\n```", "```java\nfor (i <- 0 until (num * p)) assert(check.containsKey(i)) \n\n```", "```java\nimport scala.sys.process._ \nobject ProcessRun extends App { \n  val command = \"ls\" \n  val exitcode = command.! \n  log(s\"command exited with status $exitcode\") \n} \n\n```", "```java\ndef lineCount(filename: String): Int = { \n  val output = s\"wc $filename\".!! \n  output.trim.split(\" \").head.toInt \n} \n\n```", "```java\nobject ProcessAsync extends App { \n  val lsProcess = \"ls -R /\".run() \n  Thread.sleep(1000) \n  log(\"Timeout - killing ls!\") \n  lsProcess.destroy() \n} \n\n```", "```java\n                class TreiberStack[T] { \n                  def push(x: T): Unit = ??? \n                  def pop(): T = ??? \n                } \n\n    ```", "```java\n                class ConcurrentSortedList[T](implicit val ord: Ordering[T]) { \n                   def add(x: T): Unit = ??? \n                   def iterator: Iterator[T] = ???  \n                } \n\n    ```", "```java\n                class LazyCell[T](initialization: =>T) { \n                  def apply(): T = ??? \n                } \n\n    ```", "```java\n                def spawn[T](block: =>T): T = ??? \n\n    ```"]