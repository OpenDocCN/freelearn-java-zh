<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Key Features"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Key Features</h1></div></div></div><p>After a quick introduction about what Apache Camel is, this chapter will introduce the key features provided by Camel. It provides just an overview of these features; the details will come in dedicated chapters.</p><p>In an enterprise, you see a lot of different software and systems in the IT ecosystem. In order to consolidate the data and sync the systems, the enterprise would want to implement communication and integration of these systems. This communication or integration is not so easy, as we have to deal with the specifications on each system the protocol and the message's data format are different most of the time, so we have to transform and adapt to each system.</p><p>Using point-to-point communication is one option. However, the problem with this approach is that we tighten the integration of a couple of systems. Changing to other systems or protocols requires refactoring of the implementation. Moreover, dealing with multiple systems is not so easy with point-to-point.</p><p>So, instead of point-to-point, we use mediation. Mediation reduces complexity and provides a more flexible approach by adding and using a tier between the systems (man in the middle). The purpose is to facilitate the information flow and integration of the systems.</p><p>Apache Camel is a mediation framework.</p><div class="section" title="What is Apache Camel?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is Apache Camel?</h1></div></div></div><p>Apache Camel <a id="id0" class="indexterm"/>originated in <a id="id1" class="indexterm"/>Apache ServiceMix. Apache ServiceMix 3<a id="id2" class="indexterm"/> was powered by the Spring framework and implemented in the JBI specification. The <span class="strong"><strong>Java Business Integration</strong></span> (<span class="strong"><strong>JBI</strong></span>)<a id="id3" class="indexterm"/> specification proposed a Plug and Play approach for integration problems. JBI was based on WebService concepts and standards. For instance, it directly reuses the <span class="strong"><strong>Message Exchange Patterns</strong></span> (<span class="strong"><strong>MEP</strong></span>)<a id="id4" class="indexterm"/> concept that comes from <a id="id5" class="indexterm"/>
<span class="strong"><strong>WebService Description Language</strong></span> (<span class="strong"><strong>WSDL</strong></span>).</p><p>Camel reuses some of these concepts, for instance, you will see that we have the concept of MEP in Camel.</p><p>However, JBI suffered <a id="id6" class="indexterm"/>mostly from two issues:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In JBI, all messages between endpoints are transported in the <a id="id7" class="indexterm"/><span class="strong"><strong>Normalized Messages Router</strong></span> (<span class="strong"><strong>NMR</strong></span>).<p>In the NMR, a message has a standard XML format. As all messages in the NMR have the same format, it's easy to audit messages and the format is predictable.</p><p>However, the JBI XML format has an important drawback for performances: it needs to marshall and unmarshall the messages. Some protocols (such as REST or RMI) are not easy to describe in XML.</p><p>For instance, REST can work in stream mode. It doesn't make sense to marshall streams in XML.</p><p>Camel is payload-agnostic. This means that you can transport any kind of messages with Camel (not necessary XML formatted).</p></li><li class="listitem" style="list-style-type: disc">JBI describes a packaging. We distinguish the binding components (responsible for the interaction with the system outside of the NMR and the handling of the messages in the NMR), and the service engines (responsible for transforming the messages inside the NMR).<p>However, it's not possible to directly deploy the endpoints based on these components. JBI requires a service unit (a ZIP file) per endpoint, and for each package in a service assembly (another ZIP file). JBI also splits the description of the endpoint from its configuration.</p><p>It does not result in a very flexible packaging: with definitions and configurations scattered in different files, not easy to maintain. In Camel, the configuration and definition of the endpoints are gathered in a simple URI. It's easier to read.</p><p>Moreover, Camel doesn't force any packaging; the same definition can be packaged in a simple XML file, OSGi bundle, and regular JAR file.</p></li></ul></div><p>In addition to JBI, another foundation of Camel is the book <span class="emphasis"><em>Enterprise Integration Patterns by Gregor Hohpe and Bobby Woolf</em></span>.</p><p>This book describes design patterns answering classical problems while dealing with enterprise application integration and message oriented middleware.</p><p>The book describes the problems and the patterns to solve them. Camel strives to implement the patterns described in the book to make them easy to use and let the developer concentrate on the task at hand.</p><p>This is what Camel is: an open source framework that allows you to integrate systems and that comes with a lot of connectors and <a id="id8" class="indexterm"/>
<span class="strong"><strong>Enterprise Integration Patterns</strong></span> (<span class="strong"><strong>EIP</strong></span>) components out of the box. And if that is not enough, one can extend and implement custom components.</p></div></div>
<div class="section" title="Components and bean support"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Components and bean support</h1></div></div></div><p>Apache Camel ships with a<a id="id9" class="indexterm"/> wide variety of components out of the box; currently, there are more than 100 components available.</p><p>We can see:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The connectivity components that allow exposure of endpoints for external systems or communicate with external systems. For instance, the FTP, HTTP, JMX, WebServices, JMS, and a lot more components are connectivity components. Creating an endpoint and the associated configuration for these components is easy, by directly using a URI.</li><li class="listitem" style="list-style-type: disc">The internal components applying rules to the messages internally to Camel. These kinds of components apply validation or transformation rules to the inflight message. For instance, validation or XSLT are internal components.</li></ul></div><p>Thanks to this, Camel brings a very powerful connectivity and mediation framework.</p><p>Moreover, it's pretty easy to create new custom components, allowing you to extend Camel if the default components set doesn't match your requirements.</p><p>It's also very easy to implement complex integration logic by creating your own processors and reusing your beans. Camel supports beans frameworks (IoC), such as Spring or Blueprint.</p></div>
<div class="section" title="Predicates and expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Predicates and expressions</h1></div></div></div><p>As we will see later, most of the <a id="id10" class="indexterm"/>EIP need a rule definition to apply a routing logic to a message. The rule is described using an expression.</p><p>It means that we have to define expressions or predicates in the Enterprise Integration Patterns. An expression returns any kind of value, whereas a predicate returns true or false only.</p><p>Camel supports a lot of different languages to declare expressions or predicates. It doesn't force you to use one, it allows you to use the most appropriate one.</p><p>For instance, Camel supports<a id="id11" class="indexterm"/> xpath, mvel, ognl, python, ruby, PHP, JavaScript, SpEL (Spring Expression Language), Groovy, and so on as expression languages. It also provides native Camel prebuilt functions and languages that are easy to use such as header, constant, or simple languages.</p></div>
<div class="section" title="Data format and type conversion"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Data format and type conversion</h1></div></div></div><p>Camel is payload-agnostic. This means that it can support any kind of message. Depending on the endpoints, it could be required to convert from one format to another. That's why Camel supports different data formats, in a pluggable way. This means that Camel can marshall or unmarshall a message in a given format. For instance, in addition to the standard JVM serialization, Camel natively supports Avro, JSON, protobuf, JAXB, XmlBeans, XStream, JiBX, SOAP, and so on.</p><p>Depending on the endpoints and <a id="id12" class="indexterm"/>your need, you can explicitly define the data format during the processing of the message. On the other hand, Camel knows the expected format and type of endpoints. Thanks to this, Camel looks for a type converter, allowing to implicitly transform a message from one format to another.</p><p>You can also explicitly define the type converter of your choice at some points during the processing of the message. Camel provides a set of ready-to-use type converters, but, as Camel supports a pluggable model, you can extend it by providing your own type converters. It's a simple POJO to implement.</p></div>
<div class="section" title="Easy configuration and URI"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Easy configuration and URI</h1></div></div></div><p>Camel uses a different approach based on<a id="id13" class="indexterm"/> URI. The endpoint<a id="id14" class="indexterm"/> itself and its configuration are on the URI.</p><p>The URI is human readable and provides the details of the endpoint, which is the endpoint component and the endpoint configuration.</p><p>As this URI is part of the <a id="id15" class="indexterm"/>complete configuration (which defines what we name a route, as we will see later), it's possible to have a complete<a id="id16" class="indexterm"/> overview of the integration logic and connectivity in a row. We will cover this in detail in <a class="link" href="ch02.html" title="Chapter 2. Core Concepts">Chapter 2</a>, <span class="emphasis"><em>Core Concepts</em></span>.</p></div>
<div class="section" title="Lightweight and different deployment topologies"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Lightweight and different deployment topologies</h1></div></div></div><p>Camel itself is very light. The <a id="id17" class="indexterm"/>Camel core is only around 2 MB, and <a id="id18" class="indexterm"/>contains everything required to run Camel. As it's based on a pluggable architecture, all Camel components are provided as external modules, allowing you to install only what you need, without installing superfluous and needlessly heavy modules.</p><p>As we saw, Camel is based on simple POJO, which means that the Camel core doesn't depend on other frameworks: it's an atomic framework and is ready to use. All other modules (components, DSL, and so on) are built on top of this Camel core.</p><p>Moreover, Camel is not tied to one container for deployment. Camel supports a wide range of containers to run. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A J2EE application server such as WebSphere, WebLogic, JBoss, and so on</li><li class="listitem" style="list-style-type: disc">A Web container such as Apache Tomcat</li><li class="listitem" style="list-style-type: disc">An OSGi container such as Apache Karaf</li><li class="listitem" style="list-style-type: disc">A standalone application using frameworks such as Spring</li></ul></div><p>Camel gives a lot of flexibility, allowing you to embed it into your application or to use an enterprise-ready container.</p></div>
<div class="section" title="Quick prototyping and testing support"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Quick prototyping and testing support</h1></div></div></div><p>In any integration project, it's typical <a id="id19" class="indexterm"/>that we have some part of the integration <a id="id20" class="indexterm"/>logic not yet available. For instance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application to integrate with has not yet been purchased or not yet ready</li><li class="listitem" style="list-style-type: disc">The remote system to integrate with has a heavy cost, not acceptable during the development phase</li><li class="listitem" style="list-style-type: disc">Multiple teams work in parallel, so we may have some kinds of deadlocks between the teams</li></ul></div><p>As a complete integration framework, Camel provides a very easy way to prototype part of the integration logic. Even if you don't have the actual system to integrate, you can simulate this system (mock), as it allows you to implement your integration logic without waiting for dependencies. The mocking support is directly part of the Camel core and doesn't require any additional dependency.</p><p>Along the same lines, testing<a id="id21" class="indexterm"/> is also crucial in an integration <a id="id22" class="indexterm"/>project. In such a kind of project, a lot of errors can happen and most are unforeseen. Moreover, a small change in an integration process might impact a lot of other processes. Camel provides the tools to easily test your design and integration logic, allowing you to integrate this in a continuous integration platform.</p></div>
<div class="section" title="Management and monitoring using JMX"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Management and monitoring using JMX</h1></div></div></div><p>Apache Camel uses the<a id="id23" class="indexterm"/> Java Management Extension (JMX) standard and provides a lot of insights into the system using MBeans (Management Beans), providing a detailed view of the following current system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The different integration processes with the associated metrics</li><li class="listitem" style="list-style-type: disc">The different components and endpoints with the associated metrics</li></ul></div><p>Moreover, these MBeans provide more insights than metrics. They also provide the operations to manage Camel. For instance, the operations allow you to stop an integration process, to suspend an endpoint, and so on. Using a combination of metrics and operations, you can configure a very agile integration solution.</p></div>
<div class="section" title="Active community"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Active community</h1></div></div></div><p>The Apache Camel community<a id="id24" class="indexterm"/> is very active. This means that potential issues are identified very quickly and a fix is available soon after. However, it also means that a lot of ideas and contributions are proposed, giving more and more features to Camel.</p><p>Another big advantage of an active community is that you will never be alone; a lot of people are active on the mailing lists who are ready to answer your question and provide advice.</p><p>Apache Camel is an enterprise integration solution used in many large organizations with enterprise support available through RedHat or Talend.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Summary</h1></div></div></div><p>This chapter briefly introduced Camel and where it's come from. It mainly introduced Camel's key features. In the next chapter, before dealing with some of these features in detail, we will introduce the Camel core concepts, which will help you easily understand the further chapters.</p></div></body></html>