<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Scala Goodies"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Scala Goodies</h1></div></div></div><p>We have covered a number of technologies and toolkits in the previous chapters that, when combined together, offer a great opportunity to build modern and scalable-reactive web applications in Scala. Scala now celebrates 10 years of existence with an active community and large corporations supporting it, leading to a perpetual exploration of innovative ideas touching the language and the ecosystem.</p><p>We propose, in this last chapter, to touch upon a few areas where we have found some exciting ongoing projects or technologies and where we feel that Scala can provide elegant solutions to be both productive and fun. We will cover some of the following aspects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">NoSQL database access through MongoDB</li><li class="listitem" style="list-style-type: disc">Introducing DSLs and in particular, a glimpse at Parser Combinators</li><li class="listitem" style="list-style-type: disc">Scala.js—compiling Scala to JavaScript on the client side</li></ul></div><div class="section" title="Exploring MongoDB"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Exploring MongoDB</h1></div></div></div><p>As the volume of information to <a id="id552" class="indexterm"/>process and store has drastically increased in the past few years, many IT shops have been looking for alternatives to traditional relational databases to store and query data. The <span class="strong"><strong>not only SQL</strong></span> (<span class="strong"><strong>NoSQL</strong></span>) database <a id="id553" class="indexterm"/>movement has gained popularity as a way to trade consistency and <a id="id554" class="indexterm"/>structure of the data for more efficient or flexible data storage. MongoDB (<a class="ulink" href="http://www.mongodb.org">www.mongodb.org</a>) is a database product designed to store documents in formats, such as JSON, and with no strict database schema. Along with the Java driver built to access and query a MongoDB database, we are going to discover how the Casbah <a id="id555" class="indexterm"/>Scala toolkit (<a class="ulink" href="https://github.com/mongodb/casbah">https://github.com/mongodb/casbah</a>) can be used to conveniently access and query such a database through a DSL.</p><div class="section" title="Entering Casbah"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec67"/>Entering Casbah</h2></div></div></div><p>The only requirement to start <a id="id556" class="indexterm"/>experimenting with Casbah is to add its <code class="literal">.jar</code> library dependency to an <a id="id557" class="indexterm"/>SBT or Play project. In a new directory on your disk, type <code class="literal">&gt; play new ch10samples</code> from a terminal window and add the Casbah dependency to the <code class="literal">build.sbt</code> file in the root directory of the project. This dependency is added by adding the following code (note that the given version of Casbah was the latest available at the time of writing this chapter, but should soon be available as the final version 2.7.0):</p><div class="informalexample"><pre class="programlisting">name := "ch10samples"

version := "1.0-SNAPSHOT"

libraryDependencies ++= Seq(
  jdbc,
  anorm,
  cache,
  "org.mongodb" %% "casbah" % "2.7.0-RC1"
)     

play.Project.playScalaSettings</pre></div><p>If you are using an SBT project instead of Play, you may also add a default SLF4J logging implementation, as shown in the following code snippet, as otherwise the default used is a no-operation implementation:</p><div class="informalexample"><pre class="programlisting">libraryDependencies += "org.slf4j" % "slf4j-simple" % "1.7.6"</pre></div><p>As usual, starting an REPL can be done either by entering the <code class="literal">&gt; play</code> command followed by a <code class="literal">&gt; console</code> command or just <code class="literal">&gt; play console</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import com.mongodb.casbah.Imports._</strong></span>
<span class="strong"><strong>import com.mongodb.casbah.Imports._</strong></span>
</pre></div><p>After some imports, we connect to the MongoDB database on port <code class="literal">27017</code> using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val mongoClient = MongoClient("localhost", 27017)</strong></span>
<span class="strong"><strong>mongoClient: com.mongodb.casbah.MongoClient = com.mongodb.casbah.MongoClient@6fd10428</strong></span>
<span class="strong"><strong>scala&gt; val db = mongoClient("test")</strong></span>
<span class="strong"><strong>db: com.mongodb.casbah.MongoDB = test</strong></span>
<span class="strong"><strong>scala&gt; val coll = db("test")</strong></span>
<span class="strong"><strong>coll: com.mongodb.casbah.MongoCollection = test</strong></span>
</pre></div><p>These statements have, so far, been executed without a direct contact with the database. From now on, we need to make sure we have a running instance of the MongoDB process before we retrieve any content. Start the <a id="id558" class="indexterm"/>
<code class="literal">mongod</code> daemon if it is not running yet (download instructions can be found at <a class="ulink" href="https://www.mongodb.org/downloads">https://www.mongodb.org/downloads</a>), then enter the following command to fetch the names of the stored collections:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; db.collectionNames</strong></span>
<span class="strong"><strong>res0: scala.collection.mutable.Set[String] = Set()</strong></span>
</pre></div><p>We obviously get an empty set as a result, as we haven't stored any document yet. Let's create a couple of entries:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sales  = MongoDBObject("title" -&gt; "sales","amount"-&gt;50)</strong></span>
<span class="strong"><strong>sales: com.mongodb.casbah.commons.Imports.DBObject = { "title" : "sales" , "amount" : 50}</strong></span>
<span class="strong"><strong>scala&gt; val sweden  = MongoDBObject("country" -&gt; "Sweden")</strong></span>
<span class="strong"><strong>sweden: com.mongodb.casbah.commons.Imports.DBObject = { "country" : "Sweden"}</strong></span>
</pre></div><p>The created items have yet to be added <a id="id559" class="indexterm"/>to the database, using the <code class="literal">insert</code> command as shown in <a id="id560" class="indexterm"/>the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; coll.insert(sales)</strong></span>
<span class="strong"><strong>res1: com.mongodb.casbah.TypeImports.WriteResult = { "serverUsed" : "localhost:27017" , "n" : 0 , "connectionId" : 7 , "err" :  null  , "ok" : 1.0}</strong></span>
<span class="strong"><strong>scala&gt; coll.insert(sweden)</strong></span>
<span class="strong"><strong>res2: com.mongodb.casbah.TypeImports.WriteResult = { "serverUsed" : "localhost:27017" , "n" : 0 , "connectionId" : 7 , "err" :  null  , "ok" : 1.0}</strong></span>
<span class="strong"><strong>scala&gt; coll.count()</strong></span>
<span class="strong"><strong>res3: Int = 2</strong></span>
</pre></div><p>Retrieving the elements of the <a id="id561" class="indexterm"/>
<code class="literal">coll</code> <a id="id562" class="indexterm"/>collection can be done using the <code class="literal">find</code> <a id="id563" class="indexterm"/>method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val documents = coll.find() foreach println </strong></span>
<span class="strong"><strong>{ "_id" : { "$oid" : "530fd91d03645ab9c17d9012"} , "title" : "sales" , "amount" : 50}</strong></span>
<span class="strong"><strong>{ "_id" : { "$oid" : "530fd92703645ab9c17d9013"} , "country" : "Sweden"}</strong></span>
<span class="strong"><strong>documents: Unit = ()</strong></span>
</pre></div><p>Notice that a primary key for each document has been created as we did not provide any while inserting the document into the collection. You may as well retrieve a single document if you know exactly the object you are looking for and provide it as an argument. For this, the <code class="literal">findOne</code> <a id="id564" class="indexterm"/>method is available, passing a new <code class="literal">SearchedCountry MongoDBObject</code> as expressed in the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val searchedCountry  = MongoDBObject("country" -&gt; "Sweden")</strong></span>
<span class="strong"><strong>searchedCountry: com.mongodb.casbah.commons.Imports.DBObject = { "country" : "Sweden"}</strong></span>
<span class="strong"><strong>scala&gt; val result = coll.findOne(searchedCountry)</strong></span>
<span class="strong"><strong>result: Option[coll.T] = Some({ "_id" : { "$oid" : "530fd92703645ab9c17d9013"} , "country" : "Sweden"})</strong></span>
</pre></div><p>As there might not always be a matching <a id="id565" class="indexterm"/>element, the <code class="literal">findOne</code> method returns <code class="literal">Option</code>, which in the previous case resulted in <code class="literal">Some(value)</code>, in contrast to the following empty result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val emptyResult = coll.findOne(MongoDBObject("country" -&gt; "France"))</strong></span>
<span class="strong"><strong>emptyResult: Option[coll.T] = None</strong></span>
</pre></div><p>Deleting elements is performed with the <a id="id566" class="indexterm"/>
<code class="literal">remove</code> method, which can be used in a manner similar to the <code class="literal">findOne</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val result = coll.remove(searchedCountry)</strong></span>
<span class="strong"><strong>result: com.mongodb.casbah.TypeImports.WriteResult = { "serverUsed" : "localhost:27017" , "n" : 1 , "connectionId" : 9 , "err" :  null  , "ok" : 1.0}</strong></span>
<span class="strong"><strong>scala&gt; val countryNoMore = coll.findOne(searchedCountry)</strong></span>
<span class="strong"><strong>countryNoMore: Option[coll.T] = None</strong></span>
</pre></div><p>Finally, updating a document can <a id="id567" class="indexterm"/>be done as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; sales</strong></span>
<span class="strong"><strong>res3: com.mongodb.casbah.commons.Imports.DBObject = { "title" : "sales" , "amount" : 50}</strong></span>
<span class="strong"><strong>scala&gt; val newSales = MongoDBObject("title" -&gt; "sales","amount"-&gt;100)</strong></span>
<span class="strong"><strong>newSales: com.mongodb.casbah.commons.Imports.DBObject = { "title" : "sales" , "amount" : 100</strong></span>
<span class="strong"><strong>scala&gt; val result = coll.update(sales,newSales)</strong></span>
<span class="strong"><strong>result: com.mongodb.casbah.TypeImports.WriteResult = { "serverUsed" : "localhost:27017" , "updatedExisting" : true , "n" : 1 , "connectionId" : 9 , "err" :  null  , "ok" : 1.0}</strong></span>
<span class="strong"><strong>scala&gt; coll.find foreach println</strong></span>
<span class="strong"><strong>{ "_id" : { "$oid" : "530fd91d03645ab9c17d9012"} , "title" : "sales" , "amount" : 100}</strong></span>
</pre></div><p>We can see here that the primary key "530fd91d03645ab9c17d9012" is still the one we had when we initially inserted the <code class="literal">sales</code> document into the database, <a id="id568" class="indexterm"/>showing that the <code class="literal">update</code> operation was not a removal and then inserting a brand new element.</p><p>Updating multiple documents at once is <a id="id569" class="indexterm"/>also supported and we refer to the documentation available at <a class="ulink" href="http://mongodb.github.io/casbah/guide/index.html">http://mongodb.github.io/casbah/guide/index.html</a> for further operations.</p></div><div class="section" title="Applying MapReduce transformations"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec68"/>Applying MapReduce transformations</h2></div></div></div><p>Among the great <a id="id570" class="indexterm"/>features of document-oriented databases such as MongoDB, there is the possibility to run the MapReduce functions. <a id="id571" class="indexterm"/>
<span class="strong"><strong>MapReduce</strong></span> is an approach where you break up a query or task into smaller chunks of work, and then aggregate the results of those chunks. To illustrate how a document-based approach can sometimes be useful in contrast with a traditional relational database, let's take a small example of financial consolidation. In such a domain, aggregating and calculating sales figures globally for a large corporation may involve working with a number of orthogonal dimensions. For instance, sales figures can be gathered from each subsidiary that each has its own geographic location, time intervals, own currency, and specific categories, following some tree-based structures in each dimension as depicted in the following figure:</p><div class="mediaobject"><img src="graphics/3637OS_10_06.jpg" alt="Applying MapReduce transformations"/></div><p>The geographic location might be a decisive factor when it comes to the currency used, and conversion should be done to sum figures consistently. To that extent, the currency used to produce global reports usually follows the root of the company ownership tree. A company tree structure is given in the following figure:</p><div class="mediaobject"><img src="graphics/3637OS_10_07.jpg" alt="Applying MapReduce transformations"/></div><p>Similarly, various sales <a id="id572" class="indexterm"/>categories might define yet <a id="id573" class="indexterm"/>another hierarchy, as shown on the following figure:</p><div class="mediaobject"><img src="graphics/3637OS_10_08.jpg" alt="Applying MapReduce transformations"/></div><p>Such reported sales figures may either be very detailed or already accumulated, therefore, reported at various levels of the hierarchies. As large corporations are usually made of smaller groups with various degrees of ownership that are furthermore changing regularly, the consolidation job requires to aggregate and compute data according to all these parameters.</p><p>As for a number of data warehousing solutions expressed in relational databases, the heart of the domain model can be a huge table containing facts referring to the various dimensions expressed in the previous figure. For instance, some sample input data for this example can consist in the <a id="id574" class="indexterm"/>following list of sales figures (that is, amounts) as XML rows:</p><div class="mediaobject"><img src="graphics/3637OS_10_04.jpg" alt="Applying MapReduce transformations"/></div><p>The following construct shows <a id="id575" class="indexterm"/>how to represent a tree structure in JSON:</p><div class="informalexample"><pre class="programlisting">{
  "title" : "root",
  "children" : [
    {
      "title" : "node 1",
      "children" : [
        {
          "title" : "node 1.1",
          "children" : [
            ...
          ]
        },
        {
          "title" : "node 1.2",
          "children" : [
            ...
          ]
        }
      ]
    },
    {
      "title" : "node 2",
      "children" : [
        ...
      ]
    }
  ]
}</pre></div><p>The following is an example of a <a id="id576" class="indexterm"/>JSON document that contains sales figures by geographic location:</p><div class="informalexample"><pre class="programlisting">{
  "title" : "sales",
  "regions" : [
    {
      "title" : "nordic",
      "regions" : [
        {
          "title" : "norway",
          "amount" : 150
        },
        {
          "title" : "sweden",
          "amount" : 200
        }
      ]
    },
    {
      "title" : "france",
      "amount" : 400
    }
  ]
}</pre></div><p>By storing documents coming from various subsidiaries of a large corporation, such as JSON, we can <a id="id577" class="indexterm"/>consolidate the figures through MapReduce transformations already supported by the database. Moreover, Casbah takes advantage of the aggregation framework (<a class="ulink" href="http://mongodb.github.io/casbah/guide/aggregation.html">http://mongodb.github.io/casbah/guide/aggregation.html</a>) of MongoDB to be able to aggregate values without having to use MapReduce </p><p>To conclude with MongoDB, we <a id="id578" class="indexterm"/>will just mention the ReactiveMongo <a id="id579" class="indexterm"/>project (<a class="ulink" href="http://www.reactivemongo.org">www.reactivemongo.org</a>) that figures a reactive asynchronous and non-blocking driver for MongoDB. As it uses the <a id="id580" class="indexterm"/>Iteratee pattern that we covered in <a class="link" href="ch09.html" title="Chapter 9. Building Reactive Web Applications">Chapter 9</a>, <span class="emphasis"><em>Building Reactive Web Applications</em></span>, combining it with a stream-friendly framework, such as Play, can result in a number of interesting and scalable demos, as listed on their website.</p></div></div></div>
<div class="section" title="Scratching the surface of Big Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Scratching the surface of Big Data</h1></div></div></div><p>Among the recent achievements and trends towards better analysis of data and services lies the Big Data movement. In particular, the Hadoop framework has established some kind of ad hoc standard "for the distributed processing of large datasets across clusters of computers using simple programming models". In addition to a distributed file system called HDFS <a id="id581" class="indexterm"/>optimized for high throughput to access data, Hadoop offers MapReduce facilities for processing large datasets in parallel. As setting up and running Hadoop is not always considered a simple task, some other frameworks have been developed on top of Hadoop as a means to simplify the definition of Hadoop jobs. In Java, the Cascading framework is a layer on top of Hadoop that provides a convenient API to facilitate creation of MapReduce jobs. In Scala, the Scalding framework has been developed to further enhance the cascading API by utilizing the concise and expressive Scala syntax, as we can observe by taking a look at the <code class="literal">activator-scalding</code> Typesafe activator template. The sample code provided with this template illustrates a word counting application, that is, the <code class="literal">hello-world</code> project of Hadoop MapReduce jobs.</p><p>As a reminder on MapReduce jobs, <a id="id582" class="indexterm"/>consider reading the original paper from Google, available at <a class="ulink" href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf">http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf</a>
</p><p>We can express the job of counting words with the following two steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Splitting lines from a file into individual words and creating a key-value pair for each word, where key is the word of the <code class="literal">String</code> type and value is the constant <code class="literal">1</code></li><li class="listitem" style="list-style-type: disc">By grouping the elements having the same key (grouping the same words) into a list and reducing the list by summing the values, we obtain our goal</li></ul></div><p>If you run the <code class="literal">&gt; activator ui</code> command in a terminal window, as we already did a number of times in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>, and create the <code class="literal">activator-scalding</code> template project, you can verify how concise the word count in scalding is specified. Do not forget to run the <code class="literal">&gt; activator eclipse</code> command to be able to import the project into the Eclipse IDE:</p><div class="informalexample"><pre class="programlisting">class WordCount(args : Args) extends Job(args) {

  // Tokenize into words by by splitting on non-characters. This
  // is imperfect, as it splits hyphenated words, possessives
  // ("John's"), etc.
  val tokenizerRegex = """\W+"""

  // Read the file specified by the --input argument and process
  // each line by trimming the leading and trailing whitespace,
  // converting to lower case,then tokenizing into words.
  // The first argument list to flatMap specifies that we pass the
  // 'line field to the anonymous function on each call and each
  // word in the returned collection of words is given the name
  // 'word. Note that TextLine automatically associates the name
  // 'line with each line of text. It also tracks the line number
  // and names that field 'offset. Here, we're dropping the
  // offset.

  TextLine(args("input"))
    .read
    .flatMap('line -&gt; 'word) {
      line : String =&gt; line.trim.toLowerCase.split(tokenizerRegex) 
    }

  // At this point we have a stream of words in the pipeline. To
  // count occurrences of the same word, we need to group the
  // words together. The groupBy operation does this. The first
  // argument list to groupBy specifies the fields to group over
  // as the key. In this case, we only use the 'word field. 
  // The anonymous function is passed an object of type
  // com.twitter.scalding.GroupBuilder. All we need to do is
  // compute the size of the group and we give it an optional
  // name, 'count.
    .groupBy('word){ group =&gt; group.size('count) }

  // In many data flows, we would need to project out just the
  // 'word and 'count, since we don't care about them any more,
  // but groupBy has already eliminated everything but 'word and
  // 'count. Hence, we'll just write them out as tab-delimited
  // values.
    .write(Tsv(args("output")))
}</pre></div><p>Most of the code is indeed comments, which means that the whole algorithm is very close to the description one would do in pseudo code.</p><p>If you are interested in Big Data, Scala definitely fits a niche and a number of projects and frameworks handling huge streams of data and Hadoop-like jobs are already pushing the limits. Among them, we can mention <a id="id583" class="indexterm"/>Spark (<a class="ulink" href="http://spark.apache.org">http://spark.apache.org</a>) as well as Twitter's open-source projects <a id="id584" class="indexterm"/>SummingBird (<a class="ulink" href="https://github.com/twitter/summingbird">https://github.com/twitter/summingbird</a>) and <a id="id585" class="indexterm"/>Algebird (<a class="ulink" href="https://github.com/twitter/algebird">https://github.com/twitter/algebird</a>).</p></div>
<div class="section" title="Introducing DSLs in Scala"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Introducing DSLs in Scala</h1></div></div></div><p>
<span class="strong"><strong>Domain specific language</strong></span> (<span class="strong"><strong>DSL</strong></span>) is usually useful to simplify the interaction with a system by being applied to a small particular domain. They can be <a id="id586" class="indexterm"/>targeted to programmers by providing a simplified <a id="id587" class="indexterm"/>API to communicate with a system; or they may concern the so-called "business users" who may understand a domain well enough to create some scripts but are not programmers and could have difficulty dealing with a general-purpose programming language. There are, in general, two types of DSLs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Internal DSLs</li><li class="listitem" style="list-style-type: disc">External DSLs</li></ul></div><div class="section" title="Observing internal DSLs"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec69"/>Observing internal DSLs</h2></div></div></div><p>Internal DSLs use a host <a id="id588" class="indexterm"/>language (for instance, Scala) and the simplified usage is obtained by <a id="id589" class="indexterm"/>adding some syntactic sugar, through tricks and special constructs of the language. The book <span class="emphasis"><em>DSLs in Action</em></span> by Debasish Ghosh illustrates the construction of Scala internal DSLs using features of the language such as infix notation and implicit conversions.</p><p>He has given the following DSL usage example that represents an executable program expressed in clear English: <code class="literal">200 discount bonds IBM for_client NOMURA on NYSE at 72.ccy(USD)</code>. Many transformations happen under the hood, but the business user is given a very clean syntax.</p><p>Such DSLs have the advantage that you are confident that you can express anything with them as the host language is of generic purpose (such as Scala). This means that sometimes you may be constrained to use a less clean syntax but you know you have the full power of the Scala compiler under your hands. Therefore, you will always succeed in producing a DSL script or program that implements the logic you want.</p><p>However, the full power of the compiler may also be something that you would like to avoid in many cases where you want <a id="id590" class="indexterm"/>to give your business user the possibility to only perform a few specific actions. For this purpose, you may implement external DSLs instead. <a id="id591" class="indexterm"/>There are a number of additional concerns including constrained syntax (for example, you can't avoid parentheses in some cases) and convoluted error messages.</p></div><div class="section" title="Tackling external DSLs through parser combinators"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec70"/>Tackling external DSLs through parser combinators</h2></div></div></div><p>An external <a id="id592" class="indexterm"/>DSL represents a domain <a id="id593" class="indexterm"/>language where the syntax is completely up to you. This means you can express things exactly the way you want to and can constrain your business users to only use specific words or meanings. This flexibility comes with a price of much more work to implement it as you need to define a grammar (typically <a id="id594" class="indexterm"/>
<span class="strong"><strong>Backus–Naur Form</strong></span> (<span class="strong"><strong>BNF</strong></span>)), that is, define all the rules that apply to parse a meaning or script successfully. In Java, the task to write an external DSL can be cumbersome and it usually involves the ANTLR external framework.</p><p>In Scala, parser combinators are a notion very close to the definition of BNF grammars and can provide very concise and elegant code when writing external DSLs.</p><p>Once you get acquainted with a few particular operators to deal with the definition of the grammar, you will discover that writing an external DSL is fairly straightforward if your language is not too complex. A good source of information to learn all the symbols and operators involved in parser <a id="id595" class="indexterm"/>combinators is available at <a class="ulink" href="http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/">http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/</a>.</p><p>The following experimental code illustrates a small DSL in the domain of finance consolidation where specific money accounts are manipulated as part of predefined formulae. The main method given at the end of the following snippet reflects a formula; for instance, you may parse the formula (<code class="literal">3*#ACCOUNT1#</code>) to                                                           construct an object-oriented structure that will be able to compute the result of multiplying the content of a given account by three:</p><div class="informalexample"><pre class="programlisting">package parsercombinator

import scala.util.parsing.combinator._
import java.text.SimpleDateFormat
import java.util.Date

object FormulaCalculator {
  
  abstract class Node
  
  case class Transaction(amount: Int)
  case class Account(name:String) extends Node {
    var transactions: Iterable[Transaction] = List.empty
  }
  
  def addNewTransaction(startingBalance: Int, t: Transaction) = startingBalance + t.amount
  def balance(account: Account) = account.transactions.foldLeft(0)(addNewTransaction)

  case class NumberOfPeriods (value: Int) extends Node {
    override def toString = value.toString
  }
  case class RelativePeriod (value:String) extends Node {
    override def toString = value
  }
  case class Variable(name : String) extends Node
  case class Number(value : Double) extends Node
  case class UnaryOp(operator : String, arg : Node) extends Node
  case class BinaryOp(operator : String, left : Node, right : Node) extends Node
  case class Function(name:String,arguments:List[Node]) extends Node {
    override def toString =
      name+arguments.mkString("(",",",")")
  }…</pre></div><p>The objects that <a id="id596" class="indexterm"/>will result from the parsing of a <a id="id597" class="indexterm"/>formula are defined as <span class="strong"><strong>case classes</strong></span>. Hence, continuing with the code:</p><div class="informalexample"><pre class="programlisting">…
  def evaluate(e : Node) : Double = {
    e match {
      case Number(x) =&gt; x
      case UnaryOp("-", x) =&gt; -(evaluate(x))
      case BinaryOp("+", x1, x2) =&gt; (evaluate(x1) + evaluate(x2))
      case BinaryOp("-", x1, x2) =&gt; (evaluate(x1) - evaluate(x2))
      case BinaryOp("*", x1, x2) =&gt; (evaluate(x1) * evaluate(x2))
      case BinaryOp("/", x1, x2) =&gt; (evaluate(x1) / evaluate(x2))
    }
  }

  object FormulaParser extends JavaTokenParsers {        
    
    val identifier: Parser[String] = ident
    val relative_period: Parser[RelativePeriod] = """([N|P|\+|\-][0-9]+|CURRENT)""".r ^^ RelativePeriod
    val number_of_periods: Parser[NumberOfPeriods] = """\d+""".r ^^ (i =&gt; NumberOfPeriods(i.toInt))
    val account_name: Parser[String] = """[A-Za-z0-9_]+""".r
    
    def account: Parser[Account] = "#" ~&gt; account_name &lt;~ "#" ^^ { Account(_) }
    
    def function: Parser[Function] =
      identifier~"("~account~","~relative_period~","~number_of_periods~")" ^^ {
        case f~"("~acc~","~rp~","~nbp~")" =&gt; Function(f,List(acc,rp,nbp))
      } |
      identifier~"("~account~","~relative_period~")" ^^ {
        case f~"("~acc~","~rp~")" =&gt; Function(f,List(acc,rp))
      }

      def node: Parser[Node] =
        (term ~ "+" ~ term) ^^ { case lhs~plus~rhs =&gt; BinaryOp("+", lhs, rhs) } |
        (term ~ "-" ~ term) ^^ { case lhs~minus~rhs =&gt; BinaryOp("-", lhs, rhs) } |
        term

      def term: Parser[Node] =
        (factor ~ "*" ~ factor) ^^ { case lhs~times~rhs =&gt; BinaryOp("*", lhs, rhs) } |
        (factor ~ "/" ~ factor) ^^ { case lhs~div~rhs =&gt; BinaryOp("/", lhs, rhs) } |
        (factor ~ "^" ~ factor) ^^ { case lhs~exp~rhs =&gt; BinaryOp("^", lhs, rhs) } |
        factor

      def factor : Parser[Node] =
        "(" ~&gt; node &lt;~ ")" |
        floatingPointNumber ^^ {x =&gt; Number(x.toFloat) } |
        account |
        function

      def parse(text : String) =
            parseAll(node, text)        
    }

    // Parses 3 formula that make computations on accounts
    def main(args: Array[String]) {
        
        val formulaList = List("3*#ACCOUNT1#","#ACCOUNT1#- #ACCOUNT2#","AVERAGE_UNDER_PERIOD(#ACCOUNT4#,+1,12)")
        
        formulaList.foreach { formula =&gt;
            val unspacedFormula = formula.replaceAll("[ ]+","")
            println(s"Parsing of $formula gives result:\n ${FormulaParser.parse(unspacedFormula)}")
        }
    }
}</pre></div><p>If we execute this parser <a id="id598" class="indexterm"/>combinator code into <a id="id599" class="indexterm"/>Eclipse by simply right-clicking on the <code class="literal">FormulaCalculator</code> class and navigating to <span class="strong"><strong>Run As</strong></span> | <span class="strong"><strong>Scala Application</strong></span>, we should obtain the following output in the Eclipse console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Parsing of 3*#ACCOUNT1# gives result:</strong></span>
<span class="strong"><strong> [1.13] parsed: BinaryOp(*,Number(3.0),Account(ACCOUNT1))</strong></span>
<span class="strong"><strong>Parsing of #ACCOUNT1#- #ACCOUNT2# gives result:</strong></span>
<span class="strong"><strong> [1.22] parsed: BinaryOp(-,Account(ACCOUNT1),Account(ACCOUNT2))</strong></span>
<span class="strong"><strong>Parsing of AVERAGE_UNDER_PERIOD(#ACCOUNT4#,+1,12) gives result:</strong></span>
<span class="strong"><strong> [1.39] parsed: AVERAGE_UNDER_PERIOD(Account(ACCOUNT4),+1,12)</strong></span>
</pre></div><p>This output shows that the three formulae were parsed correctly and converted into classes. The final evaluation <a id="id600" class="indexterm"/>is left out from this <a id="id601" class="indexterm"/>exercise but could be set up with some actual transactions defined on the two accounts.</p></div></div>
<div class="section" title="Introducing Scala.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Introducing Scala.js</h1></div></div></div><p>Where Java is a compelling <a id="id602" class="indexterm"/>choice to run server-side code due to its robust JVM that can be run anywhere, JavaScript is increasingly becoming the dominant choice on the client side due to its flexibility and light runtime-embedded environment as well as its growing set of tools already available in the browsers. Despite its popularity, JavaScript being a dynamic language does not offer the type of safety that languages such as Java or Scala provide. The experimental but fast-growing Scala.js initiative aims at compiling Scala to JavaScript and in my view offers a really good alternative for those who want to benefit from the power of the Scala type system all the way to the browser.</p><p>Setting up a project demonstrating the usage of Scala.js can be done in a couple of minutes and is explained in the sample "getting started" project available at <a class="ulink" href="https://github.com/sjrd/scala-js-example-app">https://github.com/sjrd/scala-js-example-app</a>.</p><p>The example consists of a small HTML page containing a <code class="literal">playground &lt;div&gt;</code> element as illustrated in the following HTML code:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Example Scala.js application&lt;/title&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;Example Scala.js application - development version&lt;/h1&gt;

&lt;p&gt;After having compiled and packaged properly the code for the application
(using `sbt packageJS`), you should see "It works" here below.
See README.md for detailed explanations.&lt;/p&gt;

&lt;div id="playground"&gt;
&lt;/div&gt;

&lt;script type="text/javascript" src="./target/scala-2.10/example-extdeps.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="./target/scala-2.10/example-intdeps.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="./target/scala-2.10/example.js"&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The <code class="literal">div</code> element will be <a id="id603" class="indexterm"/>dynamically populated as:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;
  &lt;strong&gt;It works!&lt;/strong&gt;
&lt;/p&gt;</pre></div><p>The tiny snippet of code written in Scala and compiled to Javascript to achieve this is given in the following <a id="id604" class="indexterm"/>
<code class="literal">main</code> method:</p><div class="informalexample"><pre class="programlisting">package example

import scala.scalajs.js
import js.Dynamic.{ global =&gt; g }

object ScalaJSExample {
  def main(): Unit = {
    val paragraph = g.document.createElement("p")
    paragraph.innerHTML = "&lt;strong&gt;It works!&lt;/strong&gt;"
    g.document.getElementById("playground").appendChild(paragraph)
  }

  /** Computes the square of an integer.
   *  This demonstrates unit testing.
   */
  def square(x: Int): Int = x*x
}</pre></div><p>Once we have the access to the DOM of the HTML page through the <code class="literal">js.Dynamic.global</code> object, this simple Scala <code class="literal">main</code> method constructs a new paragraph node and adds it to the existing <code class="literal">"playground"</code> node.</p><p>The additional <code class="literal">square</code> <a id="id605" class="indexterm"/>method is used to illustrate a unit test written against the Jasmine JavaScript test framework.</p><p>The execution of the <code class="literal">main</code> method is <a id="id606" class="indexterm"/>triggered by the one line added to the <code class="literal">js/startup.js</code> file:</p><div class="informalexample"><pre class="programlisting">ScalaJS.modules.example_ScalaJSExample().main();</pre></div><p>The generated code produced by default by Scala.js can be quite big because of dependencies to Scala libraries. Scala.js offers an optimization through Google's closure compiler that reduces the size and optimizes the JavaScript code execution when targeted for production environments.</p><p>What is the next step now? Well, we <a id="id607" class="indexterm"/>can refer interested readers to a couple of more projects that we find interesting with regard to this book:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A project called <code class="literal">play-with-scalajs-example</code> and available at <a class="ulink" href="https://github.com/vmunier/play-with-scalajs-example">https://github.com/vmunier/play-with-scalajs-example</a> deals with a simple integration sample of Scala.js and the Play Framework that we have covered in the previous chapters.</li><li class="listitem" style="list-style-type: disc">A very interesting and more advanced usage of Scala.js is <code class="literal">TodoMVC</code> and this is a part of the <code class="literal">workbench-example-app</code> project available at <a class="ulink" href="https://github.com/lihaoyi/workbench-example-app/">https://github.com/lihaoyi/workbench-example-app/</a>. It demonstrates a sample web app for making To Do Lists, a reference app specified to compare different implementations done in various languages, but has the innovative approach of being reactive in addition to being written in Scala compiled to JavaScript. A direct link to the resulting reactive web app is available at <a class="ulink" href="http://lihaoyi.github.io/workbench-example-app/todo.html">http://lihaoyi.github.io/workbench-example-app/todo.html</a> and is rendered in a browser, as shown in the following screenshot:</li></ul></div><div class="mediaobject"><img src="graphics/3637OS_10_05.jpg" alt="Introducing Scala.js"/></div><p>There are already a number of projects around Scala.js listed on its home page at <a class="ulink" href="http://www.scala-js.org/">http://www.scala-js.org/</a>. As <a id="id608" class="indexterm"/>Scala.js is maturing quickly, many more projects should be soon available.</p></div>
<div class="section" title="Final tips"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec58"/>Final tips</h1></div></div></div><p>The following sections enlist a few final tips and tricks that you might find handy while working with the REPL.</p><div class="section" title="Copying and pasting in the REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec71"/>Copying and pasting in the REPL</h2></div></div></div><p>As a reminder, this feature introduced in <a class="link" href="ch08.html" title="Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency">Chapter 8</a>, <span class="emphasis"><em>Essential Properties of Modern Applications – Asynchrony and Concurrency</em></span>, makes it easy to execute a full <a id="id609" class="indexterm"/>code snippet at once in the REPL. For instance, the <a id="id610" class="indexterm"/>following lines of command illustrate how the copy and paste feature in REPL helps the easy execution of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; :paste</strong></span>
<span class="strong"><strong>// Entering paste mode (ctrl-D to finish)</strong></span>

<span class="strong"><strong>[Copy a code block from somewhere with ctrl-C/ctrl-V]</strong></span>

<span class="strong"><strong>  case class Person(name:String)</strong></span>

<span class="strong"><strong>  val me = Person("Thomas")</strong></span>
<span class="strong"><strong>  val you = Person("Current Reader")</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  val we = List(you,me).map(_.name).reduceLeft(_+" &amp; "+_)</strong></span>
<span class="strong"><strong>  val status = s"$we have fun with Scala"</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>[Once you are done with pasting the code block, press ctrl-D]</strong></span>

<span class="strong"><strong>// Exiting paste mode, now interpreting.</strong></span>

<span class="strong"><strong>defined class Person</strong></span>
<span class="strong"><strong>me: Person = Person(Thomas)</strong></span>
<span class="strong"><strong>you: Person = Person(Current Reader)</strong></span>
<span class="strong"><strong>we: String = Current Reader &amp; Thomas</strong></span>
<span class="strong"><strong>status: String = Current Reader &amp; Thomas have fun with Scala</strong></span>
</pre></div></div><div class="section" title="Timing code execution in the REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec72"/>Timing code execution in the REPL</h2></div></div></div><p>The REPL has been a very <a id="id611" class="indexterm"/>helpful tool throughout this book to discover and experiment with the various features of Scala. Together with the Scala worksheets <a id="id612" class="indexterm"/>introduced in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>, they enhance our productivity by providing continuous feedback and make our development, therefore, more agile. Sometimes, it is convenient to measure the time it takes to execute statements or code snippets in the REPL. This is why we have given one way of achieving this.</p><p>First, we define a <code class="literal">help</code> function <a id="id613" class="indexterm"/>called <code class="literal">using</code> that takes two parameters, first a <code class="literal">param</code> argument of the type <code class="literal">A</code> and second, a function argument <code class="literal">f</code> that transforms the type of an argument from <code class="literal">A</code> into <code class="literal">B</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def using[A &lt;: {def close(): Unit},B](param: A)(f: A=&gt;B): B =</strong></span>
<span class="strong"><strong>  try { f(param) } finally { param.close() }</strong></span>
<span class="strong"><strong>using: [A &lt;: AnyRef{def close(): Unit}, B](param: A)(f: A =&gt; B)B</strong></span>
</pre></div><p>What <code class="literal">using</code> does is to invoke the <code class="literal">f(param)</code> <a id="id614" class="indexterm"/>function, wrapping it into a <code class="literal">try {} finally{}</code> block. As the idea behind this function is to apply it on an I/O resource such as <code class="literal">FileWriter</code> or <code class="literal">PrintWriter</code>, we want to guarantee that we can close the resource no matter what. This is why you can see a <code class="literal">param.close</code> call in the <code class="literal">finally</code> block. That means the <a id="id615" class="indexterm"/>
<code class="literal">param</code> argument cannot just be of any type <code class="literal">A</code>; it must <a id="id616" class="indexterm"/>have the additional requirement to have a <code class="literal">close</code> method. This is exactly what is declared at the beginning of the definition of the generic <code class="literal">using</code> <a id="id617" class="indexterm"/>method (that is, <code class="literal">[A &lt;: {def close(): Unit}, B]</code>); the <code class="literal">param</code> argument should be a subtype of <code class="literal">A</code> that contains a method with the given signature.</p><p>In general, dealing with generic types is out of the scope of this book, and you don't need to really understand the previous definition to benefit <a id="id618" class="indexterm"/>from the <code class="literal">using</code> function. The example illustrates, however, how powerful the use of generic types in Scala can be. The type system of Scala is extremely <a id="id619" class="indexterm"/>powerful and the compiler will help you very <a id="id620" class="indexterm"/>much when writing generic code, unlike the use of generics in Java.</p><p>Let's now include the <a id="id621" class="indexterm"/>
<code class="literal">using</code> function <a id="id622" class="indexterm"/>into an <code class="literal">appendToFile</code> function that will be responsible for logging the evaluation of the code we write in the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def appendToFile(fileName:String, textData:String) =</strong></span>
<span class="strong"><strong>  using (new java.io.FileWriter(fileName, true)){</strong></span>
<span class="strong"><strong>    fileWriter =&gt; using (new java.io.PrintWriter(fileWriter)) {</strong></span>
<span class="strong"><strong>      printWriter =&gt; printWriter.println(textData)</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>appendToFile: (fileName: String, textData: String)Unit</strong></span>
</pre></div><p>Finally, the following <code class="literal">timeAndLogged</code> <a id="id623" class="indexterm"/>function is declared to wrap a body snippet entered in the REPL with both the logging and timing functionalities:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def timedAndLogged[T](body: =&gt; T): T = {</strong></span>
<span class="strong"><strong>       val start = System.nanoTime</strong></span>
<span class="strong"><strong>       try {</strong></span>
<span class="strong"><strong>          val result = body</strong></span>
<span class="strong"><strong>          appendToFile("/tmp/repl.log",result.toString)</strong></span>
<span class="strong"><strong>          result</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>       finally println(" "+(System.nanoTime - start) + " nanos elapsed. ")</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>timedAndLogged: [T](body: =&gt; T)T</strong></span>
</pre></div><p>Until Scala 2.10.0, you could use the <code class="literal">:wrap</code> <a id="id624" class="indexterm"/>method of the REPL power mode (accessible from the REPL via the <code class="literal">&gt; :power</code> command) to be able to execute all the console statements <a id="id625" class="indexterm"/>without further involvement of the <code class="literal">timedAndLogged</code> function. The <code class="literal">:wrap</code> feature has recently been removed from the Scala release, so you will have to explicitly wrap the code that you want timing or logging for in the <code class="literal">timedAndLogged</code> <a id="id626" class="indexterm"/>method and therefore, do not need to involve the power mode of the REPL for that.</p><p>For <a id="id627" class="indexterm"/>instance, <a id="id628" class="indexterm"/>you can execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; timedAndLogged{ val input = 2014 ; println(input) ; Thread.sleep(2000) ; input }</strong></span>

<span class="strong"><strong>2014</strong></span>
<span class="strong"><strong> 2004778000 nanos elapsed. </strong></span>
<span class="strong"><strong>res0: Int = 2014</strong></span>
</pre></div><p>The <code class="literal">/tmp/repl.log</code> file we <a id="id629" class="indexterm"/>specified in the <code class="literal">timedAndLogged</code> function should, of course, contain the logged result, that is, <code class="literal">2014</code>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec59"/>Summary</h1></div></div></div><p>As we now reach the end of this book, we would like to emphasize some key aspects on the numerous topics and concepts we have approached during this journey with Scala.</p><p>The concise and expressive syntax of the Scala language should make your code not only more readable but also more maintainable for yourself and other developers. You don't have to give up any of the libraries of the very large and mature Java ecosystem as all the APIs can be reused directly within Scala. Moreover, you benefit from many additional great Scala-specific libraries. Our recommendation is to take a piece of Java code from a domain you understand well, maybe because you wrote it in the first place one or several times before. Then, try to convert it to Scala code and refactor it to get rid of the boilerplate and to make it in a more functional style.</p><p>The Play Framework is not just another web framework; it breaks the conventional approach of long-cycle development following servlet and EJB containers where each redeploy can take a significant time. Moreover, it is built on top of rock solid and scalable technologies such as Akka, which should make you feel confident for future heavy loads and constraining availability requirements. Finally, our personal experience with it has been very enjoyable as the Scala compiler behind it has, most of the time, given very clear feedback on what the problems are when mistakes are made, all the way to the templates and routes specifications. As both Play and Akka are exposing Java APIs as well, they can make your transition easier.</p><p>We believe the future of web development is reactive, dealing with large streams of data, as it is already happening in many areas such as social media sites involving content distribution and real-time financial/analytics services.</p><p>We have only scratched the surface of what is possible to do with Scala. As you go along and dive more deeply into individual technologies, you will discover new features and endless possibilities. Our recommendation is to take one step at a time looking for achievable goals. For instance, first get used to the Scala collections, especially as they can help you to better master Java lambdas and functional programming, then write code with pattern matching, traits, for comprehensions, then move to more advanced topics such as implicits, generics and so on.</p><p>Finally, as inspiration, there is already a tremendous number of open source projects done with Scala, many books on the individual subjects we have covered, many forums contributed by a very active Scala community, as well as several years of extremely useful online videos coming from user groups and <a id="id630" class="indexterm"/>international conferences such as Scaladays (<a class="ulink" href="http://www.scaladays.org">www.scaladays.org</a>), <a id="id631" class="indexterm"/>Scala eXchange (<a class="ulink" href="http://www.skillsmatter.com/conferences/1948-scala-exchange-2014">www.skillsmatter.com/conferences/1948-scala-exchange-2014</a>), <a id="id632" class="indexterm"/>NEScala (<a class="ulink" href="http://www.nescala.org">www.nescala.org</a>), <a id="id633" class="indexterm"/>Jfokus (<a class="ulink" href="http://www.jfokus.se">www.jfokus.se</a>), <a id="id634" class="indexterm"/>Scala.io (<a class="ulink" href="http://www.scala.io">www.scala.io</a>), <a id="id635" class="indexterm"/>flatMap (<a class="ulink" href="http://www.flatmap.no">www.flatmap.no</a>), Ping (<a class="ulink" href="http://www.ping-conf.com">www.ping-conf.com</a>), and Scalapeño (<a class="ulink" href="http://www.scalapeno.underscore.co.il">www.scalapeno.underscore.co.il</a>), to only name a few. A whole calendar site of Scala <a id="id636" class="indexterm"/>events is available at <a class="ulink" href="http://www.scala2014.org">http://www.scala2014.org</a>.</p><p>With that in mind, I hope you enjoyed the book enough to continue exploring Scala, writing awesome code, and having fun as much as we did!</p></div></body></html>