<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Gamepads in Greenfoot"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Gamepads in Greenfoot</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Only you can control your future."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Dr. Seuss</em></span></span></td></tr></table></div><p>In this chapter, we will cover how to connect and use gamepad controllers in your Greenfoot scenarios. The set of controls you provide to your user really has an impact on their experience. Imagine playing our version of Avoider Game, which we created in the first two chapters of this book, if you had to hit <span class="emphasis"><em>U</em></span> to move up, <span class="emphasis"><em>D</em></span> to move down, <span class="emphasis"><em>L</em></span> to move left, and <span class="emphasis"><em>R</em></span> to move right. In the same way that a bad layout can frustrate a user, a good layout can feel very natural.</p><p>Gamepads<a id="id575" class="indexterm"/> are designed to heighten the experience of playing games. They provide a natural and expedient way for players to express their decisions to the game without detracting from game play. Early in gaming history, gamepads took the form of simple joysticks with a single button to fire with. Today, typical controllers have over 10 buttons, analog sticks, analog triggers, and a digital D-pad. Many controllers often allow the user to build custom macros as well.</p><p>In this chapter, you will learn how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Connect a gamepad to your Greenfoot scenario</li><li class="listitem">Listen and respond to various gamepad events using the Greenfoot GamePad API</li><li class="listitem">Connect unsupported gamepads to OS X using controller-mapping software</li></ul></div><p>Adding gamepad support to your scenarios is a great way to add to the playability of the games you create. It also adds a feel of professionalism to your work. After learning about connecting gamepads, we will augment Avoider Game, which we created in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>, and <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>, to allow the user to choose between controlling the game with a mouse or a gamepad.</p><div class="section" title="Gamepad overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Gamepad overview</h1></div></div></div><p>There<a id="id576" class="indexterm"/> are many types of gamepads currently on the market for both PCs and Macs. Some resemble game controllers made for popular console gaming systems, such as Xbox, PlayStation, and Nintendo, while others have their own unique design and capabilities. <span class="emphasis"><em>Figure 1</em></span> shows a typical gamepad. These gamepads are designed to put a lot of control options within easy reach.</p><p><span class="emphasis"><em>Figure 1</em></span> identifies several common groupings of gamepad controls. A D-pad<a id="id577" class="indexterm"/> is a control often used to allow players to indicate direction (hence, the <span class="strong"><strong>D</strong></span> in the name). It is fairly flat and designed for thumb use. The analog sticks serve as mini joysticks on the controller and allow fast and accurate positional control. For example, some games may use them to allow the player to look around a 3D world or aim a weapon. In a controller designed for an Xbox (and other popular consoles), the analog sticks can also be pushed down, providing two additional action buttons. The action buttons provide the user a way to specify an action in a game (see <span class="emphasis"><em>Figure 1</em></span>). These buttons often control things such as jumping, shooting, ducking, and blocking. Last, we have auxiliary buttons that may be used to do things such as start a game, pause a game, reset a game, or simply provide more action buttons.</p><div class="mediaobject"><img src="../Images/image00330.jpeg" alt="Gamepad overview"/><div class="caption"><p>Figure 1: This is a typical layout for a gamepad controller</p></div></div><p style="clear:both; height: 1em;"> </p><p>For many games, a gamepad will provide the best interface (and user experience) for players. In this chapter, we will discuss connecting a controller like the one shown in <span class="emphasis"><em>Figure 1</em></span> to your Greenfoot scenario. You will be able to assign the D-Pad, analog sticks, and action buttons to user-allowed abilities of your choosing.</p></div></div>
<div class="section" title="Windows setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Windows setup</h1></div></div></div><p>There<a id="id578" class="indexterm"/> are hundreds of gamepads you can choose from, to purchase for your PC or Mac. In this section, we will cover setting up an <span class="emphasis"><em>Xbox 360 controller for Windows</em></span>. If you <a id="id579" class="indexterm"/>have purchased a different controller, make sure to install the associated drivers according to the instructions provided with your gamepad. If you have a Mac and a gamepad officially supported by OS X, then the instructions here should work for you as well. At the end of this chapter, we will look at ways you can still use poorly supported gamepads on your Mac.</p><div class="section" title="Connecting your controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec77"/>Connecting your controller</h2></div></div></div><p>Before starting<a id="id580" class="indexterm"/> Greenfoot, plug your Xbox 360 controller for Windows into your PC and allow Microsoft Update time to search for, download, and install the required drivers for the gamepad. This should take 5–15 minutes depending on your network connectivity. If you have any problems, try following the instructions <a id="id581" class="indexterm"/>given at <a class="ulink" href="http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup">http://support.xbox.com/en-US/xbox-on-other-devices/windows/xbox-controller-for-windows-setup</a>.</p></div><div class="section" title="Greenfoot gamepad software"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec78"/>Greenfoot gamepad software</h2></div></div></div><p>From <a id="id582" class="indexterm"/>the Greenfoot website, you can download a template to build Greenfoot scenarios with gamepad support. The template is basically a blank Greenfoot scenario that contains added libraries you can use to access and control gamepads. You can download the gamepad project<a id="id583" class="indexterm"/> template at <a class="ulink" href="http://www.greenfoot.org/doc/gamepad">http://www.greenfoot.org/doc/gamepad</a>.</p><p>When you wish to create a scenario with gamepad support, you need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Move the <code class="literal">GamePadTemplate.zip</code> file downloaded from the previous URL, to a directory of your choice.</li><li class="listitem">Unzip <code class="literal">GamePadTemplate.zip</code>.</li><li class="listitem">Rename the <code class="literal">GamePadTemplate</code> folder created in the previous step, to a name you want your new scenario to have.</li><li class="listitem">Open the scenario and add your changes.</li></ol><div style="height:10px; width: 1px"/></div><p><span class="emphasis"><em>Figure 2</em></span> shows what your new Greenfoot scenario will look like after completing the preceding steps. As you can see, you will subclass the <code class="literal">World</code> and <code class="literal">Actor</code> classes as you normally would to add content to your scenario. You are also provided with two additional classes, seen<a id="id584" class="indexterm"/> in the <span class="strong"><strong>Other classes</strong></span> section, that you will use to connect to and manage gamepads.</p><div class="mediaobject"><img src="../Images/image00331.jpeg" alt="Greenfoot gamepad software"/><div class="caption"><p>Figure 2: This is a new Greenfoot scenario built from the gamepad template. The scenario pictured was renamed to "Fun"</p></div></div><p style="clear:both; height: 1em;"> </p><p>We will discuss the <code class="literal">GamePad</code> and <code class="literal">Direction</code> classes in the next section.</p></div></div>
<div class="section" title="The Greenfoot Gamepad API"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>The Greenfoot Gamepad API</h1></div></div></div><p>The<a id="id585" class="indexterm"/> Greenfoot Gamepad API supports all of the controls shown in <span class="emphasis"><em>Figure 1</em></span> except that there are only two auxiliary buttons at the top (colored orange). First, we will discuss the API at a conceptual level and then look at the specific classes that<a id="id586" class="indexterm"/> implement the API.</p><div class="section" title="Overview"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec79"/>Overview</h2></div></div></div><p>In theory, receiving<a id="id587" class="indexterm"/> user input from a gamepad is a lot like receiving input from the keyboard. We are going to poll the buttons and analog sticks on the gamepad to see whether they are presently being pressed. The analog sticks are a bit more complicated as they have more states than being pressed or not. For them, you need to know both the direction they are being pushed in and the strength of the push.</p><p>With gamepads, you might have multiple gamepads connected to your computer, so the API also provides methods to access all of the gamepads and connect to only the ones you specify.</p><p>As we saw in the gamepad template scenario, the Gamepad API is implemented in two classes. The first is the <code class="literal">GamePad</code> class and the second is the <code class="literal">Direction</code> class.</p><div class="note" title="Note"><h3 class="title"><a id="note25"/>Note</h3><p><span class="strong"><strong>The static keyword</strong></span></p><p>In Java, you have a<a id="id588" class="indexterm"/> keyword that you can use to change how variables and methods are accessed and how memory is managed for them. This keyword is known as <code class="literal">static</code>. Adding this keyword to the declaration of a class variable or method ensures that this variable or method is stored only once regardless of the number of objects of the class created. So, for example, if you declared a variable named <code class="literal">counter</code> and assigned it an initial value of <code class="literal">1</code>, then all objects of the class would see the value of that variable as <code class="literal">1</code>. If one of the objects increments <code class="literal">counter</code>, then all objects created would now see the value of this variable as <code class="literal">2</code>.</p><p>When used on methods, the methods can be invoked without needing an instance of that class created. For example, many methods contained in the Greenfoot class are <code class="literal">static</code>, such as <code class="literal">getRandomNumber()</code> and <code class="literal">setWorld()</code>. Note that when we call these methods, we do not create an instance of the class. We just add the following code:</p><div class="informalexample"><pre class="programlisting">int randomNumber = Greenfoot.getRandomNumber(10);</pre></div></div></div><div class="section" title="The GamePad and Direction classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec80"/>The GamePad and Direction classes</h2></div></div></div><p>The <code class="literal">GamePad</code> class<a id="id589" class="indexterm"/> is a special type of class known as <span class="emphasis"><em>singleton</em></span>. For a singleton class, the constructor is declared as <code class="literal">private</code>; therefore, no code external to the class can create a new instance of the class. All other attempts to create a new object will fail with an error stating that the constructor has private access. It is a singleton class because you want to ensure that only one object represents a gamepad controller.</p><p>The methods you will commonly use from this class are <code class="literal">getGamePad()</code>, <code class="literal">isDown()</code>, <code class="literal">getAxis()</code>, and <code class="literal">runConfigurePad()</code>. The first thing you need to do to use a gamepad in your scenario is call <code class="literal">getGamePad()</code>. This method will return a <code class="literal">GamePad</code> object that represents the gamepad controller connected to your computer. Here is an example of its use:</p><div class="informalexample"><pre class="programlisting">GamePad pad = GamePad.getGamePad();</pre></div><p>Once you have the <code class="literal">GamePad</code> object for your controller, you can check whether the user is pressing an action button (shown in <span class="emphasis"><em>Figure 1</em></span>) by calling <code class="literal">isDown()</code>. The <code class="literal">isDown()</code>method is used exactly like the <code class="literal">isKeyDown()</code> Greenfoot method we used to detect keyboard input. To detect keyboard input, we supply the name of the key we are interested in. For gamepads, you specify which button you are interested in using the <code class="literal">GamePad.Button</code> enumeration, which provides the following labels that correspond to gamepad buttons: <code class="literal">ACTION_DOWN</code>, <code class="literal">ACTION_LEFT</code>, <code class="literal">ACTION_RIGHT</code>, <code class="literal">ACTION_UP</code>, <code class="literal">L1</code>, <code class="literal">L2</code>, <code class="literal">L3</code>, <code class="literal">R1</code>, <code class="literal">R2</code>, <code class="literal">R3</code>, <code class="literal">SELECT</code>, and <code class="literal">START</code>. So, to determine whether the user was pressing the blue action button shown in <span class="emphasis"><em>Figure 1</em></span>, you would use the following lines of code:</p><div class="informalexample"><pre class="programlisting">if( pad.isDown(GamePad.Button.ACTION_UP) ) {
  System.out.println("The ACTION_UP key is being pressed.");
}</pre></div><p>Getting user input from the analog sticks is a two-step process. First, you get the direction information from the analog stick in the following way:</p><div class="informalexample"><pre class="programlisting">Direction direction = getGamePad().getAxis(GamePad.Axis.LEFT );</pre></div><p>The <code class="literal">Axis</code> enumeration provides labels you can use to specify the D-pad, the left analog stick, or the right analog stick. The labels are <code class="literal">DPAD</code>, <code class="literal">LEFT</code>, and <code class="literal">RIGHT</code>, respectively. Secondly, once you <a id="id590" class="indexterm"/>have a <code class="literal">Direction</code> object, you can determine the angle at which the analog stick is being pushed and how far it is being pushed. Here are two lines of code that demonstrate how to extract this information:</p><div class="informalexample"><pre class="programlisting">int angle = direction.getAngle();
float strength = direction.getStrength();</pre></div><p>The last method you will often use is the <code class="literal">runConfigurePad()</code> method. This method will present a GUI<a id="id591" class="indexterm"/> interface the user can use to specify how the controls on their gamepad should map to the labels provided in<a id="id592" class="indexterm"/> the <code class="literal">GamePad.Button</code> enumeration and the <code class="literal">GamePad.Axis</code> enumeration. This is needed because not all gamepads have the same layout.</p><p>For more information, refer <a id="id593" class="indexterm"/>to the official documentation of this class at <a class="ulink" href="http://www.greenfoot.org/files/gamepad/GamePad.html">http://www.greenfoot.org/files/gamepad/GamePad.html</a>.</p><div class="note" title="Note"><h3 class="title"><a id="note26"/>Note</h3><p><span class="strong"><strong>Singleton classes</strong></span></p><p>Design patterns are solutions to well-known or common problems. They provide a blueprint that programmers can easily follow. One of the most used design patterns in Java is the singleton pattern. You use this design pattern when you want to ensure that one and only one object of a class is instantiated. Why would this be useful? Well, imagine you wanted to manage and share a resource such as a printer or network connection within your application. It is much simpler and more efficient to only allow the creation of one object that represents that single resource. A class that follows the singleton design pattern enforces this behavior.</p></div></div></div>
<div class="section" title="Avoider Game with Gamepad"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Avoider Game with Gamepad</h1></div></div></div><p>We went over how to connect a gamepad to your Greenfoot scenario and how to use the Gamepad API. Now, it is time to code. We are going to add gamepad support to our version of <a id="id594" class="indexterm"/>Avoider Game, which we finished creating in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>. You can access a copy of that scenario at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p><p>We have two main changes to make to Avoider Game. First, we need to add a reference to a <code class="literal">GamePad</code> object associated with our controller and pass that reference between all three worlds in that scenario: <code class="literal">AvoiderGameIntroScreen</code>, <code class="literal">AvoiderWorld</code>, and <code class="literal">AvoiderGameOverWorld</code>. Second, we need to change the <code class="literal">Avatar</code> class to be controlled by a gamepad, if present. Otherwise, we default to mouse control.</p><p>The entire <code class="literal">AvoiderWorld</code> class is not shown in the following code; only the methods that need changing are shown. Here are the changes for <code class="literal">AvoiderWorld</code>:</p><div class="informalexample"><pre class="programlisting">private GamePad pad;

<span class="strong"><strong>public AvoiderWorld(GamePad p) {</strong></span>
  super(600, 400, 1, false);
  
  bkgMusic = new GreenfootSound("sounds/UFO_T-Balt.mp3");
  // Music Credit: T-Balt at
  // http://www.newgrounds.com/audio/listen/504436
  bkgMusic.playLoop();
  
  <span class="strong"><strong>// set gamepad</strong></span>
<span class="strong"><strong>  pad = p;</strong></span>
  
  setPaintOrder(Eye.class, Avatar.class,
  Enemy.class, PowerItems.class,
  Counter.class);
  prepare();
  generateInitialStarField();
}</pre></div><p>First, we<a id="id595" class="indexterm"/> need an instance variable named <code class="literal">pad</code> to hold a reference to our gamepad. Change the constructor function to accept a reference to a <code class="literal">GamePad</code> object and then use that value to initialize our <code class="literal">pad</code> variable. This value will be passed to us from <code class="literal">AvoiderGameIntroScreen</code>. We will also need to pass the value of <code class="literal">pad</code> to <code class="literal">AvoiderGameOverWorld</code>, so we need to modify the <code class="literal">endgame()</code> method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void endGame() {
  bkgMusic.stop();
<span class="strong"><strong>  AvoiderGameOverWorld go = new AvoiderGameOverWorld(pad);</strong></span>
  Greenfoot.setWorld(go);
}</pre></div><p>The last thing we need to change in <code class="literal">AvoiderWorld</code> is pass the <code class="literal">pad</code> instance variable to the single <code class="literal">Avatar</code> object we create in this game. Thus, we need to change one line of code in the <code class="literal">prepare()</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">private void prepare()
{
<span class="strong"><strong>  Avatar avatar = new Avatar(pad);</strong></span>
  addObject(avatar, 287, 232);
  scoreBoard = new Counter("Score: ");
  addObject(scoreBoard, 70, 20);
}</pre></div><p><code class="literal">AvoiderGameIntroScreen</code> has the responsibility of detecting and configuring the gamepad. Here are the changes to make that happen:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 
<span class="strong"><strong>import java.lang.IllegalArgumentException;</strong></span>

public class AvoiderGameIntroScreen extends World
{
<span class="strong"><strong>  private GamePad pad;</strong></span>

  public AvoiderGameIntroScreen() {
    super(600, 400, 1); 

<span class="strong"><strong>    try {</strong></span>
<span class="strong"><strong>      pad = GamePad.getGamePad();</strong></span>
<span class="strong"><strong>      pad.runConfigurePad();</strong></span>
<span class="strong"><strong>    } catch(IllegalArgumentException e) {</strong></span>
<span class="strong"><strong>      System.out.println( "Exception caught: " + e.getMessage() );</strong></span>
<span class="strong"><strong>      pad = null;</strong></span>
<span class="strong"><strong>    }</strong></span>
  }

  public void act() {
    if( Greenfoot.mouseClicked(this) ) {
<span class="strong"><strong>      AvoiderWorld world = new AvoiderWorld(pad);</strong></span>
      Greenfoot.setWorld(world);
    }
  }
}</pre></div><p>First, we <a id="id596" class="indexterm"/>add an instance variable, <code class="literal">pad</code>, to the class and then initialize that variable using the <code class="literal">GamePad.getGamePad()</code> method of the Gamepad API. We have to surround the call to <code class="literal">GamePad.getGamePad()</code> in a try-catch block because the <code class="literal">getGamePad()</code> method will throw an exception if there is no gamepad plugged into the computer. The type of exception thrown is <code class="literal">IllegalArgumentException</code>, so that is what we have to catch. You will notice that we added another import statement at the top to define the <code class="literal">IllegalArgumentException</code> class. If we do not have a gamepad, then we set <code class="literal">pad</code> to <code class="literal">null</code>. We also call the <code class="literal">runConfigurePad()</code>method in the try block. This will bring up a dialogue box that will prompt the user as to whether they want to redefine the buttons for their controller. Last, we pass <code class="literal">pad</code> to <code class="literal">AvoiderWorld</code> in the <code class="literal">act()</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="note27"/>Note</h3><p><span class="strong"><strong>Exceptions</strong></span></p><p>Java exceptions<a id="id597" class="indexterm"/> provide an organized and flexible way to handle runtime errors. They allow you to detangle your code from error detection code, making your code more readable and maintainable. The main keywords associated with exception handling in Java are <code class="literal">throw</code>, <code class="literal">try</code>, and <code class="literal">catch</code>. To learn <a id="id598" class="indexterm"/>more about Java exceptions, refer to <a class="ulink" href="http://docs.oracle.com/javase/tutorial/essential/exceptions/">http://docs.oracle.com/javase/tutorial/essential/exceptions/</a>.</p></div><p>The changes<a id="id599" class="indexterm"/> needed to the <code class="literal">AvoiderGameOverScreen</code> class are simple. It only needs to pass the reference to the gamepad it got from the prior instance of <code class="literal">AvoiderWorld</code> and pass it back to a new instance of <code class="literal">AvoiderWorld</code> if the player clicks on the screen to play again. Here are the changes:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 

public class AvoiderGameOverWorld extends World
{
  <span class="strong"><strong>private GamePad pad;</strong></span>

  <span class="strong"><strong>public AvoiderGameOverWorld(GamePad p)</strong></span> {  
    super(600, 400, 1); 
    <span class="strong"><strong>pad = p;</strong></span>
  }

  public void act() {
    if( Greenfoot.mouseClicked(this) ) {
      <span class="strong"><strong>AvoiderWorld world = new AvoiderWorld(pad);</strong></span>
      Greenfoot.setWorld(world);
    }
  }
}</pre></div><p>The class that deals directly with receiving events from the gamepad is the <code class="literal">Avatar</code> class. We need to modify this class to use the gamepad to accept user input or default to the mouse if no gamepad is present.</p><p>Here are the changes to the <code class="literal">Avatar</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Avatar extends Actor {
  private static final float MIN_STRENGTH = 0.5F;
  private int health = 3;
  private int hitDelay = 0;
  private int stunDelay = -1;
  private int lagDelay = -1;
  private int nextImage = 0;
  private Eye leftEye;
  private Eye rightEye;
<span class="strong"><strong>  private GamePad pad;</strong></span>
<span class="strong"><strong>  private boolean useGamepad = true;</strong></span>
<span class="strong"><strong>  private int gpStepX = 3;</strong></span>
<span class="strong"><strong>  private int gpStepY = 3;</strong></span>
<span class="strong"><strong>  private int gpLagStepX = 1;</strong></span>
<span class="strong"><strong>  private int gpLagStepY = 1;</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  public Avatar( GamePad p ) {</strong></span>
<span class="strong"><strong>    pad = p;</strong></span>
<span class="strong"><strong>    if( pad == null ) {</strong></span>
<span class="strong"><strong>      useGamepad = false;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
  protected void addedToWorld(World w) {
    leftEye = new Eye();
    rightEye = new Eye();
    w.addObject(leftEye, getX()-10, getY()-8);
    w.addObject(rightEye, getX()+10, getY()-8);
  }
  
  public void act() {
    userControls();
    checkForCollisions();
  }
  
  public void addHealth() {
    if( health &lt; 3 ) {
      health++;
      if( --nextImage == 0 ) {
        setImage("skull.png");
      } else {
        setImage("skull" + nextImage + ".png");
      }
    }
  }
  
  public void lagControls() {
    lagDelay = 150;
  }
  
  public void stun() {
    stunDelay = 50;
  }
  
  private void checkForCollisions() {
    Actor enemy = getOneIntersectingObject(Enemy.class);
    if( hitDelay == 0 &amp;&amp; enemy != null ) {
      if( health == 0 ) {
        AvoiderWorld world = (AvoiderWorld) getWorld();
        world.endGame();
      }
      else {
        health--;
        setImage("skull" + ++nextImage + ".png");
        hitDelay = 50;
      }
    }
    if( hitDelay &gt; 0 ) hitDelay--;
  }
  
  private void userControls() {
    if( stunDelay &lt; 0 ) {
      if( lagDelay &gt; 0 ) {
        if( useGamepad ) {
          moveViaGamepad(true);
        } else {
          moveViaMouse(true);
        }
        --lagDelay;
      } else {
        if( useGamepad ) {
          moveViaGamepad(false);
        } else {
          moveViaMouse(false);
        }
      }
      
      leftEye.setLocation(getX()-10, getY()-8);
      rightEye.setLocation(getX()+10, getY()-8);
    } else {
      stunDelay--;
    }
  }
  
  private void moveViaGamepad(boolean lag) {
    int stepX = lag ? gpLagStepX : gpStepX;
    int stepY = lag ? gpLagStepY : gpStepY;
    
    Direction dir = pad.getAxis( GamePad.Axis.DPAD );
    if ( dir.getStrength() == 0 ) {
      dir = pad.getAxis( GamePad.Axis.LEFT );
    }
    
    if ( dir.getStrength() &gt; MIN_STRENGTH ) {
      final int angle = dir.getAngle();
      
      if ( angle &gt; 315 || angle &lt;= 45 ) {
        setLocation(getX()+stepX, getY());
      } else if ( angle &gt; 45 &amp;&amp; angle &lt;= 135 ) {
        setLocation(getX(), getY()+stepY);
      } else if ( angle &gt; 135 &amp;&amp; angle &lt;= 225 ) {
        setLocation(getX()-stepX, getY());
      } else {
        setLocation(getX(), getY()-stepY);
      }
    }
  }
  
  private void moveViaMouse(boolean lag) {
    MouseInfo mi = Greenfoot.getMouseInfo();
    
    if( mi != null ) {
      if( lag ) {
        int stepX = (mi.getX() - getX())/40;
        int stepY = (mi.getY() - getY())/40;
        setLocation(stepX + getX(), stepY + getY());
      } else {
        setLocation(mi.getX(), mi.getY());
      }
    }
  }
}</pre></div><p>At the <a id="id600" class="indexterm"/>beginning of the <code class="literal">Avatar</code> class, we define a few additional variables that we will need to allow instances of the class to be controlled by a gamepad. We declare <code class="literal">pad</code> to hold a reference to the gamepad and some integers to specify how fast to move the <code class="literal">Avatar</code> object. We also declare the Boolean <code class="literal">useGamePad</code> variable that we will check later in class methods.</p><p>In the constructor, we initialize <code class="literal">pad</code> and set <code class="literal">useGamePad</code>. You will remember that we set <code class="literal">pad</code> to <code class="literal">null</code> in <code class="literal">AvoiderGameIntroScreen</code> if no gamepad was detected.</p><p>We have refactored the <code class="literal">userControls()</code> method. Both lag and stun delays work the same, but now we call a method to actually move the object. If <code class="literal">useGamePad</code> is <code class="literal">true</code> then we call <code class="literal">moveViaGamepad()</code>; otherwise, we call <code class="literal">moveViaMouse()</code>. The <code class="literal">moveViaMouse()</code>method contains the same logic we had previously to move the object. The <code class="literal">moveViaGamepad()</code>method is completely new and contains the logic to move the <code class="literal">Avatar</code> object by detecting input from the user's gamepad.</p><p>In <code class="literal">moveViaGamepad()</code>, we first set the speed to move. If we are lagging, we will go slower. The implementation of lagging for the gamepad is a little different than the implementation of lagging using the mouse. However, the effect in either case is to slow the user movement. Next, we check to see whether the user is presently pressing the D-pad by checking the strength of the push. If it equals 0, then we assume the user is using the left analog stick. We then detect the angle at which the user is pushing the D-pad (or analog stick) and translate that angle to the direction—up, down, left, or right.</p><div class="section" title="Try it out"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec81"/>Try it out</h2></div></div></div><p>We have added all the code we need to use a gamepad controller with our version of Avoider Game. Compile all the changes you typed in previously, fix any errors you have, and play the game. I really feel that playing the game with a gamepad is more natural and satisfying.</p><p>You will notice that we still have a lot of unused buttons on the gamepad. What could you add to the game to take advantage of those?</p></div></div>
<div class="section" title="OS X setup/workarounds"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>OS X setup/workarounds</h1></div></div></div><p>OS X does not directly <a id="id601" class="indexterm"/>support many gamepads. If you have a gamepad that is not directly supported, you can still use that gamepad to control your Greenfoot games.</p><div class="section" title="Gamepad mapper software"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec82"/>Gamepad mapper software</h2></div></div></div><p>There are <a id="id602" class="indexterm"/>several OS X applications available that will map a gamepad controller to keyboard keys and mouse actions. For example, you could map the D-Pad up, down, left, and right actions to the <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>S</em></span>, <span class="emphasis"><em>A</em></span>, and <span class="emphasis"><em>D</em></span> keys. Typically, these applications have better gamepad support than <code class="literal">JInput</code>, which is at the heart of gamepad support in Greenfoot and, therefore, will permit a wider variety of controllers to connect to your game. Another advantage is that you can program your scenarios without any thought to gamepad support. You assume standard keyboard and mouse controls, and<a id="id603" class="indexterm"/> the gamepad mapping software handles the rest. Here are some popular programs that do this mapping:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Joystick<a id="id604" class="indexterm"/> Mapper: <a class="ulink" href="http://joystickmapper.com">http://joystickmapper.com</a></li><li class="listitem">Enjoy: <a class="ulink" href="https://yukkurigames.com/enjoyable/">https://yukkurigames.com/enjoyable/</a></li><li class="listitem">ControllerMate <a id="id605" class="indexterm"/>for Mac: <a class="ulink" href="http://www.macupdate.com/app/mac/17779/controllermate">http://www.macupdate.com/app/mac/17779/controllermate</a></li></ul></div></div></div>
<div class="section" title="Exporting games with gamepads"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Exporting games with gamepads</h1></div></div></div><p>There is<a id="id606" class="indexterm"/> one thing you need to keep in mind when you add gamepad support to your Greenfoot scenarios. If you have it, then your game will not be able to be played on the Greenfoot site. This is due to the fact that there is no Java support to connect to a gamepad via a web application. However, you will still be able to export your scenario as a desktop application if you follow the simple steps at <a class="ulink" href="http://www.greenfoot.org/doc/gamepad_export">http://www.greenfoot.org/doc/gamepad_export</a>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Summary</h1></div></div></div><p>The Greenfoot Gamepad API is simple to set up and use and allows you to provide a well-designed control interface to your users. By giving your users the option to use mouse, keyboard, or gamepad controls, you allow them to interact with your Greenfoot creations in a way that is natural and comfortable to them. In previous chapters, you learned how to work with both the keyboard and mouse and, in this chapter, you learned how to use gamepads.</p></div></body></html>