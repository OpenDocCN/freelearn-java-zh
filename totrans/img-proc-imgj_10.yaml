- en: Chapter 10. Where to Go from Here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will sum up the topics that were discussed and provide
    further resources that are available to continue developing your own plugins.
    The chapter will also look at some of the more advanced techniques that are available
    for developers. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project management and feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have looked at many different ways of performing image processing
    and analysis. Automation using macros and plugins were introduced, allowing for
    infinite possibilities in processing and analysis. The topics in this book have
    been written for users who would like to start developing their own plugins and
    macros. Naturally, this book can only provide so much information within its pages,
    so this section is meant to provide some handles on how to proceed further along
    this path.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, creating macros and plugins gets easier with repeated practice
    and learning from previous code (or other people's code). When creating macros,
    it is a good practice to make small macros that perform only a single step in
    processing. Then, by combining multiple macros, you can create a very versatile
    toolbox. Many useful tools in ImageJ, such as the ActionBar plugin, allow you
    to create a fast way to launch many different macros in succession. When developing
    in this fashion, make sure that you create macros that can be daisy-chained. The
    output of one macro can be used as input to the next macro and so on. This method
    will save you a lot of time, and it allows for almost any combination you wish
    to create.
  prefs: []
  type: TYPE_NORMAL
- en: For plugins, a similar advice holds. When you use a specific function many times
    over, it may be worth it to create a standalone class with helpful tools that
    you use often. By instantiating the class to gain access to its methods, you can
    reuse your code in many different projects. Some of the larger ImageJ projects
    use a specific tool class or classes. For instance, MtrackJ and NeuronJ both use
    a library of methods called `imagescience.jar`. When making plugins with an interface,
    it is also a good idea to build your actual processing or analysis routines in
    separate classes, which can easily be swapped when you develop new or better techniques.
  prefs: []
  type: TYPE_NORMAL
- en: There are many good resources available online to develop macros used in image
    processing and analysis. The most basic one is the repository on the ImageJ website,
    which contains many excellent macros that perform basic and more advanced tasks
    and can be found at [http://imagej.nih.gov/ij/macros/](http://imagej.nih.gov/ij/macros/).
    Another good resource is the Fiji website, which contains a lot of information
    about image processing and analysis described in a cookbook ([http://imagej.net/Cookbook](http://imagej.net/Cookbook)).
    This cookbook is based on the defunct MBF microscopy resources and explains how
    to process and analyze specific images using the tools supplied with Fiji.
  prefs: []
  type: TYPE_NORMAL
- en: Some very good resources have been published as well. *Digital Image Processing*
    by *Burger and Burge* is a comprehensive textbook that focuses on the algorithms
    used by ImageJ functions. This provides a mathematical background to some of the
    processing functions in ImageJ as well as image transformations and interpolations.
    Examples in their work are based on or extracted from ImageJ source code. Another
    good resource is Gonzalez and Woods' *Digital Image Processing*, which uses MATLAB
    for image-processing examples. It, however, also provides a mathematical background
    as well as techniques such as fuzzy logic in image processing. Many of the examples
    used can be translated to ImageJ as an exercise. A good source for algorithms
    is the *Numerical recipes* book series, which was written in the C/C++ language.
    Many of the algorithms can be translated into Java without too much hassle. Another
    resource that can help in understanding the physics of image formation, as well
    as the basics of signal processing, is *The Scientist and Engineer's Guide to
    Digital Signal Processing* by Steven Smith (available on [http://www.dspguide.com/](http://www.dspguide.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you wish to develop plugins that utilize a user interface, it is
    a good idea to look at many different plugins with interfaces. In [Chapter 8](ch08.html
    "Chapter 8. Anatomy of ImageJ Plugins"), *Anatomy of ImageJ Plugins* we looked
    at different examples of plugins with a basic and advanced interface. Some of
    these examples have a very clear and intuitive interface that can be used with
    minimal documentation. There are many good publications on good designs of interfaces
    as well as online resources that can show you examples of good and bad designs.
    Examples of published books include *Universal Principles of Design*, which examines
    common concepts in design based on experience and psychological knowledge. Another
    good resource is the book *Don't make me think, revisited*, which is written with
    web design in mind. However, the core principles are the same for desktop applications
    and ImageJ plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Another good online resource is the blog of Joel Spolsky, a developer involved
    with Microsoft Excel, at [http://www.joelonsoftware.com/uibook/chapters/fog0000000057.html](http://www.joelonsoftware.com/uibook/chapters/fog0000000057.html).
    Although the examples mentioned are slightly historic, the general truth behind
    the observations still holds true. It also has a lot of useful insights into designing
    and running projects.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about plugin development in the new ImageJ2 framework, there is
    good documentation and background available on the Fiji website on the framework
    ([http://fiji.sc/ImageJ2](http://fiji.sc/ImageJ2)) and some of the library functions
    such as ImgLib2 ([http://fiji.sc/ImgLib2](http://fiji.sc/ImgLib2)). There is also
    a good collection of example projects available to test and discover how to use
    these concepts, for instance, how to work with images using ImgLib2 ([http://fiji.sc/ImgLib2_Examples](http://fiji.sc/ImgLib2_Examples)).
    A set of ImageJ tutorials is available on GitHub as well. They can be cloned using
    your favorite Git implementation from [https://GitHub.com/imagej/imagej-tutorials/](https://GitHub.com/imagej/imagej-tutorials/).
    As ImageJ2 is still under active development and currently is at release candidate
    status, many changes will still be implemented before it is released as a final
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the examples described in this book can be designed and built using
    the built-in editors of ImageJ and Fiji, but if you want to develop more advanced
    plugins, setting up an IDE would make you work faster. As a learning tool, an
    IDE might not be the best option. The learning curve of the IDE itself can be
    steep, and also, it can make you lazy. IDEs can be quite clever and analyze your
    code to provide automatic importing of classes, implementing the required methods,
    and variable checking and casting. These tools are handy, but it is important
    to understand what is happening when the IDE suggests these options. Of course,
    the spellchecking and completion of variable names makes sure that you will make
    fewer typos, but you should never blindly rely on it. The analysis of code can
    be quite sophisticated, but it cannot predict what the developer has in mind.
    This can sometimes result in very odd behavior or errors that may be hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: To work with an IDE such as NetBeans, as described in the previous chapters,
    many resources are available from the developers of the software. Tutorials for
    NetBeans can be found at [https://netbeans.org/kb/index.html](https://netbeans.org/kb/index.html),
    which contains tutorials, examples, and videos to use the IDE to develop projects.
    Packt Publishing also has books about NetBeans IDE usage, specifically *NetBeans
    IDE 8 cookbook* and *Mastering NetBeans*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides investing time in an IDE, it is also helpful to invest time in understanding
    and learning how to use a revision system, such as Git. The workflow when using
    a revision system is a little different than when just developing code directly.
    A revision system would only work if you commit your changes on a regular basis
    and provide useful commit messages. If you are the only developer on a project,
    you would not run into many problems such as difficult code mergers and conflicts,
    so the process becomes relatively straightforward. With the help of a graphical
    frontend for Git, the whole process becomes manageable and accessible, even for
    beginners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are comfortable with using Git before you start a multideveloper
    project. Conflicts and mergers can get complicated and resolving them may become
    hard if binary files are involved. Many IDEs have a revision system built in (many
    times, it''s under the **Team** menu, that is, in Eclipse and NetBeans). Whether
    you use the built-in system or a standalone interface, there are a few good resources
    to look at before using them. They will help in understanding what the system
    is capable of (and what not). A very good resource is the *Git Book*, which can
    be downloaded from [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2),
    while printed copies are also available. [Chapter 2](ch02.html "Chapter 2. Basic
    Image Processing with ImageJ"), *Basic Image Processing with ImageJ* and [Chapter
    3](ch03.html "Chapter 3. Advanced Image Processing with ImageJ"), *Advanced Image
    Processing with ImageJ* give a clear overview of how to use Git in daily life.
    It mostly uses the command-line interface for the examples. However, the graphical
    frontends that are available use the same terminology. Packt Publishing has practical
    books for working with Git as well, including *Git Version Control cookbook* and
    *Git: Version Control for Everyone*, which contain practical examples and use
    cases for development.'
  prefs: []
  type: TYPE_NORMAL
- en: For Subversion, another revision software package, a similar online resource
    is available at [http://svnbook.red-bean.com/en/1.7/index.html](http://svnbook.red-bean.com/en/1.7/index.html).
    It details the basis of subversion and explains the process of committing changes
    and the revision process. This resource also assumes a mostly command-line approach
    to dealing with the repository system, but the terminology is similar to most
    graphical frontends. Most clients that are compatible with Git also support Subversion,
    and there are packages available that can convert a Subversion repository into
    a Git repository without (too much) loss of the structure of the repository. One
    graphical frontend that I use on a regular basis is SmartGit/Hg by Syntevo. It
    runs on all platforms and has support for GitHub repositories. It is free for
    non-commercial work, but requires a license when used for commercial projects.
  prefs: []
  type: TYPE_NORMAL
- en: Project management and feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few difficulties that come with working with a team on a project.
    Such work requires an additional layer on top of the actual development. For this,
    there are project-management solutions available that can organize projects. These
    solutions usually contain multiple levels and are usually built on top or on part
    of a revision system. Most project-management solutions contain (at least) issue
    trackers and road maps. Most of these solutions are mostly built as administrative
    tools and do not directly interface with the developed code (at least in the case
    of ImageJ plugins). They, however, allow for developers to keep track of progress
    and plan future development and for end users to provide feedback and indicate
    where bugs and errors exist. Most of these solutions run on a server that can
    be approached via a browser, and they support multiple users as well as unregistered
    guest users.
  prefs: []
  type: TYPE_NORMAL
- en: Different solutions exist, and the choice for a solution should be based on
    your needs and equipment available. Server hosting nowadays is not really complicated
    or expensive, so the choices are quite broad. Some options are available are GitHub.
    They can host projects, provided they are open source, for free. Other options
    are hosting your own solution, such as Redmine. Redmine is an open source project
    management solution written in the Ruby language. Other open source examples are
    Launchpad, used by many Canonical projects related to Ubuntu and Trac used by
    NASA's JPL and for Tor development. Besides bug trackers, they also have some
    form of time management and road map. They also allow us to host files and documentation.
    Redmine also supports news and forum pages for projects, as well as user management
    on a project basis.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to develop code in a more managed setting, these tools may be useful
    to investigate. Many of these systems can work on a small network or even just
    on your local computer. To use any of these systems in a more accessible setting,
    you require a computer system with a revision system installed, such as Git or
    Subversion, and a functional and configured webserver application, such as Apache,
    Nginx, or Tomcat. For Redmine, a Ruby, and a *SQL database installation is also
    required. Some systems also require a PHP installation for certain functionality.
    Although this may sound complicated, many of these functionalities come standard
    with a **LAMP** (**Linux, Apache, MySQL, PHP**) server distribution, such as the
    Ubuntu Server edition. Many server-hosting companies provide a fully configured
    LAMP server without additional management. Also, many of these project-management
    suites come with simple installers that are configurable for many different use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Using the software is done via a basic login page, which allows different users
    with different levels of access to the management system. Privileges can be granted
    to allow certain users to create, modify, and manage projects. Other users can
    be added as reporters. They can access most parts of the management systems, such
    as the trackers and the forum pages, but not the settings of the project. In the
    case of Redmine, most of the pages are based on a Wiki-like syntax for the content,
    allowing rich and feature-rich documentation with graphics and other layout options.
    Most issue trackers have room for different categories, such as bugs, features,
    or support. This allows us to make classifications of the type of issue that is
    being reported as well as their priority. Issues can also be assigned to specific
    developers, making the division of labor for multiple developers clear and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Resources and documentation for Redmine is available online at [http://www.redmine.org/projects/redmine/wiki/Guide](http://www.redmine.org/projects/redmine/wiki/Guide),
    which uses Redmine itself and functions as a clear example of the workflow. A
    published book called *Mastering Redmine* is available as well.
  prefs: []
  type: TYPE_NORMAL
- en: Other resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing code, it can be useful to check whether certain solutions to
    your problem already exist. When a good implementation already exists and is used,
    it saves you time in developing a library or functions. For example, many good
    solutions to generate Excel files exist in the form of libraries written in Java.
    One such example is the Apache POI project, which allows for the reading and writing
    of Excel files (and other Microsoft Office products). Implementations of this
    library exist for many software packages as well as other Java-based software.
    For instance, the xlwrite wrapper function developed for Matlab by Alec de Zegher
    uses the Apache POI project to create Excel files ([http://www.mathworks.com/matlabcentral/fileexchange/38591](http://www.mathworks.com/matlabcentral/fileexchange/38591)).
    It should not to be confused with the `.xlswrite` wrapper function supplied by
    MATLAB, which uses ActiveX to write Excel files, thereby requiring a Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'For resources that you wish to use as libraries, you can use Maven, as described
    in [Chapter 7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"), *Explanation
    of ImageJ Constructs*. Maven is part of most IDE installations (either as part
    of the core or as a separate plugin). By including the libraries as dependencies
    in the `<dependencies>` tag of the POM model, they will automatically be added
    to your projects'' dependencies list. Additional resources on how to use Maven
    in a project can be found on the Apache Maven website ([https://maven.apache.org/guides/index.html](https://maven.apache.org/guides/index.html)),
    which is the main developer of the Maven system. There are also some books and
    videos available to set up and develop software using Maven, for instance, *Apache
    Maven 3.0 cookbook* and *Maven: The definitive guide*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the steps that can be taken after finishing
    this book. I focused on some tools that are available to make the development
    of software more organized and professional. Some resources for each of these
    components were included, both ones available online as well as published works.
  prefs: []
  type: TYPE_NORMAL
