- en: Debugging the JEE Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to write and run unit tests for Java
    applications using Eclipse and JUnit. In this chapter, we are going to learn how
    to use Eclipse to debug JEE applications. Debugging is an unavoidable part of
    application development. Unless the application is very simple, the chances are
    that it is not going to work as expected on the very first attempt and you will
    spend some time trying to find out the reasons why. In very complex applications,
    application developers may end up spending more time debugging than writing application
    code. Problems may not necessarily exist in your code, but may exist in the external
    system that your application depends on. Debugging a complex piece of software
    requires skill, which can be developed with experience. However, it also needs
    good support from the application runtime and IDE.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to debug an application. You may just put `System.out.println()`
    statements in your code and print values of the variables, or just a message stating
    that execution of the application has reached a certain point. If the application
    is small or simple, this may work, but this may not be a good idea when debugging
    large and complex applications. You also need to remember to remove such debug
    statements before moving the code to staging or production. If you have written
    unit tests and if some of the unit tests fail, then that may give you some idea
    about the problems in your code. However, in many cases, you may want to monitor
    the execution of code at line level or function level and check the values of
    the variables at that line or in that function. This requires support from the
    language runtime and a good IDE that helps you visualize and control the debugging
    process. Fortunately, Java has an excellent debugger, and Eclipse JEE provides
    great support for debugging Java code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to debug JEE applications using Eclipse
    JEE. We will use the same *Course Management* application that we built in [Chapter
    4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating JEE Database
    Applications*, for debugging. The debugging technique described in this chapter
    can be applied to remotely debug any Java application, and is not necessarily
    restricted to the JEE applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Eclipse to debug JEE applications remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to perform different different debugging actions, such as
    setting breakpoints, inspecting variables and expressions, and stepping through
    the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the debugger from Eclipse to an externally running JEE application
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a remote Java application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have debugged standalone Java applications from Eclipse. You set breakpoints
    in the code, run the application in the Debug mode from Eclipse, and then debug
    the application by stepping through the code. Debugging remote Java applications
    is a bit different, particularly when it comes to how you launch the debugger.
    In the case of local application, the debugger launches the application. In the
    case of remote application, it is already launched and you need to connect the
    debugger to it. In general, if you want to allow remote debugging for the application,
    you need to run the application using the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Xdebug` enables debugging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xrunjdwp` runs the debugger implementation of the **Java Debug Wire Protocol**
    (**JDWP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of `-Xdebug -Xrunjdwp`, you can also use `-agentlib:jdwp` for JDK 1.5
    and above, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the parameters used here in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transport=dt_socket`: This starts a socket server at `address=9001` (this
    can be any free port) to receive debugger commands and send responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server=y`: This tells the JVM if the application is a server or a client,
    in the context of debugger communication. Use the `y` value for remote applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suspend=n`: This tells the JVM to not wait for the debugger client to attach
    to it. If the value is `y`, then the JVM will wait before executing the main class
    until a debugger client attaches to it. Setting the `y` value for this option
    may be useful in cases where you want to debug, for example, the initialization
    code of servlets that are loaded upon startup of the web container. In such cases,
    if you do not choose to suspend the application till the debugger connects to
    it, the code that you want to debug may get executed before the debugger client
    attaches to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a web application using Tomcat in Eclipse EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how to configure Tomcat in Eclipse EE and deploy web
    applications in it from Eclipse (refer to the *Configuring Tomcat in Eclipse*
    and *Running JSP in Tomcat* sections in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*). We will use the *Course Management*
    application that we created in [Chapter 4](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications* (JDBC version), for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Tomcat in Debug mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to debug a remote Java process, you need to start the process using
    debug parameters. However, if you have configured Tomcat in Eclipse EE, you don''t
    need to do this manually. Eclipse takes care of launching Tomcat in Debug mode.
    To start Tomcat in Debug mode, select the server in the Servers view and click
    the Debug button. Alternatively, right-click on the server and select Debug from
    the menu. Make sure that the project you want to debug is already added to Tomcat;
    in this case, the project is `CourseManagementJDBC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Starting Tomcat in Debug mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Tomcat is started in Debug mode, its status changes to Debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Tomcat running in Debug mode'
  prefs: []
  type: TYPE_NORMAL
- en: Setting breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s set breakpoints in the code before we launch the `CourseManagement`
    application. Open `CourseDAO` from the `CourseManagementJDBC` project and double-click
    in the left margin of the first line in the `getCourses` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Setting a breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to set a breakpoint at a line is to right-click in the left margin
    and select Toggle Breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Toggling breakpoints using the menu'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set breakpoints at the method level. Just place the caret inside
    any method, and select the Run | Toggle Method Breakpoint menu. This is equivalent
    to setting the breakpoint at the first line of the method. This is preferred over
    setting a breakpoint at the first line of the method when you always want to stop
    at the beginning of the method. The debugger will always stop at the first statement
    in the method, even if you later insert code at the beginning of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful breakpoint option is to set it when any exception occurs during
    program execution. Often, you may not want to set a breakpoint at a specific location,
    but may want to investigate why an exception is happening. If you do not have
    access to the stack trace of the exception, you can just set a breakpoint for
    the exception and run the program again. Next time, the execution will stop at
    the code location where the exception occurred. This makes it easy to debug exceptions.
    To set a breakpoint for an exception, select Run | Add Java Exception Breakpoint... and
    select the `Exception` class from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Setting a breakpoint at an exception'
  prefs: []
  type: TYPE_NORMAL
- en: Running the application in Debug mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s run the `listCourse.jsp` page in Debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Project Navigator, go to `src/main/webapp/listCourse.jsp` and right-click
    on the file. Select Debug As | Debug on Server. Eclipse may prompt you to use
    the existing debug server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Choosing an existing debug server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Finish. Eclipse will ask you if you want to switch to the Debug perspective
    (refer to [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse*, for a discussion on Eclipse perspectives):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Auto-switching to the Debug perspective'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Remember my decision option and click the Yes button. Eclipse will
    switch to the Debug perspective. Eclipse will try to open the page in the internal
    Eclipse browser, but it won''t display the page immediately. Recall that `listCourse.jsp`
    calls `Course.getCourses()`, which in turn calls `CourseDAO.getCourses()`. We
    have set a breakpoint in the `CourseDAO.getCourses()` method, so the execution
    of the page stops there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The debugger paused at a breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: Performing step operations and inspecting variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can now perform different step operations (step over, step in, and step
    out) using the toolbar icons at the top, or using keyboard shortcuts. Open the
    drop-down on the Run menu to learn about the menu and toolbar shortcuts for debugging.
    Typically, you would inspect variables or perform step operations to verify whether
    the execution flow is correct and then continue the execution by clicking the Resume
    button or by using the menu/keyboard shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: In the Debug tab (refer to *Figure 6.8*), you can see all the threads and inspect
    the stack frames of each thread when the debugger is suspended. Stack frames of
    a thread show you the path of a program execution in that thread until the point
    that the debugger was suspended after hitting a breakpoint or due to step operations.
    In a multithreaded application, such as a Tomcat web container, more than one
    thread might have been suspended at a time and each might have different stack
    frames. When debugging a multithreaded application, make sure that you have selected
    the required thread in the Debug tab before selecting options to step over/in/out
    or resume.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you step into a method and realize that the values are not what you expect
    and you want to rerun statements in the current method to investigate them. In
    such cases, you can drop to any previous stack frame and start over.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that in the preceding example we step into the `DatabaseConnectionFactory.getConnectionFactory().getConnection`
    method. When we step in, the debugger first steps into the `getConnectionFactory`
    method, and in the next step-in operation, it steps into the `getConnection` method.
    Suppose, when we are in the `getConnection` method that we want to go back and
    check what happened in the `getConnectionFactory` method for something that we
    might have missed earlier (although in this simple example, not much happens in
    the `getConnectionFactory` method; it should just serve as an example). We can
    go back to the `getCourses` method and start over the execution of `getConnectionFactory`
    and `getConnection`. In the Debug tab, right-click on the `CourseDAO.getCourses()`
    stack frame and select Drop to Frame, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 Drop to Frame
  prefs: []
  type: TYPE_NORMAL
- en: The debugger discards all the stack frames above the selected frame, and the
    execution drops back to the selected frame; in this case, in the `getCourses`
    method of the `CourseDAO` class. You can then step over again into the `getConnection`
    method. Note that only stack variables and their values are discarded when you
    drop to frame. Any changes made to reference objects that are not on the stack
    are not rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting variable values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s step over a few statements till we are in the `while` loop to create
    course objects from the data returned by the result set. In the top-right window,
    you will find the Variables view, which displays variables applicable at that
    point of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: The debugger paused at breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inspect variables in the previous method calls too by changing the
    selection in the Debug tab: click on any previous method call (stack frame) and
    the Variables view will display variables that are valid for the selected method.
    You can change the value of any variable, including values of the member variables
    of the objects. For example, in *Figure 6.8, *we can change the value of the course
    name from `"Machine Learning"` to `"Machine Learning - Part1"`. To change the
    variable value, right-click on the variable in the Variables view and select Change
    Value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Changing the variable''s value during debugging'
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t have to go to the Variables view to check a variable''s value every
    time. There is a quick way: just hover the cursor over the variable in the editor
    and Eclipse will pop up a window showing the variable''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Inspecting the variable'
  prefs: []
  type: TYPE_NORMAL
- en: You can also right-click on a variable and select the Inspect option to see
    the variable's values. However, you cannot change the value when you select the Inspect
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the value of a variable frequently (for example, a variable
    in a loop), you can add the variable to the watchlist. It is a more convenient
    option than trying to search for the variable in the Variables view. Right-click
    on a variable and select the Watch option from the menu. The Watch option adds
    the variable to the Expressions view (its default location is next to the Breakpoints
    view at the top right) and displays its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Inspecting a variable'
  prefs: []
  type: TYPE_NORMAL
- en: The use of the Expressions view is not limited to watching variable values.
    You can watch any valid Java expression, such as arithmetic expressions, or even
    method calls. Click on the plus icon in the Expressions view and add an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an application in an externally configured Tomcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we have debugged our application using Tomcat configured within Eclipse.
    When we launched Tomcat in Debug mode, Eclipse took care of adding the JVM parameters
    for debugging to the Tomcat launch script. In this section, we will see how to
    launch an external (to Eclipse) Tomcat instance and connect to it from Eclipse.
    Although we are going to debug a remote instance of Tomcat, information in this
    section can be used for connecting to any remotely running Java program that is
    launched in Debug mode. We have already seen the debug parameters to pass when
    launching a remote application in Debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launching Tomcat externally in Debug mode is not too difficult. Tomcat startup
    scripts already have an option to start the server in Debug mode; you just need
    to pass the appropriate parameters. From the Command Prompt, select the `<TOMCAT_HOME>/bin` folder
    and type the following command in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Launching Tomcat in Debug mode in Mac OSX and Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing the `jpda` argument sets the default values to all the required debug
    parameters. The default debug port is 8000\. If you want to change it, either
    modify `catalin.bat/catalin.sh` or set the environment variable `JPDA_ADDRESS` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting `JPDA_ADDRESS` environment variable in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `JPDA_ADDRESS` environment variable in OSX and Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can set `JPDA_SUSPEND` to `y` or `n` to control whether the debugger
    should wait for the client to connect before executing the `main` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect the debugger from Eclipse to a remote instance, select the Run |
    Debug Configurations... menu. Right-click on the Remote Java Application node
    in the list view on the left and select New:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Inspecting a variable'
  prefs: []
  type: TYPE_NORMAL
- en: Set the appropriate Project and Port (the same as what you selected to start
    Tomcat in Debug mode, that is, the default: `8000`) and click Debug. If the debugger
    connection is successful, Eclipse will switch to the debug perspective. From here
    on out, the process of debugging is the same as that explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Using the debugger to know the status of program execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how to use the debugger to verify the execution flow of a program
    (using the step operations) and to inspect variables. You can also use the debugger
    to know what the status of the running program is. For example, a web request
    is taking too long and you want to know where exactly the execution is stuck.
    You can use the debugger to find this. It is similar to taking the thread dump
    of a running program, but is much easier than the methods used to get the thread
    dump. Let''s assume that our `CourseDAO.getCourses` method is taking a long time
    to execute. Let''s simulate this by using a couple of `Thread.sleep` calls, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Start Tomcat in Debug mode, and run `listCourses.jsp` in Debug mode. Because
    we have inserted `Thread.sleep` statements, the request will take time. Go to
    the Debug view, which is where threads and stack frames are displayed. Click on
    the first node under the Tomcat debug configuration node and select the Suspend
    option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Suspending program execution'
  prefs: []
  type: TYPE_NORMAL
- en: 'The debugger pauses execution of all threads in the program. You can then see
    the status of each thread by expanding the thread nodes. You will find one of
    the threads executing the `CourseDAO.getCourse` method and the statement that
    it was executing before being suspended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: The status of suspended threads'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, you can see that the execution of the thread
    is suspended in the `CourseDAO.getCourses` method of the `Thread.sleep` statement.
    You can even inspect variables at each stack frame when the program is suspended.
    By suspending the program and inspecting the state of threads and stack frames,
    you may be able to find bottlenecks in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good support for debugging from language runtime and IDE can considerably reduce
    the time spent in debugging. Java runtime and Eclipse provide excellent support
    for debugging local and remote applications. To debug a remote application, launch
    it with debug parameters for JVM and connect the Eclipse debugger to it. You can
    then debug the remote application just as you would debug the local one, that
    is, set breakpoints, perform step operations, and inspect variables. You can also
    change variable values in the application when its execution is suspended.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to develop JEE applications using EJBs
    and use the GlassFish server. Although this chapter explained the debugging of
    JEE applications deployed in Tomcat, you can use the same techniques in the GlassFish
    server.
  prefs: []
  type: TYPE_NORMAL
