<html><head></head><body>
<div id="_idContainer049">
<h1 class="chapter-number" id="_idParaDest-130"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-131"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.2.1">Advanced Testing Strategies</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter will further guide our entry into the world of complex testing methods and will offer clear guides to ensure that our software is reliable and robust. </span><span class="koboSpan" id="kobo.3.2">It will cover a range of topics: from a consideration of the basics of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">test-driven development</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">TDD</span></strong><span class="koboSpan" id="kobo.7.1">) to </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.8.1">specifics such as unit testing web controllers with security considerations, integration of different parts of an application, and the unique challenges of testing in reactive environments. </span><span class="koboSpan" id="kobo.8.2">This should make you a better developer who can write tests that cover all code. </span><span class="koboSpan" id="kobo.8.3">These techniques provide a strong foundation for ensuring improvements in quality and that these improvements are applicable to diverse software architectures – from classical web applications to reactive systems of modern </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">software architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In other words, by learning these testing strategies, you work not only to catch bugs or prevent errors but to prepare for the modern demands of software development. </span><span class="koboSpan" id="kobo.10.2">This chapter outlines everything you need to create high-performing, scalable, and maintainable applications. </span><span class="koboSpan" id="kobo.10.3">As we go on through the chapter, you will understand when and how to apply those testing techniques confidently, regardless of the complexity of your application or its architecture. </span><span class="koboSpan" id="kobo.10.4">This chapter will prepare you with the information and tools necessary to go successfully through the constantly changing world of </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">software management.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we’ll cover </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">TDD in </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Spring Boot</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Unit testing of controllers with a </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">security layer</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Integration testing – bridging </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">components together</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Testing </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">reactive components</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">Let’s begin this journey of learning how to make your Spring Boot applications secure </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">and robust!</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">For this chapter, we are going to need some settings in our </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">local machines:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Java 17 Development Kit</span></strong><span class="koboSpan" id="kobo.28.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.29.1">JDK 17</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">A modern </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">integrated development environment</span></strong><span class="koboSpan" id="kobo.33.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.34.1">IDE</span></strong><span class="koboSpan" id="kobo.35.1">) – I recommend </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">IntelliJ IDEA</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">GitHub repository</span></strong><span class="koboSpan" id="kobo.38.1">: You can clone all repositories related to </span><a href="B18400_06.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.39.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.40.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">here: </span></span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Docker Desktop</span></span></li>
</ul>
<h1 id="_idParaDest-133"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.44.1">TDD in Spring Boot</span></h1>
<p><span class="koboSpan" id="kobo.45.1">When I </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.46.1">was first introduced to the concept of TDD, I admit I was quite skeptical. </span><span class="koboSpan" id="kobo.46.2">I felt the concept of writing unit tests before the code itself just seemed ridiculous, or, in other words, crazy. </span><span class="koboSpan" id="kobo.46.3">I was not different from others who felt it was just an added process to slow down an already jam-packed development life cycle. </span><span class="koboSpan" id="kobo.46.4">But now, having explored the use of TDD during application development with Spring Boot 3.0, I know that this is not </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the case.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Spring Boot 3.0 was a very fantastic platform to go for TDD-based work. </span><span class="koboSpan" id="kobo.48.2">I’d just taken on a new project and started moving forward based on the concept of TDD. </span><span class="koboSpan" id="kobo.48.3">The process itself was awkward, to say the least. </span><span class="koboSpan" id="kobo.48.4">It’s like pre-judging the future through writing a code test for code that doesn’t even exist. </span><span class="koboSpan" id="kobo.48.5">However, I continued with it. </span><span class="koboSpan" id="kobo.48.6">The unit tests literally drove the writing of the code in a way that I’ve never seen before. </span><span class="koboSpan" id="kobo.48.7">Having a clear and defined purpose in every single test and the development of code that would meet it made each relevant approach to the development focused </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">and considered.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Its purpose was to catch early bugs and make the code base organized and maintainable. </span><span class="koboSpan" id="kobo.50.2">Writing tests in this manner becomes a cycle through </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Red</span></strong><span class="koboSpan" id="kobo.52.1"> (writing a failing test), </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">Green</span></strong><span class="koboSpan" id="kobo.54.1"> (making the test pass), and </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">Refactor</span></strong><span class="koboSpan" id="kobo.56.1"> (cleaning up the code). </span><span class="koboSpan" id="kobo.56.2">It bounces you along the project. </span><span class="koboSpan" id="kobo.56.3">The time spent upfront in writing tests gets paid off by a reduction in debugging and revising faulty </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">code later.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Now, let’s proceed practically to apply the theory in our Bookstore application. </span><span class="koboSpan" id="kobo.58.2">In this section, we will practice TDD, building a feature in our application. </span><span class="koboSpan" id="kobo.58.3">You will learn how to first write and then pass the tests according to the feature. </span><span class="koboSpan" id="kobo.58.4">All of this practical experience is intended</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.59.1"> to provide you with a solid foundation, rather than just theoretical knowledge, in application development with Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">Boot 3.0.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">This, of course, is meant to make you feel comfortable and confident when using TDD in your projects. </span><span class="koboSpan" id="kobo.61.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">get started!</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.63.1">Implementing TDD</span></h2>
<p><span class="koboSpan" id="kobo.64.1">In this</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.65.1"> section, we will start a new TDD journey. </span><span class="koboSpan" id="kobo.65.2">As a part of this task, we have a new requirement for our Bookstore application: introducing an additional service layer between the controller and the repository for </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">Author</span></strong><span class="koboSpan" id="kobo.67.1"> flows. </span><span class="koboSpan" id="kobo.67.2">The controller has two GET methods and one PUT, one POST, and one DELETE method. </span><span class="koboSpan" id="kobo.67.3">The requirements are to create a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">AuthorService.java</span></strong><span class="koboSpan" id="kobo.69.1">, provide the methods the controller class needs, and throw an </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">EntityNotFound</span></strong><span class="koboSpan" id="kobo.71.1"> exception when </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">Author</span></strong><span class="koboSpan" id="kobo.73.1"> is not found in the database in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">DELETE</span></strong><span class="koboSpan" id="kobo.75.1"> process. </span><span class="koboSpan" id="kobo.75.2">Let’s achieve this task by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">TDD approach:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.77.1">The cycle of Red (writing a failing test)</span></strong><span class="koboSpan" id="kobo.78.1">: We will create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">AuthorServiceTest.java</span></strong><span class="koboSpan" id="kobo.80.1"> under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">src/test/java</span></strong><span class="koboSpan" id="kobo.82.1"> folder. </span><span class="koboSpan" id="kobo.82.2">First, we will </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.83.1">write our first test for the potential </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">getAuthor</span></strong><span class="koboSpan" id="kobo.85.1"> method. </span><span class="koboSpan" id="kobo.85.2">However, when we start writing the test method, we will see we don’t have a service class yet, and we will create an empty service class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">AuthorService.java</span></strong><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">But when we try to autocomplete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">getAuthor</span></strong><span class="koboSpan" id="kobo.89.1"> method, we will see there is no method named like this. </span><span class="koboSpan" id="kobo.89.2">So, we will create a new method in the service class </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.91.1">
public Optional&lt;Author&gt; getAuthor(Long id) {
return Optional.empty();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.92.1">As you can see, this method almost is empty. </span><span class="koboSpan" id="kobo.92.2">However, we know we will have a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">getAuthor</span></strong><span class="koboSpan" id="kobo.94.1">, accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Id</span></strong><span class="koboSpan" id="kobo.96.1"> as a parameter, and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Optional&lt;Author&gt;</span></strong><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">In all tests, we need to prepare the environment for this test such as creating the required data. </span><span class="koboSpan" id="kobo.98.3">So, we will inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">authorRepository</span></strong><span class="koboSpan" id="kobo.100.1"> class</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.101.1"> in both service and</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.102.1"> test classes. </span><span class="koboSpan" id="kobo.102.2">Now, we can write the first </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">test case:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.104.1">@Mock
private AuthorRepository authorRepository;
@Test
void givenExistingAuthorId_whenGetAuthor_thenReturnAuthor() {
Publisher defaultPublisher = Publisher.builder().name("Packt Publishing").build();
Author savedAuthor = Author.builder()
                .id(1L)
                .name("Author Name")
                .publisher(defaultPublisher)
                .biography("Biography of Author")
                .build();
    when(authorRepository.findById(1L)).thenReturn(Optional.of(savedAuthor));
    Optional&lt;Author&gt; author = authorService.getAuthor(1L);
    assertTrue(author.isPresent(), "Author should be found");
    assertEquals(1L, author.get().getId(), "Author ID should match");
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.105.1">Before </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.106.1">running this test, let’s understand the new </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.107.1">terminologies in this </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">code snippet:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">@Mock</span></strong><span class="koboSpan" id="kobo.110.1">: This mocks the class and allows us to manipulate all </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">its methods.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">when</span></strong><span class="koboSpan" id="kobo.113.1">: This helps us to manipulate the returned object of the mocked methods. </span><span class="koboSpan" id="kobo.113.2">In our sample, it mocks when </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">authorRepository.findById()</span></strong><span class="koboSpan" id="kobo.115.1"> is called, and it will always </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">savedAuthor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">assertTrue</span></strong><span class="koboSpan" id="kobo.120.1">: This asserts the method </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">returns true.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">assertEquals</span></strong><span class="koboSpan" id="kobo.123.1">: This asserts that the provided two values </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">are equal.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.125.1">When we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">givenExistingAuthorId_whenGetAuthor_thenReturnAuthor</span></strong><span class="koboSpan" id="kobo.127.1"> method, the test will fail because our method is always returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Optional.empty()</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">So, we have a failing test on our hands; let’s go and </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">fix it.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.131.1">Green (making the test pass)</span></strong><span class="koboSpan" id="kobo.132.1">: In </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.133.1">order to pass this test, we need to use the repository class in </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">our method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.135.1">
public Optional&lt;Author&gt; getAuthor(long id) {
       return authorRepository.findById(id);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.136.1">Now, it is done. </span><span class="koboSpan" id="kobo.136.2">When we run the tests again, we will see it </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">will pass.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Refactor (cleaning up the code)</span></strong><span class="koboSpan" id="kobo.139.1">: In this step, we need to check both the test and source </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.140.1">classes and see whether they need refactoring. </span><span class="koboSpan" id="kobo.140.2">In our case, in the source class, we don’t need any refactoring, but on the test side, we may tidy up a little bit. </span><span class="koboSpan" id="kobo.140.3">We can remove the object creation from the test class and make the test case more readable. </span><span class="koboSpan" id="kobo.140.4">Also, we </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.141.1">can reuse that object in other test classes in </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">the future:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.143.1">
private Author savedAuthor;
@BeforeEach
void setup() {
 Publisher defaultPublisher = Publisher.builder().name("Packt Publishing").build();
 savedAuthor = Author.builder()
         .id(1L)
         .name("Author Name")
         .publisher(defaultPublisher)
         .biography("Biography of Author")
         .build();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.144.1">We have </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.145.1">introduced a </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">setup</span></strong><span class="koboSpan" id="kobo.147.1"> method for setting the common variables to reduce code duplications in the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">test class.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.149.1">After introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">setup</span></strong><span class="koboSpan" id="kobo.151.1"> method, our test method became clearer with fewer lines </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">of code:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.153.1">@Test
void givenExistingAuthorId_whenGetAuthor_thenReturnAuthor() {
when(authorRepository.findById(1L)).thenReturn(Optional.of(savedAuthor));
    Optional&lt;Author&gt; author = authorService.getAuthor(1L);
    assertTrue(author.isPresent(), "Author should be found");
    assertEquals(1L, author.get().getId(), "Author ID should match");
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.154.1">We have completed one iteration of TDD for the Author service. </span><span class="koboSpan" id="kobo.154.2">We need to do the</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.155.1"> same iterations for all methods until we have a mature </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">AuthorService</span></strong><span class="koboSpan" id="kobo.157.1"> that can be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">controller class.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.159.1">At the end</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.160.1"> of these processes, we will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">AuthorServiceTest</span></strong><span class="koboSpan" id="kobo.162.1"> as in the GitHub repository. </span><span class="koboSpan" id="kobo.162.2">However, we will also have some new terminology for unit tests, which we will discuss in the </span><em class="italic"><span class="koboSpan" id="kobo.163.1">Discussing terminology for unit </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.164.1">tests</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> section.</span></span></p></li> <li><span class="koboSpan" id="kobo.166.1">We have left one final step: updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">AuthorController</span></strong><span class="koboSpan" id="kobo.168.1"> class to consume this new (</span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">AuthorService</span></strong><span class="koboSpan" id="kobo.170.1">) service instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">the repository.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.172.1">We will need to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">AuthorService</span></strong><span class="koboSpan" id="kobo.174.1"> class into the controller class and use the methods in </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">AuthorService</span></strong><span class="koboSpan" id="kobo.176.1"> instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">repository methods.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.178.1">You can see the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">AuthorController</span></strong><span class="koboSpan" id="kobo.180.1"> in the GitHub repository (</span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java"><span class="koboSpan" id="kobo.181.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java</span></a><span class="koboSpan" id="kobo.182.1">). </span><span class="koboSpan" id="kobo.182.2">I would like to mention the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">delete</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.184.1">method here:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.185.1">
    @DeleteMapping("/{id}")
    public ResponseEntity&lt;Object&gt; deleteAuthor(@PathVariable Long id) {
        try {
            authorService.deleteAuthor(id);
            return ResponseEntity.ok().build();
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.186.1">As you can see, we have replaced the methods and, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">delete</span></strong><span class="koboSpan" id="kobo.188.1"> function, we have added an exception handler to </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">cover </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">EntityNotFoundException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.192.1">In this section, we</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.193.1"> have learned about the TDD and how to implement it in a real-world sample. </span><span class="koboSpan" id="kobo.193.2">This will take some time, and it requires some patience to make it a habit in the development cycle. </span><span class="koboSpan" id="kobo.193.3">However, once you have learned how to go with TDD, you will have fewer bugs and more </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">maintainable code.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.195.1">Discussing terminology for unit tests</span></h2>
<p><span class="koboSpan" id="kobo.196.1">Let’s discuss</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.197.1"> some essential terminology in </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">unit testing:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">assertThrows()</span></strong><span class="koboSpan" id="kobo.200.1">: This </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.201.1">is a method used in JUnit tests to assert that a specific type of exception is thrown during the execution of a piece of code. </span><span class="koboSpan" id="kobo.201.2">It is particularly useful when you want to test that your code properly handles error conditions. </span><span class="koboSpan" id="kobo.201.3">In our test class, you can see it </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
assertThrows(EntityNotFoundException.class, () -&gt; authorService.deleteAuthor(1L));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.204.1">This method takes two main parameters: the expected exception type and a functional interface (usually a lambda expression), which contains the code expected to throw the exception. </span><span class="koboSpan" id="kobo.204.2">If the specified exception is thrown, the test passes; otherwise, </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">it fails.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">verify()</span></strong><span class="koboSpan" id="kobo.207.1">: Mockito</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.208.1"> is a library that we always </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.209.1">use in unit testing. </span><span class="koboSpan" id="kobo.209.2">It has very useful methods that make our tests more reliable and readable. </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">verify()</span></strong><span class="koboSpan" id="kobo.211.1"> is one of them; it is used to check that certain interactions with mock objects occur. </span><span class="koboSpan" id="kobo.211.2">It can verify that methods were called with specific parameters, a certain number of times, or even that they were never called. </span><span class="koboSpan" id="kobo.211.3">This is crucial for testing that your code interacts with dependencies as expected. </span><span class="koboSpan" id="kobo.211.4">In our test class, you can see it </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
verify(authorRepository).delete(savedAuthor);
verify(authorRepository, times(1)).delete(savedAuthor);</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">@InjectMocks</span></strong><span class="koboSpan" id="kobo.215.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">@InjectMocks</span></strong><span class="koboSpan" id="kobo.217.1"> annotation in Mockito is used to create</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.218.1"> instances</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.219.1"> of a class and inject mock fields into it. </span><span class="koboSpan" id="kobo.219.2">This is particularly useful when you have a class that depends on other components or services, and you want to test the class in isolation by using mock versions of its dependencies. </span><span class="koboSpan" id="kobo.219.3">The following code snippet shows a </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">sample usage:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
@InjectMocks
private AuthorService authorService;</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">@ExtendWith(MockitoExtension.class)</span></strong><span class="koboSpan" id="kobo.223.1">: This annotation is used with JUnit 5 to enable Mockito support in tests. </span><span class="koboSpan" id="kobo.223.2">By declaring </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">@ExtendWith(MockitoExtension.class)</span></strong><span class="koboSpan" id="kobo.225.1"> at the class level, you allow Mockito</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.226.1"> to initialize mocks and inject them before tests are run. </span><span class="koboSpan" id="kobo.226.2">This makes it easier to write cleaner test code with less boilerplate. </span><span class="koboSpan" id="kobo.226.3">You can see it here in our </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">test class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.228.1">
@ExtendWith(MockitoExtension.class)
public class AuthorServiceTest
{}</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">@BeforeEach</span></strong><span class="koboSpan" id="kobo.230.1">: In JUnit 5, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">@BeforeEach</span></strong><span class="koboSpan" id="kobo.232.1"> annotation is used on a method to specify that it </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.233.1">should be executed before each test method in the current test class. </span><span class="koboSpan" id="kobo.233.2">It’s commonly used for setup tasks that are common to all tests, ensuring each test starts with a fresh state. </span><span class="koboSpan" id="kobo.233.3">It is used with a method, as you can see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.235.1">
@BeforeEach
void setUp() {
   // common setup code
}</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.236.1">As we are </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.237.1">now aware of the new terminology in the unit test, in the next section, we will use our unit test knowledge and improve it by learning how to test controller classes, especially the ones with a </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">security layer.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.239.1">Unit testing of controllers with a security layer</span></h1>
<p><span class="koboSpan" id="kobo.240.1">In this </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.241.1">new section, we will deal with testing controller classes. </span><span class="koboSpan" id="kobo.241.2">Why do we have a different test approach for controller classes? </span><span class="koboSpan" id="kobo.241.3">The request and response can be represented as JSON objects, similar to a real Request and Response, not like the objects in our project. </span><span class="koboSpan" id="kobo.241.4">This will help us check that everything is OK to accept requests and also assert the JSON response if they match the requirements. </span><span class="koboSpan" id="kobo.241.5">We will discuss some new annotations and next, we will focus on how to implement these new annotations for </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">AuthorControllerTest</span></strong><span class="koboSpan" id="kobo.243.1"> step </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">by step.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.245.1">Key annotations for Spring MVC controller testing</span></h2>
<p><span class="koboSpan" id="kobo.246.1">Spring </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">model-view-controller</span></strong><span class="koboSpan" id="kobo.248.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.249.1">MVC</span></strong><span class="koboSpan" id="kobo.250.1">) testing uncovers a wealth of annotations that are crafted to </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.251.1">simplify and improve our testing endeavors. </span><span class="koboSpan" id="kobo.251.2">Each annotation has a purpose, allowing us to replicate an environment that closely resembles our application with a focus, on the MVC layers and their interactions with security settings. </span><span class="koboSpan" id="kobo.251.3">Let’s delve into some annotations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">@WebMvcTest</span></strong><span class="koboSpan" id="kobo.253.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">@Import</span></strong><span class="koboSpan" id="kobo.255.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">@WithMockUser</span></strong><span class="koboSpan" id="kobo.257.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">@MockBean</span></strong><span class="koboSpan" id="kobo.259.1">, which are essential players in Spring MVC controller testing. </span><span class="koboSpan" id="kobo.259.2">These annotations help establish a testing framework that ensures our controllers perform as expected whether in isolation or when integrated</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.260.1"> with Spring’s web context and security components. </span><span class="koboSpan" id="kobo.260.2">Let’s take a look </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">at them:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">@WebMvcTest(AuthorController.class)</span></strong><span class="koboSpan" id="kobo.263.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">@WebMvcTest </span></strong><span class="koboSpan" id="kobo.265.1">annotation is </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.266.1">used for unit testing Spring MVC applications in a more focused way. </span><span class="koboSpan" id="kobo.266.2">It is applied to test classes that need to test Spring MVC controllers. </span><span class="koboSpan" id="kobo.266.3">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">@WebMvcTest</span></strong><span class="koboSpan" id="kobo.268.1"> with a specific controller class, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">AuthorController.class</span></strong><span class="koboSpan" id="kobo.270.1">, tells Spring Boot to only instantiate the given controller and its required dependencies, not the whole context. </span><span class="koboSpan" id="kobo.270.2">This makes the tests run faster and focus strictly on the MVC components. </span><span class="koboSpan" id="kobo.270.3">This annotation automatically configures the Spring MVC infrastructure for </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">your tests.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">@Import(SecurityConfig.class)</span></strong><span class="koboSpan" id="kobo.273.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">@Import</span></strong><span class="koboSpan" id="kobo.275.1"> annotation allows you to</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.276.1"> import additional configuration classes into the Spring test context. </span><span class="koboSpan" id="kobo.276.2">When used in controller tests, particularly alongside </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">@WebMvcTest</span></strong><span class="koboSpan" id="kobo.278.1">, it’s often necessary to include specific configuration classes that aren’t automatically picked up by </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">@WebMvcTest</span></strong><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">By specifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">@Import(SecurityConfig.class)</span></strong><span class="koboSpan" id="kobo.282.1">, you’re explicitly telling Spring to load your </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">SecurityConfig</span></strong><span class="koboSpan" id="kobo.284.1"> class. </span><span class="koboSpan" id="kobo.284.2">This class contains security configurations (such as authentication and authorization settings) that are necessary for your tests to run in an environment that closely mimics your application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">security setup.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">@MockBean</span></strong><span class="koboSpan" id="kobo.287.1">: Spring</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.288.1"> application context uses beans such as Service and Repository, and in our test context, we need to mock these beans. </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">@MockBean</span></strong><span class="koboSpan" id="kobo.290.1"> adds mock objects to the Spring application context, and these mocked objects are used instead of real Service and Repository objects. </span><span class="koboSpan" id="kobo.290.2">This is useful for injecting mock implementations for services, repositories, or any other components that your controller depends on, without actually loading those beans from the real </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">application context.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">@WithMockUser</span></strong><span class="koboSpan" id="kobo.293.1">: This </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.294.1">annotation is used in Spring Security tests to simulate running a test with a mock authenticated user. </span><span class="koboSpan" id="kobo.294.2">This annotation allows you to specify details of the mock user, such as username, roles, and authorities, without the need to interact with the actual security environment or authentication mechanism. </span><span class="koboSpan" id="kobo.294.3">It’s particularly useful for controller tests where you want to test the behavior of your endpoints under different authentication or authorization scenarios. </span><span class="koboSpan" id="kobo.294.4">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">@WithMockUser</span></strong><span class="koboSpan" id="kobo.296.1">, you can easily emulate different user contexts, testing how your application responds to various levels of access and ensuring that security constraints are correctly enforced. </span><span class="koboSpan" id="kobo.296.2">This makes it an essential tool for comprehensive testing of secured endpoints in a Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">Boot application.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.298.1">For controller tests, especially </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.299.1">with a security layer, these annotations play crucial roles in ensuring that your tests are focused and fast and reflect your application’s actual running conditions as closely as possible. </span><span class="koboSpan" id="kobo.299.2">In the next section, we will get our hands dirty while implementing these into our </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">test class.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.301.1">Crafting controller tests with Spring annotations</span></h2>
<p><span class="koboSpan" id="kobo.302.1">When we </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.303.1">start working on creating tests, for controllers, it’s important to make use of Springs annotations. </span><span class="koboSpan" id="kobo.303.2">These annotations, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">@WebMvcTest</span></strong><span class="koboSpan" id="kobo.305.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">@Import</span></strong><span class="koboSpan" id="kobo.307.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">@WithMockUser</span></strong><span class="koboSpan" id="kobo.309.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">@MockBean</span></strong><span class="koboSpan" id="kobo.311.1">, are crucial for establishing the testing environment that mirrors our application’s web layer and </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.312.1">security setups. </span><span class="koboSpan" id="kobo.312.2">This section focuses on utilizing these annotations to develop targeted tests for our controllers. </span><span class="koboSpan" id="kobo.312.3">By incorporating these tools, our goal is to strike a balance between speed and accuracy in testing to ensure that our controllers operate effectively within the web environment. </span><span class="koboSpan" id="kobo.312.4">Let’s explore how we can practically apply these annotations to mimic real-world scenarios and verify the functionality of our Spring MVC controllers in </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">certain situations.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Creating a comprehensive test suite for </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">AuthorController</span></strong><span class="koboSpan" id="kobo.316.1"> in a Spring Boot application involves several steps, from setting up the initial testing environment with specific annotations to writing detailed test cases for different user roles and operations. </span><span class="koboSpan" id="kobo.316.2">Here is a step-by-step guide to achieve the final state of </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">AuthorControllerTest.java</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.318.1">as described.</span></span></p>
<h3><span class="koboSpan" id="kobo.319.1">Step 1 – setting up your test environment</span></h3>
<p><span class="koboSpan" id="kobo.320.1">To set up</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.321.1"> your environment, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.323.1">Create a test class file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">AuthorControllerTest.java</span></strong><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">Annotate the class with </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">@WebMvcTest(AuthorController.class)</span></strong><span class="koboSpan" id="kobo.327.1"> to focus on testing only </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">AuthorController</span></strong><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">This tells Spring Boot to configure only the MVC components necessary for the test, without the full </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">application context.</span></span></li>
<li><span class="koboSpan" id="kobo.331.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">@Import(SecurityConfig.class)</span></strong><span class="koboSpan" id="kobo.333.1"> to include your custom security configuration in the test context. </span><span class="koboSpan" id="kobo.333.2">This is crucial for accurately simulating security behaviors </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">during testing.</span></span></li>
<li><span class="koboSpan" id="kobo.335.1">Declare the </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">required fields:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.338.1"> to set up the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">MockMvc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1"> object</span></span></li><li><span class="koboSpan" id="kobo.341.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">MockMvc</span></strong><span class="koboSpan" id="kobo.343.1"> object for performing and asserting </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">HTTP requests</span></span></li><li><span class="koboSpan" id="kobo.345.1">Mock beans for any services or components the controller depends on, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">AuthorService</span></strong><span class="koboSpan" id="kobo.347.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">JwtDecoder</span></strong><span class="koboSpan" id="kobo.349.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">MockBean</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1"> annotation</span></span></li><li><span class="koboSpan" id="kobo.353.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">ObjectMapper</span></strong><span class="koboSpan" id="kobo.355.1"> for JSON serialization and deserialization </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">in tests</span></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.357.1">These are the code changes of </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">this step:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
@WebMvcTest(AuthorController.class)
@Import(SecurityConfig.class)
class AuthorControllerTest {
    @Autowired
    private WebApplicationContext context;
    private MockMvc mockMvc;
    @MockBean
    private AuthorService authorService;
    @MockBean
    private JwtDecoder jwtDecoder;
    private final ObjectMapper objectMapper = new ObjectMapper();
}</span></pre> <p><span class="koboSpan" id="kobo.360.1">Here, we </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.361.1">have set up our test class by mocking </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">AuthorService</span></strong><span class="koboSpan" id="kobo.363.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">JwtDecoder</span></strong><span class="koboSpan" id="kobo.365.1">. </span><span class="koboSpan" id="kobo.365.2">We will be able to manipulate them when needed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.367.1">Step 2 – initializing the testing framework</span></h3>
<p><span class="koboSpan" id="kobo.368.1">Implement a </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.369.1">setup method annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">@BeforeEach</span></strong><span class="koboSpan" id="kobo.371.1"> to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">MockMvc</span></strong><span class="koboSpan" id="kobo.373.1"> object before </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">each test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
    @BeforeEach
    public void setup() {
        mockMvc = MockMvcBuilders
                .webAppContextSetup(context)
                .apply(springSecurity())
                .build();
    }</span></pre> <p><span class="koboSpan" id="kobo.376.1">This method uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">MockMvcBuilders</span></strong><span class="koboSpan" id="kobo.378.1"> utility to build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">MockMvc</span></strong><span class="koboSpan" id="kobo.380.1"> object with the web application context and Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">Security integration.</span></span></p>
<h3><span class="koboSpan" id="kobo.382.1">Step 3 – writing test cases</span></h3>
<p><span class="koboSpan" id="kobo.383.1">After setting </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.384.1">up our test class, we can start to write our test cases step </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">by step:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.386.1">Write parameterized test cases for adding and getting authors with different roles. </span><span class="koboSpan" id="kobo.386.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">@ParameterizedTest</span></strong><span class="koboSpan" id="kobo.388.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">@MethodSource</span></strong><span class="koboSpan" id="kobo.390.1"> to supply the roles and expected HTTP statuses. </span><span class="koboSpan" id="kobo.390.2">In these tests, you’ll simulate requests with different user roles and assert the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">expected outcomes.</span></span><ul><li><span class="koboSpan" id="kobo.392.1">For adding authors, mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">AuthorService</span></strong><span class="koboSpan" id="kobo.394.1"> response and perform a POST request, asserting the status based on </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the role.</span></span></li><li><span class="koboSpan" id="kobo.396.1">For getting an author by ID, mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">AuthorService</span></strong><span class="koboSpan" id="kobo.398.1"> response and perform a GET request, asserting both the status and the content based on </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the role.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.400.1">Write tests for fetching all authors, updating an author, and deleting an author. </span><span class="koboSpan" id="kobo.400.2">Utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">@Test</span></strong><span class="koboSpan" id="kobo.402.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">@WithMockUser</span></strong><span class="koboSpan" id="kobo.404.1"> to specify the user details inline. </span><span class="koboSpan" id="kobo.404.2">These tests will do </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">the following:</span></span><ul><li><span class="koboSpan" id="kobo.406.1">Mock service </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">layer responses</span></span></li><li><span class="koboSpan" id="kobo.408.1">Perform the relevant HTTP request (GET for all authors, PUT for updating, DELETE </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">for deleting)</span></span></li><li><span class="koboSpan" id="kobo.410.1">Assert the expected outcomes, including status codes and, when applicable, response </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">body content</span></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.412.1">You can see how these steps are implemented in the controller test class. </span><span class="koboSpan" id="kobo.412.2">You can see five test methods in the GitHub repository, which validates the test cases, as we mentioned in this section, at </span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java"><span class="koboSpan" id="kobo.413.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java</span></a><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">We will discuss how we can test exception handling in the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.416.1">Step 4 – handling exceptional cases</span></h3>
<p><span class="koboSpan" id="kobo.417.1">Write a test case for handling a scenario where an author to be deleted is not found. </span><span class="koboSpan" id="kobo.417.2">Mock the</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.418.1"> service to throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">EntityNotFoundException</span></strong><span class="koboSpan" id="kobo.420.1"> when attempting to delete a non-existent author, and assert that the controller correctly responds with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">404</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1"> status:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
    @Test
    @WithMockUser(username="testUser", authorities={"ROLE_ADMIN"})
    void testDeleteAuthorNotFoundWithAdminRole() throws Exception {
        Long id = 1L;
        doThrow(new EntityNotFoundException("Author not found with id: " + id))
                .when(authorService).deleteAuthor(id);
        mockMvc.perform(delete("/authors/" + id))
                .andExpect(status().isNotFound());
    }</span></pre> <p><span class="koboSpan" id="kobo.424.1">In this test method, we are manipulating our </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">authorService.deleteAuthor</span></strong><span class="koboSpan" id="kobo.426.1"> method to throw an exception by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">doThrow()</span></strong><span class="koboSpan" id="kobo.428.1"> method, and we are expecting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">not found</span></strong><span class="koboSpan" id="kobo.430.1"> status as </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">a response.</span></span></p>
<h3><span class="koboSpan" id="kobo.432.1">Step 5 – running the tests</span></h3>
<p><span class="koboSpan" id="kobo.433.1">Run your</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.434.1"> tests to verify that all pass and that your controller behaves as expected across various scenarios and </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">user roles.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">This comprehensive testing approach not only validates the functional aspects of </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">AuthorController</span></strong><span class="koboSpan" id="kobo.438.1"> but also ensures that security constraints are respected, providing confidence in both the application’s behavior and its </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">security posture.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">In this section, we learned how to write controller tests by using Spring MVC controllers with security configurations. </span><span class="koboSpan" id="kobo.440.2">We have written the tests for both assertions, functionality, and security. </span><span class="koboSpan" id="kobo.440.3">By these tests, we are sure our controllers and the security filters are working </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">After completing </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.443.1">our journey in the unit test, we will focus on the integration test in the next section. </span><span class="koboSpan" id="kobo.443.2">We will explore how to test the integration/interaction between various components of our project, including databases, web services, and </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">external APIs.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.445.1">Integration testing – bridging components together</span></h1>
<p><span class="koboSpan" id="kobo.446.1">Once you </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.447.1">understand the concepts of unit testing, especially when dealing with tricky security layers, you can expand your vision to integration testing. </span><span class="koboSpan" id="kobo.447.2">While writing unit tests, you can think of quality checks on bricks that are carried out to ensure that a wall built with those bricks will keep you and your family safe from rain, snow, and everything else. </span><span class="koboSpan" id="kobo.447.3">Integration testing assesses how well different pieces of our application work. </span><span class="koboSpan" id="kobo.447.4">This is where the complete application tests are run at full length: the module interaction, databases, web services, and interaction with all the other external systems required are cross-examined to affirm that it is </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">all smooth.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Why integration tests? </span><span class="koboSpan" id="kobo.449.2">Are unit tests not enough to prove our application is robust? </span><span class="koboSpan" id="kobo.449.3">The quick answer is no. </span><span class="koboSpan" id="kobo.449.4">In unit tests, we are just proving the methods are working as expected, but in real life, the methods are not working on their own. </span><span class="koboSpan" id="kobo.449.5">They interact with other components. </span><span class="koboSpan" id="kobo.449.6">So, integration tests are crucial to see whether any component has been affected by </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">your change.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">So, fasten your seatbelts, because we are now going to take a ride. </span><span class="koboSpan" id="kobo.451.2">Just to be sure, a big integrated system will stand by all the requirements and possible scenarios – this, in fact, leaves your application far better prepared for the real world and the ultimate test of meeting user needs against expectations. </span><span class="koboSpan" id="kobo.451.3">We guide you with clear, practical examples to finally give you concise integration tests, ensuring peace of mind that your high-quality software product can finally </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">be delivered.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.453.1">Setting up the testing environment</span></h2>
<p><span class="koboSpan" id="kobo.454.1">The main</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.455.1"> purpose of integration testing is to identify and solve problems attached to the interaction amid different parts of the application. </span><span class="koboSpan" id="kobo.455.2">This may comprise designed interactions between several service layers, databases, or external APIs, all together aimed at having them purposefully work together in the same way functions are supposed to take place. </span><span class="koboSpan" id="kobo.455.3">Unlike unit testing, integration testing ensures that isolated functionality is correct since it studies how the system behaves. </span><span class="koboSpan" id="kobo.455.4">Overall, the</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.456.1"> application itself should be tested from the interface level part, to ensure that the quality and functionality are full, avoiding interface lack in the defects, performance bottlenecks, and other integration issues left from </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">unit testing.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">In our integration testing strategy for the Author Controller endpoints, we utilize these two </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">primary classes:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">AbstractIntegrationTest</span></strong><span class="koboSpan" id="kobo.461.1">: This class</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.462.1"> serves as the foundation for our integration tests, providing common configuration and setup routines that are shared across multiple test classes. </span><span class="koboSpan" id="kobo.462.2">It is an abstract class that does not directly run tests; instead, it sets up the testing environment. </span><span class="koboSpan" id="kobo.462.3">This includes configuring test containers for databases, initializing WireMock for mocking external services, and setting up Spring’s application context with the necessary profiles and configurations for integration testing. </span><span class="koboSpan" id="kobo.462.4">WireMock is a library that we use for mocking services such as REST </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.463.1">and </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">Simple Object Access Protocol</span></strong><span class="koboSpan" id="kobo.465.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.466.1">SOAP</span></strong><span class="koboSpan" id="kobo.467.1">) services. </span><span class="koboSpan" id="kobo.467.2">By this mocking power, we can isolate our component from external connections and the potential faults of these services. </span><span class="koboSpan" id="kobo.467.3">We can use this abstract class for all integration tests since they will also need the same setup. </span><span class="koboSpan" id="kobo.467.4">The usage of an abstract base class helps us maintain a</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.468.1"> clean and </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.470.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.471.1">DRY</span></strong><span class="koboSpan" id="kobo.472.1">) testing </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">code base.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">AuthorControllerIntegrationTest</span></strong><span class="koboSpan" id="kobo.475.1">: Extending from </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">AbstractIntegrationTest</span></strong><span class="koboSpan" id="kobo.477.1">, this</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.478.1"> class focuses specifically on testing the Author Controller endpoints. </span><span class="koboSpan" id="kobo.478.2">It inherits the common testing environment setup from </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">AbstractIntegrationTest</span></strong><span class="koboSpan" id="kobo.480.1"> and adds tests that cover the functionality of the Author Controller, such as creating, reading, updating, and deleting authors. </span><span class="koboSpan" id="kobo.480.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">AuthorControllerIntegrationTest</span></strong><span class="koboSpan" id="kobo.482.1"> class utilizes Spring’s MockMvc to simulate HTTP requests and assert the responses, ensuring that the Author Controller behaves as expected when integrated with other application components such as the security layer and </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the database.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.484.1">By structuring our integration tests this way, we achieve a layered testing approach that allows us to isolate the testing of specific components (such as the Author Controller) while still leveraging a </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.485.1">common setup for aspects shared across tests. </span><span class="koboSpan" id="kobo.485.2">This organization makes our tests more efficient and easier to maintain and ensures that we comprehensively test the interactions and integrations crucial for the application’s overall performance </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">and reliability.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.487.1">Configuring application properties for integration testing</span></h2>
<p><span class="koboSpan" id="kobo.488.1">In integration tests, our </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.489.1">application will need to run as it would in a real environment. </span><span class="koboSpan" id="kobo.489.2">So, it is crucial to set up the application properties file. </span><span class="koboSpan" id="kobo.489.3">However, we also need to isolate the integration test environment from other test environments. </span><span class="koboSpan" id="kobo.489.4">That’s why we are initiating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">application-integration-test.properties</span></strong><span class="koboSpan" id="kobo.491.1">. </span><span class="koboSpan" id="kobo.491.2">By this segregation, we ensure that the configuration in the integration test environment is just for that environment and it won’t affect the other test and </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">development environments.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">We are adding the same properties as we are using in the current source code. </span><span class="koboSpan" id="kobo.493.2">This is because the following parameters will be needed by our application when it is running in the integration </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">test profile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
spring.security.oauth2.client.registration.keycloak.client-id=bookstore-client
spring.security.oauth2.client.registration.keycloak.client-secret=secret-client
spring.security.oauth2.client.registration.keycloak.client-name=Keycloak
spring.security.oauth2.client.registration.keycloak.provider=keycloak
spring.security.oauth2.client.registration.keycloak.scope=openid,profile,email
spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.keycloak.redirect-uri={baseUrl}/login/oauth2/code/keycloak
spring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm</span></pre> <p><span class="koboSpan" id="kobo.496.1">By configuring </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.497.1">these properties, we create a controlled, predictable, and isolated environment that allows us to test our application’s integration points thoroughly and accurately. </span><span class="koboSpan" id="kobo.497.2">This setup is crucial for evaluating the application’s behavior in a simulated production environment, ensuring that all components work </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">harmoniously together.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">Next, we’ll dive into the practical application of these configurations, where we set the stage for robust, </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">environment-true testing.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.501.1">Initializing the database with Testcontainers</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.503.1"> is a</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.504.1"> Java</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.505.1"> library designed for JUnit and systems testing. </span><span class="koboSpan" id="kobo.505.2">It usually provides a lightweight, throw-away instance manner on the run of shared </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.506.1">databases and Selenium web browsers or anything that can run inside a Docker container. </span><span class="koboSpan" id="kobo.506.2">Under the hood, </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.508.1"> uses Docker to help with the full setup and, especially, tear-down of actual database instances, which are isolated, ephemeral, and fully in one’s control. </span><span class="koboSpan" id="kobo.508.2">With the help of tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.510.1">, one can accurately test the database interaction and persistence necessary for business needs without much overhead, the complexity of database installations, or setups of some sort of shared </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">test instances.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">We will now configure PostgreSQL and MongoDB containers by initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.514.1"> for PostgreSQL and MongoDB databases in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">AbstractIntegrationTest</span></strong><span class="koboSpan" id="kobo.516.1"> class. </span><span class="koboSpan" id="kobo.516.2">Here’s how </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">it’s done:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.518.1">PostgreSQL container</span></strong><span class="koboSpan" id="kobo.519.1">: The class </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.520.1">defines a static method to initialize a PostgreSQL container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.522.1"> library. </span><span class="koboSpan" id="kobo.522.2">This method specifies the Docker image to use (</span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">postgres:latest</span></strong><span class="koboSpan" id="kobo.524.1">), as well as database-specific configurations such as the database name, username, and password. </span><span class="koboSpan" id="kobo.524.2">Once initialized, the container is started, and the </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">Java Database Connectivity</span></strong><span class="koboSpan" id="kobo.526.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.527.1">JDBC</span></strong><span class="koboSpan" id="kobo.528.1">) URL, username, and password are dynamically </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.529.1">injected into the Spring application context. </span><span class="koboSpan" id="kobo.529.2">This allows the integration tests to interact with a real PostgreSQL database instance that’s identical to what would be used </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">in production.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.531.1">MongoDB container</span></strong><span class="koboSpan" id="kobo.532.1">: Similarly, a </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.533.1">MongoDB container is initialized using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.535.1"> library by specifying the Docker image (</span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">mongo:4.4.6</span></strong><span class="koboSpan" id="kobo.537.1">). </span><span class="koboSpan" id="kobo.537.2">Upon starting the MongoDB container, the connection URI is injected into the Spring application context, enabling tests to communicate with a real </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">MongoDB instance.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.539.1">To initialize the</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.540.1"> database, follow</span><a id="_idIndexMarker463"/> <span class="No-Break"><span class="koboSpan" id="kobo.541.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.542.1">First off, we will define the required parameters such as database image versions and the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">database name:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.544.1">
   private static final String POSTGRES_IMAGE = "postgres:latest";
    private static final String MONGO_IMAGE = "mongo:4.4.6";
    private static final String DATABASE_NAME = "bookstore";
    private static final String DATABASE_USER = "postgres";
    private static final String DATABASE_PASSWORD = "yourpassword";
    private static final int WIREMOCK_PORT = 8180;
    private static WireMockServer wireMockServer;</span></pre></li> <li><span class="koboSpan" id="kobo.545.1">We will use these parameters when we are initiating our test </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">database containers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
    @Container
    static final PostgreSQLContainer&lt;?&gt; postgresqlContainer = initPostgresqlContainer();
    @Container
    static final MongoDBContainer mongoDBContainer = initMongoDBContainer();
    private static PostgreSQLContainer&lt;?&gt; initPostgresqlContainer() {
        PostgreSQLContainer&lt;?&gt; container = new PostgreSQLContainer&lt;&gt;(POSTGRES_IMAGE)
                .withDatabaseName(DATABASE_NAME)
                .withUsername(DATABASE_USER)
                .withPassword(DATABASE_PASSWORD);
        container.start();
        return container;
    }
    private static MongoDBContainer initMongoDBContainer() {
        MongoDBContainer container = new MongoDBContainer(DockerImageName.parse(MONGO_IMAGE));
        container.start();
        return container;
    }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.548.1">In this code block, first, we define the container and call the container initialize function in it. </span><span class="koboSpan" id="kobo.548.2">The container initialize function consumes the parameters defined in the previous code block in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.549.1">Step 1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.551.1">We will</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.552.1"> need some </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.553.1">dynamic properties, which will be defined after containers are triggered. </span><span class="koboSpan" id="kobo.553.2">By using the following code, we can let the application know which data source URL will be used for connecting to </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">the database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
    @DynamicPropertySource
    static void properties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgresqlContainer::getJdbcUrl);
        registry.add("spring.datasource.username", postgresqlContainer::getUsername);
        registry.add("spring.datasource.password", postgresqlContainer::getPassword);
        registry.add("spring.data.mongodb.uri", mongoDBContainer::getReplicaSetUrl);
    }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.556.1">Each container is automatically run up, prepared, and torn down before and after tests, ensuring that every test suite runs against a clean, isolated database environment. </span><span class="koboSpan" id="kobo.556.2">This automated process elevates the reliability and repeatability of integration tests and simplifies the setup and troubleshooting of </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">database interactions.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.558.1">With the databases ready and set up in containerized sandboxes, the next section is going to show us how to do just that: simulate responses from our dependencies on external APIs so that we can burrow deep into our code base to offer a full, no-holds-barred </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">testing strategy.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.560.1">Mocking external services with WireMock</span></h2>
<p><span class="koboSpan" id="kobo.561.1">In the </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.562.1">context of integration testing, the ability to simulate external services is important because you cannot run all </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.563.1">external devices in your integration test environment. </span><span class="koboSpan" id="kobo.563.2">Even if you can run them, the purpose of integration tests is to test the codes in the component. </span><span class="koboSpan" id="kobo.563.3">The external system’s problems are unrelated to the quality of the application’s code. </span><span class="koboSpan" id="kobo.563.4">WireMock offers a powerful solution for this challenge. </span><span class="koboSpan" id="kobo.563.5">By creating programmable HTTP servers that mimic the behavior of these external services, WireMock allows developers to produce reliable, consistent, and fast tests. </span><span class="koboSpan" id="kobo.563.6">Mocking external services ensures that tests are not only isolated from factors outside the application’s control but also that they can be run in any environment without the need for actual </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">service connectivity.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">To effectively simulate the interaction with an OpenID Connect provider, WireMock can be configured to respond to authentication and token requests with predefined responses. </span><span class="koboSpan" id="kobo.565.2">We need this setup to test secured endpoints without needing to interact with the real authentication service. </span><span class="koboSpan" id="kobo.565.3">Here’s how to </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">achieve this:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.567.1">Initialize the WireMock server</span></strong><span class="koboSpan" id="kobo.568.1">: Within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">AbstractIntegrationTest</span></strong><span class="koboSpan" id="kobo.570.1"> class, set up a WireMock server to run on a specific port. </span><span class="koboSpan" id="kobo.570.2">This server acts as your mock OpenID </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">Connect provider.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.572.1">Stubbing the OpenID configuration</span></strong><span class="koboSpan" id="kobo.573.1">: Configure WireMock to serve responses for the OpenID Connect discovery document and other related endpoints. </span><span class="koboSpan" id="kobo.573.2">We need to stub the endpoint to return the provider metadata, which includes URLs for the authorization, token, user information, and </span><strong class="bold"><span class="koboSpan" id="kobo.574.1">JSON Web Key Set</span></strong><span class="koboSpan" id="kobo.575.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.576.1">JWKS</span></strong><span class="koboSpan" id="kobo.577.1">) URIs. </span><span class="koboSpan" id="kobo.577.2">This</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.578.1"> ensures that when your application tries to discover the OpenID Connect provider’s configuration, it receives a consistent and controlled response </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">from WireMock.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.580.1">Mocking token and authorization responses</span></strong><span class="koboSpan" id="kobo.581.1">: Further configure WireMock to respond to token and authorization requests with mock responses. </span><span class="koboSpan" id="kobo.581.2">These responses should mimic the structure of real responses from an OpenID Connect provider, including access tokens, ID tokens, and refresh tokens </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">as necessary.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.583.1">Please see the related abstract class in the GitHub repository to see how we need to mock the key-cloak server at </span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java"><span class="koboSpan" id="kobo.584.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java</span></a><span class="koboSpan" id="kobo.585.1">. </span><span class="koboSpan" id="kobo.585.2">Whenever our application needs to communicate with key-cloak, our mock server respond to our application as </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">we expected.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">By mocking</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.588.1"> the OpenID Connect </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.589.1">provider in this manner, you can test your application’s authentication and authorization flow accurately and consistently, ensuring that your security mechanisms work as intended without relying on </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">external systems.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Having established a controlled environment for both database interactions and external service dependencies, we’re now well prepared to start writing our integration tests in the </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">next section.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.593.1">Writing integration tests for Author Controller</span></h2>
<p><span class="koboSpan" id="kobo.594.1">Before </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.595.1">diving into the tests</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.596.1"> themselves, ensuring a clean page for each test run is crucial. </span><span class="koboSpan" id="kobo.596.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">@BeforeEach</span></strong><span class="koboSpan" id="kobo.598.1"> method plays a vital role in this process, allowing us to reset our database to a known state before </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">every test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.600.1">
@BeforeEach
void clearData() { authorRepository.deleteAll(); }</span></pre> <p><span class="koboSpan" id="kobo.601.1">By invoking methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">authorRepository.deleteAll()</span></strong><span class="koboSpan" id="kobo.603.1">, we can clear all data, preventing cross-test contamination and ensuring each test </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">operates independently.</span></span></p>
<h3><span class="koboSpan" id="kobo.605.1">Securing tests with @WithMockUser</span></h3>
<p><span class="koboSpan" id="kobo.606.1">Since our</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.607.1"> application has a security layer, we need to write our tests by considering this layer, even if we have a mocked third-party security dependency. </span><span class="koboSpan" id="kobo.607.2">Our application still checks the roles of the requests in the security filter. </span><span class="koboSpan" id="kobo.607.3">We have a very helpful annotation for this: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">@WithMockUser</span></strong><span class="koboSpan" id="kobo.609.1"> annotation </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.610.1">allows us to simulate requests from authenticated users with specific roles, ensuring that our tests accurately reflect the application’s security constraints. </span><span class="koboSpan" id="kobo.610.2">In this way, we can confirm our security configuration is </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">working effectively.</span></span></p>
<h3><span class="koboSpan" id="kobo.612.1">Testing the endpoints</span></h3>
<p><span class="koboSpan" id="kobo.613.1">Now, we are ready </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.614.1">to write our tests for each endpoint. </span><span class="koboSpan" id="kobo.614.2">We have up-and-running test databases and mocked third-party dependencies. </span><span class="koboSpan" id="kobo.614.3">Now, we just need to send requests and assert the responses to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">/authors</span></strong><span class="koboSpan" id="kobo.616.1"> endpoints. </span><span class="koboSpan" id="kobo.616.2">This part is very similar to the controller unit tests but the difference is we will not mock the service – we will use the service itself. </span><span class="koboSpan" id="kobo.616.3">The tests will all run end to end. </span><span class="koboSpan" id="kobo.616.4">So, we will ensure our application is running as expected with its </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">all components.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">In the following code block, we will write a test case for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Get /</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">authors/{authorId}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.621.1"> endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
@Test
@WithMockUser(username="testUser", authorities={"ROLE_ADMIN"})
void testGetAuthor() throws Exception {
    Author author = Author.builder().name("Author Name").build();
    authorRepository.save(author);
    mockMvc.perform(get("/authors/" + author.getId()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.name", is(author.getName())));
}</span></pre> <p><span class="koboSpan" id="kobo.623.1">Here, we make a GET request to our application with a mock user with an admin role, and we prepare the database by inserting a sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">Author</span></strong><span class="koboSpan" id="kobo.625.1"> object. </span><span class="koboSpan" id="kobo.625.2">We also expect to get a valid response from the application. </span><span class="koboSpan" id="kobo.625.3">As you can see, we didn’t mock the repository class or service </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.626.1">class, therefore, when the application starts working, and we initiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">GET</span></strong><span class="koboSpan" id="kobo.628.1"> request, all related classes and methods are really working like a </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">real application.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">For the rest of the test cases, you can check out our GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">at </span></span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java"><span class="No-Break"><span class="koboSpan" id="kobo.632.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.633.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.634.1">When we run our test class, it will test all the endpoints end to end. </span><span class="koboSpan" id="kobo.634.2">Integration testing bridges the gap between unit testing and end-to-end testing, focusing on the interactions between different parts of the application. </span><span class="koboSpan" id="kobo.634.3">It verifies that the application components work together as expected, identifying issues that might not be visible when testing components in isolation. </span><span class="koboSpan" id="kobo.634.4">Through the use of tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.636.1"> and WireMock, we’ve seen how to simulate real-world environments and dependencies, allowing for comprehensive and </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">reliable testing.</span></span></p>
<p><span class="koboSpan" id="kobo.638.1">In conclusion, we can see how important integration testing is in the software development cycle. </span><span class="koboSpan" id="kobo.638.2">It offers a comprehensive test of our application’s overall functionality. </span><span class="koboSpan" id="kobo.638.3">I always imagine these integration tests are like local development tests. </span><span class="koboSpan" id="kobo.638.4">When you change a code base, you can rely on integration tests to be sure your change doesn’t break any other flow. </span><span class="koboSpan" id="kobo.638.5">In the next section, we will deal with the asynchronous environment: </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">reactive components.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.640.1">Testing reactive components</span></h1>
<p><span class="koboSpan" id="kobo.641.1">In this section, we’ll delve into</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.642.1"> testing reactive components, focusing on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">UserController</span></strong><span class="koboSpan" id="kobo.644.1"> endpoints in our sample reactive Spring Boot application. </span><span class="koboSpan" id="kobo.644.2">Testing reactive components is slightly different from traditional applications because reactive programming offers a non-blocking, event-driven approach to handling data streams and the propagation of change. </span><span class="koboSpan" id="kobo.644.3">We’ll use Spring WebFlux along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">WebTestClient</span></strong><span class="koboSpan" id="kobo.646.1"> for testing reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">HTTP requests.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.648.1">Setting up the testing environment</span></h2>
<p><span class="koboSpan" id="kobo.649.1">As </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.650.1">we learned in </span><a href="B18400_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.651.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.652.1">, reactive programming in Spring, facilitated by Spring WebFlux, introduces an approach to a non-blocking, event-driven model that efficiently handles asynchronous data streams. </span><span class="koboSpan" id="kobo.652.2">That’s why we need a slightly different strategy to test these reactive components to ensure that the asynchronous and non-blocking behavior is accurately accounted for. </span><span class="koboSpan" id="kobo.652.3">The reactive testing environment must be capable of dealing with data flows and sequences over time, making it crucial to understand how to set up and utilize the right </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">tools effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">WebTestClient</span></strong><span class="koboSpan" id="kobo.656.1"> to test reactive components instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">MockMVC</span></strong><span class="koboSpan" id="kobo.658.1">, as we used in non-reactive application tests. </span><span class="koboSpan" id="kobo.658.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">UserControllerTest</span></strong><span class="koboSpan" id="kobo.660.1"> class, configured with </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">@WebFluxTest(controllers = UserController.class)</span></strong><span class="koboSpan" id="kobo.662.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">WebTestClient</span></strong><span class="koboSpan" id="kobo.664.1"> is autowired to enable direct interaction with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">UserController</span></strong><span class="koboSpan" id="kobo.666.1"> endpoints. </span><span class="koboSpan" id="kobo.666.2">This annotation helps us to isolate our controller from the full configuration. </span><span class="koboSpan" id="kobo.666.3">It ensures that tests are lightweight and targeted, significantly speeding up the </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">testing process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.668.1">
@WebFluxTest(controllers = UserController.class,
        excludeAutoConfiguration = {ReactiveSecurityAutoConfiguration.class, ReactiveOAuth2ClientAutoConfiguration.class})
class UserControllerTest {
    @Autowired
    private WebTestClient webTestClient;
}</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">@WebFluxTest</span></strong><span class="koboSpan" id="kobo.670.1"> also sets up </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">WebTestClient</span></strong><span class="koboSpan" id="kobo.672.1"> for our test environment and it becomes ready to use for sending simulated HTTP requests and asserting </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">the responses.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">WebTestClient</span></strong><span class="koboSpan" id="kobo.675.1"> helps to mock the behavior of requests and responses as they would occur in a live, reactive web environment. </span><span class="koboSpan" id="kobo.675.2">It also shows us again how Spring seamlessly supports the testing of reactive endpoints. </span><span class="koboSpan" id="kobo.675.3">After this theoretical information, we will delve into mocking the components in the </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">next section.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.677.1">Preparing mock components</span></h2>
<p><span class="koboSpan" id="kobo.678.1">Mocking </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.679.1">plays a pivotal role in preventing actual database operations during tests, which is crucial for several reasons. </span><span class="koboSpan" id="kobo.679.2">Firstly, it ensures test isolation, allowing each test to run independently without the side effects of shared data. </span><span class="koboSpan" id="kobo.679.3">You already knew this from the previous chapter. </span><span class="koboSpan" id="kobo.679.4">So, we are directly diving into the </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
@MockBean
private UserRepository userRepository;
private User testUser;
@MockBean
private SecurityWebFilterChain securityWebFilterChain;
@BeforeEach
void setUp() {
    testUser = new User(1L, "Test User", "test@example.com");
}</span></pre> <p><span class="koboSpan" id="kobo.682.1">With our dependencies mocked and test data freshly initialized before each test, we’re well equipped to dive into the core of our testing strategy, examining how each endpoint in </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">UserController</span></strong><span class="koboSpan" id="kobo.684.1"> is tested. </span><span class="koboSpan" id="kobo.684.2">Next, we’ll start writing test cases, where we’ll break down the testing process for each operation, ensuring </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">UserController</span></strong><span class="koboSpan" id="kobo.686.1"> behaves as expected under </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">various conditions.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.688.1">Writing test cases</span></h2>
<p><span class="koboSpan" id="kobo.689.1">Now, we</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.690.1"> are ready to write our tests for each method. </span><span class="koboSpan" id="kobo.690.2">We have mocked our dependencies; we just need to write unit tests and see whether they return the expected results. </span><span class="koboSpan" id="kobo.690.3">The only difference between testing non-reactive components and this is that we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">webTestClient</span></strong><span class="koboSpan" id="kobo.692.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">mockMVC</span></strong><span class="koboSpan" id="kobo.694.1">. </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">Let’s start:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.696.1">
@Test
void getAllUsersTest() {
    when(userRepository.findAll()).thenReturn(Flux.just(testUser));
    webTestClient.get().uri("/users")
            .exchange()
            .expectStatus().isOk()
            .expectBodyList(User.class).hasSize(1);
}</span></pre> <p><span class="koboSpan" id="kobo.697.1">In</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.698.1"> this code block, we have written a unit test to get all user endpoints. </span><span class="koboSpan" id="kobo.698.2">First, we have manipulated the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">userRepositry.findAll()</span></strong><span class="koboSpan" id="kobo.700.1"> method to return a Flux </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">testUser</span></strong><span class="koboSpan" id="kobo.702.1"> object, and we expect a </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">successful response.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">For the test methods for other endpoints, please see the GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">at </span></span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java"><span class="No-Break"><span class="koboSpan" id="kobo.706.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.707.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">A look back is in order as we end our hands-on to test reactive components in our Spring Boot applications. </span><span class="koboSpan" id="kobo.708.2">A transition to the programming of reactivity obliges the developer to change their way of crafting applications and communicating in essence – chiefly focusing on non-blocking, asynchronous, and scalable interaction under pressure. </span><span class="koboSpan" id="kobo.708.3">However, great responsibility follows great power, and the testing of code stands at the pinnacle of that principle. </span><span class="koboSpan" id="kobo.708.4">The principal test challenges that testing these very reactive components brings in are the guaranteed handling of data streams, assured non-blocking nature, and dealing </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">with backpressure.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">With a myriad of approaches discussed in this section for testing a target, right from setting up the testing environment via </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">@WebFluxTest</span></strong><span class="koboSpan" id="kobo.712.1"> to specifying dependencies and testing asynchronous results with </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">WebTestClient</span></strong><span class="koboSpan" id="kobo.714.1">, one is set up with the tools required to achieve quality, scalability, and maintainability in your reactive Spring Boot application. </span><span class="koboSpan" id="kobo.714.2">These then are ensuring strategies toward the guarantee that no matter what conditions are realized at runtime, the application behaves well and delivers the desired functionality and the </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">desired performance.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">The third good</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.717.1"> practice in testing is “reactive.” </span><span class="koboSpan" id="kobo.717.2">When applications become more complex and bigger in scale, the ability to effectively test these reactive components becomes a cornerstone of a successful development life cycle. </span><span class="koboSpan" id="kobo.717.3">In another light, developers who practice these testing methodologies can catch issues before they even rise to the level of annoyance and find a way to instill cultures of quality </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">and resilience.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">In other words, the way to test the reactive part is an accent of the dynamically changing web development landscape, which is always running into innovation in best development and best testing practices. </span><span class="koboSpan" id="kobo.719.2">With these insights and techniques from this exploration, go forth into future builds of more robust, responsible, and </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">user-friendly applications.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.721.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.722.1">As we wrap up this comprehensive exploration into advanced testing strategies for both non-reactive and reactive Spring Boot applications, it’s clear that the journey has been both enlightening and empowering. </span><span class="koboSpan" id="kobo.722.2">We learned how testing is important for the development life cycle and how it is easy with Springboot capabilities. </span><span class="koboSpan" id="kobo.722.3">With practical examples and hands-on guidance, this chapter has equipped you with essential skills and insights that are critical in today’s fast-paced software development landscape. </span><span class="koboSpan" id="kobo.722.4">Here’s a summary of what </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">we’ve covered:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.724.1">Foundational principles of TDD</span></strong><span class="koboSpan" id="kobo.725.1">: We learned the foundational principles of TDD and its impact on software quality </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">and reliability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.727.1">Unit testing controllers</span></strong><span class="koboSpan" id="kobo.728.1">: We explored techniques for unit testing controllers with a security layer, ensuring that our applications are not only functional but </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">also secure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.730.1">Importance of integration testing</span></strong><span class="koboSpan" id="kobo.731.1">: We learned the importance of integration testing in validating the interaction between different parts of our applications, ensuring they work </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">together seamlessly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.733.1">Testing reactive components</span></strong><span class="koboSpan" id="kobo.734.1">: We explored strategies for testing reactive components, addressing the unique challenges presented by the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">programming paradigm.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.736.1">These skills will make your applications tested, more reliable, scalable, and maintainable. </span><span class="koboSpan" id="kobo.736.2">Mastering these testing techniques in Spring Boot sets you apart as </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">a developer.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">Looking ahead, the journey through software development continues to evolve, bringing new challenges and opportunities. </span><span class="koboSpan" id="kobo.738.2">In the next chapter, we’ll dive into the world of containerization and orchestration. </span><span class="koboSpan" id="kobo.738.3">This upcoming chapter promises to unveil how Spring Boot applications can be made container ready, and how they can be orchestrated using Kubernetes for enhanced scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">and manageability.</span></span></p>
</div>


<div class="Content" id="_idContainer050">
<h1 id="_idParaDest-150" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1.1">Part 4: Deployment, Scalability, and Productivity</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will shift our focus towards deploying and scaling applications effectively, alongside boosting productivity. </span><a href="B18400_07.xhtml#_idTextAnchor213"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.4.1"> explores the latest Spring Boot 3.0 features, particularly those that enhance containerization and orchestration for smoother deployment processes. </span><a href="B18400_08.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.5.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.6.1"> dives into building event-driven systems with Kafka, which are crucial for managing high-throughput data with scalability in mind. </span><span class="koboSpan" id="kobo.6.2">Lastly, </span><a href="B18400_09.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.8.1"> covers strategies to enhance productivity and simplify development, ensuring you can maintain a rapid and efficient workflow as your projects grow. </span><span class="koboSpan" id="kobo.8.2">This section is key to mastering the operational side of software development, preparing you to handle large-scale deployments </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">with ease.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">following chapters:</span></span></p>
<ul>
<li><a href="B18400_07.xhtml#_idTextAnchor213"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Spring Boot 3.0 Features for Containerization and Orchestration</span></em></li>
<li><a href="B18400_08.xhtml#_idTextAnchor233"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Exploring Event-Driven Systems with Kafka</span></em></li>
<li><a href="B18400_09.xhtml#_idTextAnchor249"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.19.1">, </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Enhancing Productivity and Development Simplification</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer051">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer052">
</div>
</div>
</body></html>