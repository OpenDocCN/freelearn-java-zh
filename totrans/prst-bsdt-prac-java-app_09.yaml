- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persistence Practices – Exploring Polyglot Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development has become more complex, requiring way more integration,
    and we need to innovate simultaneously to make our lives easier. One good option
    is to take advantage of several databases with polyglot persistence.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about persistence solutions, there are around 400, with different
    types, structures, and particular behavior that make sense in specific cases.
    The philosophy of polyglot persistence is to use the tool to find the right solution.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce the principle of polyglot persistence and how to
    use it with Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The trade-offs of polyglot persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding **Domain-Driven Design** (**DDD**) and Jakarta
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for the chapter is available at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09).
  prefs: []
  type: TYPE_NORMAL
- en: The trade-offs of polyglot persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polyglot persistence is an approach to data storage in which multiple types
    of databases are used together to address different needs within an application.
    The term **polyglot** refers to the use of various languages or tools, and in
    this context, it refers to the use of multiple types of databases.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional monolithic applications, a single database is typically used
    to store all data types. However, this approach can become less effective as applications
    become more complex. Polyglot persistence, however, allows developers to choose
    the best database for each use case based on factors such as scalability, data
    structure, and query requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a social media platform might use a document database such as MongoDB
    to store user profiles and activity feeds, a graph database such as Neo4j to analyze
    social connections, and a relational database such as MySQL to manage transactions
    and payments.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging multiple databases, polyglot persistence can help improve an application’s
    performance, scalability, and flexibility. However, it also comes with additional
    complexity in managing data consistency, migrations, and backups across multiple
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of polyglots is always good and provides several opportunities for
    an application. The core idea is sound: taking advantage of a database in the
    perfect scenario is terrific. But, even with polyglot persistence, there are trade-offs,
    as with any software architecture decision.'
  prefs: []
  type: TYPE_NORMAL
- en: More databases also mean greater cost and infrastructure knowledge to handle
    specific persistence solutions. Please be aware of this.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, more databases mean more dependencies in the application, which might
    *add to the jar-hell headache*. The microservices approach will help you in this
    situation, *where each database in your environment has its own interface*; it
    also helps to isolate the technology from the business.
  prefs: []
  type: TYPE_NORMAL
- en: From a code design perspective, there is the Ports and Adapters pattern, or
    the Hexagonal model, where you can isolate the core logic of an application from
    the persistence layer. However, as mentioned, more layers mean more code overall,
    which means concerns about maintainability and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Starting simply with three layers, as in the **Model-View-Controller** (**MVC**)
    architectural pattern, and isolating them is a good start, such as beginning with
    a monolith instead of microservices. When the need arises, go for it and refactor
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we only need some of these layers for our applications; starting
    with enough architecture is an excellent way to manage risk in your architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the abstraction from/to the business layer and avoiding coupling
    it with the persistence layer as much as possible is crucial to an evolutionary
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Common sense and pragmatism are the best formulas to define the best pattern
    for each scenario. As advice, think of software as a long-term project; we don’t
    need to design a sophisticated Netflix-style architecture on the first day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the best practices, enjoying, taking advantage of, and exploring databases
    to take advantage of your system is possible. In the following figure, based on
    James Serra’s article *What is Polyglot Persistence?* ([https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/](https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/)),
    you can get more context for which database is best suited to or a good candidate
    for a given scenario. It describes what type of database is recommended to address
    recurrent and key requirements of the listed use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Use cases and database types](img/Figure_9.01_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Use cases and database types
  prefs: []
  type: TYPE_NORMAL
- en: Those are some possibilities of database uses based on the type; when we talk
    about NoSQL, remember that in some classes, there is particular behavior that
    makes sense and is worth using.
  prefs: []
  type: TYPE_NORMAL
- en: For long-term applications, migration is possible. The isolation can help you
    in the polyglot journey. The following section will introduce **DDD**, its impacts
    on the persistence layer, and how Jakarta can help us on this journey.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DDD and Jakarta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD is an approach to software development that focuses on understanding the
    problem domain and modeling it in code. DDD is based on the idea that the problem
    domain should be the primary focus of development and that the software should
    be designed to reflect the underlying domain concepts and processes.
  prefs: []
  type: TYPE_NORMAL
- en: DDD distinguishes between strategic and tactical design. Strategic design refers
    to the overall architecture and organization of the software, while tactical design
    refers to the detailed design of individual components and modules.
  prefs: []
  type: TYPE_NORMAL
- en: In strategic design, DDD emphasizes the importance of defining a clear and consistent
    domain model that represents the business concepts and processes in the problem
    domain. This model should be independent of any particular technology or implementation
    and should be based on a deep understanding of the domain. Strategic design also
    involves defining bounded contexts and specific domain areas with well-defined
    boundaries modeled separately from other parts of the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Tactical design, on the other hand, focuses on the details of how individual
    components and modules are designed and implemented. DDD uses patterns and techniques
    such as aggregates, entities, value objects, and repositories to model and manipulate
    the domain objects in the tactical design.
  prefs: []
  type: TYPE_NORMAL
- en: 'DDD can significantly impact the different layers of a software application,
    including the presentation layer, application layer, domain layer, and persistence
    layer. Here’s a brief overview of how DDD can apply to and impact each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The presentation layer**: DDD can impact the presentation layer by providing
    a clear and consistent domain model that can be used to guide the design of user
    interfaces and user interactions. The presentation layer should reflect the domain
    model. It should provide a user-friendly interface that enables users to interact
    with the application in a way that makes sense from a domain perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application layer**: DDD can impact the application layer by providing
    a clear and consistent set of services and operations that reflects the business
    processes and workflows in the domain. The application layer should be designed
    to support the domain model and should provide a layer of abstraction, which enables
    the domain layer to focus on business logic rather than implementation details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The domain layer**: DDD has the most significant impact on the domain layer,
    which is the heart of the application. In the domain layer, DDD emphasizes the
    importance of modeling the domain using a rich and expressive language that reflects
    the business concepts and processes. The domain layer should be designed to be
    independent of any specific technology or implementation and focused on encapsulating
    business logic and domain knowledge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The persistence layer**: DDD can also impact the persistence layer by providing
    a clear and consistent way of mapping domain objects to the database. DDD emphasizes
    repositories, which provide a layer of abstraction between the domain layer and
    the persistence layer. Repositories enable the domain layer to focus on business
    logic rather than database access and provide a way to ensure that domain objects
    are persisted and retrieved consistently and reliably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, DDD can significantly impact the design and architecture of a software
    application and can help ensure that the application is focused on the problem
    domain rather than implementation details. DDD can help create more maintainable
    and scalable software that is adaptable to changing business requirements by providing
    a clear and consistent domain model and a set of design patterns and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern is a design pattern that provides a layer of abstraction
    between the domain layer and the persistence layer. The repository pattern encapsulates
    the logic for accessing and persisting domain objects. It provides a way to ensure
    that domain objects are stored and retrieved consistently and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Using repositories, the domain layer can be designed to be independent of the
    persistence layer. It can be focused on modeling business processes and workflows
    using rich and expressive language. The repository pattern can significantly impact
    the persistence layer by enabling the domain layer to focus on business logic
    and domain knowledge rather than implementation details such as database access
    and querying.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern is typically implemented as an interface in the domain
    layer, with a concrete implementation in the persistence layer. The repository
    interface defines a set of methods for storing, retrieving, and querying domain
    objects. The concrete implementation provides the actual implementation of these
    methods using the persistence technology of choice (such as a relational or NoSQL
    database).
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of the repository pattern is that it enables the domain
    layer to be decoupled from the persistence layer, making the application more
    modular and easier to maintain. By separating concerns and encapsulating logic,
    the repository pattern can ensure that the application is more flexible and adaptable
    to changing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern is often compared to the **Data Access Object** (**DAO**)
    pattern, another design pattern for accessing and persisting data. The main difference
    between a repository and a DAO is a repository is designed to encapsulate the
    logic for accessing and persisting domain objects. In contrast, a DAO is designed
    to encapsulate general logic for accessing and persisting data. The following
    figure shows the sequence starting from the controller to the database and returning
    to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Sequence from the controller to the database](img/Figure_9.02_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Sequence from the controller to the database
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a DAO is typically focused on low-level details, such as database
    connections, transactions, and SQL statements. In contrast, a repository focuses
    on the domain model’s higher-level concerns. While both patterns can be used for
    persistence, the repository pattern is often considered more aligned with the
    principles of DDD, as it provides a way to ensure that the persistence layer is
    designed to support the domain model and business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Where does the data come from? We don’t need to know the source of the database,
    whether it comes from SQL, NoSQL, or a web service. The client does need to know.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows this idea, where we have the business layer injecting
    a persistence layer, and it does matter where the data source comes from; it might
    be coming from all of the sources simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – A DDD repository representation](img/Figure_9.03_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – A DDD repository representation
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see some code to explore the capabilities of Jakarta Data in the first
    version that released the repository feature. As with MicroStream, we’ll start
    with Java SE and then move the application to Jakarta EE. We’ll create two CRUD
    operations using both the `Developer` and `Airplane` entities, where the second
    will handle simple pagination code.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing an application with multiple database systems is one of the hardest
    things to do in the software world. Fortunately, there is a specification that
    makes it easier to implement polyglot persistence in Java. It is a persistence-agnostic
    API that connects to different types of databases and storage sources seamlessly.
    The API offered by Jakarta Data enables convenient access to data technologies,
    making it possible for Java developers to divide their persistence and model concerns
    into distinct features. For instance, a repository interface can be created with
    a query method that the framework will implement.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring agnostic design patterns is one of the goals of Jakarta Data; the
    first feature of this specification is the DDD repository pattern. The objective
    of the repository is to facilitate polyglot persistence without impacting the
    business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with dependencies, from now on, we’ll add only the API; then, we’ll
    start to explain the implementations. So, we’ll include the Jakarta Data dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create both the `Developer` and `Airline` entities. In the Jakarta
    Data API, we must define the entity and its IDs using `@Entity` and `@Id`, respectively.
    Hey, how about adding other fields? It varies with the implementation; for example,
    in JPA, this is enough, whereas in Jakarta NoSQL, we need to identify the other
    fields with the `@``Column` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have the entities; the next step is the persistence layer with a repository.
    Once we have two different entities, we’ll create two separate repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'This interface provides several methods the user doesn’t need to implement;
    the vendor will implement them. The first one relates to the `Developer` entity
    and uses the most basic repository: `CrudDataRepository`. Furthermore, there is
    the method that uses querying, where you can, using the convention, create queries
    that you don’t need to implement; the vendor will implement them.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DeveloperRepository` is the Developer repository, an interface that extends
    `CrudDataRepository`. Now we will go through several methods; furthermore, we
    will create a query to find by language using the `findByLanguage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The next step is the `Airplane` repository, so we have our `Hangar`, but wait!?
    Should it be `AirplaneRepository` instead? We have a convention of using the `Repository`
    suffix. However, you can use the collection of the entity, such as `Garage` for
    a collection of cars or `Team` for a collection of players.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Hangar` interface extends a different interface, this time, `PageableRepository`.
    It is a specialization that enables pagination resources. It uses the query method
    and returns a `Page` interface to work with a slice of information on airplanes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have both code repositories ready for execution. Starting with
    the `Developer` repository, we’ll create developers, find them by ID, delete them
    by ID, and use the method we made, which is querying by language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to execute the pagination resource with pagination in our
    Hangar. Once we have a few airplanes added, we’ll include pagination with a size
    of two elements. In the real world, the number is more considerable. It will vary
    based on the area and context; it is often between 10 and 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have both running on Java SE; let’s move on to the next stage, which is
    pushing the same code to `MicroProfile` to create a microservice. In the chapter
    about `MicroStream` in [*Chapter 8*](B19375_08.xhtml#_idTextAnchor151), we explained
    the CDI engine/core; we’ll follow the same principle – copy/paste the same code
    and change the access to make it a rest resource instead of a Java SE application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We showed the pure API, but how about the implementations? To display the number
    of options, we have a repository that illustrates an implementation of the particular
    behavior to each example in our `git` remote. You can try out, run, and get a
    feel for the difference between vendors and persistence solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polyglot persistence is a good path to advance most enterprise applications.
    It is possible to explore SQL, NoSQL, or any persistence solution with this approach.
    However, as with any architectural decision, pay attention to the trade-offs;
    an abstraction can ensure that the choice of database will not impact the business
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Data helps standardize behavior and code patterns. It helps us build
    a universe of capabilities out of several persistence solutions. It is promising
    solution to increase the capabilities around data persistence patterns on Java,
    and it is open for help and feedback; join us to make our lives even easier when
    working with this tool.
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to explore, at an architectural level, the integration practices
    that allow us to explore the best out-of-data integration patterns in modern cloud-oriented
    solutions.
  prefs: []
  type: TYPE_NORMAL
