<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-34"><em class="italic"><a id="_idTextAnchor033"/>Chapter 2</em>: Working on Data Access</h1>
			<p>Any microservice adoption is incomplete without integrating with persistence or data storage. In this chapter, we will explore various aspects of persistence and data access in the Micronaut framework. We will begin by using an <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) framework to integrate with a relational database. Then, we will dive into integrating a database using a persistence framework. Furthermore, in the end, we will see an example of integrating a NoSQL database. To cover these topics, we will work on a pet clinic application. This application will be composed of the following microservices:</p>
			<ul>
				<li><strong class="source-inline">pet-owner</strong>: A microservice to integrate with a relational database using an ORM framework in Micronaut</li>
				<li><strong class="source-inline">pet-clinic</strong>: A microservice to integrate with a relational database using a persistence framework in Micronaut</li>
				<li><strong class="source-inline">pet-clinic-review</strong>: A microservice to integrate with a NoSQL database in Micronaut</li>
			</ul>
			<p>By the end of this chapter, you will have good and hands-on knowledge of working with various kinds of persistence frameworks and how to integrate persistence frameworks with different kinds of databases (relational as well as NoSQL) in the Micronaut framework.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter are run on Windows 10 and macOS. Code examples covered in this chapter are available in the book's GitHub repository at <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02</a>.</p>
			<p>The following tools need to be installed and set up in the development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong>: Version 13 or above (we used Java 14).</li>
				<li><strong class="bold">Maven</strong>: This is optional and only required if you would like to use Maven as the build system. However, we recommend having Maven set up on any development machine. Instructions to download and install Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">Development IDE</strong>: Based on your preferences, any Java-based IDE can be used, but for the purpose of writing this chapter, IntelliJ was used. </li>
				<li><strong class="bold">Git</strong>: Instructions to download and install Git can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</li>
				<li><strong class="bold">PostgreSQL</strong>: Instructions to download and install PostgreSQL can be found at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</li>
				<li><strong class="bold">MongoDB</strong>: MongoDB Atlas provides a free online database-as-a-service with up to 512 MB storage. However, if the local database is preferred, then instructions to download and install can be found at <a href="https://docs.mongodb.com/manual/administration/install-community/">https://docs.mongodb.com/manual/administration/install-community/</a>. We used a local installation for writing this chapter.</li>
				<li><strong class="bold">Studio 3T for MongoDB</strong>: With the MongoDB local installation, we used Studio 3T for the GUI. Instructions to download and install Studio 3T can be found at <a href="https://studio3t.com/download/">https://studio3t.com/download/</a>.</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Integrating with persistence in the Micronaut framework</h1>
			<p>To<a id="_idIndexMarker091"/> exhibit integration with<a id="_idIndexMarker092"/> persistence (database) in the Micronaut framework, we will work on three different microservices within the <strong class="source-inline">pet-clinic</strong> application:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.1_B16585.jpg" alt="Figure 2.1 – Microservices in the pet-clinic application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Microservices in the pet-clinic application</p>
			<p>Hibernate<a id="_idIndexMarker093"/> and MyBatis<a id="_idIndexMarker094"/> are persistence frameworks for relational databases, whereas to integrate with NoSQL (MongoDB), we will use its native synchronous driver. </p>
			<p>In the <a id="_idIndexMarker095"/>following sections, we will cover each integration <a id="_idIndexMarker096"/>technique by doing hands-on work with the respective microservice. Each microservice (for the scope of this chapter) will be componentized into the following types of components:</p>
			<ul>
				<li><strong class="bold">Entity</strong>: To <a id="_idIndexMarker097"/>encapsulate ORMs</li>
				<li><strong class="bold">Repository</strong>: To <a id="_idIndexMarker098"/>encapsulate interaction to the underlying Hibernate framework</li>
				<li><strong class="bold">Service</strong>: To <a id="_idIndexMarker099"/>contain any business logic as well as concierge calls to the downstream repository</li>
				<li><strong class="bold">CLI client</strong>: To <a id="_idIndexMarker100"/>connect <strong class="bold">create-read-update-delete</strong> (<strong class="bold">CRUD</strong>) requests<a id="_idIndexMarker101"/> to the service</li>
			</ul>
			<p>The following diagram depicts these components and their interaction with each other:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.2_B16585_Fixed.jpg" alt="Figure 2.2 – Microservice components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 2.2 – Microservice components</p>
			<p>We will follow the service-repository <a id="_idIndexMarker102"/>pattern to separate the concerns <a id="_idIndexMarker103"/>and decouple components within a microservice. We will cover these components in a bottom-up fashion by kickstarting with entities, then repositories, and finally services. In the next section, we will explore integrating with a relational database using an ORM framework.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Integrating with a relational database using an ORM (Hibernate) framework</h1>
			<p>An ORM framework enables you to store, query, or manipulate data using the object-oriented <a id="_idIndexMarker104"/>paradigm. It provides <a id="_idIndexMarker105"/>an object-oriented approach to access the data from the database or, in other words, instead of using SQL, you can use Java objects to interact with the database. </p>
			<p>In Java, as <a id="_idIndexMarker106"/>a standard specification, the <strong class="bold">Java Persistence API</strong> (<strong class="bold">JPA</strong>) specifies the following:</p>
			<ul>
				<li>Which Java objects ought to be persisted </li>
				<li>How these objects should be persisted </li>
			</ul>
			<p>JPA is not a framework or tool but it dictates the standard protocol and covers the core concepts of what to persist and how to persist. Various implementing frameworks such as Hibernate and EclipseLink have adopted these JPA standards. We will be using <strong class="bold">Hibernate</strong> as our ORM framework.</p>
			<p>To get hands-on with <a id="_idIndexMarker107"/>Hibernate in the Micronaut framework, we will work on <a id="_idIndexMarker108"/>the small <strong class="source-inline">pet-clinic</strong> application <a id="_idIndexMarker109"/>and, specifically for Hibernate, we will focus on the <strong class="source-inline">pet-owner</strong> microservice. The following diagram captures the schema design for the <strong class="source-inline">pet-owner</strong> microservice:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_2.3_B16585.jpg" alt="Figure 2.3 – The pet-owner schema&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – The pet-owner schema</p>
			<p>Essentially, in the <strong class="source-inline">pet-owner</strong> schema, one owner can have zero or more pets (of a certain type) and a pet can have zero or more vet visits. In the next section, we will get started with setting up the <strong class="source-inline">pet-owner</strong> schema. </p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Generating the pet-owner schema in PostgreSQL</h2>
			<p>To <a id="_idIndexMarker110"/>generate <a id="_idIndexMarker111"/>the <strong class="source-inline">pet-owner</strong> schema, follow <a id="_idIndexMarker112"/>these instructions:</p>
			<ol>
				<li>Download DB-SQL from <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-owner/src/main/resources/db/db-sql.txt</a>.</li>
				<li>Open PostgreSQL's PgAdmin and open the query tool. </li>
				<li>Run the preceding SQL <strong class="bold">section by section</strong>. It will create a <strong class="source-inline">pet-owner</strong> user, schema, and tables. </li>
				<li>Finally, run the SQL data to ingest some dummy data into these tables. </li>
			</ol>
			<p>After finishing <a id="_idIndexMarker113"/>setting up the schema, we <a id="_idIndexMarker114"/>will focus our attention on <a id="_idIndexMarker115"/>working on the Micronaut project next.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Creating a Micronaut application for the pet-owner microservice</h2>
			<p>In order <a id="_idIndexMarker116"/>to generate boilerplate <a id="_idIndexMarker117"/>source code for the <strong class="source-inline">pet-owner</strong> microservice, we will use Micronaut Launch. Micronaut Launch <a id="_idIndexMarker118"/>is an intuitive interface to generate boilerplate and it can be accessed at <a href="https://micronaut.io/launch/">https://micronaut.io/launch/</a>. Once opened, this interface will look as in the following screenshot:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_2.4_B16585_Fixed.jpg" alt="Figure 2.4 – Using Micronaut Launch to generate the pet-owner project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Using Micronaut Launch to generate the pet-owner project</p>
			<p>In Micronaut <a id="_idIndexMarker119"/>Launch, we will <a id="_idIndexMarker120"/>choose the <a id="_idIndexMarker121"/>following features (by clicking on the <strong class="bold">FEATURES</strong> button):</p>
			<ul>
				<li><strong class="bold">data-jpa</strong></li>
				<li><strong class="bold">hibernate-jpa</strong></li>
				<li><strong class="bold">jdbc-hikari</strong></li>
				<li><strong class="bold">logback</strong></li>
				<li><strong class="bold">postgres</strong></li>
			</ul>
			<p>After specifying the aforementioned options, click on the <strong class="bold">GENERATE PROJECT</strong> button. A ZIP file will be downloaded onto your system. Unzip the downloaded source code into your workspace and open the project in your preferred IDE.</p>
			<p>In the <strong class="source-inline">pet-owner</strong> microservice application, we will follow the service-repository pattern to <a id="_idIndexMarker122"/>separate the concerns <a id="_idIndexMarker123"/>and decouple <a id="_idIndexMarker124"/>components within the microservice. As discussed before, we will take a bottom-up approach in covering these components by kickstarting with entities, and then exploring repositories and finally services.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Creating the entity classes</h2>
			<p>An entity is a <strong class="bold">plain-old-Java-object</strong> (<strong class="bold">POJO</strong>) class that is annotated with the <strong class="source-inline">@Entity</strong> annotation. An entity <a id="_idIndexMarker125"/>class definition usually contains a set of mappings <a id="_idIndexMarker126"/>for each column in the table. Therefore, an entity object instance will represent one row in the mapped table. </p>
			<p>We will <a id="_idIndexMarker127"/>create a domain package to contain all the entity classes. We will create the <strong class="source-inline">com.packtpub.micronaut.domain</strong> package under the root package.</p>
			<p>To map the owners table, we can define an <strong class="source-inline">Owner</strong> entity. Let's begin with mapping basic columns (skipping foreign keys or any relationships):</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name = "owners", schema = "petowner")</p>
			<p class="source-code">public class Owner implements Serializable {</p>
			<p class="source-code">    private static final long serialVersionUID = 1L;</p>
			<p class="source-code">    @Id</p>
			<p class="source-code">    @GeneratedValue(strategy = GenerationType.IDENTITY)</p>
			<p class="source-code">    private Long id;</p>
			<p class="source-code">    @Column(name = "first_name")</p>
			<p class="source-code">    private String firstName;</p>
			<p class="source-code">    @Column(name = "last_name")</p>
			<p class="source-code">    private String lastName;</p>
			<p class="source-code">    @Column(name = "address")</p>
			<p class="source-code">    private String address;</p>
			<p class="source-code">    @Column(name = "city")</p>
			<p class="source-code">    private String city;</p>
			<p class="source-code">    @Column(name = "telephone")</p>
			<p class="source-code">    private String telephone;</p>
			<p class="source-code">}</p>
			<p>In the preceding code snippet, we are declaring an <strong class="source-inline">Owner</strong> entity class for the owners table. To map <a id="_idIndexMarker128"/>the primary key, we are using the <strong class="source-inline">@Id</strong> annotation <a id="_idIndexMarker129"/>in tandem with <strong class="source-inline">@GeneratedValue</strong>. You can generate getters and setters for the mapped columns. Similarly, we can define other entity classes: <strong class="source-inline">Pet</strong> for the pets table, <strong class="source-inline">Visit</strong> for the visits table, and <strong class="source-inline">PetType</strong> for the types table. We will take a look at defining the relationships in the next section.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Defining relationships among entities</h2>
			<p>Using the <a id="_idIndexMarker130"/>Hibernate framework, we can define the following <a id="_idIndexMarker131"/>relationship types:</p>
			<ul>
				<li>One-to-one</li>
				<li>One-to-many/many-to-one</li>
				<li>Many-to-many</li>
			</ul>
			<p>Let's take a look at each relationship type.</p>
			<h3>Mapping a one-to-one relationship</h3>
			<p>In the <strong class="source-inline">pet-owner</strong> example, we do not have a one-to-one relationship between any entities. However, let's consider that all the address information from the owners table has <a id="_idIndexMarker132"/>been taken out into an addresses <a id="_idIndexMarker133"/>table; the resultant schema will look as in the following figure: </p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_2.5_B16585.jpg" alt="Figure 2.5 – One-to-one relationship between owners and addresses&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – One-to-one relationship between owners and addresses</p>
			<p>Essentially, one owner will have one address in the preceding schema. </p>
			<p>In the <strong class="source-inline">Owner</strong> entity, to define this relationship, we can use <strong class="source-inline">@OneToOne</strong>:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name = "owners", schema = "petowner")</p>
			<p class="source-code">public class Owner implements Serializable {</p>
			<p class="source-code">     .// ...</p>
			<p class="source-code">@OneToOne(cascade = CascadeType.ALL)</p>
			<p class="source-code">     @JoinColumn(name = "address_id", referencedColumnName = "id")</p>
			<p class="source-code">     private Address address;</p>
			<p class="source-code">// ... getters and setters</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">@JoinColumn</strong> will refer to joining the <strong class="source-inline">address_id</strong> column in the owners table. </p>
			<p>Whereas this relationship in the <strong class="source-inline">Address</strong> entity will be defined as follows:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name = "address")</p>
			<p class="source-code">public class Address {</p>
			<p class="source-code"> </p>
			<p class="source-code">    @Id</p>
			<p class="source-code">    @GeneratedValue(strategy = GenerationType.IDENTITY)</p>
			<p class="source-code">    @Column(name = "id")</p>
			<p class="source-code">    private Long id;</p>
			<p class="source-code">    //...</p>
			<p class="source-code"> </p>
			<p class="source-code">    @OneToOne(mappedBy = "address")</p>
			<p class="source-code">    private User user;</p>
			<p class="source-code"> </p>
			<p class="source-code">    //... getters and setters</p>
			<p class="source-code">}</p>
			<p>You may <a id="_idIndexMarker134"/>note in the <strong class="source-inline">Owner</strong> entity <a id="_idIndexMarker135"/>we have defined a one-to-one relationship using <strong class="source-inline">@JoinColumn</strong> because the owners table contains <strong class="source-inline">address_id</strong>. However, in the <strong class="source-inline">Address</strong> entity, we can simply use <strong class="source-inline">mappedBy</strong> and point to the <strong class="source-inline">address</strong> variable defined in the <strong class="source-inline">Owner</strong> entity. JPA will take care of managing this bi-directional relationship behind the scenes.</p>
			<h3>Mapping a one-to-many/many-to-one relationship</h3>
			<p>Fortunately, in <a id="_idIndexMarker136"/>the <strong class="source-inline">pet-owner</strong> schema, we <a id="_idIndexMarker137"/>have various instances of one-to-many or many-to-one relationships (many-to-one is just a flip <a id="_idIndexMarker138"/>of a one-to-many relationship). To keep it focused, let's <a id="_idIndexMarker139"/>consider the following relationship between the owners and pets tables:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_2.6_B16585.jpg" alt="Figure 2.6 – One-to-many relationship between owners and pets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – One-to-many relationship between owners and pets</p>
			<p>In <a id="_idIndexMarker140"/>the <strong class="source-inline">Owner</strong> entity, the preceding <a id="_idIndexMarker141"/>one-to-many relationship will be defined as follows:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name = "owners", schema = "petowner")</p>
			<p class="source-code">public class Owner implements Serializable {</p>
			<p class="source-code">    @Id</p>
			<p class="source-code">    @GeneratedValue(strategy = GenerationType.IDENTITY)</p>
			<p class="source-code">    private Long id;</p>
			<p class="source-code">    //...</p>
			<p class="source-code">  </p>
			<p class="source-code">    @OneToMany(mappedBy = "owner", cascade = </p>
			<p class="source-code">      CascadeType.ALL)</p>
			<p class="source-code">    private Set&lt;Pet&gt; pets = new HashSet&lt;&gt;();</p>
			<p class="source-code">    //...</p>
			<p>In <a id="_idIndexMarker142"/>the <strong class="source-inline">Pet</strong> entity, this relationship <a id="_idIndexMarker143"/>will be mapped <a id="_idIndexMarker144"/>as follows:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name = "pets", schema = "petowner")</p>
			<p class="source-code">public class Pet implements Serializable {</p>
			<p class="source-code">    @Id</p>
			<p class="source-code">    @GeneratedValue(strategy = GenerationType.IDENTITY)</p>
			<p class="source-code">    private Long id;</p>
			<p class="source-code">    </p>
			<p class="source-code">    //...</p>
			<p class="source-code">    @ManyToOne</p>
			<p class="source-code">    @JoinColumn(name = "owner_id")</p>
			<p class="source-code">    private Owner owner;</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p>Again, if <a id="_idIndexMarker145"/>you notice in the <strong class="source-inline">Pet</strong> entity we have a crisply defined relationship with <strong class="source-inline">Owner</strong> using <strong class="source-inline">@JoinColumn</strong> (because the pets table contains <strong class="source-inline">owner_id</strong>), whereas in the <strong class="source-inline">Owner</strong> entity, we simply used <strong class="source-inline">mappedBy = "owner"</strong>. JPA will take care of defining and managing this bi-directional relationship behind the scenes. </p>
			<h3>Mapping a many-to-many relationship</h3>
			<p>Mapping and <a id="_idIndexMarker146"/>managing a many-to-many relationship <a id="_idIndexMarker147"/>is a tad more complex. In the <strong class="source-inline">pet-owner</strong> schema, we don't have an instance of a many-to-many relationship, so let's assume a hypothetical relationship between two imaginary entities, <strong class="source-inline">Foo</strong> and <strong class="source-inline">Bar</strong>:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_2.7_B16585.jpg" alt="Figure 2.7 – Many-to-many relationship between foos and bars&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Many-to-many relationship between foos and bars</p>
			<p>The aforementioned many-to-many relationship will be defined as follows in the <strong class="source-inline">Foo</strong> entity:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name = "foos")</p>
			<p class="source-code">public class Foo { </p>
			<p class="source-code">    </p>
			<p class="source-code">   // ...</p>
			<p class="source-code"> </p>
			<p class="source-code">    @ManyToMany(cascade = { CascadeType.ALL })</p>
			<p class="source-code">    @JoinTable(</p>
			<p class="source-code">        name = "foo_bars", </p>
			<p class="source-code">        joinColumns = { @JoinColumn(name = "foo_id") }, </p>
			<p class="source-code">        inverseJoinColumns = { @JoinColumn(name = "bar_id") }</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Set&lt;Bar&gt; bars = new HashSet&lt;&gt;();</p>
			<p class="source-code"> </p>
			<p class="source-code">    // getters and setters</p>
			<p class="source-code">}</p>
			<p>We use <strong class="source-inline">@JoinTable</strong> to map the relationship with a many-to-many table. <strong class="source-inline">joinColumns</strong> refers to <a id="_idIndexMarker148"/>the column that is owned by the entity, whereas <strong class="source-inline">inverseJoinColumns</strong> refers to the column in the co-joining entity. </p>
			<p>The <strong class="source-inline">Bar</strong> entity <a id="_idIndexMarker149"/>will define this relationship as follows:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name = "bars")</p>
			<p class="source-code">public class Bar {    </p>
			<p class="source-code">    </p>
			<p class="source-code">    // ...  </p>
			<p class="source-code"> </p>
			<p class="source-code">    @ManyToMany(mappedBy = "bars")</p>
			<p class="source-code">    private Set&lt;Foo&gt; foos = new HashSet&lt;&gt;();</p>
			<p class="source-code">    </p>
			<p class="source-code">    // getters and setters   </p>
			<p class="source-code">}</p>
			<p>Just like previous examples, we have crisply defined the many-to-many relationship in the <strong class="source-inline">Foo</strong> entity using <strong class="source-inline">@JoinTable</strong>, whereas in the <strong class="source-inline">Bar</strong> entity we have simply used <strong class="source-inline">mappedBy</strong>. </p>
			<p>Up until now, we have covered how to define different kinds of relationships in the entity classes. Next, we will divert our attention to how to create data access repositories. </p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Creating data access repositories</h2>
			<p>The Hibernate framework enables us to define CRUD access to the database very intuitively. For <a id="_idIndexMarker150"/>each of the entities, we will define a <a id="_idIndexMarker151"/>repository abstract class, wherein each repository abstract class will implement <strong class="source-inline">JpaRepository</strong>. <strong class="source-inline">JpaRepository</strong> is an out-of-the-box interface defined in <strong class="source-inline">io.micronaut.data.jpa.repository</strong>, which further extends <strong class="source-inline">CrudRepository</strong> and <strong class="source-inline">PageableRepository</strong> to declare and define standard methods to support common CRUD operations. This reduces the syntactic sugar and frees us from defining these methods ourselves.</p>
			<p>At the outset, we will create a new package called <strong class="source-inline">com.packtpub.micronaut.repository</strong> to contain all the repositories. All the repository abstract classes will look the same and here's how the <strong class="source-inline">OwnerRepository</strong> will look:</p>
			<p class="source-code">@Repository</p>
			<p class="source-code">public abstract class OwnerRepository implements JpaRepository&lt;Owner, Long&gt; {</p>
			<p class="source-code">    @PersistenceContext</p>
			<p class="source-code">    private final EntityManager entityManager;</p>
			<p class="source-code">    public OwnerRepository(EntityManager entityManager) {</p>
			<p class="source-code">        this.entityManager = entityManager;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Transactional</p>
			<p class="source-code">    public Owner mergeAndSave(Owner owner) {</p>
			<p class="source-code">        owner = entityManager.merge(owner);</p>
			<p class="source-code">        return save(owner);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">OwnerRepository</strong> is using Micronaut's standard <strong class="source-inline">@Repository</strong> annotation and it leverages <strong class="source-inline">JpaRepository</strong> to declare and define standard CRUD methods for the <strong class="source-inline">Owner</strong> entity.</p>
			<p>Similarly, we can <a id="_idIndexMarker152"/>define these abstract classes for other <a id="_idIndexMarker153"/>entities as well – such as <strong class="source-inline">Pet</strong>, <strong class="source-inline">Visit</strong>, and <strong class="source-inline">PetType</strong> in <strong class="source-inline">io.micronaut.data.jpa.repository</strong>.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Creating services for entities</h2>
			<p>Services will contain any business logic as well as downstream access to the repositories. We can define standard interfaces for each entity service, which will <a id="_idIndexMarker154"/>outline basic operations supported in a service. </p>
			<p>To contain all services, we will create a package called <strong class="source-inline">com.packtpub.micronaut.service</strong>. The interface for <strong class="source-inline">OwnerService</strong> will be declared as follows:</p>
			<p class="source-code">public interface OwnerService {</p>
			<p class="source-code">    Owner save(Owner owner);</p>
			<p class="source-code">    Page&lt;Owner&gt; findAll(Pageable pageable);</p>
			<p class="source-code">    Optional&lt;Owner&gt; findOne(Long id);</p>
			<p class="source-code">    void delete(Long id);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">OwnerService</strong> interface <a id="_idIndexMarker155"/>provides an abstract declaration of all service methods. We can implement all declared methods in a concrete class: </p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">@Transactional</p>
			<p class="source-code">public class OwnerServiceImpl implements OwnerService {</p>
			<p class="source-code">    private final Logger log = </p>
			<p class="source-code">     LoggerFactory.getLogger(OwnerServiceImpl.class);</p>
			<p class="source-code">    private final OwnerRepository ownerRepository;</p>
			<p class="source-code">    public OwnerServiceImpl(OwnerRepository </p>
			<p class="source-code">     ownerRepository) {</p>
			<p class="source-code">        this.ownerRepository = ownerRepository;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Owner save(Owner owner) {</p>
			<p class="source-code">        log.debug("Request to save Owner : {}", owner);</p>
			<p class="source-code">        return ownerRepository.mergeAndSave(owner);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    @ReadOnly</p>
			<p class="source-code">    @Transactional</p>
			<p class="source-code">    public Page&lt;Owner&gt; findAll(Pageable pageable) {</p>
			<p class="source-code">        log.debug("Request to get all Owners");</p>
			<p class="source-code">        return ownerRepository.findAll(pageable);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    @ReadOnly</p>
			<p class="source-code">    @Transactional</p>
			<p class="source-code">    public Optional&lt;Owner&gt; findOne(Long id) {</p>
			<p class="source-code">        log.debug("Request to get Owner : {}", id);</p>
			<p class="source-code">        return ownerRepository.findById(id);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void delete(Long id) {</p>
			<p class="source-code">        log.debug("Request to delete Owner : {}", id);</p>
			<p class="source-code">        ownerRepository.deleteById(id);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Service method definitions essentially delegate execution to the <a id="_idIndexMarker156"/>downstream repository. We will repeat steps to declare service interfaces and define concrete service classes for the rest of the entities – <strong class="source-inline">Pet</strong>, <strong class="source-inline">Visit</strong>, and <strong class="source-inline">PetType</strong>. </p>
			<p>In the <a id="_idIndexMarker157"/>next section, we will focus our attention on creating a small command-line utility to perform common CRUD operations in the <strong class="source-inline">pet-owner</strong> database. </p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Performing basic CRUD operations</h2>
			<p>In order to exhibit basic CRUD operations on the entities, we will <a id="_idIndexMarker158"/>create a simple utility. We can create a new package called <strong class="source-inline">com.packtpub.micronaut.utils</strong> to define <strong class="source-inline">PetOwnerCliClient</strong>:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class PetOwnerCliClient {</p>
			<p class="source-code">    private final OwnerService ownerService;</p>
			<p class="source-code">    private final PetService petService;</p>
			<p class="source-code">    private final VisitService visitService;</p>
			<p class="source-code">    private final PetTypeService petTypeService;</p>
			<p class="source-code">    public PetOwnerCliClient(OwnerService ownerService, </p>
			<p class="source-code">                             PetService petService, </p>
			<p class="source-code">                             VisitService visitService, </p>
			<p class="source-code">                             PetTypeService petTypeService) {</p>
			<p class="source-code">        this.ownerService = ownerService;</p>
			<p class="source-code">        this.petService = petService;</p>
			<p class="source-code">        this.visitService = visitService;</p>
			<p class="source-code">        this.petTypeService = petTypeService;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // methods for performing CRUD operations...</p>
			<p class="source-code">}</p>
			<p>This utility <a id="_idIndexMarker159"/>will inject all services using the constructor method. Any CRUD calls made in this utility will be executed using the injected services.</p>
			<h3>Performing read/fetch operations</h3>
			<p>We can <a id="_idIndexMarker160"/>define a simple utility method in <strong class="source-inline">PetOwnerCliClient</strong> that can call <strong class="source-inline">OwnerService</strong> to fetch all owners. Moreover, since <strong class="source-inline">Owner</strong> has multiple pets and each pet can have multiple visits, fetching an owner will fetch pretty much everything in the <strong class="source-inline">pet-owner</strong> schema:</p>
			<p class="source-code">protected void performFindAll() {</p>
			<p class="source-code">    Page&lt;Owner&gt; pOwners = </p>
			<p class="source-code">     ownerService.findAll(Pageable.unpaged());</p>
			<p class="source-code">    … iterate through paged content</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">performFindAll()</strong> will fetch all owners and their pets (along with pet visits). </p>
			<h3>Performing a save operation</h3>
			<p>To save an owner with a pet and a visit, we can define a method <a id="_idIndexMarker161"/>in <strong class="source-inline">PetOwnerCliClient</strong>:</p>
			<p class="source-code">protected Owner performSave() {</p>
			<p class="source-code">    Owner owner = initOwner();</p>
			<p class="source-code">    return ownerService.save(owner);</p>
			<p class="source-code">}</p>
			<p class="source-code">private Owner initOwner() {Owner owner = new Owner();</p>
			<p class="source-code">    owner.setFirstName("Foo");</p>
			<p class="source-code">    owner.setLastName("Bar");</p>
			<p class="source-code">    owner.setCity("Toronto");</p>
			<p class="source-code">    owner.setAddress("404 Adelaide St W");</p>
			<p class="source-code">    owner.setTelephone("647000999");</p>
			<p class="source-code">    Pet pet = new Pet();</p>
			<p class="source-code">    pet.setType(petTypeService.findAll(Pageable.unpaged()).getContent().get(1));</p>
			<p class="source-code">    pet.setName("Baz");</p>
			<p class="source-code">    pet.setBirthDate(LocalDate.of(2010, 12, 12));</p>
			<p class="source-code">    pet.setOwner(owner);</p>
			<p class="source-code">    Visit visit = new Visit();</p>
			<p class="source-code">    visit.setVisitDate(LocalDate.now());</p>
			<p class="source-code">    visit.setDescription("Breathing issues");</p>
			<p class="source-code">    visit.setPet(pet);</p>
			<p class="source-code">    return owner;</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">initOwner()</strong> initializes <a id="_idIndexMarker162"/>an owner with a pet and pet visit, and it will be used by <strong class="source-inline">performSave()</strong> to invoke the downstream service class method to save this owner.</p>
			<h3>Performing a delete operation</h3>
			<p>In <strong class="source-inline">PetOwnerCliClient</strong>, we will define a delete method <a id="_idIndexMarker163"/>to delete an owner (along with their pets and visits):</p>
			<p class="source-code">protected void performDelete(Owner owner) {</p>
			<p class="source-code">    /** delete owner pets and their visits */</p>
			<p class="source-code">    Set&lt;Pet&gt; pets = owner.getPets();</p>
			<p class="source-code">    if (CollectionUtils.isNotEmpty(pets)) {</p>
			<p class="source-code">        for (Pet pet : pets) {</p>
			<p class="source-code">            Set&lt;Visit&gt; visits = pet.getVisits();</p>
			<p class="source-code">            if (CollectionUtils.isNotEmpty(visits)) {</p>
			<p class="source-code">                for (Visit visit : visits) {</p>
			<p class="source-code">                    visitService.delete(visit.getId());</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            petService.delete(pet.getId());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ownerService.delete(owner.getId());</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">performDelete()</strong> first iterates through pets and pet visits; after deleting pet visits and pets, it will finally delegate the call to delete the owner.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Wrapping up</h2>
			<p>To perform <strong class="source-inline">PetOwnerCliClient</strong> CRUD operations, we will <a id="_idIndexMarker164"/>add the following code logic to <strong class="source-inline">Application.java</strong>:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class Application {</p>
			<p class="source-code">    private final PetOwnerCliClient petOwnerCliClient;</p>
			<p class="source-code">    public Application(PetOwnerCliClient petOwnerCliClient) {</p>
			<p class="source-code">        this.petOwnerCliClient = petOwnerCliClient;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Micronaut.run(Application.class, args);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @EventListener</p>
			<p class="source-code">    void init(StartupEvent event) {</p>
			<p class="source-code">        petOwnerCliClient.performDatabaseOperations();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Then, when we run our application, the aforementioned <strong class="source-inline">@EventListener</strong> will invoke <strong class="source-inline">PetOwnerCliClient</strong> to perform database operations. </p>
			<p>In this section, through the <strong class="source-inline">pet-owner</strong> microservice, we covered how to integrate a Micronaut-based microservice with a relational database. We also discussed how to define entities, repositories, and services, and lastly exhibited CRUD operations. In the next section, we will explore how to integrate with a relational database using another type of persistence framework (MyBatis).</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Integrating with a relational database using a persistence (MyBatis) framework</h1>
			<p><strong class="bold">MyBatis</strong> is a Java <a id="_idIndexMarker165"/>persistence framework. Unlike Hibernate (an ORM framework), MyBatis does not support the direct mapping of Java objects to the <a id="_idIndexMarker166"/>database but instead maps Java methods to SQL statements.</p>
			<p>MyBatis <a id="_idIndexMarker167"/>is commonly used in migration or transformational projects where a legacy database(s) already exists. Since a lot of tables, views, and other data objects are already defined and used in the database, it may not be an ideal scenario to refactor and normalize these table/view definitions to map them directly to Java objects (using an ORM framework). MyBatis offers an ideal way of mapping Java methods to SQL statements. These SQL statements, which manage any CRUD access thereof, are defined in an XML mapper or POJO mapper using MyBatis annotations. </p>
			<p>Furthermore, as an ORM framework (such as Hibernate) manages child entities on its own and hides the SQL part completely, some developers prefer to have control of interacting with SQL. Therefore, MyBatis can chime in as a preferred persistence framework. </p>
			<p>Micronaut supports integration with relational databases through MyBatis. In order to exhibit this integration, we will work on another microservice that will manage the veterinary aspect of the pet clinic application. This microservice will integrate with the following schema:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_2.8_B16585.jpg" alt="Figure 2.8 – Pet clinic schema&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Pet clinic schema</p>
			<p>Essentially, one vet can have many specialties and one specialty can belong to multiple vets. In the next section, we will get started with setting up the <strong class="source-inline">pet-clinic</strong> schema. </p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Generating the pet-clinic schema in PostgreSQL</h2>
			<p>To generate <a id="_idIndexMarker168"/>the <strong class="source-inline">pet-clinic</strong> schema, follow these instructions:</p>
			<ol>
				<li value="1">Download DB-SQL from <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/blob/master/Chapter02/micronaut-petclinic/pet-clinic/src/main/resources/db/db-sql.txt</a>.</li>
				<li>Open <a id="_idIndexMarker169"/>PostgreSQL's PgAdmin and open the query tool. </li>
				<li>Run the preceding SQL <strong class="bold">section by section</strong>. It will create a <strong class="source-inline">pet-owner</strong> user, schema, and tables. </li>
				<li>Lastly, run the data SQL to ingest some dummy data into these tables. </li>
			</ol>
			<p>After finishing setting up the schema, we will turn our attention to working on the Micronaut project next.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Generating a Micronaut application for the pet-clinic microservice</h2>
			<p>In order <a id="_idIndexMarker170"/>to generate <a id="_idIndexMarker171"/>boilerplate <a id="_idIndexMarker172"/>source code for the <strong class="source-inline">pet-clinic</strong> microservice, we will use Micronaut Launch:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_2.9_B16585_Fixed.jpg" alt="Figure 2.9 – Using Micronaut Launch for generating the pet-clinic project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Using Micronaut Launch for generating the pet-clinic project</p>
			<p>In Micronaut <a id="_idIndexMarker173"/>Launch, we will choose the following features (by clicking on the <strong class="bold">FEATURES</strong> button):</p>
			<ul>
				<li><strong class="bold">jdbc-hikari</strong></li>
				<li><strong class="bold">logback</strong></li>
				<li><strong class="bold">postgres</strong></li>
			</ul>
			<p>After <a id="_idIndexMarker174"/>specifying <a id="_idIndexMarker175"/>the aforementioned options, click on the <strong class="bold">GENERATE PROJECT</strong> button. A ZIP file will be downloaded onto your system. </p>
			<p>Unzip the downloaded source code into your workspace and open the project in your preferred IDE. Once the project is open in the IDE, add the following dependency in <strong class="source-inline">pom.xml</strong> (or <strong class="source-inline">gradle build</strong>) for MyBatis:</p>
			<p class="source-code">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">     &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</p>
			<p class="source-code">     &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</p>
			<p class="source-code">     &lt;version&gt;3.5.5&lt;/version&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>This <a id="_idIndexMarker176"/>dependency is core to our integration with the <strong class="source-inline">pet-clinic</strong> schema in Micronaut.</p>
			<p>Consistent <a id="_idIndexMarker177"/>with the service-repository <a id="_idIndexMarker178"/>pattern, we will explore MyBatis integration in a bottom-up fashion. First, we will define entities, and then repositories, and finally, we will work on services. </p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Defining a MyBatis factory</h2>
			<p>To execute <a id="_idIndexMarker179"/>various SQL statements, MyBatis would need <a id="_idIndexMarker180"/>a <strong class="source-inline">SqlSessionFactory</strong> object at runtime. We will begin by adding a package – <strong class="source-inline">com.packtpub.micronaut.config</strong>. Add the following class to this newly created package:</p>
			<p class="source-code">@Factory</p>
			<p class="source-code">public class MybatisFactory {</p>
			<p class="source-code">    private final DataSource dataSource;</p>
			<p class="source-code">    public MybatisFactory(DataSource dataSource) {</p>
			<p class="source-code">        this.dataSource = dataSource;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Context</p>
			<p class="source-code">    public SqlSessionFactory sqlSessionFactory() {</p>
			<p class="source-code">        TransactionFactory transactionFactory = new </p>
			<p class="source-code">         JdbcTransactionFactory();</p>
			<p class="source-code">        Environment environment = new Environment(</p>
			<p class="source-code">         "pet-clinic", transactionFactory, dataSource);</p>
			<p class="source-code">        Configuration configuration = new </p>
			<p class="source-code">         Configuration(environment);</p>
			<p class="source-code">        configuration.addMappers("com.packtpub.micronaut.repository");</p>
			<p class="source-code">        return new </p>
			<p class="source-code">         SqlSessionFactoryBuilder().build(configuration);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Using <a id="_idIndexMarker181"/>standard properties in <strong class="source-inline">application.yml</strong>, Micronaut <a id="_idIndexMarker182"/>will define a Hikari-based data source, which will be injected to define <strong class="source-inline">SqlSessionFactory</strong>. While defining the environment, you can choose any name (as we have given <strong class="source-inline">pet-clinic</strong>).</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Creating the entity classes</h2>
			<p>Similar to Hibernate entities, a MyBatis entity fundamentally defines a Java class to integrate <a id="_idIndexMarker183"/>upstream Java classes with downstream SQL interactions (defined in XML or Java mappers). However, a subtle difference is that any MyBatis entity will not contain any mapping logic. </p>
			<p>We will add a <strong class="source-inline">com.packtpub.micronaut.domain</strong> package to contain the domain entities. Add an entity to represent <strong class="source-inline">Specialty</strong>:</p>
			<p class="source-code">@Introspected</p>
			<p class="source-code">public class Specialty implements Serializable {</p>
			<p class="source-code">    private static final long serialVersionUID = 1L;</p>
			<p class="source-code">    @NotNull</p>
			<p class="source-code">    private Long id;</p>
			<p class="source-code">    private String name;</p>
			<p class="source-code">    // ... getters and setters</p>
			<p class="source-code">}</p>
			<p>Similarly, we can define an entity for the vets table:</p>
			<p class="source-code">@Introspected</p>
			<p class="source-code">public class Vet implements Serializable {</p>
			<p class="source-code">    private static final long serialVersionUID = 1L;</p>
			<p class="source-code">    @NotNull</p>
			<p class="source-code">    private Long id;</p>
			<p class="source-code">    private String firstName;</p>
			<p class="source-code">    private String lastName;</p>
			<p class="source-code">    private Set&lt;Specialty&gt; specialties = new HashSet&lt;&gt;();</p>
			<p class="source-code">    // ... getters and setters</p>
			<p class="source-code">}</p>
			<p>You can <a id="_idIndexMarker184"/>note that both the entities do not have any mapping logic to map to the specialties or vets tables. In the next section, we will focus our attention on how to create data access repositories in MyBatis.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Defining the mappers (repositories) for the entities</h2>
			<p>For the <strong class="source-inline">Vet</strong> and <strong class="source-inline">Specialty</strong> entities, we will need to define MyBatis mappers. MyBatis interacts <a id="_idIndexMarker185"/>with the downstream <a id="_idIndexMarker186"/>database using these mappers. In comparison to a typical Java application, MyBatis mappers are data access repositories. We will add a <strong class="source-inline">com.packtpub.micronaut.repository</strong> package to contain all these repositories. </p>
			<p>Under this package, we will add the <strong class="source-inline">SpecialtyRepository</strong> interface:</p>
			<p class="source-code">/**</p>
			<p class="source-code"> * Mybatis mapper for {@link Specialty}.</p>
			<p class="source-code"> */</p>
			<p class="source-code">public interface SpecialtyRepository {</p>
			<p class="source-code">    @Select("SELECT * FROM petclinic.specialties")</p>
			<p class="source-code">    Collection&lt;Specialty&gt; findAll() throws Exception;</p>
			<p class="source-code">    @Select("SELECT * FROM petclinic.specialties WHERE id =</p>
			<p class="source-code">       #{id}")</p>
			<p class="source-code">    Specialty findById(@Param("id") Long id) throws </p>
			<p class="source-code">     Exception;</p>
			<p class="source-code">    @Select("SELECT * FROM petclinic.specialties WHERE </p>
			<p class="source-code">      UPPER(name) = #{name}")</p>
			<p class="source-code">    Specialty findByName(@Param("name") String name) throws </p>
			<p class="source-code">     Exception;</p>
			<p class="source-code">    @Select(</p>
			<p class="source-code">        {</p>
			<p class="source-code">            "INSERT INTO petclinic.specialties(id, name)\n" +</p>
			<p class="source-code">                "VALUES (COALESCE(#{id}, (select </p>
			<p class="source-code">                 nextval('petclinic.specialties_id_seq'))),</p>
			<p class="source-code">                 #{name})\n" +</p>
			<p class="source-code">                "ON CONFLICT (id)\n" +</p>
			<p class="source-code">                "DO UPDATE SET name = #{name}  \n" +</p>
			<p class="source-code">                "WHERE petclinic.specialties.id = #{id}\n" +</p>
			<p class="source-code">                "RETURNING id"</p>
			<p class="source-code">        }</p>
			<p class="source-code">    )</p>
			<p class="source-code">    @Options(flushCache = Options.FlushCachePolicy.TRUE)</p>
			<p class="source-code">    Long save(Specialty specialty) throws Exception;</p>
			<p class="source-code">    @Delete("DELETE FROM petclinic.specialties WHERE id = </p>
			<p class="source-code">     #{id}")</p>
			<p class="source-code">    void deleteById(@Param("id") Long id) throws Exception;</p>
			<p class="source-code">    @Select({</p>
			<p class="source-code">        "SELECT DISTINCT id, name FROM </p>
			<p class="source-code">          petclinic.specialties WHERE id IN(",</p>
			<p class="source-code">        "SELECT specialty_id FROM petclinic.vet_specialties </p>
			<p class="source-code">          WHERE vet_id = #{vetId}",</p>
			<p class="source-code">        ")"</p>
			<p class="source-code">    })</p>
			<p class="source-code">    Set&lt;Specialty&gt; findByVetId(@Param("vetId") Long vetId) </p>
			<p class="source-code">     throws Exception;</p>
			<p class="source-code">}</p>
			<p>In the preceding code snippet, we can see all the actual SQL statements, which are then bound to Java methods. Therefore, whenever any upstream caller invokes any of the aforementioned methods, MyBatis will execute the corresponding mapped SQL. On the same note, we will define <strong class="source-inline">VetRepository</strong> to manage access to the vets table.</p>
			<p>Unlike <a id="_idIndexMarker187"/>Hibernate (which provides <a id="_idIndexMarker188"/>concrete implementations for abstract repository classes), in MyBatis we will have to provide concrete implementation for the repositories. We will add the implementations to <strong class="source-inline">com.packtpub.micronaut.repository.impl</strong>.</p>
			<p>A concrete implementation for <strong class="source-inline">SpecialtyRepository</strong> can be defined as the following:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class SpecialtyRepositoryImpl implements SpecialtyRepository {</p>
			<p class="source-code">    ... SqlSessionFactory injection …</p>
			<p class="source-code">    private SpecialtyRepository </p>
			<p class="source-code">     getSpecialtyRepository(SqlSession sqlSession) {</p>
			<p class="source-code">        return </p>
			<p class="source-code">         sqlSession.getMapper(SpecialtyRepository.class);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Collection&lt;Specialty&gt; findAll() throws Exception {</p>
			<p class="source-code">        try (SqlSession sqlSession = </p>
			<p class="source-code">         sqlSessionFactory.openSession()) {</p>
			<p class="source-code">            return </p>
			<p class="source-code">             getSpecialtyRepository(sqlSession).findAll();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Specialty findById(Long id) throws Exception {</p>
			<p class="source-code">        try (SqlSession sqlSession = </p>
			<p class="source-code">          sqlSessionFactory.openSession()) {</p>
			<p class="source-code">            return getSpecialtyRepository</p>
			<p class="source-code">             (sqlSession).findById(id);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Specialty findByName(String name) throws </p>
			<p class="source-code">      Exception {</p>
			<p class="source-code">        try (SqlSession sqlSession = </p>
			<p class="source-code">         sqlSessionFactory.openSession()) {</p>
			<p class="source-code">            return getSpecialtyRepository</p>
			<p class="source-code">            (sqlSession).findByName(name);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Long save(Specialty specialty) throws Exception {</p>
			<p class="source-code">        Long specialtyId;</p>
			<p class="source-code">        try (SqlSession sqlSession = </p>
			<p class="source-code">         sqlSessionFactory.openSession()) {</p>
			<p class="source-code">            specialtyId = getSpecialtyRepository</p>
			<p class="source-code">             (sqlSession).save(specialty);</p>
			<p class="source-code">            sqlSession.commit();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return specialtyId;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void deleteById(Long id) throws Exception {</p>
			<p class="source-code">        try (SqlSession sqlSession = </p>
			<p class="source-code">         sqlSessionFactory.openSession()) {</p>
			<p class="source-code">            getSpecialtyRepository(sqlSession).deleteById</p>
			<p class="source-code">              (id);</p>
			<p class="source-code">            sqlSession.commit();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Set&lt;Specialty&gt; findByVetId(Long vetId) throws </p>
			<p class="source-code">     Exception {</p>
			<p class="source-code">        try (SqlSession sqlSession = </p>
			<p class="source-code">         sqlSessionFactory.openSession()) {</p>
			<p class="source-code">            return getSpecialtyRepository</p>
			<p class="source-code">             (sqlSession).findByVetId(vetId);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>All the <a id="_idIndexMarker189"/>concrete method definitions <a id="_idIndexMarker190"/>use <strong class="source-inline">SqlSessionFactory</strong> to obtain a <strong class="source-inline">SqlSession</strong> instance. The <strong class="source-inline">getSpecialtyRepository()</strong> method will then return the MyBatis mapper using this <strong class="source-inline">SqlSession</strong> instance. Similarly, <strong class="source-inline">VetRepositoryImpl</strong> can be defined to provide concrete implementations for <strong class="source-inline">VetRepository</strong>. </p>
			<p>In the next section, we will create upstream service classes for these repositories we just defined. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Creating services for entities</h2>
			<p>Services will contain any business logic as well as downstream access to the preceding repositories. We <a id="_idIndexMarker191"/>can define standard interfaces for each entity service, which will outline basic operations supported in a service. </p>
			<p>To contain all services, first, we will create a package called <strong class="source-inline">com.packtpub.micronaut.service</strong>. We can declare an interface for <strong class="source-inline">SpecialtyService</strong> to abstract our barebones structure:</p>
			<p class="source-code">public interface SpecialtyService {</p>
			<p class="source-code">    Specialty save(Specialty specialty) throws Exception;</p>
			<p class="source-code">    Collection&lt;Specialty&gt; findAll() throws Exception;</p>
			<p class="source-code">    Optional&lt;Specialty&gt; findOne(Long id) throws Exception;</p>
			<p class="source-code">    void delete(Long id) throws Exception;</p>
			<p class="source-code">}</p>
			<p>For these barebones methods, we will need to provide concrete implementations. </p>
			<p>We can add a package called <strong class="source-inline">com.packtpub.micronaut.service.impl</strong> under the service package. The <a id="_idIndexMarker192"/>concrete implementation for <strong class="source-inline">SpecialtyService</strong> will be defined as follows:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class SpecialtyServiceImpl implements SpecialtyService {</p>
			<p class="source-code">    private final Logger log = </p>
			<p class="source-code">     LoggerFactory.getLogger(SpecialtyServiceImpl.class);</p>
			<p class="source-code">    private final SpecialtyRepository specialtyRepository;</p>
			<p class="source-code">    public SpecialtyServiceImpl(SpecialtyRepository </p>
			<p class="source-code">      specialtyRepository) {</p>
			<p class="source-code">        this.specialtyRepository = specialtyRepository;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Specialty save(Specialty specialty) throws </p>
			<p class="source-code">       Exception {</p>
			<p class="source-code">        log.debug("Request to save Specialty : {}", </p>
			<p class="source-code">         specialty);</p>
			<p class="source-code">        Long specialtyId = </p>
			<p class="source-code">         specialtyRepository.save(specialty);</p>
			<p class="source-code">        return specialtyRepository.findById(specialtyId);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Collection&lt;Specialty&gt; findAll() throws Exception {</p>
			<p class="source-code">        log.debug("Request to get all Specialties");</p>
			<p class="source-code">        return specialtyRepository.findAll();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Optional&lt;Specialty&gt; findOne(Long id) throws </p>
			<p class="source-code">      Exception {</p>
			<p class="source-code">        log.debug("Request to get Specialty : {}", id);</p>
			<p class="source-code">        return Optional.ofNullable</p>
			<p class="source-code">         (specialtyRepository.findById(id));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void delete(Long id) throws Exception {</p>
			<p class="source-code">        log.debug("Request to delete Specialty : {}", id);</p>
			<p class="source-code">        specialtyRepository.deleteById(id);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Concrete service <a id="_idIndexMarker193"/>methods are very simple in nature and concierge any calls to downstream repository methods. We will add a similar service interface and concrete implementation for <strong class="source-inline">Vet</strong> as <strong class="source-inline">VetService</strong> and <strong class="source-inline">VetServiceImpl</strong>.</p>
			<p>In the next section, we will focus our attention on creating a small command-line utility to perform common CRUD operations in the <strong class="source-inline">pet-clinic</strong> database. </p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Performing basic CRUD operations</h2>
			<p>To use services and repositories defined in previous sections and to perform basic CRUD operations <a id="_idIndexMarker194"/>on the entities, we can create a simple utility. We can create a new package called <strong class="source-inline">com.packtpub.micronaut.utils</strong> to define <strong class="source-inline">PetClinicCliClient</strong>:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class PetClinicCliClient {</p>
			<p class="source-code">    private final VetService vetService;</p>
			<p class="source-code">    private final SpecialtyService specialtyService;</p>
			<p class="source-code">    public PetClinicCliClient(VetService vetService, </p>
			<p class="source-code">                              SpecialtyService </p>
			<p class="source-code">                              specialtyService) {</p>
			<p class="source-code">        this.vetService = vetService;</p>
			<p class="source-code">        this.specialtyService = specialtyService;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // …</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">PetClinicCliClient</strong> injects <strong class="source-inline">VetService</strong> and <strong class="source-inline">SpecialtyService</strong> using the constructor method. These services will then be used to perform various database operations on the <strong class="source-inline">vets</strong>, <strong class="source-inline">specialties</strong>, and <strong class="source-inline">vet_specialties</strong> tables.</p>
			<h3>Performing read/fetch operations</h3>
			<p>We can <a id="_idIndexMarker195"/>define a simple utility method in <strong class="source-inline">PetClinicCliClient</strong> that can call <strong class="source-inline">VetService</strong> to fetch all vets. Moreover, since a vet can have multiple specialties, fetching a vet will fetch from the specialties table as well:</p>
			<p class="source-code">protected void performFindAll() {</p>
			<p class="source-code">    List&lt;Vet&gt; vets;</p>
			<p class="source-code">    try {</p>
			<p class="source-code">        vets = (List&lt;Vet&gt;) vetService.findAll();</p>
			<p class="source-code">        … iterate on vets</p>
			<p class="source-code">    } catch (Exception e) {</p>
			<p class="source-code">        log.error("Exception: {}", e.toString());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">performFindAll()</strong> method fetches all vets along with their specialties from the database.</p>
			<h3>Performing a save operation</h3>
			<p>We will <a id="_idIndexMarker196"/>save a vet with a specialty in <strong class="source-inline">PetClinicCliClient</strong>:</p>
			<p class="source-code">protected Vet performSave() {</p>
			<p class="source-code">    Vet vet = initVet();</p>
			<p class="source-code">    Vet savedVet = null;</p>
			<p class="source-code">    try {</p>
			<p class="source-code">        savedVet = vetService.save(vet);</p>
			<p class="source-code">    } catch (Exception e) {</p>
			<p class="source-code">        log.error("Exception: {}", e.toString());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return savedVet;</p>
			<p class="source-code">}</p>
			<p class="source-code">private Vet initVet() {</p>
			<p class="source-code">    Vet vet = new Vet();</p>
			<p class="source-code">    vet.setFirstName("Foo");</p>
			<p class="source-code">    vet.setLastName("Bar");</p>
			<p class="source-code">    Specialty specialty = new Specialty();</p>
			<p class="source-code">    specialty.setName("Baz");</p>
			<p class="source-code">    vet.getSpecialties().add(specialty);</p>
			<p class="source-code">    return vet;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">initVet()</strong> method <a id="_idIndexMarker197"/>initializes a new vet with a specialty, which is then used by the <strong class="source-inline">performSave()</strong> method to persist this object to database tables.</p>
			<h3>Performing a delete operation</h3>
			<p>In <strong class="source-inline">PetClinicCliClient</strong>, we <a id="_idIndexMarker198"/>will define a delete method to delete a vet (along with their specialties):</p>
			<p class="source-code">protected void performDelete(Vet vet) {</p>
			<p class="source-code">    try {</p>
			<p class="source-code">        vetService.delete(vet.getId());</p>
			<p class="source-code">    } catch (Exception e) {</p>
			<p class="source-code">        log.error("Exception: {}", e.toString());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">performDelete()</strong> method <a id="_idIndexMarker199"/>delegates a call to <strong class="source-inline">VetService</strong>, which then calls the repository to finally delete the vet from the database.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Wrapping up</h2>
			<p>To perform <strong class="source-inline">PetClinicCliClient</strong> CRUD operations, we will <a id="_idIndexMarker200"/>add the following code logic to <strong class="source-inline">Application.java</strong>:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class Application {</p>
			<p class="source-code">    private final PetClinicCliClient petClinicCliClient;</p>
			<p class="source-code">    public Application(PetClinicCliClient </p>
			<p class="source-code">     petClinicCliClient) {</p>
			<p class="source-code">        this.petClinicCliClient = petClinicCliClient;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Micronaut.run(Application.class, args);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @EventListener</p>
			<p class="source-code">    void init(StartupEvent event) {</p>
			<p class="source-code">        petClinicCliClient.performDatabaseOperations();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When we run our application, the aforementioned <strong class="source-inline">@EventListener</strong> will invoke <strong class="source-inline">PetClinicCliClient</strong> to perform various database operations. </p>
			<p>In this <a id="_idIndexMarker201"/>section, we integrated with a relational database using MyBatis. We covered how to define entities, repositories, and services, and lastly, we exhibited basic CRUD operations through a utility. In the next section, we will explore integration with a NoSQL database in the Micronaut framework.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Integrating with a NoSQL database (MongoDB)</h1>
			<p><strong class="bold">MongoDB</strong> is a <a id="_idIndexMarker202"/>document-based database and it stores the data in JSON or BSON format. Data is stored in key-value pairs, similar to a JSON object. MongoDB is engineered <a id="_idIndexMarker203"/>in a scale-out fashion and it is recommended to use it when the volume and structure of data are agile and growing very rapidly. There are a few key terms in contrast to a relational database:</p>
			<ul>
				<li><strong class="bold">Database</strong>: A database<a id="_idIndexMarker204"/> in MongoDB is much similar to a database in a relational database.</li>
				<li><strong class="bold">Table</strong>: A collection (of documents) is much similar to a table<a id="_idIndexMarker205"/> in a relational database.</li>
				<li><strong class="bold">Row</strong>: A BSON or JSON document will be a close analogy to a row<a id="_idIndexMarker206"/> in a relational database.</li>
			</ul>
			<p>In order to do hands-on work, we will continue with the <strong class="source-inline">pet-clinic</strong> application and add a new microservice, that is, <strong class="source-inline">pet-clinic-reviews</strong>. This microservice will be responsible for managing vet reviews. As reviews could grow rapidly and a schema to store a review could change, we will prefer to store this data in MongoDB: </p>
			<p class="source-code">{ </p>
			<p class="source-code">    "_id" : ObjectId("5f485523d0cfa84e00963fe4"), </p>
			<p class="source-code">    "reviewId" : "0ee19b1c-ec8e-11ea-adc1-0242ac120002", </p>
			<p class="source-code">    "rating" : 4.0, </p>
			<p class="source-code">    "comment" : "Good vet in the area", </p>
			<p class="source-code">    "vetId" : 1.0, </p>
			<p class="source-code">    "dateAdded" : ISODate("2020-08-28T00:51:47.922+0000")</p>
			<p class="source-code">}</p>
			<p>The preceding <a id="_idIndexMarker207"/>JSON document depicts a review stored in MongoDB.</p>
			<p>In the next section, we will get started with setting up the <strong class="source-inline">pet-clinic-reviews</strong> schema in MongoDB.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Creating a vet-reviews collection in MongoDB</h2>
			<p>For <a id="_idIndexMarker208"/>the <strong class="source-inline">pet-clinic-reviews</strong> microservice, we will create a database and collection in the MongoDB instance:</p>
			<ol>
				<li value="1">Open <a id="_idIndexMarker209"/>Studio 3T or any other preferred GUI for MongoDB.</li>
				<li>Connect <a id="_idIndexMarker210"/>to your localhost instance or any other preferred instance (such as MongoDB Atlas).</li>
				<li>Under <strong class="bold">Databases</strong>, add a new database: <strong class="source-inline">pet-clinic-reviews</strong>.</li>
				<li>In the aforementioned database, we will create a new collection: <strong class="source-inline">vet-reviews</strong>.</li>
				<li>To ingest some dummy data into this collection, use the import option to import data (CSV or JSON) from <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter02/micronaut-petclinic/pet-clinic-reviews/src/main/resources/db</a>.</li>
			</ol>
			<p>After finishing setting up the schema, we will turn our attention to working on the Micronaut project next.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Generating a Micronaut application for the pet-clinic-reviews microservice</h2>
			<p>In order <a id="_idIndexMarker211"/>to generate boilerplate source code for the <strong class="source-inline">pet-clinic-reviews</strong> microservice, we <a id="_idIndexMarker212"/>will use <a id="_idIndexMarker213"/>Micronaut Launch. It is an intuitive interface to generate boilerplate:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_2.10_B16585_Fixed.jpg" alt="Figure 2.10 – Using Micronaut Launch to generate the pet-clinic-reviews project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – Using Micronaut Launch to generate the pet-clinic-reviews project</p>
			<p>In Micronaut Launch, we will choose the following features (by clicking on the <strong class="bold">FEATURES</strong> button):</p>
			<ul>
				<li><strong class="bold">mongodb-sync</strong> (synchronous access to MongoDB) </li>
				<li><strong class="bold">logback</strong></li>
			</ul>
			<p>After specifying the aforementioned options, click on the <strong class="bold">GENERATE PROJECT</strong> button. A ZIP file will be downloaded onto your system. Unzip the downloaded source code into your workspace and open the project in your preferred IDE.</p>
			<p>In the <a id="_idIndexMarker214"/>following sections, we will <a id="_idIndexMarker215"/>dive deeper <a id="_idIndexMarker216"/>into how to integrate the <strong class="source-inline">pet-clinic-reviews</strong> microservice with MongoDB.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Configuring MongoDB in Micronaut</h2>
			<p>In the <a id="_idIndexMarker217"/>freshly created <strong class="source-inline">pet-clinic-reviews</strong> project, we would need to update the URI in <strong class="source-inline">application.yml</strong> to point to the <a id="_idIndexMarker218"/>correct instance of MongoDB. Furthermore, we <a id="_idIndexMarker219"/>will define two new custom properties – <strong class="source-inline">databaseName</strong> and <strong class="source-inline">collectionName</strong>:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  application:</p>
			<p class="source-code">    name: Pet Clinic Reviews</p>
			<p class="source-code">mongodb:</p>
			<p class="source-code">  uri: mongodb://mongodb:mongodb@localhost:27017/pet-clinic-reviews</p>
			<p class="source-code">  databaseName: pet-clinic-reviews</p>
			<p class="source-code">  collectionName: vet-reviews</p>
			<p>To use the aforementioned database and collection across the project, we can define a configuration class in a new package – <strong class="source-inline">com.packtpub.micronaut.config</strong>:</p>
			<p class="source-code">public class MongoConfiguration {</p>
			<p class="source-code">    @Value("${mongodb.databaseName}")</p>
			<p class="source-code">    private String databaseName;</p>
			<p class="source-code">    @Value("${mongodb.collectionName}")</p>
			<p class="source-code">    private String collectionName;</p>
			<p class="source-code">    public String getDatabaseName() {</p>
			<p class="source-code">        return databaseName;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public String getCollectionName() {</p>
			<p class="source-code">        return collectionName;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This will <a id="_idIndexMarker220"/>enable easy access to both <a id="_idIndexMarker221"/>the <strong class="source-inline">databaseName</strong> and <strong class="source-inline">collectionName</strong> properties across the project and we will not need to use <strong class="source-inline">@Value</strong>. Besides, since <a id="_idIndexMarker222"/>these properties are read-only, we will only define getters for these properties.</p>
			<p>Next, we will create an entity class to define the vet review object.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Creating the entity class</h2>
			<p>At the root level, add a new package called <strong class="source-inline">com.packtpub.micronaut.domain</strong>. This package <a id="_idIndexMarker223"/>will contain the domain/entity for the vet review. We <a id="_idIndexMarker224"/>can define the following POJO to represent a vet review:</p>
			<p class="source-code">public class VetReview {</p>
			<p class="source-code">    private String reviewId;</p>
			<p class="source-code">    private Long vetId;</p>
			<p class="source-code">    private Double rating;</p>
			<p class="source-code">    private String comment;</p>
			<p class="source-code">    private LocalDate dateAdded;</p>
			<p class="source-code">    @BsonCreator</p>
			<p class="source-code">    @JsonCreator</p>
			<p class="source-code">    public VetReview(</p>
			<p class="source-code">            @JsonProperty("reviewId")</p>
			<p class="source-code">            @BsonProperty("reviewId") String reviewId,</p>
			<p class="source-code">            @JsonProperty("vetId")</p>
			<p class="source-code">            @BsonProperty("vetId") Long vetId,</p>
			<p class="source-code">            @JsonProperty("rating")</p>
			<p class="source-code">            @BsonProperty("rating") Double rating,</p>
			<p class="source-code">            @JsonProperty("comment")</p>
			<p class="source-code">            @BsonProperty("comment") String comment,</p>
			<p class="source-code">            @JsonProperty("dateAdded")</p>
			<p class="source-code">            @BsonProperty("dateAdded") LocalDate dateAdded) {</p>
			<p class="source-code">        this.reviewId = reviewId;</p>
			<p class="source-code">        this.vetId = vetId;</p>
			<p class="source-code">        this.rating = rating;</p>
			<p class="source-code">        this.comment = comment;</p>
			<p class="source-code">        this.dateAdded = dateAdded;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // ... getters and setters</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">@BsonCreator</strong> and <strong class="source-inline">@JsonCreator</strong> piggyback on the class constructor to map an object of <strong class="source-inline">VetReview</strong> to the corresponding BSON or JSON document. This will come in handy while <a id="_idIndexMarker225"/>fetching or storing a document <a id="_idIndexMarker226"/>from MongoDB and therefore mapping it to a Java object.</p>
			<p>Next, we will focus our attention on how to create the data access repository for <strong class="source-inline">VetReview</strong>.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Creating a data access repository</h2>
			<p>To manage access to the <strong class="source-inline">vet-reviews</strong> collection, we will <a id="_idIndexMarker227"/>create a repository. We can add <strong class="source-inline">com.packtpub.micronaut.repository</strong> to contain this repository class.</p>
			<p>To abstract out all the methods that the repository will expose, we can declare an interface:</p>
			<p class="source-code">public interface VetReviewRepository {</p>
			<p class="source-code">    List&lt;VetReview&gt; findAll();</p>
			<p class="source-code">    VetReview findByReviewId(String reviewId);</p>
			<p class="source-code">    VetReview save(VetReview vetReview);</p>
			<p class="source-code">    void delete(String reviewId);</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">VetReviewRepository</strong> outlines essential operations supported in this repository. </p>
			<p>We will need to<a id="_idIndexMarker228"/> provide a concrete implementation for the <strong class="source-inline">VetReviewRepository</strong> interface in the <strong class="source-inline">com.packtpub.micronaut.repository.impl</strong> package:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class VetReviewRepositoryImpl implements VetReviewRepository {</p>
			<p class="source-code">    private final MongoClient mongoClient;</p>
			<p class="source-code">    private final MongoConfiguration mongoConfiguration;</p>
			<p class="source-code">    public VetReviewRepositoryImpl(MongoClient mongoClient,</p>
			<p class="source-code">     MongoConfiguration mongoConfiguration) {</p>
			<p class="source-code">        this.mongoClient = mongoClient;</p>
			<p class="source-code">        this.mongoConfiguration = mongoConfiguration;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public List&lt;VetReview&gt; findAll() {</p>
			<p class="source-code">        List&lt;VetReview&gt; vetReviews = new ArrayList&lt;&gt;();</p>
			<p class="source-code">        getCollection().find().forEach(vetReview -&gt; {</p>
			<p class="source-code">            vetReviews.add(vetReview);</p>
			<p class="source-code">        });</p>
			<p class="source-code">        return vetReviews;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public VetReview findByReviewId(String reviewId) {</p>
			<p class="source-code">        return getCollection().find(eq("reviewId", </p>
			<p class="source-code">         reviewId)).first();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public VetReview save(VetReview vetReview) {</p>
			<p class="source-code">        getCollection().insertOne(vetReview).</p>
			<p class="source-code">         getInsertedId();</p>
			<p class="source-code">        return findByReviewId(vetReview.getReviewId());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void delete(String reviewId) {</p>
			<p class="source-code">        getCollection().deleteOne(eq("reviewId", </p>
			<p class="source-code">         reviewId));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private MongoCollection&lt;VetReview&gt; getCollection() {</p>
			<p class="source-code">        return mongoClient</p>
			<p class="source-code">                .getDatabase(mongoConfiguration.getDatabaseName())</p>
			<p class="source-code">                .getCollection(mongoConfiguration.getCollectionName(), VetReview.class);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">getCollection()</strong> method in this concrete class will get the database and collection from MongoDB. Saving to and deleting from this collection <a id="_idIndexMarker229"/>is straightforward, as shown previously. To find it based on a certain condition, we can use <strong class="source-inline">find()</strong> with <strong class="source-inline">eq()</strong>. <strong class="source-inline">eq()</strong> is a BSON filter defined in the MongoDB driver itself. </p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Creating a service for the entity</h2>
			<p>A service will <a id="_idIndexMarker230"/>encapsulate any business logic as well as downstream access to the <strong class="source-inline">vet-reviews</strong> collection (in MongoDB). We can declare an interface to abstract out core methods in a service. To contain a service, we should first create a package called <strong class="source-inline">com.packtpub.micronaut.service</strong> under the root package. </p>
			<p>The <strong class="source-inline">VetReviewService</strong> interface can then be declared as follows:</p>
			<p class="source-code">public interface VetReviewService {</p>
			<p class="source-code">    List&lt;VetReview&gt; findAll();</p>
			<p class="source-code">    VetReview findByReviewId(String reviewId);</p>
			<p class="source-code">    VetReview save(VetReview vetReview);</p>
			<p class="source-code">    void delete(String reviewId);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">VetReviewService</strong> interface will declare barebones methods supported by this service. To provide concrete<a id="_idIndexMarker231"/> implementation for these methods, we will create a <strong class="source-inline">VetServiceImpl</strong> class under the <strong class="source-inline">com.packtpub.micronaut.service.impl</strong> package:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class VetReviewServiceImpl implements VetReviewService {</p>
			<p class="source-code">    private final VetReviewRepository vetReviewRepository;</p>
			<p class="source-code">    public VetReviewServiceImpl(VetReviewRepository </p>
			<p class="source-code">      vetReviewRepository) {</p>
			<p class="source-code">        this.vetReviewRepository = vetReviewRepository;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public List&lt;VetReview&gt; findAll() {</p>
			<p class="source-code">        return vetReviewRepository.findAll();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public VetReview findByReviewId(String reviewId) {</p>
			<p class="source-code">        return </p>
			<p class="source-code">         vetReviewRepository.findByReviewId(reviewId);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public VetReview save(VetReview vetReview) {</p>
			<p class="source-code">        return vetReviewRepository.save(vetReview);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void delete(String reviewId) {</p>
			<p class="source-code">        vetReviewRepository.delete(reviewId);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Concrete <a id="_idIndexMarker232"/>implementations for these methods are essentially delegating the call to <strong class="source-inline">VetReviewRepository</strong>. However, for any future needs, these methods can be extended to contain any business logic, such as data validations or data transformation.</p>
			<p>In the next section, we will focus our attention on creating a small command-line utility to perform common CRUD operations on the <strong class="source-inline">pet-clinic-reviews</strong> collection.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Performing basic CRUD operations</h2>
			<p>In order <a id="_idIndexMarker233"/>to perform basic CRUD operations on the <strong class="source-inline">VetReview</strong> entity, we can create a simple utility. We can create a new package called <strong class="source-inline">com.packtpub.micronaut.utils</strong> to define <strong class="source-inline">PetClinicReviewCliClient</strong>:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">@Requires(beans = MongoClient.class)</p>
			<p class="source-code">public class PetClinicReviewCliClient {</p>
			<p class="source-code">    private final Logger log = LoggerFactory.getLogger</p>
			<p class="source-code">     (PetClinicReviewCliClient.class);</p>
			<p class="source-code">    private final VetReviewService vetReviewService;</p>
			<p class="source-code">    public PetClinicReviewCliClient(VetReviewService </p>
			<p class="source-code">      vetReviewService) {</p>
			<p class="source-code">        this.vetReviewService = vetReviewService;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This utility <a id="_idIndexMarker234"/>will inject <strong class="source-inline">VetReviewService</strong> using the constructor. We will delegate the CRUD calls via this service. </p>
			<h3>Performing read/fetch operations</h3>
			<p>We <a id="_idIndexMarker235"/>can define a simple utility method in <strong class="source-inline">PetClinicReviewCliClient</strong> that can call <strong class="source-inline">VetReviewService</strong> to fetch all vet reviews or a specific vet review:</p>
			<p class="source-code">protected void performFindAll() {</p>
			<p class="source-code">    List&lt;VetReview&gt; vetReviews = </p>
			<p class="source-code">     this.vetReviewService.findAll();</p>
			<p class="source-code">    … iterate over vetReviews</p>
			<p class="source-code">}</p>
			<p class="source-code">protected void performFindByReviewId(String reviewId) {</p>
			<p class="source-code">    VetReview vetReview = </p>
			<p class="source-code">     vetReviewService.findByReviewId(reviewId);</p>
			<p class="source-code">    log.info("Review: {}", vetReview);</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">performFindAll()</strong> will fetch all vet reviews in the collection, whereas <strong class="source-inline">performFindByReviewId()</strong> will fetch a specific review by <strong class="source-inline">reviewId</strong>.</p>
			<h3>Performing a save operation</h3>
			<p>We will save<a id="_idIndexMarker236"/> a vet review through a method in <strong class="source-inline">PetClinicReviewCliClient</strong>:</p>
			<p class="source-code">protected VetReview performSave() {</p>
			<p class="source-code">    VetReview vetReview = new VetReview(</p>
			<p class="source-code">            UUID.randomUUID().toString(),</p>
			<p class="source-code">            1L,</p>
			<p class="source-code">            3.5,</p>
			<p class="source-code">            "Good experience",</p>
			<p class="source-code">            LocalDate.now());</p>
			<p class="source-code">    return vetReviewService.save(vetReview);</p>
			<p class="source-code">}</p>
			<p>Though <a id="_idIndexMarker237"/>we are defining a vet review object in Java, the constructor in the <strong class="source-inline">VetReview</strong> entity will take care of mapping this object to <strong class="source-inline">BsonDocument</strong> and downstream code in <strong class="source-inline">VetReviewRepository</strong> will save this document to the <strong class="source-inline">vet-reviews</strong> collection.</p>
			<h3>Performing a delete operation</h3>
			<p>In <strong class="source-inline">PetClinicReviewCliClient</strong>, we will<a id="_idIndexMarker238"/> define a delete method to <strong class="source-inline">delete</strong> a vet review:</p>
			<p class="source-code">protected void performDelete(VetReview vetReview) {</p>
			<p class="source-code">    vetReviewService.delete(vetReview.getReviewId());</p>
			<p class="source-code">}</p>
			<p>It is a <a id="_idIndexMarker239"/>small method and it delegates the call to <strong class="source-inline">VetReviewService</strong> for deletion. <strong class="source-inline">VetReviewService</strong> further invokes the repository to delete the given vet review from the collection. </p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Wrapping up</h2>
			<p>In <strong class="source-inline">Application.java</strong>, we can <a id="_idIndexMarker240"/>call <strong class="source-inline">PetClinicReviewCliClient</strong> as a startup event, which can then exhibit basic CRUD operations on the <strong class="source-inline">vet-reviews</strong> collection: </p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class Application {</p>
			<p class="source-code">    private final PetClinicReviewCliClient </p>
			<p class="source-code">     petClinicReviewCliClient;</p>
			<p class="source-code">    public Application(PetClinicReviewCliClient </p>
			<p class="source-code">     petClinicReviewCliClient) {</p>
			<p class="source-code">        this.petClinicReviewCliClient = </p>
			<p class="source-code">         petClinicReviewCliClient;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        Micronaut.run(Application.class, args);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @EventListener</p>
			<p class="source-code">    void init(StartupEvent event) {</p>
			<p class="source-code">        petClinicReviewCliClient.</p>
			<p class="source-code">         performDatabaseOperations();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When we kickstart our application, the aforementioned <strong class="source-inline">@EventListener</strong> will invoke <strong class="source-inline">PetClinicReviewCliClient</strong> to perform database operations. </p>
			<p>In this <a id="_idIndexMarker241"/>section, we covered how to integrate a Micronaut application with MongoDB. We defined the entity, repository, and service to access the MongoDB database. Lastly, we exhibited CRUD operations through a light utility. </p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we covered various aspects of integrating a Micronaut application with relational as well as NoSQL databases. We explored different ways of persistence integration, that is, using ORM (Hibernate), a persistence framework (MyBatis), or a driver-based framework (MongoDB Sync). In each technique, we covered, in depth, how to define entities, relationships, repositories, and services. Each microservice defined a simple command-line utility to exhibit common CRUD operations. </p>
			<p>This chapter has given us the skills to cover almost all the data access aspects in Micronaut. In the rest of the book, we will further explore and use these skills and learnings by doing more hands-on exercises and covering other aspects of the Micronaut framework. </p>
			<p>In the next chapter, we will work on the web layer of the <strong class="source-inline">pet-clinic</strong> application, defining various REST endpoints in all the microservices.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Questions</h1>
			<ol>
				<li value="1">What is an <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) framework?</li>
				<li>What is Hibernate?</li>
				<li>How can you define an entity using Hibernate in Micronaut?</li>
				<li>How can you map a one-to-one relationship using Hibernate in Micronaut?</li>
				<li>How can you map a one-to-many or many-to-one relationship using Hibernate in Micronaut?</li>
				<li>How can you map many-to-many relationships using Hibernate in Micronaut?</li>
				<li>How can you perform CRUD operations using Hibernate in Micronaut?</li>
				<li>How can you integrate with a relational database using MyBatis in Micronaut?</li>
				<li>How can you define MyBatis mappers in Micronaut?</li>
				<li>How can you perform CRUD operations using MyBatis in Micronaut?</li>
				<li>How can you integrate with a NoSQL (MongoDB) database in Micronaut? </li>
				<li>How can you perform CRUD operations in MongoDB in Micronaut?</li>
			</ol>
		</div>
	</body></html>