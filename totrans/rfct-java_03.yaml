- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Smells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The title of this chapter should be self-explanatory or perhaps sounds disgusting,
    but I think it’s important to explain what is meant by the term *code smell*.
    The sensation is similar to when you open the refrigerator and a strange odor
    hits your nose, something that shouldn’t be there. A bad smell doesn’t necessarily
    indicate a problem, but it’s worth taking a look, just in case. There might be
    an issue, or there might not be, but ignoring it is not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: In our code base, it’s the same. A code smell is a potential problem, a situation
    in the code that makes us wrinkle our noses. They are very tangible and observable
    situations, recurring patterns in our projects. They indicate that there is or
    could be something that needs to be fixed as soon as possible before the problem
    becomes even bigger. Just like bad code in general, smelly code can lead to widespread
    inefficiency, limited code extensibility, and comprehension, as well as performance
    issues and potential bugs.
  prefs: []
  type: TYPE_NORMAL
- en: We need to learn how to recognize and avoid code smells; it’s much easier to
    produce them than one might think, given how absorbed we are in tasks and deadlines.
    The important thing is, once again, to take the time to review our work and identify
    potential problems, the bad smells that arise from our lines of code. Over time,
    with practice and experience, you’ll build a mental compass that points out coding
    pitfalls like a seasoned treasure hunter unearthing hidden gems. Sometimes, it
    will guide you even before you’ve finished crafting your code.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of code smells that have already been cataloged by our *developer
    ancestors*; I don’t think it’s appropriate to list them all here. I’ll tell you
    about the ones that I believe are the most common to encounter and produce. The
    selection has been made based on purely subjective criteria, so feel free – in
    fact, I recommend it – to delve deeper into the *Further reading* section. Many
    of these code smells are related to **clean code** and the **SOLID principles**.
    If you happened to skip the previous chapter, it might be a good idea to go back
    and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with duplicated code, the nuisance of almost all code bases. It’s
    often caused by the developer’s temptation to meet deadlines by resorting to the
    ultimate shortcut: copy and paste. We’ll then move on to long methods and large
    classes. It’s truly disheartening when you encounter a bug on line number *4215*
    of a class, not because of the bug itself, but due to the humongous number of
    lines the class contains!'
  prefs: []
  type: TYPE_NORMAL
- en: Then, I’ll show you that `switch` statements can also be a problem when they
    are repeated; a typical situation that object-oriented programming can easily
    solve! When discussing object-oriented programming, why not represent the concepts
    of our domain through dedicated objects rather than rely on language primitives?
    There’s an anti-pattern called **Primitive Obsession** and we’ll tackle it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to large classes, there are classes or methods that heavily rely
    on the methods of others; in other words, they just can’t mind their own business!
    We’ll explore what **feature envy** methods are and how to address the potential
    harm they cause. We’ll also discuss two anti-patterns closely related to code
    changes and intertwined with each other: **divergent change** and **Shotgun Surgery**.
    Depending on where and how many changes we need to make in our code when introducing
    new features or making modifications in general, we may encounter one or the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we’ll talk about the so-called **god object**; this anti-pattern
    is a bit like that friend of yours who insists on doing everything, taking all
    the responsibilities; but then everyone relies on them for everything, and it’s
    too much for them. Too many responsibilities should not be assigned to a single
    entity, right? I’ll tell you what’s wrong with this and how to try to solve the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive Obsession
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middle Man
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message Chains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature envy methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Divergent change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shotgun Surgery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: God object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned before, code smells are, at the end of the day, smells. Just as
    a bad odor in the fridge doesn’t necessarily indicate a problem with your food
    (think of gorgonzola cheese!), a bad smell in your code doesn’t necessarily indicate
    a problem. However, there is a potential problem that is worth considering. In
    my view, the most important thing is to be aware of what we have in our code bases.
    We shouldn’t perceive every code smell as the most urgent thing in the world because
    it probably isn’t. However, it is crucial not to underestimate them because by
    ignoring one code smell after another, we end up with code bases that are either
    unmaintainable or maintainable at an excessively high cost. This applies not only
    in economic terms but also to personal frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicated code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with what Martin Fowler calls the *stink parade* (I can’t help but
    mention it because the term cracks me up) with duplicated code. Duplicated code
    is intuitively a bad smell, and our software engineer instincts will soon learn
    to reject it as something that harms us. Let’s try to list a few reasons why duplicated
    code is harmful to the health of our code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, copy-pasting code is the first thing to avoid, at least in 99% of cases.
    Taking a piece of code from one class and using it exactly as it is in another
    is easily avoidable. By pausing for a moment to reflect, it’s highly likely that
    we can extract a method to use instead of the duplicated code. Centralizing the
    code in this way ensures better code maintainability. Just think about how nightmarish
    it would be to maintain (e.g., fixing a bug in) every single piece of copy-pasted
    code scattered throughout the code base (and the scariest part is that the developers
    might not be aware of all the instances of duplication). A nightmare. A nightmare
    that is a reality in many places, believe me.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, duplicated code exists because the programmer doesn’t have a clear
    understanding of what they are doing, they don’t own the source, or they want
    to change it. In other words, they struggle to grasp the code they are working
    on. As mentioned before, it’s useful to do some refactoring to try to better understand
    the code we’re working with. It’s likely that even with this simple (figuratively
    speaking) approach, you’ll already be able to handle what you’re working on more
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In general, code quality is compromised by duplicated code; the code becomes
    longer and sometimes less readable. Sometimes it’s impossible to refactor a duplicate
    code block, but the aim should be to decrease technical debt as much as possible.
    It helps to make your code of higher quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic form of duplicated code occurs when you come across the same
    expression in two methods within the same class. To solve this, all you need to
    do is extract a method and call that piece of code from both locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous snippet presents some repetitions, as you can easily spot. We’ll
    extract a `printDetails` method and use it twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These days, IDEs are perfectly capable of flagging duplicate code (for example,
    in IntelliJ IDEA, it’s a built-in feature) and suggesting a small refactoring
    to extract the method. We will discuss how to get the most out of IDEs and other
    tools later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now move on to long methods.
  prefs: []
  type: TYPE_NORMAL
- en: Long methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very typical code smell, very sneaky, and often underestimated. Even
    though it may seem like a trivial topic to address, I’d like to share some thoughts.
  prefs: []
  type: TYPE_NORMAL
- en: Code is read much more than it’s written, so taking a little extra time to shorten
    a method can pay off big time. When you have to modify a long method, you have
    to read and comprehend every single line of code to make the change safely. In
    this case, we’re burdened with loading all the work this method does into our
    brains just to understand what’s happening, let alone have the ability to modify
    any part of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long code is very likely doing more than one thing: according to the **Single
    Responsibility Principle**, a method should ideally focus on doing just one thing.
    It’s almost impossible to achieve that when you have so many lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: It would be useful to know when “long” becomes “too long.” 10 lines? 20? 100?
    It’s hard to establish a fixed rule. It’s a bit like saying when a cake is too
    sweet or when pasta is too salty; we instinctively recognize the excesses, but
    we probably couldn’t agree on the exact numbers.
  prefs: []
  type: TYPE_NORMAL
- en: My advice here is to follow your gut and, above all, reach a consensus within
    the team. For example, you can decide that 20 lines are the maximum limit or that
    it shouldn’t exceed one screen height (of course, it depends on screen resolution,
    font size, etc.). Another cool thing would be to use standards for formatting,
    even through the use of automatic tools that take care of it; more on this later
    in the book. In short, it depends. It could also be the case that a method is
    long but only contains configurations, things that are very readable and don’t
    require much effort to understand. In that case, you might even not care about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, I want to bring up a heuristic tip from Martin Fowler’s *Refactoring*:
    whenever you feel the need to insert a comment in the code to explain it, write
    a method instead. The method will contain the code you intended to comment on,
    but the name of the function itself will explain the intention behind the code,
    rather than its functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: The following are some small tricks that help in the case of long methods.
  prefs: []
  type: TYPE_NORMAL
- en: Replace temporary variables with query methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time, extracting a method or a function from your long method should
    do the trick; look for parts of the function that go well together and create
    a fresh one. Sometimes you have a function with many parameters and temporary
    variables and they could become obstacles to the extraction process; extracting
    a function would lead to passing a lot of parameters to the extracted method,
    and that would be as unreadable as before. So, it could be useful to replace those
    temporary variables with a query function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, the `basePrice` variable is used to store the result
    of a pricing operation and then again to calculate the final price, which is discounted
    by 50% for child passengers. It could be a good idea to remove the temporary variable
    and inline the calculation, writing a method (query function) called `calculateBasePrice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll look at parameter objects.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It could also happen that you have functions or methods with a long or “repeated”
    signature, such as the `calculateFinalPrice` and `discountPrice` methods in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we have a couple of methods with the same signature, repeated.
    It’s also crucial to notice that in this case, the `amount` and `currency` parameters
    must always go together, as they represent a price. A cool solution is to pass
    to these methods a “parameter object” or a “request object” (I’ve heard it being
    called in many ways): that is, a complex object representing all the needed parameters
    that make sense together. Given that amount and currency represent a price, why
    don’t we create a `Price` class? We do this in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, let’s replace a function/method with a command.
  prefs: []
  type: TYPE_NORMAL
- en: Replace a function or method with a command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve tried to extract functions and create parameter objects but you’re
    still left with an excessive number of temporary variables and parameters, another
    thing you can do is to replace the function with a command. Let’s suppose you
    have the following method, which takes a lot of parameters and is very long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we implement a `PriceCalculator` object, everything becomes clearer; in
    this way, you have replaced a function with a command. All the parameters are
    passed at the beginning, of the constructor. You can reuse this component by passing
    all the parameters every time (and actually, this makes your component more reusable).
    The logic of the method is executed in the `calculatePrice()` method, which doesn’t
    take any parameters; readability is also improved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When dealing with code extraction, which is to be put in a different method,
    it can be hard, sometimes, just to identify the code you want to separate. How
    can you spot the chunks of code to extract? A handy approach is to check for comments.
    They often indicate these types of meaningful sections. If you come across a block
    of code with a comment explaining its purpose, you can replace it with a method
    named after the comment (and then you can decide whether to keep the comments
    or not). Even a single line is worth extracting if it requires an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Decompose conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are also other indicators of code that need to be extracted; for instance,
    conditionals and loops also provide useful hints for extractions. If you have
    a conditional expression, such as the `if` in the following snippet, it can be
    handy to apply the “decompose conditional” technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet calculates the price of a plane seat depending on the row
    numbers (it probably doesn’t make any sense, but it’s useful for this example!).
    If the seat is located in the first 30 lines, we have to pay a different fare.
    There is an `if`, which is quite simple here, but you have to imagine this in
    a real-world scenario, where conditions can be much more complex and involve many
    more parameters and objects. In the refactored snippet, we isolated some logic,
    including the condition, to improve readability and potentially reuse the code
    (and potentially, in the future, you could externalize the condition calculations,
    by doing requests to third-party systems or even rule engines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But conditions are not only *ifs*, but also *switches* (which are, in a way,
    *ifs* in disguise). If you encounter a lengthy switch statement, transform each
    case into a separate function call using the “extract function” approach, which
    we covered in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: Split loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, loops can also become a problem; for instance, it is common to have
    a loop body that does more than one thing. In this case, you should create a distinct
    method for the loop itself and the code within it. If you struggle to find a suitable
    name for the extracted loop, it might be because it’s performing two distinct
    tasks. In such cases, don’t hesitate to use the following technique, called **split
    loop**, to separate the tasks into different parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous snippet is made of a very basic `for` loop. Even in these two
    lines, a problem is hidden! In fact, you have two different things done in the
    same `for` loop. I can already hear you saying, “*Come on, it’s just two lines!*”
    but – again – I’m simplifying things as much as possible here. Reality is often
    more complex, but the problem is the same. Refactoring the code by splitting the
    loop makes the code clearer and more reusable; should you move part of the logic
    elsewhere, now it should be simpler (we could also use Java streams, but we want
    to keep it as simple as possible):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Lots of programmers don’t like this refactoring because it makes you run the
    loop twice. But please remember that we’re separating refactoring from optimization.
    First, get your code nice and clean, then you can optimize it. If looping through
    a list is causing a slowdown, you can easily combine the loops again. But honestly,
    going through a big list is usually not the real issue, and splitting the loops
    can actually open up opportunities for better optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Large classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another very common smell. How many times have you found yourself working
    on classes with thousands of lines? It’s nobody’s fault, it’s just that classes
    start small and, very understandably, gradually end up incorporating more information
    and functionality. There’s nothing wrong with that; the important thing is to
    realize it and refactor it.
  prefs: []
  type: TYPE_NORMAL
- en: A practical way to notice that a class is too big is when there are too many
    fields (instance variables). If there are too many fields in a class, it’s likely
    doing too many things; besides having too many responsibilities, often in this
    case, code duplication becomes a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create (extract) a new class to group several variables together. Pick
    the variables that naturally go hand in hand and put them in a component. For
    instance, if you see a bunch of parameters called something such as `priceAmount`
    and `priceCurrency`, they are probably meant to be part of the same component.
    In general, if you notice common prefixes or suffixes among a subset of variables
    in a class, it indicates the possibility of creating a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Order` class contains numerous fields that each represent distinct properties
    of the order. However, if you look closer, it becomes evident that some of these
    fields can be logically “grouped” together, as they belong to specific aspects
    of an order property. For instance, the `name` and `surname` fields can be seen
    as representing the buyer’s information (to simplify the concept). Similarly,
    the `streetName`, `streetType`, and `streetDirection` fields are related to the
    shipping address for the order, while `priceAmount` and `priceCurrency` provide
    information about the selling price.
  prefs: []
  type: TYPE_NORMAL
- en: Given these insights, it is possible to restructure the `Order` class by grouping
    certain fields to create new **entities**. These entities can (*should*) be reused
    effectively throughout the project, enhancing code organization and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The restructured `Order` class should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it should have all of the previous fields “distributed” among different
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If using inheritance makes sense for the component, you’ll likely find that
    techniques such as extracting a superclass or replacing `type` with subclasses
    (also known as extracting a subclass) are often simpler to apply. The following
    is a very common situation; we have a class that takes a `type` parameter because,
    depending on its value, the class has to behave slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'I bet some instances of `if` are hiding inside the `Transport` class! But object-oriented
    programming comes with inheritance, so why don’t we use it? Take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this refactored code snippet, we have two major improvements. We changed
    the class of `type` from `String` to an enum called `TransportType`; this allows
    us to perform the subsequent switch statement in a safer way because we’ll be
    warned (by an IDE, likely) if we are not considering some of the possible values
    of type. Then, we created a specific class for each type of transport, avoiding
    mixing things up; of course, all of these classes will implement the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from having a bunch of instance parameters, a class that is too large
    is generally not good; it’s a breeding ground for duplicated code, unclear code,
    confusion, and despair. A simple, yet effective, approach to start with is to
    eliminate repetitions within the class itself. Simply put, you can look for code
    that makes sense to group together and write standalone methods for them. Shorten
    the methods within a very large class. Maybe the number of methods will increase,
    but you’ll likely realize that you can move some of them to a separate class,
    if those methods make sense together and concern a single aspect. In very large
    classes, it’s very common to have duplicated code or similar repetitions. At that
    point, from a 100-line method, we can extract two or three 10-line methods, with
    a few extra lines to invoke them. The most difficult part is probably understanding
    how to split the code. Here’s a very simple tip that often works: the *clients*
    of such a class can often provide valuable hints for breaking it down. Take a
    closer look and perform some static analysis of the code (that is, open the code
    and go through it. There are also automatic tools for doing this; we’ll meet them
    later) to see how clients utilize only a portion of the class’s features. Each
    distinct subset of features can potentially become a separate class.'
  prefs: []
  type: TYPE_NORMAL
- en: Switches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To put it simply, the `switch` statement itself is not problematic per se. In
    fact, we find it quite elegant and self-explanatory. Many programming languages
    even offer more advanced forms of `switch` statements that can use more complex
    code as their foundation. They can simplify code and replace ugly nested ifs.
    I must admit, we have a soft spot for the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: However, the issue arises when we encounter *repeated* switches in object-oriented
    programming. We consider this to be problematic for several reasons. The `switch`
    statements violate the `case` statement in each section. This leads to modifying
    existing code, which goes against the principle. Furthermore, switches can be
    challenging to maintain. As new requirements emerge, the `switch` statements can
    grow in complexity, making the code harder to manage. Another issue with switches
    is the potential for redundant code in certain cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution in this case is quite simple – use polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I assume you’re already familiar with these characters and you know what a
    *lightsaber* is. If not, I highly recommend Googling them and watching those movies
    right away. The previous piece of code could be refactored into the following
    classes/methods, in which we designed an abstract class, `SwCharacter`, that will
    be extended for each specific character. The `printLightSaberColor` method will
    take a “generic” `SwCharacter` and call the relative implementation of the `getLightSaberColor`
    method. In the following code, we’re going to omit some boilerplate code, such
    as constructors or other getters, for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that in this particular case, we increased the number
    of code lines. However, in our opinion, this is highly acceptable as we improved
    readability. In the examples I’ve given you, I tried to keep things simple by
    using basic stuff such as `int` or `String` most of the time. But that’s not always
    the best approach. It depends. Sometimes, relying too much on the language’s primitive
    types can lead to a code smell called **Primitive Obsession**.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Obsession
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what Primitive Obsession is and how to deal with it, let’s remember
    what primitive types are in a programming language. Primitive types are like the
    ready-made types that come with the language. You can think of them as straight
    from the manufacturer. Each language has its own set of primitive types, and since
    we’re talking about Java here, let’s focus on how it works in Java.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a `java.lang.String` class. Although the `String` class is not technically
    a primitive data type, it’s given special treatment in the language, so you might
    consider it as one.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Obsession is when the code becomes too dependent on basic data types.
    It means that a simple value takes charge of the class logic and lacks type safety.
    In simpler terms, it’s a bad habit of using basic types to represent an object
    in a specific area of focus.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the example of representing a website’s URL. Usually, we store it
    as a string. However, the problem arises because a URL has more details and distinct
    characteristics than just being a simple string. It includes elements such as
    the scheme, query parameters, and protocol. When we store it as a string, we lose
    the ability to directly access these URL-specific components (the essential parts
    of the URL) without writing additional code. We could use `java.net.URL` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are often breeding grounds for this kind of issue. Take a telephone
    number, for example. It’s more than just a random assortment of characters. In
    many cases, a proper data type can provide consistent display logic when it needs
    to be shown in a user interface. Representing such types as strings creates a
    problem so common that they are sometimes referred to as *stringly* *typed* variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think about it, it is quite simple to solve the problem; it is necessary
    to replace the primitive(s) with objects. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This can become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you’re curious about how the `URL` class works, look at its documentation
    (the `java.net.URL` class is included in the Standard Java Library).
  prefs: []
  type: TYPE_NORMAL
- en: If you have a group of primitives that can go together, you can group them by
    extracting a class, like in the address example we covered in the *Large* *classes*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve dealt with Primitive Obsession, let’s tackle all those classes
    that have little desire to work and make others do all the work. This was just
    a playful way to say that we will talk about a smell called **middle man**.
  prefs: []
  type: TYPE_NORMAL
- en: Middle man
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The middle man is a code smell that occurs when we have a class or, in general,
    an object that does only one thing, and that thing is... delegating the work to
    someone else. We are not suggesting that a class should have only one method to
    be considered a "middle man". Rather, each of its methods should only invoke others.
    So, the question arises spontaneously: why keep a class in our codebase that does
    nothing? In fact, there is (almost never) a reason. Let’s delete this class or
    method and ensure that the client calls the “destination” directly. This way,
    we will eliminate unnecessary complexity and ensure that, when we modify or add
    features to the destination objects, we are not forced to also modify our middle
    man.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example, suppose we have a class structured like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A “client” method would use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily notice that the `getCity()` method serves solely as a proxy
    to the other class. So why not use the other class directly? Our example would
    then become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And so, we can eliminate the middle man composed of the `getCity()` method in
    the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: However, this refactoring can paradoxically lead to another code smell, the
    message chain!
  prefs: []
  type: TYPE_NORMAL
- en: Message chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **message chain** occurs when a client requests an object, which then requests
    another object, and so on. This makes all the objects dependent on the structure
    of the called objects, and a change in these objects would necessarily impact
    the entire chain of calls, at every point where they are made. Building upon the
    example from the previous section, we could have something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to hide the “delegate”, that is the method calling the other
    one(s). We could transform the previous example into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Where the chain of calls is hidden in the `getCityName()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Taken to the extreme, however, this refactoring can lead to the middle man smell!
    Have we ended up in a time loop like Christopher Nolan? The truth is, it depends.
    These refactorings must indeed be properly weighted, attempting to choose the
    lesser evil (also considering the possibility that perhaps the class modeling
    itself is flawed and might require changes in some way).
  prefs: []
  type: TYPE_NORMAL
- en: Opting for middle man instead of message chains offers the advantage of requiring
    fewer mocks during unit testing. Testing classes becomes challenging when you
    have to provide mocks not just for their immediate and indirect dependencies.
    Additionally, it aids in the separation of concerns. A code that possesses an
    *A* component and requires a *C* component should ideally remain unaware of the
    involvement of a *B* component. This contributes to better modularity. While the
    primary argument for message chains is the avoidance of writing boilerplate in
    the middle, and there might be cases where it makes sense, the general guideline
    should lean towards preferring the middle man.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing middle man over message chains aligns with the principles of the Law
    of Demeter, often summarized as “only talk to your direct dependencies.” This
    guideline encapsulates a design philosophy advocating for encapsulation and reduced
    coupling in object-oriented systems. We talked about the Law of Demeter in [*Chapter
    2*](B20912_02.xhtml#_idTextAnchor042).
  prefs: []
  type: TYPE_NORMAL
- en: Feature envy methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we try to break down our code base into components that make sense based
    on our use case and domain, we’re basically dividing the code into *zones*. One
    of the key things we need to be careful about is maximizing interactions within
    the zones and, conversely, minimizing interactions between different zones. **Feature
    envy** is like a warning sign in the code, describing when an object accesses
    another object’s fields to perform an operation instead of simply instructing
    the object on what to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, let’s consider a method that calculates a price based
    on a payment request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything seems fine until we realize that we need the order and some user
    information to calculate the price. That’s when we start writing its implementation
    and, for instance, we must retrieve the order related to the payment request;
    in the first lines of the method, we’ll write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Very likely, a user will be needed too. So, after fetching the order, we’ll
    probably add a line in which we also retrieve the user, because we need some information
    about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'From these objects, we’re going to take some specific properties that we need
    to complete the payment. For instance, we’ll write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we’re faced with a ton of finder/getter methods being called. It’s
    very common to find methods invoking tons of getter methods of other objects to
    retrieve or calculate some value. In this case, it’s also likely that your bean,
    your Java class, will have a lot of *collaborators*, that is, a lot of other classes
    injected in yours through the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In the most basic scenario, you can simply transfer the method you’re using
    from one class to another (and modify its name, if necessary). If only a portion
    of the method requires access to another object’s data, you can extract that specific
    part into a separate method. However, not all cases are straightforward; sometimes,
    a function relies on features from multiple modules, so it becomes a question
    of which module it should belong to. A rule of thumb (as suggested by Martin Fowler)
    is to determine the module that possesses most of the data and place the function
    there. This process is often facilitated by extracting methods to break down the
    function into smaller pieces that can be placed in different locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, even when this guideline is not applicable, you have the option
    to use the Strategy or Visitor patterns described in the book by the *Gang of
    Four*. However, providing a detailed explanation of these patterns is beyond our
    scope. For more in-depth explanations, you can refer to the *Further reading*
    section. The fundamental principle remains unchanged: grouping elements that undergo
    changes together. Typically, data and the corresponding behavior that relies on
    that data tend to change simultaneously, though exceptions exist. In such scenarios,
    relocating the behavior ensures that changes are consolidated in a single location.
    Strategies and Visitors offer a practical means of modifying behavior by isolating
    specific portions that require overriding, even though this approach introduces
    some additional indirection.'
  prefs: []
  type: TYPE_NORMAL
- en: Divergent change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As software engineers, we know our work product is soft and flexible. Once,
    a professor at university told us, “*We’re the only engineers who are asked to
    change the project many times, even when it’s done. Imagine doing that with a
    bridge. This is our strength and* *our curse.*”
  prefs: []
  type: TYPE_NORMAL
- en: As we know from the Agile philosophy, *change is good*, but it needs to be controlled
    and managed. Going back to code smells, we have divergent changes when we need
    to modify a certain class often, even though we’re touching seemingly unrelated
    aspects. Think of a class that handles the results of a search for transportation
    options like for a travel booking website (those where you put when you want to
    leave, when you want to return, where you want to go and they give you a bazillion
    options to choose from – planes, trains, buses and so on). At some point, we need
    to change the database the application relies on. Consequently, we modify class
    *X*. Then, we need to integrate a new type of transportation, and we must modify
    class *X* again. New payment method? Again, class *X* needs modification.
  prefs: []
  type: TYPE_NORMAL
- en: All these aspects are unrelated, but class *X* is always in the middle! Divergent
    change happens when a module (or a class, or a project) is frequently modified
    for various reasons, resulting in a mixing of different contexts in a single location.
    To enhance our programming experience, we can improve it by segregating these
    contexts into separate modules.
  prefs: []
  type: TYPE_NORMAL
- en: The most likely reason is that the **Single Responsibility Principle** has been
    violated. In general, we either have a flawed programming structure or we’ve gone
    overboard with copy and paste. Thus, it becomes necessary to create appropriate
    modules and move the methods accordingly. Sometimes it may be necessary to extract
    ad hoc methods (and perhaps relocate them) or even extract entire classes.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we come across a special situation where two aspects, mistakenly
    tangled up in a single class, naturally form a sequence. A classic example is
    when we fetch data from the database, process it, and then feed it to a function
    that uses it. In cases like these, we can use a refactoring technique called **split
    phase**. In this refactoring process, we break down a complex computation into
    two phases (or more). During the first phase, we calculate a result, and then
    we pass this result, along with some intermediate data structure, to the second
    phase for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the following code snippet: it retrieves some flight data
    array from a database, parses an element of that array to a double, then takes
    some of the output and uses it to perform further calculation... the point is
    that it does a lot of different things one after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be nice to refactor this code and make it a bit more readable and
    somehow modular, even if this term could be inappropriate when talking about a
    small set of code lines. Anyway, we’re going to split this code into phases, almost
    like it was a workflow: we’ll call `getFlightDataFromDatabase` (without splitting
    the result immediately; that is something that will be needed only in the next
    code line). The `flightData` string, of course, is not very handy (we’re assuming
    we cannot change the return type because we’re using a third-party library) so
    we’re going to use `parseFlightData` into a `FlightInfo` object, which handles
    the flight information in a very handy way. At the end, we’re going to finally
    implement `calculateTotalPrice`, using the `flightInfo` object. See how this code
    – even a four-line piece of code – can become much more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When the change you need is not in a single class you have to change often,
    but spread across the project, you’re forced to modify the code in a lot of different
    points. That’s when you have the code smell known as *Shotgun Surgery*.
  prefs: []
  type: TYPE_NORMAL
- en: Shotgun Surgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it might seem a bit violent at first, to me, the term seems also funny,
    to be honest; that’s why I really like it. Sometimes, I’ve heard it referred to
    as *shooting a fly with a bazooka.* It is, basically, the opposite of divergent
    change.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re dealing with Shotgun Surgery, it means you must make a bunch of
    changes in your code base just to tackle seemingly simple tasks. Frequently, you’ll
    find yourself altering code that appears quite similar, either directly copy-pasted
    or with a similar purpose. The term refers to the work of a surgeon, which is
    done very precisely, with a scalpel, in the least invasive way possible. Now replace
    the image of the scalpel with a shotgun and... well, you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be several examples or reasons that lead to Shotgun Surgery; let’s
    quickly go through some of them, so we can prevent the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copy and paste**: This is the first example that comes to mind; you’ve done
    some good old copy and pasting of code! This means, of course, that making changes
    to some of the copied code requires you to make those same changes to each and
    every copy. It’s pretty straightforward, really.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excessive layering**: Sometimes, our application tends to be too layered.
    For example, imagine a basic CRUD app that goes all out with multiple layers,
    including data transfer objects, data access objects, and domain objects. Every
    time you want to add a table to the database, you not only have to add stuff to
    all four layers but also deal with all the property bag objects within those layers.
    It’s another case of Shotgun Surgery. (But the world isn’t all black or white;
    there are many shades of gray. Sometimes, an application with well-defined layers
    helps to isolate concepts and responsibilities. So, be careful; I’m not saying
    that designing multiple layers in an architecture is inherently bad. You always
    have to find the right balance, just like in life!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited layering**: Just as sometimes there are too many layers in the design
    of an application, there are also times when responsibilities are excessively
    separated: one class for constants, another for static variables, and so on. Then,
    when you need to make a change, you find yourself having to touch them all! Has
    it ever happened to you? It happens to me quite often. And there you are again,
    using a shotgun in the operating room.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should care about these problems because changes become more time-consuming
    since you have to edit your code base in more places. *Merge conflicts* become
    more likely, as more people are touching the code in different locations, making
    collaborative projects more difficult. You’re also more likely to introduce bugs
    due to the cognitive load of remembering to change the code in multiple places.
    Additionally, you end up with more code because of knowledge duplication and the
    need for additional constructs to connect the different pieces. Lastly, the learning
    curve is higher for new team members as development becomes like a treasure hunt
    in navigating through the code base.
  prefs: []
  type: TYPE_NORMAL
- en: When you have your logic spread all over the code base, you could simply move
    your method(s) or your field(s) into the same class or module. By doing so, you
    make sure that related software elements are clustered together, making it easier
    to locate and comprehend the connections between them. All the relevant context
    would be consolidated in one place, enhancing encapsulation and enabling other
    parts of the software to be less reliant on the specifics of this module.
  prefs: []
  type: TYPE_NORMAL
- en: Another intriguing approach to tackle Shotgun Surgery is to employ inlining
    refactorings. In other words, it can be beneficial to merge methods or classes
    in order to consolidate poorly separated logic. This may result in a long method
    or a large class; I know we just said that this would be bad, but this would only
    be a temporary (but very useful) situation so that you can subsequently use extractions
    to break it down into more coherent pieces. Of course, we typically prefer small
    functions and classes in our code but don’t hesitate to create something large
    as an intermediate step toward reorganization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inlining a method means, basically, doing the opposite of extracting a method.
    Suppose we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You have created a separate class, with a static method, just to implement
    the VAT addition. Supposing that this method is used only once, this seems a bit
    too much; the suggestion here is simply to inline the content of the static method,
    avoiding creating a separate class, which would make the code a bit more difficult
    to read. You could simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Anyway, the real deal is to always keep Shotgun Surgery on your radar as you
    work. Keep asking yourself whether future maintenance programmers (which could
    also be your future self) will need a shotgun or a scalpel to make the anticipated
    changes. If the answer leans toward *shotgun*… then it’s high time you rethink
    your approach.
  prefs: []
  type: TYPE_NORMAL
- en: God object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the anti-patterns mentioned in this chapter (there are many more; I encourage
    you to delve into the *Further reading* section), perhaps the one called **god
    object** (or **god class**) is the one I most frequently come across. As the name
    suggests (I must say, in the world of refactoring and clean code, the level of
    naming is remarkable!), a god class is a negative coding practice characterized
    by a class that assumes an excessively considerable number of responsibilities.
    It manifests as a class that consolidates and oversees numerous objects, performing
    all tasks within the application. This anti-pattern violates the principle of
    keeping classes focused and modular, leading to poor maintainability and hindered
    code readability.
  prefs: []
  type: TYPE_NORMAL
- en: You may think that this may be a good pattern; also, the name can suggest something
    positive. Well, this is not the case, and we are about to see why.
  prefs: []
  type: TYPE_NORMAL
- en: God objects violate SOLID, especially the Single Responsibility Principle. God
    classes go completely against the Single Responsibility Principle by assuming
    an excessive number of responsibilities and lacking focus. As a result, engineers
    end up reinventing the wheel, duplicating code, and accumulating technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Because of god objects, your code will be more fragile. Due to the overwhelming
    responsibilities of a god class, it requires frequent updates, which significantly
    raises the chances of introducing breaking changes. Understanding the impact of
    modifications to a god class on the rest of the application can be challenging,
    if not impossible.
  prefs: []
  type: TYPE_NORMAL
- en: God objects are hardly testable. A class is easily testable, in general, when
    it is small, focused, and independent of other types. On the contrary, a god class
    operates in the opposite manner. Being a large, all-encompassing entity that controls
    and manages numerous other objects, it becomes tightly coupled to those types.
    Consequently, testing the god class becomes a daunting task due to its intricate
    setup and the necessity to stub or mock numerous dependencies just to instantiate
    it for testing purposes. You can often become aware you are writing a god object
    when it has too many *collaborators*, that is, too many other objects needed for
    the class itself to work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the main pain point. We always end up with this. A god object makes
    your code harder to read and understand. It is no wonder that the code within
    these classes becomes complex, considering their extensive responsibilities and
    interactions with several types. I am not (only) talking about cyclomatic complexity
    here; for example, relying on external dependencies that cause side effects and
    mutability. The cumulative effect of these complexities contributes to the overall
    cognitive complexity of the code, creating obstacles in understanding and reducing
    engineers’ productivity and performance.
  prefs: []
  type: TYPE_NORMAL
- en: The solution here is not unique, but the approach can be. It is quite easy to
    create a god object (especially in object-oriented programming) but it can be
    extremely hard to undo them. So, use the good old *divide et impera* technique
    (again, the Single Responsibility Principle) and split the class into smaller
    pieces; be guided by your domain; and group the common methods and properties
    in a class while keeping the classes loosely coupled. If classes or methods have
    a lot of code or functionality in them, break them into simple, manageable, testable
    classes and methods. Finally, delete or deprecate the god object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to spot some – not all – code smells. We covered
    the ones that I think are the most common. Some of them you’ll pick up instinctively
    and avoid them as you write code. We tackled duplicated code, long methods, large
    classes, and repeated switches. We also learned to avoid our obsession with primitive
    types (using string for everything is a strong temptation!) and looked at feature
    envy methods. Finally, we talked about divergent change and its opposite, Shotgun
    Surgery. Oh, and let’s not forget about the god object. This is just a partial
    selection of all the existing code smells out there, but I believe it’s a good
    starting point to steer clear of them.
  prefs: []
  type: TYPE_NORMAL
- en: A crucial condition to perform any kind of refactoring, especially god object
    refactoring, is good test coverage. In the next chapter, we are going to tackle
    this extremely important matter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Primitive Data** **Types**: [https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: [https://refactoring.guru/design-patterns/strategy](https://refactoring.guru/design-patterns/strategy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: [https://refactoring.guru/design-patterns/visitor](https://refactoring.guru/design-patterns/visitor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (1994). *Design
    Patterns: Elements of Reusable Object-Oriented Software*. Addison-Wesley Professional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code** **Smells**: [https://refactoring.guru/refactoring/smells](https://refactoring.guru/refactoring/smells)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
