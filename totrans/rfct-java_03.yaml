- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Code Smells
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码异味
- en: The title of this chapter should be self-explanatory or perhaps sounds disgusting,
    but I think it’s important to explain what is meant by the term *code smell*.
    The sensation is similar to when you open the refrigerator and a strange odor
    hits your nose, something that shouldn’t be there. A bad smell doesn’t necessarily
    indicate a problem, but it’s worth taking a look, just in case. There might be
    an issue, or there might not be, but ignoring it is not a good idea.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的标题应该是自解释的，或者可能听起来令人厌恶，但我认为解释一下“代码异味”这个词的含义很重要。这种感觉类似于当你打开冰箱时，一股奇怪的气味扑鼻而来，一些不应该存在的东西。坏气味并不一定表明有问题，但看看它总是值得的。可能有问题，也可能没有，但忽略它并不是一个好主意。
- en: In our code base, it’s the same. A code smell is a potential problem, a situation
    in the code that makes us wrinkle our noses. They are very tangible and observable
    situations, recurring patterns in our projects. They indicate that there is or
    could be something that needs to be fixed as soon as possible before the problem
    becomes even bigger. Just like bad code in general, smelly code can lead to widespread
    inefficiency, limited code extensibility, and comprehension, as well as performance
    issues and potential bugs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码库中，情况也是一样的。代码异味是一个潜在的问题，是代码中让我们皱眉的情况。它们是非常具体和可观察的情况，是我们项目中的重复模式。它们表明，在问题变得更大之前，需要尽快修复某些东西。就像一般的坏代码一样，有异味的代码可能导致广泛的不效率、有限的代码可扩展性和可理解性，以及性能问题和潜在的bug。
- en: We need to learn how to recognize and avoid code smells; it’s much easier to
    produce them than one might think, given how absorbed we are in tasks and deadlines.
    The important thing is, once again, to take the time to review our work and identify
    potential problems, the bad smells that arise from our lines of code. Over time,
    with practice and experience, you’ll build a mental compass that points out coding
    pitfalls like a seasoned treasure hunter unearthing hidden gems. Sometimes, it
    will guide you even before you’ve finished crafting your code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要学习如何识别和避免代码异味；考虑到我们如何专注于任务和截止日期，它们的生产比人们想象的要容易得多。重要的是，再次强调，花时间审查我们的工作并识别潜在问题，即从我们的代码行中产生的坏异味。随着时间的推移，通过实践和经验，你会建立一个心理指南针，就像经验丰富的寻宝者发现隐藏的宝石一样，指出编码陷阱。有时，它甚至在你完成编码之前就会引导你。
- en: There are plenty of code smells that have already been cataloged by our *developer
    ancestors*; I don’t think it’s appropriate to list them all here. I’ll tell you
    about the ones that I believe are the most common to encounter and produce. The
    selection has been made based on purely subjective criteria, so feel free – in
    fact, I recommend it – to delve deeper into the *Further reading* section. Many
    of these code smells are related to **clean code** and the **SOLID principles**.
    If you happened to skip the previous chapter, it might be a good idea to go back
    and take a look.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有许多代码异味被我们的**开发者前辈**们整理出来了；我认为在这里列出所有并不合适。我会告诉你我认为最常见且容易产生的那些。这个选择完全是基于主观标准，所以请随意——事实上，我推荐你——深入阅读**进一步阅读**部分。许多这些代码异味都与**清洁代码**和**SOLID原则**相关。如果你跳过了前面的章节，可能回去看看是个好主意。
- en: 'We’ll start with duplicated code, the nuisance of almost all code bases. It’s
    often caused by the developer’s temptation to meet deadlines by resorting to the
    ultimate shortcut: copy and paste. We’ll then move on to long methods and large
    classes. It’s truly disheartening when you encounter a bug on line number *4215*
    of a class, not because of the bug itself, but due to the humongous number of
    lines the class contains!'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从重复代码开始，这是几乎所有代码库的烦恼。它通常是由于开发者为了赶工期而采取终极捷径：复制粘贴。然后我们将转向长方法和大型类。当你在一个类中发现第*4215*行的bug时，真正令人沮丧的是，不是因为bug本身，而是因为该类包含的行数太多！
- en: Then, I’ll show you that `switch` statements can also be a problem when they
    are repeated; a typical situation that object-oriented programming can easily
    solve! When discussing object-oriented programming, why not represent the concepts
    of our domain through dedicated objects rather than rely on language primitives?
    There’s an anti-pattern called **Primitive Obsession** and we’ll tackle it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我会向你展示，当`switch`语句重复时，它们也可能成为问题；这是一个面向对象编程可以轻松解决的问题！在讨论面向对象编程时，为什么不通过专用对象来表示我们领域的概念，而不是依赖于语言原语呢？有一个名为**原始主义**的反模式，我们将解决它。
- en: 'In addition to large classes, there are classes or methods that heavily rely
    on the methods of others; in other words, they just can’t mind their own business!
    We’ll explore what **feature envy** methods are and how to address the potential
    harm they cause. We’ll also discuss two anti-patterns closely related to code
    changes and intertwined with each other: **divergent change** and **Shotgun Surgery**.
    Depending on where and how many changes we need to make in our code when introducing
    new features or making modifications in general, we may encounter one or the other.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了大类之外，还有一些类或方法过度依赖其他人的方法；换句话说，它们就是无法管好自己的事！我们将探讨什么是**特征嫉妒**方法以及如何解决它们可能造成的潜在危害。我们还将讨论两个与代码更改密切相关且相互交织的反模式：**分歧变更**和**雷射枪手术**。根据我们在引入新功能或进行一般修改时需要在代码中做出多少更改，我们可能会遇到其中之一或另一个。
- en: Last but not least, we’ll talk about the so-called **god object**; this anti-pattern
    is a bit like that friend of yours who insists on doing everything, taking all
    the responsibilities; but then everyone relies on them for everything, and it’s
    too much for them. Too many responsibilities should not be assigned to a single
    entity, right? I’ll tell you what’s wrong with this and how to try to solve the
    problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将讨论所谓的**神对象**；这个反模式有点像那个总是坚持做所有事情、承担所有责任的朋友；但然后每个人都依赖他们做所有事情，这对他们来说太沉重了。不应该将过多的责任分配给单个实体，对吧？我会告诉你这个问题在哪里，以及如何尝试解决这个问题。
- en: 'In this chapter, we’ll learn about the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Duplicated code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复代码
- en: Long methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长方法
- en: Large classes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大类
- en: Switches
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开关
- en: Primitive Obsession
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始迷恋
- en: Middle Man
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间人
- en: Message Chains
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息链
- en: Feature envy methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征嫉妒方法
- en: Divergent change
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分歧变更
- en: Shotgun Surgery
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雷射枪手术
- en: God object
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: God object
- en: As mentioned before, code smells are, at the end of the day, smells. Just as
    a bad odor in the fridge doesn’t necessarily indicate a problem with your food
    (think of gorgonzola cheese!), a bad smell in your code doesn’t necessarily indicate
    a problem. However, there is a potential problem that is worth considering. In
    my view, the most important thing is to be aware of what we have in our code bases.
    We shouldn’t perceive every code smell as the most urgent thing in the world because
    it probably isn’t. However, it is crucial not to underestimate them because by
    ignoring one code smell after another, we end up with code bases that are either
    unmaintainable or maintainable at an excessively high cost. This applies not only
    in economic terms but also to personal frustration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，代码异味最终只是异味。就像冰箱里的恶臭并不一定意味着你的食物有问题（想想蓝纹奶酪吧！），代码中的恶臭也不一定意味着有问题。然而，有一个潜在的问题值得我们考虑。在我看来，最重要的是要意识到我们代码库中的内容。我们不应该把每一个代码异味都看作是世界上最紧迫的事情，因为可能并不是。然而，不容低估它们，因为如果我们忽视了一个又一个的代码异味，最终我们得到的代码库要么是无法维护的，要么是维护成本极高。这不仅从经济角度适用，也适用于个人挫败感。
- en: Duplicated code
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复代码
- en: Let’s start with what Martin Fowler calls the *stink parade* (I can’t help but
    mention it because the term cracks me up) with duplicated code. Duplicated code
    is intuitively a bad smell, and our software engineer instincts will soon learn
    to reject it as something that harms us. Let’s try to list a few reasons why duplicated
    code is harmful to the health of our code bases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从马丁·福勒所说的*臭味游行*（我忍不住要提到它，因为这个词让我忍俊不禁）开始，讨论重复代码。重复代码直观上是一个异味，我们的软件工程师本能很快就会学会拒绝它，因为它会给我们带来危害。让我们尝试列出一些为什么重复代码会危害我们代码库健康的原因。
- en: Clearly, copy-pasting code is the first thing to avoid, at least in 99% of cases.
    Taking a piece of code from one class and using it exactly as it is in another
    is easily avoidable. By pausing for a moment to reflect, it’s highly likely that
    we can extract a method to use instead of the duplicated code. Centralizing the
    code in this way ensures better code maintainability. Just think about how nightmarish
    it would be to maintain (e.g., fixing a bug in) every single piece of copy-pasted
    code scattered throughout the code base (and the scariest part is that the developers
    might not be aware of all the instances of duplication). A nightmare. A nightmare
    that is a reality in many places, believe me.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，复制粘贴代码是首先要避免的，至少在99%的情况下。从一个类中取出一段代码，并完全如它在另一个类中使用，是容易避免的。通过稍作停顿进行反思，我们很可能可以提取一个方法来代替重复的代码。以这种方式集中代码确保了更好的代码可维护性。只需想想维护（例如，修复代码库中的错误）散布在代码库中的每一块复制粘贴的代码是多么的噩梦（最可怕的部分是开发者可能没有意识到所有重复的实例）。一个噩梦。一个在许多地方成为现实的噩梦，相信我。
- en: Sometimes, duplicated code exists because the programmer doesn’t have a clear
    understanding of what they are doing, they don’t own the source, or they want
    to change it. In other words, they struggle to grasp the code they are working
    on. As mentioned before, it’s useful to do some refactoring to try to better understand
    the code we’re working with. It’s likely that even with this simple (figuratively
    speaking) approach, you’ll already be able to handle what you’re working on more
    effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，重复的代码存在是因为程序员对他们正在做的事情没有清晰的理解，他们没有拥有源代码，或者他们想要修改它。换句话说，他们难以掌握他们正在工作的代码。正如之前提到的，进行一些重构以更好地理解我们正在处理的代码是有用的。很可能即使以这种简单（比喻地说）的方法，你也能更有效地处理你正在处理的事情。
- en: In general, code quality is compromised by duplicated code; the code becomes
    longer and sometimes less readable. Sometimes it’s impossible to refactor a duplicate
    code block, but the aim should be to decrease technical debt as much as possible.
    It helps to make your code of higher quality.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码质量会因为重复代码而受损；代码变得更长，有时可读性更低。有时可能无法重构重复的代码块，但目标应该是尽可能减少技术债务。这有助于提高代码的质量。
- en: 'The most basic form of duplicated code occurs when you come across the same
    expression in two methods within the same class. To solve this, all you need to
    do is extract a method and call that piece of code from both locations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码的最基本形式发生在你在一个类的两个方法中遇到相同的表达式时。为了解决这个问题，你所需要做的就是提取一个方法，并从两个位置调用这段代码：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous snippet presents some repetitions, as you can easily spot. We’ll
    extract a `printDetails` method and use it twice:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段中存在一些重复，你可以轻松地发现。我们将提取一个`printDetails`方法并使用它两次：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These days, IDEs are perfectly capable of flagging duplicate code (for example,
    in IntelliJ IDEA, it’s a built-in feature) and suggesting a small refactoring
    to extract the method. We will discuss how to get the most out of IDEs and other
    tools later in the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，IDE（集成开发环境）完全能够标记重复的代码（例如，在IntelliJ IDEA中，这是一个内置功能），并建议进行小的重构以提取方法。我们将在本书的后面部分讨论如何充分利用IDE和其他工具。
- en: We’ll now move on to long methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向长方法。
- en: Long methods
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长方法
- en: This is a very typical code smell, very sneaky, and often underestimated. Even
    though it may seem like a trivial topic to address, I’d like to share some thoughts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常典型的代码异味，非常隐蔽，并且经常被低估。尽管这可能看起来是一个微不足道的话题，但我愿意分享一些想法。
- en: Code is read much more than it’s written, so taking a little extra time to shorten
    a method can pay off big time. When you have to modify a long method, you have
    to read and comprehend every single line of code to make the change safely. In
    this case, we’re burdened with loading all the work this method does into our
    brains just to understand what’s happening, let alone have the ability to modify
    any part of it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的阅读量远大于编写量，因此花点额外的时间来缩短一个方法可以带来巨大的回报。当你需要修改一个长方法时，你必须阅读并理解代码的每一行，以确保安全地做出更改。在这种情况下，我们不得不将这个方法所做的一切工作都加载到大脑中，只是为了理解发生了什么，更不用说有能力修改它的任何部分了。
- en: 'Long code is very likely doing more than one thing: according to the **Single
    Responsibility Principle**, a method should ideally focus on doing just one thing.
    It’s almost impossible to achieve that when you have so many lines of code.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 长代码很可能做不止一件事：根据**单一职责原则**，一个方法理想上应该只专注于做一件事。当你有这么多行代码时，几乎不可能实现这一点。
- en: It would be useful to know when “long” becomes “too long.” 10 lines? 20? 100?
    It’s hard to establish a fixed rule. It’s a bit like saying when a cake is too
    sweet or when pasta is too salty; we instinctively recognize the excesses, but
    we probably couldn’t agree on the exact numbers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时“长”变成“太长”是有用的。10行？20行？100行？很难制定一个固定的规则。这有点像说蛋糕太甜或意大利面太咸的时候；我们本能地认识到过度，但我们可能无法就确切的数字达成一致。
- en: My advice here is to follow your gut and, above all, reach a consensus within
    the team. For example, you can decide that 20 lines are the maximum limit or that
    it shouldn’t exceed one screen height (of course, it depends on screen resolution,
    font size, etc.). Another cool thing would be to use standards for formatting,
    even through the use of automatic tools that take care of it; more on this later
    in the book. In short, it depends. It could also be the case that a method is
    long but only contains configurations, things that are very readable and don’t
    require much effort to understand. In that case, you might even not care about
    it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是跟随你的直觉，最重要的是在团队内部达成共识。例如，你可以决定20行是最大限制，或者它不应该超过一屏的高度（当然，这取决于屏幕分辨率、字体大小等）。另一件酷的事情是使用格式化标准，即使是通过使用自动工具来处理它；关于这一点，本书后面会详细介绍。简而言之，这取决于。也可能存在这样的情况，一个方法很长，但只包含配置，这些内容非常易于阅读，不需要太多努力就能理解。在这种情况下，你可能甚至不在乎它。
- en: 'Furthermore, I want to bring up a heuristic tip from Martin Fowler’s *Refactoring*:
    whenever you feel the need to insert a comment in the code to explain it, write
    a method instead. The method will contain the code you intended to comment on,
    but the name of the function itself will explain the intention behind the code,
    rather than its functionality.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我想从马丁·福勒的《重构》中提出一个启发式技巧：每当你在代码中感到需要插入注释来解释时，写一个方法代替。这个方法将包含你打算注释的代码，但函数本身的名称将解释代码背后的意图，而不是其功能。
- en: The following are some small tricks that help in the case of long methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在长方法情况下有帮助的小技巧。
- en: Replace temporary variables with query methods
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用查询方法替换临时变量
- en: 'Most of the time, extracting a method or a function from your long method should
    do the trick; look for parts of the function that go well together and create
    a fresh one. Sometimes you have a function with many parameters and temporary
    variables and they could become obstacles to the extraction process; extracting
    a function would lead to passing a lot of parameters to the extracted method,
    and that would be as unreadable as before. So, it could be useful to replace those
    temporary variables with a query function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，从你的长方法中提取一个方法或函数应该能解决问题；寻找函数中配合得好的部分，创建一个新的方法。有时你有一个具有许多参数和临时变量的函数，它们可能成为提取过程的障碍；提取函数会导致将许多参数传递给提取的方法，这会像之前一样难以阅读。因此，用查询函数替换那些临时变量可能是有用的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code snippet, the `basePrice` variable is used to store the result
    of a pricing operation and then again to calculate the final price, which is discounted
    by 50% for child passengers. It could be a good idea to remove the temporary variable
    and inline the calculation, writing a method (query function) called `calculateBasePrice`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`basePrice`变量用于存储定价操作的结果，然后再次用于计算最终价格，对于儿童乘客，最终价格将折扣50%。删除临时变量并将计算内联，编写一个名为`calculateBasePrice`的方法（查询函数）可能是个好主意：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the next section, we’ll look at parameter objects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨参数对象。
- en: Parameter object
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数对象
- en: 'It could also happen that you have functions or methods with a long or “repeated”
    signature, such as the `calculateFinalPrice` and `discountPrice` methods in the
    following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能发生这样的情况，你有一些具有长或“重复”签名的函数或方法，例如以下代码片段中的`calculateFinalPrice`和`discountPrice`方法：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that we have a couple of methods with the same signature, repeated.
    It’s also crucial to notice that in this case, the `amount` and `currency` parameters
    must always go together, as they represent a price. A cool solution is to pass
    to these methods a “parameter object” or a “request object” (I’ve heard it being
    called in many ways): that is, a complex object representing all the needed parameters
    that make sense together. Given that amount and currency represent a price, why
    don’t we create a `Price` class? We do this in the following snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们有两个具有相同签名的方法被重复使用。同样重要的是要注意，在这种情况下，`amount`和`currency`参数必须始终一起使用，因为它们代表一个价格。一个很酷的解决方案是将“参数对象”或“请求对象”传递给这些方法（我听说它被许多不同的方式称呼）：即一个复杂对象，代表所有有意义的参数。鉴于金额和货币代表一个价格，我们为什么不创建一个`Price`类呢？我们在以下片段中这样做：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next section, let’s replace a function/method with a command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们用一个命令来替换一个函数/方法。
- en: Replace a function or method with a command
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用命令替换函数或方法
- en: 'If you’ve tried to extract functions and create parameter objects but you’re
    still left with an excessive number of temporary variables and parameters, another
    thing you can do is to replace the function with a command. Let’s suppose you
    have the following method, which takes a lot of parameters and is very long:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试提取函数并创建参数对象，但你仍然剩下过多的临时变量和参数，你可以做的是用命令替换函数。假设你有一个以下方法，它接受很多参数并且非常长：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we implement a `PriceCalculator` object, everything becomes clearer; in
    this way, you have replaced a function with a command. All the parameters are
    passed at the beginning, of the constructor. You can reuse this component by passing
    all the parameters every time (and actually, this makes your component more reusable).
    The logic of the method is executed in the `calculatePrice()` method, which doesn’t
    take any parameters; readability is also improved:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现一个`PriceCalculator`对象，一切都会变得清晰；这样，你就用一个命令替换了一个函数。所有参数都在构造函数的开始处传递。你可以通过每次传递所有参数来重用这个组件（实际上，这也使得你的组件更具可重用性）。方法的逻辑在`calculatePrice()`方法中执行，它不接受任何参数；可读性也得到了提高：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When dealing with code extraction, which is to be put in a different method,
    it can be hard, sometimes, just to identify the code you want to separate. How
    can you spot the chunks of code to extract? A handy approach is to check for comments.
    They often indicate these types of meaningful sections. If you come across a block
    of code with a comment explaining its purpose, you can replace it with a method
    named after the comment (and then you can decide whether to keep the comments
    or not). Even a single line is worth extracting if it requires an explanation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理代码提取，需要将其放入不同的方法中时，有时仅仅识别出想要分离的代码就变得很困难。你如何找到要提取的代码块？一个实用的方法是检查注释。它们通常指示这些有意义的部分。如果你遇到一个带有解释其目的的注释的代码块，你可以用注释命名的函数（然后你可以决定是否保留注释）。即使是一行代码，如果它需要解释，也值得提取。
- en: Decompose conditionals
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解条件
- en: 'There are also other indicators of code that need to be extracted; for instance,
    conditionals and loops also provide useful hints for extractions. If you have
    a conditional expression, such as the `if` in the following snippet, it can be
    handy to apply the “decompose conditional” technique:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还有其他需要提取的代码的指示器；例如，条件和循环也提供了有用的提取提示。如果你有一个条件表达式，比如以下片段中的`if`，应用“分解条件”技术可能很有用：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code snippet calculates the price of a plane seat depending on the row
    numbers (it probably doesn’t make any sense, but it’s useful for this example!).
    If the seat is located in the first 30 lines, we have to pay a different fare.
    There is an `if`, which is quite simple here, but you have to imagine this in
    a real-world scenario, where conditions can be much more complex and involve many
    more parameters and objects. In the refactored snippet, we isolated some logic,
    including the condition, to improve readability and potentially reuse the code
    (and potentially, in the future, you could externalize the condition calculations,
    by doing requests to third-party systems or even rule engines):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段根据行号计算飞机座位的票价（这或许没有太多意义，但在这个例子中很有用！）。如果座位位于前30行，我们需要支付不同的票价。这里有一个`if`语句，在这里很简单，但你要想象在现实世界场景中，条件可能更加复杂，涉及更多的参数和对象。在重构的代码片段中，我们隔离了一些逻辑，包括条件，以提高可读性和潜在的代码重用（并且在未来，你可能会通过向第三方系统或甚至规则引擎发起请求来外部化条件计算）：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But conditions are not only *ifs*, but also *switches* (which are, in a way,
    *ifs* in disguise). If you encounter a lengthy switch statement, transform each
    case into a separate function call using the “extract function” approach, which
    we covered in the preceding section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但条件不仅仅是`if`，还有`switch`（在某种程度上，`switch`是伪装的`if`）。如果你遇到一个冗长的`switch`语句，可以使用我们在上一节中介绍过的“提取函数”方法，将每个情况转换为单独的函数调用。
- en: Split loops
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆分循环
- en: 'Sometimes, loops can also become a problem; for instance, it is common to have
    a loop body that does more than one thing. In this case, you should create a distinct
    method for the loop itself and the code within it. If you struggle to find a suitable
    name for the extracted loop, it might be because it’s performing two distinct
    tasks. In such cases, don’t hesitate to use the following technique, called **split
    loop**, to separate the tasks into different parts:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，循环也可能成为问题；例如，常见的循环体执行多项操作。在这种情况下，你应该为循环本身和其中的代码创建一个独立的方法。如果你难以找到一个合适的提取循环名称，可能是因为它执行了两个不同的任务。在这种情况下，不要犹豫，使用以下称为**拆分循环**的技术，将任务分离到不同的部分：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous snippet is made of a very basic `for` loop. Even in these two
    lines, a problem is hidden! In fact, you have two different things done in the
    same `for` loop. I can already hear you saying, “*Come on, it’s just two lines!*”
    but – again – I’m simplifying things as much as possible here. Reality is often
    more complex, but the problem is the same. Refactoring the code by splitting the
    loop makes the code clearer and more reusable; should you move part of the logic
    elsewhere, now it should be simpler (we could also use Java streams, but we want
    to keep it as simple as possible):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段由一个非常基本的`for`循环组成。即使在这两行中，也隐藏了一个问题！实际上，你在同一个`for`循环中做了两件不同的事情。我都能听到你在说，“*哎呀，这只是两行而已!*”但——再次——我在这里尽可能地简化事情。现实往往更加复杂，但问题是一样的。通过拆分循环重构代码可以使代码更清晰、更可重用；如果你需要将部分逻辑移动到其他地方，现在应该会简单一些（我们也可以使用Java流，但我们想尽可能保持简单）：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Lots of programmers don’t like this refactoring because it makes you run the
    loop twice. But please remember that we’re separating refactoring from optimization.
    First, get your code nice and clean, then you can optimize it. If looping through
    a list is causing a slowdown, you can easily combine the loops again. But honestly,
    going through a big list is usually not the real issue, and splitting the loops
    can actually open up opportunities for better optimizations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员不喜欢这种重构，因为它会让你运行循环两次。但请记住，我们正在将重构与优化分开。首先，让你的代码变得整洁，然后你可以优化它。如果你发现遍历列表会导致速度减慢，你可以轻松地将循环合并。但说实话，遍历一个大列表通常并不是真正的问题，拆分循环实际上可以打开更好的优化机会。
- en: Large classes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大型类
- en: This is another very common smell. How many times have you found yourself working
    on classes with thousands of lines? It’s nobody’s fault, it’s just that classes
    start small and, very understandably, gradually end up incorporating more information
    and functionality. There’s nothing wrong with that; the important thing is to
    realize it and refactor it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个非常常见的代码异味。你有多少次发现自己正在处理拥有数千行代码的类？这不是任何人的错，只是类开始时很小，非常合理地逐渐包含了更多的信息和功能。这并没有什么问题；重要的是要意识到这一点并进行重构。
- en: A practical way to notice that a class is too big is when there are too many
    fields (instance variables). If there are too many fields in a class, it’s likely
    doing too many things; besides having too many responsibilities, often in this
    case, code duplication becomes a problem.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类中有太多字段（实例变量）时，这是一个实际的方法来注意到这个类太大。如果一个类中有太多字段，它很可能会做太多事情；除了有太多的职责外，通常在这种情况下，代码重复成为了一个问题。
- en: 'You can create (extract) a new class to group several variables together. Pick
    the variables that naturally go hand in hand and put them in a component. For
    instance, if you see a bunch of parameters called something such as `priceAmount`
    and `priceCurrency`, they are probably meant to be part of the same component.
    In general, if you notice common prefixes or suffixes among a subset of variables
    in a class, it indicates the possibility of creating a component:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建（提取）一个新的类来将几个变量组合在一起。选择那些自然结合在一起的变量并将它们放入一个组件中。例如，如果你看到一些名为 `priceAmount`
    和 `priceCurrency` 的参数，它们可能意味着是同一个组件的一部分。一般来说，如果你注意到一个类中变量子集的常见前缀或后缀，这表明了创建组件的可能性：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Order` class contains numerous fields that each represent distinct properties
    of the order. However, if you look closer, it becomes evident that some of these
    fields can be logically “grouped” together, as they belong to specific aspects
    of an order property. For instance, the `name` and `surname` fields can be seen
    as representing the buyer’s information (to simplify the concept). Similarly,
    the `streetName`, `streetType`, and `streetDirection` fields are related to the
    shipping address for the order, while `priceAmount` and `priceCurrency` provide
    information about the selling price.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 类包含许多字段，每个字段都代表订单的不同属性。然而，如果你仔细观察，很明显，其中一些字段可以从逻辑上“分组”在一起，因为它们属于订单属性的特定方面。例如，`name`
    和 `surname` 字段可以看作是代表买家的信息（为了简化概念）。同样，`streetName`、`streetType` 和 `streetDirection`
    字段与订单的送货地址相关，而 `priceAmount` 和 `priceCurrency` 提供了关于销售价格的信息。'
- en: Given these insights, it is possible to restructure the `Order` class by grouping
    certain fields to create new **entities**. These entities can (*should*) be reused
    effectively throughout the project, enhancing code organization and maintainability.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些见解，我们可以通过将某些字段分组来重新结构化 `Order` 类，创建新的 **实体**。这些实体可以在整个项目中有效地重用，增强代码组织和可维护性。
- en: 'The restructured `Order` class should look something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重新结构化的 `Order` 类应该看起来像这样：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Of course, it should have all of the previous fields “distributed” among different
    classes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它应该将所有这些字段“分布”在不同的类中：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If using inheritance makes sense for the component, you’ll likely find that
    techniques such as extracting a superclass or replacing `type` with subclasses
    (also known as extracting a subclass) are often simpler to apply. The following
    is a very common situation; we have a class that takes a `type` parameter because,
    depending on its value, the class has to behave slightly differently:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用继承对组件来说是有意义的，你可能会发现提取超类或用子类替换 `type`（也称为提取子类）等技术通常更容易应用。以下是一个非常常见的情况；我们有一个类，它接受一个
    `type` 参数，因为根据其值，该类必须以稍微不同的方式行为：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I bet some instances of `if` are hiding inside the `Transport` class! But object-oriented
    programming comes with inheritance, so why don’t we use it? Take the following
    example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，`Transport` 类中隐藏着一些 `if` 语句！但是面向对象编程伴随着继承，那么我们为什么不使用它呢？以下是一个例子：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this refactored code snippet, we have two major improvements. We changed
    the class of `type` from `String` to an enum called `TransportType`; this allows
    us to perform the subsequent switch statement in a safer way because we’ll be
    warned (by an IDE, likely) if we are not considering some of the possible values
    of type. Then, we created a specific class for each type of transport, avoiding
    mixing things up; of course, all of these classes will implement the same interface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构的代码片段中，我们有两个主要改进。我们将 `type` 类从 `String` 改为名为 `TransportType` 的枚举；这允许我们以更安全的方式执行后续的
    switch 语句，因为我们将在不考虑类型的一些可能值时被警告（可能是一个 IDE）。然后，我们为每种类型的运输创建了一个特定的类，避免了混淆；当然，所有这些类都将实现相同的接口。
- en: 'Aside from having a bunch of instance parameters, a class that is too large
    is generally not good; it’s a breeding ground for duplicated code, unclear code,
    confusion, and despair. A simple, yet effective, approach to start with is to
    eliminate repetitions within the class itself. Simply put, you can look for code
    that makes sense to group together and write standalone methods for them. Shorten
    the methods within a very large class. Maybe the number of methods will increase,
    but you’ll likely realize that you can move some of them to a separate class,
    if those methods make sense together and concern a single aspect. In very large
    classes, it’s very common to have duplicated code or similar repetitions. At that
    point, from a 100-line method, we can extract two or three 10-line methods, with
    a few extra lines to invoke them. The most difficult part is probably understanding
    how to split the code. Here’s a very simple tip that often works: the *clients*
    of such a class can often provide valuable hints for breaking it down. Take a
    closer look and perform some static analysis of the code (that is, open the code
    and go through it. There are also automatic tools for doing this; we’ll meet them
    later) to see how clients utilize only a portion of the class’s features. Each
    distinct subset of features can potentially become a separate class.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有大量实例参数外，一个太大的类通常不是很好；它是重复代码、代码不清晰、混乱和绝望的温床。一个简单而有效的方法是从消除类内部的重复开始。简单来说，你可以寻找有意义的代码组合，并为它们编写独立的方法。缩短一个非常大的类中的方法。也许方法数量会增加，但你可能会意识到，如果你可以将它们移动到另一个类中，如果这些方法有意义并且关注单一方面，那么你很可能会这样做。在非常大的类中，非常常见的是有重复的代码或类似的重复。在那个点上，我们可以从100行的方法中提取出两到三个10行的方法，再加上一些额外的代码来调用它们。最困难的部分可能是理解如何拆分代码。这里有一个非常简单的技巧，通常很有效：这样的类的**客户端**通常可以提供有价值的拆分提示。仔细观察并执行一些代码的静态分析（即打开代码并遍历它。还有自动工具可以做到这一点；我们稍后会遇到它们）以查看客户端如何仅使用类的一部分功能。每个不同的功能子集都可能成为一个单独的类。
- en: Switches
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: To put it simply, the `switch` statement itself is not problematic per se. In
    fact, we find it quite elegant and self-explanatory. Many programming languages
    even offer more advanced forms of `switch` statements that can use more complex
    code as their foundation. They can simplify code and replace ugly nested ifs.
    I must admit, we have a soft spot for the `switch` statement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`switch` 语句本身并没有问题。事实上，我们发现它非常优雅且易于理解。许多编程语言甚至提供了更高级的 `switch` 语句形式，它们可以使用更复杂的代码作为基础。它们可以简化代码并替换掉丑陋的嵌套
    `if` 语句。我必须承认，我们对 `switch` 语句情有独钟。
- en: However, the issue arises when we encounter *repeated* switches in object-oriented
    programming. We consider this to be problematic for several reasons. The `switch`
    statements violate the `case` statement in each section. This leads to modifying
    existing code, which goes against the principle. Furthermore, switches can be
    challenging to maintain. As new requirements emerge, the `switch` statements can
    grow in complexity, making the code harder to manage. Another issue with switches
    is the potential for redundant code in certain cases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们遇到面向对象编程中的**重复** `switch` 语句时，问题就出现了。我们认为这有几个原因使其成为问题。`switch` 语句违反了每个部分的
    `case` 语句，这导致修改现有代码，这与原则相悖。此外，`switch` 语句的维护可能具有挑战性。随着新需求的产生，`switch` 语句可能会变得更加复杂，使得代码更难管理。`switch`
    语句的另一个问题是，在某些情况下可能存在冗余代码。
- en: 'The solution in this case is quite simple – use polymorphism:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，解决方案相当简单——使用多态：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I assume you’re already familiar with these characters and you know what a
    *lightsaber* is. If not, I highly recommend Googling them and watching those movies
    right away. The previous piece of code could be refactored into the following
    classes/methods, in which we designed an abstract class, `SwCharacter`, that will
    be extended for each specific character. The `printLightSaberColor` method will
    take a “generic” `SwCharacter` and call the relative implementation of the `getLightSaberColor`
    method. In the following code, we’re going to omit some boilerplate code, such
    as constructors or other getters, for simplicity:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经熟悉这些角色，并且知道什么是**光剑**。如果不是，我强烈建议你立即在 Google 上搜索它们并观看那些电影。前一段代码可以被重构为以下类/方法，其中我们设计了一个抽象类
    `SwCharacter`，它将被扩展为每个特定角色。`printLightSaberColor` 方法将接受一个“通用”的 `SwCharacter` 并调用相应的
    `getLightSaberColor` 方法的实现。在以下代码中，为了简化，我们将省略一些样板代码，例如构造函数或其他获取器：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is worth mentioning that in this particular case, we increased the number
    of code lines. However, in our opinion, this is highly acceptable as we improved
    readability. In the examples I’ve given you, I tried to keep things simple by
    using basic stuff such as `int` or `String` most of the time. But that’s not always
    the best approach. It depends. Sometimes, relying too much on the language’s primitive
    types can lead to a code smell called **Primitive Obsession**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在这个特定案例中，我们增加了代码行的数量。然而，在我们看来，这是完全可以接受的，因为我们提高了可读性。在我给出的例子中，我尽量保持简单，大部分时间使用基本的类型，如`int`或`String`。但这种方法并不总是最佳选择。这取决于具体情况。有时，过度依赖语言的基本类型可能会导致一种被称为**原始类型迷恋**的代码问题。
- en: Primitive Obsession
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型迷恋
- en: To understand what Primitive Obsession is and how to deal with it, let’s remember
    what primitive types are in a programming language. Primitive types are like the
    ready-made types that come with the language. You can think of them as straight
    from the manufacturer. Each language has its own set of primitive types, and since
    we’re talking about Java here, let’s focus on how it works in Java.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解什么是原始类型迷恋以及如何处理它，让我们回顾一下编程语言中的原始类型是什么。原始类型就像语言自带的自定义类型。你可以把它们想象成直接从制造商那里来的。每种语言都有自己的原始类型集合，既然我们在这里讨论Java，让我们关注一下它在Java中的工作方式。
- en: In Java, a `java.lang.String` class. Although the `String` class is not technically
    a primitive data type, it’s given special treatment in the language, so you might
    consider it as one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`java.lang.String`类。尽管`String`类在技术上不是一个原始数据类型，但在语言中得到了特殊处理，所以你可以将其视为一种。
- en: Primitive Obsession is when the code becomes too dependent on basic data types.
    It means that a simple value takes charge of the class logic and lacks type safety.
    In simpler terms, it’s a bad habit of using basic types to represent an object
    in a specific area of focus.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型迷恋是指代码过度依赖基本数据类型。这意味着一个简单的值负责类逻辑，缺乏类型安全。用更简单的话说，这是一种在特定关注区域使用基本类型来表示对象的坏习惯。
- en: Let’s take the example of representing a website’s URL. Usually, we store it
    as a string. However, the problem arises because a URL has more details and distinct
    characteristics than just being a simple string. It includes elements such as
    the scheme, query parameters, and protocol. When we store it as a string, we lose
    the ability to directly access these URL-specific components (the essential parts
    of the URL) without writing additional code. We could use `java.net.URL` instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以表示网站URL为例。通常，我们将其存储为字符串。然而，问题在于URL比简单的字符串具有更多的细节和独特的特征。它包括诸如方案、查询参数和协议等元素。当我们将其存储为字符串时，我们失去了直接访问这些URL特定组件（URL的基本部分）的能力，而不需要编写额外的代码。我们可以使用`java.net.URL`代替。
- en: Strings are often breeding grounds for this kind of issue. Take a telephone
    number, for example. It’s more than just a random assortment of characters. In
    many cases, a proper data type can provide consistent display logic when it needs
    to be shown in a user interface. Representing such types as strings creates a
    problem so common that they are sometimes referred to as *stringly* *typed* variables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串往往是这种问题的滋生地。以电话号码为例。它不仅仅是随机字符的集合。在许多情况下，适当的数据类型可以在需要显示在用户界面时提供一致的显示逻辑。将这种类型表示为字符串会引发一个如此常见的问题，以至于它们有时被称为*字符串类型化*变量。
- en: 'If you think about it, it is quite simple to solve the problem; it is necessary
    to replace the primitive(s) with objects. Take the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，解决这个问题其实很简单；必要的是用对象替换原始类型。以下是一个例子：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This can become the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以变成以下形式：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you’re curious about how the `URL` class works, look at its documentation
    (the `java.net.URL` class is included in the Standard Java Library).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇`URL`类是如何工作的，可以查看其文档（`java.net.URL`类包含在标准Java库中）。
- en: If you have a group of primitives that can go together, you can group them by
    extracting a class, like in the address example we covered in the *Large* *classes*
    section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一组可以一起使用的原始类型，你可以通过提取一个类来将它们分组，就像我们在*大型*类部分中讨论的地址示例一样。
- en: Now that we’ve dealt with Primitive Obsession, let’s tackle all those classes
    that have little desire to work and make others do all the work. This was just
    a playful way to say that we will talk about a smell called **middle man**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了原始类型迷恋，让我们来谈谈那些不太愿意工作，而让其他事物做所有工作的类。这只是一个玩笑的说法，我们将讨论一种被称为**中介**的代码问题。
- en: Middle man
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介
- en: 'The middle man is a code smell that occurs when we have a class or, in general,
    an object that does only one thing, and that thing is... delegating the work to
    someone else. We are not suggesting that a class should have only one method to
    be considered a "middle man". Rather, each of its methods should only invoke others.
    So, the question arises spontaneously: why keep a class in our codebase that does
    nothing? In fact, there is (almost never) a reason. Let’s delete this class or
    method and ensure that the client calls the “destination” directly. This way,
    we will eliminate unnecessary complexity and ensure that, when we modify or add
    features to the destination objects, we are not forced to also modify our middle
    man.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example, suppose we have a class structured like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A “client” method would use it in the following way:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can easily notice that the `getCity()` method serves solely as a proxy
    to the other class. So why not use the other class directly? Our example would
    then become:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And so, we can eliminate the middle man composed of the `getCity()` method in
    the `Person` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: However, this refactoring can paradoxically lead to another code smell, the
    message chain!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Message chains
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **message chain** occurs when a client requests an object, which then requests
    another object, and so on. This makes all the objects dependent on the structure
    of the called objects, and a change in these objects would necessarily impact
    the entire chain of calls, at every point where they are made. Building upon the
    example from the previous section, we could have something like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The solution is to hide the “delegate”, that is the method calling the other
    one(s). We could transform the previous example into this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Where the chain of calls is hidden in the `getCityName()` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Taken to the extreme, however, this refactoring can lead to the middle man smell!
    Have we ended up in a time loop like Christopher Nolan? The truth is, it depends.
    These refactorings must indeed be properly weighted, attempting to choose the
    lesser evil (also considering the possibility that perhaps the class modeling
    itself is flawed and might require changes in some way).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Opting for middle man instead of message chains offers the advantage of requiring
    fewer mocks during unit testing. Testing classes becomes challenging when you
    have to provide mocks not just for their immediate and indirect dependencies.
    Additionally, it aids in the separation of concerns. A code that possesses an
    *A* component and requires a *C* component should ideally remain unaware of the
    involvement of a *B* component. This contributes to better modularity. While the
    primary argument for message chains is the avoidance of writing boilerplate in
    the middle, and there might be cases where it makes sense, the general guideline
    should lean towards preferring the middle man.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Choosing middle man over message chains aligns with the principles of the Law
    of Demeter, often summarized as “only talk to your direct dependencies.” This
    guideline encapsulates a design philosophy advocating for encapsulation and reduced
    coupling in object-oriented systems. We talked about the Law of Demeter in [*Chapter
    2*](B20912_02.xhtml#_idTextAnchor042).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Feature envy methods
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we try to break down our code base into components that make sense based
    on our use case and domain, we’re basically dividing the code into *zones*. One
    of the key things we need to be careful about is maximizing interactions within
    the zones and, conversely, minimizing interactions between different zones. **Feature
    envy** is like a warning sign in the code, describing when an object accesses
    another object’s fields to perform an operation instead of simply instructing
    the object on what to do.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, let’s consider a method that calculates a price based
    on a payment request:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Everything seems fine until we realize that we need the order and some user
    information to calculate the price. That’s when we start writing its implementation
    and, for instance, we must retrieve the order related to the payment request;
    in the first lines of the method, we’ll write something like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Very likely, a user will be needed too. So, after fetching the order, we’ll
    probably add a line in which we also retrieve the user, because we need some information
    about them:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From these objects, we’re going to take some specific properties that we need
    to complete the payment. For instance, we’ll write something like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once again, we’re faced with a ton of finder/getter methods being called. It’s
    very common to find methods invoking tons of getter methods of other objects to
    retrieve or calculate some value. In this case, it’s also likely that your bean,
    your Java class, will have a lot of *collaborators*, that is, a lot of other classes
    injected in yours through the constructor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In the most basic scenario, you can simply transfer the method you’re using
    from one class to another (and modify its name, if necessary). If only a portion
    of the method requires access to another object’s data, you can extract that specific
    part into a separate method. However, not all cases are straightforward; sometimes,
    a function relies on features from multiple modules, so it becomes a question
    of which module it should belong to. A rule of thumb (as suggested by Martin Fowler)
    is to determine the module that possesses most of the data and place the function
    there. This process is often facilitated by extracting methods to break down the
    function into smaller pieces that can be placed in different locations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, even when this guideline is not applicable, you have the option
    to use the Strategy or Visitor patterns described in the book by the *Gang of
    Four*. However, providing a detailed explanation of these patterns is beyond our
    scope. For more in-depth explanations, you can refer to the *Further reading*
    section. The fundamental principle remains unchanged: grouping elements that undergo
    changes together. Typically, data and the corresponding behavior that relies on
    that data tend to change simultaneously, though exceptions exist. In such scenarios,
    relocating the behavior ensures that changes are consolidated in a single location.
    Strategies and Visitors offer a practical means of modifying behavior by isolating
    specific portions that require overriding, even though this approach introduces
    some additional indirection.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Divergent change
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As software engineers, we know our work product is soft and flexible. Once,
    a professor at university told us, “*We’re the only engineers who are asked to
    change the project many times, even when it’s done. Imagine doing that with a
    bridge. This is our strength and* *our curse.*”
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: As we know from the Agile philosophy, *change is good*, but it needs to be controlled
    and managed. Going back to code smells, we have divergent changes when we need
    to modify a certain class often, even though we’re touching seemingly unrelated
    aspects. Think of a class that handles the results of a search for transportation
    options like for a travel booking website (those where you put when you want to
    leave, when you want to return, where you want to go and they give you a bazillion
    options to choose from – planes, trains, buses and so on). At some point, we need
    to change the database the application relies on. Consequently, we modify class
    *X*. Then, we need to integrate a new type of transportation, and we must modify
    class *X* again. New payment method? Again, class *X* needs modification.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: All these aspects are unrelated, but class *X* is always in the middle! Divergent
    change happens when a module (or a class, or a project) is frequently modified
    for various reasons, resulting in a mixing of different contexts in a single location.
    To enhance our programming experience, we can improve it by segregating these
    contexts into separate modules.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The most likely reason is that the **Single Responsibility Principle** has been
    violated. In general, we either have a flawed programming structure or we’ve gone
    overboard with copy and paste. Thus, it becomes necessary to create appropriate
    modules and move the methods accordingly. Sometimes it may be necessary to extract
    ad hoc methods (and perhaps relocate them) or even extract entire classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we come across a special situation where two aspects, mistakenly
    tangled up in a single class, naturally form a sequence. A classic example is
    when we fetch data from the database, process it, and then feed it to a function
    that uses it. In cases like these, we can use a refactoring technique called **split
    phase**. In this refactoring process, we break down a complex computation into
    two phases (or more). During the first phase, we calculate a result, and then
    we pass this result, along with some intermediate data structure, to the second
    phase for further processing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the following code snippet: it retrieves some flight data
    array from a database, parses an element of that array to a double, then takes
    some of the output and uses it to perform further calculation... the point is
    that it does a lot of different things one after the other:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It would be nice to refactor this code and make it a bit more readable and
    somehow modular, even if this term could be inappropriate when talking about a
    small set of code lines. Anyway, we’re going to split this code into phases, almost
    like it was a workflow: we’ll call `getFlightDataFromDatabase` (without splitting
    the result immediately; that is something that will be needed only in the next
    code line). The `flightData` string, of course, is not very handy (we’re assuming
    we cannot change the return type because we’re using a third-party library) so
    we’re going to use `parseFlightData` into a `FlightInfo` object, which handles
    the flight information in a very handy way. At the end, we’re going to finally
    implement `calculateTotalPrice`, using the `flightInfo` object. See how this code
    – even a four-line piece of code – can become much more readable:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the change you need is not in a single class you have to change often,
    but spread across the project, you’re forced to modify the code in a lot of different
    points. That’s when you have the code smell known as *Shotgun Surgery*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Shotgun Surgery
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it might seem a bit violent at first, to me, the term seems also funny,
    to be honest; that’s why I really like it. Sometimes, I’ve heard it referred to
    as *shooting a fly with a bazooka.* It is, basically, the opposite of divergent
    change.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: When you’re dealing with Shotgun Surgery, it means you must make a bunch of
    changes in your code base just to tackle seemingly simple tasks. Frequently, you’ll
    find yourself altering code that appears quite similar, either directly copy-pasted
    or with a similar purpose. The term refers to the work of a surgeon, which is
    done very precisely, with a scalpel, in the least invasive way possible. Now replace
    the image of the scalpel with a shotgun and... well, you get the idea.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be several examples or reasons that lead to Shotgun Surgery; let’s
    quickly go through some of them, so we can prevent the problem:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Copy and paste**: This is the first example that comes to mind; you’ve done
    some good old copy and pasting of code! This means, of course, that making changes
    to some of the copied code requires you to make those same changes to each and
    every copy. It’s pretty straightforward, really.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excessive layering**: Sometimes, our application tends to be too layered.
    For example, imagine a basic CRUD app that goes all out with multiple layers,
    including data transfer objects, data access objects, and domain objects. Every
    time you want to add a table to the database, you not only have to add stuff to
    all four layers but also deal with all the property bag objects within those layers.
    It’s another case of Shotgun Surgery. (But the world isn’t all black or white;
    there are many shades of gray. Sometimes, an application with well-defined layers
    helps to isolate concepts and responsibilities. So, be careful; I’m not saying
    that designing multiple layers in an architecture is inherently bad. You always
    have to find the right balance, just like in life!)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited layering**: Just as sometimes there are too many layers in the design
    of an application, there are also times when responsibilities are excessively
    separated: one class for constants, another for static variables, and so on. Then,
    when you need to make a change, you find yourself having to touch them all! Has
    it ever happened to you? It happens to me quite often. And there you are again,
    using a shotgun in the operating room.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should care about these problems because changes become more time-consuming
    since you have to edit your code base in more places. *Merge conflicts* become
    more likely, as more people are touching the code in different locations, making
    collaborative projects more difficult. You’re also more likely to introduce bugs
    due to the cognitive load of remembering to change the code in multiple places.
    Additionally, you end up with more code because of knowledge duplication and the
    need for additional constructs to connect the different pieces. Lastly, the learning
    curve is higher for new team members as development becomes like a treasure hunt
    in navigating through the code base.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: When you have your logic spread all over the code base, you could simply move
    your method(s) or your field(s) into the same class or module. By doing so, you
    make sure that related software elements are clustered together, making it easier
    to locate and comprehend the connections between them. All the relevant context
    would be consolidated in one place, enhancing encapsulation and enabling other
    parts of the software to be less reliant on the specifics of this module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Another intriguing approach to tackle Shotgun Surgery is to employ inlining
    refactorings. In other words, it can be beneficial to merge methods or classes
    in order to consolidate poorly separated logic. This may result in a long method
    or a large class; I know we just said that this would be bad, but this would only
    be a temporary (but very useful) situation so that you can subsequently use extractions
    to break it down into more coherent pieces. Of course, we typically prefer small
    functions and classes in our code but don’t hesitate to create something large
    as an intermediate step toward reorganization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Inlining a method means, basically, doing the opposite of extracting a method.
    Suppose we have the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You have created a separate class, with a static method, just to implement
    the VAT addition. Supposing that this method is used only once, this seems a bit
    too much; the suggestion here is simply to inline the content of the static method,
    avoiding creating a separate class, which would make the code a bit more difficult
    to read. You could simply do the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Anyway, the real deal is to always keep Shotgun Surgery on your radar as you
    work. Keep asking yourself whether future maintenance programmers (which could
    also be your future self) will need a shotgun or a scalpel to make the anticipated
    changes. If the answer leans toward *shotgun*… then it’s high time you rethink
    your approach.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: God object
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the anti-patterns mentioned in this chapter (there are many more; I encourage
    you to delve into the *Further reading* section), perhaps the one called **god
    object** (or **god class**) is the one I most frequently come across. As the name
    suggests (I must say, in the world of refactoring and clean code, the level of
    naming is remarkable!), a god class is a negative coding practice characterized
    by a class that assumes an excessively considerable number of responsibilities.
    It manifests as a class that consolidates and oversees numerous objects, performing
    all tasks within the application. This anti-pattern violates the principle of
    keeping classes focused and modular, leading to poor maintainability and hindered
    code readability.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: You may think that this may be a good pattern; also, the name can suggest something
    positive. Well, this is not the case, and we are about to see why.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: God objects violate SOLID, especially the Single Responsibility Principle. God
    classes go completely against the Single Responsibility Principle by assuming
    an excessive number of responsibilities and lacking focus. As a result, engineers
    end up reinventing the wheel, duplicating code, and accumulating technical debt.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Because of god objects, your code will be more fragile. Due to the overwhelming
    responsibilities of a god class, it requires frequent updates, which significantly
    raises the chances of introducing breaking changes. Understanding the impact of
    modifications to a god class on the rest of the application can be challenging,
    if not impossible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: God objects are hardly testable. A class is easily testable, in general, when
    it is small, focused, and independent of other types. On the contrary, a god class
    operates in the opposite manner. Being a large, all-encompassing entity that controls
    and manages numerous other objects, it becomes tightly coupled to those types.
    Consequently, testing the god class becomes a daunting task due to its intricate
    setup and the necessity to stub or mock numerous dependencies just to instantiate
    it for testing purposes. You can often become aware you are writing a god object
    when it has too many *collaborators*, that is, too many other objects needed for
    the class itself to work.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the main pain point. We always end up with this. A god object makes
    your code harder to read and understand. It is no wonder that the code within
    these classes becomes complex, considering their extensive responsibilities and
    interactions with several types. I am not (only) talking about cyclomatic complexity
    here; for example, relying on external dependencies that cause side effects and
    mutability. The cumulative effect of these complexities contributes to the overall
    cognitive complexity of the code, creating obstacles in understanding and reducing
    engineers’ productivity and performance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The solution here is not unique, but the approach can be. It is quite easy to
    create a god object (especially in object-oriented programming) but it can be
    extremely hard to undo them. So, use the good old *divide et impera* technique
    (again, the Single Responsibility Principle) and split the class into smaller
    pieces; be guided by your domain; and group the common methods and properties
    in a class while keeping the classes loosely coupled. If classes or methods have
    a lot of code or functionality in them, break them into simple, manageable, testable
    classes and methods. Finally, delete or deprecate the god object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to spot some – not all – code smells. We covered
    the ones that I think are the most common. Some of them you’ll pick up instinctively
    and avoid them as you write code. We tackled duplicated code, long methods, large
    classes, and repeated switches. We also learned to avoid our obsession with primitive
    types (using string for everything is a strong temptation!) and looked at feature
    envy methods. Finally, we talked about divergent change and its opposite, Shotgun
    Surgery. Oh, and let’s not forget about the god object. This is just a partial
    selection of all the existing code smells out there, but I believe it’s a good
    starting point to steer clear of them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: A crucial condition to perform any kind of refactoring, especially god object
    refactoring, is good test coverage. In the next chapter, we are going to tackle
    this extremely important matter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Primitive Data** **Types**: [https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: [https://refactoring.guru/design-patterns/strategy](https://refactoring.guru/design-patterns/strategy)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: [https://refactoring.guru/design-patterns/visitor](https://refactoring.guru/design-patterns/visitor)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (1994). *Design
    Patterns: Elements of Reusable Object-Oriented Software*. Addison-Wesley Professional.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code** **Smells**: [https://refactoring.guru/refactoring/smells](https://refactoring.guru/refactoring/smells)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
