<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Working with Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Data</h1></div></div></div><p>In the previous chapter, we learned about batch configurations, components, and execution modes to match with diverse business needs. Handling the data, which includes reading, processing, and writing, is an essential part of any kind of application, and batch applications are no exception. Spring Batch provides the ability to read different forms of data, process the data in the way business expects, and write it back to different systems, which can be easily integrated with different frameworks.</p><p>In this chapter, we will cover three major operations involved in data handling:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data reading</li><li class="listitem" style="list-style-type: disc">Data processing</li><li class="listitem" style="list-style-type: disc">Data writing<div class="mediaobject"><img src="Images/3372OS_03_01.jpg" alt="Working with Data" width="600" height="221"/></div></li></ul></div><p>The preceding figure shows the three stages of handling data in a batch application. The input (source) can be a database, a filesystem (flat file or XML), or data from a web service as well. Applications need to read the data from an input (source), process it, and write to the output (destination) system. The output (destination) can be a database or a filesystem (a flat file or an XML file). In the processing stage, data read in format can be verified and transformed into the desired format before writing to the output. Let's examine each of these stages now.</p><div class="section" title="Data reading"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Data reading</h1></div></div></div><p>Spring Batch provides the <a id="id160" class="indexterm"/>configuration to read different forms of data from different sources, including flat files, XML, and relational databases. It also supports the custom reader configurations for the formats that are not available with the specification.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="ItemReader"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>ItemReader</h1></div></div></div><p>Spring Batch provides <a id="id161" class="indexterm"/>an interface in the form of <code class="literal">ItemReader</code> to read bulk <a id="id162" class="indexterm"/>data from different forms, which include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flat files</strong></span>: These <a id="id163" class="indexterm"/>are typically of two types: fixed width and delimited character-based files</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>XML</strong></span>: This <a id="id164" class="indexterm"/>format is used for different forms of application data</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Database</strong></span>: This <a id="id165" class="indexterm"/>maintains a set of records of similar or different groups of information</li></ul></div><p>The following is the definition of the <code class="literal">ItemReader</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface ItemReader&lt;T&gt; {

T read() throws Exception, UnexpectedInputException, ParseException;

}</pre></div><p>Let's examine how <code class="literal">ItemReader</code> can help us with reading different formats.</p><div class="section" title="Reading data from flat files"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Reading data from flat files</h2></div></div></div><p>Flat files are <a id="id166" class="indexterm"/>configured in two formats, namely, <span class="strong"><strong>fixed width</strong></span> <a id="id167" class="indexterm"/>and <span class="strong"><strong>delimited</strong></span>. Fixed width files have each <a id="id168" class="indexterm"/>field detail configured with a predefined <a id="id169" class="indexterm"/>fixed width, whereas the delimited files have fields with a specific character (or tab in general) used to delimit them from the other fields.</p><div class="section" title="Fixed width file"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec01"/>Fixed width file</h3></div></div></div><p>A fixed width file <a id="id170" class="indexterm"/>generally has a predefined specification of its fields, how much length each field should occupy on the file, and from <a id="id171" class="indexterm"/>which position to which position on a line.</p><p>The following is one such specification of the fixed width file we want to read:</p><div class="informalexample"><pre class="programlisting">Field                 Length                   Position
ID                    2 characters             1 to 2
Last name             10 characters            3 to 12
First name            10 characters            13 to 22
Designation           10 characters            23 to 32
Department            15 characters            33 to 47
Year of joining       4 characters             48 to 51</pre></div><p>Using the preceding <a id="id172" class="indexterm"/>specification, let's fill a sample file with employee information in a fixed width file, as follows (<code class="literal">employees.txt</code>):</p><div class="informalexample"><pre class="programlisting">11Alden     Richie    associate   sales          1996
12Casey     Stanley   manager     sales          1999
13Rex       An        architect   development    2001
14Royce     Dan       writer      development    2006
15Merlin    Sams      accountant  finance        1995
16Olin      Covey     manager     finance        1989</pre></div><p>If a Java object is to be generated corresponding to this specification, we can create a <span class="strong"><strong>Plain Old Java Object</strong></span> (<span class="strong"><strong>POJO</strong></span>) with the following representation:</p><div class="informalexample"><pre class="programlisting">package batch;

import java.io.Serializable;

public class Employee implements Serializable {
  int id;
  String lastName;
  String firstName;
  String designation;
  String department;
  int yearOfJoining;
  
  public int getID() {
  return id;
  }
  public void setID(int id) {
    this.id = id;
  }
  public String getLastName() {
    return lastName;
  }
  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
  public String getFirstName() {
    return firstName;
  }
  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }
  public String getDesignation() {
    return designation;
  }
  public void setDesignation(String designation) {
    this.designation = designation;
  }
  public String getDepartment() {
    return department;
  }
  public void setDepartment(String department) {
    this.department = department;
  }
  public int getYearOfJoining() {
    return yearOfJoining;
  }
  public void setYearOfJoining(int yearOfJoining) {
    this.yearOfJoining = yearOfJoining;
  }
  
  public String toString() {
    return "Employee: ID="+ id + ", Last Name="+ lastName +
    ", First Name="+ firstName + ", Designation="+ designation +
    ", Department="+ department + ",Year of joining="+
    yearOfJoining;
    }
}</pre></div></div><div class="section" title="FlatFileItemReader"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec02"/>FlatFileItemReader</h3></div></div></div><p>
<code class="literal">FlatFileItemReader</code> <a id="id173" class="indexterm"/>provides a means of <a id="id174" class="indexterm"/>reading different types of flat files and parsing them by the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">resource</code>: This <a id="id175" class="indexterm"/>represents the file from which the data has to be read.</li><li class="listitem" style="list-style-type: disc"><code class="literal">lineMapper</code>: This <a id="id176" class="indexterm"/>represents the mapper that converts the String that is read by <code class="literal">ItemReader</code> to the Java object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">linesToSkip</code>: This <a id="id177" class="indexterm"/>is used with files having header content before records. It is the number of lines we want to ignore at the top of the file.</li></ul></div></div><div class="section" title="LineMapper"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec03"/>LineMapper</h3></div></div></div><p>The <code class="literal">LineMapper</code> <a id="id178" class="indexterm"/>interface lets us read each line from the file with the line number passed in every iteration. It is the Spring Batch standard <a id="id179" class="indexterm"/>implementation of <code class="literal">LineMapper</code>. The following is <a id="id180" class="indexterm"/>the <code class="literal">LineMapper</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface LineMapper&lt;T&gt; {

T mapLine(String line, int lineNumber) throws Exception;

}</pre></div><p>The <code class="literal">LineTokenizer</code> interface converts the line read from <code class="literal">LineMapper</code> to the set of fields (<code class="literal">FieldSet</code>). <code class="literal">DelimitedLineTokenizer</code>, <code class="literal">FixedLengthTokenizer</code>, and <code class="literal">PatternMatchingCompositeLineTokenizer</code> are Spring Batch's supporting implementations of <code class="literal">LineTokenizer</code>. The following is the <code class="literal">LineTokenizer</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface LineTokenizer {

FieldSet tokenize(String line);

}</pre></div><p>The <code class="literal">FieldSetMapper</code> interface lets us map each field from the String read to the <code class="literal">Employee</code> object. The following is the <code class="literal">FieldSetMapper</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface FieldSetMapper&lt;T&gt; {

  T mapFieldSet(FieldSet fieldSet);

}</pre></div><p>We can implement <code class="literal">FieldSetMapper</code> for our <code class="literal">Employee</code> data, as follows:</p><div class="informalexample"><pre class="programlisting">package batch;

import org.springframework.batch.item.file.mapping.FieldSetMapper;
import org.springframework.batch.item.file.transform.FieldSet;

class EmployeeFieldSetMapper implements FieldSetMapper&lt;Employee&gt; {
  public Employee mapFieldSet(FieldSet fieldSet) {
    Employee emp = new Employee();
    emp.setID(fieldSet.readInt("ID")); 
    emp.setLastName(fieldSet.readString("lastName"));
    emp.setFirstName(fieldSet.readString("firstName"));
    emp.setDesignation(fieldSet.readString("designation"));
    emp.setDepartment(fieldSet.readString("department"));
    emp.setYearOfJoining(fieldSet.readInt("yearOfJoining"));
    return emp;
  }
}</pre></div><p>The data can be read <a id="id181" class="indexterm"/>from the file as part of the batch job, <a id="id182" class="indexterm"/>as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">FlatFileItemReader&lt;Employee&gt; itemReader = new FlatFileItemReader&lt;Employee&gt;();
itemReader.setResource(new FileSystemResource("employees.txt"));
// FixedLengthTokenizer reads each field of length specified
DefaultLineMapper&lt;Employee&gt; lineMapper = new DefaultLineMapper&lt;Employee&gt;();
FixedLengthTokenizer lineTokenizer = new FixedLengthTokenizer();

lineMapper.setLineTokenizer(lineTokenizer);
lineMapper.setFieldSetMapper(new EmployeeFieldSetMapper());
itemReader.setLineMapper(lineMapper);
itemReader.open);
Employee ;
while (employee != null) {
  employee = itemReader.read();
  if (employee == null) {
    return RepeatStatus.FINISHED;
  }
  System.out.println(employee.toString());
}</pre></div><p>The <code class="literal">setResource()</code> method sends the flat file resource to <code class="literal">FlatFileItemReader</code>. The <code class="literal">LineTokenizer</code> interface can be used with field names and ranges with the start and end positions on the file set as an array using the <code class="literal">setNames()</code> and <code class="literal">setColumns()</code> methods respectively. Every <a id="id183" class="indexterm"/>time the <code class="literal">read()</code> method is invoked on <code class="literal">itemReader</code>, it reads a line and moves on to the next.</p><p>The following is the <a id="id184" class="indexterm"/>output of the batch program after reading data from a fixed width flat file and capturing them into Java objects:</p><div class="informalexample"><pre class="programlisting">** Executing the fixed width file read batch job! **
Employee: ID=11, Last Name=Alden, First Name=Richie, Designation=associate, Department=sales,Year of joining=1996
Employee: ID=12, Last Name=Casey, First Name=Stanley, Designation=manager, Department=sales,Year of joining=1999
Employee: ID=13, Last Name=Rex, First Name=An, Designation=architect, Department=development,Year of joining=2001
Employee: ID=14, Last Name=Royce, First Name=Dan, Designation=writer, Department=development,Year of joining=2006
Employee: ID=15, Last Name=Merlin, First Name=Sams, Designation=accountant, Department=finance,Year of joining=1995
Employee: ID=16, Last Name=Olin, First Name=Covey, Designation=manager, Department=finance,Year of joining=1989
Exit Status : COMPLETED</pre></div><p>The <a id="id185" class="indexterm"/>
<code class="literal">reader</code>, <code class="literal">linetokenizer</code>, and <code class="literal">fieldsetmapper</code> are used in the batch as beans, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;beans:bean id="employeeFile" 
class="org.springframework.core.io.FileSystemResource" &gt; 
&lt;beans:constructor-arg value=""/&gt; 
&lt;/beans:bean&gt; 
&lt;beans:bean id="employeeReader" 
class="org.springframework.batch.item.file.FlatFileItemReader"&gt; 
&lt;beans:property name="resource" ref="employeeFile" /&gt; 
&lt;beans:property name="lineMapper"&gt; 
&lt;beans:bean class="org.springframework.batch.item.file.mapping.
DefaultLineMapper"&gt; 
&lt;beans:property name="lineTokenizer"&gt; 
&lt;beans:bean class="org.springframework.batch.item.file.transform. 
FixedLengthTokenizer"&gt; 
&lt;beans:property name="names" value="ID, lastName, firstName, designation, department, yearOfJoining"/&gt; 
&lt;beans:property name="columns" value="1-2,3-12,13-22,23-32,33-47,48-51"/&gt; 
&lt;/beans:bean&gt; 
&lt;/beans:property&gt; 
&lt;beans:property name="fieldSetMapper"&gt; 
 
 
&lt;/beans:bean&gt; 
&lt;/beans:property&gt; 
&lt;/beans:bean&gt; 
&lt;/beans:property&gt; 
&lt;/beans:bean&gt; 
&lt;beans:bean id="employee" class="" /&gt;batchstep</pre></div></div><div class="section" title="Delimited file"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Delimited file</h3></div></div></div><p>A delimited flat <a id="id186" class="indexterm"/>file contains fields separated by a <a id="id187" class="indexterm"/>specific character in each line. The following is an example of a delimited file, with each field delimited by the character comma. Let's take an example of reading employee details from a delimited flat file.</p><p>The following are the specifications of the file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ID</li><li class="listitem" style="list-style-type: disc">Last name</li><li class="listitem" style="list-style-type: disc">First name</li><li class="listitem" style="list-style-type: disc">Designation</li><li class="listitem" style="list-style-type: disc">Department</li><li class="listitem" style="list-style-type: disc">Year of joining</li></ul></div><p>Each field should be separated from the other with a comma. The following is the sample file content (<code class="literal">employees.csv</code>):</p><div class="informalexample"><pre class="programlisting">1,Alden,Richie,associate,sales,1996
2,Casey,Stanley,manager,sales,1999
3,Rex,An,architect,development,2001
4,Royce,Dan,writer,development,2006
5,Merlin,Sams,accountant,finance,1995
6,Olin,Covey,manager,finance,1989</pre></div><p>Delimited files need to be handled the same way as the fixed width flat files, except that <code class="literal">LineTokenizer</code> used in this case should be <code class="literal">DelimitedLineTokenizer</code>. The following is the Java code realized to read a delimited flat file to be handled as part of the batch job:</p><div class="informalexample"><pre class="programlisting">// Delimited File Read
FlatFileItemReader&lt;Employee&gt; itemReader = new FlatFileItemReader&lt;Employee&gt;();
itemReader.setResource(new FileSystemResource("employees.csv"));
// DelimitedLineTokenizer defaults to comma as its delimiter
DefaultLineMapper&lt;Employee&gt; lineMapper = new DefaultLineMapper&lt;Employee&gt;();
DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();
lineTokenizer.setNames(new String[] { "ID", "lastName", "firstName", "designation", "department", "yearOfJoining" });
lineMapper.setLineTokenizer(lineTokenizer);
lineMapper.setFieldSetMapper(new EmployeeFieldSetMapper());
itemReader.setLineMapper(lineMapper);
itemReader.open(new ExecutionContext());
  employee = itemReader.read();
  if (employee == null) {
    return RepeatStatus.FINISHED;
  }
  System.out.println(employee.toString());
}</pre></div><p>With the delimited files, we don't have to set the column's property. The delimiter used has to be set unless <a id="id188" class="indexterm"/>the delimiter is a comma. Executing <a id="id189" class="indexterm"/>this program should read the delimited flat files into the Java objects and the output is as follows:</p><div class="informalexample"><pre class="programlisting">** Executing the delimited file read batch job! **
Employee: ID=1, Last Name=Alden, First Name=Richie, Designation=associate, Department=sales,Year of joining=1996
Employee: ID=2, Last Name=Casey, First Name=Stanley, Designation=manager, Department=sales,Year of joining=1999
Employee: ID=3, Last Name=Rex, First Name=An, Designation=architect, Department=development,Year of joining=2001
Employee: ID=4, Last Name=Royce, First Name=Dan, Designation=writer, Department=development,Year of joining=2006
Employee: ID=5, Last Name=Merlin, First Name=Sams, Designation=accountant, Department=finance,Year of joining=1995
Employee: ID=6, Last Name=Olin, First Name=Covey, Designation=manager, Department=finance,Year of joining=1989
Exit Status : COMPLETED</pre></div><p>The <code class="literal">ItemReader</code>, <code class="literal">LineTokenizer</code>, and <code class="literal">FieldSetMapper</code> in the case of delimited files can be configured in the batch as beans and used in the program as follows:</p><div class="informalexample"><pre class="programlisting">&lt;beans:bean id="employeeFile" 
  class="org.springframework.core.io.FileSystemResource" 
  scope="step"&gt; 
&lt;beans:constructor-arg value="#{jobParameters[employeeFile]}"/&gt; 
&lt;/beans:bean&gt; 
&lt;beans:bean id="employeeFileReader" class="org.springframework.batch.item.file.FlatFileItemReader"&gt; 
&lt;beans:property name="resource" ref="employeeFile" /&gt; 
&lt;beans:property name="lineMapper"&gt; 
&lt;beans:bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper"&gt; 
&lt;beans:property name="lineTokenizer"&gt; 
&lt;beans:bean class="org.springframework.batch.item.file.transform. 
DelimitedLineTokenizer"&gt; 
&lt;beans:property name="names" value="ID, lastName, firstName, designation, department, yearOfJoining"/&gt; 
&lt;beans:property name="delimiter" value=","/&gt; 
&lt;/beans:bean&gt; 
&lt;/beans:property&gt; 
&lt;beans:property name="fieldSetMapper"&gt; 
&lt;beans:bean 
class="batch.EmployeeFieldSetMapper"/&gt; 
&lt;/beans:property&gt; 
&lt;/beans:bean&gt; 
&lt;/beans:property&gt; 
&lt;/beans:bean&gt;</pre></div><p>If the lines of file are defined in a different format specific to a business, <code class="literal">LineTokenizer</code> is open <a id="id190" class="indexterm"/>for custom implementation and configuration. The <code class="literal">PatternMatchingCompositeLineMapper</code> can be used to read files with complex patterns. For example, if <a id="id191" class="indexterm"/>we have multiple record types within a single flat file, we can use <code class="literal">PatternMatchingCompositeLineMapper</code> to have tokenizers for each record type, as follows.</p><p>A sample flat file with multiple record types:</p><div class="informalexample"><pre class="programlisting">EMPLOYEE,Steve,Jacob,21,manager,2009
BANKINFO,524851478569,STEVEJACOB,REDROSECITY
ADDRESSINFO,No24,SUNFLOWERWAY,CASAYA</pre></div><p>The following is the bean configuration for this multiple record type:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="employeeFileLineMapper"
class=" org.springframework.batch.item.file.mapping.PatternMatchingCompositeLineMapper"&gt;
&lt;property name="tokenizers"&gt;
&lt;map&gt;
&lt;entry key="EMPLOYEE*" value-ref="employeeTokenizer"/&gt;
&lt;entry key="BANKINFO*" value-ref="bankInfoTokenizer"/&gt;
&lt;entry key="ADDRESSINFO*" value-ref="addressInfoTokenizer"/&gt;
&lt;/map&gt;
&lt;/property&gt;
&lt;property name="fieldSetMappers"&gt;
&lt;map&gt;
&lt;entry key="EMPLOYEE*" value-ref="employeeFieldSetMapper"/&gt;
&lt;entry key="BANKINFO*" value-ref="bankInfoFieldSetMapper"/&gt;
&lt;entry key="ADDRESSINFO*" value-ref="addressInfoFieldSetMapper"/&gt;
&lt;/map&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div><p>The <code class="literal">PatternMatchingCompositeLineMapper</code> identifies each line by its pattern, with matching keys <a id="id192" class="indexterm"/>to let the corresponding <a id="id193" class="indexterm"/>
<code class="literal">Tokenizer</code> and <code class="literal">FieldSetMapper</code> read and match the records.</p></div><div class="section" title="Exceptions from flat file reading"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Exceptions from flat file reading</h3></div></div></div><p>The following <a id="id194" class="indexterm"/>are the possible exceptions from flat files, for example when in <a id="id195" class="indexterm"/>case the file has an incorrect format, a problem in reading the data from file, or inconsistent data in the flat file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FlatFileParseException</code>: This is the exception thrown by <code class="literal">FlatFileItemReader</code> <a id="id196" class="indexterm"/>for the errors that occur <a id="id197" class="indexterm"/>during file reading</li><li class="listitem" style="list-style-type: disc"><code class="literal">FlatFileFormatException</code>: This <a id="id198" class="indexterm"/>is the exception <a id="id199" class="indexterm"/>thrown by <code class="literal">LineTokenizer</code> for the errors that occur during data tokenizing</li><li class="listitem" style="list-style-type: disc"><code class="literal">IncorrectTokenCountException</code>: This is thrown if the number of columns <a id="id200" class="indexterm"/>specified do not match with the <a id="id201" class="indexterm"/>number of columns tokenized</li><li class="listitem" style="list-style-type: disc"><code class="literal">IncorrectLineLengthException</code>: This is thrown during the fixed width flat file <a id="id202" class="indexterm"/>reading if the line/field lengths do <a id="id203" class="indexterm"/>not match with the ones specified</li></ul></div></div></div><div class="section" title="Reading data from XML"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Reading data from XML</h2></div></div></div><p>
<span class="strong"><strong>Extensible </strong></span><a id="id204" class="indexterm"/>
<span class="strong"><strong>Markup Language</strong></span> (<span class="strong"><strong>XML</strong></span>) is a markup language to <a id="id205" class="indexterm"/>define documents with data that <a id="id206" class="indexterm"/>can be readable by both humans and machines. XML is mainly used when multiple systems interact with each other.</p><p>Spring Batch <a id="id207" class="indexterm"/>uses the <span class="strong"><strong>Streaming API for XML</strong></span> (<span class="strong"><strong>StAX</strong></span>) parser. In the StAX metaphor, the programmatic entry point is a cursor that represents a <a id="id208" class="indexterm"/>point <a id="id209" class="indexterm"/>within the document. The application moves the cursor forward, 'pulling' the information from the parser as required. Hence, the reading happens in fragments of XML content from a file that is represented in the following figure:</p><div class="mediaobject"><img src="Images/3372OS_03_02.jpg" alt="Reading data from XML" width="477" height="460"/></div><p>The <code class="literal">StaxItemReader</code> lets us parse the XML file, considering that the root element of each fragment is <a id="id210" class="indexterm"/>common (<code class="literal">employee</code> in the above example). <code class="literal">unmarshaller</code> converts the data into Java objects.</p><p>The following <a id="id211" class="indexterm"/>are the <code class="literal">employeeFile</code> and <code class="literal">employeeFileReader</code> <a id="id212" class="indexterm"/>configuration as beans:</p><div class="informalexample"><pre class="programlisting">&lt;beans:bean id="employeeFile" 
class="org.springframework.core.io.FileSystemResource" scope="step"&gt; 
&lt;beans:constructor-arg value="#{jobParameters[employeeFile]}"/&gt; 
&lt;/beans:bean&gt; 
&lt;beans:bean id="employeeFileReader" 
class="org.springframework.batch.item.xml.StaxEventItemReader"&gt; 
&lt;beans:property name="fragmentRootElementName" value="employee" /&gt; 
&lt;beans:property name="resource" ref="employeeFile" /&gt; 
&lt;beans:property name="unmarshaller" ref="employeeMarshaller" /&gt; 
&lt;/beans:bean&gt;</pre></div><p>We can use different unmarshalling technologies, including JAXB, XStream binding, JiBX, and XML Beans. We used StAX as an engine for marshalling. Let's consider the XStream binding <a id="id213" class="indexterm"/>and the following configuration with it:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="employeeMarshaller"
class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
&lt;property name="aliases"&gt;
&lt;util:map id="aliases"&gt;
&lt;entry key="employee"
value="batch.Employee" /&gt;
&lt;entry key="ID" value="java.lang.Integer" /&gt;
&lt;/util:map&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="informalexample"><pre class="programlisting">StaxEventItemReader xmlStaxEventItemReader = ;
Resource resource = ( .getBytes());
Map aliases = new HashMap();
aliases.put("employee","batch.Employee");
aliases.put("ID","java.lang.Integer");
Marshaller marshaller = newXStreamMarshaller();
marshaller.setAliases(aliases);
xmlStaxEventItemReader.setUnmarshaller(marshaller);
xmlStaxEventItemReader.setResource(resource);
xmlStaxEventItemReader.setFragmentRootElementName("employee");
xmlStaxEventItemReader.open(newExecutionContext());
boolean hasNext = true;
Employee employee = null;
while(hasNext) {
  employee = xmlStaxEventItemReader.read();
  if(employee == null) {
    hasNext = false;
  }
  else{
    System.out.println(employee.getName());
  }
}</pre></div><p>If more than one file has the <a id="id214" class="indexterm"/>XML details to be read, we can use <a id="id215" class="indexterm"/>
<code class="literal">MuliResourceItemReader</code> to configure multiple resources to be read in a read operation.</p></div><div class="section" title="Reading data from a database"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Reading data from a database</h2></div></div></div><p>A database <a id="id216" class="indexterm"/>contains information in the form of tables with <a id="id217" class="indexterm"/>multiple columns to hold each field in it. If a <a id="id218" class="indexterm"/>batch job has to read the data from a database, it can be performed using the following two types of item reading concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cursor-based </strong></span><a id="id219" class="indexterm"/><span class="strong"><strong>item reading</strong></span>: This reads each <a id="id220" class="indexterm"/>fragment having a cursor pointing to one after the other</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Page-based </strong></span><a id="id221" class="indexterm"/><span class="strong"><strong>item reading</strong></span>: This <a id="id222" class="indexterm"/>reads multiple records together, considering them as a page</li></ul></div><p>In comparison, cursor-based item reading works well as it reads little data and processes unless their memory leaks with the system.</p><div class="section" title="JdbcCursorItemReader"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>JdbcCursorItemReader</h3></div></div></div><p>To <a id="id223" class="indexterm"/>read the data in a cursor-based <a id="id224" class="indexterm"/>technique, we can use <code class="literal">JdbcCursorItemReader</code>. It configures with <code class="literal">RowMapper</code> (of Spring framework) to match each attribute in the database to the Java object attributes.</p><p>The <code class="literal">RowMapper</code> for the employee example can be implemented as follows:</p><div class="informalexample"><pre class="programlisting">public class EmployeeRowMapper implements RowMapper {
public static final String ID_COLUMN = "id";
public static final String LAST_NAME_COLUMN = "lastname";
public static final String FIRST_NAME_COLUMN = "firstname";
public static final String DESIGNATIoN_COLUMN = "designation";
public static final String DEPARTMENT_COLUMN = "department";
public static final String YEAR_OF_JOINING_COLUMN = "yearOfJoining";

public Object mapRow(ResultSet rs, int rowNum) throws SQLException 
  {
  Employee employee = new Employee();
  employee.setId(rs.getInt(ID_COLUMN));
  employee.setLastName(rs.getString(LAST_NAME_COLUMN));
  employee.setFirstName(rs.getString(FIRST_NAME_COLUMN));
  employee.setDesignation(rs.getString(DESIGNATION_COLUMN));
  employee.setDepartment(rs.getString(DEPARTMENT_COLUMN));
  employee.setYearOfJoining(rs.getString(YEAR_OF_JOINING_COLUMN));
  return employee;
  }
}</pre></div><p>The Java program <a id="id225" class="indexterm"/>to read the data from the database with <code class="literal">EmployeeRowMapper</code> can be realized as follows:</p><div class="informalexample"><pre class="programlisting">JdbcCursorItemReader itemReader = new JdbcCursorItemReader();
itemReader.setDataSource(dataSource);
itemReader.setSql("SELECT ID, LASTNAME, FIRSTNAME,DESIGNATION,DEPARTMENT,YEAROFJOINING from EMPLOYEE");
itemReader.setRowMapper(new EmployeeRowMapper());
int counter = 0;
ExecutionContext executionContext = new ExecutionContext();
itemReader.open(executionContext);
Object employee = newObject();
while(employee != null){
employee = itemReader.read();
counter++;
}
itemReader.close(executionContext);</pre></div><p>The <a id="id226" class="indexterm"/>
<code class="literal">JdbcCursorItemReader</code> and <code class="literal">EmployeeRowMapper</code> can be configured in the batch XML as follows:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="itemReader" class=" org.springframework.batch.item.database.JdbcCursorItemReader"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;property name="sql" value=" SELECT ID, LASTNAME, FIRSTNAME,DESIGNATION,DEPARTMENT,YEAROFJOINING from EMPLOYEE "/&gt;
  &lt;property name="rowMapper"&gt;
    &lt;bean class="batch.EmployeeRowMapper"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre></div><p>
<code class="literal">JdbcCursorItemReader</code> can be customized by setting ignore warnings, fetch size, max rows, query timeout, verify cursor position, and such properties with the corresponding options for respective items.</p><p>If we want to configure the database read activity using the Hibernate framework, we can use <code class="literal">HibernateCursorItemReader</code>. The stored procedure-based read operation can be performed using the <a id="id227" class="indexterm"/>
<code class="literal">StoredProcedureItemReader</code>.</p></div><div class="section" title="JdbcPagingItemReader"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>JdbcPagingItemReader</h3></div></div></div><p>The paging <a id="id228" class="indexterm"/>mode read operation on a database can be performed using the <code class="literal">JdbcPagingItemReader</code>. The configuration with <a id="id229" class="indexterm"/>the <code class="literal">JdbcPagingItemReader</code> with the properties of <code class="literal">dataSource</code>, <code class="literal">queryProvider</code>, and query with different clauses can be done as follows:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="itemReader" class=" JdbcPagingItemReader.JdbcPagingItemReader"&gt;
&lt;property name="dataSource" ref="dataSource"/&gt;
&lt;property name="queryProvider"&gt;
&lt;bean class=" org.springframework.batch.item.database.support.SqlPagingQueryProviderFactoryBean"&gt;
&lt;property name="selectClause" value=" SELECT ID, LASTNAME, FIRSTNAME,DESIGNATION,DEPARTMENT,YEAROFJOINING "/&gt;
&lt;property name="fromClause" value="from EMPLOYEE"/&gt;
&lt;property name="whereClause" value="where designation=:designation"/&gt;
&lt;property name="sortKey" value="id"/&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="parameterValues"&gt;
&lt;map&gt;
&lt;entry key="designation" value="manager"/&gt;
&lt;/map&gt;
&lt;/property&gt;
&lt;property name="pageSize" value="100"/&gt;
&lt;property name="rowMapper" ref="employeeMapper"/&gt;
&lt;/bean&gt;</pre></div><p>Using the <code class="literal">SqlPagingQueryProviderFactoryBean</code>, we can set the <code class="literal">select</code>, <code class="literal">from</code>, and <code class="literal">where</code> clauses separately, along with a sortkey and parameter to be passed.</p><p>Spring Batch <a id="id230" class="indexterm"/>supports different object relational frameworks as well the corresponding item readers such as <code class="literal">JpaPagingItemReader</code> for JPA and <code class="literal">IbatisPagingItemReader</code> for IBatis.</p></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Data processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Data processing</h1></div></div></div><p>Spring Batch <a id="id231" class="indexterm"/>provides the means to read input data in one form, process it, and return it in a desired form of output data. The <code class="literal">ItemProcessor</code> interface is the interface that supports the processing activity.</p><div class="section" title="ItemProcessor"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>ItemProcessor</h2></div></div></div><p>Spring Batch <a id="id232" class="indexterm"/>provides the simple interface <code class="literal">ItemProcessor</code> <a id="id233" class="indexterm"/>to take the object, process it, and transform it to the desired form and return as another object.</p><p>The following is the definition of the <code class="literal">ItemProcessor</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface ItemProcessor&lt;I, O&gt; {

O process(I item) throws Exception;

}</pre></div><p>
<code class="literal">ValidatingItemProcessor</code> is an implementation of the <code class="literal">ItemProcessor</code> that lets us validate the input data before processing. If the data fails to pass the validation, it gives <code class="literal">org.springframework.batch.item.validator.ValidationException</code>. Frameworks such as Hibernate have the validation framework (<code class="literal">hibernate-validator</code>) that lets us configure annotation-based validators for the beans.</p><p>The <code class="literal">ItemProcessor</code> can be implemented for the <code class="literal">Employee</code> example as follows:</p><div class="informalexample"><pre class="programlisting">public class Employee {}
public class Associate {
public Associate (Employee employee) {}
}
public class EmployeeProcessor implements ItemProcessor&lt;Employee,Associate&gt;{
public Associate process(Employee employee) throws Exception {
  return new Associate(employee);
}
}</pre></div><p>The preceding program <a id="id234" class="indexterm"/>takes the <code class="literal">employee</code> data object, transforms the object, and returns an <code class="literal">Associate</code> data object.</p><p>The <code class="literal">itemProcessor</code> can be configured as a job chunk in the following format:</p><div class="informalexample"><pre class="programlisting">&lt;job id="jobId"&gt;
&lt;step name="stepName"&gt;
&lt;tasklet&gt;
&lt;chunk reader="itemReaderName" processor="itemProcessorName" writer="itemWriterName" commit-interval="2"/&gt;
&lt;/tasklet&gt;
&lt;/step&gt;
&lt;/job&gt;</pre></div></div><div class="section" title="Chaining the process"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Chaining the process</h2></div></div></div><p>The processing <a id="id235" class="indexterm"/>activity can be chained by defining more than one item processor and calling from one another to make <code class="literal">compositeItemProcessor</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;job id="jobId"&gt;
&lt;step name="stepName"&gt;
&lt;tasklet&gt;
&lt;chunk reader="itemReaderName" processor="compositeItemProcessorName" writer="itemWriterName"
commit-interval="2"/&gt;
&lt;/tasklet&gt;
&lt;/step&gt;
&lt;/job&gt; 
      &lt;bean id="compositeItemProcessorName"
class="org.springframework.batch.item.support.CompositeItemProcessor"&gt;
&lt;property name="delegates"&gt;
&lt;list&gt;
&lt;bean class="batch.EmployeeProcessor"/&gt;
&lt;bean class="batch.AssociateProcessor"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Data writing"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Data writing</h1></div></div></div><p>Spring Batch provides the <a id="id236" class="indexterm"/>configuration to write the read and processed data to a <a id="id237" class="indexterm"/>different output (destination). The writer can integrate easily with different relational frameworks. It can also be customized for the different formats.</p><div class="section" title="ItemWriter"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>ItemWriter</h2></div></div></div><p>Spring Batch <a id="id238" class="indexterm"/>provides an interface in the form of <code class="literal">ItemWriter</code> to <a id="id239" class="indexterm"/>write bulk data. The following is the definition of the <code class="literal">ItemWriter</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface ItemWriter&lt;T&gt; {

void write(List&lt;? extends T&gt; items) throws Exception;

}</pre></div><p>Based on the destination <a id="id240" class="indexterm"/>platform onto which we have to write the data, we have the following item writers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flat file item writers</strong></span>: These write the content onto a flat file (fixed width and delimited)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>XML item writers</strong></span>: These write the data onto an XML file</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Database item writers</strong></span>: These write the data onto a database</li></ul></div><div class="section" title="Flat file item writers"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Flat file item writers</h3></div></div></div><p>The data read <a id="id241" class="indexterm"/>from any of the existing formats can be processed to the <a id="id242" class="indexterm"/>desired format and then be written onto multiple formats, including flat files. The following are the APIs that help in flat file item writing.</p><div class="section" title="LineAggregator"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec01"/>LineAggregator</h4></div></div></div><p>The <code class="literal">LineAggregator</code> <a id="id243" class="indexterm"/>API concatenates multiple fields into a String to write <a id="id244" class="indexterm"/>onto the flat file. This works exactly the opposite way of <code class="literal">LineTokenizer</code> in the read operation.</p><div class="informalexample"><pre class="programlisting">public interface LineAggregator&lt;T&gt; {

  public String aggregate(T item);

}</pre></div></div><div class="section" title="PassThroughLineAggregator"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec02"/>PassThroughLineAggregator</h4></div></div></div><p>
<code class="literal">PassThroughLineAggregator</code> is <a id="id245" class="indexterm"/>an implementation of <a id="id246" class="indexterm"/>
<code class="literal">LineAggreagator</code> that considers the object in use is already aggregated and simply returns the String from the object using the <code class="literal">toString()</code> method.</p><div class="informalexample"><pre class="programlisting">public class PassThroughLineAggregator&lt;T&gt; implements LineAggregator&lt;T&gt; {

  public String aggregate(T item) {

    return item.toString();

  }

}</pre></div><p>The <code class="literal">FlatFileItemWriter</code> <a id="id247" class="indexterm"/>can be configured with the <a id="id248" class="indexterm"/>
<code class="literal">PassThroughLineAggregator</code> , as follows:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="itemWriter" class=" org.springframework.batch.item.file.FlatFileItemWriter"&gt;
&lt;property name="resource" value="file:target/outputfiles/employee_output.txt"/&gt;
&lt;property name="lineAggregator"&gt;
&lt;bean class=" org.springframework.batch.item.file.transform.PassThroughLineAggregator"/&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div></div></div><div class="section" title="FieldExtractor"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>FieldExtractor</h3></div></div></div><p>If the object <a id="id249" class="indexterm"/>writing is more than just writing its String form onto the file, <code class="literal">FieldExtractor</code> needs to be used, wherein each object gets converted to the <a id="id250" class="indexterm"/>array of fields, aggregated together to form a String to <a id="id251" class="indexterm"/>write onto the file.</p><div class="informalexample"><pre class="programlisting">public interface FieldExtractor&lt;T&gt; {

  Object[] extract(T item);

}</pre></div><p>Field extractors are primarily of two types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PassThroughFieldExtractor</code>: For the scenario where the object collection has to <a id="id252" class="indexterm"/>just be converted to the array and passed to <a id="id253" class="indexterm"/>write</li><li class="listitem" style="list-style-type: disc"><code class="literal">BeanWrapperFieldExtractor</code>: With a field-level configuration of how each field <a id="id254" class="indexterm"/>of the object gets placed in the String to <a id="id255" class="indexterm"/>write onto the file, this works exactly the opposite way of <code class="literal">BeanWrapperFieldSetMapper</code></li></ul></div><p>The <code class="literal">BeanWrapperFieldSetExtractor</code> works as follows:</p><div class="informalexample"><pre class="programlisting">BeanWrapperFieldExtractor&lt;Employee&gt; extractor = new BeanWrapperFieldExtractor&lt;Employee&gt;();
extractor.setEmployees(new String[] { "id", "lastname", "firstname","designation","department","yearofjoining"});
int id = 11;
String lastname = "Alden";
String firstname = "Richie";
String desination = "associate";
String department = "sales";
int yearofjoining = 1996;
Employee employee = new Employee(id, lastname, firstname,designation, department, yearofjoining);
Object[] values = extractor.extract(n);
assertEquals(id, values[0]);
assertEquals(lastname, values[1]);
assertEquals(firstname, values[2]);
assertEquals(designation, values[3]);
assertEquals(department, values[4]);
assertEquals(yearofjoining, values[5]);</pre></div></div><div class="section" title="Writing delimited files"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Writing delimited files</h3></div></div></div><p>If the Java <a id="id256" class="indexterm"/>object can be written onto the flat files in delimited file format, we can perform it as shown in the following example. Let's consider the <code class="literal">Employee</code> object defined already.</p><p>This object <a id="id257" class="indexterm"/>can be configured with the <code class="literal">FlatFileItemWriter</code>, the <code class="literal">DelimitedLineAggregator</code>, and the <code class="literal">BeanWrapperFieldExtractor</code> to perform the delimited flat file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="itemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter"&gt;
&lt;property name="resource" ref="outputResource"/&gt;
&lt;property name="lineAggregator"&gt;
&lt;bean class=" org.springframework.batch.item.file.transform.DelimitedLineAggregator"&gt;
&lt;property name="delimiter" value=","/&gt;
&lt;property name="fieldExtractor"&gt;
&lt;bean class=" org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor"&gt;
&lt;property name="employees" value="id,lastname,firstname,designation,department,yearofjoining"/&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div></div><div class="section" title="Writing a fixed width file"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec11"/>Writing a fixed width file</h3></div></div></div><p>Spring Batch supports <a id="id258" class="indexterm"/>fixed width file writing with the help of <a id="id259" class="indexterm"/>
<code class="literal">FormatterLineAggregator</code>. Considering the same example data as delimited flat file writing, we can <a id="id260" class="indexterm"/>perform the fixed width file writing using the following configuration:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="itemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter"&gt;
&lt;property name="resource" ref="outputResource"/&gt;
&lt;property name="lineAggregator"&gt;
&lt;bean class=" org.springframework.batch.item.file.transform.FormatterLineAggregator"&gt;
&lt;property name="fieldExtractor"&gt;
&lt;bean class=" org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor"&gt;
&lt;property name="employees" value=" id,lastname,firstname,designation,department,yearofjoining"/&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="format" value="%-2d%-10s%-10s%-10s%-15s%-4d"/&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div><p>The format value is <a id="id261" class="indexterm"/>formed based on the following listed formatter conversions, where <code class="literal">arg</code> represents the argument for conversion:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Conversion</p>
</th><th style="text-align: left" valign="bottom">
<p>Category</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">b</code>, <code class="literal">B</code>
</p>
</td><td style="text-align: left" valign="top">
<p>general</p>
</td><td style="text-align: left" valign="top">
<p>This converts Boolean to the String format. The value is <code class="literal">false</code> for <code class="literal">null</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">h</code>, <code class="literal">H</code>
</p>
</td><td style="text-align: left" valign="top">
<p>general</p>
</td><td style="text-align: left" valign="top">
<p>This is the <code class="literal">Integer.toHexString(arg.hashCode())</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">s</code>, <code class="literal">S</code>
</p>
</td><td style="text-align: left" valign="top">
<p>general</p>
</td><td style="text-align: left" valign="top">
<p>If <code class="literal">arg</code> implements <code class="literal">Formattable</code>, then <code class="literal">arg.formatTo()</code> Otherwise, <code class="literal">arg.toString()</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">c</code>, <code class="literal">C</code>
</p>
</td><td style="text-align: left" valign="top">
<p>character</p>
</td><td style="text-align: left" valign="top">
<p>This is a Unicode character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">d</code>
</p>
</td><td style="text-align: left" valign="top">
<p>integral</p>
</td><td style="text-align: left" valign="top">
<p>This is a decimal integer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">o</code>
</p>
</td><td style="text-align: left" valign="top">
<p>integral</p>
</td><td style="text-align: left" valign="top">
<p>This is an octal integer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">x</code>, <code class="literal">X</code>
</p>
</td><td style="text-align: left" valign="top">
<p>integral</p>
</td><td style="text-align: left" valign="top">
<p>This is a hexadecimal integer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">e</code>, <code class="literal">E</code>
</p>
</td><td style="text-align: left" valign="top">
<p>floating point</p>
</td><td style="text-align: left" valign="top">
<p>This is a decimal number in computerized scientific notation</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">f</code>
</p>
</td><td style="text-align: left" valign="top">
<p>floating point</p>
</td><td style="text-align: left" valign="top">
<p>This is a decimal number</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">g</code>, <code class="literal">G</code>
</p>
</td><td style="text-align: left" valign="top">
<p>floating point</p>
</td><td style="text-align: left" valign="top">
<p>This is a computerized scientific notation or decimal format, depending on the precision and value after rounding</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">a</code>, <code class="literal">A</code>
</p>
</td><td style="text-align: left" valign="top">
<p>floating point</p>
</td><td style="text-align: left" valign="top">
<p>This is a hexadecimal floating point number with a significand and an exponent</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">t</code>, <code class="literal">T</code>
</p>
</td><td style="text-align: left" valign="top">
<p>date/time</p>
</td><td style="text-align: left" valign="top">
<p>This is the prefix for date and time conversion characters</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%</code>
</p>
</td><td style="text-align: left" valign="top">
<p>percent</p>
</td><td style="text-align: left" valign="top">
<p>This is a literal <code class="literal">%</code> (<code class="literal">\u0025</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">n</code>
</p>
</td><td style="text-align: left" valign="top">
<p>line separator</p>
</td><td style="text-align: left" valign="top">
<p>This is the platform-specific line separator</p>
</td></tr></tbody></table></div><p>
<code class="literal">FlatFileItemWriter</code> can be configured with the <code class="literal">shouldDeleteIfExists</code> option, to delete a file if it already <a id="id262" class="indexterm"/>exists in the specified location. The <a id="id263" class="indexterm"/>header and footer can be added to the flat <a id="id264" class="indexterm"/>file by implementing <code class="literal">FlatFileHeaderCallBack</code> and <code class="literal">FlatFileFooterCallBack</code> and including these beans with the <code class="literal">headerCallback</code> and <code class="literal">footerCallback</code> properties respectively.</p></div><div class="section" title="XML item writers"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec12"/>XML item writers</h3></div></div></div><p>The data can be <a id="id265" class="indexterm"/>written to the <span class="strong"><strong>Extensible Markup Language</strong></span> (<span class="strong"><strong>XML</strong></span>) format using <code class="literal">StaxEventItemWriter</code>. The Spring Batch configuration for <a id="id266" class="indexterm"/>this activity, for the employee example can be the following:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="itemWriter" class="org.springframework.batch.item.xml.StaxEventItemWriter"&gt;
  &lt;property name="resource" ref="outputResource"/&gt;
  &lt;property name="marshaller" ref="employeeMarshaller"/&gt;
  &lt;property name="rootTagName" value="employees"/&gt;
  &lt;property name="overwriteOutput" value="true"/&gt;
&lt;/bean&gt;</pre></div><p>Using the XStream to do the marshalling activity, the following is the configuration:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="employeeMarshaller"
class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
&lt;property name="aliases"&gt;
&lt;util:map id="aliases"&gt;
&lt;entry key="employee"
value="batch.Employee"/&gt;
&lt;entry key="ID" value="java.lang.Integer"/&gt;
&lt;/util:map&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div><p>The Java code for <a id="id267" class="indexterm"/>the preceding configuration can be realized as follows:</p><div class="informalexample"><pre class="programlisting">StaxEventItemWriter staxItemWriter = newStaxEventItemWriter();
FileSystemResource resource = new FileSystemResource("export/employee_output.xml")
Map aliases = newHashMap();
aliases.put("employee","batch.Employee");
aliases.put("ID","java.lang.Integer");
Marshaller marshaller = newXStreamMarshaller();
marshaller.setAliases(aliases);
staxItemWriter.setResource(resource);
staxItemWriter.setMarshaller(marshaller);
staxItemWriter.setRootTagName("employees");
staxItemWriter.setOverwriteOutput(true);
ExecutionContext executionContext = newExecutionContext();
staxItemWriter.open(executionContext);
Employee employee = new Employee();
employee.setID(11);
employee.setLastName("Alden");
employee.setFirstName("Richie");
employee.setDesignation("associate");
employee.setDepartment("sales");
employee.setYearOfJoining("1996");
staxItemWriter.write(employee);</pre></div></div></div><div class="section" title="Database item writers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Database item writers</h2></div></div></div><p>Spring Batch <a id="id268" class="indexterm"/>supports database item writing with two possible <a id="id269" class="indexterm"/>access types: JDBC and ORM.</p><div class="section" title="JDBC-based database writing"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec13"/>JDBC-based database writing</h3></div></div></div><p>Spring Batch supports <a id="id270" class="indexterm"/>JDBC-based database writing with the help of <a id="id271" class="indexterm"/>
<code class="literal">JdbcBatchItemWriter</code>, which is an implementation of <code class="literal">ItemWriter</code>, which executes multiple SQL statements in the batch mode. The following is the sample configuration for the employee example with the JDBC-based database writing:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="employeeWriter" class="org.springframework.batch.item.database.JdbcBatchItemWriter"&gt;
&lt;property name="assertUpdates" value="true" /&gt;
&lt;property name="itemPreparedStatementSetter"&gt;
&lt;bean class="batch.EmployeePreparedStatementSetter" /&gt;
&lt;/property&gt;
&lt;property name="sql"
value="INSERT INTO EMPLOYEE (ID, LASTNAME, FIRSTNAME, DESIGNATION, DEPARTMENT, YEAROFJOINING) VALUES(?, ?, ?, ?, ?, ?)" /&gt;
&lt;property name="dataSource" ref="dataSource" /&gt;
&lt;/bean&gt; </pre></div><p>The <a id="id272" class="indexterm"/>
<code class="literal">ItemPreparedStatementSetter</code> can be implemented <a id="id273" class="indexterm"/>for our example of <code class="literal">Employee</code> data as follows:</p><div class="informalexample"><pre class="programlisting">public class EmployeePreparedStatementSetter 
implements ItemPreparedStatementSetter&lt;Employee&gt; {

@Override
public void setValues(Employee item, PreparedStatement ps) throws SQLException {
  ps.setInt(1, item.getId()); 
  ps.setString(2, item.getLastName()); 
  ps.setString(3, item.getFirstName()); 
  ps.setString(4, item.getDesignation()); 
  ps.setString(5, item.getDepartment()); 
  ps.setInt(6, item.getYearOfJoining()); 
}
}</pre></div></div><div class="section" title="ORM-based database writing"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec14"/>ORM-based database writing</h3></div></div></div><p>
<span class="strong"><strong>Object </strong></span><a id="id274" class="indexterm"/>
<span class="strong"><strong>relational mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>) is defined <a id="id275" class="indexterm"/>as a programming technique to <a id="id276" class="indexterm"/>convert data between incompatible type systems in object-oriented programming languages. ORM takes care of the data persistence from the object oriented program to the database. Spring Batch supports multiple ORMs including Hibernate, JPA, and iBatis.</p><div class="mediaobject"><img src="Images/3372OS_03_03.jpg" alt="ORM-based database writing" width="600" height="173"/></div><p>In our example, the <a id="id277" class="indexterm"/>
<code class="literal">Employee</code> class should be annotated to be <a id="id278" class="indexterm"/>used with ORM (Hibernate/JPA) for persistence as follows:</p><div class="informalexample"><pre class="programlisting">@Entity("employee")
public class Employee {
@Id("id")
private int id;
@Column("lastName")
private String lastName;
@Column("firstName")
private String firstName;
@Column("designation")
private String designation;
@Column("department")
private String department;
@Column("yearOfJoining")
private int yearOfJoining;

public int getID() {
  return id;
}
public void setID(int id) {
  this.id = id;
}
public String getLastName() {
  return lastName;
}
public void setLastName(String lastName) {
  this.lastName = lastName;
}
public String getFirstName() {
  return firstName;
}
public void setFirstName(String firstName) {
  this.firstName = firstName;
}
public String getDesignation() {
  return designation;
}
public void setDesignation(String designation) {
  this.designation = designation;
}
public String getDepartment() {
  return department;
}
public void setDepartment(String department) {
  this.department = department;
}
public int getYearOfJoining() {
  return yearOfJoining;
}
public void setYearOfJoining(int yearOfJoining) {
  this.yearOfJoining = yearOfJoining;
}
}</pre></div><p>The annotations specify that the class <code class="literal">Employee</code> is representing a corresponding table in the database with a name as shown with <code class="literal">@Entity</code>, and each field corresponds to a column in the database <a id="id279" class="indexterm"/>as shown with the <code class="literal">@ID</code> and <code class="literal">@Column</code> annotations.</p><p>The following is the <a id="id280" class="indexterm"/>configuration to be made with Hibernate for the employee example:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="employeeWriter"
class="org.springframework.batch.item.database.HibernateItemWriter"&gt;
&lt;property name="hibernateTemplate" ref="hibernateTemplate" /&gt;
&lt;/bean&gt;</pre></div><p>Similarly, for JPA and iBatis, the configurations can be made with <code class="literal">JpaItemWriter</code> and <code class="literal">IbatisBatchItemWriter</code> respectively.</p></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Custom item readers and writers"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Custom item readers and writers</h1></div></div></div><p>Spring <a id="id281" class="indexterm"/>Batch supports custom item readers' and writers' configurations. This can be done easily by implementing the <code class="literal">ItemReader</code> and <code class="literal">ItemWriter</code> interfaces for the respective read and write operations with the business logic we want, and configuring the <code class="literal">ItemReader</code> and <code class="literal">ItemWriter</code> in the XML batch configuration.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Summary</h1></div></div></div><p>Through this chapter we learned the essential data handling mechanisms, including reading the data from different sources (such as flat files, XML, and databases), processing the data, and writing the data to different destinations including flat files, XML, and databases. We also learned about transforming and validating the data in the processing data section. We finished this chapter with an understanding of the Spring Batch support to custom formats by implementing the interface to match the business needs that are different from the default formats. In the next chapter, we will learn about managing the transactions with diverse configurations and patterns in detail.</p></div></div>



  </body></html>