<html><head></head><body>
		<div>
			<div id="_idContainer028" class="Content">
			</div>
		</div>
		<div id="_idContainer029" class="Content">
			<h1 id="_idParaDest-71"><a id="_idTextAnchor076"/>4. Mapping and Filtering</h1>
		</div>
		<div id="_idContainer040" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will begin our exploration of how to use sequential collections in Clojure by taking a look at two of the most useful patterns: mapping and filtering. We will work with the map and filter functions and handle sequential data without using a for loop. We will also use common patterns and idioms for Clojure collections and take advantage of lazy evaluation while avoiding the traps. We will load and process sequential datasets from <strong class="bold">Comma-Separated Values</strong> (<strong class="bold">CSV</strong>) files and extract and shape data from a large dataset.</p>
			<p class="callout">By the end of this chapter, you will be able to parse datasets and perform various types of transformations to extract and summarize data.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor077"/>Introduction</h1>
			<p>Dealing with collections of data is one of the most common and powerful parts of programming. Whether they are called lists, arrays, or vectors, sequential collections are at the heart of almost every program. Every programming language provides tools for creating, accessing, and modifying collections, and, often, what you've learned in one language will apply to the others. Clojure is different, however. We are accustomed to setting a variable and then controlling some other part of the system by changing the value of that variable.</p>
			<p>This is what happens in a <strong class="source-inline">for</strong> loop in most procedural languages. Say that we have an iterator, <strong class="source-inline">i</strong>, that we increment by calling <strong class="source-inline">i++</strong>. Changing the value of the iterator controls the flow of the loop. By executing <strong class="source-inline">i = i + 3</strong>, we can make the loop skip two iterations. The value of <strong class="source-inline">i</strong> is like a remote control for the loop. In case we increment the iterator by three, what happens if we are just one item away from the end of the array we are looping over? The remote control doesn't prevent us from making mistakes with it.</p>
			<p>Clojure has a completely different approach. It may take some practice and some experience to get used to it, depending on what kinds of programming you've done before. With Clojure, it's helpful to think of the functions you write as a way of describing the shape of the data we want to have. Often, you will need to reshape the data in several steps to get it to where you need it to go. Rather than using data, such as the iterator we mentioned previously, to keep track of the internal state of the program, Clojure invites you to write the functions that will be the bridge between the data you have and the data you want. That's at least one way of thinking about it.</p>
			<p>From a 30,000-foot perspective, the fundamental pattern of Clojure programs is as follows:</p>
			<ol>
				<li>Get the data.</li>
				<li>Shape the data.</li>
				<li>Do something with the data.</li>
			</ol>
			<p>The traditional <strong class="source-inline">for</strong> loop tends to roll these three phases into one. A typical example would be a <strong class="source-inline">for</strong> loop that reads a row of data from a database or a file (<em class="italic">get the data</em>), does some computations (<em class="italic">shape the data</em>), and writes data back or sends it somewhere else (<em class="italic">do something</em>), and then starts over again with the next row. A good design in Clojure usually means separating these three steps and moving as much logic as possible into the middle, which is the data-shaping step. </p>
			<p>The techniques that we'll cover in this chapter will help you do that.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Clojure does have a <strong class="source-inline">for</strong> macro, but it is used for list comprehensions, which you can think of as an alternate syntax for many of the patterns in this chapter.</p>
			<p>This approach to coding makes Clojure an excellent language for doing complicated things with complex data as simply as possible. Learning a functional approach to data collections is not just for processing large datasets, however. Clojure programs often tend to be data-centric, regardless of how much data they are actually processing. Much of the important work in a Clojure program is done by shaping your data, big or small. The techniques and patterns you'll learn about in this chapter will help you write any kind of Clojure code.</p>
			<p>The <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> functions are fundamentally quite simple, as you'll soon see. In this chapter, we will focus on how to use them to solve problems. At the same time, learning about <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> and, more generally, how to handle sequential data, means learning lots of new things about the Clojure ecosystem – things such as immutability, lazy sequences, or the basics of functional programming. Toward the end of this chapter, we will start to use the techniques we learned along the way to manipulate a larger dataset, composed of the results of years and years of professional tennis matches. In subsequent chapters, we will continue to build on our experience with this data as we learn more and more about Clojure.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor078"/>map and filter</h1>
			<p>The <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> functions are a key part of a much larger group of functions for dealing with sequences. Of that group, <strong class="source-inline">map</strong> is certainly the one you will use the most, and <strong class="source-inline">filter</strong> is a close second. Their role is to modify sequences. </p>
			<p>They accept one or more sequences as input, and return a sequence: <em class="italic">sequence in</em>, <em class="italic">sequence out</em>:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B14502_04_01.jpg" alt="Figure 4.1: A schematic diagram of map and filter working together&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1: A schematic diagram of map and filter working together</p>
			<p>In the preceding diagram, we can see <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> working together, where <strong class="source-inline">filter</strong> eliminates items from the original list while <strong class="source-inline">map</strong> changes them. </p>
			<p>The first question to ask when solving a problem involving collections is: "Do I want to obtain a list of values, or a single value?" If the answer is a list, then <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, or similar functions are what you need. If you need some other kind of value, the solution is probably a reduction of some kind, which we will discuss in the next chapter. But even then, as you break the problem down, there is a good chance that some component parts of the problem will require sequence-manipulating functions such as <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong>. If, for example, the problem at hand involves searching in a list of items for sale, perhaps <strong class="source-inline">filter</strong> would allow you to narrow the scope of the search to a certain category or price range. Then, you may use <strong class="source-inline">map</strong> to calculate a derived value for each item – maybe the item's volume in cubic centimeters or the number of commentaries it has received on a website. And then, finally, you may extract the single item you are seeking, or the summary data that you need, from this transformed list. </p>
			<p>To get started, let's take a closer look at <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> separately, before looking at how we will use them together.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor079"/>map</h2>
			<p>Like the majority of Clojure's functions for working with sequences, the first argument of map is always a function. The function we provide will be called on each item in the sequence that we will iterate over. Here is a very simple use of <strong class="source-inline">map</strong> that uses Clojure's <strong class="source-inline">inc</strong> function to add 1 to each value in the input sequence:</p>
			<p class="source-code">user&gt; map inc [1 2 3])</p>
			<p class="source-code">(2 3 4)</p>
			<p>The return value of each call to the <strong class="source-inline">inc</strong> function becomes a value in the new sequence that <strong class="source-inline">map</strong> returns.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">map</strong> function can take more sequences as arguments, as we'll see shortly. Like many of the sequence-handling functions, there is a single-argument form of <strong class="source-inline">map</strong>. When <strong class="source-inline">map</strong> is called with just one argument, that is, the function, it returns a special function called a <strong class="bold">transducer</strong>. You don't need to worry about transducers for now. However, if you forget to provide a third argument to <strong class="source-inline">map</strong>, the Clojure compiler won't complain about not having enough arguments. Instead, you'll see a strange error about a function that you don't remember writing. That function is the transducer you've produced by mistake.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor080"/>Exercise 4.01: Working with map</h2>
			<p>Let's get started! In this exercise, we'll use <strong class="source-inline">map</strong> on a list of integers to obtain different kinds of results:</p>
			<ol>
				<li value="1">Try this in your REPL:<p class="source-code">user&gt; (map (fn [i] (* i 10)) [1 2 3 4 5])</p><p>The output is as follows:</p><p class="source-code">(10 20 30 40 50)</p><p>This call to <strong class="source-inline">map</strong> simply applied the anonymous function known as <strong class="source-inline">(fn [i] (* i 10))</strong> to the list of integers, multiplying each one by 10. In doing so, we end up with a new list of integers, one for each of the integers in the original input:</p><div id="_idContainer031" class="IMG---Figure"><img src="image/B14502_04_02.jpg" alt="Figure 4.2: Mapping one sequence to another &#13;&#10;"/></div><p class="figure-caption">Figure 4.2: Mapping one sequence to another </p><p>This one-to-one equivalence is obvious, but it is also a key feature of <strong class="source-inline">map</strong>. With <strong class="source-inline">map</strong>, the sequence of results is always exactly the same length as the input sequence so that each value in the input maps to the corresponding value in the result sequence, hence the name.</p></li>
				<li>Let's measure word length now. When working with sequences, Clojure's <strong class="source-inline">count</strong> function is invaluable. Since Clojure considers a string to be a sequence of characters, <strong class="source-inline">count</strong> can also be used to find the length of a string:<p class="source-code">user&gt; (map count ["Let's" "measure" "word" "length" "now"])</p><p>You should see the length of each word:</p><p class="source-code">(5 7 4 6 3)</p></li>
				<li>To make our output easier to read, we could add the word along with its length:<p class="source-code">user&gt; (map (fn [w] (str w ": " (count w))) ["Let's" "measure" "word" "length" "now"]) </p><p>The output is as follows:</p><p class="source-code">("Let's: 5" "measure: 7" "word: 4" "length: 6" "now: 3")</p></li>
			</ol>
			<p>This example, of course, just scratches the surface of the different applications of <strong class="source-inline">map</strong>. At the same time, it shows how simple the concept of mapping really is: for each value in a list, produce a new value in a new list.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor081"/>filter</h2>
			<p>Unlike <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong> can, and often does, produce a sequence of results containing fewer items than the input sequence. A call to <strong class="source-inline">filter</strong> looks basically like a call to <strong class="source-inline">map</strong>:</p>
			<p class="source-code">user&gt; filter keyword? ["a" :b "c" :d "e" :f "g"])</p>
			<p class="source-code">(:b :d :f)</p>
			<p>Like in <strong class="source-inline">map</strong>, the function that's supplied as the first argument to <strong class="source-inline">filter</strong> is called on each item in the sequence. The difference is that, in this case, the function is being used as a <strong class="bold">predicate</strong>, which means that we only care about whether the value returned is logically <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. When a <strong class="bold">truthy</strong> value is returned, that item will be included in the sequence of results.</p>
			<p>One key difference with <strong class="source-inline">map</strong> is that the predicate that's provided to <strong class="source-inline">filter</strong> only serves to decide whether the given item should be included or not. It does not change the items in any way. The result set of <strong class="source-inline">filter</strong> is always a subset of the input set.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor082"/>Exercise 4.02: Getting Started with filter</h2>
			<p>In this exercise, we'll use <strong class="source-inline">filter</strong> on a list of integers to obtain different kinds of results. Let's get started:</p>
			<ol>
				<li value="1">The <strong class="source-inline">odd?</strong> function is a predicate that returns <strong class="source-inline">true</strong> if a number is <strong class="source-inline">odd</strong>. Try it by itself in the REPL:<p class="source-code">user&gt; (odd? 5)</p><p>The output is as follows:</p><p class="source-code">true</p></li>
				<li>Now, try passing an even number as input:<p class="source-code">user&gt; (odd? 6)</p><p>The output is as follows:</p><p class="source-code">false</p></li>
				<li>Now, use <strong class="source-inline">odd?</strong> with <strong class="source-inline">filter</strong>:<p class="source-code">user&gt; (filter odd? [1 2 3 4 5])</p><p>The output is as follows:</p><p class="source-code">(1 3 5)</p></li>
				<li>We could also use the alter ego of filter, <strong class="source-inline">remove</strong>, which does the exact inverse of <strong class="source-inline">filter</strong>. When the predicate returns <strong class="source-inline">true</strong>, the item is removed:<p class="source-code">user&gt; (remove odd? [1 2 3 4 5])</p><p>The output is as follows:</p><p class="source-code">(2 4)</p><p>Here is how we can visualize what <strong class="source-inline">filter</strong> does:</p><div id="_idContainer032" class="IMG---Figure"><img src="image/B14502_04_03.jpg" alt="Figure 4.3: The filter function uses a predicate to define a new sequence&#13;&#10;"/></div><p class="figure-caption">Figure 4.3: The filter function uses a predicate to define a new sequence</p></li>
				<li>With <strong class="source-inline">filter</strong>, we are limiting the original sequence, but the result is always a sequence. Consider these two extreme cases where each predicate always returns a single value (Clojure's <strong class="source-inline">constantly</strong> function returns a function that does nothing but return a single value, regardless of the number of arguments that are passed to it):<p class="source-code">user&gt; (filter (constantly true) [1 2 3 4 5])</p><p class="source-code">(1 2 3 4 5)</p><p class="source-code">user&gt; (filter (constantly false) [1 2 3 4 5])</p><p class="source-code">()</p><p>Whether we keep everything or nothing, <strong class="source-inline">filter</strong> <em class="italic">always</em> returns a sequence.</p></li>
			</ol>
			<p>Like <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong> is conceptually very simple: using a predicate, keep some or all of the items in a list. Despite this simplicity, or thanks to it, <strong class="source-inline">filter</strong> is an extremely useful function that can be used in countless circumstances.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor083"/>Other Members of the filter Family – take-while and drop-while</h2>
			<p>The <strong class="source-inline">take-while</strong> and <strong class="source-inline">drop-while</strong> functions follow the same logic as <strong class="source-inline">filter</strong> and <strong class="source-inline">remove</strong> – at least as far as their use of a predicate goes. The difference is that they only operate at the beginning of a sequence, much like <strong class="source-inline">take</strong> and <strong class="source-inline">drop</strong>. The <strong class="source-inline">take</strong> function returns the first <strong class="source-inline">n</strong> items of a list, while <strong class="source-inline">drop</strong> returns the original list minus the first <strong class="source-inline">n</strong> items:</p>
			<p class="source-code">user&gt; (take 3 [1 2 3 4 5])</p>
			<p class="source-code">(1 2 3)</p>
			<p class="source-code">user&gt; (drop 3 [1 2 3 4 5])</p>
			<p class="source-code">(4 5)</p>
			<p>Similarly, <strong class="source-inline">take-while</strong> starts at the beginning of the list and returns all the items as long as they satisfy the predicate, while <strong class="source-inline">drop-while</strong> removes those same items from the beginning of the sequence:</p>
			<p class="source-code">User&gt; (take-while #(&gt; 10 %) [2 9 4 12 3 99 1])</p>
			<p class="source-code">(2 9 4)</p>
			<p class="source-code">user&gt; (drop-while #(&gt; 10 %) [2 9 4 12 3 99 1])</p>
			<p class="source-code">(12 3 99 1)</p>
			<p>Perhaps the most obvious application of <strong class="source-inline">take-while</strong> and <strong class="source-inline">drop-while</strong> is to subdivide sorted data. We can even use them together to find the exact point in a sequence where a predicate stops returning <strong class="source-inline">true</strong> and starts returning <strong class="source-inline">false</strong>.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor084"/>Exercise 4.03: Partitioning a Sequence with take-while and drop-while</h2>
			<p>We have a sorted list of students that we'd like to separate into two groups: those born before the year 2000 and those born after. Let's get started:</p>
			<ol>
				<li value="1">In your REPL, define a <strong class="source-inline">students</strong> variable. You can copy the list from this course's GitHub repository at <a href="https://packt.live/2sQyVYz">https://packt.live/2sQyVYz</a>:<p class="source-code">(def students [{:name "Eliza" :year 1994}</p><p class="source-code">               {:name "Salma" :year 1995}</p><p class="source-code">               {:name "Jodie" :year 1997}</p><p class="source-code">               {:name "Kaitlyn" :year 2000}</p><p class="source-code">               {:name "Alice" :year 2001}</p><p class="source-code">               {:name "Pippa" :year 2002}</p><p class="source-code">               {:name "Fleur" :year 2002}])</p></li>
				<li>Write a predicate that translates the idea <strong class="source-inline">before 2000</strong>:<p class="source-code">#(&lt; (:year %) 2000)</p><p>This anonymous function extracts the <strong class="source-inline">:year</strong> value from the student map and compares it to <strong class="source-inline">2000</strong>.</p></li>
				<li>Use the predicate with <strong class="source-inline">take-while</strong> to find the students born before 2000:<p class="source-code">user&gt; (take-while #(&lt; (:year %) 2000) students)</p><p class="source-code">({:name "Eliza", :year 1994}</p><p class="source-code"> {:name "Salma", :year 1995}</p><p class="source-code"> {:name "Jodie", :year 1997})</p></li>
				<li>Use the same predicate with <strong class="source-inline">drop-while</strong> to find the students born in 2000 or after:<p class="source-code">user&gt; (drop-while #(&lt; (:year %) 2000) students)</p><p class="source-code">({:name "Kaitlyn", :year 2000}</p><p class="source-code"> {:name "Alice", :year 2001}</p><p class="source-code"> {:name "Pippa", :year 2002}</p><p class="source-code"> {:name "Fleur", :year 2002})</p></li>
			</ol>
			<p>You won't use the <strong class="source-inline">take-while</strong> and <strong class="source-inline">drop-while</strong> functions as much as <strong class="source-inline">filter</strong> itself, but they can be very useful in certain circumstances. Like <strong class="source-inline">filter</strong>, they are useful tools for shaping sequences.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor085"/>Using map and filter Together</h2>
			<p>Much of the power of Clojure's sequence functions comes from combining them. Let's combine the previous examples. How would we obtain a sequence such as 10, 30, 50 from 1, 2, 3, 4, 5? It's just a question of applying our functions in the right order. If we multiply by 10 first, all the resulting integers will be even. To meaningfully filter out the odd numbers, we have to do this first. Consider the following example: </p>
			<p class="source-code">user&gt; (map (fn [n] (* 10 n))</p>
			<p class="source-code">           (filter odd? [1 2 3 4 5]))</p>
			<p>The output is as follows:</p>
			<p class="source-code">(10 30 50)</p>
			<p>This is a little bit hard to read, especially if you aren't used to reading Lisp code with its nested parentheses. Even though <strong class="source-inline">map</strong> comes first in the source code, the evaluation starts with the call to <strong class="source-inline">filter</strong>. The result is then passed into <strong class="source-inline">map</strong> (we'll show you a better way to write this later in this chapter). First, though, let's look at what is happening.</p>
			<p>Conceptually, the computation looks something like this:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B14502_04_04.jpg" alt="Figure 4.4: Combining the two – filter, then map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4: Combining the two – filter, then map</p>
			<p>It may be helpful to think of this as data flowing through a pipeline. The functional arguments to <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> are what shape your data as it flows along.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor086"/>Threading Macros</h2>
			<p>It's possible to write the same expression in a way that reflects the logic of what we are doing to the data. If we write this in a very non-idiomatic style, using <strong class="source-inline">def</strong>, it's a little clearer:</p>
			<p class="source-code">user&gt; (def filtered (filter odd? [1 2 3 4 5]))</p>
			<p class="source-code">filtered</p>
			<p class="source-code">user&gt; (map (fn [n] (* 10 n)) filtered)</p>
			<p class="source-code">(10 30 50)</p>
			<p>Alternatively, and much more idiomatically, we can use Clojure's <strong class="bold">threading macros</strong> to make it easier to read:</p>
			<p class="source-code">user&gt; (-&gt;&gt; [1 2 3 4 5]</p>
			<p class="source-code">        (filter odd?)</p>
			<p class="source-code">        (map (fn [n] (* 10 n))))</p>
			<p class="source-code">(10 30 50)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A macro is a construct that transforms code before it is executed. In <em class="italic">Chapter 11</em>, <em class="italic">Macros</em>, we will explore macros in much more depth. For now, you can think of Clojure's threading macros as "syntactic sugar" that allows us to write more readable code by avoiding deep nesting.</p>
			<p>This is how we will write our code throughout this chapter. Threading allows us to preserve the logical order of execution without having to name the return values. The <strong class="source-inline">-&gt;&gt;</strong> macro rewrites your code so that the result of each form is inserted at the end of the next form. This way, we can write the following:</p>
			<p class="source-code">user&gt; (-&gt;&gt; [1 2 3 4 5]</p>
			<p class="source-code">        (filter odd?))</p>
			<p>And the compiler really "sees" this:</p>
			<p class="source-code">user&gt; (filter odd? [1 2 3 4 5])</p>
			<p>This is an extremely common pattern that helps immensely in writing easy-to-read code, especially when applying many different operations to sequences. In Clojure, when a function takes a sequence as an argument, that argument is generally the last argument. This is quite convenient, or rather, a great design decision, because it allows us to chain together transformations in an intuitive way using the <strong class="source-inline">-&gt;&gt;</strong> macro, which happens to fill in the last argument in an expression. A complex transformation can be broken down into smaller, composable steps, which are easier to write, test, and understand.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor087"/>Using Lazy Sequences</h1>
			<p>Before we move on, it's important to take a closer look at how lazy sequences work in Clojure. When using <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong>, lazy evaluation is often an important consideration. In the examples we've looked at so far, we have used a literal vector as input: <strong class="source-inline">[1 2 3 4 5]</strong>. Instead of typing out each number, we could use the <strong class="source-inline">range</strong> function and write <strong class="source-inline">(range 1 6)</strong>. If we type this in the REPL, we get basically the same thing:</p>
			<p class="source-code">user&gt; (range 1 6)</p>
			<p class="source-code">(1 2 3 4 5)</p>
			<p>So, is this just a shortcut to avoid typing out lots of integers? Well, it is, but <strong class="source-inline">range</strong> has another interesting characteristic: it's lazy.</p>
			<p>Before we go further, let's revisit <strong class="bold">laziness</strong> briefly. If <strong class="source-inline">(range 100)</strong> is a <strong class="bold">lazy sequence</strong>, that means that it is not realized until each element in the sequence has been calculated. Say we define a lazy sequence from 0 to <strong class="source-inline">100</strong>:</p>
			<p class="source-code">user&gt; (def our-seq (range 100))</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The REPL causes lazy sequences to be evaluated. This can be confusing sometimes if the problem you are debugging is caused by a lazy sequence not being fully evaluated: "This code works just fine in the REPL; why doesn't it work correctly in my code?" When debugging in the REPL, if you want to avoid forcing the evaluation of a lazy sequence, assign it to a variable instead. </p>
			<p>The <strong class="source-inline">range</strong> function creates a list of integers by calling <strong class="source-inline">inc</strong> as many times as necessary. It's easy enough to guess that the last integer in <strong class="source-inline">our-seq</strong> will be <strong class="source-inline">99</strong>, but the computer doesn't know that until it has performed all the arithmetic. This means that when we look at the first item, only one item is known:</p>
			<p class="source-code">user&gt; (first our-seq)</p>
			<p class="source-code">0</p>
			<p>But if we look at the last item, all the intermediate calculations will be performed:</p>
			<p class="source-code">user&gt; (last our-seq)</p>
			<p class="source-code">99</p>
			<p>Now, the entire sequence has been realized, and for all practical purposes, it's no longer any different from a literal sequence of integers.</p>
			<p>Functions such as <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">remove</strong> are also lazy. This means that when we call them on a lazy sequence, they do not force the calculation of the entire sequence. Essentially, lazy functions just add new calculations to a virtual backlog of deferred calculations that will realize the sequence when needed. Functions such as <strong class="source-inline">count</strong>, <strong class="source-inline">sort</strong>, or <strong class="source-inline">last</strong>, on the other hand, are not lazy. Obviously, in order to count all the items in the list, we need the entire list first.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor088"/>Exercise 4.04: Watching Lazy Evaluation</h2>
			<p>We can observe laziness in action by doing something that we never want to do in production code: introduce a side effect. Let's get started:</p>
			<ol>
				<li value="1">Define a simple version of <strong class="source-inline">range</strong> in the REPL:<p class="source-code">user&gt; (defn our-range [limit]</p><p class="source-code">        (take-while #(&lt; % limit) (iterate inc 0)))</p><p>Here, the <strong class="source-inline">iterate</strong> function creates a lazy sequence by calling <strong class="source-inline">inc</strong> on <strong class="source-inline">0</strong>, then calling <strong class="source-inline">inc</strong> on the result of that, then on the result of that, and so on. <strong class="source-inline">take-while</strong> will stop consuming the sequence when the anonymous function, that is, <strong class="source-inline">#(&lt; % limit)</strong>, stops returning <strong class="source-inline">true</strong>. This will then stop <strong class="source-inline">iterate</strong>.</p></li>
				<li>Test the function at the REPL:<p class="source-code">user&gt; (our-range 5)</p><p class="source-code">(0 1 2 3 4)</p></li>
				<li>Use <strong class="source-inline">map</strong> to multiply each integer by 10:<p class="source-code">user&gt; (map #(* 10 %) (our-range 5))</p><p class="source-code">(0 10 20 30 40)</p></li>
				<li>Now, we'll use a function with side effects to print <strong class="source-inline">.</strong> each time an integer is multiplied:<p class="source-code">user&gt; (map (fn [i] (print ".") (* i 10)) (our-range 5)) </p><p class="source-code">.(0. 10. 20. 30. 40)</p><p>As predicted, there is a <strong class="source-inline">.</strong> operator for each integer. The exact position of the dots may be different when you try this: they may appear before or after the list of integers. They are not part of the result sequence; they are being printed simultaneously, just before each multiplication is executed. There is one dot for each integer because the entire sequence has been realized.</p></li>
				<li>This time, use <strong class="source-inline">def</strong> to store the lazy sequence, instead of viewing it in the REPL:<p class="source-code">user&gt; (def by-ten (map (fn [i] (print ".") (* i 10)) (our-range 5)))</p><p class="source-code">#'user/by-ten</p><p>The REPL returns the <strong class="source-inline">by-ten</strong> variable, but does not print any dots, so we know that none of the multiplications have been performed yet.</p></li>
				<li>Evaluate the variable in the REPL:<p class="source-code">user&gt; by-ten</p><p class="source-code">.(0. 10. 20. 30. 40)   ;; this looks familiar!</p><p>What happened here? This is the same output as in <em class="italic">step 4</em>. The computations weren't performed until we finally decided to consume the lazy sequences in the REPL. This is the essence of laziness in Clojure: deferring evaluation until it is necessary.</p></li>
			</ol>
			<p>Lazy evaluation has some important benefits, both in terms of simplifying our programs and in terms of performance. Deferring computation on a sequence means that we can sometimes avoid the computation altogether, at least on part of the sequence. For now, the important thing to understand is how lazy evaluation can change the way we write and organize our code. Consider this expression:</p>
			<p class="source-code">(range)</p>
			<p>With no arguments, <strong class="source-inline">range</strong> returns all the integers from zero to the biggest number your system can handle. If you type this expression into your REPL, it will fill up the screen with numbers. Because there is a built-in limit regarding the number of items the REPL will display, it won't increment all the way to infinity, or until your JVM blows up – whichever comes first. Now, imagine that we write something like this:</p>
			<p class="source-code">(-&gt;&gt; (range)</p>
			<p class="source-code">     (map #(* 10 %))</p>
			<p class="source-code">     (take 5))</p>
			<p>This expression tells the computer to multiply every integer from 1 to infinity by 10, and then, when that calculation is complete, keep the first five values. Without lazy evaluation, this would be crazy. It would fail on the first line. Then, why perform a calculation on a huge set of numbers when we're only interested in the first five values? Yet, in Clojure, this is a perfectly reasonable way to write code. The calls to <strong class="source-inline">range</strong> and <strong class="source-inline">map</strong> are a description of the data that we want: positive integers multiplied by 10. The call to take allows us to select, within that infinite set, the items that we actually need. Lazy evaluation means that only five calculations will be performed, so the preceding code is not only elegant, but perfectly efficient.</p>
			<p>There are dangers too, of course. In this example, if we replace <strong class="source-inline">(take 5)</strong> with <strong class="source-inline">last</strong>, it would mean trying to evaluate the entire sequence, with disastrous consequences as your machine tries, and fails, to calculate all the integers to infinity. Lazy evaluation is extremely useful, but it is important to understand how it works.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor089"/>Exercise 4.05: Creating Our Own Lazy Sequence</h2>
			<p>From time to time, we need to create sequences of random numbers. This may be for a simulation or for writing tests. In a procedural language such as JavaScript, we may write something like this:</p>
			<p class="source-code">var ints = [];</p>
			<p class="source-code">for (var i = 0; i &lt; 20; i++) {</p>
			<p class="source-code">  ints.push(Math.round(Math.random() * 100));</p>
			<p class="source-code">}</p>
			<p>We could then wrap this in a function and parameterize the length of the array we wanted.</p>
			<p>How can we do this in Clojure without a <strong class="source-inline">for</strong> loop? Clojure has a <strong class="source-inline">rand-int</strong> function that returns a single random integer. We can use the <strong class="source-inline">repeatedly</strong> function, which returns a lazy sequence of calls to whatever function we pass it. Let's get started:</p>
			<ol>
				<li value="1">Create a lazy sequence with <strong class="source-inline">repeatedly</strong> and an anonymous function that calls <strong class="source-inline">rand-int</strong> with a fixed argument:<p class="source-code">user&gt; (def our-randoms (repeatedly (partial rand-int 100)))</p><p>The <strong class="source-inline">parse-int</strong> function just takes one argument that defines the upper bound of the value to be returned. It is common to use <strong class="source-inline">partial</strong> in cases like this, but we could have just as well written a literal anonymous function: <strong class="source-inline">#(rand-int 100)</strong>.</p></li>
				<li>Use <strong class="source-inline">take</strong> to limit how many integers are returned:<p class="source-code">user&gt; (take 20 our-randoms) </p></li>
				<li>Wrap this into a function:<p class="source-code">user&gt; (defn some-random-integers [size]</p><p class="source-code">    (take size (repeatedly (fn [] (rand-int 100)))))</p></li>
				<li>Use it as follows:<p class="source-code">user&gt; (some-random-integers 12)</p><p>The output is as follows:</p><p class="source-code">(32 0 26 61 10 96 38 38 93 26 68 81)</p></li>
			</ol>
			<p>When moving from a procedural approach to Clojure's functional approach, this pattern can be useful. First, describe the data you want, and then delimit it or transform it as needed.</p>
			<p>Lazy sequences may seem unnecessarily confusing at first: why bother with a data structure that introduces uncertainty about whether something has been calculated or not? There are indeed some edge cases where this can be an issue, and we'll see one of those later in this chapter. Most of the time, however, these problems can be avoided by writing code that does not produce or depend on side effects. And then you will start to reap the benefits of lazy sequences, which allow sequences to be defined in a declarative way that will ultimately simplify your code.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor090"/>Common Idioms and Patterns</h2>
			<p>Functions such as <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> are two of the most powerful tools in Clojure for extracting, selecting, and transforming data. The key to using them effectively is, of course, knowing what kind of function to use with them. Clojure tries to make writing functions easy, and there are many shortcuts for some of the most common situations. These techniques will help you to start writing code more quickly, and they will also give you some valuable practice in functional programming.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor091"/>Anonymous Functions </h2>
			<p>So far, we've been writing functional arguments as anonymous functions using the canonical <strong class="source-inline">fn</strong> form, or by using a named function such as <strong class="source-inline">odd?</strong>. Because sequence-handling functions in Clojure often make use of functions that are passed in as arguments, writing (and reading) anonymous functions is an extremely common task. This is why it's good to know the different shortcuts for writing them.</p>
			<p>One of the most common ways to pass a function to <strong class="source-inline">map</strong> or <strong class="source-inline">filter</strong> is by using what's known as a <strong class="bold">function literal</strong>. A function literal is a simplified version of the <strong class="source-inline">fn</strong> form. The <strong class="source-inline">fn</strong> symbol and the argument list disappear, leaving only the heart of the function and a <strong class="source-inline">#</strong> operator just before the opening parenthesis.  </p>
			<p>In <em class="italic">Exercise 4.01</em>, <em class="italic">Working with map</em>, instead of <strong class="source-inline">(fn [n] (* 10 n))</strong>, we could have written <strong class="source-inline">#(* 10 %)</strong>. The leading <strong class="source-inline">#</strong> operator identifies the form that follows as a function. We still don't have an argument list, though, which would be a disastrous omission in a functional language! However, we are saved by a pattern: instead of naming the arguments freely, as in most functions, with function literals, the arguments are automatically named by following a simple pattern. The first argument is named <strong class="source-inline">%</strong> and all the other arguments are named <strong class="source-inline">%2</strong>, <strong class="source-inline">%3</strong>, <strong class="source-inline">%4</strong>, and so forth. </p>
			<p>There are some limits to the expressiveness of function literals. The pattern for argument names does not allow anything such as destructuring or any of the other interesting features of Clojure's argument lists. And, of course, not being able to name the arguments does make for inexpressive code. If you have more than two arguments, it may be time to switch back to <strong class="source-inline">fn</strong>. It may seem obvious what you meant by <strong class="source-inline">%4</strong> in the complex function literal you wrote this morning, but in a week, you will probably have forgotten. Function literals should be brief and simple.</p>
			<p>The final limitation of functional literals is that they cannot be nested. In other words, if you have a function literal that calls <strong class="source-inline">map</strong>, then the function you provide to <strong class="source-inline">map</strong> cannot also be a function literal. The reason why nesting is impossible is quite simple. How would the compiler know which <strong class="source-inline">%</strong> goes with which function?</p>
			<p>As soon as a function literal starts to become even a little bit complex, it's certainly time to switch to the <strong class="source-inline">fn</strong> form. Function literals should be used as simple wrappers for setting up calls to existing functions, rather than as a place to write complex code.</p>
			<p>As you become more familiar with some of the more advanced functional techniques in Clojure, you will start to use some of the other options that are now at your disposal. For multiplying by 10, we could have also written the following:</p>
			<p class="source-code">(map (partial * 10) [1 2 3 4 5])</p>
			<p>Notice that there is no <strong class="source-inline">#</strong> in front of this form. Here, the <strong class="source-inline">partial</strong> function returns a new anonymous function, that is, <strong class="source-inline">*</strong>, with its first argument "preloaded." This is easier to understand in the REPL:</p>
			<p class="source-code">user&gt; (def apart (partial * 10))</p>
			<p class="source-code">#'user/apart</p>
			<p class="source-code">user&gt; (apart 5)</p>
			<p class="source-code">50</p>
			<p>Here, we've defined <strong class="source-inline">apart</strong>, which is a partially evaluated call to <strong class="source-inline">*</strong>. By calling that function, it behaves just like <strong class="source-inline">*</strong>, except that the first argument to <strong class="source-inline">*</strong> is already filled in. Writing <strong class="source-inline">(partial * 10)</strong> is essentially the same thing as writing <strong class="source-inline">(fn [x] (* 10 x))</strong>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Any function that's created with <strong class="source-inline">partial</strong> can always be rewritten as a function. The power of functions such as <strong class="source-inline">partial</strong> is their ability to create new functions programmatically. This is where a lot of the power of <strong class="bold">functional programming</strong> resides.</p>
			<p>This is, in fact, the exact same function we've been writing. For now, you don't need to worry about <strong class="source-inline">partial</strong>. The other ways of writing functions like this are equivalent and sufficient.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor092"/>Keywords as Functions</h2>
			<p>By now, you're already familiar with using a <strong class="bold">keyword</strong> to get a value in a map, as follows:</p>
			<p class="source-code">user&gt; (:my-field {:my-field 42})</p>
			<p class="source-code">42</p>
			<p>This works because Clojure keywords can be used as functions whose arguments are a map. It is also very useful when extracting a single field from a list of maps, as we'll see in the next exercise.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor093"/>Exercise 4.06: Extracting Data from a List of Maps</h2>
			<p>Extracting information from a more complex structure is a common task. We are often presented with a sequence of Clojure maps, where each map has multiple keyword keys. We need a sequence of the values of just one key, one for each map. Let's say we have a vector containing the players in a game. Each player may be represented by a map like this:</p>
			<p class="source-code">{:id 9342</p>
			<p class="source-code"> :username "speedy"</p>
			<p class="source-code"> :current-points 45</p>
			<p class="source-code"> :remaining-lives 2</p>
			<p class="source-code"> :experience-level 5</p>
			<p class="source-code"> :status :active }</p>
			<p>Imagine that the game requires us to get the current points of all the players, maybe to calculate an average or to find the maximum and minimum values.</p>
			<p>Copy the <strong class="source-inline">game-users</strong> vector into your REPL from <a href="https://packt.live/36tHiI3">https://packt.live/36tHiI3</a>. It contains a list of maps, with each map containing some information about a user:</p>
			<p class="source-code">{:id 9342</p>
			<p class="source-code"> :username "speedy"</p>
			<p class="source-code"> :current-points 45</p>
			<p class="source-code"> :remaining-lives 2s</p>
			<p class="source-code"> :experience-level 5</p>
			<p class="source-code"> :status :active}</p>
			<p>Let's get started:</p>
			<ol>
				<li value="1">Use <strong class="source-inline">map</strong> to return a vector of <strong class="source-inline">:current-points</strong> for each user. To do this, we could write something like this:<p class="source-code">user&gt; (map (fn [player] (:current-points player)) game-users)</p><p class="source-code">(45 67 33 59 12 0…)</p></li>
				<li>Rewrite this expression using a keyword:<p class="source-code">user&gt; (map :current-points game-usersplayers)</p><p class="source-code">(45 67 33 59 12 0…)</p></li>
			</ol>
			<p>The ability to extract lists of data with so little code is one of the benefits of the fact that Clojure keywords can also be functions. Shortcuts like this are not just convenient or faster to type: they help us write expressive code that says exactly what we want.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor094"/>Sets as Predicates </h2>
			<p>Another common task is to filter based on whether an item is a member of a set. Clojure sets are another form of collection that mimic the logic of mathematical sets. As a tool in programming, they have two important characteristics:</p>
			<ul>
				<li>An item is either part of a set or not part of a set. This means that there are never any duplicates in a set. Adding an item to a set more than once has no effect.</li>
				<li>The main job of a set is to tell you whether something belongs or not. This is why sets can be used as functions, and why they can be useful when combined with <strong class="source-inline">filter</strong>. <p>Here, we're defining a set with the <strong class="source-inline">set</strong> function, which takes a list as an argument. It can then be used as a function that returns <strong class="source-inline">true</strong> if called on a value that is already part of the set, or <strong class="source-inline">false</strong> otherwise. In this example, <strong class="source-inline">(alpha-set :z)</strong> returns <strong class="source-inline">false</strong> because <strong class="source-inline">alpha-set</strong> does not contain <strong class="source-inline">:z</strong>:</p><p class="source-code">user&gt; (def alpha-set (set [:a :b :c]))</p><p class="source-code">#'user/alpha-set</p><p class="source-code">user&gt; (alpha-set :z)</p><p class="source-code">nil</p><p class="source-code">user&gt; (alpha-set :a)</p><p class="source-code">:a</p></li>
			</ul>
			<p>The <strong class="source-inline">hash-set</strong> also produces a set. Instead of a sequence, <strong class="source-inline">hash-set</strong> takes zero or more individual items as its arguments:</p>
			<p class="source-code">(hash-set :a :b :c)</p>
			<p>The choice of one over the other will depend on what form of data you have. The resulting sets are identical.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">clojure.set</strong> library is built into Clojure. This extremely useful library contains functions for performing set arithmetic, such as intersections.</p>
			<p>Imagine we have a list of strings that are animal names:</p>
			<p class="source-code">user&gt; (def animal-names ["turtle" "horse" "cat" "frog" "hawk" "worm"])</p>
			<p>Say we want to remove all the mammals from the list. One solution would be to simply test for different values:</p>
			<p class="source-code">(remove (fn [animal-name]</p>
			<p class="source-code">             (or (= animal-name "horse")</p>
			<p class="source-code">                 (= animal-name "cat")))</p>
			<p class="source-code">         animal-names)             </p>
			<p>This works, but there is a lot of repetitive text. Let's try using a set:</p>
			<p class="source-code">user&gt; (remove #{"horse" "cat"} animal-names)</p>
			<p>The output is as follows:</p>
			<p class="source-code">("turtle" "frog" "hawk" "worm")</p>
			<p>This is brief, clear, and reads almost like an English sentence: remove <strong class="source-inline">horse</strong>, <strong class="source-inline">cat</strong> [from] <strong class="source-inline">animal-names</strong>. There is another advantage, too. Our list of mammals to exclude is fairly limited. What happens if we need to update it? We have to alter the source code to add more tests. The set, on the other hand, is data, so it could be defined once and for all in a variable at the top of our namespace or be calculated at runtime from other data available to our program. </p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor095"/>Filtering on a Keyword with comp and a Set</h2>
			<p>To compose functions means to create a new function out of one to more existing functions. This is what <strong class="source-inline">comp</strong> does. Like <strong class="source-inline">partial</strong>, it is a higher-order function that returns a new function. Functional <strong class="bold">composition</strong> with <strong class="source-inline">comp</strong> means that in the returned function, each function provided to <strong class="source-inline">comp</strong> will be called on the results of the previous function.</p>
			<p>Let's say we want to normalize an input string by doing two things: trimming whitespace from both ends of the string and converting the string into lowercase. The <strong class="source-inline">clojure.string</strong> library provides functions for both of those tasks: <strong class="source-inline">trim</strong> and <strong class="source-inline">lower-case</strong>. We could, of course, write a function that does what we need:</p>
			<p class="source-code">(require '[clojure.string :as string])</p>
			<p class="source-code">(defn normalize [s] (string/trim (string/lower-case s)))</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">clojure.string</strong> library is a standard library that provides many familiar string manipulation functions such as <strong class="source-inline">split</strong> and <strong class="source-inline">join</strong>. String behavior depends on how strings are implemented in the underlying platform, so <strong class="source-inline">clojure.string</strong> provides a unified interface that is the same for Clojure and ClojureScript.</p>
			<p>With <strong class="source-inline">comp</strong>, we can do exactly the same thing with fewer parentheses:</p>
			<p class="source-code">user&gt; (def normalizer (comp string/trim string/lower-case))</p>
			<p class="source-code">user&gt; (normalizer "  Some Information ")</p>
			<p class="source-code">"some information"</p>
			<p>The functional arguments to <strong class="source-inline">comp</strong> are called from right to left. That might sound confusing. It means that the functions are called in the same order as if they were written out as normal function calls:</p>
			<p class="source-code">(comp function-c function-b function-a)</p>
			<p>The preceding code is equivalent to the following:</p>
			<p class="source-code">(fn [x] (function c (function-b (function-a x))))</p>
			<p>In both of these functions, <strong class="source-inline">function-a</strong> would be called first, then <strong class="source-inline">function-b</strong> on that result, and, finally, <strong class="source-inline">function-c</strong> on the result of that.</p>
			<p>Composing functions on the fly can be useful whenever you need to define a function on the fly. With filter, we could use <strong class="source-inline">comp</strong> to quickly build a predicate. Let's say we need to remove any strings from a list that are present in a normalized form set:</p>
			<p class="source-code">user&gt; (def remove-words #{"and" "an" "a" "the" "of" "is"}) </p>
			<p class="source-code">#'user/remove-words</p>
			<p class="source-code">user&gt; (remove (comp remove-words string/lower-case string/trim) ["February" " THE " "4th"])</p>
			<p class="source-code">("February" "4th")</p>
			<p>Using <strong class="source-inline">comp</strong>, we are able to build a function that combines three separate steps.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor096"/>Exercise 4.07: Using comp and a Set to Filter on a Keyword</h2>
			<p>Let's go back to <strong class="source-inline">game-users</strong> from the previous exercise. This time, we need to narrow the scope of the users whose scores we want to calculate. In our imaginary game, users can have one of several statuses: <strong class="source-inline">:active</strong>, <strong class="source-inline">:imprisoned</strong>, <strong class="source-inline">:speed-boost</strong>, <strong class="source-inline">:pending</strong>, or <strong class="source-inline">:terminated</strong>. We only want scores for players who have the <strong class="source-inline">:pending</strong> or <strong class="source-inline">:terminated</strong> statuses. To do this, we will combine the techniques we've used so far.</p>
			<p>The mapping part will stay the same:</p>
			<p class="source-code">(map :current-score game-users)</p>
			<p>Let's get started:</p>
			<ol>
				<li value="1">As in the previous exercise, copy the <strong class="source-inline">game-users</strong> vector into your REPL from <a href="https://packt.live/36tHiI3">https://packt.live/36tHiI3</a>.</li>
				<li>Define a set with the statuses we want to keep:<p class="source-code">(def keep-statuses #{:active :imprisoned :speed-boost})</p></li>
				<li>Write a function to extract the <strong class="source-inline">:status</strong> field from each map and call the predicate on it.<p>There are several ways we could do this. Maybe the first thing that occurs to us would be to write something like this:</p><p class="source-code">(filter (fn [player] (keep-statuses (:status player))) game-users)</p><p>The difficulty here, compared to our previous examples, is that we need to do two things at the same time: get the field, and then test it. In this case, we could also use the <strong class="source-inline">comp</strong> function, which takes two functions and returns a new function, which is the result of calling the first function on the result of the second function. So, instead of writing <strong class="source-inline">(fn [player] (statuses (:status player)))</strong>, we would write the following:</p><p class="source-code">(comp keep-statuses :status)</p></li>
				<li>Use the <strong class="source-inline">-&gt;&gt;</strong> threading macro to put the different pieces back together:<p class="source-code">user&gt; (-&gt;&gt; game-users</p><p class="source-code">       (filter (comp #{:active :imprisoned :speed-boost} :status))</p><p class="source-code">       (map :current-points))</p><p>The result is uncluttered and easy to read. With a little imagination, it almost reads like an English sentence: start with <strong class="source-inline">game-users</strong>, and filter out the users whose <strong class="source-inline">:status</strong> is not one of <strong class="source-inline">:active</strong>, <strong class="source-inline">:imprisoned</strong>, or <strong class="source-inline">:speed-boost</strong>, and then return the <strong class="source-inline">:current-points</strong> of each of those.</p></li>
			</ol>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor097"/>Returning a List Longer than the Input with mapcat</h2>
			<p>As we've already said, <strong class="source-inline">map</strong> always returns the same number of items as the original input sequence. Sometimes, you may need to make a new list with more items if, for example, multiple items can be derived from a single input item. This is what <strong class="source-inline">mapcat</strong> is for.</p>
			<p>Here's a simple example. Suppose we have a list of letters of the alphabet, all in lowercase:</p>
			<p class="source-code">user&gt; (def alpha-lc [ "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"])</p>
			<p class="source-code">#'user/alpha-lc</p>
			<p>We'll stop at <strong class="source-inline">"j"</strong> to save space, but you get the idea. The output we want to obtain is a new list where each lowercase letter is followed by its uppercase counterpart. <strong class="source-inline">mapcat</strong> lets us do that:</p>
			<p class="source-code">user&gt; (mapcat (fn [letter] [letter (clojure.string/upper-case letter)]) alpha-lc)</p>
			<p class="source-code">("a" "A" "b" "B" "c" "C" "d" "D" "e" "E" "f" "F" "g" "G" "h" "H" "i" "I" "j" "J")</p>
			<p>Here, the function we provided returns a two-item vector, such as <strong class="source-inline">["a" "A"]</strong>. <strong class="source-inline">mapcat</strong> simply unwraps each of these vectors so that, in the end, you have a single, flat list.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Clojure has many interesting, more specialized sequence manipulation functions that you may like to explore. We could have solved this problem with <strong class="source-inline">interleave</strong> as well.</p>
			<p>In situations where you have a one-to-many relationship between each item of the input list and the items in the output list, you probably want to consider <strong class="source-inline">mapcat</strong> first. Later in this book, we will use <strong class="source-inline">mapcat</strong> in situations where we need to flatten a list that contains a mix of individual items and sublists.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/>Mapping with Multiple Inputs</h2>
			<p>Among Clojure's sequence functions, <strong class="source-inline">map</strong> is unique in that it can accept more than one sequence as input. This can be useful when you need to stitch sequences together in some way or derive a combined value of some kind.</p>
			<p>When <strong class="source-inline">map</strong> has more than one sequence as input, the mapping function must accept as many arguments as there are sequences. The basic pattern looks like this:</p>
			<p class="source-code">user&gt; (map (fn [a b] (+ a b)) [5 8 3 1 2] [5 2 7 9 8])</p>
			<p class="source-code">(10 10 10 10 10)</p>
			<p>Clojure already has a <strong class="source-inline">zipmap</strong> function that takes two sequences and combines them together in a map:</p>
			<p class="source-code">user&gt; (defn our-zipmap [xs ys]</p>
			<p class="source-code">          (-&gt;&gt; (map (fn [x y] [x y]) xs ys)</p>
			<p class="source-code">               (into {})))</p>
			<p class="source-code">user&gt; (our-zipmap [:a :b :c] [1 2 3])</p>
			<p class="source-code">{:a 1, :b 2, :c 3}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">into</strong> function is extremely useful when moving data from one collection type to another. It can also convert a map into a vector of key-value tuples, any sequence into a set, or the other way around.</p>
			<p>The mapping function here, <strong class="source-inline">(fn [x y] [x y])</strong>, simply wraps the value pairs in a vector, which functions as a <strong class="bold">tuple</strong>, that is, a fixed-length sequential data structure. The <strong class="source-inline">into</strong> function then converts the sequence of two-item tuples into a Clojure map.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A tuple is not a special Clojure data structure. Generally implemented as a short vector, a tuple is an alternative to a map with named fields. Instead of writing <strong class="source-inline">{:x 5 :y 9}</strong>, it is sometimes simpler to write <strong class="source-inline">[5 9]</strong>. A list is a tuple when the position of the items in the list determines what they mean. In theory, tuples can be of any length; in practice, if they are longer than three or four items, it becomes difficult to remember what each position in the list means.</p>
			<p>Another reason to use multiple inputs would be if we needed to know the offset of the item currently being processed. Let's say we have a list of strings for our daily menu:</p>
			<p class="source-code">user&gt; (def meals ["breakfast" "lunch" "dinner" "midnight snack"])</p>
			<p>We may want to add a number in front of each item when presenting the list to the users. We could use <strong class="source-inline">range</strong> to supply an endless supply of integers to match each meal:</p>
			<p class="source-code">user&gt; (map (fn [idx meal] (str (inc idx) ". " meal)) (range) meals)</p>
			<p class="source-code">("1. breakfast" "2. lunch" "3. dinner" "4. midnight snack")</p>
			<p>The lazy sequence produced by <strong class="source-inline">range</strong> starts at zero, which is great inside a computer, but humans prefer lists to start with <strong class="source-inline">1</strong>, so we'll write <strong class="source-inline">(inc idx)</strong>. This pattern is so useful, in fact, that there is already the convenient <strong class="source-inline">map-indexed</strong> function that does exactly the same thing. In the end, all we need to write is the following:</p>
			<p class="source-code">(map-indexed (fn [idx meal] (str (inc idx) ". " meal)) meals)</p>
			<p>In the examples so far, the functions supplied to <strong class="source-inline">map</strong> or <strong class="source-inline">filter</strong> only look at one item at a time. Even when using <strong class="source-inline">map</strong> with multiple sequences, we are still looking at each item separately. With a traditional <strong class="source-inline">for</strong> loop, however, we can look ahead or behind. For example, this is something that we may write in JavaScript if we had an array of values (<strong class="source-inline">ourValues</strong>) and a function that we wanted to call on each value and the next value:</p>
			<p class="source-code">for (var i = 0; i++; i &lt; ourValues.length) {</p>
			<p class="source-code">  if (ourValues[i + 1]) {</p>
			<p class="source-code">    myFunction(ourValues[i], ourValues[i + 1]);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We check to make sure that we aren't at the last value in the array, and then we call <strong class="source-inline">myFunction</strong>. While it would be possible to write more or less the same thing in Clojure (and we'll do some looping in <em class="italic">Chapter 7</em>, <em class="italic">Recursion II: Lazy Sequences</em>), there is a much more elegant way to do this, that is, by using <strong class="source-inline">map</strong> and multiple sequences.</p>
			<p>The trick here is to use the same sequence more than once, but with an offset so that the second argument in the mapping function contains the item that follows the first argument:</p>
			<p class="source-code">(map (fn [x next-x] (do-something x next-x))</p>
			<p class="source-code">     my-sequence</p>
			<p class="source-code">     (rest my-sequence))</p>
			<p>The second sequence here is, of course, the same as the first one, except that we start with the second element. The first time the anonymous function is called, its arguments will be the first and second items in <strong class="source-inline">my-sequence</strong>; the second time, the arguments will be the second and third items, and so on.</p>
			<p>The following diagram represents this. The list from <strong class="source-inline">0</strong> to <strong class="source-inline">5</strong> is repeated with an offset. Each vertical pair corresponds to the two arguments that the mapping function will receive:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B14502_04_05.jpg" alt="Figure 4.5: A windowing or look-ahead effect with map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5: A windowing or look-ahead effect with map</p>
			<p>When using <strong class="source-inline">map</strong> with multiple collections, <strong class="source-inline">map</strong> stops iterating over them when it reaches the end of the shortest sequence. This ensures that there will always be enough arguments to supply to the mapping function. Depending on the context, when using offsets like this, it may be necessary to append data to the other end of the shortened function if it's important that the last item in the sequence is included in the results.</p>
			<p>If the problem you are solving requires looking farther ahead, you can add more offset sequences, and thus more arguments to the mapping function. All sorts of creative possibilities are available. Just remember that the shortest sequence will limit the number of items that will be mapped over.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you just need to break up a sequence into multiple parts and then map over those, you can just use <strong class="source-inline">partition</strong>. <strong class="source-inline">(partition 2 my-sequence)</strong> will break your input up into two-item sublists. </p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor099"/>Exercise 4.08: Identifying Weather Trends</h2>
			<p>In this exercise, we'll pretend that we have a list of outdoor temperatures for a series of days. We want to determine whether each day was warmer, colder, or the same as the previous day. This information could then be used to add up or down arrows to a visualization. Let's get started:</p>
			<ol>
				<li value="1">In your REPL, define a variable with the vector of integers found in <a href="https://packt.live/2tBRrnK">https://packt.live/2tBRrnK</a>:<p class="source-code">(def temperature-by-day</p><p class="source-code">  [18 23 24 23 27 24 22 21 21 20 32 33 30 29 35 28 25 24 28 29 30])</p></li>
				<li>Write an expression that maps over this vector, starting at the second item, <strong class="source-inline">23</strong>, and outputs either <strong class="source-inline">:warmer</strong>, <strong class="source-inline">:colder</strong>, or <strong class="source-inline">:unchanged</strong>:<p class="source-code">(map (fn [today yesterday] </p><p class="source-code">               (cond (&gt; today yesterday) :warmer</p><p class="source-code">                     (&lt; today yesterday) :colder</p><p class="source-code">                     (= today yesterday) :unchanged))</p><p class="source-code">             (rest temperature-by-day)</p><p class="source-code">             temperature-by-day)</p><p>Instead of looking ahead this time, we are really looking backward, so, for clarity, we've put <strong class="source-inline">(rest temperature-by-day)</strong> before <strong class="source-inline">temperature-by-day</strong> and <strong class="source-inline">today</strong> before <strong class="source-inline">yesterday</strong> in the arguments of the anonymous function. As long as you understand which sequence corresponds to which argument, the order doesn't really matter. Thanks to the offset between the two versions of the same sequence of days, we can compare <strong class="source-inline">yesterday</strong> and <strong class="source-inline">today</strong> to define a trend.</p><p>The expression should return the following:</p><p class="source-code">(:warmer :warmer :colder :warmer :colder :colder :colder :unchanged :colder :warmer :warmer :colder :colder :warmer :colder :colder :colder :warmer :warmer :warmer)</p><p>Remember that our first day corresponds to the second temperature. 23 is warmer than 18, so we get <strong class="source-inline">:warmer</strong>.</p></li>
			</ol>
			<p>The "windows" that are created by offsetting a sequence against itself can be wider than two items: <strong class="source-inline">map</strong> can accept any number of lists. </p>
			<p>The windowing pattern makes <strong class="source-inline">map</strong> even more powerful because it gets around one of its inherent limitations. In its simplest form, <strong class="source-inline">map</strong> is limited to a one-to-one relationship between the input list and the output list. With windowing, more items in the list can participate in each calculation.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor100"/>Consuming Extracted Data with apply</h2>
			<p>Often, when <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> are used to target and extract data in the form you need, the next step is producing some kind of summary. In <em class="italic">Chapter 7</em>, <em class="italic">Recursion II: Lazy Sequences</em>, we'll go into this in much more depth. For now, though, we can build some simple summary data by calling a single function, such as <strong class="source-inline">min</strong> or <strong class="source-inline">max</strong>, on a list using <strong class="source-inline">apply</strong>.</p>
			<p>Functions such as <strong class="source-inline">min</strong>, <strong class="source-inline">max</strong>, and <strong class="source-inline">+</strong> accept an unlimited number of arguments. On the other hand, they don't accept lists. If you have a list of numbers and want to find the highest value, you may find yourself thinking "If only I could take these numbers out of this list and plug them directly into my call to <strong class="source-inline">max</strong>!" Well, with <strong class="source-inline">apply</strong>, you can do just that.</p>
			<p>In its simplest form, a call to <strong class="source-inline">apply</strong> takes a function and a list, and calls the function on the list as if it were a simple multiple-arity function call:</p>
			<p class="source-code">user&gt; (apply max [3 9 6])</p>
			<p class="source-code">9</p>
			<p>This would be the same as the following:</p>
			<p class="source-code">user&gt; (max 3 9 6)</p>
			<p class="source-code">9</p>
			<p>There are many situations where this can be useful, even if you do know how many arguments you have: </p>
			<p class="source-code">user&gt; (let [a 5</p>
			<p class="source-code">            b nil</p>
			<p class="source-code">            c 18]</p>
			<p class="source-code">        (+ a b c))</p>
			<p class="source-code">Execution error (NullPointerException) at user/eval12115 (REPL:46).</p>
			<p class="source-code">null</p>
			<p>The <strong class="source-inline">+</strong> function did not appreciate the <strong class="source-inline">nil</strong> that was bound to <strong class="source-inline">b</strong>. With <strong class="source-inline">apply</strong>, we can use <strong class="source-inline">filter</strong> to remove any unwanted arguments:</p>
			<p class="source-code">user&gt; (let [a 5</p>
			<p class="source-code">            b nil</p>
			<p class="source-code">            c 18]</p>
			<p class="source-code">        (apply + (filter integer? [a b c])))</p>
			<p class="source-code">23</p>
			<p>The <strong class="source-inline">apply</strong> function is an important part of any functional programming toolkit. It is especially useful when dealing with sequential data that you can shape with <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong>.</p>
			<p>There is one danger with this technique, however. Many functions that accept multiple arguments do not accept zero arguments. The <strong class="source-inline">+</strong> function can actually be called without any arguments. If you call <strong class="source-inline">(+)</strong>, it will return <strong class="source-inline">0</strong>. On the other hand, <strong class="source-inline">min</strong> and <strong class="source-inline">max</strong> will fail if we <strong class="source-inline">apply</strong> them to an empty list:</p>
			<p class="source-code">(apply min [])</p>
			<p class="source-code">Execution error (ArityException) at chapterfive/eval13541 (REPL:103).</p>
			<p class="source-code">Wrong number of args (0) passed to: clojure.core/min</p>
			<p>In situations like this, it's important to be sure that an empty list is impossible. One way to do that is to supply at least one value. This is made easier by the fact that <strong class="source-inline">apply</strong> can accept non-list items before the list argument. This way, the call to <strong class="source-inline">min</strong> will always at least have a value of <strong class="source-inline">0</strong>:</p>
			<p class="source-code">user&gt; (apply min 0 [])</p>
			<p class="source-code">0</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor101"/>Exercise 4.09: Finding the Average Weather Temperature</h2>
			<p>Using the same weather data as in the previous exercise, we'll calculate the average temperature for the days listed. Let's get started:</p>
			<ol>
				<li value="1">Continue using the REPL from the previous exercise or start a new REPL and copy the data in from <a href="https://packt.live/2tBRrnK">https://packt.live/2tBRrnK</a>:<p class="source-code">user&gt; (def temperature-by-day</p><p class="source-code">  [18 23 24 23 27 24 22 21 21 20 32 33 30 29 35 28 25 24 28 29 30])</p><p class="source-code">#'user/temperature-by-day</p></li>
				<li>Use <strong class="source-inline">(apply +…)</strong> and <strong class="source-inline">count</strong> to calculate the sum of the temperatures and count them, and then find the average:<p class="source-code">user&gt; (let [total (apply + temperature-by-day)</p><p class="source-code">            c (count temperature-by-day)]</p><p class="source-code">        (/ total c))</p><p class="source-code">26</p></li>
			</ol>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor102"/>Activity 4.01: Using map and filter to Report Summary Information</h2>
			<p>In our imaginary game, we want to create a dashboard where users can compare themselves to other users in the same situation: active users should only be able to see other active users, and so forth. We want to know the maximum and minimum values in each case so that the current user can see how they have been placed relative to the extremes.</p>
			<p>This means that we need a function that accepts a field name (whichever field we want to display), a status (the status of the current user), and a list of <strong class="source-inline">game-users</strong>.</p>
			<p>Write two functions that report the minimum and maximum values for each of the numeric fields in <strong class="source-inline">game-users</strong> for all the users and for each status category. We want to be able to ask: What is the highest value of <strong class="source-inline">:current-points</strong> for all the <strong class="source-inline">:active</strong> users?</p>
			<p>The functions should take three arguments: the field we want, the status we want, and the list of users. They should be called like this:</p>
			<p class="source-code">(max-value-by-status :current-points :active game-users)</p>
			<p class="source-code">(min-value-by-status :remaining-lives :imprisoned game-users)</p>
			<p>The call signature of the function will look like this:</p>
			<p class="source-code">(defn max-value-by-status [field status users]</p>
			<p class="source-code">;; TODO: write code</p>
			<p class="source-code">)</p>
			<p>For simplicity, you should probably structure your code the same way we have done previously, that is, with the threading macro, <strong class="source-inline">-&gt;&gt;</strong>, which can chain multiple function calls together.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Use <strong class="source-inline">filter</strong> to narrow down the users who have the status we are looking for.</li>
				<li>Use <strong class="source-inline">map</strong> to extract the value that you want.</li>
				<li>Use the <strong class="source-inline">min</strong> and <strong class="source-inline">max</strong> functions with <strong class="source-inline">apply</strong> to find the minimums and maximums. Make sure your code will still work, even if there aren't any users who have the status you are looking for.</li>
			</ol>
			<p>The following is the expected outcome:</p>
			<p> </p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B14502_04_06.jpg" alt="Figure 4.6: Expected outcome&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6: Expected outcome</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 689.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor103"/>Importing a Dataset from a CSV File</h1>
			<p>Now that we've seen some basic patterns for manipulating data, it's time to be more ambitious! We are going to start using a dataset that we will use in many of the following chapters as we build up our Clojure knowledge: ATP World Tour tennis data, a CSV file that includes, among other things, information about professional tennis matches going back to 1871. Besides learning about new concepts and techniques, we will see that Clojure can be an interesting choice for exploring and manipulating large datasets. And, naturally, most of the datasets that are available to us are CSV files.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This dataset was created and is maintained at <a href="https://packt.live/2Fq30kk">https://packt.live/2Fq30kk</a>, and is available under the Creative Commons 4.0 International License. The files that we'll be using here are also available at <a href="https://packt.live/37DCkZn">https://packt.live/37DCkZn</a>. </p>
			<p>In the rest of this chapter, we will import tennis match data from a CSV file and use our mapping and filtering techniques to extract interesting data from it.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor104"/>Exercise 4.10: Importing Data from a CSV File</h2>
			<p>It's time to imagine that you work for a sports journalism website specializing in data-centric reporting. Your role is to help the journalists analyze data and produce interesting visualizations for the site. In your new job, you need to be able to import large datasets that are usually published as CSV. Let's get started:</p>
			<ol>
				<li value="1">Create a folder somewhere convenient on your computer. </li>
				<li>Download the <strong class="source-inline">match_scores_1991-2016_UNINDEXED.csv</strong> file to the folder you created.</li>
				<li>In your editor, in the same folder, create a <strong class="source-inline">deps.edn</strong> file with the following contents:<p class="source-code">{:deps</p><p class="source-code"> {org.clojure/data.csv {:mvn/version "0.1.4"}</p><p class="source-code">  semantic-csv {:mvn/version "0.2.1-alpha1"}}}</p><p>These are references to two libraries that we will use extensively. The first one, <strong class="source-inline">clojure.data.csv</strong>, is lower-level tool and deals with the mechanics of getting data in and out of a <strong class="source-inline">.csv</strong> file. <strong class="source-inline">semantic-csv</strong>, on the other hand, is a higher-level tool that makes it easier to work with <strong class="source-inline">.csv</strong> data.</p><p>Still in the same folder, with your editor or IDE, start a Clojure REPL.</p></li>
				<li>Verify that everything is working by evaluating the following expression in your REPL:<p class="source-code">user&gt; (require '[clojure.data.csv :as csv])</p><p class="source-code">nil</p><p class="source-code">user&gt; (require '[clojure.java.io :as io])</p><p class="source-code">nil</p><p class="source-code">user&gt; (with-open [r (io/reader "match_scores_1991-2016_unindexed_csv.csv")]</p><p class="source-code">         (first (csv/read-csv r)))</p><p class="callout-heading">Note</p><p class="callout">When accessing data files, using the filename without the path will work as long as the data file is in the root directory of your Clojure project, which is the convention we have adopted here. If your data file is somewhere else, you'll need to include the absolute path instead.</p><p>Note that we didn't need to include <strong class="source-inline">clojure.java.io</strong> in our <strong class="source-inline">deps.edn</strong> file. That's because <strong class="source-inline">clojure.java.io</strong> is a core Clojure library. We still need to require it into our namespace, though. You should see this as the output:</p><p class="source-code">["tourney_year_id"</p><p class="source-code"> "tourney_order"</p><p class="source-code"> "tourney_slug"</p><p class="source-code"> "tourney_url_suffix"</p><p class="source-code"> "tourney_round_name"</p><p class="source-code"> "round_order"</p><p class="source-code"> "match_order"</p><p class="source-code"> "winner_name"</p><p class="source-code"> "winner_player_id"</p><p class="source-code"> "winner_slug"</p><p class="source-code"> "loser_name"</p><p class="source-code"> "loser_player_id"</p><p class="source-code"> "loser_slug"</p><p class="source-code"> "winner_seed"</p><p class="source-code"> "loser_seed"</p><p class="source-code"> "match_score_tiebreaks"</p><p class="source-code"> "winner_sets_won"</p><p class="source-code"> "loser_sets_won"</p><p class="source-code"> "winner_games_won"</p><p class="source-code"> "loser_games_won"</p><p class="source-code"> "winner_tiebreaks_won"</p><p class="source-code"> "loser_tiebreaks_won"</p><p class="source-code"> "match_id"</p><p class="source-code"> "match_stats_url_suffix"]</p><p><strong class="source-inline">clojure.data.csv</strong> returns a vector of strings for each line in the file. This is the first line of the file, which is, of course, the column headers.</p></li>
				<li>When exploring a new dataset, it's always good to know the size of the data. We can use <strong class="source-inline">count</strong> here to check that:<p class="source-code">user&gt; (with-open [r (io/reader "match_scores_1991-2016_unindexed_csv.csv")]</p><p class="source-code">         (count (csv/read-csv r)))</p><p class="source-code">91957</p></li>
			</ol>
			<p>These are the basics of opening and reading a CSV file in Clojure. All the other data analysis techniques we will examine will use this same basic pattern. But before we go any further, we need to take a look at lazy evaluation.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor105"/>Real-World Laziness</h2>
			<p>Did you notice how the code you evaluated in the previous exercise was rather fast? The data file is quite long, and it seems like it would take a long time to parse it. But <strong class="source-inline">parse-csv</strong> is lazy. Because we only asked for the first result, the evaluation stopped after one line. This is convenient because it allows us to process large files without loading them into memory. </p>
			<p>Because we are dealing with files, we have to be careful. Remember that lazy evaluation means that evaluation is deferred until it is needed. That is fine for sequences of integers, but with an external resource such as a file reader, if we wait too long, the resource may not be available anymore. To avoid problems, we will do two things: </p>
			<ul>
				<li>Most of our data work will happen inside the scope of the <strong class="source-inline">with-open</strong> macro. </li>
				<li>We won't return any lazy sequences from the <strong class="source-inline">with-open</strong> macro. </li>
			</ul>
			<p>In other words, inside the scope of <strong class="source-inline">with-open</strong>, we can use and combine all the lazy evaluation techniques we like. When we return sequences, we'll make sure that they are fully realized, often using the <strong class="source-inline">doall</strong> function. It may be tempting to immediately call <strong class="source-inline">doall</strong> to avoid having to worry about lazy evaluation at all. While there are cases where this may be appropriate, it is best to try to resist this temptation. Reading a large CSV file is a good example of why preserving the laziness of sequences is important. Calling <strong class="source-inline">doall</strong> too soon would force all of the rows of data to be loaded into memory, when maybe we only need a few rows.</p>
			<p>Let's look at this in practice.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor106"/>Exercise 4.11: Avoiding Lazy Evaluation Traps with Files</h2>
			<p>In the previous exercise, you successfully opened a CSV file and started to play with it a little bit. "It's time," you say to yourself, "to look at some real data." The incoming data appears to be a sequence, since we can use <strong class="source-inline">first</strong> and <strong class="source-inline">count</strong> on it. Let's try to extract some more data:</p>
			<ol>
				<li value="1">In the same folder as before, open your REPL again.</li>
				<li>If necessary, load the dependencies again:<p class="source-code">user&gt; (require '[clojure.data.csv :as csv])</p><p class="source-code">nil</p><p class="source-code">user&gt; (require '[clojure.java.io :as io])</p><p class="source-code">nil</p></li>
				<li>Let's try to extract the name of the winner of each of the first five matches. Starting from 0, the <strong class="source-inline">winner_name</strong> field is number <strong class="source-inline">7</strong>, so we want to call <strong class="source-inline">#(nth % 7)</strong> on each of the first five lines (after the initial header line). Maybe this will work:<p class="source-code">(with-open [r (io/reader "match_scores_1991-2016_unindexed_csv.csv")]</p><p class="source-code">  (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">       (map #(nth % 7))</p><p class="source-code">       (take 6)))</p><p>The output is as follows:</p><p class="source-code">Error printing return value (IOException) at java.io.BufferedReader/ensureOpen (BufferedReader.java:122).</p><p class="source-code">Stream closed</p><p>What happened? As the error message suggests, the file stream is closed when the REPL tries to print the results. <strong class="source-inline">map</strong> and <strong class="source-inline">take</strong> are both lazy. But why? We call <strong class="source-inline">map</strong> and <strong class="source-inline">take</strong> <em class="italic">inside</em> the scope of <strong class="source-inline">with-open</strong>. Shouldn't the file still be open? The problem is that because the evaluation is deferred, it has not happened yet when we exit the scope of the <strong class="source-inline">with-open</strong> macro. All we have at that point is an unevaluated sequence. When the REPL tried to evaluate the lazy expression returned by <strong class="source-inline">take</strong>, the scope where the file reader was available disappeared. Lazy sequences are not evaluated until they are consumed, and in this case, the sequence is consumed in your REPL.</p></li>
				<li>Now, try again with <strong class="source-inline">doall</strong>:<p class="source-code">user&gt; (with-open [r (io/reader "match_scores_1991-2016_unindexed_csv.csv")]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         (map #(nth % 7))</p><p class="source-code">         (take 6)</p><p class="source-code">         doall))</p><p>This time, you should see something like this:</p><p class="source-code">("winner_name"</p><p class="source-code"> "Nicklas Kulti"</p><p class="source-code"> "Michael Stich"</p><p class="source-code"> "Nicklas Kulti"</p><p class="source-code"> "Jim Courier"</p><p class="source-code"> "Michael Stich")</p><p>As you can see, <strong class="source-inline">doall</strong> forces the evaluation of the lazy sequence. The closed stream is no longer a problem. The expression returns a simple list.</p></li>
			</ol>
			<p>While working with this dataset, we will use this basic pattern many times, often ending with <strong class="source-inline">doall</strong>. You can also see how it reproduces a familiar pattern: get the information (<strong class="source-inline">csv/read-csv</strong>), shape the information (<strong class="source-inline">map, take</strong>), and hand the information off (<strong class="source-inline">doall</strong>). Lazy evaluation combined with limited external resources, such as file I/O, in this case, does add an extra challenge. Maintaining a clear separation between data acquisition, data manipulation, and data output is not only good design or good practice—in a situation like this, it will really help avoid errors and bugs. Even in this case, however, there is an upside to lazy evaluation: some files may be too large to fit in memory. By evaluating the output from the file "lazily," the entire file doesn't need to be loaded into memory simultaneously. </p>
			<p>You've now extracted some real data from the <strong class="source-inline">.csv</strong> file.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Clojure's <strong class="source-inline">mapv</strong> function is a replacement for <strong class="source-inline">map</strong>, with one key difference: instead of returning a lazy sequence, it returns a vector. Because vectors are not lazy, this can be a way of avoiding a call to <strong class="source-inline">doall</strong>. For clarity, however, it is often preferable to use <strong class="source-inline">doall</strong> explicitly.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor107"/>Convenient CSV Parsing</h2>
			<p>As you can see from the previous example, <strong class="source-inline">clojure.data.csv</strong> returns a sequence of vectors, where each vector contains, as individual strings, the CSV files in a single line of the original file. There is still some work to do before we can really use that data, however. Because <strong class="source-inline">.csv</strong> is such a common format, there are libraries that can make things a little bit more convenient. We'll be using <strong class="source-inline">semantic-csv</strong>, which we've already included in our <strong class="source-inline">deps.edn</strong> file. </p>
			<p>The main functions that we'll use from <strong class="source-inline">semantic-csv</strong> are <strong class="source-inline">mappify</strong> and <strong class="source-inline">cast-with</strong>. With <strong class="source-inline">mappify</strong>, each row becomes a Clojure map, where the keys are the column names from the CSV file, and with <strong class="source-inline">cast-with</strong>, we can transform strings containing numeric values in the source file into the correct types.</p>
			<p>Let's see how this works. After that, we'll be ready to do some more interesting things with the data in our <strong class="source-inline">.csv</strong> file. </p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/>Exercise 4.12: Parsing CSV with semantic-csv</h2>
			<p>In this exercise, we'll start by saving our work in a file so that we can come back to it later. Let's get started:</p>
			<ol>
				<li value="1">In the same folder as before, create a new file, <strong class="source-inline">tennis.clj</strong>, in your text editor. </li>
				<li>Set up your namespace and use <strong class="source-inline">:require</strong> so that you have access to the necessary libraries: <p class="source-code">(ns packt-clj.tennis</p><p class="source-code">  (:require</p><p class="source-code">   [clojure.data.csv :as csv]</p><p class="source-code">   [clojure.java.io :as io]</p><p class="source-code">   [semantic-csv.core :as sc]))</p></li>
				<li>Write a function that returns the first row of data:<p class="source-code">(defn first-match [csv]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         first)))</p></li>
				<li>Evaluate your file, move to the <strong class="source-inline">packt-clj.tennis</strong> namespace in your REPL, and call the function:<p class="source-code">(in-ns 'packt-clj.tennis)</p><p class="source-code">(first-match "match_scores_1991-2016_unindexed_csv.csv")</p><p>You should see a map with the data for the first match:</p><p class="source-code">{:tourney_slug "adelaide",</p><p class="source-code"> :loser_slug "michael-stich",</p><p class="source-code"> :winner_sets_won "2",</p><p class="source-code"> :match_score_tiebreaks "63 16 62",</p><p class="source-code"> :loser_sets_won "1",</p><p class="source-code"> :loser_games_won "11",</p><p class="source-code"> :tourney_year_id "1991-7308",</p><p class="source-code"> :tourney_order "1",</p><p class="source-code"> :winner_seed "",</p><p class="source-code"> :loser_seed "6",</p><p class="source-code"> :winner_slug "nicklas-kulti",</p><p class="source-code"> :match_order "1",</p><p class="source-code"> :loser_name "Michael Stich",</p><p class="source-code"> :winner_player_id "k181",</p><p class="source-code"> :match_stats_url_suffix "/en/scores/1991/7308/MS001/match-stats",</p><p class="source-code"> :tourney_url_suffix "/en/scores/archive/adelaide/7308/1991/results",</p><p class="source-code"> :loser_player_id "s351",</p><p class="source-code"> :loser_tiebreaks_won "0",</p><p class="source-code"> :round_order "1",</p><p class="source-code"> :tourney_round_name "Finals",</p><p class="source-code"> :match_id "1991-7308-k181-s351",</p><p class="source-code"> :winner_name "Nicklas Kulti",</p><p class="source-code"> :winner_games_won "13",</p><p class="source-code"> :winner_tiebreaks_won "0"}</p></li>
				<li>That's a lot of information. We don't need all of those fields, so we'll call <strong class="source-inline">select-keys</strong> on each <strong class="source-inline">map</strong> to keep only the values that interest us. This time, we'll keep the first five rows:<p class="source-code">(defn five-matches [csv]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (map #(select-keys % [:tourney_year_id</p><p class="source-code">                               :winner_name</p><p class="source-code">                               :loser_name</p><p class="source-code">                               :winner_sets_won</p><p class="source-code">                               :loser_sets_won]))</p><p class="source-code">         (take 5)</p><p class="source-code">         doall)))</p><p>Evaluate your file again, and then call <strong class="source-inline">five-matches</strong> in the REPL:</p><p class="source-code">(five-matches "match_scores_1991-2016_unindexed_csv.csv")</p><p>You should see a list of maps:</p><p class="source-code">({:tourney_year_id "1991-7308",</p><p class="source-code">  :winner_name "Nicklas Kulti",</p><p class="source-code">  :loser_name "Michael Stich",</p><p class="source-code">  :winner_sets_won "2",</p><p class="source-code">  :loser_sets_won "1"}</p><p class="source-code"> {:tourney_year_id "1991-7308",</p><p class="source-code">  :winner_name "Michael Stich",</p><p class="source-code">  :loser_name "Jim Courier",</p><p class="source-code">  :winner_sets_won "2",</p><p class="source-code">  :loser_sets_won "0"}</p><p class="source-code">...etc.</p></li>
				<li>To use the <strong class="source-inline">:winner_sets_won</strong> and <strong class="source-inline">:loser_sets_won</strong> fields in a calculation of some kind, we need to cast them as integers first. Use the <strong class="source-inline">cast-with</strong> function of <strong class="source-inline">semantic-csv</strong>:<p class="source-code">(defn five-matches-int-sets [csv]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (map #(select-keys % [:tourney_year_id</p><p class="source-code">                               :winner_name</p><p class="source-code">                               :loser_name</p><p class="source-code">                               :winner_sets_won</p><p class="source-code">                               :loser_sets_won]))</p><p class="source-code">         (sc/cast-with {:winner_sets_won sc/-&gt;int</p><p class="source-code">                     :loser_sets_won sc/-&gt;int})</p><p class="source-code">         (take 5)</p><p class="source-code">         doall)))</p><p>This will return the same data as the previous function, except that the values for <strong class="source-inline">:winner_sets_won</strong> and <strong class="source-inline">:loser_sets_won</strong> won't appear with quotation marks anymore:</p><p class="source-code">{:tourney_year_id "1991-7308",</p><p class="source-code">  :winner_name "Nicklas Kulti",</p><p class="source-code">  :loser_name "Michael Stich",</p><p class="source-code">  :winner_sets_won 2, ;; &lt;----- Real integer!</p><p class="source-code">  :loser_sets_won 1}</p></li>
			</ol>
			<p>Now, we have enough tools to start performing some interesting queries against our dataset. With <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and a few simple tools, we are ready to write simple, yet sophisticated, queries. In the next section, we are going to look at some techniques that will be useful in their own right and will help you to think about using functions to describe the data you want. </p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/>Exercise 4.13: Querying the Data with filter</h1>
			<p>If we think of this CSV data as a database, then writing queries is a question of writing and combining predicates. In this exercise, we will use <strong class="source-inline">filter</strong> to narrow our dataset down to the exact information we want. Imagine that the journalists on your team are working on a new project dedicated to famous tennis rivalries. As a first step, they've asked you to produce a list of all the tennis matches won by Roger Federer. Let's get started:</p>
			<ol>
				<li value="1">Make sure that your project is set up the same way as it was in the previous exercises.</li>
				<li>Create a function called <strong class="source-inline">federer-wins</strong> that provides the CSV processing steps we've already used. Add the calls to <strong class="source-inline">select-keys</strong> and <strong class="source-inline">doall</strong>, which will be applied to the data once it has been narrowed down:<p class="source-code">(defn federer-wins [csv]</p><p class="source-code">    (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         ;; TODO: keep writing code</p><p class="source-code">         (map #(select-keys % [:winner_name</p><p class="source-code">                               :loser_name</p><p class="source-code">                               :winner_sets_won</p><p class="source-code">                               :loser_sets_won</p><p class="source-code">                               :winner_games_won</p><p class="source-code">                               :loser_games_won</p><p class="source-code">                               :tourney_year_id</p><p class="source-code">                               :tourney_slug]))</p><p class="source-code">         doall)))</p></li>
				<li>Write a predicate that will decide whether Roger Federer won a match. Using the same pattern as in the previous examples, all we need to do is "plug in" a call to <strong class="source-inline">filter</strong> with the right predicate.<p>The predicate itself is rather simple. It's just a question of matching one of the fields of each map:</p><p class="source-code">#(= "Roger Federer" (:winner_name %))</p></li>
				<li>Use this predicate with <strong class="source-inline">filter</strong> in the function:<p class="source-code">(defn federer-wins [csv]</p><p class="source-code">    (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (filter #(= "Roger Federer" (:winner_name %)))</p><p class="source-code">         (map #(select-keys % [:winner_name</p><p class="source-code">                               :loser_name</p><p class="source-code">                               :winner_sets_won</p><p class="source-code">                               :loser_sets_won</p><p class="source-code">                               :winner_games_won</p><p class="source-code">                               :loser_games_won</p><p class="source-code">                               :tourney_year_id</p><p class="source-code">                               :tourney_slug]))</p><p class="source-code">         doall)))</p><p>Try calling <strong class="source-inline">federer-wins</strong>. You will receive the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B14502_04_07.jpg" alt="Figure 4.7: Printing the details&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7: Printing the details</p>
			<p>This seems to work!</p>
			<p>This exercise shows how writing a query is as simple as writing a new predicate. You have all the power and flexibility of the Clojure language at hand to describe exactly what results you need. In the next exercise, we will use a higher-order functional technique to write a dedicated query function.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>Exercise 4.14: A Dedicated Query Function</h2>
			<p>Your team is happy with the initial results and now they have started asking you to run new queries all the time. You are tired of writing the same code each time, so you've decided to write a function that can accept any predicate. Let's get started:</p>
			<ol>
				<li value="1">Use the same environment as in the previous exercise.</li>
				<li>Rewrite the <strong class="source-inline">federer-wins</strong> function as <strong class="source-inline">match-query</strong>, which takes a second argument, that is, <strong class="source-inline">pred</strong>:<p class="source-code">(defn match-query [csv pred]</p><p class="source-code">    (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (filter pred)</p><p class="source-code">         (map #(select-keys % [:winner_name</p><p class="source-code">                               :loser_name</p><p class="source-code">                               :winner_sets_won</p><p class="source-code">                               :loser_sets_won</p><p class="source-code">                               :winner_games_won</p><p class="source-code">                               :loser_games_won</p><p class="source-code">                               :tourney_year_id</p><p class="source-code">                               :tourney_slug]))</p><p class="source-code">         doall)))</p></li>
				<li>Write a predicate to search for all of Federer's matches, wins, and losses.<p>One possibility would be to simply add an <strong class="source-inline">or</strong> operator:</p><p class="source-code">#(or (= "Roger Federer" (:winner_name %))</p><p class="source-code">     (= "Roger Federer" (:loser_name %)))</p><p>We could also use a set as a predicate, as we saw earlier: </p><p class="source-code">#((hash-set (:winner_name %) (:loser_name %)) "Roger Federer")</p><p>First, we define a set that includes the <strong class="source-inline">:winner_name</strong> and <strong class="source-inline">:loser_name</strong> fields and then we ask: is <strong class="source-inline">Roger Federer</strong> a member of that set?</p><p class="callout-heading">Note</p><p class="callout">We've written <strong class="source-inline">hash-set</strong> here instead of using the literal notation, <strong class="source-inline">#{…}</strong>, to avoid confusion with the <strong class="source-inline">#(…)</strong> of the anonymous function. <strong class="source-inline">hash-set</strong> and <strong class="source-inline">set</strong> do the same thing, that is, they create Clojure sets, except that <strong class="source-inline">set</strong> takes a single collection as an argument, while <strong class="source-inline">hash-set</strong> takes any number of items.</p></li>
				<li>Test this by counting the number of matches played and the number of matches won using the predicate from the previous exercise:</li>
			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B14502_04_08.jpg" alt="Figure 4.8: Number of matches played and won by Federer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8: Number of matches played and won by Federer</p>
			<p>Now, we know that, in our dataset, Federer played <strong class="source-inline">1,290</strong> matches and won <strong class="source-inline">1,050</strong> times! </p>
			<p>Providing a predicate as an argument makes writing queries like this very convenient. It becomes easier to write more and more complex queries. In the next exercise, we will continue to build on this.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/>Exercise 4.15: Using filter to Find a Tennis Rivalry</h2>
			<p>As your team's deadline approaches, the journalists are asking for more and more specific queries. They've decided to write an article about one of the most famous rivalries in modern tennis, that is, between Roger Federer and Rafael Nadal. They want you to write two queries: the first should return all the matches between the two players, while the second should return only the matches where the score was very close. Let's get started:</p>
			<ol>
				<li value="1">Use the same environment as the previous exercises.</li>
				<li>Write a predicate that will select all the matches between the two players. One possibility would be to use <strong class="source-inline">or</strong>, like this:<p class="source-code">#(and </p><p class="source-code">   (or (= (:winner_name %) "Roger Federer")</p><p class="source-code">       (= (:winner_name %) "Rafael Nadal"))</p><p class="source-code">   (or (= (:loser_name %) "Roger Federer")</p><p class="source-code">       (= (:loser_name %) "Rafael Nadal")))</p><p>This would work, but you can see that the logic is getting more complex because we have to account for two different possibilities. This is where sets can be very useful:</p><p class="source-code">#(= (hash-set (:winner_name %) (:loser_name %)) </p><p class="source-code">    #{"Roger Federer" "Rafael Nadal"})</p><p>Sets are great for these kinds of situations. We don't care about the order, or, unlike the players themselves, which one is the winner or the loser. </p><p>Test this predicate using the <strong class="source-inline">match-query</strong> function from the previous exercise:</p><div id="_idContainer038" class="IMG---Figure"><img src="image/B14502_04_09.jpg" alt="Figure 4.9: Testing the predicate&#13;&#10;"/></div><p class="figure-caption">Figure 4.9: Testing the predicate</p><p>This seems to work. Now, we need to narrow down the results to the closest matches.</p></li>
				<li>Update <strong class="source-inline">match-query</strong> so that we can do arithmetic on the fields. To know whether a match was close, we need to be able to subtract <strong class="source-inline">:loser_sets_won</strong> from <strong class="source-inline">:winner_sets_won</strong>. We have a problem, though: the values are strings here and not integers, so we can't subtract. To fix this, we need to go back to <strong class="source-inline">match-query</strong> and reintroduce the type conversions that we used in the previous exercises. Here's the new version of <strong class="source-inline">match-query</strong>:<p class="source-code">(defn match-query [csv pred]</p><p class="source-code">    (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (sc/cast-with {:winner_sets_won sc/-&gt;int</p><p class="source-code">                        :loser_sets_won sc/-&gt;int</p><p class="source-code">                        :winner_games_won sc/-&gt;int</p><p class="source-code">                        :loser_games_won sc/-&gt;int})</p><p class="source-code">         (filter pred)</p><p class="source-code">         (map #(select-keys % [:winner_name</p><p class="source-code">                               :loser_name</p><p class="source-code">                               :winner_sets_won</p><p class="source-code">                               :loser_sets_won</p><p class="source-code">                               :winner_games_won</p><p class="source-code">                               :loser_games_won</p><p class="source-code">                               :tourney_year_id</p><p class="source-code">                               :tourney_slug]))</p><p class="source-code">         doall)))</p></li>
				<li>Write a predicate for close matches.<p>We'll use <strong class="source-inline">and</strong> to combine the Federer-Nadal predicate with a test for the difference in sets won:</p><p class="source-code">#(and (= (hash-set (:winner_name %) (:loser_name %)) </p><p class="source-code">      #{"Roger Federer" "Rafael Nadal"})</p><p class="source-code">      (= <a id="_idTextAnchor112"/>1 (- (:winner_sets_won %) (:loser_sets_won %))))</p></li>
				<li>Let's test our new predicate:</li>
			</ol>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B14502_04_10.jpg" alt="Figure 4.10: Printing the results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10: Printing the results</p>
			<p>The results tell the story of one of the great rivalries in sports!</p>
			<p>As long as we are searching for lists of results, <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and some carefully crafted predicates can accomplish a lot: <strong class="source-inline">map</strong> prepares the data while <strong class="source-inline">filter</strong> finds the items we are looking for.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor113"/>Activity 4.02: Arbitrary Tennis Rivalries</h2>
			<p>Your data consultancy team is encouraged by what they could learn by looking at the Federer-Nadal rivalry data and they want to be able to expand the approach. They've asked you to write a function that will find some summary statistics about all the matches between any two players. They would also like to have a list of the most competitive matches between the players. </p>
			<p>Using the tennis dataset, write a function that provides information about a tennis rivalry. The call signature should look like this:</p>
			<p class="source-code">(defn rivalry-data [csv player-1 player-2])</p>
			<p>The function should return a map with the following fields:</p>
			<p class="source-code">:first-victory-player-1 </p>
			<p class="source-code">:first-victory-player-2 </p>
			<p class="source-code">:total-matches</p>
			<p class="source-code">:total-victories-player-1 </p>
			<p class="source-code">:total-victories-player-2</p>
			<p class="source-code">:most-competitive-matches</p>
			<p>The values in the <strong class="source-inline">:total-*</strong> fields should be integers. The other fields should be (possibly empty) lists of matches. When displaying matches in the results, limit the fields to those displayed in the previous example, that is, <strong class="source-inline">:winner_name</strong>, <strong class="source-inline">:loser_name</strong>, <strong class="source-inline">:winner_sets_won</strong>, <strong class="source-inline">:loser_sets_won</strong>, <strong class="source-inline">:winner_games_won</strong>, <strong class="source-inline">:loser_games_won</strong>, <strong class="source-inline">:tourney_year_id</strong>, and <strong class="source-inline">:tourney_slug</strong>.</p>
			<p>Save your function in the same file that you did for <em class="italic">Exercise 4.12</em>, <em class="italic">Parsing CSV with semantic-csv</em>.</p>
			<p>These steps will help you to complete this activity:</p>
			<ol>
				<li value="1">Don't forget to use the same calls to <strong class="source-inline">sc/mappify</strong> and <strong class="source-inline">sc/cast-with</strong> to make your data easy to work with.</li>
				<li>Within the scope of a <strong class="source-inline">with-open</strong> macro, use <strong class="source-inline">let</strong> to bind the lazy sequence of all the matches between the two players to a local symbol. Use that binding later whenever you need to match data, rather than rereading from the <strong class="source-inline">.csv</strong> file.</li>
				<li>To calculate each result field, you will need to filter the list of matches  in a different way. </li>
				<li>For the <strong class="source-inline">:total-*</strong> fields, obtain the correct sequences and then use <strong class="source-inline">count</strong>.</li>
				<li>For the fields that show matches, use <strong class="source-inline">select-keys</strong> to keep only the fields we are interested in.</li>
			</ol>
			<p>The following is the expected outcome:</p>
			<p>For any two players who have actually played against each other, your function should produce summary data:</p>
			<p class="source-code">packt-clj.tennis&gt; (rivalry-data "/Users/joseph/Documents/Packt/data/atp-world-tour-tennis-data_zip/data/match_scores_1968-1990_unindexed_csv.csv" "Boris Becker" "Jimmy Connors"  )</p>
			<p class="source-code">{:first-victory-player-1</p>
			<p class="source-code">  {:winner_name "Boris Becker",</p>
			<p class="source-code">  :loser_name "Jimmy Connors",</p>
			<p class="source-code">  :winner_sets_won 2,</p>
			<p class="source-code">  :loser_sets_won 1,</p>
			<p class="source-code">  :winner_games_won 17,</p>
			<p class="source-code">  :loser_games_won 16,</p>
			<p class="source-code">  :tourney_year_id "1986-411",</p>
			<p class="source-code">  :tourney_slug "chicago"},</p>
			<p class="source-code">  :first-victory-player-2 nil,</p>
			<p class="source-code">  :total-matches 5,</p>
			<p class="source-code">  :total-victories-player-1 5,</p>
			<p class="source-code">  :total-victories-player-2 0,</p>
			<p class="source-code">  :most-competitive-matches</p>
			<p class="source-code">  ({:winner_name "Boris Becker",</p>
			<p class="source-code">  :loser_name "Jimmy Connors",</p>
			<p class="source-code">  :winner_sets_won 2,</p>
			<p class="source-code">  :loser_sets_won 1,</p>
			<p class="source-code">  :winner_games_won 17,</p>
			<p class="source-code">  :loser_games_won 16,</p>
			<p class="source-code">  :tourney_year_id "1986-411",</p>
			<p class="source-code">  :tourney_slug "chicago"}</p>
			<p class="source-code">  {:winner_name "Boris Becker",</p>
			<p class="source-code">  :loser_name "Jimmy Connors",</p>
			<p class="source-code">  :winner_sets_won 2,</p>
			<p class="source-code">  :loser_sets_won 1,</p>
			<p class="source-code">  :winner_games_won 15,</p>
			<p class="source-code">  :loser_games_won 15,</p>
			<p class="source-code">  :tourney_year_id "1986-428",</p>
			<p class="source-code">  :tourney_slug "bolton"}</p>
			<p class="source-code">  {:winner_name "Boris Becker",</p>
			<p class="source-code">  :loser_name "Jimmy Connors",</p>
			<p class="source-code">  :winner_sets_won 2,</p>
			<p class="source-code">  :loser_sets_won 1,</p>
			<p class="source-code">  :winner_games_won 18,</p>
			<p class="source-code">  :loser_games_won 14,</p>
			<p class="source-code">  :tourney_year_id "1987-311",</p>
			<p class="source-code">  :tourney_slug "london"}</p>
			<p class="source-code">  {:winner_name "Boris Becker",</p>
			<p class="source-code">  :loser_name "Jimmy Connors",</p>
			<p class="source-code">  :winner_sets_won 2,</p>
			<p class="source-code">  :loser_sets_won 1,</p>
			<p class="source-code">  :winner_games_won 15,</p>
			<p class="source-code">  :loser_games_won 14,</p>
			<p class="source-code">  :tourney_year_id "1987-605",</p>
			<p class="source-code">  :tourney_slug "nitto-atp-finals"})}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 691.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor114"/>Summary</h1>
			<p>In this chapter, we have looked at how to use two of Clojure's most important and useful functions for handling sequential data. From a practical point of view, you have seen how to use <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong>, as well as some patterns and idioms for accomplishing common tasks and avoiding some common problems. You are starting to build your mental toolkit for working with collections.</p>
			<p>Working with <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> means we are working with lazy sequences, and so this chapter explored some of the ins and outs of lazy evaluation, which is one of Clojure's fundamental building blocks. </p>
			<p>The techniques for reading and parsing files, extracting, querying, and manipulating data will also be useful right away as we continue to build on these data-handling techniques in the next chapter.</p>
		</div>
		<div>
			<div id="_idContainer041" class="Content">
			</div>
		</div>
	</body></html>