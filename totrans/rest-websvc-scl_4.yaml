- en: Chapter 4. An Easy REST Service Using Scalatra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to create REST services using frameworks
    that use a functional, Scala language-like approach. Finch used a very functional
    programming-based approach, and Unfiltered used pattern matching. In this chapter,
    we explore a Scala framework, Scalatra, whose main goal is simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explain Scalatra''s functionality using the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First Scalatra service**: We''ll create a simple Scalatra service that shows
    how you can get up and running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verb and path handling**: Scalatra provides a number of constructs you can
    use to define a route. A route can match a specific HTTP verb and path and on
    a match, it will return a specific response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add support for futures and simple validation**: In its standard configuration,
    Scalatra works synchronously. In this part, we''ll show you how you can add support
    for futures and also add some basic validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convert to and from JSON and support advanced validations**: In the last
    part of this chapter, we''ll look at JSON support and explain how Scalatra supports
    a more advanced way of validating incoming requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, though, let's have a quick look at what Scalatra is, and what it aims
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Scalatra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalatra is a small Scala web framework which tries to keep things simple. It
    provides a set of guidelines and helper classes to create complete web applications.
    In this chapter, we'll focus on the support it provides to create REST services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalatra is built with a number of principles in mind (from the Scalatra home
    page):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Start small, build upwards: Start with a small core, and have lots of easy
    integrations for common tasks.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Freedom: Allow the user freedom to choose whatever structure and libraries
    make the most sense for the application being built.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Solid, but not stolid: Use solid base components. For instance, servlets aren''t
    cool, but they are extremely stable and have a huge community behind them. At
    the same time, work to advance the state of web application development by using
    new techniques and approaches.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Love HTTP: Embrace HTTP and its stateless nature. People get into trouble
    when they fool themselves into thinking things which aren''t true - fancy server-side
    tricks to give an illusion of statefulness aren''t for us.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you'll see in this chapter, the main goal of Scalatra is to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Your first Scalatra service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get our first Scalatra service up and running, we need to take a couple
    of extra steps. The reason is that Scalatra is designed to run in a servlet container
    (for example, Tomcat or Jetty). While this works great for test and production
    environments, it doesn''t allow us to do some quick prototyping or easily run
    from SBT or an IDE. Luckily, you can also start the Jetty servlet container programmatically
    and run your Scalatra service from there. So, in this section, we''ll:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by showing you the dependencies required to run Scalatra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Jetty in such a way that it can run our Scalatra REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple Scalatra service that responds to a specific `GET` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s look at the dependencies for Scalatra. You can find these in
    the `Dependencies.scala` file in the `project` directory of the `sources` directory.
    For Scalatra (and Jetty), we define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first dependency in this `Seq` pulls in all the required Scalatra libraries,
    the second one allows us to define how and what Jetty will log, and the final
    dependency is needed so that we can start Jetty programmatically from our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these dependencies defined, we can create an embedded Jetty server, which
    we can use to serve our REST services. The code for this launcher can be found
    in the `chapter4/package.scala` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll not dive too much into this code since it isn't really related to Scalatra.
    The main thing to understand here is that we've defined a function called `launch`,
    which takes the name of a bootstrap class as a parameter (more on this later)
    and that we've added a `ScalatraListener` instance using the `addEventListener`
    function. Once the Jetty server has finished starting up, the `ScalatraListener`
    will be called and start the Scalatra service using the provided `bootstrapClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created a way to launch our Scalatra service, let''s look at
    the most basic example (source can be found in the `HelloScalatra.scala` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through this file from top to bottom. At the top, we define an object
    called `ScalatraRunner`. With this object, we start our REST service by calling
    launch on the `JettyLauncher` we saw previously. We also pass the name of the
    `ScalatraBootstrap` class to the launcher so that the `ScalatraListener` we saw
    earlier can call the ScalatraBootstrap's `init` method when Jetty has finished
    starting up. In the `ScalatraBootstrap` class, we implement the `init` method
    and use that to instantiate our REST service (in this example, it is called `HelloScalatra`)
    and make it available to the outside world by calling mount. For each of the examples
    in this chapter, we'll use this same approach. In the `HelloScalatra` class, we
    finally see our REST service definition. In this case, we define a route which
    returns `Hello from scalatra` when it receives a `GET` request on the `/` path.
    If no route matches, the `notFound` function is triggered which returns a `404`
    message stating `route not found`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left to do is test these two scenarios. From the sources directory,
    run `sbt runCH04-HelloScalatra`. This should show an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can press *Enter* to stop the server or fire up Postman and
    test our service. In Postman, you''ll find a collection of requests for this chapter;
    let''s just test the request (`hello scalatra`), which returns our `Hello from
    scalatra` message so that we know everything is working as it should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your first Scalatra service](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the response from Scalatra is as
    we expected, so our basic Scalatra setup is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Verb and path handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve got our basic Scalatra REST service running, let''s look at
    a more elaborate example, which we''ll use to explore some more features of Scalatra.
    Before we look at the code, let''s make a request from Postman. First, start the
    server by calling `sbt runCH04-runCH04Step1` from the console, which shows something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open up Postman and from the folder, `chapter-04`, select `request Step
    01 – Update Task` and send it to the server. This request will simulate creating
    a new task and will respond by echoing some of the information it has received:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verb and path handling](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding screenshot, our server is up and running,
    and responds with a message containing the updated task. Next, we''ll walk through
    the code of this Scalatra service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in the previous section, we need to call `JettyLauncher` and
    define a `ScalatraBootstrapStep1` class to run our service. The interesting code
    in this example is located in the `ScalatraStep1` class, which defines a number
    of routes that we can call from our REST client.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you look at the routes in this chapter, you'll notice that the more generic
    routes are at the top of the `ScalatraServlet` class. The reason is that Scalatra
    tries to match incoming requests starting from the bottom and from there, it moves
    up. So when defining routes, take care that you place the most generic routes
    at the top and the most specific ones at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ScalatraStep1` class, we define a number of routes. Let''s look at
    a couple of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we see two routes. The `get("/tasks/:id")` matches `GET` HTTP requests
    made on a URL, which looks similar to `/tasks/12`. When the request is made, we
    use the `params` function to get the value of the path segment and try and convert
    it to an integer. If this is successful, we just return a string, and if not,
    we return the HTTP error, `BadRequest`. The `put("tasks/:id")` route matches `PUT`
    HTTP requests and always returns a string, which contains the provided ID using
    the `params` function, and also shows the sent message body that can be accessed
    through the `request.body` value. Besides the `params` function, Scalatra also
    provides a `multiParams` function. With the `multiParams` function, you don't
    get a single string, but a `Seq[String]` instance. This is especially useful if
    you want to access request parameters that have multiple values. For instance,
    if we match on `/task/search?status=new,old`, we can get a `Seq[String]` containing
    new and old by calling `multiParams("status")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides matching directly on a path element, Scalatra also supports a number
    of other ways to match an HTTP request. The following table shows how you can
    match specific HTTP verbs and routes in Scalatra:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Construct | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `get("/")`, `post("/")`, `put("/")`, `delete("/")` and the other HTTP verbs.
    | Scalatra allows you to match a specific HTTP verb. Scalatra supports the following
    HTTP verbs, which you can directly use in your route definition: `options`, `get`,
    `head`, `post`, `put`, `delete`, `trace`, `connect`, and `patch`. |'
  prefs: []
  type: TYPE_TB
- en: '| `get("/full/path")` | The most basic way to match a request on a specific
    path is by specifying the full path to match on. This will only match if the provided
    path matches exactly. In this case, `"/full/path"` will match, while `"/full/path/something"`
    won''t. |'
  prefs: []
  type: TYPE_TB
- en: '| `get("/path/:param")` | As we''ve seen in the examples, you can also extract
    variables from the path by prefixing a path segment with a `:`. This will match
    paths such as `"/path/12"` and `"path/hello"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `get("""^\/tasks\/(.*)""".r)` | You can also use a regular expression to
    match a specific path in Scalatra. To access the groups that match, you can either
    use the `params("splat")` call or through the `multiParams("splat")` function
    call. |'
  prefs: []
  type: TYPE_TB
- en: '| `get("/*/*")` | Scalatra also support the use of wildcards. You can access
    the parameters that match either through the `params("splat")` call or through
    the `multiParams("splat")` function call. |'
  prefs: []
  type: TYPE_TB
- en: '| `get("/tasks", condition1, condition2)` | You can further fine-tune the matching
    by supplying conditions. A condition is a function that returns either `True`
    or `False`. If all conditions return `True`, the route matches, and is executed.
    For example, you can use something similar to `post("/tasks", request.getHeader("headername")
    == "headerValue")`. |'
  prefs: []
  type: TYPE_TB
- en: 'Before we move on to the next section, let''s have a quick look at how you
    can access all the attributes of a request. So far, we''ve seen `params`, `multiParams`,
    and `request.body` to access certain parts. Scalatra also exposes the other parts
    of a request. The following table shows a complete overview of the helper functions
    and request properties exposed by Scalatra (note that you can easily use these
    request properties as conditions in your routes):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `requestPath` | This returns the path against which the route is matched.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `multiParams(key)` | This returns the value of a request parameter (or match
    path segment) as a `Seq[String]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Params(key)` | This returns the value of a request parameter (or match path
    segment) as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.serverProtocol` | This returns an `HttpVersion` object, which is
    either `Http11` or `Http10`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.uri` | This is the URI of the request as a `java.net.URI`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.urlScheme` | This returns a `Scheme` object, either `Http` or `Https`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `request.requestMethod` | This returns an `HttpMethod`, for example, `Get`,
    `Post`, or `Put`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.pathInfo` | This returns the path info from the request or an empty
    string if no pathinfo is available. |'
  prefs: []
  type: TYPE_TB
- en: '| `Request.scriptName` | This returns the servlet path part of the request
    as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `Request.queryString` | This returns the query string of the request or an
    empty string if no query string is present. |'
  prefs: []
  type: TYPE_TB
- en: '| `Request.multiParameters` | This returns a map of all the parameters of this
    request as a `MultiMap`. This contains the parameters from the query string and
    any posted form data. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.headers` | This returns all the headers as a `Map[String, String]`
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.header(key)` | This gets a specific header from the request and
    returns an `Option[String]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.characterEncoding` | This returns, if present, the character encoding
    of the request and an `Option[String]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.contentType` | This gets the content-type of the request if present
    and returns an `Option[String]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.contentLength` | This gets the length of the content and returns
    an `Option[Long]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.serverName` | This returns the server name part of the complete
    path and a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.serverPort` | This returns the port of the server as an integer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `request.referrer` | This tries to get the referrer from the request and
    returns an `Option[String]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.body` | This returns the body of the request as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.isAjax` | This checks whether the request is an AJAX request. It
    does this by checking the presence of an `X-Requested-With` header. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.isWrite` | Checks whether the request is not safe (see RFC 2616).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `request.multiCookie` | This returns a map of all the cookies of this request
    as a `MultiMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.cookies` | This returns all the cookies as a `Map[String, String]`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `request.inputStream` | This gets the `inputStream` of the request, which
    can be used to read the body. Note that this `inputStream` is already consumed
    when you call `request.body`. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.remoteAddress` | This tries to get the clients IP address and returns
    it as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `request.locale` | This returns the `Locale` value from the request. |'
  prefs: []
  type: TYPE_TB
- en: As you can see, Scalatra wraps all the normal request properties and attributes
    you'd expect and makes them easily available either through some helper functions
    or as properties on the available request value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored the basic functionality of Scalatra and seen how we
    can match HTTP verbs and paths, we'll look at some more advanced features in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Add support for futures and simple validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll add support for futures to Scalatra and show a couple
    of first steps to validate incoming requests. To work asynchronously, Scalatra
    needs some additional dependencies. The complete list of dependencies required
    for this examples are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the dependencies, Scalatra uses Akka ([http://akka.io](http://akka.io))
    to handle requests asynchronously. However, you don''t need to know much about
    Akka to get everything up and running. In the following code fragment, we show
    you the basic glue that is required to connect all the moving parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code fragment, we use the JettyLauncher we''ve already seen to start
    the Jetty server and specify the Scalatra bootstrap class that we want to start
    when Jetty is started. In the bootstrap for this example, we take a couple of
    additional steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When this class is instantiated, we create a new Akka, `ActorSystem`, which
    is required by Akka. We pass this system to the constructor of our Scalatra route
    (`ScalatraStep2`) so that we can use it from there. In this bootstrap class, we
    also override the `destroy` function. When the Jetty server is shut down, this
    will neatly close the `ActorSystem` and clean up any open resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the code that handles our routes, we''ll first make some
    calls from Postman to better understand what our routes need to do. So, start
    the server for this part with `sbt runCH04-runCH04Step2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a number of tasks by using the **Step 02 – Create Task** request
    from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Add support for futures and simple validation](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get an overview of all the tasks that have been stored, use the **Step 02
    – Get All Tasks** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Add support for futures and simple validation](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the two screenshots, this time we store the tasks, and
    you can retrieve them through other REST calls. The code for these two routes,
    and a route to delete a task based on an ID, is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s walk through this code fragment and see what is happening. Let''s start
    with the definition of the class that holds the routes and the first statement
    inside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This time, besides extending from `ScalatraServlet`, we also mix in the `FutureSupport`
    trait. When we mix in this trait, we add support for futures to Scalatra. This
    trait also requires us to define an `ExecutionContext` instance. In this example,
    we use the default, `ExecutionContext`, provided by Akka. You can, of course,
    also define and configure one yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `ExecutionContext` is used by programs to execute logic asynchronously and
    for the developer to gain a finer control of threading. You could, for instance,
    execute a piece of code by passing a `Runnable` instance to the `execute` method.
    Scalatra and Akka hide all the details of how the `ExecutionContext` is used,
    but it is up to the developer to specify which `ExecutionContext` to use and how
    it is configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve configured the last part, we can look at running calls asynchronously.
    The first route we''ll look at is the `get("/tasks")` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This route is very simple. It calls the `TaskService.all` function, which returns
    a `Future[List[Task]]` and we transform this to a `Future[String]` through the
    `map` function. Internally, Scalatra will run this request on top of Akka, and
    wait, non-blocking, for the `Future` to finish. Once it is finished, Scalatra
    will return the string to the client. The great thing is that you don''t have
    to do anything yourself. Just return a `Future` object, and Scalatra knows how
    to handle everything since we added `FutureSupport`. In this sample, we just return
    a string inside the `Future`. Scalatra also supports a number of other return
    types you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ActionResult` | An `ActionResult` type is a class where you can set the
    status, body, and headers which are returned. Scalatra comes with a large number
    of standard `ActionResult` you can use—`OK`, `Created`, `Accepted`, and so on.
    For a complete overview, look at the source for the `ActionResult.scala` file.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Array[Byte]` | The content-type of the response (if not set) is set to application/octet-stream,
    and the byte array is returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeSeq` | The content-type of the response (if not set) is set to `text/HTML`
    and the `NodeSeq` instance is converted to a string and is returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `Unit` | If you don''t specify anything, Scalatra assumes you''ve set the
    correct values in the response object yourself. |'
  prefs: []
  type: TYPE_TB
- en: '| `Any` | The content-type of the response (if not set) is set to `text/plain`
    and the `toString` method is called on the object and the result is returned.
    |'
  prefs: []
  type: TYPE_TB
- en: Note that you can override this functionality, or add new functionality, by
    overriding the `renderResponse` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the `delete("/tasks/:id")` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `TaskService.delete` service returns a `Future[Option[Task]]`, which we
    transform to a `Future[String]`, just like we did in the previous code fragment.
    The main difference here is that we don't directly return a `Future`, but wrap
    the block inside an `AsyncResult` object. The reason why we need to do this is
    that we access values from the request. We use `params("id")` to get the value
    from the URL path. If you access any information from the request, you need to
    wrap it in an `AsyncResult` object to avoid timing issues and strange exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with futures or when adding new complex routes, it is often practical
    to add some logging to see what is happening before and after the request has
    been processed. Scalatra supports this through the `before("path")` and `after("path")`
    functions you can define in your class. In this example, we, for instance, log
    every request by specifying a `before(/*)` function and log some additional information
    afterward for the request made to a specific path defined by a regular expression:
    `after(""""^\/tasks\/(.*)"""".r).`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s move on to some simple validations. Look at the following code from
    the `POST` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What you see here is that we can use `getOrElse` on the parameters to check
    whether it is provided, and if not, we can either throw an error or add a default
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we've used a special construct here from Scalatra—`halt`. When this
    function is called, Scalatra will immediately stop processing the request and
    return the specified HTTP response. Besides halt, Scalatra also provides a `pass`
    function which can be used to stop processing inside the current route and instead
    try to see if there are other routes that might match.
  prefs: []
  type: TYPE_NORMAL
- en: This is just some basic simple validation. In the next section, we'll look at
    the more advanced ways of adding validation.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced validation and JSON support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final example, we're going to add JSON support to the service and some
    more advanced validations. To test the examples in this section, run `sbt runCH04-runCH04Step3`.
  prefs: []
  type: TYPE_NORMAL
- en: Add JSON support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by adding JSON support. First off, add the following dependencies
    to the SBT build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding JSON support only takes a couple of simple steps. First, change the
    class definition of our route to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `JacksonJsonSupport` trait added, we next need to add the following
    line to enable automatic JSON parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we only need to inform the routes that we want to work with JSON. For this,
    we use the `before()` function, where we set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can just return our case classes, and Scalatra will automatically
    convert them to JSON. For instance, for the get all tasks service, it looks similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we look at Postman and see the requests, we need to take one final step
    so that we can also store the incoming JSON messages. Let''s look at the `post("/tasks")`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see this in action. Open Postman and, using the **Step 03 – Add Task**
    request, add some tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Add JSON support](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the body we sent is a JSON message describing the task. Retrieving
    the messages works in pretty much the same way. In Postman, you can use the **Step
    03 – Get All Tasks** request for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Add JSON support](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And here, you can see that the tasks you just added are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced validations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve got JSON support added, let''s look at the final part of this
    chapter and explore how you can add more advanced validations to your Scalatra
    routes. The first thing we need to do is add one more dependency to our `sbt`
    build file (`scalatra-commands`). At this point, our dependencies should look
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Through the use of commands, we can add more complex validations to our input
    parameters. For this, we need to change a couple of things in our route. The first
    thing we need to do is add `CommandSupport` to our route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to process incoming requests using commands. Next, we need to
    specify which types of command our service should process. Since we only use a
    single command in this case, we set the `CommandType` to `SearchTaskCommand` (more
    on this file later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look a bit closer at the commands and validations we''ll use in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At the bottom of this object, we define a `SearchTasksCommand` class. This command
    will process the incoming parameters (since we extend from `ParamsOnlyCommand`)
    and check whether the incoming parameters are valid. In this case, we don't validate
    the text parameter, but expect the `status` parameter to validate against the
    `notBlank`, `minLength`, and the custom `validStatus` validators. In this object,
    we also define an implicit conversion between the `SearchTaskCommand` class and
    the `SearchParams` case class, which we can use in our service. This makes the
    code in our route more clean, as we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a custom validator in this object—the `ValidStatusValidations`
    class. This class takes a `FieldDescriptor` as its input and defines a `validStatus`
    function. In the `validStatus` function, we use the `validateWith` function of
    the `FieldDescriptor` to validate the value of the parameter. We can write this
    ourselves or use the `PredicateValidator`, as we did in this example. Once the
    validation is defined, we make it available in our command by defining the `implicit
    def statusValidator` conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalatra comes with a large set of validators out of the box, which you can
    use in the manner explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `notEmpty` | This checks whether the provided field contains a value |'
  prefs: []
  type: TYPE_TB
- en: '| `greaterThan` | This tries to convert value to a number and checks whether
    it is greater than the provided value |'
  prefs: []
  type: TYPE_TB
- en: '| `lessThan` | This tries to convert value to a number and checks whether it
    is less than the provided value |'
  prefs: []
  type: TYPE_TB
- en: '| `greaterThanOrEqualTo` | This tries to convert value to a number and checks
    whether it is greater than or equal to the provided value |'
  prefs: []
  type: TYPE_TB
- en: '| `lessThanOrEqualTo` | This tries to convert value to a number and checks
    whether it is less than or equal to the provided value |'
  prefs: []
  type: TYPE_TB
- en: '| `notBlank` | This removes any spaces and checks whether the provided field
    still contains a value |'
  prefs: []
  type: TYPE_TB
- en: '| `validEmail` | This checks whether the value is a valid e-mail value |'
  prefs: []
  type: TYPE_TB
- en: '| `validAbsoluteUrl` | This checks whether the value is a valid absolute URL
    |'
  prefs: []
  type: TYPE_TB
- en: '| `validUrl` | This checks whether the value is a valid URL |'
  prefs: []
  type: TYPE_TB
- en: '| `validForFormat` | This checks the value against the provided regular expression
    |'
  prefs: []
  type: TYPE_TB
- en: '| `minLength` | This validates whether the value''s length is at least a specific
    amount of characters |'
  prefs: []
  type: TYPE_TB
- en: '| `maxLength` | This validates whether the value''s length is less than a specific
    amount of characters |'
  prefs: []
  type: TYPE_TB
- en: '| `enumValue` | This checks whether the value is one of the provided values
    |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we can finally use the command in our route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax might be a bit rough, but the following steps happen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Command[SearchTasksCommand] >>` means that we execute the command specified
    in the `SearchTasksCommand` class and call the function to the right of `>>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provided function in this case is `TaskServiceWrapper.wrapSearch()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of this service is a `ModelValidation[T]` on which we can call `fold`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our validation returns errors, we halt the call and return the errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our validation returns tasks, we just return those
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we need to return a `ModelValidation[T]` instance, we have created a
    simple wrapper service around the `TaskService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At this point, when we call the `/tasks/search` URL, Scalatra will create the
    command, execute the validations, and if successful, call the `WrapSearch` function
    and return a set of tasks. If errors occur during validations, those will be returned
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily test this with Postman. First, add some tasks through the **Step
    03 – Add Task** request. Now when you call **Step 03 – Search Tasks**, you''ll
    just get a set of valid results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced validations](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If, on the other hand, you call **Step 03 – Search Tasks – Invalid**, you''ll
    see an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced validations](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we saw some of the possibilities Scalatra commands provide
    for validation. You can do much more with commands than shown in this section;
    for more information, refer to the Scalatra commands documentation at [http://www.scalatra.org/2.3/guides/formats/commands.html](http://www.scalatra.org/2.3/guides/formats/commands.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use Scalatra to create a REST service. We
    saw that you need a custom Jetty launcher to run Scalatra standalone since it's
    been created to run inside servlet containers. Once you've got Scalatra running,
    you can just add routes to a class, and they will be automatically picked up when
    you run Scalatra. Remember, though, that routes are matched starting from the
    bottom and going up. Scalatra also provides easy access to all the properties
    of a request and some basic validations through the use of Options. For more advanced
    validations, you can use the `scalatra-commands` module, where you can automatically
    parse incoming parameters and validate against a large set of validators. Finally,
    adding JSON support to Scalatra is very easy. All you have to is add the correct
    modules to your build and import the conversions classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll show you how to use the Spray-based DSL from Akka
    HTTP to create REST services.
  prefs: []
  type: TYPE_NORMAL
