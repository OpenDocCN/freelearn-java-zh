- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Reactive and Spring Cloud Stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A different approach to applications may be necessary in high concurrency scenarios,
    with resource-intensive operations such as **Input/Output** (**I/O**)-bounded
    tasks that require low latency and responsiveness. In this chapter, we’ll learn
    about two Spring Boot projects that address such a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Reactive** is Spring’s response to reactive processing scenarios.
    Reactive processing is a paradigm that allows developers to build **non-blocking**,
    asynchronous applications that can handle **backpressure**. Non-blocking means
    that when an application waits for an external resource to respond, for instance,
    when calling an external web service or database, the application doesn’t block
    the processing thread. Instead, it reuses the processing threads to handle new
    requests. Backpressure is a mechanism for handling situations where a downstream
    component cannot keep up with the rate of data production from an upstream component.
    For these mechanisms, Spring Reactive can be used in high-concurrency scenarios
    with resource-intensive operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring WebFlux** is the reactive web framework equivalent to the Spring **model-view-controller**
    (**MVC**) we used in the previous chapters. To facilitate the transition between
    web frameworks, Spring WebFlux mirrors the names and annotations from the Spring
    MVC.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data **Reactive Relational Database Connectivity** (**R2DBC**) is the
    specification for integrating relational databases using reactive drivers. Compared
    to traditional blocking drivers, it also applies familiar abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud Stream** is a framework for building highly scalable event-driven
    distributed applications connected with shared messaging systems. You can use
    reactive programming with Spring Cloud Stream, but the main goal of Spring Cloud
    Stream is to create loosely coupled distributed applications that can scale independently.
    Rather than trying to optimize the runtime execution as reactive does, Spring
    Cloud Stream provides the foundations for creating distributed applications that
    can work with some asynchronous degree. Spring Reactive and Spring Cloud Stream
    can be combined and complementary in high-concurrency scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this chapter, we’ll explore Spring Reactive by learning
    how to use Spring WebFlux and Spring Data R2DBC with PostgreSQL. In the second
    part, we’ll learn how to use Spring Cloud Stream while using RabbitMQ as the messaging
    service. What you’ll learn can be applied to other messaging services, such as
    Kafka, or other services provided by cloud providers, such as Amazon Kinesis,
    Azure Event Hub, or Google PubSub.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reactive RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a reactive API client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing reactive applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to PostgreSQL using Spring Data R2DBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven applications with Spring Cloud Stream and RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing messages with Spring Cloud Stream and RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling with Spring Cloud Stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll need a PostgreSQL server and a RabbitMQ server. The easiest
    way to run them on your computer is by using Docker. You can get Docker from the
    official site at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
    I will explain how to deploy each tool in its corresponding recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter8).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reactive RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Reactive is the Spring initiative that provides reactive programming
    features and capabilities that can be used in our Spring Boot applications. It
    is designed to support asynchronous and non-blocking programming. But what are
    asynchronous and non-blocking programming? To understand these concepts, it is
    better to start with the traditional model, the non-reactive programming model.
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional model, when a Spring Boot application receives a request, a
    dedicated thread processes that request. If that request requires communicating
    with another service, such as a database, the processing thread is blocked until
    it receives a response from the other service. The number of available threads
    is limited, so if your application requires high concurrency but mostly waits
    for its dependent services to finish, this synchronous blocking model may have
    limitations.
  prefs: []
  type: TYPE_NORMAL
- en: In the reactive model, asynchronous and non-blocking programming reuses the
    threads across the concurrent requests and is not blocked by I/O operations, such
    as network calls or file operations.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is particularly well suited for building applications requiring
    high concurrency and scalability, such as web applications that handle many concurrent
    connections or real-time data processing systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Spring WebFlux to build a RESTful API using reactive
    programming. Spring WebFlux is a module within Spring that enables reactive programming
    for building web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe doesn’t have additional requirements. We will generate the project
    using the **Spring Initializr** tool and, once downloaded, you can make the changes
    with your favorite **Integrated Development Environment** (**IDE**) or editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a RESTful API application. This time, we will
    create it using reactive programming, unlike the recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    as in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), in the *Creating a RESTful
    API* recipe, except changing the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `cards`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring** **Reactive Web**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `cards` project, add a record named `Card`. Define the record as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same folder, add a controller named `CardsController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method named `getCards` that retrieves all cards:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'And add another method to retrieve a card:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In WebFlux, `Flux<T>` is used to return a stream of objects, while `Mono<T>`
    is used to return a single object. In non-reactive programming, they would be
    the equivalents to returning `List<T>` for `Flux<T>` and `T` for `Mono<T>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this controller, `Flux<Card> getCards()` returns multiple objects of the
    `Card` type, and `Mono<Card> getCard` returns just one card.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add an exception class named `SampleException`, implementing a new custom
    exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add two more methods to `CardsController` to demonstrate how to implement
    error handling in WebFlux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getException` method always throws the exception, and `handleSampleException`
    handles exceptions of the `SampleException` type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open a terminal in the root folder of the cards project and execute the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have the RESTful API server running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can test the application by executing a request to `http://locahost:8080/cards`.
    You can use `curl` for this purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also test how error handling works by requesting `http://localhost:8080/exception`.
    You will see that it will return an `HTTP` `400` result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the same annotations as Spring Web to define the controllers in this
    recipe. However, the methods return the `Mono` and `Flux` types instead of traditional
    objects, indicating that the responses will be generated asynchronously. `Mono`
    and `Flux` are the core interfaces of the reactive programming model in WebFlux.
    `Mono` is used for asynchronous operations that produce at most one result, while
    `Flux` is used for asynchronous operations that return zero or more elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive programming is centered around the concept of reactive streams. Reactive
    streams model asynchronous data flows with non-blocking backpressure. I mentioned
    some terms that may sound strange, so let me clarify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-blocking**: This refers to operations related to I/O, such as making
    an HTTP request, that avoid blocking threads. This enables the execution of a
    large number of concurrent requests without a dedicated thread per request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backpressure**: This is a mechanism to ensure that data is only produced
    as fast as it can be consumed, preventing resource exhaustion. For instance, this
    situation may happen when a downstream component cannot keep up with the data
    emitted by an upstream component. WebFlux manages the backpressure automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the annotation-based programming model used in this recipe,
    WebFlux also supports the `cards` RESTful API with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a class handling the logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And another one to configure the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Annotation-based programming** is more like a traditional non-reactive programming
    model, while functional programming can be more expressive, especially for complex
    routing scenarios. The functional style is better suited for handling high concurrency
    and non-blocking scenarios because it naturally integrates with reactive programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Using annotation-based or functional is a matter of personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Using a reactive API client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a RESTful API, now it’s time to use it in a non-blocking fashion. We’ll
    create a reactive RESTful API that calls another RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll create a reactive application that consumes an API. We’ll
    learn how to use the reactive WebClient to perform requests to the target RESTful
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll consume the application created in the *Creating a reactive
    RESTful API* recipe. If you haven’t completed it yet, I prepared a working version
    that you can use as a starting point for this recipe. You can find it on the book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-2/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the target project and keep it for the rest of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll create an efficient consumer application for our RESTful API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create a new application using the Spring Boot Initializr tool.
    You can use the same options as in the *Creating a RESTful API* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), except changing the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `consumer`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring** **Reactive Web**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we run the consumer application alongside the `cards` application, we’ll
    need to change the port where the application listens for requests. We’ll set
    `8090` as the server port. We will also create a configuration for the target
    football service URL. For that, open the `application.yml` file in the `resources`
    folder and set the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a record named `Card` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll create a controller class named `ConsumerController` that will
    consume the target RESTful API. So, this controller will need a WebClient. For
    that, set the `ConsumerController` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The controller now has a WebClient that allows us to perform requests in a non-blocking
    fashion in our client application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a method to consume the operation from the other application that returns
    a stream of `Card` instances. For that, in `ConsumerController`, add the following
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a method to consume the method returning a single object by adding the
    following method to the `ConsumerController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a method that manages different response codes from the remote
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run the consumer application now. When we perform requests to the client
    application, it will call the server RESTful API server application. Remember
    that we have the server RESTFul API server already running, as explained in the
    *Getting ready* section. Open a terminal in the root folder of the `consumer`
    project and execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, test the `consumer` application. Remember that it listens on port `8090`,
    and the server application listens on port `8080`. In the terminal, execute the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will return `Remote Server return 404`. The `consumer` application tried
    to call a method that does not exist in the server RESTful API server application.
    The consumer application handles the HTTP response codes from the server, in this
    case, `HttpStatus.NOT_FOUND` to return the final response message, which is `Remote
    Server` `return 404`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we consumed a RESTful API that is implemented using reactive
    technologies, but from the consumer’s point of view, it doesn’t matter. We can
    consume any RESTful API, regardless of the internal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: What’s important is that as we take advantage of a non-blocking client, the
    consumer application will benefit if it’s also reactive. When we request against
    the consumer application, it will perform another request to the `cards` application.
    As we use a reactive client in the `consumer` application, it won’t block a thread
    while the `cards` application responds, making that thread available to process
    other requests. This way, the application can manage higher concurrency than traditional
    blocking threads applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing reactive applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with non-reactive Spring Boot applications, we want to automate the testing
    of our reactive applications, and Spring Boot provides excellent support for testing
    such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to create the tests using the components provided
    by default by Spring Boot when we add the **Spring Reactive** **Web** starter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create the tests for the projects used in the *Using a
    reactive API client* recipe. If you haven’t completed that recipe yet, you can
    use the completed version that I prepared as a starting point for this recipe.
    You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-3/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We like robust and reliable applications. We’ll do it with our Reactive applications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the applications from the *Using a reactive API client* recipe were created
    with the Spring Boot Initializr tool, just by adding Spring Reactive Web starter
    the testing dependencies are already included. You can check that the `pom.xml`
    file contains the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll start the tests with the `cards` application. Create a new test
    class named `CardsControllerTest`. Remember, it should be created under the `test`
    folder; you can create it in the `src/test/java/com/packt/cards` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The test class should be annotated with `@WebFluxTest`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll inject a `WebTestClient` field. For that, annotate the new field
    with `@Autowired`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the `webTestClient` field to emulate the calls to the reactive
    RESTful API. For instance, let’s create a test for the `/cards` path that returns
    a list of type `Card`. For that, create a new method annotated with `@Test`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s test the `/cards/exception` path. For learning purposes, this path always
    returns `a 404 code`, a bad request result; and the body is of type `ProblemDetail`.
    The test method may look as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create the tests for the `consumer` application. As we want to
    test this application independently of the `cards` application, we’ll need to
    mock the `cards` application server. As we learned in the *Mocking a RESTful API*
    recipe, in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), we’ll use the WireMock
    library. For that, open the `pom.xml` file of the project `consumer` and add the
    following dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have all the dependencies, we’ll create a new test class named
    `ConsumerControllerTest` and prepare it before writing the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, annotate the class with `@SpringBootTest` and set a few configuration
    options as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we set a new class in the `classes` field that doesn’t exist yet,
    `ConsumerControllerTests.Config`. It’s used to configure the MockServer, as you’ll
    see soon.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we’ll need to set up the WireMock server. For that, we’ll create a configuration
    subclass class named `Config`; it will define a `WireMockServer` bean:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to configure the URI of the new remote server for the reactive
    WebClient. We need to set the `footballservice.url` application context variable.
    To perform this dynamic configuration, we’ll use the `@DynamicPropertySource`
    annotation. For that, define a static method in the `ConsumerControllerTests`
    class:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the test preparation, we’ll inject `WebTestClient` and `WireMockServer`,
    which we’ll use in the tests. For that, define the fields with the `@``Autowired`
    annotation:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can write the tests now. For instance, we’ll create a test to get the cards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can name it `getCards`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we’ll arrange what the mocked cards server will return. For that, we’ll
    mock a small set of results for learning purposes:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can perform the request using `webTestClient` and validate the results:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can write tests for the rest of the application’s features. I created some
    sample tests, which you can find in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-3/end` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `@WebFluxTest` annotation, we can define test classes focusing only
    on WebFlux-related components. This means that it will disable the configuration
    of all components save for those relevant to WebFlux. For instance, it will configure
    the classes annotated with `@Controller` or `@RestController`, but it won’t configure
    classes annotated with `@Service`. With that, Spring Boot can inject `WebTestClient`,
    which we can use to perform requests to our application server.
  prefs: []
  type: TYPE_NORMAL
- en: In the consumer application, we need to mock the `cards` service. I won’t go
    deeply into the details, as the mechanism is the same as explained in the *Mocking
    a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020). We used
    a configuration subclass annotated with `@TestConfiguration`. This annotation
    allows the configuration of beans that can be used alongside the tests. In our
    case, we just needed `WireMockServer`. Then, we dynamically configured the URI
    of the mocked server using the `@``DynamicPropertySource` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To reference the `Config` class, we used `ConsumerControllerTests.Config` instead
    of just `Config`. The reason for this is that it’s a subclass of the `ConsumerControllerTests`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `webEnvironment` field, assigning `SpringBootTest.WebEnvironment.RANDOM_PORT`.
    This means that the test will host the application as a service on a random port.
    We used that to avoid port collisions with the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to PostgreSQL using Spring Data R2DBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a Reactive database driver makes sense as we need to connect our Reactive
    application to PostgreSQL. This means the application is not blocked when it makes
    requests to the database. There is a Java specification to integrate SQL databases
    using reactive drivers named **R2DBC**. Spring Framework supports R2DBC with Spring
    Data R2DBC, which is part of the larger Spring Data family.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data R2DBC applies familiar Spring abstractions for R2DBC. You may use
    `R2dbcEntityTemplate`, running statements using the Criteria API and Reactive
    Repositories, among other features.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to connect to PostgreSQL using Reactive Repositories
    and some of the differences between Reactive and non-reactive Repositories. We’ll
    also learn how to configure Flyway for database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we’ll need a PostgreSQL database. You can use the instructions
    from the *Getting ready* section of the *Connecting your application to PostgreSQL*
    recipe, in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203). Once you have Docker
    installed, as explained in the aforementioned recipe, you can execute the following
    command to run a PostgreSQL server on Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I also prepared a starting project for this recipe that contains the classes
    that we’ll use as data entities to map with the database tables and the database
    initialization scripts that we’ll use in the *There’s more* section for the Flyway
    migration. You can find the project in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-4/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll configure an application to connect to use PostgreSQL. Let’s go Reactive:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll ensure we have all the required dependencies. For that, open the
    project’s `pom.xml` file and add the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`org.springframework.boot:spring-boot-starter-webflux`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.boot:spring-boot-starter-test`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.projectreactor:reactor-test`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.boot:spring-boot-starter-data-r2dbc`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.postgresql:r2dbc-postgresql`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we’ll configure the connection to the database using the R2DBC driver.
    For that, open the `application.yml` file and add the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the database URL doesn’t start with `jdbc:` but with `r2dbc:`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we’ll configure the entity classes we want to map to the database. These
    classes are in the `repo` folder. To prepare the classes, follow these steps for
    each of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `@Table` annotation to the class. You can set the name as it’s defined
    on the database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `@Id` annotation to the identifier field. I named this field `Id` in
    all entity classes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the `CardEntity` class as an example here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can create the repositories for our entities. For instance, for the `CardEntity`,
    we’ll create the `CardsRepository` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can do the same for the rest of the entities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll add a method to `PlayersRepository` to find a player by their name. For
    that, just add the following method definition to the `PlayersRepository` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a new service to manage players. You can name it `PlayersService`,
    and as it uses `PlayersRepository`, we’ll add it as a parameter to the constructor,
    and we’ll let Spring Boot do its magic to inject it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create a couple of methods using the repository. For instance, one
    method to get a player by the ID, and another one to get the player by the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that both methods use a class named `PlayerMapper`. I provided this class
    as part of the starting project to create the mappings between the entities and
    the objects returned by the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s make something more complex now. We’ll retrieve a card and its related
    data, that is, `Album`, if it is already assigned, and `Player` in the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create a new service class named `CardsService`. This service requires
    `CardsRepository`, `PlayersRepository`, and `AlbumsRepository`. We’ll create a
    constructor with an argument of each type:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a method to get an item of type `Card`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see in the `getCard` method, there is a reference to `retrieveRelations`.
    The `retrieveRelations` method retrieves `Player` from the database and `Album`
    in case it’s defined. Of course, we’ll do all this using a reactive approach:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can implement the Reactive RESTful endpoints to expose this functionality,
    as explained in the *Creating a Reactive RESTful API* recipe in this chapter.
    I prepared some examples that you can find in the book’s GitHub repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)
    in the `chapter8/recipe8-4/end` folder. I recommend you check out the *There’s
    more* section, as it includes Flyway to initialize the database and some tests
    using `Testcontainers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apparently, the Reactive entities and `ReactiveCrudRepository` are very similar
    to their non-reactive counterparts. `ReactiveCrudRepository` provides the same
    base methods with basic functionality such as `findById` and `save`, but there
    are important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive repositories don’t manage relations between entities. For that
    reason, we haven’t defined any `@OneToMany` or `@ManyToOne` fields. The relations
    between entities should be managed explicitly in our application, as we did in
    the `getCard` and `retrieveRelations` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reactive repositories allow you to define methods following the same naming
    convention as the non-reactive repositories but returning `Mono` for single results
    and `Flux` for multiple results. These methods are transformed into queries in
    the database. You can find more details about the naming convention on the R2DBC
    web page at [https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html](https://docs.spring.io/spring-data/relational/reference/r2dbc/query-methods.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We haven’t used it in this recipe, but it’s possible to use the `@Query` annotation
    and provide an SQL query. It is a native query; JPQL is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reactive programming model leverages the request’s asynchronous and non-blocking
    process. Note that in the `getCard` method, the album and the player are retrieved
    asynchronously and simultaneously when the card is found. Parallelism is achieved
    using the `Mono.zip` method, which allows several non-blocking processes to be
    executed simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flyway is not directly supported with R2DBC drivers, but it can be used with
    some adjustments. Let’s see how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must add the Flyway dependency in your `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we want to validate the database migration automatically, we’ll also include
    the `Testcontainers` support. For `Testcontainers`, there are no specific reactive
    adjustments to make.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll need to configure the connection for Flyway explicitly. The reason
    for this is that Flyway only supports the JDBC driver; for that reason, we’ll
    need to specify the `jdbc:` version of the database URL. This configuration can
    be applied in the `application.yml` file. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can set this configuration in a test supporting `Testcontainers`. Let’s
    see what the class to test the `PlayersService` may look like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the context configuration gets the database configuration from the
    PostgreSQL test container. As `PostgreSQLContainer` only returns the JDBC version
    of the URL, we replaced the `jdbc:` string with `r2dbc:` for the R2DBC driver,
    while keeping the JDBC URL version for Flyway.
  prefs: []
  type: TYPE_NORMAL
- en: The rest is just standard Flyway configuration. The sample project provides
    the database initialization scripts in the default folder at `resources/db/migration`.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven applications with Spring Cloud Stream and RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to enhance the experience of our football application by using facts
    from a match, such as a goal or a red card. We can use the information to prepare
    a timeline with all events happening during the match or update the match score.
    We foresee that in the future, we can use this information for other features,
    such as preparing player statistics in real time or creating a player’s ranking
    using the statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this scenario, we can apply an **event-driven architecture** design. This
    type of design consists of detecting, processing, and reacting to real-time events
    as they happen. Usually, there are two types of components: the event producers
    and the event consumers, and they are loosely coupled. Spring Cloud Stream is
    the Spring project that supports event-driven applications that communicate using
    a shared messaging system, such as Kafka or RabbitMQ.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to use Spring Cloud Stream to create one application
    that emits football match events and one that is subscribed to those events. We’ll
    also learn how to configure the applications to use RabbitMQ as the messaging
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll use RabbitMQ. You can install it on your computer by
    following the instructions of the official website at [https://www.rabbitmq.com/docs/download](https://www.rabbitmq.com/docs/download).
    I recommend running it on Docker locally. With the following command in your terminal,
    you can download and run RabbitMQ on Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The image used includes the management portal. You can access it at `http://localhost:15672`
    using `packt` as username and password.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll create two applications and we’ll connect them using RabbitMQ. We’ll
    use the power of Spring Cloud Stream to make it possible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by creating two applications using the Spring Boot Initializr tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`matches`: This application will produce the match events and will publish
    them on RabbitMQ'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeline`: This application will process all events published to create a
    match timeline'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For that, repeat this step for each application. Open [https://start.spring.io](https://start.spring.io)
    in your browser and use the same options as in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    in *Creating a RESTful API*, save for the following options:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For `matches` or `timeline`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, don’t select any starter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll add the following dependency to the three applications:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step will be configuring the `matches` application to emit events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we’ll define a record that will be used to represent the match events:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can create a nested builder class to facilitate the manipulation. I’m not
    including the builder code in this sample for brevity, but you can find an implementation
    on the book’s GitHub repository.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we’ll define a bean in the `MatchesApplication` class that configures
    `Supplier<Message<MatchEvent>>`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This bean generates the `MatchEvent` messages with a random value assigned to
    the `type` field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we’ll configure the application to use RabbitMQ. We’ll bind the bean
    we just created to a RabbitMQ exchange named `match-events-topic` and configure
    the binding to map the *routing key* message property to the `eventType` message
    header. For that, open the `application.yml` file and set the following configuration:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check that the `spring.rabbitmq` properties are aligned with the parameters
    used to start the RabbitMQ container in the *Getting ready* section. Verify that
    the binding name matches the method that exposes the bean.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the `matches` application is ready to start producing events. You can start
    it now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll configure the `timeline` application. This application will consume
    all events produced by the `matches` application. For that, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, create a `Consumer<MatchEvent>` bean. Open the `TimelineApplication`
    class and add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the sake of clarity, we haven’t created a library with shared code across
    the three applications. Therefore, you will need to define the `MatchEvent` record
    in this project, too.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this project, we only need to configure the RabbitMQ configuration to bind
    an input queue named `timeline` to the `match-events-topic` exchange created in
    *Step 2* and the `processMatchEvent` function to the input queue. That can be
    done by configuring the `application.yml` file as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The timeline application is now ready to process messages. Just run the application,
    and it will start processing messages. You will see the messages when the events
    are processed in the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `spring-cloud-stream-binder-rabbit` dependency includes the Spring Cloud
    Stream starter, with specific bindings for RabbitMQ. The Spring Cloud Stream starter
    provides the necessary abstractions to create event-driven applications with no
    specific references to the underlying messaging technology. In our application,
    we haven’t used any explicit RabbitMQ component in the code. For that reason,
    we could switch to another messaging system, such as Kafka, just by changing the
    dependencies and the configuration, but with no code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Stream allows binding a `Supplier` function registered as a bean
    to a given destination, in our case, `match-events-topic`. That means that the
    messages produced by the `Supplier` function are sent to that destination. We
    use `spring-cloud-stream-binder-rabbit`, which includes the bindings to RabbitMQ.
    When we start the `matches` application, RabbitMQ creates an **exchange**. An
    exchange is an intermediary component between the producer and the consumer applications.
    Producer applications never send messages directly to consumers. Then, depending
    on the type of exchange, the messages are sent to one or multiple queues or discarded.
    When we started the matches application and the timeline application was not running
    yet, the exchange was created in RabbitMQ, but as there were no subscribers, the
    messages were discarded. In the **RabbitMQ** portal, you would see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: match-events-topic in RabbitMQ](img/B21646_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: match-events-topic in RabbitMQ'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the application calls the `Supplier` function once every second,
    which is the default configuration in Spring Cloud Stream. Still, the messages
    are discarded as it’s not defined yet how to route the messages. Indeed, if you
    check the **Queues and Streams** tab, you will see that there are no queues defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `timeline` application, we configured the binding between the `match-event-topic`
    exchange and the destination queue where the messages are forwarded. It’s defined
    in the `spring.cloud.stream.binding.input` properties. We specified `match-events-topic`
    with the `destination` property, and we defined the target queue with the `group`
    property. Then, with the `spring.cloud.stream.function.bindings` properties, we
    defined the link between that queue and the function registered as a bean to process
    the messages. After starting the `timeline` application, you will see that `match-events-topic`
    has a binding that connects the `match-events-topic` exchange to a queue named
    `match-events-topic.timeline`. You can check that in RabbitMQ. It should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Timeline queue bound to match-events-topic](img/B21646_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Timeline queue bound to match-events-topic'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the RabbitMQ portal, Spring Cloud Stream created the exchange
    and the queue and configured the binding to route all messages to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used the functional approach to send messages, letting the
    Spring Stream Cloud invoke the `Supplier` function to generate messages. In many
    scenarios, we must decide when to send messages more explicitly. For this purpose,
    you can use the `StreamBridge` component. This component lets you send messages
    while only specifying the binding to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. You can create a service component that receives a `StreamBridge`
    in the constructor, then Spring Boot will inject an instance in runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use `StreamBridge` to send the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RabbitMQ provides different types of exchanges, depending on how the messages
    are routed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct**: The messages are forwarded to a queue based on a routing key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fanout**: The messages are forwarded to all bounded queues, regardless of
    the routing key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topic**: The messages are routed to the bounded queues depending on a pattern
    defined in the exchange and the routing keys defined in the queues. This is the
    default type. In the next recipe, we’ll explore this scenario further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Headers**: This is similar to the topic exchange, but RabbitMQ routes messages
    using the message headers instead of the routing key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing messages with Spring Cloud Stream and RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We decided to utilize the match events generated in the previous recipe to update
    the football match score. We’ll create a new application that subscribes to the
    goal events to implement this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to configure our Spring Cloud Stream producer
    application to set the routing key based on the message headers. Then, we’ll learn
    how to configure the consumer applications to set up the queue bindings based
    on pattern matches for the routing key.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe starts with the outcome of the *Event-driven applications with Spring
    Cloud Stream and RabbitMQ* recipe. I prepared a working version in case you haven’t
    yet completed that recipe. You can find it in the book’s GitHub repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-6/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: As in the *Event-driven applications with Spring Cloud Stream and RabbitMQ*
    recipe, you will need a RabbitMQ server. To set up the RabbitMQ service on your
    computer, follow the instructions in the *Getting ready* section of that recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s make the few necessary adjustments to the producer application, and then
    we’ll use Spring Cloud Stream’s powerful capabilities to set up all RabbitMQ bindings
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll modify the `matches` producer application to include some headers
    in the messages. For that, open the `MatchesApplication` class and modify the
    `matchEvents` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the method’s signature; instead of returning `MatchEvent`, we’ll return
    `Message<MatchEvent>`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll use `MessageBuilder` to create the returning `Message<MatchEvent>`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll include a new header named `eventType`. We’ll assume that events with
    the `type` field equal to `2` are goals.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll change the `matches` application’s configuration to assign the
    `eventType` header’s value to the routing key. For that, we’ll configure the rabbit
    producer binding with the `routing-key-expression` property in the `application.yml`
    file. The Spring Cloud configuration should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a bean that returns `Consumer<MatchEvent>`. You can define it
    in the `ScoreApplication` class. This function will process the events received.
    It could look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, configure the bindings to the `match-event-topic` exchange. In this application,
    we’ll set the binding route key using pattern matching. As we defined in *Steps
    1* and *2*, the goals will have the `football.goal` value. So, the configuration
    will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can run the `score` application. You should check that it only receives
    the goal events. If you run the `timeline` application we created in the *Event-driven
    applications with Spring Cloud Stream and RabbitMQ* recipe, you will see that
    it receives all events, including the goals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the Spring Cloud Stream doesn’t automatically remove the bindings
    when you stop the application. For that reason, you may need to manually remove
    the bindings, exchanges, or queues of previous executions. You can do that from
    the RabbitMQ portal.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key concept in this recipe is the **routing key**, which is an attribute
    added by the producer to the message header. The exchange can then use the routing
    key to decide how to route the message. On the consumer side, it’s possible to
    define a binding to link a queue with an exchange based on the routing keys.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the `routing-key-expression` to set the routing key
    based on the message’s properties, such as `header` or `payload`. The Spring RabbitMQ
    binder allows the use of **Spring Expression Language** (**SpEL**) to define the
    message’s routing key. The binder evaluates the expression and sets the value
    of the routing key.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the messages generated in RabbitMQ, you will see the values of
    **Routing Key** and **headers**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Message in RabbitMQ showing the routing key](img/B21646_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Message in RabbitMQ showing the routing key'
  prefs: []
  type: TYPE_NORMAL
- en: On the consumer side, it’s possible to use pattern-matching values when binding
    the queue to the exchange. The messages whose routing key matches the given pattern
    will be forwarded to the corresponding queue. If you look at the bindings of `match-events-topic`
    in the RabbitMQ portal, you will see that two queues are bound, each using a different
    routing key.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Queues bound with different routing keys](img/B21646_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Queues bound with different routing keys'
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration, RabbitMQ will send to the `match-events-topic.score`
    queue only the messages that match the `football.goal.#` routing key. That is,
    all messages whose routing key starts with `football.goal`. It will send to the
    `match-events-topic.timeline` queue all messages, as the `#` symbol acts as a
    wildcard.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find more information about SpEL on the project page at [https://docs.spring.io/spring-framework/reference/core/expressions.html](https://docs.spring.io/spring-framework/reference/core/expressions.html).
    It supports querying and manipulating an object graph at runtime, and all Spring
    projects widely use it.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling with Spring Cloud Stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The score application we developed in the previous recipe has become critical
    for football matches as it manages the final match score. For that reason, we
    need to ensure the solution’s robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Stream can implement highly available, loosely coupled, resilient
    systems. The reason is that the underlying messaging systems, such as RabbitMQ,
    provide different mechanisms to ensure the message is delivered to the intended
    destination. First, the messages can be queued before they are delivered. If,
    for any reason, the consumer application is not ready yet or has a transient failure,
    it will process the queued messages once it’s ready again. You can use the same
    mechanism to increase the number of consumers to increase the throughput of your
    system. You can also configure a retry policy in case of a transient failure in
    your application or forward it to a special queue, which is named a **dead-letter
    queue** (**DLQ**). The DLQ is a common mechanism in messaging systems; the DLQ
    can receive all messages that cannot be processed normally for whatever reason;
    the main purpose is to provide the capability to keep messages that cannot be
    processed, not only due to technical transient errors but those related to software
    issues as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to configure a DLQ and retry policies for our
    application, and we’ll see how the application behaves in case of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the *Routing messages with Spring Cloud Stream and RabbitMQ*
    recipe outcomes as the starting point. If you haven’t completed it yet, you can
    use the version I prepared, which can be found in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter8/recipe8-7/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: As in the *Event-driven applications with Spring Cloud Stream and RabbitMQ*
    recipe, you will need a RabbitMQ server. To set up the RabbitMQ service on your
    computer, follow the instructions in the *Getting ready* section of that recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we configure the application for error handling, we’ll simulate some
    transient errors in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our score application to introduce random errors when message
    processing. We’ll simulate an error happening 80% of the time. For that, open
    the `processGoals` method of the `ScoreApplication` class and replace the code
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll configure the application to automatically create a DLQ. To do that,
    open the `score` application’s `application.yml` and set the `autoBindDlq` property
    in the `spring.cloud.string.rabbit.bindings.input.consumer` section to `true`.
    It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.5: DLQ](img/B21646_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: DLQ'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ll configure the retry policy. For instance, we can configure three
    attempts before a message is routed to the DLQ and one second as the maximum time
    to process a message, which is its `spring.cloud.string.rabbit.bindings.input.consumer.maxAttempts`
    = `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spring.cloud.string.rabbit.bindings.input.consumer.ttl` = `1000`. This property
    is expressed in milliseconds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can run the application now. If you keep it running for a while, you will
    see some errors in the score application, and some messages will reach the DLQ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6: DLQ messages](img/B21646_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: DLQ messages'
  prefs: []
  type: TYPE_NORMAL
- en: You can also stop and restart the `score` application. In the RabbitMQ portal,
    you can verify that the messages are queued in the `match-events-topic.score`
    queue and that once the application is ready again, it will process all pending
    messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a queue is bound to an exchange, a new message is forwarded to the queue
    every time there’s a new message in the exchange. The message lasts in the queue
    until it’s processed or the TTL expires. The consumer application, in our case,
    the `score` application, tries to read and process; if, for any reason, it fails
    before completing the process, the message returns to the queue. This process
    can be executed with the number of attempts configured, in our case, three attempts.
    Finally, if the message cannot be processed or the TTL expires, then the message
    is forwarded to the DLQ.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we configured an 80% failure rate for demonstration purposes.
    If we reduce the failure rate, fewer messages will reach the DLQ.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is more resilient because once the message is queued, we can ensure
    that it will be processed, regardless of the availability of the `score` application.
    The `score` application may be unavailable for a given time for many reasons,
    including a transient error and planned maintenance. For features like these,
    this kind of solution is so popular in microservices architectures and cloud solutions.
    The assumption is that the messaging service is highly available, for instance,
    by deploying a cluster with redundant servers or just by using the **platform
    as a service** (**PaaS**) provided by cloud providers. On the Spring Cloud Stream
    page at [https://spring.io/projects/spring-cloud-stream](https://spring.io/projects/spring-cloud-stream),
    you can find the compatible binders; some are maintained directly by the Spring
    Cloud Team, while partners maintain others.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can configure more than one consumer application. If one consumer instance
    cannot process one message, another instance can process it. With this approach,
    scaling out the application by adding more consumers is possible. This design
    is known as **Competing Consumers**. You can find a good description of this scenario
    in the Azure Architecture Center at [https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers](https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers).
    The implementation suggests Azure products, but you can apply the same principles
    with other technologies, such as RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other design patterns rely on queue systems that are worth having in our toolbox.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous Request-Reply**: In this pattern, you may need to respond quickly
    to client applications, such as web browsers. However, operations may take much
    longer to respond. To solve this situation, the application saves the request
    in a queue and processes it asynchronously. The application exposes an endpoint
    to get the request status; then, the clients can periodically check the request
    status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue-Based Load Leveling**. Some applications may rely on a backend with
    limited capacity, but load spikes can occur. In those scenarios with unpredictable
    demand, the queue acts as a buffer, and the consumer application processes the
    requests at a pace that doesn’t overflow the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Upgrading to Spring Boot 3 from Previous Versions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time invested in an application over its lifetime is related to
    maintenance. A successful application may last for years or decades. During this
    time, it may require upgrades for its evolution. You probably have an application
    that you want to evolve and take advantage of the Spring Boot 3 features. In this
    part, we’ll learn how to upgrade an existing application from Spring Boot 2 to
    Spring Boot 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21646_09.xhtml#_idTextAnchor407)*,* *Upgrading from Spring Boot
    2.x to Spring Boot 3.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
