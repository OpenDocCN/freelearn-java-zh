<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer123">
<h1 class="chapter-number" id="_idParaDest-315"><a id="_idTextAnchor479"/>15</h1>
<h1 id="_idParaDest-316"><a id="_idTextAnchor480"/>Additional Spring Security Features</h1>
<p>In this chapter, we will explore several additional <strong class="source-inline">Spring Security</strong> features that we have not covered so far in this book, including the <span class="No-Break">following topics:</span></p>
<ul>
<li><strong class="bold">Cross-Site </strong><span class="No-Break"><strong class="bold">Scripting</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">XSS</strong></span><span class="No-Break">)</span></li>
<li><strong class="bold">Cross-Site Request </strong><span class="No-Break"><strong class="bold">Forgery</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CSRF</strong></span><span class="No-Break">)</span></li>
<li>Synchronizer <span class="No-Break">token pattern</span></li>
<li><span class="No-Break">Clickjacking</span></li>
<li>Testing Spring <span class="No-Break">Security Applications</span></li>
<li>Reactive <span class="No-Break">Applications support</span></li>
</ul>
<p>We will understand how to include various HTTP headers to protect against common security vulnerabilities, using the <span class="No-Break">following methods:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">Cache-Control</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Content-Type Options</strong></span></li>
<li><strong class="source-inline">HTTP Strict Transport </strong><span class="No-Break"><strong class="source-inline">Security (HSTS)</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">X-Frame-Options</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">X-XSS-Protection</strong></span></li>
</ul>
<p>Before you read this chapter, you should already understand how <strong class="source-inline">Spring Security</strong> works. This means you should already be able to set up authentication and authorization in a simple web application. If you are unable to do this, you will want to ensure you have read up to <a href="B21757_03.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Custom Authentication</em>, before proceeding with <span class="No-Break">this chapter.</span></p>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/aXvKi"><span class="No-Break">https://packt.link/aXvKi</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-317"><a id="_idTextAnchor481"/>Security vulnerabilities</h1>
<p>In the age of the <a id="_idIndexMarker1008"/>internet, there is a multitude of possible vulnerabilities that can be exploited. A great resource to learn more about web-based vulnerabilities is the <strong class="bold">Open Web Application Security Project</strong> (<strong class="bold">OWASP</strong>), which<a id="_idIndexMarker1009"/> is located <span class="No-Break">at </span><a href="https://owasp.org"><span class="No-Break">https://owasp.org</span></a><span class="No-Break">.</span></p>
<p>In addition to being a great resource to understand various vulnerabilities, OWAS<a id="_idTextAnchor482"/>P categorizes the top 10 vulnerabilities based on <span class="No-Break">industry trends.</span></p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor483"/>Cross-Site Scripting</h1>
<p><strong class="bold">Cross-site scripting</strong> or <strong class="bold">XSS</strong> attacks <a id="_idIndexMarker1010"/>involve malicious scripts that have been injected into a <span class="No-Break">trusted site.</span></p>
<p>XSS attacks occur when an attacker exploits a given web application that allows unventilated input to be sent to the site, generally in the form of browser-based scripts, which are then executed by a different user of <span class="No-Break">the website.</span></p>
<p>There are many forms that attackers can exploit, based on validated or unencoded information provided <span class="No-Break">to websites.</span></p>
<p>XSS can be described by the following <span class="No-Break">sequence diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<img alt="Figure 15.1 – Cross-Site Scripting (XSS)" height="515" src="image/B21757_15_1.jpg" width="1113"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – Cross-Site Scripting (XSS)</p>
<p>At the core of this issue is expecting<a id="_idIndexMarker1011"/> a user to trust the site’s information that is being sent. The end user’s browser has no way of knowing that the script should not be trusted because there is implicit trust in the website they’re browsing. Because the end user thinks the script came from a trusted source, the malicious script can access any cookies, session tokens, or other sensitive information retained by the browser and used with <span class="No-Break">that website.</span></p>
<h1 id="_idParaDest-319"><a id="_idTextAnchor484"/>Cross-Site Request Forgery</h1>
<p><strong class="bold">Cross-site request forgery</strong> (<strong class="bold">CSRF</strong>) is an <a id="_idIndexMarker1012"/>attack that tricks the victim into submitting a malicious request. This type of attack inherits or hijacks the identity and privileges of the victim and performs unauthorized functions and gains access on the <span class="No-Break">victim’s behalf.</span></p>
<p>For web applications, most browsers automatically include credentials associated with the site, which includes a user session, cookie, IP address, Windows domain credentials, and <span class="No-Break">so forth.</span></p>
<p>So, if a user is currently authenticated on a site, that given site will have no way to distinguish between the forged request sent by the victim and a <span class="No-Break">legitimate request.</span></p>
<p>CSRF attacks target functionality that causes a state change on the server, such as changing the victim’s email address or password, or engaging in a <span class="No-Break">financial transaction.</span></p>
<p>This forces the victim to retrieve data that doesn’t benefit an attacker because the attacker does not receive the response; the victim does. Thus, CSRF attacks target <span class="No-Break">state-changing requests.</span></p>
<p>The following sequence diagram details how a <a id="_idIndexMarker1013"/>CSRF attack <span class="No-Break">would occur:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer121">
<img alt="Figure 15.2 – CSRF" height="828" src="image/B21757_15_2.jpg" width="1518"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – CSRF</p>
<p>There are several different design measures that may be taken to attempt to prevent CSRF; however, measures such as secret cookies, <strong class="source-inline">HTTP POST</strong> requests, multistep transactions, URL rewriting, and <strong class="source-inline">HTTPS</strong> in no way prevent this type <span class="No-Break">of attack.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">OWASP’s top 10 security vulnerabilities list details CSRF as the eighth most common attack <span class="No-Break">at </span><a href="https://owasp.org/www-community/attacks/csrf"><span class="No-Break">https://owasp.org/www-community/attacks/csrf</span></a><span class="No-Break">.</span></p>
<p>In summary, CSRF is the<a id="_idIndexMarker1014"/> general concept of an attack where a user is tricked into performing unintended actions. In the next section, we will explore the <strong class="source-inline">Synchronizer Tokens pattern</strong>, which is a specific method used to mitigate CSRF attacks by using unique tokens associated with each <span class="No-Break">user session.</span></p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor485"/>Synchronizer token pattern</h2>
<p>A solution to CSRF is to use<a id="_idIndexMarker1015"/> the <strong class="bold">synchronizer token</strong> pattern. This solution<a id="_idIndexMarker1016"/> ensures that each request requires, in addition to our session cookie, a randomly generated token as an HTTP parameter. When a request is submitted, the server must look up the expected value for the parameter and compare it to the actual value in the request. If the values do not match, the request <span class="No-Break">should fail.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The <em class="italic">Cross-Site Request Forgery Prevention Cheat Sheet</em> recommends the <strong class="source-inline">synchronizer token</strong> pattern as a viable solution for CSRF <span class="No-Break">attacks: </span><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern"><span class="No-Break">https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern</span></a><span class="No-Break">.</span></p>
<p>Let’s look at how our example would change. Assume the randomly generated token is present in an HTTP parameter named <strong class="source-inline">_csrf</strong>. For example, the request to transfer money would look <span class="No-Break">as follows:</span></p>
<pre class="console">
POST /transfer HTTP/1.1 Host: bank.example.com
Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly
Content-Type: application/x-www-form-urlencoded amount=100.00&amp;routingNumber=1234&amp;account=9876&amp;_csrf=&lt;secure-random token&gt;</pre> <p>You will notice that we added the <strong class="source-inline">_csrf</strong> parameter with a random value. Now, the malicious website will not be able to guess the correct value for the <strong class="source-inline">_csrf</strong> parameter (which must be explicitly provided on the malicious website), and the transfer will fail when the server compares the actual token to the <span class="No-Break">expected token.</span></p>
<p>The following diagram shows a standard use case for a <strong class="source-inline">synchronizer </strong><span class="No-Break"><strong class="source-inline">token</strong></span><span class="No-Break"> pattern:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<img alt="Figure 15.3 – Synchronizer token pattern" height="511" src="image/B21757_15_3.jpg" width="1135"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – Synchronizer token pattern</p>
<p><strong class="source-inline">Spring Security</strong> provides <strong class="source-inline">synchronizer token</strong> support that is turned on by default. You might have noticed <a id="_idIndexMarker1017"/>from the previous chapters that in<a id="_idIndexMarker1018"/> our <strong class="source-inline">SecurityConfig.java</strong> file, we disabled CSRF protection, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
...
    http.csrf(AbstractHttpConfigurer::disable);
    return http.build();
}</pre> <p>Up to this point in the book, we have disabled <strong class="source-inline">synchronizer token</strong> protection so that we can focus on other <span class="No-Break">security concerns.</span></p>
<p>If we start the application at this point, and there will be no <strong class="source-inline">synchronizer token</strong> support added to any of <span class="No-Break">the pages.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the code <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter15.00-calendar</strong></span><span class="No-Break">.</span></p>
<p>After exploring the <strong class="source-inline">synchronizer token</strong> pattern, we will explore when to use <span class="No-Break">CSRF protection.</span></p>
<h2 id="_idParaDest-321"><a id="_idTextAnchor486"/>When to use CSRF protection</h2>
<p>It is recommended you use CSRF protection for any request that could be processed by a browser or normal users. If you are only creating a service that is used by non-<a id="_idTextAnchor487"/>browser clients, you will most likely want to disable <span class="No-Break">CSRF protection.</span></p>
<h3>CSRF protection and JSON</h3>
<p>A common question is, do I need to<a id="_idIndexMarker1019"/> protect JSON requests made by JavaScript? The short answer is, it depends. However, you must be very careful, as there are CSRF exploits that can impact JSON requests. For example, a malicious user can create a CSRF with JSON using the <span class="No-Break">following form:</span></p>
<pre class="source-code">
&lt;form action="https://example.com/secureTransaction" method="post" enctype="text/plain"&gt;
    &lt;input name='{"amount":100,"routingNumber":"maliciousRoutingNumber", "account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'&gt;
    &lt;input type="submit" value="Win Money!"/&gt;
&lt;/form&gt;</pre> <p>This will produce the following <span class="No-Break">JSON structure:</span></p>
<pre class="source-code">
{
  "amount": 100,
  "routingNumber": "maliciousRoutingNumber",
  "account": "maliciousAccountNumber",
  "ignore_me": "=test"
}</pre> <p>If an application were not <a id="_idIndexMarker1020"/>validating the <strong class="source-inline">Content-Type</strong> method, then it would be exposed to this exploit. Depending on the setup, a Spring MVC application that validates the <strong class="source-inline">Content- Type</strong> method could still be exploited by updating the URL suffix to end with <strong class="source-inline">.json</strong>, as shown in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
&lt;form action="https://example.com/secureTransaction.json" method="post" enctype="text/plain"&gt;
    &lt;input name='{"amount":100,"routingNumber":"maliciousRoutingNumber", "account":"maliciousAccountNumber", "ignore_me":"' value='test"}' type='hidden'&gt;
    &lt;input type="submit" value="Win Money!"/&gt;
&lt;/form&gt;</pre> <p>In this section, we have explored CSRF protection and JSON. In the next section, we will cover CSRF and stateless <span class="No-Break">browser applications.</span></p>
<h3>CSRF and stateless browser applications</h3>
<p>What if your application is <a id="_idIndexMarker1021"/>stateless? That doesn’t necessarily mean you are protected. In fact, if a user does not need to perform any actions in the web browser for a given request, they are likely still vulnerable to <span class="No-Break">CSRF attacks.</span></p>
<p>For example, consider an application using a custom cookie that contains all of the states within it for authentication instead of the <strong class="source-inline">JSESSIONID</strong> cookie. When the CSRF attack happens, the custom cookie will be sent with the request in the same manner that the <strong class="source-inline">JSESSIONID</strong> cookie was sent in our <span class="No-Break">previous example.</span></p>
<p>Users using basic authentication are also vulnerable to CSRF attacks, since the browser will automatically include the username and password in any requests, in the same manner, that the <strong class="source-inline">JSESSIONID</strong> cookie was sent in our <span class="No-Break">previous example.</span></p>
<h3>Using Spring Security CSRF protection</h3>
<p>So, what are the steps <a id="_idIndexMarker1022"/>necessary to use <strong class="source-inline">Spring Security</strong> to protect our site against CSRF attacks? The steps for using <strong class="source-inline">Spring Security</strong>’s CSRF protection are <span class="No-Break">as follows:</span></p>
<ol>
<li>Use proper <span class="No-Break">HTTP verbs.</span></li>
<li>Configure <span class="No-Break">CSRF protection.</span></li>
<li>Include the <span class="No-Break">CSRF token.</span></li>
</ol>
<p>Let’s understand these steps <span class="No-Break">better now.</span></p>
<h4>Using proper HTTP verbs</h4>
<p>The first step to<a id="_idIndexMarker1023"/> protecting against CSRF attacks is to ensure that your website uses proper <strong class="source-inline">HTTP</strong> verbs. Specifically, before <strong class="source-inline">Spring Security</strong>’s CSRF support can be of use, you need to be certain that your application uses <strong class="source-inline">PATCH</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and/or <strong class="source-inline">DELETE</strong> for anything that <span class="No-Break">modifies state.</span></p>
<p>This is not a limitation of <strong class="source-inline">Spring Security</strong>’s support but, instead, a general requirement for proper <strong class="source-inline">CSRF</strong> prevention. The reason is that including private information in an <strong class="source-inline">HTTP GET</strong> method can cause the information to <span class="No-Break">be leaked.</span></p>
<p>Refer to <em class="italic">RFC 2616, Section 15.1.3</em>, <em class="italic">Encoding Sensitive Information in URI’s</em>, for general guidance on using <strong class="source-inline">POST</strong> instead of <strong class="source-inline">GET</strong> for sensitive <span class="No-Break">information (</span><a href="https://www.rfc-editor.org/rfc/rfc2616.xhtml#section-15.1.3"><span class="No-Break">https://www.rfc-editor.org/rfc/rfc2616.xhtml#sect<span id="_idTextAnchor488"/>ion-15.1.3</span></a><span class="No-Break">).</span></p>
<h4>Conﬁguring CSRF protection</h4>
<p>The next <a id="_idIndexMarker1024"/>step is to include <strong class="source-inline">Spring Security</strong>’s CSRF protection within your application. Some frameworks handle invalid CSRF tokens by invaliding the user’s session, but this causes its own problems. Instead, by default, <strong class="source-inline">Spring Security</strong>’s CSRF protection will produce <strong class="source-inline">HTTP 403 access denied</strong>. This can be customized by configuring <strong class="source-inline">AccessDeniedHandler</strong> to process <span class="No-Break"><strong class="source-inline">InvalidCsrfTokenException</strong></span><span class="No-Break"> differently.</span></p>
<p>For passivity reasons, if you are using the <strong class="source-inline">XML</strong> configuration, CSRF protection must be explicitly enabled using the <strong class="source-inline">&lt;csrf&gt;</strong> element. Refer to the <strong class="source-inline">&lt;csrf&gt;</strong> element’s documentation for<a id="_idIndexMarker1025"/> <span class="No-Break">additional customizations.</span></p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor489"/>Default CSRF support</h2>
<p>CSRF protection is enabled by <a id="_idIndexMarker1026"/>default with Java configuration. Refer to the Java documentation of <strong class="source-inline">csrf()</strong> for additional customizations regarding how CSRF protection <span class="No-Break">is configured.</span></p>
<p>Just to be verbose in this configuration, we are going to add the CSRF method to our<strong class="source-inline"> SecurityConfig.java</strong> file, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
...
    http.csrf(Customizer.withDefaults());
    return http.build();
}</pre> <p>To have access to the H2 console, CSRF needs to be disabled, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
...
    http
       .csrf(csrf -&gt; csrf
             .ignoringRequestMatchers(toH2Console())
             .disable());
    return http.build();
}</pre> <p>After configuring<a id="_idIndexMarker1027"/> CSRF in the <strong class="source-inline">Spring Security</strong> <strong class="source-inline">SecurityFilterChain</strong> bean, we will see how we can enable the support in <span class="No-Break">web forms.</span></p>
<h3>Including the CSRF token in the &lt;form&gt; submissions</h3>
<p>The last <a id="_idIndexMarker1028"/>step is to ensure that you include the CSRF token in all <strong class="source-inline">PATCH</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> methods. One way to approach this is to use the <strong class="source-inline">_csrf</strong> request attribute to obtain the current <strong class="source-inline">CsrfToken</strong> token. An example of doing this with <a id="_idIndexMarker1029"/>a <strong class="bold">Java Server Page</strong> (<strong class="bold">JSP</strong>) is shown <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;c:url var="logoutUrl" value="/logout"/&gt;
&lt;form action="${logoutUrl}"
      method="post"&gt;
    &lt;input type="submit"
           value="Log out" /&gt;
    &lt;input type="hidden"
           name="${_csrf.parameterName}"
           value="${_csrf.token}"/&gt;
&lt;/form&gt;</pre> <p>After including the CSRF token in the <strong class="source-inline">&lt;form&gt;</strong>, we will explore another option by including the CSRF token based on <strong class="source-inline">Spring Security</strong> <span class="No-Break">JSP tags.</span></p>
<h3>Including the CSRF token using the Spring Security JSP tag library</h3>
<p>If CSRF <a id="_idIndexMarker1030"/>protection is enabled, the <strong class="source-inline">Spring Security</strong> tag inserts a hidden form field with the correct name and value for the CSRF protection token. If CSRF protection is not enabled, this tag has <span class="No-Break">no output.</span></p>
<p>Normally, <strong class="source-inline">Spring Security</strong> automatically inserts a CSRF form field for any <strong class="source-inline">&lt;form:form&gt;</strong> tags you use, but if for some reason you cannot use <strong class="source-inline">&lt;form:form&gt;</strong>, <strong class="source-inline">csrfInput</strong> is a <span class="No-Break">handy replacement.</span></p>
<p>You should place this tag within an <strong class="source-inline">HTML &lt;form&gt;&lt;/form&gt;</strong> block, where you would normally place other input fields. Do not place this tag within a Spring <strong class="source-inline">&lt;form:form&gt;&lt;/form:form&gt;</strong> block. <strong class="source-inline">Spring Security</strong> handles Spring forms automatically, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;form method="post" action="/logout"&gt;
    &lt;sec:csrfInput /&gt;
    ...
&lt;/form&gt;</pre> <h3>Default CSRF token support</h3>
<p>If you<a id="_idIndexMarker1031"/> are using the Spring MVC <strong class="source-inline">&lt;form:form&gt;</strong> tag, or <strong class="source-inline">Thymeleaf 2.1+</strong>, and you are also using <strong class="source-inline">@EnableWebSecurity</strong>, the <strong class="source-inline">CsrfToken</strong> token is automatically included for you (using the <strong class="source-inline">CsrfRequestDataValue</strong> token we have <span class="No-Break">been processing).</span></p>
<p>So, for this book, we have been using <em class="italic">Thymeleaf</em> for all of our web pages. Thymeleaf has CSRF support enabled by default if we enable CSRF support in <span class="No-Break"><strong class="source-inline">Spring Security</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">logout</strong> link will not work with CSRF support enabled and needs to be replaced by the <span class="No-Break">following code:</span></p>
<pre class="source-code">
//src/main/webapp/WEB-INF/templates/fragments/header.xhtml
&lt;form th:action="@{/logout}" method="post"&gt;
    &lt;input type="submit" value="Logout" class="btn btn-outline-light" /&gt;
&lt;/form&gt;&lt;/li&gt;</pre> <p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter15.01-calendar</strong></span><span class="No-Break">.</span></p>
<p>If we start up the<a id="_idIndexMarker1032"/> JBCP calendar application and navigate to the login page at <strong class="source-inline">http://localhost:8080/login.xhtml</strong>, we can view the generated source for the <strong class="source-inline">login.xhtml</strong> page, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;form class="form-horizontal" method="POST" action="/login"&gt;
    &lt;input type="hidden" name="_csrf" value="eEOF9AiMgfLo353Q19oTxLz5JFiNDUwbVnp-UiIExznGwFV9HiK2xGq_4sLFvfng4fcn9oTNCTrpay82YEhLNBBhpV_x8DFM"/&gt;
...
&lt;/form&gt;</pre> <h3>Ajax and JavaScript requests</h3>
<p>If you are<a id="_idIndexMarker1033"/> using JSON, then it is not possible to submit the CSRF token within an HTTP parameter. Instead, you can submit the token within an HTTP header. A typical pattern would be to include the CSRF token within your <strong class="source-inline">&lt;meta&gt;</strong> HTML tags. An example with a JSP is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;html&gt;
&lt;head&gt;
    &lt;meta name="_csrf" th:content="${_csrf.token}"/&gt;
    &lt;!-- default header name is X-CSRF-TOKEN --&gt;
    &lt;meta name="_csrf_header" th:content="${_csrf.headerName}"/&gt;
    &lt;!-- ... --&gt;
&lt;/head&gt;</pre> <p>Instead of <a id="_idIndexMarker1034"/>manually creating the meta tags, you can use the s<a id="_idTextAnchor490"/>impler <strong class="source-inline">csrfMetaTags</strong> tag from the <strong class="source-inline">Spring Security</strong> JSP <span class="No-Break">tag library.</span></p>
<h3>The csrfMetaTags tag</h3>
<p>If CSRF protection is<a id="_idIndexMarker1035"/> enabled, this tag inserts meta tags containing the<a id="_idIndexMarker1036"/> CSRF protection token form field, header names, and CSRF protection token value. These meta tags are useful for employing CSRF protection within JavaScript in <span class="No-Break">your applications.</span></p>
<p>You should place the <strong class="source-inline">csrfMetaTags</strong> tag within an HTML <strong class="source-inline">&lt;head&gt;&lt;/head&gt;</strong> block, where you would normally place other meta tags. Once you use this tag, you can access the form field name, header name, and token value easily using JavaScript, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;CSRF Protected JavaScript Page&lt;/title&gt;
    &lt;meta name="description" content="This is the description for this page"/&gt;
    &lt;sec:csrfMetaTags/&gt;
    &lt;script type="text/javascript"&gt;
        var csrfParameter = $("meta[name='_csrf_parameter']").attr("content");
        var csrfHeader = $("meta[name='_csrf_header']").attr("content");
        var csrfToken = $("meta[name='_csrf']").attr("content");
        // using XMLHttpRequest directly to send an x-www-form-urlencoded request
        var ajax = new XMLHttpRequest();
        ajax.open("POST", "https://www.example.org/do/something", true);
        ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded data");
        ajax.send(csrfParameter + "=" + csrfToken + "&amp;name=John&amp;...");
        // using XMLHttpRequest directly to send a non-x-www-form-urlencoded request
        var ajax = new XMLHttpRequest();
        ajax.open("POST", "https://www.example.org/do/something", true);
        ajax.setRequestHeader(csrfHeader, csrfToken);
        ajax.send("...");
    &lt;/script&gt;
&lt;/head&gt;&gt;
&lt;body&gt;
...
&lt;/body&gt;
&lt;/html&gt;</pre> <p>If CSRF<a id="_idIndexMarker1037"/> protection is not enabled, <strong class="source-inline">csrfMetaTags</strong> <span class="No-Break">outputs </span><span class="No-Break"><a id="_idIndexMarker1038"/></span><span class="No-Break">nothing.</span></p>
<h3>jQuery usage</h3>
<p>You can then include the<a id="_idIndexMarker1039"/> token within all of your Ajax requests. If you were using jQuery, this could be done with the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
// using JQuery to send an x-www-form-urlencoded request
var data = {};
data[csrfParameter] = csrfToken;
data["name"] = "John";
...
$.ajax({
    url: "https://www.example.org/do/something",
    type: "POST",
    data: data,
    ...
});
// using JQuery to send a non-x-www-form-urlencoded request
var headers = {};
headers[csrfHeader] = csrfToken;
$.ajax({
    url: "https://www.example.org/do/something",
    type: "POST",
    headers: headers,
    ...
});</pre> <p>After exploring the default CSRF configuration, we will conclude with some <span class="No-Break">CSRF caveats.</span></p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor491"/>CSRF caveats</h2>
<p>There are a few caveats when implementing CSRF in <strong class="source-inline">Spring <a id="_idTextAnchor492"/>Security</strong> that you need to be aware of. Let us see these caveats in the next <span class="No-Break">few sections.</span></p>
<h3>Timeouts</h3>
<p>One issue is that the expected <a id="_idIndexMarker1040"/>CSRF token is stored in the <strong class="source-inline">HttpSession</strong> method, so as soon as the <strong class="source-inline">HttpSession</strong> method expires, your configured <strong class="source-inline">AccessDeniedHandler</strong> handler will receive <strong class="source-inline">InvalidCsrfTokenException</strong>. If you are using the default <strong class="source-inline">AccessDeniedHandler</strong> handler, the browser will get an <strong class="source-inline">HTTP 403</strong> and display a poor <span class="No-Break">error message.</span></p>
<p>Another disadvantage is that by removing the state (the timeout), you lose the ability to forcibly terminate the token if something <span class="No-Break">is compromised.</span></p>
<p>A simple way to mitigate an active user experiencing a timeout is to have some JavaScript that lets the user know their session is about to expire. The user can click a button to continue and refresh <span class="No-Break">the session.</span></p>
<p>Alternatively, specifying a custom <strong class="source-inline">AccessDeniedHandler</strong> handler allows you to process <strong class="source-inline">InvalidCsrfTokenException</strong> any way you like, as we can see in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, CustomAccessDeniedHandler accessDeniedHandler) throws Exception {
       http
             // ...
             .exceptionHandling(exceptionHandlin) -&gt; exceptionHandling
                   .accessDeniedHandler(accessDeniedHandler);
             );
       return http.build();
    }
    @Bean
    public CustomAccessDeniedHandler accessDeniedHandler(){ return new AccessDeniedHandlerImpl();
    }
}</pre> <h3>Logging in</h3>
<p>To protect against forged <a id="_idIndexMarker1041"/>login requests, the login form should be protected against CSRF attacks, too. Since the <strong class="source-inline">CsrfToken</strong> token is stored in <strong class="source-inline">HttpSession</strong>, this means an <strong class="source-inline">HttpSession</strong> method will be created as soon as the <strong class="source-inline">CsrfToken</strong> attribute <span class="No-Break">is accessed.</span></p>
<p>While this sounds bad in a RESTful/stateless architecture, the reality is that the state is necessary to implement practical security. Without the state, we have nothing we can do if a token is compromised. Practically speaking, the CSRF token is quite small in size and should have a negligible impact on <span class="No-Break">our architecture.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">An attacker may forge a request to log the victim into a target website using the attacker’s credentials; this is known as<a id="_idIndexMarker1042"/> login <span class="No-Break">CSRF (</span><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests"><span class="No-Break">https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests</span></a><span class="No-Break">).</span></p>
<h3>Logging out</h3>
<p>Adding CSRF will update<a id="_idIndexMarker1043"/> the <strong class="source-inline">LogoutFilter</strong> filter to only use <strong class="source-inline">HTTP POST</strong>. This ensures that logging out requires a CSRF token and that a malicious user cannot forcibly log out <span class="No-Break">your users.</span></p>
<p>One approach to prevent CSRF attacks is to use a <strong class="source-inline">&lt;form&gt;</strong> tag for logout. If you want an <strong class="source-inline">HTML</strong> link, you can use JavaScript to have the link perform an <strong class="source-inline">HTTP POST</strong> (which can be in a hidden form). For browsers with JavaScript disabled, you can optionally have the link take the user to a logout confirmation page that will perform the <span class="No-Break"><strong class="source-inline">HTTP POST</strong></span><span class="No-Break">.</span></p>
<p>If you want to use <strong class="source-inline">HTTP GET</strong> with logout, you can do so, but remember, this is generally not recommended. For example, the following Java configuration will perform logout when the logout URL pattern is requested with any <span class="No-Break"><strong class="source-inline">HTTP</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .logout(logout -&gt; logout
                   .logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
             );
       return http.build();
    }
}</pre> <p>In this section, we’ve discussed CSRF now, let’s delve into securing HTTP <span class="No-Break">response headers.</span></p>
<h1 id="_idParaDest-324"><a id="_idTextAnchor493"/>Security HTTP response headers</h1>
<p>The following <a id="_idIndexMarker1044"/>sections discuss <strong class="source-inline">Spring Security</strong>’s su<a id="_idTextAnchor494"/>pport for adding various <a id="_idTextAnchor495"/>security headers to <span class="No-Break">the response.</span></p>
<p><strong class="source-inline">Spring Security</strong> allows users to easily inject default security headers to assist in protecting their applications. The following is a list of the current default security headers provided by <span class="No-Break"><strong class="source-inline">Spring Security</strong></span><span class="No-Break">:</span></p>
<ul>
<li><span class="No-Break">Cache-Control</span></li>
<li><span class="No-Break">Content-Type Options</span></li>
<li>HTTP Strict <span class="No-Break">Transport Security</span></li>
<li><span class="No-Break">X-Frame-Options</span></li>
<li><span class="No-Break">X-XSS-Protection</span></li>
</ul>
<p>While each of these headers is considered best practice, it should be noted that not all clients utilize these headers, so additional testing is encouraged. For passivity reasons, if you are using <strong class="source-inline">Spring Security</strong>’s <strong class="source-inline">XML namespace</strong> support, you must explicitly enable the security headers. All of the default headers can be easily added using the <strong class="source-inline">&lt;headers&gt;</strong> element with no <span class="No-Break">child elements.</span></p>
<p>If you are using <strong class="source-inline">Spring Security</strong>’s Java configuration, all of the default security headers are added by default. They can be disabled using Java configuration, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers.disable());
       return http.build();
    }
}</pre> <p>By default, <strong class="source-inline">Spring Security</strong> instructs <a id="_idIndexMarker1045"/>browsers to disable the XSS Auditor by using <strong class="source-inline">&lt;headers-xss-protection,X-XSS-Protection header&gt;</strong>. You can disable the <strong class="source-inline">X-XSS-Protection</strong> <span class="No-Break">header entirely:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
SecurityFilterChain springSecurityFilterChain(HttpSecurity http) throws Exception {
    http
          .headers(headers -&gt; headers
                .xssProtection(XXssConfig::disable)
          );
    return http.build();
}</pre> <p>You can also set the <span class="No-Break">header value:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
SecurityFilterChain springSecurityFilterChain(HttpSecurity http) throws Exception {
    http
          .headers(headers -&gt; headers
                .xssProtection(xssProtection -&gt; xssProtection.headerValue(XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK))
          );
    return http.build();
}</pre> <p>As soon as you <a id="_idIndexMarker1046"/>specify any headers that should be included, then only those headers will be included. For example, the following configuration will include support for <span class="No-Break"><strong class="source-inline">X-Frame-Options</strong></span><span class="No-Break"> only:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
SecurityFilterChain springSecurityFilterChain(HttpSecurity http) throws Exception {
    http
          .headers(headers -&gt; headers
                .frameOptions(FrameOptionsConfig::sameOrigin));
    return http.build();
}</pre> <h2 id="_idParaDest-325"><a id="_idTextAnchor496"/>Cache-Control</h2>
<p>In the past, <strong class="source-inline">Spring Security</strong> required<a id="_idIndexMarker1047"/> you to provide your own <strong class="source-inline">Cache-Control</strong> method <a id="_idIndexMarker1048"/>for your web application. This seemed reasonable at the time, but browser caches have evolved to include caches for secure connections as well. This means that a user may view an authenticated page and log out, and then a malicious user can use the browser history to view the <span class="No-Break">cached page.</span></p>
<p>To help mitigate this, <strong class="source-inline">Spring Security</strong> has added <strong class="source-inline">Cache-Control</strong> support, which will insert the following headers into <span class="No-Break">your response:</span></p>
<pre class="console">
Cache-Control: no-cache, no-store, max-age=0, must-revalidate Pragma: no-cache
Expires: 0</pre> <p>To be secure, <strong class="source-inline">Spring Security</strong> adds these headers by default. However, if your application provides its own cache control headers, <strong class="source-inline">Spring Security</strong> will rely on your own application headers only. This allows for applications to ensure that static resources (such as CSS and JavaScript) can <span class="No-Break">be cached.</span></p>
<h2 id="_idParaDest-326"><a id="_idTextAnchor497"/>Content-Type Options</h2>
<p>Historically, browsers, including <a id="_idIndexMarker1049"/>Internet Explorer, would<a id="_idIndexMarker1050"/> try to guess the content type of a request using content sniffing. This allowed browsers to improve the user experience by guessing the content type of resources that had not specified the content type. For example, if a browser encountered a JavaScript file that did not have the content type specified, it would be able to guess the content type and then <span class="No-Break">execute it.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">There are many additional things one should do, such as only displaying the document in a distinct domain, ensuring the <strong class="source-inline">Content-Type</strong> header is set, sanitizing the document, and so on, when allowing content to be uploaded. However, these measures are out of the scope of what <strong class="source-inline">Spring Security</strong> provides. It is also important to point out that when disabling content sniffing, you must specify the content type for things to <span class="No-Break">work properly.</span></p>
<p>The problem with content sniffing is that this allows malicious users to use <em class="italic">polyglots</em> (a file that is valid as multiple content types) to execute XSS attacks. For example, some sites may allow users to submit a valid PostScript document to a website and view it. A malicious user might create a PostScript document that is also a valid JavaScript file and execute an XSS attack with <span class="No-Break">it (</span><a href="http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf"><span class="No-Break">http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf</span></a><span class="No-Break">).</span></p>
<p>Content sniffing can be disabled by adding the following header to <span class="No-Break">our response:</span></p>
<pre class="console">
X-Content-Type-Options: nosniff</pre> <p>By<a id="_idIndexMarker1051"/> default, <strong class="source-inline">Spring Security</strong> disables content <a id="_idIndexMarker1052"/>sniffing by adding this header to <span class="No-Break">HTTP responses.</span></p>
<h2 id="_idParaDest-327"><a id="_idTextAnchor498"/>HTTP Strict Transport Security</h2>
<p>When you <a id="_idIndexMarker1053"/>type in <a id="_idIndexMarker1054"/>your bank’s website, do you enter <strong class="source-inline">mybank.example.com</strong>, or do you enter <strong class="source-inline">https://mybank.example.com</strong>? If you omit the HTTPS protocol, you are potentially<a id="_idIndexMarker1055"/> vulnerable to <strong class="bold">Man-in-the-Middle</strong> (<strong class="bold">MitM</strong>) attacks. Even if the website performs a redirect to <strong class="source-inline">https://mybank.example.com</strong>, a malicious user could intercept the initial HTTP request and manipulate the response (redirect to <strong class="source-inline">https://mibank.example.com</strong> and steal <span class="No-Break">your credentials).</span></p>
<p>Many users omit the HTTPS protocol, and this is why <strong class="source-inline">HSTS</strong> <span class="No-Break">was created.</span></p>
<p>In accordance with <strong class="source-inline">RFC6797</strong>, the <strong class="source-inline">HSTS</strong> header is only injected into <strong class="source-inline">HTTPS</strong> responses. In order for the browser to acknowledge the header, the browser must first trust the <strong class="bold">certificate authority </strong>(<strong class="bold">CA</strong>) that <a id="_idIndexMarker1056"/>signed the <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificate<a id="_idIndexMarker1057"/> used to make the connection, not just the SSL <span class="No-Break">certificate (</span><a href="https://datatracker.ietf.org/doc/html/rfc6797"><span class="No-Break">https://datatracker.ietf.org/doc/html/rfc6797</span></a><span class="No-Break">).</span></p>
<p>Once <strong class="source-inline">mybank.example.com</strong> is added as an HSTS host, a browser can know beforehand that any request to <strong class="source-inline">mybank.example.com</strong> should be interpreted as <strong class="source-inline">https://mybank.example.com</strong>. This greatly reduces the <a id="_idIndexMarker1058"/>possibility of a <strong class="bold">Man-in-the-Middle</strong> (<strong class="bold">MitM</strong>) <span class="No-Break">attack occurring.</span></p>
<p>One way for a site to be marked as an HSTS host is to have the host preloaded into the browser. Another is to add the <strong class="source-inline">Strict-Transport-Security</strong> header to the response. For example, the following would instruct the browser to treat the domain as an HSTS host for a year (there are approximately <strong class="source-inline">31,536,000</strong> seconds in <span class="No-Break">a year):</span></p>
<pre class="console">
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload</pre> <p>The optional <strong class="source-inline">includeSubDomains</strong> directive instructs <strong class="source-inline">Spring Security</strong> that subdomains (such as <strong class="source-inline">secure.mybank.example.com</strong>) should also be treated as an <span class="No-Break">HSTS domain.</span></p>
<p>The optional preload directive instructs the browser that the domain should be preloaded in the browser as an HSTS domain. For more details on <a id="_idIndexMarker1059"/>HSTS preload, <span class="No-Break">see </span><a href="http://hstspreload.org"><span class="No-Break">hstspreload.org</span></a><span class="No-Break">.</span></p>
<p>You can <a id="_idIndexMarker1060"/>explicitly customize the results. The following example explicitly <span class="No-Break">provides HSTS:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .httpStrictTransportSecurity(hsts -&gt; hsts
                         .includeSubDomains(true)
                         .preload(true)
                         .maxAgeInSeconds(31536000)
                   )
             );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-328"><a id="_idTextAnchor499"/>HTTP Public Key Pinning (HPKP)</h2>
<p><strong class="source-inline">Spring Security</strong> provides <a id="_idIndexMarker1061"/>servlet <a id="_idIndexMarker1062"/>support for HPKP (see here: <a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp">https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp</a>), but it is no longer <span class="No-Break">recommended (</span><a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp-deprecated"><span class="No-Break">https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp-deprecated</span></a><span class="No-Break">).</span></p>
<p>You can enable HPKP headers with the <span class="No-Break">following configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .httpPublicKeyPinning(hpkp -&gt; hpkp
                         .includeSubDomains(true)
                         .reportUri("https://example.net/pkp-report")
                         .addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=")
                   )
             );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-329"><a id="_idTextAnchor500"/>X-Frame-Options</h2>
<p>Allowing<a id="_idIndexMarker1063"/> your website to be added to a frame can be a security <a id="_idIndexMarker1064"/>issue. For example, through the use of clever CSS styling, users could be tricked into clicking on something that they did not <span class="No-Break">intend to.</span></p>
<p>For example, a user who is logged in to their bank might click a button that grants access to other users. This sort of attack is known <a id="_idIndexMarker1065"/><span class="No-Break">as </span><span class="No-Break"><strong class="bold">clickjacking</strong></span><span class="No-Break">.</span></p>
<p>Read more about <a id="_idIndexMarker1066"/>Clickjacking <span class="No-Break">at </span><a href="https://owasp.org/www-community/attacks/Clickjacking"><span class="No-Break">https://owasp.org/www-community/attacks/Clickjacking</span></a><span class="No-Break">.</span></p>
<p>Another modern<a id="_idIndexMarker1067"/> approach to dealing with Clickjacking is using a <strong class="bold">Content Security </strong><span class="No-Break"><strong class="bold">Policy</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CSP</strong></span><span class="No-Break">).</span></p>
<p>There are a number of ways to mitigate Clickjacking attacks. For example, to protect legacy browsers from Clickjacking attacks, you can use frame-breaking code. While not perfect, frame-breaking code is the best you can do for <span class="No-Break">legacy browsers.</span></p>
<p>A more modern approach to address Clickjacking is to use the <strong class="source-inline">X-Frame-Options</strong> header, <span class="No-Break">as follows:</span></p>
<pre class="console">
X-Frame-Options: DENY</pre> <p>If you want to change the value for the <strong class="source-inline">X-Frame-Options</strong> header, then you can use an <span class="No-Break"><strong class="source-inline">XFrameOptionsHeaderWriter</strong></span><span class="No-Break"> instance.</span></p>
<p>Some browsers have built-in support for filtering out reflected XSS attacks. This is by no means foolproof, but it does assist with <span class="No-Break">XSS protection.</span></p>
<p>Filtering is typically<a id="_idIndexMarker1068"/> enabled by default, so adding the <a id="_idIndexMarker1069"/>header just ensures that it is enabled and instructs the browser as to what to do when an XSS attack is detected. For example, the filter might try to change the content in the least invasive way to still render everything. At times, this type of replacement can become an XSS vulnerability. Instead, it is best to block the content, rather than attempt to fix it. To do this, we can add the <span class="No-Break">following header:</span></p>
<pre class="console">
X-XSS-Protection: 1; mode=block</pre> <h2 id="_idParaDest-330"><a id="_idTextAnchor501"/>CSP</h2>
<p><strong class="source-inline">Spring Security</strong> does <a id="_idIndexMarker1070"/>not add a CSP (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-csp) by default, because a reasonable <a id="_idIndexMarker1071"/>default is impossible to know without knowing the context of the application. The web application author must declare the security policy (or policies) to enforce or monitor them for the <span class="No-Break">protected resources.</span></p>
<p>Consider the following <span class="No-Break">security policy:</span></p>
<pre class="console">
Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/</pre> <p>Given the preceding security policy, you can enable the <span class="No-Break">CSP header:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .contentSecurityPolicy(csp -&gt; csp
                         .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                   )
             );
       return http.build();
    }
}</pre> <p>To enable the <a id="_idIndexMarker1072"/>CSP report-only <a id="_idIndexMarker1073"/>header, provide the <span class="No-Break">following configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .contentSecurityPolicy(csp -&gt; csp
                         .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                         .reportOnly()
                   )
             );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-331"><a id="_idTextAnchor502"/>Referrer Policy</h2>
<p><strong class="source-inline">Spring Security</strong> does not <a id="_idIndexMarker1074"/>add <a id="_idIndexMarker1075"/>Referrer Policy (<a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer">https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer</a>) headers by default. You can enable the <strong class="source-inline">ReferrerPolicy</strong> header by using <span class="No-Break">this configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .referrerPolicy(referrer -&gt; referrer
                         .policy(ReferrerPolicy.SAME_ORIGIN)
                   )
             );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-332"><a id="_idTextAnchor503"/>Feature Policy</h2>
<p><strong class="source-inline">Spring Security</strong> does not<a id="_idIndexMarker1076"/> add <a id="_idIndexMarker1077"/>Feature Policy (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-feature) headers by default. Consider the following <span class="No-Break"><strong class="source-inline">Feature-Policy</strong></span><span class="No-Break"> header:</span></p>
<pre class="source-code">
Feature-Policy: geolocation 'self'</pre> <p>You can enable the preceding feature policy header by using the <span class="No-Break">following configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .featurePolicy("geolocation 'self'")
             );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-333"><a id="_idTextAnchor504"/>Permissions Policy</h2>
<p><strong class="source-inline">Spring Security</strong> does not<a id="_idIndexMarker1078"/> add<a id="_idIndexMarker1079"/> Permissions Policy (<a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions">https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions</a>) headers by default. Consider the following <span class="No-Break"><strong class="source-inline">Permissions-Policy</strong></span><span class="No-Break"> header:</span></p>
<pre class="console">
Permissions-Policy: geolocation=(self)</pre> <p>You can enable the preceding permissions policy header using the <span class="No-Break">following configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .featurePolicy("geolocation 'self'")
             );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-334"><a id="_idTextAnchor505"/>Clear Site Data</h2>
<p><strong class="source-inline">Spring Security</strong> does not<a id="_idIndexMarker1080"/> add <strong class="source-inline">Clear-Site-Data</strong> (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-clear-site-data) headers by default. Consider the<a id="_idIndexMarker1081"/> following <span class="No-Break"><strong class="source-inline">Clear-Site-Data</strong></span><span class="No-Break"> header:</span></p>
<pre class="console">
Clear-Site-Data: "cache", "cookies"</pre> <p>You can send the preceding header to logout function with the <span class="No-Break">following configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
       // ...
       .logout((logout) -&gt; logout
             .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES)))
       );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-335"><a id="_idTextAnchor506"/>Static headers</h2>
<p>There <a id="_idIndexMarker1082"/>may be times when you wish to inject custom security headers into your application that are not supported out of the box. For example, perhaps you wish to have early support for a CSP to ensure that resources are only loaded from the same origin. Since support for a CSP has not been finalized, browsers use one of two common extension headers to implement the feature. This means we will need to inject the policy twice. An example of the headers can be seen in the following <span class="No-Break">code snippet:</span></p>
<pre class="console">
X-Content-Security-Policy: default-src 'self' X-WebKit-CSP: default-src 'self'</pre> <p>When using Java configuration, these headers can be added to the response using the<strong class="source-inline"> header()</strong> method, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.headers(headers -&gt; headers
          .addHeaderWriter(
                new StaticHeadersWriter("X-Content-Security-Policy", "default-src 'self'"))
          .addHeaderWriter(
                new StaticHeadersWriter( "X-WebKit-CSP","default-src 'self'");
    return http.build();
  }
}</pre> <h2 id="_idParaDest-336"><a id="_idTextAnchor507"/>The HeadersWriter instance</h2>
<p>When the <a id="_idIndexMarker1083"/>namespace or Java configuration does not support the <a id="_idIndexMarker1084"/>headers you want, you can create a custom <strong class="source-inline">HeadersWriter</strong> instance or even provide a custom implementation <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">HeadersWriter</strong></span><span class="No-Break">.</span></p>
<p>Let’s look at an example of using a custom instance of <strong class="source-inline">XFrameOptionsHeaderWriter</strong>. Perhaps you want to allow the framing of content for the same origin. This is easily supported by setting the policy attribute to <strong class="source-inline">SAMEORIGIN</strong>, but let’s look at a more explicit example using the <strong class="source-inline">ref</strong> attribute, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
             // ...
             .headers(headers -&gt; headers
                   .frameOptions(FrameOptionsConfig::sameOrigin
                   )
             );
       return http.build();
    }
}</pre> <h2 id="_idParaDest-337"><a id="_idTextAnchor508"/>The DelegatingRequestMatcherHeaderWriter class</h2>
<p>At times, you<a id="_idIndexMarker1085"/> may <a id="_idIndexMarker1086"/>want to only write a header for certain requests. For example, perhaps you want to only protect your login page from being framed. You could use the <strong class="source-inline">DelegatingRequestMatcherHeaderWriter</strong> class to do so. When using Java configuration, this can be done with the <span class="No-Break">following code:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       RequestMatcher matcher = new AntPathRequestMatcher("/login");
       DelegatingRequestMatcherHeaderWriter headerWriter =
             new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
       http
             // ...
             .headers(headers -&gt; headers
                   .frameOptions(frameOptions -&gt; frameOptions.disable())
                   .addHeaderWriter(headerWriter)
             );
       return http.build();
    }
}</pre> <p>To summarize this<a id="_idIndexMarker1087"/> section, you can add <strong class="source-inline">CSRF</strong> protection<a id="_idIndexMarker1088"/> based on <strong class="source-inline">DelegatingRequestMatcherHeaderWriter</strong>, explicit <strong class="bold">HTTP Strict Transport Security</strong> (<strong class="bold">HSTS</strong>), a <a id="_idIndexMarker1089"/>Permissions Policy, <strong class="source-inline">Clear-Site-Data</strong>, frame options, static headers, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DelegatingRequestMatcherHeaderWriter</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter15.02-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-338"><a id="_idTextAnchor509"/>Testing Spring Security Applications</h1>
<p>In addition to <strong class="source-inline">spring-boot-starter-test</strong>, <strong class="source-inline">Spring Security</strong> provides an artifact tailored specifically for<a id="_idIndexMarker1090"/> testing purposes. Its primary purpose is to provide utilities and classes that assist developers in writing tests for applications that use <strong class="source-inline">Spring Security</strong> for authentication <span class="No-Break">and authorization.</span></p>
<p>Some of the key functionalities provided by <span class="No-Break"><strong class="source-inline">org.springframework.security:spring-security-test</strong></span><span class="No-Break"> include:</span></p>
<ul>
<li><strong class="bold">Mocking Authentication</strong>: It allows you to easily mock authentication and authorization contexts during testing, enabling you to simulate different user roles <span class="No-Break">and permissions.</span></li>
<li><strong class="bold">Integration Testing</strong>: It provides support for integration testing by offering utilities for setting up security configurations in your test environment, ensuring that your security configurations are correctly applied <span class="No-Break">and tested.</span></li>
<li><strong class="bold">Testing Security Filters</strong>: <strong class="source-inline">Spring Security</strong> often involves configuring a chain of filters to handle authentication and authorization tasks. This module provides utilities to test these filters in isolation or as part of the <span class="No-Break">filter chain.</span></li>
</ul>
<p>To get started, you<a id="_idIndexMarker1091"/> need to include the following dependencies in your <strong class="source-inline">Spring </strong><span class="No-Break"><strong class="source-inline">Security</strong></span><span class="No-Break"> project:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
testImplementation 'org.springframework.boot:spring-boot-starter-test'
testImplementation 'org.springframework.security:spring-security-test'
}!</pre> <p>By using <strong class="source-inline">spring-security-test</strong>, you can effectively test the security features of the applications, ensuring that sensitive resources are properly protected and accessible only to <span class="No-Break">authorized users.</span></p>
<h1 id="_idParaDest-339"><a id="_idTextAnchor510"/>Reactive Applications Support</h1>
<p>Reactive programming<a id="_idIndexMarker1092"/> revolves around asynchronous and non-blocking interactions, characterized by callback and declarative approaches. It incorporates a backpressure mechanism to regulate the throughput from the producer, aiding in consumer control. In Java, Reactive programming relies on <strong class="source-inline">Streams</strong>, <strong class="source-inline">CompletableFuture</strong>, and backpressure controls. There exist numerous relevant use cases where reactive programming proves beneficial, including supporting high peak workloads, microservices, contention avoidance, IoT and Big <span class="No-Break">Data applications.</span></p>
<p>Spring relies on the project reactor(<a href="https://projectreactor.io/">https://projectreactor.io/</a>) that is the f foundation of <strong class="source-inline">Spring </strong><span class="No-Break"><strong class="source-inline">Webflux</strong></span><span class="No-Break"> (</span><a href="https://docs.spring.io/spring-framework/reference/web/webflux.xhtml"><span class="No-Break">https://docs.spring.io/spring-framework/reference/web/webflux.xhtml</span></a><span class="No-Break">).</span></p>
<p>To add <strong class="source-inline">Spring Security</strong> reactive <a id="_idIndexMarker1093"/>support into your Spring Boot project, you need to include <strong class="source-inline">spring-boot-starter-security</strong> and <strong class="source-inline">spring-boot-starter-webflux</strong> dependencies in <span class="No-Break">your projects:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
    // spring-webflux
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    // spring-security
    implementation 'org.springframework.boot:spring-boot-starter-security'...
}!</pre> <p>This table provides an overview of key classes to facilitate the transition from the Spring Security <a id="_idIndexMarker1094"/>Servlet implementation to the Spring Security <span class="No-Break">Reactive implementation.</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-9">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Spring Security</strong></span></p>
<p><span class="No-Break"><strong class="bold">Servlet implementation</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Spring Security</strong></span></p>
<p><span class="No-Break"><strong class="bold">Reactive implementation</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.w.SecurityFilterChain</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.w.s.Security WebFilterChain</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.u.UserDetailsService</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.u. ReactiveUserDetailsService</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.a.w.b.HttpSecurity</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.w.s.ServerHttpSecurity</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.c. SecurityContextHolder</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.c. ReactiveSecurityContextHolder</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.a.AuthenticationManager</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.a.ReactiveAuthentication Manager</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.a.w.c.EnableWebSecurity</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.a.m.r. EnableWeb</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">FluxSecurity</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.a.m.c. EnableMethodSecurity</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.a.m.c.EnableReactive MethodSecurity</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.p.InMemoryUser DetailsManager</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.c.u. MapReactiveUserDetailsService</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.OAuth2Authorized ClientManager</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.ReactiveOAuth2 AuthorizedClientManager</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c. OAuth2Authorized</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">ClientProvider</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.ReactiveOAuth2 AuthorizedClientProvider</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.w.DefaultOAuth2Authorized ClientManager</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.w.DefaultReactiveO Auth2AuthorizedClientManager</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.r.ClientRegistration Repository</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.r.ReactiveClient RegistrationRepository</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.e. OAuth2Access</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">TokenResponseClient</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.c.e.ReactiveOAuth2 AccessTokenResponseClient</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.j.JwtDecoder</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o.s.s.o.j.ReactiveJwtDecoder</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.1 – Transitioning from Spring Security Servlet to Reactive Implementation</p>
<p class="callout-heading">Important note</p>
<p class="callout">In this section, we provide a fully functional reactive implementation available <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter15.03-calendar</strong></span><span class="No-Break">.</span></p>
<p>You will notice the<a id="_idIndexMarker1095"/> following main changes in to enable <span class="No-Break">reactive support:</span></p>
<ol>
<li>Configure <strong class="source-inline">Spring Security</strong> to use our custom <strong class="source-inline">ReactiveUserDetailsService</strong><span class="P---Regular-Char"> </span>object, <span class="No-Break">as follow:</span><pre class="source-code">
//com/packtpub/springsecurity/service/UserDetailsServiceImpl.java
@Service
public class UserDetailsServiceImpl implements ReactiveUserDetailsService {
    private final CalendarUserRepository userRepository;
    public UserDetailsServiceImpl(CalendarUserRepository userRepository) {
       this.userRepository = userRepository;
    }
    @Override
    public Mono&lt;UserDetails&gt; findByUsername(String username) {
       return userRepository.findByEmail(username)
             .flatMap(user -&gt; {
                Set&lt;GrantedAuthority&gt; grantedAuthorities = new HashSet&lt;&gt;();
                for (Role role : user.getRoles()) {
                   grantedAuthorities.add(new SimpleGrantedAuthority(role.getName()));
                }
                return Mono.just(new User(user.getEmail(), user.getPassword(), grantedAuthorities));
             });
    }
}</pre></li> <li>Use <strong class="source-inline">@EnableWebFluxSecurity</strong><span class="P---Regular-Char"> </span>annotation, to<a id="_idIndexMarker1096"/> enable Spring Security <span class="No-Break">reactive support:</span><pre class="source-code">
//com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {
...
}</pre></li> <li>Define a <span class="No-Break"><strong class="source-inline">ReactiveAuthenticationManager</strong></span><span class="No-Break"><span class="P---Regular-Char"> bean</span></span><span class="No-Break">:</span><pre class="source-code">
//com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public ReactiveAuthenticationManager reactiveAuthenticationManager(final ReactiveUserDetailsService userDetailsService,
       final PasswordEncoder passwordEncoder) {
    UserDetailsRepositoryReactiveAuthenticationManager authenticationManager = new UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService);
    authenticationManager.setPasswordEncoder(passwordEncoder);
    return authenticationManager;
}</pre></li> <li>Create <a id="_idIndexMarker1097"/>the <span class="No-Break"><strong class="source-inline">SecurityWebFilterChain</strong></span><span class="No-Break"><span class="P---Regular-Char"> </span></span><span class="No-Break">bean:</span><pre class="source-code">
//com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public SecurityWebFilterChain filterChain(ServerHttpSecurity http)  {
    http.authorizeExchange(exchanges -&gt; exchanges
                .pathMatchers("/webjars/**").permitAll()
                .pathMatchers("/css/**").permitAll()
                .pathMatchers("/favicon.ico").permitAll()
                // H2 console:
                .pathMatchers("/admin/h2/**").permitAll()
                .pathMatchers("/").permitAll()
                .pathMatchers("/login/*").permitAll()
                .pathMatchers("/logout").permitAll()
                .pathMatchers("/signup/*").permitAll()
                .pathMatchers("/errors/**").permitAll()
                .pathMatchers("/admin/*").hasRole("ADMIN")
                .pathMatchers("/events/").hasRole("ADMIN")
                .pathMatchers("/**").hasRole("USER"));
    http.formLogin(Customizer.withDefaults());
    http.exceptionHandling(exceptions -&gt; exceptions
          .accessDeniedHandler(new HttpStatusServerAccessDeniedHandler(HttpStatus.FORBIDDEN)));
    return http.build();
}</pre></li> </ol>
<p>Launch the application and try to access it <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">http://localhost:8080</strong></span><span class="No-Break">.</span></p>
<p>You should be able to log in with the configured users <strong class="source-inline">admin1@example.com/admin1</strong> or <strong class="source-inline">user1@example.com/user1</strong> and test the <span class="No-Break">events creation.</span></p>
<p>Furthermore, creating a new user enables immediate login with the newly <span class="No-Break">created credentials.</span></p>
<p>In summary, <strong class="source-inline">Spring Security</strong> also provide a<a id="_idIndexMarker1098"/> reactive implementation. This implementation is best suited for applications that require handling a large number of concurrent connections, high scalability, and efficient resource utilization. It’s particularly beneficial in scenarios involving non-blocking I/O operations, such as web applications with heavy user traffic or real-time <span class="No-Break">data processing.</span></p>
<h1 id="_idParaDest-340"><a id="_idTextAnchor511"/>Summary</h1>
<p>In this chapter, we covered several security vulnerabilities, as well as employing <strong class="source-inline">Spring Security</strong> to circumvent those vulnerabilities. After reading this chapter, you should understand the threat of CSRF and the use of <em class="italic">synchronizer token</em> pattern to <span class="No-Break">prevent CSRF.</span></p>
<p>You should also know how to include various HTTP headers to protect against common security vulnerabilities using the <em class="italic">Cache-Control</em>, <em class="italic">Content-Type Options</em>, <em class="italic">HSTS</em>, <em class="italic">X-Frame-Options</em>, and <span class="No-Break"><em class="italic">X-XSS-Protection</em></span><span class="No-Break"> methods.</span></p>
<p>In the next chapter, we will discuss how to migrate to <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Security 6.x</strong></span><span class="No-Break">.</span></p>
</div>
</div></body></html>