<html><head></head><body>
		<div id="_idContainer079">
			<h1 id="_idParaDest-204"><em class="italic"><a id="_idTextAnchor215"/>Chapter 12</em>: MicroProfile LRA and the Future of MicroProfile</h1>
			<p>You have reached the final chapter of this book. Congratulations on making it this far! In this final chapter, we will briefly discuss the newly released MicroProfile <strong class="bold">Long-Running Action</strong> (<strong class="bold">LRA</strong>) and then look at the future of MicroProfile. </p>
			<p>While writing this book, MicroProfile LRA 1.0 was released to address the need for microservice transactions. A traditional <strong class="bold">transaction</strong>, as we all must know, is a movement of money, such as an online payment or a withdrawal of money from a bank. In a traditional application, you normally use technologies such as the <strong class="bold">two-phase commit</strong> or <strong class="bold">eXtended Architecture</strong> (<strong class="bold">XA</strong>) protocol to manage transactions. However, these technologies do not suit cloud-native application transactions. In this chapter, we will explore how MicroProfile addresses the need to manage cloud-native transactions. We also will have a look at the transaction architecture for cloud-native applications. After that, we will take you through the latest MicroProfile platform release. Finally, we will learn about the future roadmap of MicroProfile as well as its alignment with the Jakarta EE community.</p>
			<p>We will cover the following topics:</p>
			<ul>
				<li>Cloud-native application transactions</li>
				<li>Using the latest MicroProfile platform release</li>
				<li>MicroProfile's technical roadmap</li>
				<li>MicroProfile and Jakarta EE alignment</li>
			</ul>
			<p>By the end of this chapter, you should be able to use MicroProfile LRA for cloud-native application transactions and describe the roadmap for MicroProfile, which will help you to architect applications for the future.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor216"/>Cloud-native application transactions</h1>
			<p>Cloud-native <a id="_idIndexMarker1203"/>application transactions try to ensure data consistency and integrity, similar to a traditional transaction. Traditional transactions normally use the two-phase commit or XA protocol. The two-phase commit protocol ensures that transactional updates are committed in all databases or are fully rolled back in the case of a failure. It is widely supported by many databases. As its name implies, this <a id="_idIndexMarker1204"/>protocol <a id="_idIndexMarker1205"/>consists of two phases: the <strong class="bold">voting</strong><strong class="bold"> phase</strong> and the <strong class="bold">commit phase</strong>. In the voting phase, the transaction manager gets approval or rejection from the participating XA resources. In the commit phase, the transaction manager informs the participants about the result. If the result is positive, the entire transaction will be committed. Otherwise, it will be rolled back. This protocol is very reliable and guarantees data consistency. The drawback is that it locks resources and might lead to indefinite blocking. Therefore, it is not suitable for cloud-native applications, because they do not scale well and the latency of held locks is<a id="_idIndexMarker1206"/> problematic. Consequently, the <strong class="bold">saga pattern</strong> was established for cloud-native application transactions to achieve eventual data consistency. The saga pattern commits local transactions and then either completes or compensates the transactions. MicroProfile LRA is a realization of the saga pattern. In the upcoming subsections, we will discuss more on LRA. </p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor217"/>Using MicroProfile LRA for cloud-native application transactions</h2>
			<p>MicroProfile<a id="_idIndexMarker1207"/> LRA (<a href="https://download.eclipse.org/microprofile/microprofile-lra-1.0">https://download.eclipse.org/microprofile/microprofile-lra-1.0</a>) provides a solution<a id="_idIndexMarker1208"/> for cloud-native application transactions. It introduces two main concepts:</p>
			<ul>
				<li> <strong class="bold">LRA participants</strong>: LRA participants are transaction participants, which are cloud-native applications.</li>
				<li> <strong class="bold">LRA coordinator</strong>: The LRA coordinator is a transaction coordinator that manages the LRA processing and LRA participants. The LRA coordinator manages all LRAs and invokes LRA methods based on the LRA status.</li>
			</ul>
			<p>The following illustrates the relationships between LRA participants and the LRA coordinator:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B17377_12_01.jpg" alt="Figure 12.1 – LRA coordinator and participants&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – LRA coordinator and participants</p>
			<p>As shown in <em class="italic">Figure 12.1</em>, the LRA participants enlist with the LRA coordinator, which will then<a id="_idIndexMarker1209"/> call<a id="_idIndexMarker1210"/> back with the relevant JAX-RS methods based on the transaction status. We will now discuss LRA participants in more detail.</p>
			<h3>LRA participants</h3>
			<p>LRA<a id="_idIndexMarker1211"/> participants are JAX-RS methods that are involved in a transaction and are annotated with the following LRA annotations in the <strong class="source-inline">org.eclipse.microprofile.lra.annotation</strong> package:</p>
			<ul>
				<li><strong class="source-inline">@LRA</strong>: A method with this annotation will be associated with an LRA. The <strong class="source-inline">@LRA</strong> annotation registers the method with the LRA coordinator. When using this annotation, the following <strong class="bold">LRA types</strong> can be specified. <strong class="source-inline">LRA.Type</strong> is like the <strong class="source-inline">TransactionAttributeType</strong> enum<a id="_idIndexMarker1212"/> in <strong class="bold">Enterprise JavaBeans </strong>(<strong class="bold">EJB</strong>), indicating whether an LRA is a new one or an existing one. The commonly used <strong class="source-inline">LRA.Type</strong> variants are as follows:<p>a) <strong class="source-inline">REQUIRED</strong>: With this type, the method invocation will run with a new LRA context if called outside an LRA context. Otherwise, it will run with the same context. </p><p>b) <strong class="source-inline">REQUIRES_NEW</strong>: With this type, the method invocation will always run with a new LRA context.</p><p>c) <strong class="source-inline">MANDATORY</strong>: With this type, the method invocation will run inside an LRA context. If it is called outside an LRA context, an error will be returned. </p><p>d) <strong class="source-inline">SUPPORTS</strong>: With this type, if the method is called outside an LRA context, it will be executed outside an LRA context. If it is called inside an LRA context, it will be executed inside an LRA context.</p><p>e) <strong class="source-inline">NOT_SUPPORTED</strong>: With this type, the method is always executed outside an LRA context.<strong class="source-inline"> </strong></p><p>f) <strong class="source-inline">NEVER</strong>: With<a id="_idIndexMarker1213"/> this type, if the method is called outside an LRA context, it will be executed outside an LRA context. If it is called inside an LRA context, the method execution will fail and the return code <strong class="source-inline">412</strong> will be returned.</p><p>g) <strong class="source-inline">NESTED</strong>: With this type, when the method is called, a new LRA will be created, which can be either top-level or nested based on whether it is called inside an LRA context or not. If invoked outside a context, the new LRA will be top-level. Otherwise, the new LRA will be nested.</p></li>
			</ul>
			<p>You might be wondering how to determine whether a method is called inside an LRA context. If the <strong class="source-inline">LRA_HTTP_CONTEXT_HEADER</strong> header is present, it means the method is called inside an LRA context. </p>
			<ul>
				<li><strong class="source-inline">@Complete</strong>: A method with this annotation will be called when the LRA closes.</li>
				<li><strong class="source-inline">@Compensate</strong>: A method with this annotation will be invoked if the LRA  is canceled.</li>
				<li><strong class="source-inline">@Forget</strong>: A method with this annotation will be invoked if either the <strong class="source-inline">@Complete</strong> or <strong class="source-inline">@Compensate</strong> method invocation fails.</li>
				<li><strong class="source-inline">@Leave</strong>: A method with this annotation causes the LRA participant to be removed from the LRA participation.</li>
				<li><strong class="source-inline">@Status</strong>: A method with this annotation reports the status of the associated LRA.</li>
				<li><strong class="source-inline">@AfterLRA</strong>: A method with this annotation will be called when an LRA ends.</li>
			</ul>
			<p>The <strong class="source-inline">@Compensate</strong>, <strong class="source-inline">@Complete</strong>, and <strong class="source-inline">@AfterLRA</strong> annotations are for the <strong class="source-inline">PUT</strong> operation, while the <strong class="source-inline">@Status</strong> annotation is for the <strong class="source-inline">GET</strong> operation and <strong class="source-inline">@Forget</strong> for the <strong class="source-inline">DELETE</strong> operation. Let's <a id="_idIndexMarker1214"/>go through this code snippet to explain these annotations further:</p>
			<p class="source-code">    @LRA(value = LRA.Type.REQUIRED, end=false)</p>
			<p class="source-code">    @POST</p>
			<p class="source-code">    @Path("/book")</p>
			<p class="source-code">    public Response  bookHotel(@HeaderParam</p>
			<p class="source-code">      (LRA_HTTP_CONTEXT_HEADER) String lraId)   {</p>
			<p class="source-code">        // code</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Complete</p>
			<p class="source-code">    @Path("/complete")</p>
			<p class="source-code">    @PUT</p>
			<p class="source-code">    public Response completeBooking(@HeaderParam       (LRA_HTTP_CONTEXT_HEADER) String lraId,         String userData) {</p>
			<p class="source-code">        //code</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Compensate</p>
			<p class="source-code">    @Path("/compensate")</p>
			<p class="source-code">    @PUT</p>
			<p class="source-code">    public Response cancelBooking(@HeaderParam       (LRA_HTTP_CONTEXT_HEADER) String lraId,         String userData) {</p>
			<p class="source-code">        //code</p>
			<p class="source-code">    }</p>
			<p>In the code snippet, when the <strong class="source-inline">bookHotel()</strong>method is called inside an LRA, this method will run with the same LRA context. If it is called outside an LRA context, the method will run with a new context. This method might call in to another service. If this method succeeds, the <strong class="source-inline">completeBooking()</strong> method will be invoked. Otherwise, the <strong class="source-inline">cancelBooking()</strong>method will be invoked. You might be wondering which service calls the <strong class="source-inline">completeBooking()</strong> and <strong class="source-inline">cancelBooking()</strong>methods. It's the job of the LRA coordinator, which will ensure the corresponding method is invoked. In the next section, we will <a id="_idIndexMarker1215"/>discuss how to make the APIs from LRA available to your Maven and Gradle projects.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor218"/>Making MicroProfile LRA available</h2>
			<p>To use the <a id="_idIndexMarker1216"/>MicroProfile LRA APIs, you need to make these APIs available to your application. If you create a Maven project, you can directly add the following to your <strong class="source-inline">pom.xml</strong>:</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">  &lt;groupId&gt;org.eclipse.microprofile.lra&lt;/groupId&gt;</p>
			<p class="source-code">  &lt;artifactId&gt;microprofile-lra-api&lt;/artifactId&gt;</p>
			<p class="source-code">  &lt;version&gt;1.0&lt;/version&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>Alternatively, if you create a Gradle project, you need to add the following dependency:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">  providedCompile org.eclipse.microprofile.lra     :microprofile-lra-api:1.0</p>
			<p class="source-code">}</p>
			<p>With this, you have learned how to perform transactions in your cloud-native application. Congratulations! You have now learned about all the MicroProfile specifications. In the next section, let's discuss how best to use the latest MicroProfile platform <a id="_idIndexMarker1217"/>release. </p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor219"/>Using the latest MicroProfile platform release</h1>
			<p>In <a href="B17377_02_Final_SB_epub.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">How Does MicroProfile Fit Into Cloud-Native Application Development?</em>, we<a id="_idIndexMarker1218"/> mentioned the MicroProfile platform release and its content. So far, the latest MicroProfile platform release is MicroProfile 4.1, which can be found at <a href="https://download.eclipse.org/microprofile/microprofile-4.1/">https://download.eclipse.org/microprofile/microprofile-4.1/</a>. </p>
			<p>MicroProfile 4.1 was built on top of MicroProfile 4.0, with MicroProfile Health updating from 3.0 to 3.1. MicroProfile 4.1 aligns with the following Jakarta EE 8 specifications:</p>
			<ul>
				<li>Jakarta Contexts and Dependency Injection 2.0</li>
				<li>Jakarta Annotations 1.3, Jakarta RESTful Web Services 2.1</li>
				<li>Jakarta JSON-B 1.0</li>
				<li>Jakarta JSON-P 1.1</li>
				<li>Jakarta Annotations 1.3</li>
			</ul>
			<p>It also includes the following MicroProfile specifications: </p>
			<ul>
				<li>Config 2.0</li>
				<li>Fault Tolerance 3.0</li>
				<li>Health 3.1 </li>
				<li>JWT Propagation 1.2 </li>
				<li>Metrics 3.0 </li>
				<li>OpenAPI 2.0 </li>
				<li>OpenTracing 2.0 </li>
				<li>Rest Client 2.0</li>
			</ul>
			<p>If you want to use a few of the MicroProfile specifications from MicroProfile 4.1 for your cloud-native applications, you need to follow these steps:</p>
			<ol>
				<li>Make the APIs from MicroProfile 4.1 available for compiling your cloud-native applications.</li>
				<li>If you build a Maven project, add the following dependency in your <strong class="source-inline">pom.xml</strong> to make the<a id="_idIndexMarker1219"/> APIs available to your cloud-native applications:<p class="source-code">&lt;dependency&gt;</p><p class="source-code">    &lt;groupId&gt;org.eclipse.microprofile&lt;/groupId&gt;</p><p class="source-code">    &lt;artifactId&gt;microprofile&lt;/artifactId&gt;</p><p class="source-code">    &lt;version&gt;4.1&lt;/version&gt;</p><p class="source-code">    &lt;type&gt;pom&lt;/type&gt;</p><p class="source-code">    &lt;scope&gt;provided&lt;/scope&gt;</p><p class="source-code">&lt;/dependency&gt;</p><p>Alternatively, specify the following dependency for your Gradle projects:</p><p class="source-code">dependencies {</p><p class="source-code">providedCompile org.eclipse.microprofile   :microprofile:4.1</p><p class="source-code">}</p></li>
				<li>Choose a MicroProfile 4.1 implementation to run your cloud-native applications.<p>Open Liberty was used as the compatible implementation to release MicroProfile 4.1. Open Liberty, as mentioned in <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">The MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes,</em> is a very lightweight and performant runtime for supporting MicroProfile specifications. It is also a composable runtime. Specifying the following MicroProfile 4.1 feature in your <strong class="source-inline">server.xml</strong> causes the implementation of MicroProfile 4.1 to be loaded:</p><p class="source-code">&lt;feature&gt;microProfile-4.1&lt;/feature&gt;</p></li>
				<li>To use the standalone specifications, such as MicroProfile GraphQL, MicroProfile Context Propagation, MicroProfile Reactive Messaging, and MicroProfile LRA, you will need to specify the relevant API Maven dependencies as mentioned in the previous chapters and then include the corresponding feature elements in your <strong class="source-inline">server.xml</strong>, as shown next. The following line pulls in the implementation of MicroProfile GraphQL 1.0:<p class="source-code">&lt;feature&gt;mpGraphQL-1.0&lt;/feature&gt;</p><p>This line enables the support of MicroProfile Context Propagation 1.2:</p><p class="source-code">&lt;feature&gt;mpContextPropagation-1.2&lt;/feature&gt;</p><p>This line <a id="_idIndexMarker1220"/>pulls in the implementation of MicroProfile Reactive Messaging 1.0:</p><p class="source-code">&lt;feature&gt;mpReactiveMessaging-1.0&lt;/feature&gt;</p><p>This line enables MicroProfile LRA participants of MicroPorfile LRA 1.0:</p><p class="source-code">&lt;feature&gt;mpLRA-1.0&lt;/feature&gt;</p><p>This line enables the MicroProfile LRA coordinator of MicroProfile LRA 1.0:</p><p class="source-code">&lt;feature&gt;mpLRACoordinator-1.0&lt;/feature&gt;</p><p>The support for MicroProfile LRA 1.0 is available in the Open Liberty beta driver from 20.0.0.12-beta onward.</p></li>
			</ol>
			<p>With this, you have gained up-to-date information about MicroProfile. In the next section, we will discuss the future roadmap for MicroProfile.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor220"/>MicroProfile's technical roadmap</h1>
			<p>MicroProfile<a id="_idIndexMarker1221"/> is used to define a programming model for developing cloud-native applications. It helps to establish a great ecosystem using different cloud infrastructure technologies. These cloud infrastructure technologies include some cloud-native frameworks such as Kubernetes, Jaeger, Prometheus, Grafana, and OpenTelemetry. Kubernetes, Jaeger, Prometheus, and Grafana are mature technologies, and you probably know about them already. You might not know a great deal about OpenTelemetry. OpenTelemetry is a new sandbox project<a id="_idIndexMarker1222"/> from the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>), and we will spend some time<a id="_idIndexMarker1223"/> explaining it a bit.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor221"/>Adopting OpenTelemetry in MicroProfile</h2>
			<p><strong class="bold">OpenTelemetry </strong>(<a href="https://opentelemetry.io/">https://opentelemetry.io/</a>) is<a id="_idIndexMarker1224"/> a<a id="_idIndexMarker1225"/> new CNCF observability framework developed <a id="_idIndexMarker1226"/>by<a id="_idIndexMarker1227"/> merging of <strong class="bold">OpenTracing </strong>(<a href="https://opentracing.io/">https://opentracing.io/</a>) and <strong class="bold">OpenCensus </strong>(<a href="https://opencensus.io/">https://opencensus.io/</a>). Since<a id="_idIndexMarker1228"/> MicroProfile OpenTracing, covered in <a href="B17377_06_Final_SB_epub.xhtml#_idTextAnchor123"><em class="italic">Chapter 6</em></a>, <em class="italic">Observing and Monitoring Cloud-Native Applications</em>, was based on OpenTracing, OpenTelemetry was bound to be adopted by MicroProfile eventually. </p>
			<p>A lot of effort has been gone to in the MicroProfile community to investigate how to utilize OpenTelemetry in MicroProfile. One suggestion is to continue supporting the OpenTracing API, but its implementation adopts OpenTelemetry by using the following code snippet to transform an OpenTelemetry tracer to an OpenTracing tracer:</p>
			<p class="source-code">io.opentracing.Tracer tracer =   TracerShim.createTracerShim(openTelemetryTracer);</p>
			<p>With the tracer transformation, the current MicroProfile OpenTracing should be able to continue working. However, the OpenTracing Tracer API won't be maintained anymore because the community has moved to working on OpenTelemetry APIs. The ultimate goal is to expose the Tracer API (<strong class="source-inline">io.opentelemetry.api.trace.Tracer</strong>) from OpenTelemetry. The MicroProfile community is trying to find the best way of adopting OpenTelemetry. </p>
			<p>You might be aware that OpenTelemetry also provides metrics support. Do we need to pull OpenTelemetry metrics to MicroProfile? This is an open question. Let's discuss the future roadmap of MicroProfile Metrics in the next section.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor222"/>What is the future of MicroProfile Metrics?</h2>
			<p><strong class="bold">MicroProfile Metrics</strong>, explained <a id="_idIndexMarker1229"/>in <a href="B17377_06_Final_SB_epub.xhtml#_idTextAnchor123"><em class="italic">Chapter 6</em></a>, <em class="italic">Observing and Monitoring Cloud-Native Applications</em>, was based on <strong class="bold">Dropwizard</strong> (<a href="https://www.dropwizard.io/en/latest/">https://www.dropwizard.io/en/latest/</a>), a Java framework for developing ops-friendly, high-performance, RESTful web services. Dropwizard has been very popular in the past few years. However, recently, <strong class="bold">Micrometer </strong>(<a href="https://micrometer.io/">https://micrometer.io/</a>) has gained more momentum and <a id="_idIndexMarker1230"/>become a prominent metrics framework. The MicroProfile Metrics specification team is investigating how to adopt Micrometer while keeping the current APIs working with either Micrometer or Dropwizard. </p>
			<p>As mentioned previously, OpenTelemetry also contains metrics support. The other suggestion is for MicroProfile Metrics to align with OpenTelemetry Metrics. If OpenTelemetry Metrics is the new metrics standard in the future, MicroProfile should adopt OpenTelemetry Metrics instead. So, MicroProfile offers two metrics candidates to choose from. Now, the question arises: <em class="italic">Which one should you choose</em>? It depends on which one will become the mainstream. The ideal situation is that Micrometer integrates with OpenTelemetry. if Micrometer integrates well with OpenTelemetry Metrics, adopting Micrometer would naturally align with OpenTelemetry Metrics. Maybe MicroProfile Metrics should wait for OpenTelemetry Metrics to settle and then work out which <a id="_idIndexMarker1231"/>framework to adopt.</p>
			<p>Apart from the existing MicroProfile specifications, the MicroProfile community is also interested in new initiatives, such as gRPC.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor223"/>Adopting gPRC</h2>
			<p>Apart <a id="_idIndexMarker1232"/>from<a id="_idIndexMarker1233"/> the evolution of the current MicroProfile specifications, the community is interested in adopting new technologies to provide better support in cloud-native applications. One potential new specification is gRPC.</p>
			<p><strong class="bold">gRPC</strong> (<a href="https://grpc.io/">https://grpc.io/</a>) is a <a id="_idIndexMarker1234"/>modern high-performance <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>) framework<a id="_idIndexMarker1235"/> that can run in any environment. To make gRPC easier to use in cloud-native applications, it would be great if it can be integrated with CDI, JAX-RS, and so on. If MicroProfile adopts gRPC to create a new specification MicroProfile gRPC, this specification will be able to work closely and seamlessly with other MicroProfile specifications. </p>
			<p>Now that we have discussed the specification updates, we will discuss MicroProfile alignment with Jakarta EE releases.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor224"/>MicroProfile and Jakarta EE alignment</h2>
			<p>MicroProfile<a id="_idIndexMarker1236"/> adopts a few Jakarta EE technologies, such as CDI, JAX-RS, JSON-B, JSON-P, and Common Annotations. MicroProfile 4.0 and 4.1 align with the Jakarta EE 8 release. This book is based on the MicroProfile 4.1 release. MicroProfile has been working very closely with Jakarta EE. Most major players in MicroProfile are also involved in Jakarta EE. MicroProfile and Jakarta EE form a great ecosystem for developing cloud-native applications. It is very important that they always keep in sync and are compatible with each other. Jakarta EE 9.1 (<a href="https://jakarta.ee/release/9.1/">https://jakarta.ee/release/9.1/</a>) was released in 2021, which adds a requirement for MicroProfile to work with this release so that end users can use APIs from both frameworks. Due to this requirement, we will discuss MicroProfile 5.0 in the next section, which<a id="_idIndexMarker1237"/> is planned to align with Jakarta EE 9.1. </p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor225"/>Aligning MicroProfile 5.0 with Jakarta EE 9.1</h2>
			<p>The focus<a id="_idIndexMarker1238"/> of <a id="_idIndexMarker1239"/>MicroProfile 5.0 is to align with Jakarta EE 9.1. The eight component specifications, including Config, Fault Tolerance, Rest Client, Health, Metrics, OpenTracing, OpenAPI, and JWT Propagation, need to be updated so that they are aligned with Jakarta EE 9.1. Some of these specifications do not directly depend on the Jakarta specifications in their APIs, but their <strong class="bold">Technology Compatibility Kits</strong> (<strong class="bold">TCKs</strong>) pull in <a id="_idIndexMarker1240"/>Jakarta specifications. For these specifications, only a minor release is needed. To make all the MicroProfile specifications work with Jakarta 9.1, the specifications under the standalone releases such as Reactive Streams Operators, Reactive Messaging, LRA, GraphQL, and Context Propagation all need to be updated to align with Jakarta EE 9.1. </p>
			<p>Apart from the alignment with Jakarta EE, some of the MicroProfile specifications extend the current Jakarta specifications. Since these MicroProfile specifications were created while Java EE was stagnant, it might be the right time for these MicroProfile specifications to become Jakarta specifications so that other Jakarta specifications can benefit from them. Let's look at those specifications. </p>
			<h3>Moving some MicroProfile specifications to Jakarta EE</h3>
			<p>Some Jakarta<a id="_idIndexMarker1241"/> EE <a id="_idIndexMarker1242"/>specifications, such as <strong class="bold">Jakarta NoSQL</strong> (GitHub<a id="_idIndexMarker1243"/> repository: <a href="https://github.com/eclipse-ee4j/nosql">https://github.com/eclipse-ee4j/nosql</a>), would benefit from MicroProfile Config for configuration. If Jakarta EE depended on MicroProfile, this would create a circular dependency as MicroProfile aligns with Jakarta EE specifications. The other problem is that Jakarta EE specifications have traditionally maintained backward compatibility more carefully, while MicroProfile specifications can introduce backward-incompatibility changes from time to time. Therefore, it might be problematic for Jakarta EE specifications to directly depend on MicroProfile specifications. To solve this problem, a new proposal, <strong class="bold">Jakarta Config</strong>, was put forward to collaborate with MicroProfile Config. Jakarta Config (GitHub repository: <a href="https://github.com/eclipse-ee4j/config">https://github.com/eclipse-ee4j/config</a>) could become the centerpiece of Jakarta EE. Jakarta Config aims to be included in Jakarta Core Profile so that other profiles and MicroProfile can depend on this specification. </p>
			<p>Apart from alignment with Jakarta EE, MicroProfile is also trying to adopt <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>) Java<a id="_idIndexMarker1244"/> releases such as Java 11 and Java 17. </p>
			<p>You might still remember the two releases in MicroProfile: platform and standalone. The <a id="_idIndexMarker1245"/>MicroProfile community needs to look at the specifications included in the standalone release to see whether it is time to move some specifications back to the platform release bucket. The other area the MicroProfile community needs to improve is the end-user experience. The MicroProfile community will continue improving its entry page (<a href="https://microprofile.io/">https://microprofile.io/</a>). </p>
			<p>We can't believe that we have reached the end of this book. There are so many topics to cover. For further information on MicroProfile, please go to <a href="https://microprofile.io/">https://microprofile.io/</a>. If you would like to learn about anything related to MicroProfile, please visit the Open Liberty guides (<a href="https://openliberty.io/guides/">https://openliberty.io/guides/</a>). </p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor226"/>Summary</h1>
			<p>With that, we come to the end of this book. Let's revisit what you have learned. Throughout this book, we learned how to create cloud-native applications using Jakarta REST, JSON-P, JSON-B, CDI, and the MicroProfile Rest Client; then enhance cloud-native applications using MicroProfile Config, Fault Tolerance, Open API, and JWT Propagation; and finally monitor cloud-native applications using MicroProfile Health, Metrics, and Open Tracing. We then learned about the MicroProfile ecosystem with Open Liberty, Docker, Kubernetes, and Istio. After we covered all the technologies, we then looked at an end-to-end project that utilized different MicroProfile technologies. Afterward, we discussed deployment and day 2 operations. We then looked at the standalone specifications: MicroProfile GraphQL, MicroProfile Context Propagation, and MicroProfile Reactive Messaging.</p>
			<p>In this final chapter, we discussed the latest release of MicroProfile LRA 1.0. We then discussed the future roadmap in MicroProfile, followed by the plan with Jakarta EE alignment. The takeaway from this chapter is that MicroProfile and Jakarta EE are complementary to each other, and they form a great ecosystem that supports cloud-native applications.</p>
			<p>We hope you have enjoyed reading this book and learned how to use the amazing features of MicroProfile to help you with your cloud-native application development, deployment, and management. If you would like to contribute to MicroProfile, please click on the <strong class="bold">Join The Discussion</strong> link on the microprofile.io website (<a href="https://microprofile.io/">https://microprofile.io/</a>) to express your interest in being on the mailing list.</p>
		</div>
	</body></html>