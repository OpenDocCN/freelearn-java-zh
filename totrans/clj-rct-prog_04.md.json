["```java\n(defn do-something-important []\n  (let [f (future (do (prn \"Calculating...\")\n                      (Thread/sleep 10000)))]\n    (prn \"Perhaps the future has done its job?\")\n    (prn @f)\n    (prn \"You will only see this in about 10 seconds...\")))\n\n(do-something-important)\n```", "```java\n(defn do-something-important [callback]\n  (let [f (future (let [answer 42]\n                    (Thread/sleep 10000)\n                    (callback answer)))]\n    (prn \"Perhaps the future has done its job?\")\n    (prn \"You should see this almost immediately and then in 10 secs...\")\n     f))\n\n(do-something-important (fn [answer]\n                          (prn \"Future is done. Answer is \" answer)))\n```", "```java\nhttp.get('api/users/find?name=' + name, function(user){\n  http.get('api/orders?userId=' + user.id, function(orders){\n    orders.forEach(function(order){\n      container.append(order);\n    });\n  });\n});\n```", "```java\nhttp.get('api/users/find?name=' + name)\n  .then(function(user){\n    return http.get('api/orders?userId=' + user.id);\n  })\n  .then(function(orders){\n    orders.forEach(function(order){\n      container.append(order);\n    });\n  });  \n```", "```java\nthen function is a public function of the promises API. It is definitely a step in the right direction as the code is composable and easier to read.\n```", "```java\nuser   = http.get('api/users/find?name=' + name);\norders = http.get('api/orders?userId=' + user.id);\norders.forEach(function(order){\n  container.append(order);\n});\n```", "```java\n(import 'java.util.concurrent.ArrayBlockingQueue)\n\n(defn producer [c]\n  (prn \"Taking a nap\")\n  (Thread/sleep 5000)\n  (prn \"Now putting a name in queue...\")\n  (.put c \"Leo\"))\n\n(defn consumer [c]\n  (prn \"Attempting to take value from queue now...\")\n  (prn (str \"Got it. Hello \" (.take c) \"!\")))\n\n(def chan (ArrayBlockingQueue. 10))\n\n(future (consumer chan))\n(future (producer chan))\n```", "```java\n\"Attempting to take value from queue now...\"\n\"Taking a nap\"\n;; then 5 seconds later\n\"Now putting a name in que queue...\"\n\"Got it. Hello Leo!\"\n\n```", "```java\n[org.clojure/core.async \"0.1.278.0-76b25b-alpha\"]\n```", "```java\n(ns core-async-playground.core\n (:require [clojure.core.async :refer [go chan <! >! timeout]]))\n\n(defn prn-with-thread-id [s]\n (prn (str s \" - Thread id: \" (.getId (Thread/currentThread)))))\n\n(defn producer [c]\n (go (prn-with-thread-id \"Taking a nap \")\n (<! (timeout 5000))\n (prn-with-thread-id \"Now putting a name in que queue...\")\n (>! c \"Leo\")))\n\n(defn consumer [c]\n (go (prn-with-thread-id \"Attempting to take value from queue now...\")\n (prn-with-thread-id (str \"Got it. Hello \" (<! c) \"!\"))))\n\n(def c (chan))\n\n(consumer c)\n(producer c)\n\n```", "```java\n\"Attempting to take value from queue now... - Thread id: 43\"\n\"Taking a nap  - Thread id: 44\"\n\"Now putting a name in que queue... - Thread id: 48\"\n\"Got it. Hello Leo! - Thread id: 48\"\n\n```", "```java\n  :dependencies [[org.clojure/clojure \"1.5.1\"]\n                 [org.clojure/core.async \"0.1.278.0-76b25b-alpha\"]\n                 [seesaw \"1.4.4\"]]\n```", "```java\n(ns core-async-playground.stock-market\n  (:require [clojure.core.async\n             :refer [go chan <! >! timeout go-loop map>] :as async])\n  (:require [clojure.core.async.lab :refer [broadcast]])\n  (:use [seesaw.core]))\n```", "```java\n(native!)\n\n(def main-frame (frame :title \"Stock price monitor\"\n                       :width 200 :height 100\n                       :on-close :exit))\n\n(def price-label       (label \"Price: -\"))\n(def running-avg-label (label \"Running average: -\"))\n\n(config! main-frame :content\n         (border-panel\n          :north  price-label\n          :center running-avg-label\n          :border 5))\n\n(defn share-price [company-code]\n  (Thread/sleep 200)\n  (rand-int 1000))\n\n(defn avg [numbers]\n  (float (/ (reduce + numbers)\n            (count numbers))))\n\n(defn roll-buffer [buffer val buffer-size]\n  (let [buffer (conj buffer val)]\n    (if (> (count buffer) buffer-size)\n      (pop buffer)\n      buffer)))\n\n(defn make-sliding-buffer [buffer-size]\n  (let [buffer (atom clojure.lang.PersistentQueue/EMPTY)]\n    (fn [n]\n      (swap! buffer roll-buffer n buffer-size))))\n\n(def sliding-buffer (make-sliding-buffer 5))\n```", "```java\n(defn broadcast-at-interval [msecs task & ports]\n  (go-loop [out (apply broadcast ports)]\n    (<! (timeout msecs))\n    (>! out (task))\n    (recur out)))\n\n(defn -main [& args]\n  (show! main-frame)\n  (let [prices-ch         (chan)\n        sliding-buffer-ch (map> sliding-buffer (chan))]\n    (broadcast-at-interval 500 #(share-price \"XYZ\") prices-ch sliding-buffer-ch)\n    (go-loop []\n      (when-let [price (<! prices-ch)]\n        (text! price-label (str \"Price: \" price))\n        (recur)))\n    (go-loop []\n      (when-let [buffer (<! sliding-buffer-ch)]\n        (text! running-avg-label (str \"Running average: \" (avg buffer)))\n        (recur)))))\n```", "```java\n...\n  (let [prices-ch         (chan)\n        sliding-buffer-ch (map> sliding-buffer (chan))]\n...\n```", "```java\n(def c (map> sliding-buffer (chan 10)))\n(go (doseq [n (range 10)]\n (>! c n)))\n(go (doseq [n (range 10)]\n (prn  (vec (<! c)))))\n\n;; [0]\n;; [0 1]\n;; [0 1 2]\n;; [0 1 2 3]\n;; [0 1 2 3 4]\n;; [1 2 3 4 5]\n;; [2 3 4 5 6]\n;; [3 4 5 6 7]\n;; [4 5 6 7 8]\n;; [5 6 7 8 9]\n\n```", "```java\n$ lein run -m core-async-playground.stock-market\n\n```", "```java\n(defn get-data []\n  (throw (Exception. \"Bad things happen!\")))\n\n(defn process []\n  (let [result (chan)]\n    ;; do some processing...\n    (go (>! result (get-data)))\n    result))\n```", "```java\n`get-data` simulates a function that fetches data from the network or an in-memory cache. In this case it simply throws an exception.`process` is a function that depends on `get-data` to do something interesting and puts the result into a channel, which is returned at the end.\n```", "```java\n (go (let [result  (<! (->> (process \"data\")\n                           (map> #(* % %))\n                           (map> #(prn %))))]\n      (prn \"result is: \" result)))\n```", "```java\n(defn throw-err [e]\n  (when (instance? Throwable e) (throw e))\n  e)\n\n(defmacro <? [ch]\n  `(throw-err (async/<! ~ch)))\n```", "```java\n(defn process []\n  (let [result (chan)]\n    ;; do some processing...\n    (go (>! result (try (get-data)\n                        (catch Exception e\n                          e))))\n    result))\n```", "```java\n(go (try (let [result  (<? (->> (process \"data\")\n (map> #(* % %))\n (map> #(prn %))))]\n (prn \"result is: \" result))\n (catch Exception e\n (prn \"Oops, an error happened! We better do something about it here!\"))))\n;; \"Oops, an error happened! We better do something about it here!\"\n\n```", "```java\n(def result (chan (buffer 5)))\n(go-loop []\n (<! (async/timeout 1000))\n (when-let [x (<! result)]\n (prn \"Got value: \" x)\n (recur)))\n\n(go  (doseq [n (range 5)]\n (>! result n))\n (prn \"Done putting values!\")\n (close! result))\n\n;; \"Done putting values!\"\n;; \"Got value: \" 0\n;; \"Got value: \" 1\n;; \"Got value: \" 2\n;; \"Got value: \" 3\n;; \"Got value: \" 4\n\n```", "```java\n(def result (chan (buffer 2)))\n(go-loop []\n (<! (async/timeout 1000))\n (when-let [x (<! result)]\n (prn \"Got value: \" x)\n (recur)))\n\n(go  (doseq [n (range 5)]\n (>! result n))\n (prn \"Done putting values!\")\n (close! Result))\n;; \"Got value: \" 0\n;; \"Got value: \" 1\n;; \"Got value: \" 2\n;; \"Done putting values!\"\n;; \"Got value: \" 3\n;; \"Got value: \" 4\n\n```", "```java\n(def result (chan (dropping-buffer 2)))\n(go-loop []\n (<! (async/timeout 1000))\n (when-let [x (<! result)]\n (prn \"Got value: \" x)\n (recur)))\n\n(go  (doseq [n (range 5)]\n (>! result n))\n (prn \"Done putting values!\")\n (close! result))\n\n;; \"Done putting values!\"\n;; \"Got value: \" 0\n;; \"Got value: \" 1\n\n```", "```java\n(def result (chan (sliding-buffer 2)))\n(go-loop []\n (<! (async/timeout 1000))\n (when-let [x (<! result)]\n (prn \"Got value: \" x)\n (recur)))\n\n(go  (doseq [n (range 5)]\n (>! result n))\n (prn \"Done putting values!\")\n (close! result))\n\n;; \"Done putting values!\"\n;; \"Got value: \" 3\n;; \"Got value: \" 4\n\n```", "```java\n$ lein new core-async-transducers\n\n```", "```java\n...\n  :dependencies [[org.clojure/clojure \"1.7.0-alpha5\"]\n                 [org.clojure/core.async \"0.1.346.0-17112a-alpha\"]]\n...\n```", "```java\n$ lein repl\nuser> (require '[clojure.core.async :refer [go chan map< filter< into >! <! go-loop close! pipe]])\n\n```", "```java\n(->> (range 10)\n (map inc)           ;; creates a new sequence\n (filter even?)      ;; creates a new sequence\n (prn \"result is \"))\n;; \"result is \" (2 4 6 8 10)\n\n```", "```java\nIn the previous example, we ended up with three in total: the one created by range, the one created by map, and finally the one created by filter. Most of the time, this won't really be an issue but for large sequences this means a lot of unnecessary allocation.\n```", "```java\n(def xform\n (comp (map inc)\n (filter even?)))  ;; no intermediate sequence created\n\n(->> (range 10)\n (sequence xform)\n (prn \"result is \"))\n;; \"result is \" (2 4 6 8 10)\n\n```", "```java\n(def xform\n (comp (map inc)\n (filter even?)))\n\n```", "```java\n(->> (range 10)\n (sequence xform)\n (prn \"result is \"))\n;; \"result is \" (2 4 6 8 10)\n\n```", "```java\n(def result (chan 10))\n\n(def transformed\n  (->> result\n       (map< inc)      ;; creates a new channel\n       (filter< even?) ;; creates a new channel\n       (into [])))     \n\n(go\n  (prn \"result is \" (<! transformed)))\n\n(go\n  (doseq [n (range 10)]\n    (>! result n))\n  (close! result))\n\n;; \"result is \" [2 4 6 8 10] \n```", "```java\n(def result (chan 10))\n\n(def xform \n     (comp (map inc)\n           (filter even?)))  ;; no intermediate channels created\n\n(def transformed (->> (pipe result (chan 10 xform))\n                      (into [])))\n\n(go\n  (prn \"result is \" (<! transformed)))\n\n(go\n  (doseq [n (range 10)]\n    (>! result n))\n  (close! result))\n\n;; \"result is \" [2 4 6 8 10]\n\n```"]