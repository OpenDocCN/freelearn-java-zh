<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-217"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.2.1">Deployment of Web Services</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, you will learn about the fundamentals of containerization, Docker, and Kubernetes. </span><span class="koboSpan" id="kobo.3.2">You will then use these concepts to containerize a sample e-commerce app using Docker. </span><span class="koboSpan" id="kobo.3.3">This container will then be deployed aws a Kubernetes cluster. </span><span class="koboSpan" id="kobo.3.4">You will use Minikube for Kubernetes, which makes learning and Kubernetes-based </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">development easier.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">After completing this chapter, you will be able to perform containerization and container deployment in a </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, you’ll explore the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Exploring the fundamentals </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of containerization</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Building a </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Docker image</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Deploying an application </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">in Kubernetes</span></span></li>
</ul>
<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">You will need the following to develop and execute the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Docker (the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">container engine)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Kubernetes (Minikube)</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">An internet connection to clone the code (</span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09</span></a><span class="koboSpan" id="kobo.23.1">) and download the dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">and Gradle</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Insomnia/cURL or any API client for </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">API testing</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Let’s begin!</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.28.1">What is containerization?</span></h1>
<p><span class="koboSpan" id="kobo.29.1">One problem that’s encountered</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.30.1"> frequently by teams while developing large, complex systems is that the code that works on one machine doesn’t work on another. </span><span class="koboSpan" id="kobo.30.2">The main reason behind these kinds of scenarios is a mismatch of dependencies (such as different versions of Java, a certain web server, or OS), configurations, </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">or files.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">Also, setting up a new environment to deploy new products sometimes takes a day or more. </span><span class="koboSpan" id="kobo.32.2">This is unacceptable in today’s environment and slows down your development turnaround. </span><span class="koboSpan" id="kobo.32.3">These kinds of issues can be solved by containerizing </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">In containerization, an application is bundled, configured, and wrapped with all the required dependencies and files. </span><span class="koboSpan" id="kobo.34.2">This bundle can then be run on any machine that supports the containerization process. </span><span class="koboSpan" id="kobo.34.3">This bundling ensures that the application displays the exact same behavior in all environments. </span><span class="koboSpan" id="kobo.34.4">As a result, bugs related to misconfigurations or dependencies can be resolved, and the deployment time can be reduced to a few minutes </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">or less.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">This bundle, which sits on top of a physical machine and its OS, is called a container. </span><span class="koboSpan" id="kobo.36.2">This container shares the kernel, as well as the libraries and binaries of its host OS, in read-only mode. </span><span class="koboSpan" id="kobo.36.3">Therefore, the container is lightweight. </span><span class="koboSpan" id="kobo.36.4">In this chapter, you will use Docker and Kubernetes for containerization and </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">container deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">A related concept is virtualization – the process of creating a virtual environment using the existing hardware system</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.39.1"> by splitting it into different parts. </span><span class="koboSpan" id="kobo.39.2">Each part acts as a separate, distinct, individual system. </span><span class="koboSpan" id="kobo.39.3">These systems are called </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">virtual machines</span></strong><span class="koboSpan" id="kobo.41.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.42.1">VMs</span></strong><span class="koboSpan" id="kobo.43.1">). </span><span class="koboSpan" id="kobo.43.2">Each VM runs on its own unique OS with its own binaries, libraries, and apps. </span><span class="koboSpan" id="kobo.43.3">VMs are heavyweight and can be many </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">gigabytes</span></strong><span class="koboSpan" id="kobo.45.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.46.1">GB</span></strong><span class="koboSpan" id="kobo.47.1">) in size. </span><span class="koboSpan" id="kobo.47.2">A hardware system can have VMs with different OSes, such as Unix, Linux, and Windows. </span><span class="koboSpan" id="kobo.47.3">The following diagram depicts</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.48.1"> the difference between</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.49.1"> VMs </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">and containers:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 9.1 – VMs versus containers" src="image/Figure_09.1_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 9.1 – VMs versus containers</span></p>
<p><span class="koboSpan" id="kobo.53.1">Sometimes, people think that virtualization and containerization are the same thing, but they are not. </span><span class="koboSpan" id="kobo.53.2">VMs are created on top of the host system, which shares its hardware with the VMs, whereas containers are executed as isolated processes on top of the hardware and its OS. </span><span class="koboSpan" id="kobo.53.3">Containers are lightweight and are only a few MB, sometimes GB, whereas VMs are heavyweight and many GB in size. </span><span class="koboSpan" id="kobo.53.4">Containers</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.54.1"> run faster than VMs, and they are also </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">more portable.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">We’ll explore containers in more detail by building a Docker image in the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">next section.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.58.1">Building a Docker image</span></h1>
<p><span class="koboSpan" id="kobo.59.1">At this point, you know</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.60.1"> the benefit of containerization and why it is becoming popular – you create an application, product, or service, bundle it using containerization, and give it to the QA team, customer, or DevOps team to run without </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">any issues.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">In this section, you’ll learn how to use Docker as a containerization platform. </span><span class="koboSpan" id="kobo.62.2">Let’s learn about it before creating a Docker image of a sample </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">e-commerce app.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.64.1">What is Docker?</span></h2>
<p><span class="koboSpan" id="kobo.65.1">Launched in 2013, Docker</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.66.1"> is a leading container platform and an open source project. </span><span class="koboSpan" id="kobo.66.2">Ten thousand developers tried it after its interactive tutorial was launched in August 2013. </span><span class="koboSpan" id="kobo.66.3">It was downloaded 2.75 million times by the time of its 1.0 release in June 2013. </span><span class="koboSpan" id="kobo.66.4">Many large corporations have signed a partnership agreement with Docker Inc., including Microsoft, Red Hat, HP, and OpenStack, as well as service providers such as AWS, IBM, </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">and Google.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Docker makes use of Linux kernel features to ensure resource isolation and the packaging of an application, along with its dependencies, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">cgroups</span></strong><span class="koboSpan" id="kobo.70.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">namespaces</span></strong><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">Everything in a Docker container </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.73.1">executes natively on the host and uses</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.74.1"> the host kernel</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.75.1"> directly. </span><span class="koboSpan" id="kobo.75.2">Each container has its own user namespace – a </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">process identifier</span></strong><span class="koboSpan" id="kobo.77.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.78.1">PID</span></strong><span class="koboSpan" id="kobo.79.1">) for process isolation, a </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">network</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">NET</span></strong><span class="koboSpan" id="kobo.83.1">) to manage network interfaces, </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">inter-process communication</span></strong><span class="koboSpan" id="kobo.85.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.86.1">IPC</span></strong><span class="koboSpan" id="kobo.87.1">) to manage access to IPC resources, a </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">mount point</span></strong><span class="koboSpan" id="kobo.89.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.90.1">MNT</span></strong><span class="koboSpan" id="kobo.91.1">) to manage filesystem mount points, and </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Unix Time Sharing</span></strong><span class="koboSpan" id="kobo.93.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.94.1">UTS</span></strong><span class="koboSpan" id="kobo.95.1">) namespaces to isolate kernel and version identifiers. </span><span class="koboSpan" id="kobo.95.2">This packaging</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.96.1"> of dependencies</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.97.1"> enables an application to run as expected across different Linux OSes and distributions by supporting a level </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">of portability.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Furthermore, this portability allows developers to develop an application in any language and then easily deploy it from any computer, such as a laptop, to different environments, such as test, stage, or production. </span><span class="koboSpan" id="kobo.99.2">Docker runs natively on Linux. </span><span class="koboSpan" id="kobo.99.3">However, you can also run Docker on Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">and macOS.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Containers are comprised of just an application and its dependencies, including the basic OS. </span><span class="koboSpan" id="kobo.101.2">This makes the application lightweight and efficient in terms of resource utilization. </span><span class="koboSpan" id="kobo.101.3">Developers and system administrators are interested in a container’s portability and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">resource utilization.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">We’ll explore Docker’s architecture in the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">next subsection.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.105.1">Understanding Docker’s architecture</span></h2>
<p><span class="koboSpan" id="kobo.106.1">As specified in its</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.107.1"> documentation, Docker</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.108.1"> uses a client-server architecture. </span><span class="koboSpan" id="kobo.108.2">The Docker client (</span><strong class="bold"><span class="koboSpan" id="kobo.109.1">Docker</span></strong><span class="koboSpan" id="kobo.110.1">) is basically a </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">command-line interface</span></strong><span class="koboSpan" id="kobo.112.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.113.1">CLI</span></strong><span class="koboSpan" id="kobo.114.1">) that is used by an end user; clients communicate back and forth with the Docker server (read as a Docker daemon). </span><span class="koboSpan" id="kobo.114.2">The Docker daemon does the heavy lifting, in that it builds, runs, and distributes your Docker containers. </span><span class="koboSpan" id="kobo.114.3">The Docker client and the daemon can run on the same system or </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">different machines.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">The Docker client</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.117.1"> and daemon communicate via sockets or through a RESTful API. </span><span class="koboSpan" id="kobo.117.2">Docker registers are public or private Docker image repositories that you can upload or download images from – for</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.118.1"> example, Docker Hub (</span><a href="http://hub.docker.com"><span class="koboSpan" id="kobo.119.1">hub.docker.com</span></a><span class="koboSpan" id="kobo.120.1">) is a public </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">Docker registry.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">The primary components of Docker are </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Docker image</span></strong><span class="koboSpan" id="kobo.125.1">: A Docker image is a read-only</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.126.1"> template. </span><span class="koboSpan" id="kobo.126.2">For example, an image can contain an Ubuntu OS with an Apache web server and your web application installed on it. </span><span class="koboSpan" id="kobo.126.3">Docker images are the building components of Docker, and images are used to create Docker containers. </span><span class="koboSpan" id="kobo.126.4">Docker provides a simple way to build new images or update existing images. </span><span class="koboSpan" id="kobo.126.5">You can also use images created by others and/or </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">extend them.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">Docker container</span></strong><span class="koboSpan" id="kobo.129.1">: A Docker container</span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.130.1"> is created from a Docker image. </span><span class="koboSpan" id="kobo.130.2">Docker works so that the container can only see its own processes, and it has its own filesystem layered on a host filesystem and a networking stack, which pipes to the host-networking stack. </span><span class="koboSpan" id="kobo.130.3">Docker containers can be run, started, stopped, moved, or deleted. </span><span class="koboSpan" id="kobo.130.4">Docker also provides commands such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">docker stats</span></strong><span class="koboSpan" id="kobo.132.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">docker events</span></strong><span class="koboSpan" id="kobo.134.1"> for container usage statics, such as CPU and memory usage, and for activities that are performed by the Docker daemons, respectively. </span><span class="koboSpan" id="kobo.134.2">These commands help you monitor Docker in a </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">deployed environment.</span></span></li>
</ul>
<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.136.1">Docker container life cycle</span></h2>
<p><span class="koboSpan" id="kobo.137.1">You also need to be aware</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.138.1"> of Docker’s container life cycle, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">as follows:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.140.1">Creates a container</span></strong><span class="koboSpan" id="kobo.141.1">: Docker creates a container from the Docker image using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.144.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.145.1">Runs the container</span></strong><span class="koboSpan" id="kobo.146.1">: Docker runs the container that was created in </span><em class="italic"><span class="koboSpan" id="kobo.147.1">step 1</span></em><span class="koboSpan" id="kobo.148.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.152.1">Pauses the container (optional)</span></strong><span class="koboSpan" id="kobo.153.1">: Docker pauses the process running inside the container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">pause</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Un-pauses the container (optional)</span></strong><span class="koboSpan" id="kobo.158.1">: Docker un-pauses the processes running inside the container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">unpause</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.162.1">Starts the container</span></strong><span class="koboSpan" id="kobo.163.1">: Docker starts the container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.167.1">Stops the container</span></strong><span class="koboSpan" id="kobo.168.1">: Docker stops the container and processes running inside the container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">stop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Restarts the container</span></strong><span class="koboSpan" id="kobo.173.1">: Docker restarts the container and processes running inside it, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">restart</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.177.1">Kills the container</span></strong><span class="koboSpan" id="kobo.178.1">: Docker kills the running container using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">kill</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Destroys the container</span></strong><span class="koboSpan" id="kobo.183.1">: Finally, Docker removes</span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.184.1"> the stopped containers using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">docker rm</span></strong><span class="koboSpan" id="kobo.186.1"> command. </span><span class="koboSpan" id="kobo.186.2">Therefore, this should only be performed for the containers in a </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">stopped state.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.188.1">At this point, you might be eager to use the Docker container life cycle, but first, you’ll need to install Docker by going </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">to </span></span><a href="https://docs.docker.com/get-docker/"><span class="No-Break"><span class="koboSpan" id="kobo.190.1">https://docs.docker.com/get-docker/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.191.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">Once you’ve installed Docker, go to </span><a href="https://docs.docker.com/get-started/#start-the-tutorial"><span class="koboSpan" id="kobo.193.1">https://docs.docker.com/get-started/#start-the-tutorial</span></a><span class="koboSpan" id="kobo.194.1"> to execute the first</span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.195.1"> Docker command. </span><span class="koboSpan" id="kobo.195.2">You can refer to </span><a href="https://docs.docker.com/engine/reference/commandline/docker/"><span class="koboSpan" id="kobo.196.1">https://docs.docker.com/engine/reference/commandline/docker/</span></a><span class="koboSpan" id="kobo.197.1"> to learn more about </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">Docker commands.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">For more information, you can look</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.200.1"> at the overview of Docker that is provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">Docker (</span></span><a href="https://docs.docker.com/get-started/overview/"><span class="No-Break"><span class="koboSpan" id="kobo.202.1">https://docs.docker.com/get-started/overview/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.203.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">Let’s make the necessary code changes so that we can create a Docker image for a sample </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">e-commerce app.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.206.1">Coding to build an image by adding the Actuator dependency</span></h2>
<p><span class="koboSpan" id="kobo.207.1">I advise you to refer</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.208.1"> back to </span><a href="B19349_08.xhtml#_idTextAnchor201"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.209.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.210.1">, </span><em class="italic"><span class="koboSpan" id="kobo.211.1">Testing APIs</span></em><span class="koboSpan" id="kobo.212.1">, as a basis</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.213.1"> for this chapter’s code. </span><span class="koboSpan" id="kobo.213.2">You don’t need any additional libraries to create a Docker image. </span><span class="koboSpan" id="kobo.213.3">However, you do need to add the Spring Boot Actuator dependency, which provides production-ready features for the sample e-commerce app </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">we’ll create.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">The dependency’s features help you to monitor</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.216.1"> and manage applications using HTTP REST APIs and </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">Java Management Extensions</span></strong><span class="koboSpan" id="kobo.218.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.219.1">JMX</span></strong><span class="koboSpan" id="kobo.220.1">). </span><span class="koboSpan" id="kobo.220.2">These endpoints can be found</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.221.1"> in their respective documentation (</span><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints"><span class="koboSpan" id="kobo.222.1">https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints</span></a><span class="koboSpan" id="kobo.223.1">). </span><span class="koboSpan" id="kobo.223.2">In this chapter, however, we will only use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">/actuator/health</span></strong><span class="koboSpan" id="kobo.225.1"> endpoint, which tells us about the application’s health status. </span><span class="koboSpan" id="kobo.225.2">For the purpose of this exercise, It is sufficient to find out the health of the services/applications running inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">Docker container.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">You can add Actuator by performing the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.229.1">Add the Actuator dependency to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1"> (</span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle"><span class="No-Break"><span class="koboSpan" id="kobo.232.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.233.1">):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.234.1">runtimeOnly 'org.springframework.boot:spring-boot-starter-actuator'</span></strong></pre></li> <li><span class="koboSpan" id="kobo.235.1">Next, you need to remove all security from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">/actuator</span></strong><span class="koboSpan" id="kobo.237.1"> endpoints. </span><span class="koboSpan" id="kobo.237.2">Let’s add a constant to </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Constants.java</span></strong><span class="koboSpan" id="kobo.239.1"> (</span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/Constants.java"><span class="koboSpan" id="kobo.240.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/Constants.java</span></a><span class="koboSpan" id="kobo.241.1">) for the Actuator URL, as </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">shown here:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.243.1">public static final String ACTUATOR_URL_PREFIX =</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.244.1">"/actuator/**";</span></strong></pre></li> <li><span class="koboSpan" id="kobo.245.1">Now, you can update the security configuration in </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">SecurityConfig.java</span></strong><span class="koboSpan" id="kobo.247.1"> (</span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/SecurityConfig.java"><span class="koboSpan" id="kobo.248.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/SecurityConfig.java</span></a><span class="koboSpan" id="kobo.249.1">), as </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
// rest of the codereq.requestMatchers(toH2Console()).permitAll()    .requestMatchers(new </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">AntPathRequestMatcher(</span></strong><span class="koboSpan" id="kobo.253.1">       </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">ACTUATOR_URL_PREFIX)).permitAll()</span></strong><span class="koboSpan" id="kobo.255.1">    .requestMatchers(new AntPathRequestMatcher      (TOKEN_URL, HttpMethod.POST.name())).permitAll()// rest of the code</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.256.1">With that, you have added a matcher with Actuator endpoints. </span><span class="koboSpan" id="kobo.256.2">This allows all Actuator endpoints to be accessed with and without authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">and authorization.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Now, you can configure</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.259.1"> the Spring Boot plugin’s task, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">bootBuildImage</span></strong><span class="koboSpan" id="kobo.261.1">, to customize the name</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.262.1"> of the Docker image. </span><span class="koboSpan" id="kobo.262.2">We will do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">next subsection.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.264.1">Configuring the Spring Boot plugin task</span></h2>
<p><span class="koboSpan" id="kobo.265.1">The Spring Boot Gradle plugin</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.266.1"> already provides</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.267.1"> a command (</span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">bootBuildImage</span></strong><span class="koboSpan" id="kobo.269.1">) to build Docker images. </span><span class="koboSpan" id="kobo.269.2">It becomes available when the Java plugin is applied in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">plugins</span></strong><span class="koboSpan" id="kobo.271.1"> section. </span><span class="koboSpan" id="kobo.271.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">bootBuildImage</span></strong><span class="koboSpan" id="kobo.273.1"> task is only available for building a </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">.jar</span></strong><span class="koboSpan" id="kobo.275.1"> file and is not available for building a </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">war</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">You can customize an image’s name by adding the following code block to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
bootBuildImage {   imageName = "192.168.1.2:5000/${project.name}:${
      project.version}"
}</span></pre>
<p><span class="koboSpan" id="kobo.283.1">Here, change the IP address and port of the local Docker registry. </span><span class="koboSpan" id="kobo.283.2">The configuration of the Docker registry is explained in the next section. </span><span class="koboSpan" id="kobo.283.3">A Docker image will be built based on your project’s name and version. </span><span class="koboSpan" id="kobo.283.4">The project version is already defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">build.gradle</span></strong><span class="koboSpan" id="kobo.285.1"> file’s top section. </span><span class="koboSpan" id="kobo.285.2">The project name, on the other hand, is picked from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">settings.gradle</span></strong><span class="koboSpan" id="kobo.287.1"> file (</span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle"><span class="koboSpan" id="kobo.288.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle</span></a><span class="koboSpan" id="kobo.289.1">). </span><span class="koboSpan" id="kobo.289.2">Let’s rename it, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
rootProject.name = 'packt-modern-api-development-chapter09'</span></pre> <p><span class="koboSpan" id="kobo.292.1">In </span><a href="B19349_08.xhtml#_idTextAnchor201"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.293.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.294.1">, </span><em class="italic"><span class="koboSpan" id="kobo.295.1">Testing APIs</span></em><span class="koboSpan" id="kobo.296.1">, the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">rootProject.name</span></strong><span class="koboSpan" id="kobo.298.1"> contains a capital letter, so the Docker image build failed. </span><span class="koboSpan" id="kobo.298.2">This is because the plugin has a validation check for capital letters. </span><span class="koboSpan" id="kobo.298.3">Therefore, Docker image names should only be </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">in lowercase.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">For more information and customization</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.301.1"> options, please refer to the plugin </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">documentation (</span></span><a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image"><span class="No-Break"><span class="koboSpan" id="kobo.303.1">https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.304.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Now that you have configured</span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.306.1"> the code, you can use this to build</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.307.1"> an image after configuring the Docker registry. </span><span class="koboSpan" id="kobo.307.2">You will do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">next subsection.</span></span></p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.309.1">Configuring the Docker registry</span></h2>
<p><span class="koboSpan" id="kobo.310.1">If you have Docker Desktop</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.311.1"> installed, by default, when you build an image (</span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">gradlew bootBuildImage</span></strong><span class="koboSpan" id="kobo.313.1">), it will be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">docker.io/library/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT</span></strong><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">Here, the name refers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">docker.io/library/packt-modern-api-development-chapter09</span></strong><span class="koboSpan" id="kobo.317.1"> and the version refers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">0.0.1-SNAPSHOT</span></strong><span class="koboSpan" id="kobo.319.1">. </span><span class="koboSpan" id="kobo.319.2">You may be wondering why the name is prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">docker.io/library</span></strong><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">This is because if you don’t specify the Docker registry, it takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">docker.io</span></strong><span class="koboSpan" id="kobo.323.1"> registry by default. </span><span class="koboSpan" id="kobo.323.2">You need a Docker registry where you can pull and push images from. </span><span class="koboSpan" id="kobo.323.3">It is like an artifact repository, where you push and pull artifacts such as </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">Spring libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Once the image has been built, you can push it to Docker Hub by applying your Docker Hub login credentials. </span><span class="koboSpan" id="kobo.325.2">Then, you can fetch the image from Docker Hub for deployment in your Kubernetes environment. </span><span class="koboSpan" id="kobo.325.3">For development purposes, this is not an ideal scenario. </span><span class="koboSpan" id="kobo.325.4">The best option is to configure the local Docker registry and then use it for </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">Kubernetes deployment.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.327.1">Using Git Bash on Windows</span></p>
<p class="callout"><span class="koboSpan" id="kobo.328.1">You can use Git Bash on Windows</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.329.1"> to run these commands; it emulates </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">Linux commands.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Let’s execute the following commands</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.332.1"> to check whether Docker is up </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">and running:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.334.1">
$ docker versionClient:
 Cloud integration: v1.0.22
 Version:           20.10.11
 API version:       1.41
 Go version:        go1.16.10
 Git commit:        dea9396
 Built:             Thu Nov 18 00:36:09 2021
 OS/Arch:           darwin/amd64
 Context:           default
 Experimental:      true
Server: Docker Engine – Community
 Engine:
  Version:          20.10.11
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.16.9
// Output truncated for brevity</span></pre>
<p><span class="koboSpan" id="kobo.335.1">Here, Docker is installed. </span><span class="koboSpan" id="kobo.335.2">Therefore, when you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">docker version</span></strong><span class="koboSpan" id="kobo.337.1">, it displays the output. </span><span class="koboSpan" id="kobo.337.2">A version output without any error confirms Docker is up </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">and running.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Now, you can pull and start the Docker registry by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.341.1">
$ docker run -d -p 5000:5000 -e REGISTRY_STORAGE_DELETE_ENABLED=true --restart=always --name registry registry:2Unable to find image 'registry:2' locally
2: Pulling from library/registry
ef5531b6e74e: Pull complete
a52704366974: Pull complete
dda5a8ba6f46: Pull complete
eb9a2e8a8f76: Pull complete
25bb6825962e: Pull complete
Digest: sha256:41f413c22d6156587e2a51f3e80c09808b8c70e82be149b82b5e01 96a88d49b4
Status: Downloaded newer image for registry:2
bca056bf9653abb14ee6c461612a999c7c61ab45ea8837ecfa1c4b1ec5e5f047</span></pre>
<p><span class="koboSpan" id="kobo.342.1">Here, when you run the Docker registry</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.343.1"> for the first time, it downloads the Docker registry image before running it. </span><span class="koboSpan" id="kobo.343.2">The execution of the Docker registry creates the container, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">registry</span></strong><span class="koboSpan" id="kobo.345.1">, on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">5000</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">If port </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">5000</span></strong><span class="koboSpan" id="kobo.349.1"> is used by other services in your machine, then you can use a different port such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">5001</span></strong><span class="koboSpan" id="kobo.351.1">. </span><span class="koboSpan" id="kobo.351.2">There are two port entries – one internal container port and another exposed external port. </span><span class="koboSpan" id="kobo.351.3">Both are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">5000</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">–restart=always</span></strong><span class="koboSpan" id="kobo.355.1"> flag tells Docker to start the registry container every time Docker is restarted. </span><span class="koboSpan" id="kobo.355.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">REGISTRY_STORAGE_DELETE_ENABLED</span></strong><span class="koboSpan" id="kobo.357.1"> flag, as its name suggests, is used to remove any images from </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">registry</span></strong><span class="koboSpan" id="kobo.359.1">, as it is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">true</span></strong><span class="koboSpan" id="kobo.361.1">. </span><span class="koboSpan" id="kobo.361.2">The default value of this flag </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Now, let’s check </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">the containers:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.367.1">
$ docker psCONTAINER ID   IMAGE        COMMAND
CREATED          STATUS          PORTS                    NAMES
bca056bf9653   registry:2   "/entrypoint.sh /etc…"
11 minutes ago   Up 11 minutes   0.0.0.0:5000-&gt;5000/tcp   registry</span></pre>
<p><span class="koboSpan" id="kobo.368.1">This shows that the Docker container registry is up and running and was created using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">registry:2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.370.1"> image.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">The host’s name is necessary when you’re using the containers. </span><span class="koboSpan" id="kobo.371.2">Therefore, you’ll use the IP number instead of the local hostname for the registry. </span><span class="koboSpan" id="kobo.371.3">This is because the container will refer to its localhost, rather than the localhost of your system when you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">localhost</span></strong><span class="koboSpan" id="kobo.373.1"> as the hostname. </span><span class="koboSpan" id="kobo.373.2">In a Kubernetes environment, you need to provide a registry host, so you will need to use the IP or a proper hostname in place </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">localhost</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">Let’s find out what IP we can use by running</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.378.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.380.1">
# For Mac$ echo $(osascript -e "Ipv4 address of (system info)")
</span><strong class="bold"><span class="koboSpan" id="kobo.381.1">192.168.1.2</span></strong><span class="koboSpan" id="kobo.382.1">
# For Windows
$ ipconfig
Windows IP Configuration
Ethernet adapter Ethernet:
  Media State . </span><span class="koboSpan" id="kobo.382.2">. </span><span class="koboSpan" id="kobo.382.3">. </span><span class="koboSpan" id="kobo.382.4">. </span><span class="koboSpan" id="kobo.382.5">. </span><span class="koboSpan" id="kobo.382.6">. </span><span class="koboSpan" id="kobo.382.7">. </span><span class="koboSpan" id="kobo.382.8">. </span><span class="koboSpan" id="kobo.382.9">. </span><span class="koboSpan" id="kobo.382.10">. </span><span class="koboSpan" id="kobo.382.11">. </span><span class="koboSpan" id="kobo.382.12">: Media disconnected
  Connection-specific DNS Suffix . </span><span class="koboSpan" id="kobo.382.13">:
Ethernet adapter vEthernet (Default Switch):
  Connection-specific DNS Suffix . </span><span class="koboSpan" id="kobo.382.14">:
  Link-local Ipv6 Address . </span><span class="koboSpan" id="kobo.382.15">. </span><span class="koboSpan" id="kobo.382.16">. </span><span class="koboSpan" id="kobo.382.17">. </span><span class="koboSpan" id="kobo.382.18">. </span><span class="koboSpan" id="kobo.382.19">: ef80::2099:f848:8903:f996%81
  </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">Ipv4 Address. </span><span class="koboSpan" id="kobo.383.2">. </span><span class="koboSpan" id="kobo.383.3">. </span><span class="koboSpan" id="kobo.383.4">. </span><span class="koboSpan" id="kobo.383.5">. </span><span class="koboSpan" id="kobo.383.6">. </span><span class="koboSpan" id="kobo.383.7">. </span><span class="koboSpan" id="kobo.383.8">. </span><span class="koboSpan" id="kobo.383.9">. </span><span class="koboSpan" id="kobo.383.10">. </span><span class="koboSpan" id="kobo.383.11">. </span><span class="koboSpan" id="kobo.383.12">: 192.168.1.2</span></strong><span class="koboSpan" id="kobo.384.1">
  Subnet Mask . </span><span class="koboSpan" id="kobo.384.2">. </span><span class="koboSpan" id="kobo.384.3">. </span><span class="koboSpan" id="kobo.384.4">. </span><span class="koboSpan" id="kobo.384.5">. </span><span class="koboSpan" id="kobo.384.6">. </span><span class="koboSpan" id="kobo.384.7">. </span><span class="koboSpan" id="kobo.384.8">. </span><span class="koboSpan" id="kobo.384.9">. </span><span class="koboSpan" id="kobo.384.10">. </span><span class="koboSpan" id="kobo.384.11">. </span><span class="koboSpan" id="kobo.384.12">: 255.255.240.0
  Default Gateway . </span><span class="koboSpan" id="kobo.384.13">. </span><span class="koboSpan" id="kobo.384.14">. </span><span class="koboSpan" id="kobo.384.15">. </span><span class="koboSpan" id="kobo.384.16">. </span><span class="koboSpan" id="kobo.384.17">. </span><span class="koboSpan" id="kobo.384.18">. </span><span class="koboSpan" id="kobo.384.19">. </span><span class="koboSpan" id="kobo.384.20">. </span><span class="koboSpan" id="kobo.384.21">:</span></pre>
<p><span class="koboSpan" id="kobo.385.1">You can find your system’s IP address in the row highlighted in the preceding output. </span><span class="koboSpan" id="kobo.385.2">You can use a similar command on Linux to find out the IP address of </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">your system.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">We haven’t yet configured the </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">Transport Layer Security</span></strong><span class="koboSpan" id="kobo.389.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.390.1">TLS</span></strong><span class="koboSpan" id="kobo.391.1">) for our system host, so this registry is an insecure</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.392.1"> registry. </span><span class="koboSpan" id="kobo.392.2">Docker only supports secure registries by default. </span><span class="koboSpan" id="kobo.392.3">We must configure Docker</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.393.1"> so that it can use insecure registries. </span><span class="koboSpan" id="kobo.393.2">Refer to the Docker documentation to learn how to configure</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.394.1"> an insecure </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">registry (</span></span><a href="https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry"><span class="No-Break"><span class="koboSpan" id="kobo.396.1">https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.397.1">).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.398.1">Adding an insecure registry to daemon.json</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">daemon.json</span></strong><span class="koboSpan" id="kobo.400.1"> can be found</span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.401.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">/etc/docker/daemon.json</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.403.1">on Linux.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.404.1">1. </span><span class="koboSpan" id="kobo.404.2">For Docker Desktop on Mac/Windows, navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">Docker app</span></strong><span class="koboSpan" id="kobo.406.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">Settings</span></strong><span class="koboSpan" id="kobo.408.1"> | </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.409.1">Docker Engine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.411.1">2. </span><span class="koboSpan" id="kobo.411.2">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">insecure-registries</span></strong><span class="koboSpan" id="kobo.413.1"> entry to </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">the JSON:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">    {</span></strong></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">       “</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">features”: {</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">           “</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">buildkit”: true</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">       },</span></strong></p>
<p class="callout"><strong class="source-inline"> </strong><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">“</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">insecure-registries”: [</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">           “</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">192.168.1.2:5000”</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">       ],</span></strong></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">       …</span></strong></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">       …</span></strong></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">    }</span></strong></p>
<p class="callout"><span class="koboSpan" id="kobo.429.1">3. </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">Restart</span></span><span class="No-Break"><a id="_idIndexMarker857"/></span><span class="No-Break"><span class="koboSpan" id="kobo.431.1"> Docker.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">Note that to build and publish the image successfully, the Docker configuration must be performed with a local</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.433.1"> registry, as </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">explained previously.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.435.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.436.1">Don’t use an insecure registry in any environment other than a local or development one for </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">security purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Now, let’s create a Docker image for a sample </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">e-commerce app.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.440.1">Executing a Gradle task to build an image</span></h2>
<p><span class="koboSpan" id="kobo.441.1">You need to make a change</span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.442.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">bootBuildImage</span></strong><span class="koboSpan" id="kobo.444.1"> task so that the image’s name</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.445.1"> contains the local Docker registry’s prefix. </span><span class="koboSpan" id="kobo.445.2">Spring Boot’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">bootBuildImage</span></strong><span class="koboSpan" id="kobo.447.1"> uses Paketo Buildpacks to build the Docker image. </span><span class="koboSpan" id="kobo.447.2">It supports </span><strong class="bold"><span class="koboSpan" id="kobo.448.1">long-term support</span></strong><span class="koboSpan" id="kobo.449.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.450.1">LTS</span></strong><span class="koboSpan" id="kobo.451.1">) Java releases and only current non-LTS Java</span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.452.1"> releases. </span><span class="koboSpan" id="kobo.452.2">This means, when non-LTS Java 20 is released, then it will remove support for Java 19. </span><span class="koboSpan" id="kobo.452.3">Similarly, when Java 21 gets released, it will remove the Java 20 support. </span><span class="koboSpan" id="kobo.452.4">However, it won’t remove Java 17 support because Java 17 is an LTS release. </span><span class="koboSpan" id="kobo.452.5">We can make this change </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
bootBuildImage {   imageName = "192.168.1.2:5000/${project.name}:${
       project.version}"
   environment = ["BP_JVM_VERSION" : "17"]
}</span></pre>
<p><span class="koboSpan" id="kobo.455.1">Here, you have customized the name of the Docker image according to the local Docker registry. </span><span class="koboSpan" id="kobo.455.2">You should change the IP address and port as per your system and configuration. </span><span class="koboSpan" id="kobo.455.3">You have also used the environment property to set the Paketo Buildpacks variables. </span><span class="koboSpan" id="kobo.455.4">You have set the JVM version to 17. </span><span class="koboSpan" id="kobo.455.5">It is recommended to use Java 17 (or any future LTS release). </span><span class="koboSpan" id="kobo.455.6">You can find all the supported Paketo Buildpacks environment variables at </span><a href="https://github.com/paketo-buildpacks/bellsoft-liberica#configuration"><span class="koboSpan" id="kobo.456.1">https://github.com/paketo-buildpacks/bellsoft-liberica#configuration</span></a><span class="koboSpan" id="kobo.457.1">. </span><span class="koboSpan" id="kobo.457.2">At the time of writing, Paketo Buildpacks does not provide official support to build images for ARM. </span><span class="koboSpan" id="kobo.457.3">However, there are alternative builders available such as </span><a href="https://github.com/dashaun/paketo-arm64"><span class="koboSpan" id="kobo.458.1">https://github.com/dashaun/paketo-arm64</span></a><span class="koboSpan" id="kobo.459.1">, which supports building </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">on ARM.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Now, you can build the image by executing</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.462.1"> the following commands</span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.463.1"> from your project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">home directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.465.1">
$ ./gradlew clean build    # build the jar file of app after running the tests
$ ./gradlew bootBuildImage
&gt; Task :bootBuildImage
Building image '192.168.1.2:5000/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT'
 &gt; </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">Pulling builder image</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.467.1">'docker.io/paketobuildpacks/builder:base'</span></strong><span class="koboSpan" id="kobo.468.1">
 ..................................................
 </span><span class="koboSpan" id="kobo.468.2">&gt; Pulled builder image
'paketobuildpacks/builder@sha256:e2bf5f2355b0daddb61c6c7ed3e55e58ab581 900da63f892949ded8b772048ee'
 &gt; </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">Pulling run image 'docker.io/paketobuildpacks/run:base-cnb'</span></strong><span class="koboSpan" id="kobo.470.1">
 ..................................................
 </span><span class="koboSpan" id="kobo.470.2">&gt; Pulled run image
'paketobuildpacks/run@sha256:4a2fbf87a81964ef1a95445f343938ed19406fff da142586a35c9e20904a3315'
 &gt; Executing lifecycle version v0.16.0
 &gt; Using build cache volume 'pack-cache-2fdc28fe99dc.build'
// continue…</span></pre>
<p><span class="koboSpan" id="kobo.471.1">The Spring Boot Gradle plugin uses the </span><em class="italic"><span class="koboSpan" id="kobo.472.1">Paketo BellSoft Liberica Buildpack</span></em><span class="koboSpan" id="kobo.473.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">docker. </span><span class="koboSpan" id="kobo.474.2">io/paketobuildpacks</span></strong><span class="koboSpan" id="kobo.475.1">) to build an application</span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.476.1"> image. </span><span class="koboSpan" id="kobo.476.2">First, it pulls the image</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.477.1"> from Docker Hub and then runs its container, as </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.479.1">
&gt; Running creator    [creator]  ===&gt; ANALYZING
    [creator]  Previous image with name
               "192.168.1.2:5000/packt-modern-api-development-
               chapter09:0.0.1-SNAPSHOT" not found
    [creator]  ===&gt; DETECTING
    // truncated output for brevity
    [creator]  ===&gt; RESTORING
    [creator]  ===&gt; BUILDING
    // truncated output for brevity
    [creator]
    [creator]  </span><strong class="bold"><span class="koboSpan" id="kobo.480.1">Paketo Buildpack for BellSoft Liberica 9.11.0</span></strong><span class="koboSpan" id="kobo.481.1">
    [creator]  https://github.com/paketo-buildpacks/bellsoft-
               liberica
    // truncated output for brevity
    [creator]  Using Java version 17 from BP_JVM_VERSION
[creator] BellSoft Liberica </span><strong class="bold"><span class="koboSpan" id="kobo.482.1">JRE 17.0.6</span></strong><span class="koboSpan" id="kobo.483.1">: Contributing to layer
    [creator]  Downloading from https://github.com/bell-sw/Liberica/releases/download/17.0.6+10/</span><strong class="bold"><span class="koboSpan" id="kobo.484.1">bellsoft-jre17.0.6+10-linux-amd64.tar.gz</span></strong><span class="koboSpan" id="kobo.485.1">
    [creator]  Verifying checksum
    [creator]  Expanding to /layers/paketo-
               buildpacks_bellsoft-liberica/jre
    // truncated output for brevity</span></pre>
<p><span class="koboSpan" id="kobo.486.1">Here, the Spring Boot plugin</span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.487.1"> uses Bellsoft’s JRE 17.0.6 with Linux as a base image to build images. </span><span class="koboSpan" id="kobo.487.2">It uses finely grained</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.488.1"> filesystem layers inside the container to </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">do so:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.490.1">
    [creator]  Launch Helper: Contributing to layer    [creator]  Creating /layers/paketo-buildpacks_bellsoft-
               liberica/helper/exec.d/active-processor-count
    [creator]  Creating /layers/paketo-buildpacks_bellsoft-
               liberica/helper/exec.d/java-opts
    // truncated output for brevity
    [creator]  Paketo Buildpack for Syft 1.26.0
    [creator]  https://github.com/paketo-buildpacks/syft
    [creator]  Downloading from
               https://github.com/anchore/syft/releases/
               download/v0.75.0/syft_0.75.0_linux_amd64.tar.gz
    // truncated output for brevity
    [creator]  Paketo Buildpack for Executable JAR 6.6.2
[creator] https://github.com/paketo-buildpacks/executable-jar
    [creator]       Class Path: Contributing to layer
    // truncated output for brevity</span></pre>
<p><span class="koboSpan" id="kobo.491.1">The plugin continues to add the layers</span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.492.1"> and then the labels. </span><span class="koboSpan" id="kobo.492.2">Finally, it creates</span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.493.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">Docker image:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.495.1">
  [creator]  Paketo Buildpack for Spring Boot 5.23.0  [creator]  https://github.com/paketo-buildpacks/spring-boot
  // truncated output for brevity
  [creator]     ===&gt; EXPORTING
  [creator]  Adding layer 'paketo-buildpacks/ca-
             certificates:helper'
  // truncated output for brevity
  [creator]  Adding layer 'paketo-buildpacks/executable-
             jar:classpath'
  [creator]  Adding layer 'paketo-buildpacks/spring-
             boot:helper'
  [creator]  Adding layer 'paketo-buildpacks/spring-
             boot:spring-cloud-bindings'
  [creator]  Adding layer 'paketo-buildpacks/spring-boot:web-
             application-type'
  [creator]  Adding 5/5 app layer(s)
  [creator]  Adding layer 'buildpacksio/lifecycle:launcher'
  // truncated output for brevity
  [creator]  Adding label 'org.springframework.boot.version'
  [creator]  Setting default process type 'web'
  [creator]  *** Images (9cc6ef620b7c):
  [creator]  192.168.1.2:5000/packt-modern-api-development-
             chapter09:0.0.1-SNAPSHOT
</span><strong class="bold"><span class="koboSpan" id="kobo.496.1">Successfully built image '192.168.1.2:5000/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT'</span></strong><span class="koboSpan" id="kobo.497.1">
BUILD SUCCESSFUL in 1m 22s</span></pre>
<p><span class="koboSpan" id="kobo.498.1">You can learn more about Spring Boot, Docker, and Kubernetes and their configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">at </span></span><a href="https://github.com/dsyer/kubernetes-intro"><span class="No-Break"><span class="koboSpan" id="kobo.500.1">https://github.com/dsyer/kubernetes-intro</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.501.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">Now that the Docker image has been built, you can use this image to run the sample e-commerce app locally using the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.504.1">
$ docker run -p 8080:8080 192.168.1.2:5000/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT</span></pre> <p><span class="koboSpan" id="kobo.505.1">This command</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.506.1"> will run the application on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">8080</span></strong><span class="koboSpan" id="kobo.508.1"> inside the container. </span><span class="koboSpan" id="kobo.508.2">Because</span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.509.1"> it has been exposed on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">8080</span></strong><span class="koboSpan" id="kobo.511.1">, you can access the sample e-commerce app on </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">8080</span></strong><span class="koboSpan" id="kobo.513.1"> outside the container too, once the app is up and running. </span><span class="koboSpan" id="kobo.513.2">You can test the application by running the following command in a separate terminal tab/window once the application container is up </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">and running:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.515.1">
$ curl localhost:8080/actuator/health</span><strong class="bold"><span class="koboSpan" id="kobo.516.1">{"status":"UP"}</span></strong><span class="koboSpan" id="kobo.517.1">
$ curl localhost:8080/actuator
{
 "_links": {
  "self": {
    "href": "http://localhost:8080/actuator",
    "templated": false },
  "health-path": {
    "href": "http://localhost:8080/actuator/ health/{*path}",
    "templated": true },
  </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">"health": {</span></strong><span class="koboSpan" id="kobo.519.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">"href": "http://localhost:8080/actuator/health",</span></strong><span class="koboSpan" id="kobo.521.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">"templated": false }</span></strong><span class="koboSpan" id="kobo.523.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">}</span></strong><span class="koboSpan" id="kobo.525.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.526.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">curl localhost:8080/actuator</span></strong><span class="koboSpan" id="kobo.528.1"> command returns the available Actuator endpoints, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">health</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.530.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">health-path</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">You can also list the containers</span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.534.1"> and their statuses by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">following</span></span><span class="No-Break"><a id="_idIndexMarker873"/></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.537.1">
$ docker psCONTAINER ID   IMAGE                                                                    COMMAND                  CREATED          STATUS           PORTS                    NAMES
62255c54ab52   192.168.1.2:5000/packt-modern-api-development-chapter 09:0.0.1-SNAPSHOT   "/cnb/process/web"       7 minutes ago    Up 7 minutes    0.0.0.0:8080-&gt;8080/tcp   elated_ramanujan
bca056bf9653   registry:2                                                               "/entrypoint.sh /etc…"   58 minutes ago   Up 58 minutes   0.0.0.0:5000-&gt;5000/tcp   registry</span></pre>
<p><span class="koboSpan" id="kobo.538.1">Next, let’s find out the available Docker images by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.540.1">
$ docker imagesREPOSITORY                                                          TAG              IMAGE ID       CREATED        SIZE
paketobuildpacks/run                                                base-cnb         68c538f4e078   5 hours ago    87MB
registry                                                            2                 0d153fadf70b   5 weeks ago    24.2MB
paketobuildpacks/builder                                            base             38446f68a5f8   43 years ago   1.26GB
192.168.1.2:5000/packt-modern-api-development-chapter09             0.0.1-SNAPSHOT   9cc6ef620b7c   43 years ago   311MB</span></pre>
<p><span class="koboSpan" id="kobo.541.1">Now, you can tag and push the application</span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.542.1"> image using the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">following</span></span><span class="No-Break"><a id="_idIndexMarker875"/></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1"> commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.545.1">
$ docker tag 192.168.1.2:5000/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT 192.168.1.2:5000/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT$ docker push 192.168.1.2:5000/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT
…
b7e0fa7bfe7f: Pushed
0.0.1-SNAPSHOT: digest: sha256:bde567c41e57b15886bd7108beb26b5de7b44c6 6cdd3500c70bd59b8d5c58ded size: 5327</span></pre>
<p><span class="koboSpan" id="kobo.546.1">Similarly, you can also query the local Docker registry container. </span><span class="koboSpan" id="kobo.546.2">First, let’s run the following command to find all the published images in the registry (the default value </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">is 100):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.548.1">
$ curl -X GET http://192.168.1.2:5000/</span><strong class="bold"><span class="koboSpan" id="kobo.549.1">v2/_catalog</span></strong><span class="koboSpan" id="kobo.550.1">{"repositories":["packt-modern-api-development-chapter09"]}</span></pre>
<p><span class="koboSpan" id="kobo.551.1">Similarly, you can find out what all the available tags are for any specific image by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.553.1">
$ curl -X GET http://192.168.1.2:5000/</span><strong class="bold"><span class="koboSpan" id="kobo.554.1">v2/packt-modern-api-development-chapter09</span></strong><span class="koboSpan" id="kobo.555.1">/tags/list{"name":"packt-modern-api-development-chapter09","tags":["0.0.1-SNAPSHOT"]}</span></pre>
<p><span class="koboSpan" id="kobo.556.1">For these commands, you can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">localhost</span></strong><span class="koboSpan" id="kobo.558.1"> instead </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.559.1">of the IP, if you run a local </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">registry</span></span><span class="No-Break"><a id="_idIndexMarker877"/></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1"> container.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">We’ll deploy this image to Kubernetes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">next section.</span></span></p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.564.1">Deploying an application in Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.565.1">Docker containers</span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.566.1"> are run in isolation. </span><span class="koboSpan" id="kobo.566.2">You need a platform that can execute multiple Docker</span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.567.1"> containers and manage or scale them. </span><span class="koboSpan" id="kobo.567.2">Docker Compose does this for us. </span><span class="koboSpan" id="kobo.567.3">However, this is where Kubernetes helps. </span><span class="koboSpan" id="kobo.567.4">It not only manages the container but also helps you scale the deployed </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">containers dynamically.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">You will use Minikube to run Kubernetes locally. </span><span class="koboSpan" id="kobo.569.2">You can use it on Linux, macOS, and Windows. </span><span class="koboSpan" id="kobo.569.3">It runs a single-node Kubernetes cluster, which is used for learning or development purposes. </span><span class="koboSpan" id="kobo.569.4">You can install it by referring</span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.570.1"> to the respective </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">guide (</span></span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="No-Break"><span class="koboSpan" id="kobo.572.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.573.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">Once Minikube is installed, you need to update Minikube’s local insecure registry because, by default, Minikube’s registry uses Docker Hub. </span><span class="koboSpan" id="kobo.574.2">Adding an image to Docker Hub and then fetching it for local usage is cumbersome for development. </span><span class="koboSpan" id="kobo.574.3">You can add a local insecure registry to your Minikube environment by adding your host IP and local Docker registry port to Minikube’s config at </span><em class="italic"><span class="koboSpan" id="kobo.575.1">HostOptions</span></em><span class="koboSpan" id="kobo.576.1"> | </span><em class="italic"><span class="koboSpan" id="kobo.577.1">EngineOptions</span></em><span class="koboSpan" id="kobo.578.1"> | </span><em class="italic"><span class="koboSpan" id="kobo.579.1">InsecureRegistry</span></em><span class="koboSpan" id="kobo.580.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">~/.minikube/machines/minikube/config.json</span></strong><span class="koboSpan" id="kobo.582.1"> (note that this file is only generated after Minikube has been started once; therefore, start Minikube before </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">modifying </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">config.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.586.1">$ vi ~/.minikube/machines/minikube/config.json</span></strong><span class="koboSpan" id="kobo.587.1"> 41     …
 42     "DriverName": "qemu2",
 43     </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">"HostOptions"</span></strong><span class="koboSpan" id="kobo.589.1">: {
 44         "Driver": "",
 45         "Memory": 0,
 46         "Disk": 0,
 47         </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">"EngineOptions"</span></strong><span class="koboSpan" id="kobo.591.1">: {
 48             "ArbitraryFlags": null,
 49             "Dns": null,
 50             "GraphDir": "",
 51             "Env": null,
 52             "Ipv6": false,
 53             </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">"InsecureRegistry"</span></strong><span class="koboSpan" id="kobo.593.1">: [
 54                 "10.96.0.0/12",
 55                 </span><strong class="bold"><span class="koboSpan" id="kobo.594.1">"192.168.1.2:5000"</span></strong><span class="koboSpan" id="kobo.595.1">
 56             ],
 57     …</span></pre>
<p><span class="koboSpan" id="kobo.596.1">Once the insecure registry</span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.597.1"> has been updated, you can start Minikube</span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.598.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.600.1">
$ minikube </span><strong class="bold"><span class="koboSpan" id="kobo.601.1">start --insecure-registry="192.168.80.1:5000"</span></strong><span class="koboSpan" id="kobo.602.1">😄  minikube v1.29.0 on Darwin 13.1
✨  Using the qemu2 driver based on existing profile
👍  Starting control plane node minikube in cluster minikube
🔄  Restarting existing qemu2 VM for "minikube" ...
</span><span class="koboSpan" id="kobo.602.2">🐳  Preparing Kubernetes v1.26.1 on Docker 20.10.23 ...
</span><span class="koboSpan" id="kobo.602.3">🔗  Configuring bridge CNI (Container Networking Interface) ...
</span><span class="koboSpan" id="kobo.602.4">    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🔎  Verifying Kubernetes components...
</span><span class="koboSpan" id="kobo.602.5">🌟  Enabled addons: default-storageclass, storage-provisioner
🏄  Done! </span><span class="koboSpan" id="kobo.602.6">kubectl is now configured to use </span><strong class="bold"><span class="koboSpan" id="kobo.603.1">"minikube" cluster</span></strong><span class="koboSpan" id="kobo.604.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">"default" namespace</span></strong><span class="koboSpan" id="kobo.606.1"> by default</span></pre>
<p><span class="koboSpan" id="kobo.607.1">Here, we have used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">--insecure-registry</span></strong><span class="koboSpan" id="kobo.609.1"> flag while starting</span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.610.1"> Minikube. </span><span class="koboSpan" id="kobo.610.2">This is important, as it makes the insecure</span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.611.1"> registry work. </span><span class="koboSpan" id="kobo.611.2">The Kubernetes cluster uses the default namespace </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.614.1">namespace</span></strong><span class="koboSpan" id="kobo.615.1"> is a Kubernetes special object that allows</span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.616.1"> you to divide the Kubernetes cluster resources among users or projects. </span><span class="koboSpan" id="kobo.616.2">However, you can’t have nested namespaces. </span><span class="koboSpan" id="kobo.616.3">Kubernetes resources can only belong to </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">single namespaces.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">You can check whether Kubernetes works or not by executing the following command once Minikube is up </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">and running:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.620.1">
$ </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">kubectl get po -A</span></strong><span class="koboSpan" id="kobo.622.1">NAMESPACE    NAME                             READY   STATUS    RESTARTS        AGE
kube-system  coredns-787d4945fb-5hzc2         1/1     Running   3 (17m ago)     30m
kube-system  etcd-minikube                    1/1     Running   5 (17m ago)     32m
kube-system  kube-apiserver-minikube          1/1     Running   4 (17m ago)     32m
kube-system  kube-controller-manager-minikube 1/1     Running   5 (3m58s ago)   32m
kube-system  kube-proxy-z4n66                 1/1     Running   4 (17m ago)     31m
kube-system  kube-scheduler-minikube          1/1     Running   4 (17m ago)     32m
kube-system  storage-provisioner              1/1     Running   2 (3m25s ago)   18m</span></pre>
<p><span class="koboSpan" id="kobo.623.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">kubectl</span></strong><span class="koboSpan" id="kobo.625.1"> command is a command-line tool that’s used to control a Kubernetes cluster, like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">docker</span></strong><span class="koboSpan" id="kobo.627.1"> command for Docker. </span><span class="koboSpan" id="kobo.627.2">It is a Kubernetes client that uses Kubernetes REST APIs to perform various Kubernetes operations, such as deploying applications, viewing logs, and inspecting and managing </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">cluster resources.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">get po</span></strong><span class="koboSpan" id="kobo.631.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">get pod</span></strong><span class="koboSpan" id="kobo.633.1"> parameters allow you to retrieve pods from your Kubernetes cluster. </span><span class="koboSpan" id="kobo.633.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">-A</span></strong><span class="koboSpan" id="kobo.635.1"> flag instructs </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">kubectl</span></strong><span class="koboSpan" id="kobo.637.1"> to retrieve objects from across namespaces. </span><span class="koboSpan" id="kobo.637.2">Here, you can see that all the pods are from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">kube-system</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1"> namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">These pods are created by Kubernetes and are part of its </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">internal system.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">Minikube bundles the Kubernetes</span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.643.1"> dashboard as a UI for additional insight</span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.644.1"> into your cluster’s state. </span><span class="koboSpan" id="kobo.644.2">You can start it by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.646.1">
$ minikube dashboard🔌  Enabling dashboard ...
</span><span class="koboSpan" id="kobo.646.2">    ▪ Using image docker.io/kubernetesui/dashboard:v2.7.0
    ▪ Using image docker.io/kubernetesui/metrics-
      scraper:v1.0.8
💡  Some dashboard features require the metrics-server addon. </span><span class="koboSpan" id="kobo.646.3">To enable all features please run:
  minikube addons enable metrics-server
🤔  Verifying dashboard health ...
</span><span class="koboSpan" id="kobo.646.4">🚀  Launching proxy ...
</span><span class="koboSpan" id="kobo.646.5">🤔  Verifying proxy health ...
</span><span class="koboSpan" id="kobo.646.6">🎉  Opening http://127.0.0.1:56858/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...</span></pre>
<p><span class="koboSpan" id="kobo.647.1">Running the dashboard allows you to manage the Kubernetes cluster from the UI and looks </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.649.1"><img alt="Figure 9.2 – The Kubernetes dashboard" src="image/Figure_09.2_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.650.1">Figure 9.2 – The Kubernetes dashboard</span></p>
<p><span class="koboSpan" id="kobo.651.1">Kubernetes uses YAML configuration</span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.652.1"> to create objects. </span><span class="koboSpan" id="kobo.652.2">For example, you need a deployment</span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.653.1"> and service object to deploy and access the sample e-commerce application. </span><span class="koboSpan" id="kobo.653.2">The deployment will create a pod in the Kubernetes cluster that will run the application container, and the service will allow it to access it. </span><span class="koboSpan" id="kobo.653.3">You can create these YAML files either manually or generate them using </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">kubectl</span></strong><span class="koboSpan" id="kobo.655.1">. </span><span class="koboSpan" id="kobo.655.2">You should typically use </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">kubectl</span></strong><span class="koboSpan" id="kobo.657.1">, which generates the files for you. </span><span class="koboSpan" id="kobo.657.2">If you need to, you can modify the content of </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">Let’s create a new directory (</span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">k8s</span></strong><span class="koboSpan" id="kobo.661.1">) in the project’s home directory so that we can store the Kubernetes deployment configuration. </span><span class="koboSpan" id="kobo.661.2">We can generate the deployment Kubernetes configuration file by using the following commands from the newly created </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">k8s</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.663.1"> directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.664.1">
$ kubectl </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">create deployment</span></strong><span class="koboSpan" id="kobo.666.1"> chapter09--image=192.168.1.2:5000/packt-modern-api-developmentchapter09:0.0.1-SNAPSHOT --dry-run=client -o=yaml &gt; deployment.yaml
$ echo --- &gt;&gt; deployment.yaml
$ kubectl </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">create service</span></strong><span class="koboSpan" id="kobo.668.1"> clusterip chapter09 --tcp=8080:8080 --dry-run=client -o=yaml &gt;&gt; deployment.yaml</span></pre>
<p><span class="koboSpan" id="kobo.669.1">Here, the first command generates the deployment configuration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">deployment.yaml</span></strong><span class="koboSpan" id="kobo.671.1"> file using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">create deployment</span></strong><span class="koboSpan" id="kobo.673.1"> command. </span><span class="koboSpan" id="kobo.673.2">A Kubernetes deployment defines the scale at which you want to run your application. </span><span class="koboSpan" id="kobo.673.3">You can see that the replica is defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">1</span></strong><span class="koboSpan" id="kobo.675.1">. </span><span class="koboSpan" id="kobo.675.2">Therefore, Kubernetes will run a single replica of this deployment. </span><span class="koboSpan" id="kobo.675.3">Here, you pass the name (</span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">chapter09</span></strong><span class="koboSpan" id="kobo.677.1">) of the deployment, the image name of the application to deploy, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">--dry-run=client</span></strong><span class="koboSpan" id="kobo.679.1"> flag to preview the object that will be sent to the cluster, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">-o=yaml</span></strong><span class="koboSpan" id="kobo.681.1"> flag to generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">YAML output.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">The second command appends </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">---</span></strong><span class="koboSpan" id="kobo.685.1"> to the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">deployment.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.687.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">Finally, the third command</span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.689.1"> creates the service </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.690.1">configuration in </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">deployment.yaml</span></strong><span class="koboSpan" id="kobo.692.1">, with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">8080</span></strong><span class="koboSpan" id="kobo.694.1"> for both internal and </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">external ports.</span></span></p>
<p><span class="koboSpan" id="kobo.696.1">Here, you have used the same file for both deployment and service objects. </span><span class="koboSpan" id="kobo.696.2">However, you can create two separate files for these – </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">deployment.yaml</span></strong><span class="koboSpan" id="kobo.698.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">service.yaml</span></strong><span class="koboSpan" id="kobo.700.1">. </span><span class="koboSpan" id="kobo.700.2">In this case, you need to apply these objects separately in your </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">Let’s have a look at the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">deployment.yaml</span></strong><span class="koboSpan" id="kobo.704.1"> file, which was generated by the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.706.1">
apiVersion: apps/v1</span><strong class="bold"><span class="koboSpan" id="kobo.707.1">kind: Deployment</span></strong><span class="koboSpan" id="kobo.708.1">
metadata:
  creationTimestamp: null
  labels:
    app: chapter09
  name: chapter09
spec:
  replicas: 1
  selector:
    matchLabels:
      app: chapter09
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: chapter09
    spec:
      containers:
      - image: 192.168.1.2:5000/
       packt-modern-api-developmentchapter09:0.0.1-SNAPSHOT
        name: packt-modern-api-developmentchapter09
        resources: {}
status: {}
</span><strong class="bold"><span class="koboSpan" id="kobo.709.1">---</span></strong><span class="koboSpan" id="kobo.710.1">
apiVersion: v1
</span><strong class="bold"><span class="koboSpan" id="kobo.711.1">kind: Service</span></strong><span class="koboSpan" id="kobo.712.1">
metadata:
  creationTimestamp: null
  labels:
    app: chapter09
  name: chapter09
spec:
  ports:
  - name: 8080-8080
    port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    app: chapter09
  type: ClusterIP
status:
  loadBalancer: {}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml"><span class="No-Break"><span class="koboSpan" id="kobo.713.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml</span></span></a></p>
<p><span class="koboSpan" id="kobo.714.1">Now, you can deploy </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.715.1">the sample e-commerce</span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.716.1"> application using the file created previously in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">deployment.yaml</span></strong><span class="koboSpan" id="kobo.718.1"> file, with the following command running from the project </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">root directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.720.1">
$ kubectl </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">apply -f k8s/deployment.yaml</span></strong><span class="koboSpan" id="kobo.722.1">deployment.apps/chapter09 created
service/chapter09 created</span></pre>
<p><span class="koboSpan" id="kobo.723.1">This will deploy a sample e-commerce app (</span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09"><span class="koboSpan" id="kobo.724.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09</span></a><span class="koboSpan" id="kobo.725.1">) in Kubernetes on </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">successful creation.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">Alternatively, you can perform the following steps to publish the Docker image to Minikube. </span><span class="koboSpan" id="kobo.727.2">Start a new terminal and execute the following commands (the same terminal window should be used here, since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">eval</span></strong><span class="koboSpan" id="kobo.729.1"> commands are only valid in an </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">active terminal):</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.731.1">Execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">eval $(minikube docker-env)</span></strong><span class="koboSpan" id="kobo.733.1"> to align the Minikube environment with your </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">Docker configuration.</span></span></li>
<li><span class="koboSpan" id="kobo.735.1">Execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">gradle bootBuildImage</span></strong><span class="koboSpan" id="kobo.737.1"> to generate an image based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">Minikube environment.</span></span></li>
<li><span class="koboSpan" id="kobo.739.1">Execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.741.1">$ docker tag 192.168.1.2:5000/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT 192.168.80.1:5000/ packt-modern-api-development-chapter09:0.0.1-SNAPSHOT</span></strong><strong class="bold"><span class="koboSpan" id="kobo.742.1">$ docker push 192.168.1.2:5000/library/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT</span></strong></pre></li> <li><span class="koboSpan" id="kobo.743.1">Execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">minikube stop</span></strong><span class="koboSpan" id="kobo.745.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">minikube start</span></strong><span class="koboSpan" id="kobo.747.1"> to ensure that the new configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">is applied.</span></span></li>
<li><span class="koboSpan" id="kobo.749.1">You can start the Minikube logs by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.751.1">$ minikube -p minikube docker-env</span></strong><strong class="bold"><span class="koboSpan" id="kobo.752.1">$ eval $(minikube -p minikube docker-env)</span></strong></pre></li> <li><span class="koboSpan" id="kobo.753.1">Afterward, deployment can be done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">kubectl apply -f </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">deploymentTest.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.756.1"> command.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.757.1">This will initiate the application</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.758.1"> deployment of </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">chapter09</span></strong><span class="koboSpan" id="kobo.760.1">. </span><span class="koboSpan" id="kobo.760.2">You can then either use</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.761.1"> the Kubernetes dashboard or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">kubectl get all</span></strong><span class="koboSpan" id="kobo.763.1"> command to check the status of your pod and service. </span><strong class="bold"><span class="koboSpan" id="kobo.764.1">Pods</span></strong><span class="koboSpan" id="kobo.765.1"> are Kubernetes’ smallest and most deployable objects. </span><span class="koboSpan" id="kobo.765.2">They contain one or more</span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.766.1"> containers and represent a single instance of a running process in a Kubernetes cluster. </span><span class="koboSpan" id="kobo.766.2">A pod’s IP address and other configuration details may change because Kubernetes keep track</span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.767.1"> of these, and it may replace them if a pod goes down. </span><span class="koboSpan" id="kobo.767.2">Therefore, a </span><strong class="bold"><span class="koboSpan" id="kobo.768.1">Kubernetes service</span></strong><span class="koboSpan" id="kobo.769.1"> adds an abstraction layer over the pods it exposes the IP addresses of and manages mapping to </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">internal pods.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">Let’s run the following command to find out the status of the pod </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">and service:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.773.1">
$ kubectl get allNAME  READY STATUS  RESTARTS   AGE
</span><strong class="bold"><span class="koboSpan" id="kobo.774.1">pod/chapter09-845f48cc7f-55zqr</span></strong><span class="koboSpan" id="kobo.775.1"> 1/1 </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">Running</span></strong><span class="koboSpan" id="kobo.777.1"> 0   9m17s
NAME  TYPE CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
</span><strong class="bold"><span class="koboSpan" id="kobo.778.1">service/chapter09</span></strong><span class="koboSpan" id="kobo.779.1">   ClusterIP   </span><strong class="bold"><span class="koboSpan" id="kobo.780.1">10.100.135.86</span></strong><span class="koboSpan" id="kobo.781.1">   &lt;none&gt;        </span><strong class="bold"><span class="koboSpan" id="kobo.782.1">8080</span></strong><span class="koboSpan" id="kobo.783.1">/TCP   9m18s
service/kubernetes   ClusterIP   10.96.0.1  &lt;none&gt;        443/TCP    65m
NAME  READY UP-TO-DATE  AVAILABLE   AGE
</span><strong class="bold"><span class="koboSpan" id="kobo.784.1">deployment.apps/chapter09</span></strong><span class="koboSpan" id="kobo.785.1">  1/1   1   1     9m18s
NAME   DESIRED CURRENT READY AGE
</span><strong class="bold"><span class="koboSpan" id="kobo.786.1">replicaset.apps/chapter09-845f48cc7f</span></strong><span class="koboSpan" id="kobo.787.1"> 1   1   1   9m17s</span></pre>
<p><span class="koboSpan" id="kobo.788.1">This returns all the Kubernetes resources in the default namespace. </span><span class="koboSpan" id="kobo.788.2">Here, you can see that it returns a running pod, a service, a deployment resource, and a ReplicaSet for </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">chapter09</span></strong><span class="koboSpan" id="kobo.790.1">. </span><span class="koboSpan" id="kobo.790.2">You need to run this command multiple times until you find a successful or erroneous response (such as “</span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">image is </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">not pullable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">”).</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">You can’t access the application</span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.795.1"> running inside Kubernetes</span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.796.1"> directly, as you can see from the reponse of the </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.798.1">
$ curl localhost:8080/actuator/healthcurl: (7) Failed to connect to localhost port 8080 after 0 ms: Connection refused</span></pre>
<p><span class="koboSpan" id="kobo.799.1">You must either use some kind of proxy or SSH tunneling to access the application running inside the Kubernetes cluster. </span><span class="koboSpan" id="kobo.799.2">Let’s quickly create an SSH tunnel using the </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.801.1">
$ kubectl port-forward service/chapter09 8080:8080Forwarding from 127.0.0.1:8080 -&gt; 8080
Forwarding from [::1]:8080 -&gt; 8080</span></pre>
<p><span class="koboSpan" id="kobo.802.1">The application now runs on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">8080</span></strong><span class="koboSpan" id="kobo.804.1"> inside the Kubernete’s cluster. </span><span class="koboSpan" id="kobo.804.2">It is also mapped to the local machine’s port</span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">8080</span></strong><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">Due to this port mapping, you can access the application outside the </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.808.1">Let’s try again accessing the application after opening a new </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">terminal window:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.810.1">
$ curl localhost:8080/actuator/health{</span><strong class="bold"><span class="koboSpan" id="kobo.811.1">"status":"UP","groups"</span></strong><span class="koboSpan" id="kobo.812.1">:["liveness","readiness"]}</span></pre>
<p><span class="koboSpan" id="kobo.813.1">With that, the application</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.814.1"> has been successfully</span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.815.1"> deployed on our Kubernetes cluster. </span><span class="koboSpan" id="kobo.815.2">Now, you can use the Postman collection and run all the available </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">REST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.817.1"> endpoints.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.818.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.819.1">In this chapter, you learned about containerization and how it is different from virtualization. </span><span class="koboSpan" id="kobo.819.2">You also learned about the Docker containerization platform and how to use the Spring Boot plugin to generate a Docker image for a sample </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">e-commerce app.</span></span></p>
<p><span class="koboSpan" id="kobo.821.1">Then, you learned about the Docker registry and how to configure a local insecure registry so that you can use it to push and pull images locally. </span><span class="koboSpan" id="kobo.821.2">The same commands can be used to push and pull images from a remote </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">Docker registry.</span></span></p>
<p><span class="koboSpan" id="kobo.823.1">You also learned about Kubernetes and its cluster operations by using Minikube. </span><span class="koboSpan" id="kobo.823.2">You configured it so that you can pull Docker images from insecure local </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">Docker registries.</span></span></p>
<p><span class="koboSpan" id="kobo.825.1">Now, you have the necessary skills to build a Docker image of a Spring Boot application and deploy it to a </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">In the next chapter, you’ll learn about the fundamentals of the </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">gRPC APIs.</span></span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.829.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.830.1">What is the difference between virtualization </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">and containerization?</span></span></li>
<li><span class="koboSpan" id="kobo.832.1">What is Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">used for?</span></span></li>
<li><span class="koboSpan" id="kobo.834.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">kubectl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">?</span></span></li>
</ol>
<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.838.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.839.1">Virtualization is used to create VMs on top of the host system, which shares its hardware with the VMs, whereas containerization creates containers that are executed as an isolated process on top of the hardware and its OS. </span><span class="koboSpan" id="kobo.839.2">Containers are lightweight and need only a few MB (occasionally, GB). </span><span class="koboSpan" id="kobo.839.3">VMs are heavyweight and need many GB. </span><span class="koboSpan" id="kobo.839.4">Containers run faster and are more portable </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">than VMs.</span></span></li>
<li><span class="koboSpan" id="kobo.841.1">Kubernetes is a container orchestration system and is used to manage application containers. </span><span class="koboSpan" id="kobo.841.2">It keeps track of running containers. </span><span class="koboSpan" id="kobo.841.3">It shuts down containers when they are not used and restarts orphaned containers. </span><span class="koboSpan" id="kobo.841.4">A Kubernetes cluster is also used for scale. </span><span class="koboSpan" id="kobo.841.5">It can provision resources such as CPU, memory, and storage automatically </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">when required.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">kubectl</span></strong><span class="koboSpan" id="kobo.844.1"> is a Kubernetes </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">command-line interface</span></strong><span class="koboSpan" id="kobo.846.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.847.1">CLI</span></strong><span class="koboSpan" id="kobo.848.1">) utility that is used to run commands against a Kubernetes cluster. </span><span class="koboSpan" id="kobo.848.2">You can manage Kubernetes resources using </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">kubectl</span></strong><span class="koboSpan" id="kobo.850.1">. </span><span class="koboSpan" id="kobo.850.2">You used </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">kubectl</span></strong><span class="koboSpan" id="kobo.852.1">’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">apply</span></strong><span class="koboSpan" id="kobo.854.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">create</span></strong><span class="koboSpan" id="kobo.856.1"> commands in </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">this chapter.</span></span></li>
</ol>
<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.858.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.859.1">Mastering Kubernetes – Fourth </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.860.1">Edition</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">: </span></span><a href="https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395"><span class="No-Break"><span class="koboSpan" id="kobo.862.1">https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395</span></span></a></li>
<li><span class="koboSpan" id="kobo.863.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">documentation: </span></span><a href="https://docs.docker.com/get-started/overview/"><span class="No-Break"><span class="koboSpan" id="kobo.865.1">https://docs.docker.com/get-started/overview/</span></span></a></li>
<li><span class="koboSpan" id="kobo.866.1">Minikube </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">documentation: </span></span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="No-Break"><span class="koboSpan" id="kobo.868.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer039">
<h1 id="_idParaDest-233" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.1.1">Part 3 – gRPC, Logging, and Monitoring</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will learn about gRPC-based API development. </span><span class="koboSpan" id="kobo.2.2">On the completion of this part, you will be able to differentiate between REST and reactive APIs with gRPC-based APIs. </span><span class="koboSpan" id="kobo.2.3">You will be able to build a server and client using the Protobuf schema. </span><span class="koboSpan" id="kobo.2.4">Finally, you will be able to facilitate distributed logging and tracing, collecting the logs as an Elasticsearch index that will be used for debugging and analysis on the </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Kibana app.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19349_10.xhtml#_idTextAnchor233"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Getting Started with gRPC</span></em></li>
<li><a href="B19349_11.xhtml#_idTextAnchor250"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">gRPC API Development and Testing</span></em></li>
<li><a href="B19349_12.xhtml#_idTextAnchor272"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Adding Logging and Tracing to Services</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer040">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer041">
</div>
</div>
</body></html>