<html><head></head><body>
		<div id="_idContainer063">
			<h1 id="_idParaDest-91"><em class="italic"><a id="_idTextAnchor090"/>Chapter 4</em>: Securing the Microservices</h1>
			<p>Protecting microservices' interfaces as well as the world encompassed by them is a crucial facet for any application development. Various topologies, tools, and frameworks have arisen in recent times to address the security aspects of web services/microservices. In the course of this chapter, we will dive into some core and often-used security paradigms in microservices. We will continue with the <strong class="source-inline">pet-clinic</strong> application from the previous chapter. For hands-on work, we will work toward securing microservices while covering the following authentication strategies in the Micronaut framework:</p>
			<ul>
				<li><strong class="source-inline">pet-owner</strong>: Working hands-on to secure <strong class="source-inline">pet-owner</strong> microservice endpoints using <strong class="bold">session authentication</strong></li>
				<li><strong class="source-inline">pet-clinic</strong>: Working hands-on to secure <strong class="source-inline">pet-clinic</strong> microservice endpoints using <strong class="bold">JWT authentication</strong></li>
				<li><strong class="source-inline">pet-clinic-review</strong>: Working hands-on to secure <strong class="source-inline">pet-clinic-review</strong> microservice endpoints using <strong class="bold">OAuth authentication</strong></li>
			</ul>
			<p>With the aforementioned hands-on exercises, we will be covering the following topics in this chapter:</p>
			<ul>
				<li>Using <strong class="bold">session authentication</strong> to secure the service endpoints</li>
				<li>Using <strong class="bold">JWT authentication</strong> to secure the service endpoints</li>
				<li>Using <strong class="bold">OAuth</strong> to secure the service endpoints</li>
			</ul>
			<p>By the end of this chapter, you will have a nifty knowledge of working with various authentication strategies and local or cloud identity providers in the Micronaut framework.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter are run on Windows 10 and Mac OS X. Code examples covered in this chapter are available in the book's GitHub repository at <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04</a>.</p>
			<p>The following tools need to be installed and set up in the development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong>: Version 13 or above (we used Java 14).</li>
				<li><strong class="bold">Maven</strong>: This is optional and only required if you would like to use Maven as the build system. However, we recommend having Maven set up on any development machine. Instructions to download and install Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">Development IDE</strong>: Based on your preference, any Java-based IDE can be used, but for the purpose of writing this chapter, IntelliJ was used. </li>
				<li><strong class="bold">Git</strong>: Instructions to download and install Git can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</li>
				<li><strong class="bold">PostgreSQL</strong>: Instructions to download and install PostgreSQL can be found at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</li>
				<li><strong class="bold">MongoDB</strong>: MongoDB Atlas provides a free online database-as-a-service with up to 512 MB storage. However, if a local database is preferred, then instructions to download and install can be found at <a href="https://docs.mongodb.com/manual/administration/install-community/">https://docs.mongodb.com/manual/administration/install-community/</a>. We used a local installation for this chapter.</li>
				<li><strong class="bold">Rest client</strong>: Any HTTP rest client can be used. We used the Advanced REST Client Chrome plugin.</li>
				<li><strong class="bold">Docker</strong>: Instructions to download and install Docker can be found at <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>.</li>
				<li><strong class="bold">OpenSSL</strong>: Instructions to download and install OpenSSL can be found at <a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a>.</li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Working on RESTful microservices in the Micronaut framework</h1>
			<p>In order <a id="_idIndexMarker304"/>to dive into the security aspects of the <a id="_idIndexMarker305"/>Micronaut framework, we will continue working on the <strong class="source-inline">pet-clinic</strong> application. The following table summarizes the changes we will be making to secure each of the microservices in the application:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Table_4.1.jpg" alt="Table 4.1 – Securing the microservices in the pet-clinic application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 4.1 – Securing the microservices in the pet-clinic application</p>
			<p>To secure the desired endpoints in the microservices, we will focus on the following two key aspects:</p>
			<ul>
				<li><strong class="bold">Identity provider</strong>: Essentially, an identity provider<a id="_idIndexMarker306"/> owns the concerns regarding storing and maintaining digital identities. Furthermore, it resolves any security claim by authenticating the submitted digital identity with its quorum of stored identities.</li>
				<li><strong class="bold">Authentication strategy</strong>: The authentication strategy<a id="_idIndexMarker307"/> will dictate how a microservice will communicate with the identity provider to authenticate and authorize the user requests.</li>
			</ul>
			<p>Adding to the diagram of the components from <a href="B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Working on Restful Web Services</em>, the following will be the changes in this chapter within each microservice:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_4.1_B16585.jpg" alt="Figure 4.1 – Microservice components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Microservice components</p>
			<p>We will stick to<a id="_idIndexMarker308"/> our usual pattern of separating the <a id="_idIndexMarker309"/>concerns. We will use an identity provider in tandem with an authentication strategy within each of the microservices. </p>
			<p>In the next section, our focus will be to cover out-of-the-box tools provided by the Micronaut framework for security concerns.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>The basics of Micronaut security</h1>
			<p>For handling any <a id="_idIndexMarker310"/>security aspects, the Micronaut framework has a built-in <strong class="source-inline">SecurityFilter</strong> object. The <strong class="source-inline">SecurityFilter</strong> object intercepts any incoming HTTP requests and kickstarts the authentication/authorization process as configured in the <a id="_idIndexMarker311"/>application. In the following diagram, you can see the workflow within the <strong class="source-inline">SecurityFilter</strong> object for authorizing a user request:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_4.2_B16585.jpg" alt="Figure 4.2 – Micronaut security filter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Micronaut security filter</p>
			<p>Micronaut's <strong class="source-inline">SecurityFilter</strong> has three essential parts:</p>
			<ul>
				<li><strong class="bold">AuthenticationFetcher</strong>: <strong class="source-inline">AuthenticationFetcher</strong> will fetch the required downstream <a id="_idIndexMarker312"/>authenticator for authenticating the user request.</li>
				<li><strong class="bold">Authenticator</strong>: <strong class="source-inline">Authenticator</strong> injects the configured authentication provider(s) and security<a id="_idIndexMarker313"/> configurations for authenticating the user request. An <strong class="source-inline">AuthenticationResponse</strong> object is created based on the success or failure of the auth operation.</li>
				<li><strong class="bold">SecurityRule</strong>: If auth is successful, then the security filter will further invoke security rules. An<a id="_idIndexMarker314"/> application can configure one or more security rules either using out-of-the-box security rules such as <strong class="source-inline">SecuredAnnotationRule</strong> or <strong class="source-inline">IpPatternsRule</strong> or by creating its own security rules by extending <strong class="source-inline">AbstractSecurityRule</strong>. If the request satisfies all the security rules, then a successful <strong class="source-inline">AuthenticationResponse</strong> response is returned by the security filter; otherwise, it will return a failed <strong class="source-inline">AuthenticationResponse</strong> response.</li>
			</ul>
			<p>By leveraging <strong class="source-inline">SecurityFilter</strong>, in the next section, we will focus on how to secure a microservice using session authentication in the Micronaut framework.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Securing service endpoints using session authentication </h1>
			<p>In session-based <a id="_idIndexMarker315"/>authentication, the user state is stored at the server side. When a user logs in to the server, the server starts the session and issues a session ID in a cookie. The server uses the session ID to uniquely identify a session from the session quorum. Any subsequent user requests must have this session ID passed as a cookie to resume the session:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_4.3_B16585.jpg" alt="Figure 4.3 – Session-based authentication&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 4.3 – Session-based authentication</p>
			<p>As shown in the preceding figure, in a session-based authentication strategy, the server does the heavy lifting of keeping a track of the session. A client must provide a valid session ID to resume the session.</p>
			<p>To learn how to secure a microservice using session-based authentication, we will experiment on the <strong class="source-inline">pet-owner</strong> microservice. To begin, we will need to enable security by adding the following dependencies to the <strong class="source-inline">pom.xml</strong> project:</p>
			<p class="source-code">&lt;!-- Micronaut security --&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security-session&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">…</p>
			<p>By <a id="_idIndexMarker316"/>importing the <strong class="source-inline">micronaut-security</strong> and <strong class="source-inline">micronaut-security-session</strong> dependencies, we can leverage the session authentication toolkit in the <strong class="source-inline">pet-owner</strong> microservice. Once these dependencies are imported, we will then need to configure <strong class="source-inline">application.properties</strong> as shown in the next code block: </p>
			<p class="source-code">security:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">    authentication: session</p>
			<p class="source-code">    session:</p>
			<p class="source-code">      enabled: true</p>
			<p class="source-code">    # Auth endpoint</p>
			<p class="source-code">    endpoints:</p>
			<p class="source-code">      login:</p>
			<p class="source-code">        enabled: true</p>
			<p class="source-code">      logout:</p>
			<p class="source-code">        enabled: true</p>
			<p>As mentioned in the preceding <strong class="source-inline">application.properties</strong> instance, we will enable the security by setting <strong class="source-inline">enabled</strong> to <strong class="source-inline">true</strong> and specifying <strong class="source-inline">session</strong> as the desired authentication strategy. Furthermore, the Micronaut security toolkit provides <strong class="source-inline">LoginController</strong> and <strong class="source-inline">LogoutController</strong> out of the box. In the application properties, we have<a id="_idIndexMarker317"/> enabled them and since we haven't specified a custom path for these controllers, they will be accessible at default specified paths of <strong class="source-inline">…/login</strong> and <strong class="source-inline">…/logout</strong>, respectively. </p>
			<p>We will use a basic local identity provider that will leverage application properties to store user data. This is very primitive but will help in simplifying learning and exploration. Let's add some user data to <strong class="source-inline">application.properties</strong>:</p>
			<p class="source-code">identity-store:</p>
			<p class="source-code">  users:</p>
			<p class="source-code">    alice: alice@1</p>
			<p class="source-code">    bob: bob@2</p>
			<p class="source-code">    charlie: charlie@3</p>
			<p class="source-code">  roles:</p>
			<p class="source-code">    alice: ADMIN</p>
			<p class="source-code">    bob: VIEW</p>
			<p class="source-code">    charlie: VIEW</p>
			<p>We have added three users: <strong class="source-inline">alice</strong>, <strong class="source-inline">bob</strong>, and <strong class="source-inline">charlie</strong>. Each user is also assigned a role for the <strong class="source-inline">pet-owner</strong> microservice.</p>
			<p>In the next section, we will explore how to implement an authentication provider that will use the configured application properties for user data.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Implementing a basic authentication provider</h2>
			<p>To implement a <a id="_idIndexMarker318"/>basic authentication provider, we will begin by creating a <strong class="source-inline">com.packtpub.micronaut.security</strong> security package. This package will encompass all the artifacts concerning security. </p>
			<p>We will first add <strong class="source-inline">IdentityStore</strong> to this package:</p>
			<p class="source-code">@ConfigurationProperties("identity-store")</p>
			<p class="source-code">public class IdentityStore {</p>
			<p class="source-code">    @MapFormat</p>
			<p class="source-code">    Map&lt;String, String&gt; users;</p>
			<p class="source-code">    @MapFormat</p>
			<p class="source-code">    Map&lt;String, String&gt; roles;</p>
			<p class="source-code">    public String getUserPassword(String username) {</p>
			<p class="source-code">        return users.get(username);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public String getUserRole(String username) {</p>
			<p class="source-code">        return roles.get(username);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">IdentityStore</strong> class <a id="_idIndexMarker319"/>maps to the application properties for accessing the user data. We can leverage this identity store to implement the authentication provider, as shown in the following code snippet:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class LocalAuthProvider implements AuthenticationProvider {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    IdentityStore store;</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Publisher&lt;AuthenticationResponse&gt; </p>
			<p class="source-code">      authenticate(HttpRequest httpRequest, </p>
			<p class="source-code">      AuthenticationRequest authenticationRequest) {</p>
			<p class="source-code">        String username = </p>
			<p class="source-code">         authenticationRequest.getIdentity().toString();</p>
			<p class="source-code">        String password = </p>
			<p class="source-code">         authenticationRequest.getSecret().toString();</p>
			<p class="source-code">        if (password.equals(store.getUserPassword</p>
			<p class="source-code">         (username))) {</p>
			<p class="source-code">            UserDetails details = new UserDetails</p>
			<p class="source-code">             (username, Collections.singletonList</p>
			<p class="source-code">             (store.getUserRole(username)));</p>
			<p class="source-code">            return Flowable.just(details);</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            return Flowable.just(new </p>
			<p class="source-code">             AuthenticationFailed());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">LocalAuthProvider</strong> implements the standard <strong class="source-inline">AuthenticationProvider</strong> interface by concretely <a id="_idIndexMarker320"/>defining the <strong class="source-inline">authenticate()</strong> method. In the <strong class="source-inline">authenticate()</strong> method, we simply check whether the identity and secret specified in the user request match any username and password in the identity store. If we find a match, then we return the <strong class="source-inline">UserDetails</strong> object, else we return <strong class="source-inline">AuthenticatonFailed</strong>.</p>
			<p>In the next section, we will concentrate on how we can configure authorizations for the <strong class="source-inline">pet-owner</strong> endpoints.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Configuring authorizations for the service endpoints</h2>
			<p>Often in the <a id="_idIndexMarker321"/>user requirements for a microservice, there<a id="_idIndexMarker322"/> will be scenarios where we need anonymous as well as secured access. To begin with, we will provide anonymous access to <strong class="source-inline">PetResource</strong> and <strong class="source-inline">VisitResource</strong>. </p>
			<p>There are two ways to provide anonymous access in Micronaut security:</p>
			<ul>
				<li>Using <strong class="source-inline">@Secured(SecurityRule.IS_ANONYMOUS)</strong></li>
				<li>Configuring <strong class="source-inline">intercept-url-map</strong> in the application properties</li>
			</ul>
			<p>In the following sections, we will drill down into both approaches. </p>
			<h3>Granting anonymous access using SecurityRule.IS_ANONYMOUS</h3>
			<p>Micronaut<a id="_idIndexMarker323"/> security has <a id="_idIndexMarker324"/>a built-in anonymous access security rule. To give access to the whole controller or limit it to a specific endpoint, we can simply use the <strong class="source-inline">@Secured</strong> annotation. In <strong class="source-inline">PetResource</strong>, we have given anonymous access to all the endpoints by using this annotation at the controller level: </p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">@Secured(SecurityRule.IS_ANONYMOUS)</p>
			<p class="source-code">public class PetResource {</p>
			<p class="source-code">….</p>
			<p class="source-code">}</p>
			<p>Using <strong class="source-inline">@Secured(SecurityRule.IS_ANONYMOUS)</strong> allows anonymous access to all the <strong class="source-inline">PetResource</strong> endpoints. We can simply boot the service and try accessing any <strong class="source-inline">PetResource</strong> endpoint. You can use any REST client to hit the endpoint. In the following screenshot, you'll notice how we are using a rest client to make the HTTP GET call:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_4.4_B16585.jpg" alt="Figure 4.4 – Anonymous access to pets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Anonymous access to pets</p>
			<p>As shown in the <a id="_idIndexMarker325"/>preceding screenshot, we <a id="_idIndexMarker326"/>can anonymously access <strong class="source-inline">PetResource</strong> as it is configured for anonymous access using <strong class="source-inline">@Secured(SecurityRule.IS_ANONYMOUS)</strong>. </p>
			<p>In the next section, we will see how we can grant anonymous access using application properties. </p>
			<h3>Granting anonymous access using application properties</h3>
			<p>We can also <a id="_idIndexMarker327"/>configure anonymous access to a controller or specific endpoint in the controller using application properties. In the following code snippet, we are configuring anonymous access to <strong class="source-inline">…/api/visits</strong> endpoints:</p>
			<p class="source-code"># Intercept rules</p>
			<p class="source-code">    intercept-url-map:</p>
			<p class="source-code">      - pattern: /api/visits</p>
			<p class="source-code">        access: isAnonymous()</p>
			<p>In the application properties, we have configured that any user request to <strong class="source-inline">…/api/visits</strong> should be granted anonymous access. This will allow all users (authenticated as well as unauthenticated) to access <strong class="source-inline">VisitResource</strong>. </p>
			<p>To quickly test that we can access <strong class="source-inline">…/api/vistis</strong> anonymously, we can try hitting any <strong class="source-inline">VisitResource</strong> endpoint:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_4.5_B16585.jpg" alt="Figure 4.5 – Anonymous access to visits&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Anonymous access to visits</p>
			<p>As shown in the <a id="_idIndexMarker328"/>preceding screenshot, we can anonymously access <strong class="source-inline">VisitResource</strong> as it is configured for anonymous access using <strong class="source-inline">intercept-url-map</strong> in <strong class="source-inline">application.properties</strong>. </p>
			<p>In the next section, we will explore how to grant secure access using the earlier-defined authentication provider.</p>
			<h3>Granting secured access using the local identity provider</h3>
			<p>To grant<a id="_idIndexMarker329"/> secured access, we can use the <strong class="source-inline">@Secured</strong> annotation as well as <strong class="source-inline">intercept-url-map</strong>. In this hands-on <strong class="source-inline">OwnerResource</strong>, we will<a id="_idIndexMarker330"/> define secured access to <strong class="source-inline">OwnerResource</strong> using the <strong class="source-inline">@Secured</strong> annotation. Check out the following code block:</p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">@Secured(SecurityRule.IS_AUTHENTICATED)</p>
			<p class="source-code">public class OwnerResource {</p>
			<p class="source-code">…</p>
			<p class="source-code">}</p>
			<p>All the endpoints within <strong class="source-inline">OwnerResource</strong> are granted only secured access. If we try to hit any <strong class="source-inline">…/owners</strong> endpoint, the microservice will return a forbidden response, as shown next:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_4.6_B16585.jpg" alt="Figure 4.6 – Unauthenticated access to owners&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Unauthenticated access to owners</p>
			<p>As shown in the preceding screenshot, if we try to access any owner endpoint without specifying identity credentials, the microservice will throw an <strong class="source-inline">HTTP 401 Unauthorized</strong> response.</p>
			<p>For successful access to the owner endpoints, we will need to obtain a session cookie. We can log in using the built-in login controller. To log in, simply send a post request to the <strong class="source-inline">…/login</strong> path with the correct username and password:</p>
			<p class="source-code">curl –v "POST" "http://localhost:8081/login" –H 'Content-Type: application/json; charset=utf-8' –d '{"username":"alice","password":"alice@1"}'</p>
			<p>If the request succeeds, a cookie will be sent in the response: </p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_4.7_B16585.jpg" alt="Figure 4.7 – Obtaining a cookie for the secured access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Obtaining a cookie for the secured access</p>
			<p>As observed<a id="_idIndexMarker331"/> in the preceding <a id="_idIndexMarker332"/>screenshot, we will send a post request to <strong class="source-inline">…/login</strong> using the correct username and password, to which the service will return a cookie in response.</p>
			<p>We can pass this cookie to any requests to <strong class="source-inline">OwnerResource</strong>. In the following screenshot, we passed the obtained cookie to make an HTTP GET call to the <strong class="source-inline">/api/owners</strong> endpoint:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_4.8_B16585.jpg" alt="Figure 4.8 – Using an obtained cookie for the secured access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Using an obtained cookie for the secured access</p>
			<p>Since we <a id="_idIndexMarker333"/>passed the obtained <a id="_idIndexMarker334"/>cookie in the request headers, the service will extract this cookie, validate, and successfully return the <strong class="source-inline">HTTP 200</strong> response. </p>
			<p>Until now, we covered how to address anonymous and authenticated access scenarios using session authentication. In the next section, we will dive into using <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) for <a id="_idIndexMarker335"/>securing access to a microservice in the Micronaut framework.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Using JWT authentication to secure the service endpoints</h1>
			<p>In<a id="_idIndexMarker336"/> token-based authentication, the<a id="_idIndexMarker337"/> user state is stored at the client side. When a client logs in to the server, the server encrypts the user data into a token with a secret and sends it back to the client. Any subsequent user requests must have this token set in the request header. The server retrieves the token, validates the authenticity, and resumes the user session:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_4.9_B16585.jpg" alt="Figure 4.9 – Token-based authentication&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Token-based authentication</p>
			<p>As shown in the preceding diagram, in a token-based authentication strategy, the client does the heavy lifting of keeping track of the session in the JSON web token. A client must provide a valid token to resume the session.</p>
			<p>To learn how to secure a microservice using token-based authentication, we will work on a hands-on <strong class="source-inline">pet-clinic</strong> microservice. To begin, we will set up a third-party identity provider using Keycloak. In the next section, we will set up Keycloak locally.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Setting up Keycloak as the identity provider</h2>
			<p>We will <a id="_idIndexMarker338"/>run the Keycloak server in the local Docker container. If you don't have<a id="_idIndexMarker339"/> Docker installed, you may refer to the <em class="italic">Technical requirements</em> section to see how to install Docker on your development workspace. To boot up a local Keycloak server in Docker, open a Bash terminal and run the following command:</p>
			<p class="source-code">$ docker run -d --name keycloak -p 8888:8080 -e KEYCLOAK_USER=micronaut -e KEYCLOAK_PASSWORD=micronaut123 jboss/keycloak</p>
			<p>After this, Docker will instantiate a Keycloak server in a container and mount container port <strong class="source-inline">8080</strong> to host operating system port <strong class="source-inline">8888</strong>. Furthermore, it will create a <strong class="source-inline">micronaut</strong> admin<a id="_idIndexMarker340"/> user with the password as <strong class="source-inline">micronaut123</strong>. After<a id="_idIndexMarker341"/> successful installation, you can access Keycloak at <strong class="source-inline">http://localhost:8888/</strong>. In the next section, we will begin by setting up a client for the microservice.</p>
			<h3>Creating a client on the Keycloak server</h3>
			<p>To use<a id="_idIndexMarker342"/> Keycloak as an identity provider, we will start with<a id="_idIndexMarker343"/> setting up a client. Follow these instructions to set up a Keycloak identity provider client:</p>
			<ol>
				<li>Access the <strong class="bold">Keycloak admin</strong> module at <a href="http://localhost:8888/auth/admin/">http://localhost:8888/auth/admin/</a>.</li>
				<li>Provide a valid admin username and password (in our case, it's <strong class="source-inline">micronaut</strong> and <strong class="source-inline">micronaut123</strong>).</li>
				<li>Select <strong class="bold">Clients</strong> from the left navigation menu.</li>
				<li>Provide a client ID (you can skip the rest of the inputs).</li>
				<li>After creating a client with the provided Client ID, Keycloak will open the settings tab for the client. You must select the highlighted values shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_4.10_B16585.jpg" alt="Figure 4.10 – Creating a client in the Keycloak server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Creating a client in the Keycloak server</p>
			<p>The <a id="_idIndexMarker344"/>Keycloak server will create the <strong class="source-inline">pet-clinic</strong> client in<a id="_idIndexMarker345"/> the default master realm. Next, we will set up some users for this client space. </p>
			<h3>Setting up the users in the client space</h3>
			<p>The user setup <a id="_idIndexMarker346"/>will enable us to use these identities as test users (and, of course, later, the actual users can be configured). We will begin by creating the roles. For the <strong class="source-inline">pet-clinic</strong> microservice, we will define two roles: <strong class="source-inline">pet-clinic-admin</strong> and <strong class="source-inline">pet-clinic-user</strong>. To create a role, follow the instructions mentioned next:</p>
			<ol>
				<li value="1">Select <strong class="bold">Roles</strong> on the main menu.</li>
				<li>Hit the <strong class="bold">Add Role</strong> button.</li>
				<li>Provide a role name and hit the <strong class="bold">Save</strong> button.</li>
			</ol>
			<p>We will add three users – <strong class="source-inline">Alice</strong> (admin), <strong class="source-inline">Bob</strong> (user), and <strong class="source-inline">Charlie</strong> (user). To add a user, follow the instructions mentioned next:</p>
			<ol>
				<li value="1">Select <strong class="bold">Users</strong> on the main menu and hit <strong class="bold">Add User</strong>. </li>
				<li>Provide a username and keep the default settings. Hit the <strong class="bold">Save</strong> button.</li>
				<li>Once the <a id="_idIndexMarker347"/>user is created, go to the <strong class="bold">Credentials</strong> tab specify the password and change the <strong class="bold">Temporary</strong> flag to <strong class="bold">off</strong>. Hit the <strong class="bold">Reset</strong> <strong class="bold">Password</strong> button. </li>
				<li>To configure <strong class="source-inline">user-role</strong>, go to the <strong class="bold">Role Mappings</strong> tab and select the desired user role. Changes will be saved automatically.</li>
			</ol>
			<p>Repeat the preceding instructions to set up <strong class="source-inline">Alice</strong> as <strong class="source-inline">pet-clinic-admin</strong>, <strong class="source-inline">Bob</strong> as <strong class="source-inline">pet-clinic-user</strong>, and <strong class="source-inline">Charlie</strong> as <strong class="source-inline">pet-clinic-user</strong>. </p>
			<p>In order to surface this role data from Keycloak, we need to make the following changes:</p>
			<ol>
				<li value="1">Select the <strong class="bold">Client Scopes</strong> option from the main menu.</li>
				<li>Select <strong class="bold">Roles</strong> in the listed options.</li>
				<li>Go to the <strong class="bold">Mappers</strong> tab for the roles and select <strong class="bold">Realm Roles</strong>.</li>
				<li>Provide the input as highlighted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_4.11_B16585.jpg" alt="Figure 4.11 – Configuring the Realm Roles mapper&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Configuring the Realm Roles mapper</p>
			<p>Once the users are<a id="_idIndexMarker348"/> created and roles are assigned, we can proceed with the <strong class="source-inline">pet-clinic</strong> microservice changes. In the next section, we will dive into making <strong class="source-inline">pet-clinic</strong> secure using token-based authentication with a Keycloak identity provider.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Securing the pet-clinic microservice using token-based authentication</h2>
			<p>To <a id="_idIndexMarker349"/>secure the <strong class="source-inline">pet-clinic</strong> microservice, we<a id="_idIndexMarker350"/> will first need to enable security by adding the following dependencies in the <strong class="source-inline">pom.xml</strong> project:</p>
			<p class="source-code">&lt;!-- Micronaut security --&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;${micronaut.version}&lt;/version&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security-jwt&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;version&gt;${micronaut.version}&lt;/version&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security-oauth2&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;${micronaut.version}&lt;/version&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">…</p>
			<p>By<a id="_idIndexMarker351"/> importing the <strong class="source-inline">micronaut-security</strong> and <strong class="source-inline">micronaut-security-jwt</strong> dependencies, we can <a id="_idIndexMarker352"/>leverage the token authentication toolkit in the <strong class="source-inline">pet-clinic</strong> microservice. We will use OAuth 2 for integrating with the Keycloak server. Once these dependencies are imported, we will then need to configure <strong class="source-inline">application.properties</strong> as follows:</p>
			<p class="source-code">security:</p>
			<p class="source-code">    authentication: idtoken</p>
			<p class="source-code">    endpoints:</p>
			<p class="source-code">      login:</p>
			<p class="source-code">        enabled: true</p>
			<p class="source-code">    redirect:</p>
			<p class="source-code">      login-success: /secure/anonymous</p>
			<p class="source-code">    token:</p>
			<p class="source-code">      jwt:</p>
			<p class="source-code">        enabled: true</p>
			<p class="source-code">        signatures.jwks.keycloak:</p>
			<p class="source-code">          url: http://localhost:8888/auth/realms/master/protocol/openid-connect/certs</p>
			<p class="source-code">    oauth2.clients.keycloak:</p>
			<p class="source-code">      grant-type: password</p>
			<p class="source-code">      client-id: pet-clinic</p>
			<p class="source-code">      client-secret: XXXXXXXXX</p>
			<p class="source-code">      authorization:</p>
			<p class="source-code">        url: http://localhost:8888/auth/realms/master/protocol/openid-connect/auth</p>
			<p class="source-code">      token:</p>
			<p class="source-code">        url: http://localhost:8888/auth/realms/master/protocol/openid-connect/token</p>
			<p class="source-code">        auth-method: client_secret_post</p>
			<p>In the <a id="_idIndexMarker353"/>application properties, <strong class="source-inline">client-id</strong> and <strong class="source-inline">client-secret</strong> must be copied from <strong class="source-inline">KeyCloak</strong>. Client <a id="_idIndexMarker354"/>secret can be copied by going to <strong class="bold">Clients</strong> | <strong class="bold">pet-clinic</strong> client | <strong class="bold">Credentials</strong> tab. Furthermore, the URLs for authorization and tokens are standard but you can access all the configurations at <strong class="source-inline">http://localhost:8888/auth/realms/master/.well-known/openid-configuration</strong>. </p>
			<p>In the next section, we will focus on how to grant secured access to the controller endpoints using the configured token-based authentication strategy and Keycloak identity server.</p>
			<h3>Granting secured access using the KeyCloak identity provider</h3>
			<p>To grant<a id="_idIndexMarker355"/> secured access, we can use the <strong class="source-inline">@Secured</strong> annotation <a id="_idIndexMarker356"/>as well as <strong class="source-inline">intercept-url-map</strong>. In the hands-on example, we will grant secured access to <strong class="source-inline">VetResource</strong> using the <strong class="source-inline">@Secured</strong> annotation, as shown in the following code snippet:</p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">@Secured(SecurityRule.IS_AUTHENTICATED)</p>
			<p class="source-code">public class VetResource {</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p>All the endpoints within <strong class="source-inline">VetResource</strong> are granted only secured access. If we try to hit any <strong class="source-inline">…/vets</strong> endpoints, the microservice will return a forbidden response:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_4.12_B16585.jpg" alt="Figure 4.12 – Unauthenticated access to vets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Unauthenticated access to vets</p>
			<p>As shown in the preceding figure, if we try to access any vet endpoint without specifying a valid token, the microservice will throw an <strong class="source-inline">HTTP 401 Unauthorized</strong> response.</p>
			<p>For successful access to the vet endpoints, we will need to obtain a valid JWT. We can log in using the built-in login controller. To log in, simply send a post request to the <strong class="source-inline">…/login</strong> path with the correct username and password. If the request succeeds, a cookie with a JWT will be sent in the response, as shown in the next screenshot:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_4.13_B16585.jpg" alt="Figure 4.13 – Obtaining a cookie for the secured access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Obtaining a cookie for the secured access</p>
			<p>As highlighted <a id="_idIndexMarker357"/>in the screenshot, we <a id="_idIndexMarker358"/>will send a post request to the <strong class="source-inline">…/login</strong> endpoint using the correct username and password. The service will grant the secured access using the KeyCloak identity provider and return a cookie with the JWT.</p>
			<p>Copy the JWT portion from the preceding response. We can pass this token to any requests to <strong class="source-inline">VetResource</strong>. In the following screenshot, we are invoking the <strong class="source-inline">…/vets</strong> endpoint using the just-obtained JWT:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_4.14_B16585.jpg" alt="Figure 4.14 – Using the obtained token for the secured access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – Using the obtained token for the secured access</p>
			<p>Since we<a id="_idIndexMarker359"/> passed a valid token in the<a id="_idIndexMarker360"/> request headers, the service will validate this token and successfully return the <strong class="source-inline">HTTP 200</strong> response. </p>
			<p>So far, we have explored how to secure a microservice using a JWT with an external identity provider. In the next section, we will focus on how to implement microservice security using OAuth with a cloud identity provider.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Using OAuth to secure service endpoints</h1>
			<p>OAuth is yet <a id="_idIndexMarker361"/>another token-based authentication<a id="_idIndexMarker362"/> strategy. Its wide acceptability, good coverage of the depth and breadth of web security concerns, and the flexibility of managing user sessions at both the client and server side make it an enterprise-grade authentication mechanism. OAuth dictates to use the token to establish the identity instead of passing usernames and passwords. A token can be obtained from an external identity provider and this token can then be passed to any subsequent requests to resume a session:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_4.15_B16585.jpg" alt="Figure 4.15 – Separating the concerns with OAuth&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – Separating the concerns with OAuth</p>
			<p>As shown in the preceding figure, in the OAuth token-based authentication strategy, the client obtains a token from the identity provider and uses this token in any API requests to the server. The server validates this token with the identity provider to return a proper response. </p>
			<p>To learn how to secure a microservice using an OAuth and cloud-based identity provider, we will do a hands-on exercise with the <strong class="source-inline">pet-clinic-review</strong> microservice. To begin, we will set up a cloud identity provider using Okta.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Setting up Okta as the identity provider</h2>
			<p>Okta is a leading <a id="_idIndexMarker363"/>SaaS identity management portal. We will use <a id="_idIndexMarker364"/>Okta as the identity provider. In order to begin, you must be registered with Okta. Sign up at <a href="http://developer.okta.com">developer.okta.com</a>. Once you're signed up, Okta will ask the user to confirm the email. In the email, you will also receive an Okta domain, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_4.16_B16585.jpg" alt="Figure 4.16 – Domain name in the Okta signup acknowledgment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – Domain name in the Okta signup acknowledgment</p>
			<p>As shown in the figure, an Okta domain will be created for your developer account. You must save this as this will be used later to configure Okta as the identity provider.</p>
			<p>In the next section, we will see how to create an application on Okta.</p>
			<h3>Creating an app on Okta</h3>
			<p>In order to use <a id="_idIndexMarker365"/>Okta with your microservice, you are required to create an<a id="_idIndexMarker366"/> app on Okta. Follow the instructions given as follows for creating an app on Okta:</p>
			<ol>
				<li value="1">Log on to <a href="https://developer.okta.com/.">https://developer.okta.com/.</a></li>
				<li>On the landing page, select <strong class="bold">Creating a Web Application</strong>.</li>
				<li>Choose <strong class="bold">Native</strong> as your platform and hit the <strong class="bold">Next</strong> button.</li>
				<li>Provide the app settings mentioned in the following screenshot and once all the inputs are provided, hit the <strong class="bold">Done</strong> button:<div id="_idContainer059" class="IMG---Figure"><img src="image/Figure_4.17_B16585.jpg" alt="Figure 4.17 – Creating the microservice app on Okta&#13;&#10;"/></div><p class="figure-caption">Figure 4.17 – Creating the microservice app on Okta</p></li>
				<li>We will keep most of the inputs as their defaults. Under <strong class="bold">Grant type allowed</strong>, check all the boxes. </li>
				<li>Once the <a id="_idIndexMarker367"/>app is created successfully, edit <strong class="bold">Client Credentials</strong> and <a id="_idIndexMarker368"/>select the <strong class="bold">Use client authentication</strong> option for <strong class="bold">Client authentication</strong>. </li>
			</ol>
			<p>After creating the application as previously instructed, jot down the client ID and client secret. This will be used later. Next, we will set up some users for this app.</p>
			<h3>Setting up the users in the client space</h3>
			<p>The user setup <a id="_idIndexMarker369"/>will enable us to use these identities as test users. We will add three users – <strong class="source-inline">Alice</strong> (admin), <strong class="source-inline">Bob</strong> (user), and <strong class="source-inline">Charlie</strong> (user). To add a user, follow the given instructions:</p>
			<ol>
				<li value="1">On the main navigation bar, hover over <strong class="bold">Users</strong> and select <strong class="bold">People</strong>. </li>
				<li>Hit the <strong class="bold">Add Person</strong> button.</li>
				<li>Provide inputs as shown in the following screenshot:<div id="_idContainer060" class="IMG---Figure"><img src="image/Figure_4.18_B16585.jpg" alt="Figure 4.18 – Adding a person (user) on Okta&#13;&#10;"/></div><p class="figure-caption">Figure 4.18 – Adding a person (user) on Okta</p></li>
				<li>In the password input, choose <strong class="bold">Set by admin</strong> and you must keep <strong class="bold">User must change password on first login</strong> unchecked. This will allow us to quickly use the identity without<a id="_idIndexMarker370"/> resetting the password.</li>
			</ol>
			<p>Repeat the preceding instructions for setting up <strong class="source-inline">Bob</strong> and <strong class="source-inline">Charlie</strong> as application users. Once the users are created, we can proceed with the <strong class="source-inline">pet-clinic-reviews</strong> microservice changes. </p>
			<p>In the next section, we will dive into making <strong class="source-inline">pet-clinic-reviews</strong> secure but let's first start with enabling SSL to make encrypted communication over HTTPS.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Enabling SSL in the Micronaut framework</h2>
			<p>Any security<a id="_idIndexMarker371"/> safeguarding is left incomplete if a<a id="_idIndexMarker372"/> microservice is not exposed to HTTPS. In earlier sections, we purposely focused on authentication and authorization only while skipping SSL. As we will be using a third-party identity provided over the cloud, it's recommended and required to enable SSL in the <strong class="source-inline">pet-clinic-reviews</strong> microservice.</p>
			<p>In order to enable SSL, we will need an SSL certificate for localhost. We will be creating a self-signed certificate using OpenSSL. Follow these instructions for creating a self-signed certificate using OpenSSL:</p>
			<ol>
				<li value="1">Open a Git Bash terminal.</li>
				<li>Change directory to the root directory of the <strong class="source-inline">pet-clinic-reviews</strong> project.</li>
				<li>Run <strong class="source-inline">winpty openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365</strong> in Git Bash. Provide the correct information to create a self-signed certificate. This will create a <strong class="source-inline">key.pem</strong> file and <strong class="source-inline">cert.pem</strong> file in the opened directory. </li>
				<li>To combine the key and certificate files, run <strong class="source-inline">winpty openssl pkcs12 -inkey key.pem -in cert.pem -export -out cert.p12</strong> in Git Bash.</li>
				<li>To verify that you've created the P12 file, run <strong class="source-inline">winpty openssl pkcs12 -in cert.p12 -noout -info</strong> in Git Bash. You must provide the same password that was used to create the P12 file.</li>
			</ol>
			<p>Following the previous instructions, we can successfully create a platform-agnostic certificate. The P12 format has gained popularity as it can be used across platforms and operating systems. Next, we will add this certificate to the host operating system trust store so it can be trusted by all the running applications on the system. Follow the instructions mentioned next to add the certificate to the trust store: </p>
			<ol>
				<li value="1">Determine <strong class="source-inline">$JAVA_HOME</strong>. It can be found in the system variables.</li>
				<li>Copy the just-created <strong class="source-inline">cert.pem</strong> file to <strong class="source-inline">$JAVA_HOME/jre/lib/security/cacerts</strong>.</li>
				<li>Open the Git Bash terminal with admin rights and change the directory to <strong class="source-inline">$JAVA_HOME/jre/lib/security</strong>.</li>
				<li>Run <strong class="source-inline">winpty keytool -importcert -file cert.pem -alias localhost -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit</strong> in the Git Bash terminal.</li>
			</ol>
			<p>By following the previous instructions, we will add the self-signed certificate to the trust store. This will enable the system to trust this certificate when it's used over SSL. </p>
			<p>Our custom developer <a id="_idIndexMarker373"/>Okta domain may also not be trusted by the <a id="_idIndexMarker374"/>system. We will follow similar instructions to add the Okta certificate to the <strong class="source-inline">cacerts</strong> trust store: </p>
			<ol>
				<li value="1">Open a new tab in the Chrome browser. Open the developer tools.</li>
				<li>Hit <strong class="source-inline">https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}</strong>.</li>
				<li>In the developer tools, go to the <strong class="bold">Security</strong> tab and click on <strong class="bold">View certificate</strong>. </li>
				<li>This will open the certificate in a prompt. Go to the <strong class="bold">Details</strong> tab on this prompt. </li>
				<li>Click on <strong class="bold">Copy file</strong> and follow the instructions to export the certificate to a local directory. </li>
				<li>Copy the just-exported certificate to <strong class="source-inline">$JAVA_HOME/jre/lib/security/cacerts</strong>.</li>
				<li>Open the Git Bash terminal with admin rights and change the directory to <strong class="source-inline">$JAVA_HOME/jre/lib/security</strong>.</li>
				<li>Run <strong class="source-inline">winpty keytool -importcert -file okta.cert -alias localhost -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit</strong> in the Git Bash terminal. In the file option, you must provide the exported certificate name.</li>
			</ol>
			<p>Adding the developer domain Okta certificate to the system trust store will enable us to communicate with the Okta identity provider. In the next section, we will dive into enabling SSL in the <strong class="source-inline">pet-clinic-reviews</strong> microservice using the self-signed certificate.</p>
			<h3>Configuring the application properties for SSL</h3>
			<p>Once you have a<a id="_idIndexMarker375"/> legible certificate, the Micronaut framework <a id="_idIndexMarker376"/>provides a quick way to turn on SSL by configuring some application properties. Make the following changes to the application properties to enable SSL:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  ssl:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">    key-store:</p>
			<p class="source-code">      type: PKCS12</p>
			<p class="source-code">      path: file:cert.p12</p>
			<p class="source-code">      password: Pass@w0rd</p>
			<p>To enable SSL, we have used a self-signed certificate that we created in the previous section. The <strong class="bold">password</strong> field must match the password used to create the certificate. By making these changes to the application properties, Micronaut will enable SSL for the application and use port <strong class="source-inline">8443</strong> for secured communication.</p>
			<p>In the next section, we will focus on how to configure the <strong class="source-inline">pet-clinic-reviews</strong> microservice with OAuth security using the Okta identity provider.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Securing the pet-clinic-reviews microservice using OAuth</h2>
			<p>To <a id="_idIndexMarker377"/>secure the <strong class="source-inline">pet-clinic</strong> microservice, we<a id="_idIndexMarker378"/> will first need to enable security by adding the following dependencies in the <strong class="source-inline">pom</strong> project:</p>
			<p class="source-code">&lt;!-- Micronaut security --&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security-jwt&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut.security&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-security-oauth2&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">…</p>
			<p>By importing the <strong class="source-inline">micronaut-security</strong> and <strong class="source-inline">micronaut-security-jwt</strong> dependencies, we can <a id="_idIndexMarker379"/>leverage the token <a id="_idIndexMarker380"/>authentication and OAuth toolkit in the <strong class="source-inline">pet-clinic-reviews</strong> microservice. Once these dependencies are imported, we will then need to configure <strong class="source-inline">application.properties</strong> as follows:</p>
			<p class="source-code">security:</p>
			<p class="source-code">    authentication: idtoken</p>
			<p class="source-code">    oauth2:</p>
			<p class="source-code">      clients:</p>
			<p class="source-code">        okta:</p>
			<p class="source-code">          client-secret: HbheS-</p>
			<p class="source-code">           q4P6oewQgT7uK58bgMbtHbCwcarzWuHB32</p>
			<p class="source-code">          client-id: 0oa37vkb7Sq23P1kh5d6</p>
			<p class="source-code">          openid:</p>
			<p class="source-code">            issuer: https://dev-</p>
			<p class="source-code">             4962048.okta.com/oauth2/default</p>
			<p class="source-code">    endpoints:</p>
			<p class="source-code">      logout:</p>
			<p class="source-code">        get-allowed: true</p>
			<p>In the <a id="_idIndexMarker381"/>application properties, <strong class="source-inline">client-id</strong> and <strong class="source-inline">client-secret</strong> must be copied from Okta. For the issuer, you <a id="_idIndexMarker382"/>must provide your Okta domain in the first part. You might just need to change your developer domain but you can get more information on authorization and token URLs by accessing the OAuth configurations at <strong class="source-inline">https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}</strong>.</p>
			<p>In the next section, we will focus on how to grant secured access to the controller endpoints using the OAuth and Okta identity servers.</p>
			<h3>Granting secured access using the Okta identity provider</h3>
			<p>For granting<a id="_idIndexMarker383"/> secured access, we can use <a id="_idIndexMarker384"/>the <strong class="source-inline">@Secured</strong> annotation as well as <strong class="source-inline">intercept-url-map</strong>. In our hands-on example, we will grant secured access to <strong class="source-inline">VetReviewResource</strong> using the <strong class="source-inline">@Secured</strong> annotation:</p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">@Secured(SecurityRule.IS_AUTHENTICATED)</p>
			<p class="source-code">public class VetReviewResource {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>All the endpoints within <strong class="source-inline">VetReviewResource</strong> are granted only secured access. If we try to hit any <strong class="source-inline">…/vet-reviews</strong> endpoints, the microservice will return a forbidden response. In the<a id="_idIndexMarker385"/> following figure, we <a id="_idIndexMarker386"/>tried to access the <strong class="source-inline">…/vet-reviews</strong> endpoint unsecured and the service responded with <strong class="source-inline">HTTP 401</strong>:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_4.19_B16585.jpg" alt="Figure 4.19 – Unauthenticated access to vets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – Unauthenticated access to vets</p>
			<p>As highlighted <a id="_idIndexMarker387"/>in the previous screenshot, if <a id="_idIndexMarker388"/>we try to access any <strong class="source-inline">vet-reviews</strong> endpoint without specifying a valid token, the microservice will throw an <strong class="source-inline">HTTP 401 Unauthorized</strong> response.</p>
			<p>For successful access to the vet endpoints, we will need to obtain a valid JWT. We can obtain a valid token by accessing the Okta token API. The following is the <strong class="source-inline">curl</strong> command to call the Okta token API:</p>
			<p class="source-code">curl -k -u client_id:client_secret \</p>
			<p class="source-code">--location --request POST 'https://dev-4962048.okta.com//oauth2/default/v1/token' \</p>
			<p class="source-code">--header 'Accept: application/json' \</p>
			<p class="source-code">--header 'Content-Type: application/x-www-form-urlencoded' \</p>
			<p class="source-code">--data-urlencode 'grant_type=password' \</p>
			<p class="source-code">--data-urlencode 'username=Alice' \</p>
			<p class="source-code">--data-urlencode 'password=Pass@w0rd' \</p>
			<p class="source-code">--data-urlencode 'scope=openid'</p>
			<p>In the previous <strong class="source-inline">curl</strong> command, you must provide the correct values in <strong class="source-inline">client_id</strong> and <strong class="source-inline">client_secret</strong>, the <strong class="source-inline">POST</strong> URL and the user credentials. If everything is validated <a id="_idIndexMarker389"/>successfully, the token API will <a id="_idIndexMarker390"/>respond back with a bearer and ID token. Copy the returned access token. We can pass this token to any requests to <strong class="source-inline">VetReviewResource</strong> for secured communication:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_4.20_B16585.jpg" alt="Figure 4.20 – Using the obtained token for secured access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20 – Using the obtained token for secured access</p>
			<p>Since we passed a valid token in the request headers, the service will validate this token and successfully return the <strong class="source-inline">HTTP 200</strong> response.</p>
			<p>In this section, we learned about and experimented with OAuth security. To make <strong class="source-inline">pet-clinic-reviews</strong> service endpoints secure, we used OAuth with Okta as a third-party identity provider. </p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Summary</h1>
			<p>In this chapter, we explored various ways to secure microservices in the Micronaut framework. We began our journey by diving into a session authentication strategy, and then we explored token-based authentication using an external Keycloak identity server. Lastly, we worked on securing a microservice using OAuth with a cloud-based identity provider. Furthermore, we also worked on enabling SSL to make service communication secure over HTTPS.</p>
			<p>This chapter provided you with a handy, focused skillset in safeguarding a microservice in the Micronaut framework using various authentication strategies, along with how to work with local or external (cloud) identity providers. </p>
			<p>In the next chapter, we will explore how we can integrate different microservices using event-driven architecture.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Questions</h1>
			<ol>
				<li value="1">What are the various authentication strategies in the Micronaut framework? </li>
				<li>What is a security filter in Micronaut? </li>
				<li>How do you set up session-based authentication in the Micronaut framework?</li>
				<li>What is the <strong class="source-inline">@Secured</strong> annotation in the Micronaut framework? </li>
				<li>What is <strong class="source-inline">intercept-url-maps</strong> in the Micronaut framework? </li>
				<li>How do you set up token-based authentication in the Micronaut framework?</li>
				<li>How do you set up JWT authentication in the Micronaut framework?</li>
				<li>How do you integrate with Keycloak in the Micronaut framework?</li>
				<li>How do you set up OAuth authentication in the Micronaut framework?</li>
				<li>How do you integrate with Okta in the Micronaut framework?</li>
				<li>How do you enable SSL in the Micronaut framework?</li>
			</ol>
		</div>
	</body></html>