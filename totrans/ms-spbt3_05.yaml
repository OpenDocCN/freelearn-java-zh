- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Securing Your Spring Boot Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的 Spring Boot 应用程序
- en: 'Welcome to an important stage in your Spring Boot learning journey. In this
    chapter, we focus on security: a crucial aspect that will help you protect your
    applications against evolving digital threats. Here, you’ll learn how to implement
    strong security with Spring Boot 3.0, which includes techniques using **Open Authorization
    2.0** (**OAuth2**), **JSON Web Token** (**JWT**), and **Role-Based Access Control**
    (**RBAC**). We shall also go into the details of how to secure a reactive application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到您 Spring Boot 学习旅程的重要阶段。在本章中，我们将重点介绍安全性：这是一个至关重要的方面，将帮助您保护您的应用程序免受不断发展的数字威胁。在这里，您将学习如何使用
    Spring Boot 3.0 实现强大的安全性，包括使用 **Open Authorization 2.0**（**OAuth2**）、**JSON Web
    Token**（**JWT**）和 **基于角色的访问控制**（**RBAC**）的技术。我们还将深入了解如何确保反应式应用程序的安全性。
- en: You will learn how to authenticate users using OAuth2 and manage secure tokens
    using JWT. You will also master RBAC, whose job is to provide the right access
    to the right users. We even have a dedicated section just for reactive developers
    who want to be assured that their reactive apps are at least as secure as their
    standard web apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何使用 OAuth2 验证用户，并使用 JWT 管理安全令牌。您还将精通 RBAC，其任务是提供正确的访问权限给正确的用户。我们甚至为希望确保他们的反应式应用程序至少与标准
    Web 应用程序一样安全的反应式开发者提供了一个专门的章节。
- en: Why does this matter? In our digital world, security is not a feature; it’s
    a way of life. The concepts you are going to be a master of with this will help
    you to craft applications that are safe and trustworthy, protecting your data
    and the identity of users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要？在我们的数字世界中，安全性不是一个特性；它是一种生活方式。您将掌握的这些概念将帮助您构建安全可靠的应用程序，保护您的数据和用户身份。
- en: In the end, you will have a secure, running sample application that implements
    all the security principles mentioned. Ready to make your applications safe and
    sound? Let’s dig in!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将拥有一个安全、运行中的示例应用程序，该应用程序实现了所提到的所有安全原则。准备好使您的应用程序安全可靠了吗？让我们深入挖掘！
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing security in Spring Boot 3.0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring Boot 3.0 中引入安全性
- en: Implementing OAuth2 and JWT
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 OAuth2 和 JWT
- en: Implementing RBAC in Spring Boot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中实现 RBAC
- en: Securing reactive applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护反应式应用程序
- en: Let’s begin this journey to make your Spring Boot applications secure and robust!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这段旅程，使您的 Spring Boot 应用程序既安全又稳健！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, our local machines will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们的本地机器需要以下软件：
- en: '**Java Development Kit** (**JDK**) 17'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包**（**JDK**）17'
- en: A modern **Integrated Development Environment** (**IDE**); I recommend IntelliJ
    IDEA
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代 **集成开发环境**（**IDE**）；我推荐 IntelliJ IDEA
- en: '**GitHub repository**: You can clone all repositories related to [*Chapter
    5*](B18400_05.xhtml#_idTextAnchor179) from here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub 仓库**：您可以从这里克隆与[*第 5 章*](B18400_05.xhtml#_idTextAnchor179)相关的所有仓库：[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0)'
- en: Docker Desktop
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Introducing security in Spring Boot 3.0
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring Boot 3.0 中引入安全性
- en: In this chapter, we will delve into the aspect of security in Spring Boot 3.0\.
    Security is not a checkbox; it is an important ingredient for building any application.
    Here, we will cover security features that come integrated out of the box and
    are provided by Spring Boot, to secure our application from scratch. Now, let’s
    have a look at how all these features can be customized and extended to best serve
    our needs, ensuring that we implement not only a functional application but also
    a secure one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究 Spring Boot 3.0 的安全性方面。安全性不是一个复选框；它是构建任何应用程序的重要成分。在这里，我们将介绍 Spring
    Boot 预先集成的安全功能，以从零开始保护我们的应用程序。现在，让我们看看如何自定义和扩展所有这些功能，以满足我们的需求，确保我们不仅实现了一个功能性的应用程序，而且还是一个安全的应用程序。
- en: Firstly, let’s explore Spring Boot’s security architecture, which has been built
    to be robust and flexible. You will see how Spring Boot makes it easy to secure
    your application, with some sensible defaults out of the box, but also the ability
    to customize them for more advanced use cases. By the end of this chapter, you
    will realize why security is so important, and what tools Spring Boot 3.0 provides
    to implement effective security.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索Spring Boot的安全架构，它被构建得既强大又灵活。您将看到Spring Boot如何使保护应用程序变得简单，它提供了一些合理的默认设置，同时也允许您根据更高级的使用场景进行自定义。到本章结束时，您将意识到为什么安全性如此重要，以及Spring
    Boot 3.0提供了哪些工具来实现有效的安全性。
- en: Exploring Spring Boot 3.0’s security features
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Spring Boot 3.0的安全特性
- en: As we’re starting to build any kind of web application, the very first thing
    that comes to mind is to ensure that they are secure. Here, Spring Boot 3.0 comes
    with all the powerful utilities to secure our applications. In this section, we
    will dig into how we make a security architecture in Spring Boot 3.0 that helps
    us achieve that, ensuring that our web apps are safe and sound.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建任何类型的Web应用程序时，首先想到的便是确保它们的安全性。在这里，Spring Boot 3.0提供了所有强大的工具来确保我们的应用程序安全。在本节中，我们将深入探讨如何在Spring
    Boot 3.0中构建一个安全架构，以帮助我们实现这一目标，确保我们的Web应用程序安全可靠。
- en: The best thing about Spring Boot is that it’s really easy to set up security.
    It is based on Spring Security, a framework for securing everything. Think of
    Spring Security as a vigilant security guard who checks for every ID at the door;
    this way, it ensures that access to particular parts of your application is granted
    to only those who have the right permissions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot最棒的地方在于设置安全性的过程非常简单。它基于Spring Security，这是一个用于保护一切的系统框架。将Spring Security想象成一个警惕的安全守卫，在门口检查每一个身份证件；这样，它确保只有拥有正确权限的人才能访问应用程序的特定部分。
- en: 'The following are some of the most important security features of Spring Boot
    3.0:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Spring Boot 3.0最重要的安全特性：
- en: '**Configuring security in our application**: Setting up the security for your
    application with Spring Boot 3.0 is like configuring settings on your mobile device.
    You get to decide what you want on and what to turn off. Spring Boot allows us
    to very easily define who can access what in our application. We do this with
    a simple yet powerful configuration within our code.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在我们的应用程序中配置安全性**：使用Spring Boot 3.0为您的应用程序设置安全性就像在您的移动设备上配置设置一样。您可以选择您想要开启什么，关闭什么。Spring
    Boot允许我们非常容易地定义谁可以访问我们的应用程序中的什么内容。我们通过代码中的简单而强大的配置来实现这一点。'
- en: '**Authenticating users**: At its most basic, authentication is how we verify
    who a person is. Spring Boot 3.0 helps with this. It can be through a username
    and password, through tokens, or in some other way, and Spring Security is there
    to help you. It is very much like having a bouncer at the door of your app, making
    sure only authorized users are able to get in.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户认证**：在最基本的意义上，认证是我们验证一个人身份的方式。Spring Boot 3.0可以帮助我们完成这项工作。这可能通过用户名和密码、通过令牌或以其他方式实现，而Spring
    Security就在那里为您提供帮助。它就像在您的应用程序门口有一个保安，确保只有授权用户才能进入。'
- en: '**Authorization**: Upon identification of who a person is, one has to define
    what the person is allowed to do. Spring Security lets us set up rules for what
    authenticated users are allowed to access. It’s like giving out keys to different
    doors in your app, based on who needs to go where. As you can see, while authentication
    is verifying the identity of the user, authorization determines what resources
    and actions the user is permitted.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：在确定一个人的身份之后，必须定义这个人可以做什么。Spring Security允许我们为认证用户设置访问规则。这就像根据谁需要去哪里，给你的应用程序的不同门分发钥匙。如您所见，虽然认证是验证用户的身份，但授权决定了用户被允许访问哪些资源和执行哪些操作。'
- en: '**Defense against common threats**: The internet can be like a jungle with
    different kinds of threats hiding in it. The security architecture of Spring Boot
    3.0 is designed to protect against these threats. From **Cross-Site Scripting**
    (**XSS**) to SQL injection, Spring Security helps protect your application against
    commonly known vulnerabilities.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防御常见威胁**：互联网就像一个充满各种威胁的丛林。Spring Boot 3.0的安全架构旨在保护这些威胁。从**跨站脚本攻击**（XSS）到SQL注入，Spring
    Security帮助保护您的应用程序免受已知漏洞的侵害。'
- en: '**Leveraging advanced security features**: Getting deeper into it, Spring Boot
    3.0 provides yet another advanced security feature set. It adds OAuth2 for securing
    access to APIs and **JSON Web Tokens** (**JWTs**) for stateless authentication.
    It’s like adding an advanced security system to your application, like cameras
    and detectors.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用高级安全特性**：深入了解，Spring Boot 3.0提供了另一套高级安全特性。它添加了OAuth2来保护API访问，以及**JSON Web
    Tokens**（JWTs）来进行无状态身份验证。这就像为你的应用程序添加了一个高级安全系统，比如摄像头和探测器。'
- en: By now, we have understood and applied the security architecture of Spring Boot
    3.0, and we are in a position to develop robust and secure applications. We have
    seen the basics—from authentication and authorization to protecting against threats,
    including advanced features. It’s all about ensuring that our applications are
    safe places for our users to visit and engage with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经理解和应用了Spring Boot 3.0的安全架构，我们现在可以开发健壮且安全的应用程序。我们已经看到了基础——从身份验证和授权到保护免受威胁，包括高级特性。这一切都是为了确保我们的应用程序是用户访问和互动的安全场所。
- en: This section showed that Spring Boot 3.0 has a strong set of features under
    its security domain, built to keep our applications safe. Remember that security
    is an ongoing process. Continuously monitoring and updating is the way to go.
    The steps of continuously monitoring and updating our measures for security are
    described in this chapter. This approach ensures our applications remain secure
    over time, adapting to new challenges as they arise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了Spring Boot 3.0在其安全领域下有一套强大的特性，旨在确保我们的应用程序安全。请记住，安全是一个持续的过程。持续监控和更新是必由之路。本章描述了持续监控和更新我们安全措施步骤。这种方法确保我们的应用程序随着时间的推移保持安全，适应新出现的挑战。
- en: In this section, we have learned about Spring Boot 3.0’s basic security features.
    In the next section, we will start to look at the code for implementing Spring
    Boot security.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Spring Boot 3.0的基本安全特性。在下一节中，我们将开始查看实现Spring Boot安全性的代码。
- en: Setting up a basic security configuration
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基本安全配置
- en: 'Let’s walk through setting up a basic security configuration, ensuring your
    app is protected right from the start. The following guided walk-through will
    show you how to introduce the security layer to our sample book store application,
    making it a safe space for users and data alike:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步设置基本安全配置，确保你的应用程序从一开始就受到保护。以下指导将向你展示如何将安全层引入我们的示例书店应用程序，使其成为用户和数据的安全空间：
- en: '`build.gradle` file:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build.gradle`文件：'
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we have added all the necessary libraries to our project.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经将所有必要的库添加到我们的项目中。
- en: '**Configuring web security**: Next, we’ll create a basic security configuration
    class:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置Web安全**：接下来，我们将创建一个基本安全配置类：'
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s understand what we have introduced with this `SecurityConfig.java` class:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们了解我们通过这个`SecurityConfig.java`类引入了什么：
- en: '`@Configuration`: This annotation marks the class as a source of Bean definitions
    for the application context. It tells Spring that this class contains configuration
    information.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration`: 这个注解将类标记为应用程序上下文Bean定义的来源。它告诉Spring，这个类包含配置信息。'
- en: '`@EnableWebSecurity`: This annotation enables Spring Security’s web security
    support and provides the Spring MVC integration. It signals to the Spring Framework
    to start adding security configurations.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableWebSecurity`: 这个注解启用了Spring Security的Web安全支持，并为Spring MVC提供了集成。它向Spring框架发出信号，开始添加安全配置。'
- en: '`@Bean`: This annotation tells Spring that the method will return an object
    that should be registered as a bean in the Spring application context. In this
    case, it’s the `SecurityFilterChain` bean.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Bean`: 这个注解告诉Spring，该方法将返回一个对象，该对象应注册为Spring应用程序上下文中的一个bean。在这种情况下，它是`SecurityFilterChain`
    bean。'
- en: '`public SecurityFilterChain securityFilterChain(HttpSecurity http)`: This method
    defines the security filter chain. It takes an instance of `HttpSecurity` as a
    parameter, allowing you to configure web-based security for specific HTTP requests.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public SecurityFilterChain securityFilterChain(HttpSecurity http)`: 这个方法定义了安全过滤器链。它接受一个`HttpSecurity`实例作为参数，允许你为特定的HTTP请求配置基于Web的安全性。'
- en: '`.csrf(AbstractHttpConfigurer::disable)`: `.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))`:
    This configures the session creation policy to be stateless. In a stateless API,
    no session information is stored on the server between requests. This is typical
    for REST APIs, where each request is independent and authentication is done via
    tokens, not cookies.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.csrf(AbstractHttpConfigurer::disable)`: `.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))`:
    这配置会话创建策略为无状态。在无状态API中，请求之间不存储任何会话信息在服务器上。这对于REST API来说是典型的，其中每个请求都是独立的，认证是通过令牌而不是cookies完成的。'
- en: '`.authorizeHttpRequests(authz -> authz`: This part starts the authorization
    configuration.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.authorizeHttpRequests(authz -> authz`: 这部分开始授权配置。'
- en: '`.requestMatchers("/login").permitAll()`: This line specifies that requests
    matching the `/login` pattern should be allowed without authentication. It’s a
    way to define public endpoints within your application.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.requestMatchers("/login").permitAll()`: 这行代码指定匹配`/login`模式的请求无需认证即可允许。这是在应用程序中定义公开端点的一种方式。'
- en: '`.anyRequest().authenticated()`: This ensures that any request not matched
    by previous matchers must be authenticated. It’s a catch-all that secures the
    rest of the application by default.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.anyRequest().authenticated()`: 这确保了任何不匹配先前匹配器的请求都必须进行认证。这是一个通用的安全措施，默认情况下保护了应用程序的其余部分。'
- en: '`.httpBasic(Customizer.withDefaults())`: Enables HTTP Basic authentication.
    This is a simple, stateless authentication mechanism that allows a client to send
    a username and password with each request. The `Customizer.withDefaults()` part
    applies default configurations for HTTP Basic, making setup straightforward.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.httpBasic(Customizer.withDefaults())`: 启用HTTP基本认证。这是一个简单、无状态的认证机制，允许客户端在每个请求中发送用户名和密码。`Customizer.withDefaults()`部分为HTTP基本认证应用默认配置，使设置变得简单直接。'
- en: This code basically sets up a security filter chain that in effect disables
    CSRF protection and is perfect for stateless applications. It provides for the
    REST API’s required stateless session management and allows access only on a few
    URLs (such as through `/login`) as public. For all other URLs, it enforces to
    authenticate thorough authentication via HTTP Basic authentication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码基本上设置了一个安全过滤器链，实际上禁用了CSRF保护，非常适合无状态应用程序。它为REST API提供了所需的无状态会话管理，并允许对少数URL（如通过`/login`）进行公开访问。对于所有其他URL，它强制通过HTTP基本认证进行认证。
- en: In this section, you have learned how to put a basic security setup in place
    for your Spring Boot application. But our investigation into security is not yet
    complete.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何为你的Spring Boot应用程序实施基本的安全设置。但我们对安全的调查还没有结束。
- en: By knowing and implementing these basic security configurations, you are making
    serious steps toward the creation of secure and trusted applications. Always keep
    in mind that a secure application does not only mean the protection of data but
    trusting your users in relation to the application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解和实施这些基本的安全配置，你正朝着创建安全可信的应用程序迈出重要步伐。始终牢记，一个安全的应用程序不仅意味着保护数据，还意味着在应用方面信任你的用户。
- en: Implementing OAuth2 and JWT
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施OAuth2和JWT
- en: 'Moving on with the topic of application security, we will now discuss some
    of the more advanced mechanisms that cater to a changing environment. This brings
    us to two important technologies: OAuth2 and JWT. Both of them are critical players
    in improving security configurations for modern applications; however, both have
    different roles and complement each other to achieve the overall bigger picture
    of secure authentication and authorization.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续讨论应用程序安全的话题，现在我们将讨论一些针对不断变化的环境的更高级机制。这使我们来到了两种重要的技术：OAuth2和JWT。它们都是提高现代应用程序安全配置的关键参与者；然而，它们有不同的角色，相互补充以实现安全认证和授权的整体更大图景。
- en: In subsequent sections, we provide details of how to set up OAuth2 for Keycloak.
    We detail the configuration of OAuth2 for Keycloak, followed by the required code
    snippets. We will use Keycloak, an open source platform with full support for
    OAuth2 off-the-shelf protocols and extensive abilities to be customized, to provide
    **Identity and Access** **Management** (**IAM**).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们提供了如何为Keycloak设置OAuth2的详细信息。我们详细介绍了Keycloak的OAuth2配置，随后是所需的代码片段。我们将使用Keycloak，这是一个开源平台，完全支持现成的OAuth2协议，并具有广泛的定制能力，以提供**身份和访问管理**（**IAM**）。
- en: Configuring OAuth2 with Keycloak
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Keycloak的OAuth2
- en: Going a step further into the realm of advanced security, one of the key steps
    in increasing the security of your application is the configuration of OAuth2\.
    We are going to use Keycloak for IAM. We chose Keycloak because it is open source,
    and its setup process is very easy. It is a tool to simplify complexities in the
    security process with regard to our applications. It includes built-in support
    for OAuth2, therefore making everything that pertains to the management of user
    identity and the protection of user access to your applications easier. Think
    of Keycloak as a kind of gatekeeper who already knows your users well and ensures
    that only those who have the right permission can access certain parts of your
    application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入到高级安全领域，提高应用程序安全性的关键步骤之一是配置 OAuth2。我们将使用 Keycloak 进行 IAM。我们选择 Keycloak
    是因为它开源，并且其设置过程非常简单。它是简化我们应用程序安全过程中复杂性的工具。它包括对 OAuth2 的内置支持，因此使得与用户身份管理以及保护用户对应用程序访问相关的所有事情都变得更容易。将
    Keycloak 想象成一个已经非常了解您的用户的守门人，并确保只有那些拥有正确权限的人才能访问您应用程序的某些部分。
- en: 'Let’s start our step-by-step implementation. We will use Docker Compose to
    run Keycloak besides our PostgreSQL and MongoDB setup together. We will update
    our current `docker-compose.yml` file as follows. You can also find it in the
    GitHub repository at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-5-implementing-oauth2-jwt/docker-compose.yml](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-5-implementing-oauth2-jwt/docker-compose.yml):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始逐步实施。我们将使用 Docker Compose 来运行 Keycloak，同时与我们的 PostgreSQL 和 MongoDB 设置一起。我们将更新当前的
    `docker-compose.yml` 文件如下。您也可以在 GitHub 仓库中找到它：[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-5-implementing-oauth2-jwt/docker-compose.yml](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-5-implementing-oauth2-jwt/docker-compose.yml)：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We kept our MongoDB and PostgreSQL setup as it is and introduced two new images:
    `keycloak_db` and `keycloak`. Let’s break down the parameters here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了我们的 MongoDB 和 PostgreSQL 设置不变，并引入了两个新的镜像：`keycloak_db` 和 `keycloak`。让我们在这里分解参数：
- en: '`image: postgres`: Specifies the Docker image to use for the container. In
    this case, it’s using the official PostgreSQL image.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image: postgres`: 指定用于容器的 Docker 镜像。在这种情况下，它使用官方的 PostgreSQL 镜像。'
- en: '`restart: always`: This setting ensures the container always restarts if it
    stops. If Docker restarts or the container exits for any reason, this setting
    will cause it to be restarted.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart: always`: 此设置确保容器在停止时始终重新启动。如果 Docker 重新启动或容器由于任何原因退出，此设置将导致它重新启动。'
- en: '`environment`: Defines environment variables for the container. For `keycloak_db`,
    it sets the PostgreSQL database (`POSTGRES_DB`) to `keycloak`, the database user
    (`POSTGRES_USER`) to `keycloak`, and the user’s password (`POSTGRES_PASSWORD`)
    to `keycloakpassword`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`环境变量`: 为容器定义环境变量。对于 `keycloak_db`，它将 PostgreSQL 数据库 (`POSTGRES_DB`) 设置为 `keycloak`，数据库用户
    (`POSTGRES_USER`) 设置为 `keycloak`，以及用户的密码 (`POSTGRES_PASSWORD`) 设置为 `keycloakpassword`。'
- en: '`ports`: Maps ports from the container to the host machine. `"5433:5432"` maps
    the default PostgreSQL port inside the container (`5432`) to port `5433` on the
    host. This allows you to connect to the database from the host machine using port
    `5433`. We are using `5433` because we have already used `5432` in the PostgreSQL
    database of our application.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`: 将容器中的端口映射到主机机器。`"5433:5432"` 将容器内的默认 PostgreSQL 端口 (`5432`) 映射到主机的端口
    `5433`。这允许您使用端口 `5433` 从主机机器连接到数据库。我们使用 `5433` 是因为我们已经在我们的应用程序的 PostgreSQL 数据库中使用了
    `5432`。'
- en: '`image: bitnami/keycloak:latest`: Specifies the Docker image for the Keycloak
    server, using the latest version of the `bitnami/keycloak` image.*   `restart:
    always`: Similar to `keycloak_db`, ensures the Keycloak container is always restarted
    if it stops for any reason.*   `environment`: Sets environment variables specific
    to the Keycloak server:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image: bitnami/keycloak:latest`: 指定 Keycloak 服务器的 Docker 镜像，使用 `bitnami/keycloak`
    镜像的最新版本。*   `restart: always`: 与 `keycloak_db` 类似，确保 Keycloak 容器在停止时由于任何原因始终重新启动。*   `环境变量`:
    为 Keycloak 服务器设置特定环境变量：'
- en: '`KEYCLOAK_USER`: The admin username for Keycloak (`admin`).'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEYCLOAK_USER`: Keycloak 的管理员用户名 (`admin`)。'
- en: '`KEYCLOAK_PASSWORD`: The admin password for Keycloak (`admin`).'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEYCLOAK_PASSWORD`: Keycloak 的管理员密码 (`admin`)。'
- en: '`DB_VENDOR`: Specifies the type of database being used (`POSTGRES` in this
    case).'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_VENDOR`: 指定正在使用的数据库类型（在本例中为 `POSTGRES`）。'
- en: '`DB_ADDR`: The address of the database container. Using the `keycloak_db` service
    name allows Keycloak to find the database within the Docker network.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_ADDR`：数据库容器的地址。使用 `keycloak_db` 服务名称允许 Keycloak 在 Docker 网络中找到数据库。'
- en: '`DB_PORT`: The port on which the database is listening (`5432`).'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_PORT`：数据库监听的端口（`5432`）。'
- en: '`DB_DATABASE`: The name of the database Keycloak should use (`keycloak`).'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_DATABASE`：Keycloak 应使用的数据库名称（`keycloak`）。'
- en: '`DB_USER` and `DB_PASSWORD`: The credentials Keycloak will use to connect to
    the database.*   `ports`: Maps the Keycloak server port from the container to
    the host machine. `"8180:8080"` maps the internal port `8080` (Keycloak’s default
    port) to `8180` on the host. This allows you to access the Keycloak server from
    the host machine using port `8180`. We have changed the original port because
    our Spring Boot application is using port `8080`.*   `depends_on`:'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_USER` 和 `DB_PASSWORD`：Keycloak 将用于连接到数据库的凭据。*   `ports`：将容器中的 Keycloak
    服务器端口映射到主机机器。`"8180:8080"` 将内部端口 `8080`（Keycloak 的默认端口）映射到主机上的 `8180`。这允许您使用端口
    `8180` 从主机访问 Keycloak 服务器。我们更改了原始端口，因为我们的 Spring Boot 应用程序正在使用端口 `8080`。*   `depends_on`：'
- en: '`keycloak_db`: Specifies that the `keycloak` service depends on the `keycloak_db`
    service. Docker Compose will ensure that `keycloak_db` is started before `keycloak`.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keycloak_db`：指定 `keycloak` 服务依赖于 `keycloak_db` 服务。Docker Compose 将确保在 `keycloak`
    之前启动 `keycloak_db`。'
- en: This setup provides a robust and straightforward way to deploy Keycloak with
    a PostgreSQL database using Docker Compose. By understanding these parameters,
    you can customize your setup to fit your specific needs, such as changing ports,
    database names, or credentials.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置提供了一个强大且简单的方法来使用 Docker Compose 部署带有 PostgreSQL 数据库的 Keycloak。通过理解这些参数，您可以自定义您的设置以适应您的特定需求，例如更改端口、数据库名称或凭据。
- en: When we run the `docker-compose up` command in our terminal in the directory
    of this `docker-compose.yml` file, our four services (PostgreSQL, MongoDB, PostgreSQL
    for Keycloak, and the Keycloak service) will be up and running in our local machine.
    In the next step, we will configure the Keycloak server according to our needs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在包含此 `docker-compose.yml` 文件的目录中的终端中运行 `docker-compose up` 命令时，我们的四个服务（PostgreSQL、MongoDB、Keycloak
    的 PostgreSQL 和 Keycloak 服务）将在我们的本地机器上启动并运行。在下一步中，我们将根据我们的需求配置 Keycloak 服务器。
- en: Configuring the Keycloak service
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Keycloak 服务
- en: 'As we defined in the Docker Compose file, we now have the URL and port of the
    Keycloak server. Open a web browser and navigate to `http://localhost:8180/`.
    Log in with the admin credentials we set earlier in the Docker Compose file to
    access the Keycloak administration console. In our example, the username is `admin`
    and the password is `admin`. With the following steps, let us configure a Keycloak
    service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 Docker Compose 文件中定义的那样，我们现在有了 Keycloak 服务器的 URL 和端口。打开一个网页浏览器，导航到 `http://localhost:8180/`。使用我们在
    Docker Compose 文件中之前设置的管理员凭据登录以访问 Keycloak 管理控制台。在我们的示例中，用户名是 `admin`，密码是 `admin`。按照以下步骤，让我们配置一个
    Keycloak 服务：
- en: 'Creating a realm:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建领域：
- en: Click on `BookStoreRealm`.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `BookStoreRealm`。
- en: '![Figure 5.1: Add realm screen](img/B18400_05_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：添加领域屏幕](img/B18400_05_01.jpg)'
- en: 'Figure 5.1: Add realm screen'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：添加领域屏幕
- en: Click **Create**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建**。
- en: 'Creating a client:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建客户端：
- en: Inside your realm, navigate to `bookstore-client` and **Root URL** to the URL
    of your Spring Boot application (for our application, it is http://localhost:8080).
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的领域内，导航到 `bookstore-client` 和 **根 URL** 到您的 Spring Boot 应用程序的 URL（对于我们的应用程序，它是
    http://localhost:8080）。
- en: '![Figure 5.2: Client create screen](img/B18400_05_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：客户端创建屏幕](img/B18400_05_02.jpg)'
- en: 'Figure 5.2: Client create screen'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：客户端创建屏幕
- en: On the next screen, set client authentication to true and click the save button
    at the end of the client creation flow.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，将客户端身份验证设置为 true，并在客户端创建流程的末尾点击保存按钮。
- en: Under **Credentials**, note the secret as you will need it for your application
    properties in the Spring Boot application in the *Configuring the book store application
    for* *OAuth2* section.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **凭据** 下，注意密钥，您将需要在 *配置书店应用程序以* *OAuth2* *部分的应用程序属性中使用它。
- en: '![Figure 5.3: Credentials of the client screen](img/B18400_05_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：客户端凭据屏幕](img/B18400_05_03.jpg)'
- en: 'Figure 5.3: Credentials of the client screen'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：客户端凭据屏幕
- en: 'Creating a user:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户：
- en: Navigate to **Users**, add a user, and set up a password under the **Credentials**
    tab.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航到 **用户**，添加一个用户，并在 **凭据** 选项卡下设置密码。
- en: '![Figure 5.4: User Credentials screen](img/B18400_05_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：用户凭据屏幕](img/B18400_05_04.jpg)'
- en: 'Figure 5.4: User Credentials screen'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：用户凭据屏幕
- en: Now, we will have a user with a username and password and the secret of our
    Keycloak client, which will be used in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将有一个具有用户名、密码和我们的 Keycloak 客户端密钥的用户，这些将在下一节中使用。
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Keycloak regularly undergoes updates and improvements, which may result in changes
    to the user interface. As a result, the UI might look different from the descriptions
    and screenshots provided in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak 定期进行更新和改进，这可能会导致用户界面的变化。因此，UI 可能与本章中提供的描述和截图不同。
- en: Configuring the book store application for OAuth2
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置图书商店应用程序以使用 OAuth2
- en: 'We have a Keycloak server and it has been configured; now, we will need to
    configure our book store application so it can communicate with the Keycloak server:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 Keycloak 服务器，并且已经进行了配置；现在，我们需要配置我们的图书商店应用程序，以便它可以与 Keycloak 服务器通信：
- en: '`build.gradle` file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build.gradle` 文件：'
- en: '[PRE3]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`application.properties`: Add the following properties to your `application.properties`
    file, replacing placeholders with your actual Keycloak and client details:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`application.properties`：将以下属性添加到您的 `application.properties` 文件中，用您的实际 Keycloak
    和客户端详细信息替换占位符：'
- en: '[PRE4]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These settings are used to configure OAuth2 client registration and resource
    server properties for a Spring Boot application. They specifically configure the
    application to use Keycloak as the authentication provider. Let’s break down what
    each setting means:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些设置用于配置 Spring Boot 应用程序的 OAuth2 客户端注册和资源服务器属性。它们具体配置应用程序使用 Keycloak 作为身份验证提供者。让我们分解每个设置的含义：
- en: '`spring.security.oauth2.client.registration.keycloak.client-id`: This is the
    unique identifier for the OAuth2 client registered in Keycloak. In our case, `bookstore-client`
    is the ID that represents our application in the Keycloak server.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.registration.keycloak.client-id`：这是在 Keycloak
    中注册的 OAuth2 客户端的唯一标识符。在我们的案例中，`bookstore-client` 是代表我们在 Keycloak 服务器中的应用程序的 ID。'
- en: '`spring.security.oauth2.client.registration.keycloak.client-secret`: This secret
    is used to authenticate the client with the Keycloak server. It’s a confidential
    string known only to the application and the Keycloak server, acting as a password.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.registration.keycloak.client-secret`：此密钥用于通过
    Keycloak 服务器验证客户端。它是一个只有应用程序和 Keycloak 服务器知道的机密字符串，充当密码。'
- en: '`spring.security.oauth2.client.registration.keycloak.client-name`: A human-readable
    name for the client, which is Keycloak in our configuration.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.registration.keycloak.client-name`：客户端的人类可读名称，在我们的配置中是
    Keycloak。'
- en: '`spring.security.oauth2.client.registration.keycloak.provider`: Specifies the
    provider’s name for this client registration. It’s set to `keycloak`, linking
    this client registration to the Keycloak provider configured further down in the
    properties file.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.registration.keycloak.provider`：指定此客户端注册的提供者名称。它设置为
    `keycloak`，将此客户端注册链接到在属性文件中配置的 Keycloak 提供者。'
- en: '`spring.security.oauth2.client.registration.keycloak.scope`: Defines the scope
    of the access request. The `openid`, `profile`, and `email` scopes indicate that
    the application is requesting ID tokens and access to the user’s profile and email
    information.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.registration.keycloak.scope`：定义访问请求的范围。`openid`、`profile`
    和 `email` 范围表示应用程序正在请求 ID 令牌以及访问用户的个人资料和电子邮件信息。'
- en: '`spring.security.oauth2.client.registration.keycloak.authorization-grant-type`:
    Specifies the OAuth2 flow to be used. Here, it’s set to `authorization_code`,
    which is a secure and common method for obtaining access and refresh tokens.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.registration.keycloak.authorization-grant-type`：指定要使用的
    OAuth2 流。在这里，它设置为 `authorization_code`，这是一种安全且常用的获取访问和刷新令牌的方法。'
- en: '`spring.security.oauth2.client.registration.keycloak.redirect-uri`: This is
    the URI to which the user is redirected after logging in or out. `{baseUrl}` is
    a placeholder that Spring Security replaces with the application’s base URL, ensuring
    that the redirect URI matches the application’s domain.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.registration.keycloak.redirect-uri`：这是用户登录或登出后重定向到的
    URI。`{baseUrl}` 是 Spring Security 替换为应用程序基本 URL 的占位符，确保重定向 URI 与应用程序的域名匹配。'
- en: '`spring.security.oauth2.client.provider.keycloak.issuer-uri`: This URL points
    to the Keycloak issuer URI for the realm you’re using (`BookStoreRealm`), typically
    the base URL for Keycloak plus `/auth/realms/{realm-name}`. It tells the Spring
    Boot application where to find the Keycloak server for this realm.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.client.provider.keycloak.issuer-uri`：此URL指向您使用的域（`BookStoreRealm`）的Keycloak发行者URI，通常是Keycloak的基本URL加上`/auth/realms/{realm-name}`。它告诉Spring
    Boot应用程序在哪里可以找到此域的Keycloak服务器。'
- en: '`spring.security.oauth2.resourceserver.jwt.issuer-uri`: Similar to the provider
    issuer URI, this setting configures the issuer URI for the JWT issuer. It is used
    by the resource server (your application) to validate JWTs. The issuer URI must
    match the issuer declared in the JWT for the token to be considered valid.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.security.oauth2.resourceserver.jwt.issuer-uri`：类似于提供者发行者URI，此设置配置JWT发行者的发行者URI。它被资源服务器（您的应用程序）用于验证JWT。发行者URI必须与JWT中声明的发行者匹配，才能使令牌被视为有效。'
- en: These settings wire our Spring Boot application to authenticate using Keycloak,
    specifying how our application should register with Keycloak, what scopes it requests,
    and how to validate tokens issued by Keycloak.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些设置将我们的Spring Boot应用程序连接到使用Keycloak进行身份验证，指定了我们的应用程序应该如何在Keycloak中注册，它请求哪些作用域以及如何验证Keycloak签发的令牌。
- en: '`SecurityConfig` **file**: We need to update the SecurityConfig file to use
    the OAuth2 login with Keycloak:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SecurityConfig` **文件**：我们需要更新`SecurityConfig`文件以使用Keycloak的OAuth2登录：'
- en: '[PRE5]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Basically, in this code, we have only changed the last statement before `build`
    command.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基本上，在这个代码中，我们只更改了`build`命令之前的最后一个语句。
- en: '`.oauth2ResourceServer(...)` configures OAuth2 resource server support and
    `.jwt(Customizer.withDefaults())` indicates that the resource server expects JWTs
    for authentication.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.oauth2ResourceServer(...)`配置OAuth2资源服务器支持，`.jwt(Customizer.withDefaults())`表示资源服务器期望JWT进行身份验证。'
- en: The latter uses the default JWT decoder configuration, which is suitable for
    most scenarios. This line is essential for integrating with OAuth2, where the
    application acts as a resource server that validates JWTs.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后者使用默认的JWT解码器配置，这对于大多数场景都是合适的。这一行对于与OAuth2集成至关重要，其中应用程序充当资源服务器，验证JWT。
- en: Also, we have excluded the `/login` endpoint from being secured because this
    endpoint should be public so that users can get credentials. This brings us to
    introducing a `LoginController` class with the `/``login` endpoint.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们已将`/login`端点排除在受保护之外，因为此端点应该是公开的，以便用户可以获取凭证。这使我们转向引入一个具有`/login`端点的`LoginController`类。
- en: '`login``LoginRequestDto` class, which will be used as a body object for this
    `POST` endpoint, and a `LoginController` class. Let’s write them as shown next.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`login`类，它将用作此`POST`端点的请求体对象，以及一个`LoginController`类。让我们按照下面的方式编写它们。'
- en: 'This is the data transfer object from the client to the server. This object
    contains login credentials for the user created in the Keycloak server:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是客户端到服务器的数据传输对象。此对象包含在Keycloak服务器中创建的用户登录凭证：
- en: '[PRE6]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, we need one more configuration file to introduce the `RestTemplate` bean.
    We will use it in the `LoginController` class:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还需要一个额外的配置文件来引入`RestTemplate` bean。我们将在`LoginController`类中使用它：
- en: '[PRE7]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the `LoginController` class for introducing the `/login` endpoint to
    our application:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是引入到我们应用程序中的`/login`端点的`LoginController`类：
- en: '[PRE8]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s understand what this controller does when the user sends a `POST` request
    to the `/``login` endpoint.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们了解当用户向`/login`端点发送`POST`请求时，这个控制器做了什么。
- en: This is the first time we are using the `@Value` annotation of Spring Boot.
    This annotation injects property values into fields. Here, it’s used to inject
    the Keycloak client ID, client secret, and URL of the Keycloak server from the
    application’s properties file into the `clientId` variable.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们第一次使用Spring Boot的`@Value`注解。这个注解将属性值注入到字段中。在这里，它被用来将Keycloak客户端ID、客户端密钥和Keycloak服务器的URL从应用程序的属性文件中注入到`clientId`变量中。
- en: Our application basically gets the username and password of the user from the
    request body and prepares a REST call to the Keycloak server with the parameters
    in the application properties file. It gets the response from the Keycloak server
    and returns the response to the user. In order to demonstrate what it does, please
    see the following figure, *Figure 5**.5*.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的应用程序基本上从请求体中获取用户的用户名和密码，并使用应用程序属性文件中的参数准备对Keycloak服务器的REST调用。它从Keycloak服务器获取响应并将响应返回给用户。为了演示它的工作原理，请参阅以下图示，*图5*。5*。
- en: '![Figure 5.5: User login process with Keycloak server](img/B18400_05_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：使用 Keycloak 服务器的用户登录过程](img/B18400_05_05.jpg)'
- en: 'Figure 5.5: User login process with Keycloak server'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：使用 Keycloak 服务器的用户登录过程
- en: As shown in the diagram, the user makes a call. Our application prepares the
    requests, makes a `POST` call to the Keycloak API, and returns the response to
    the user. We will use this access token in our calls to our application. We will
    test this out in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，用户发起一个调用。我们的应用程序准备请求，向 Keycloak API 发起一个 `POST` 调用，并将响应返回给用户。我们将在我们的应用程序调用中使用此访问令牌。我们将在下一节中测试这一点。
- en: Testing our endpoints with an access token
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问令牌测试我们的端点
- en: 'Let’s run our application. As you’ll remember, in our previous tests, we received
    the HTTP `403 Forbidden` message from our application. Now we will test it after
    we get the access token from the login process:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的应用程序。如您所记得，在我们之前的测试中，我们从应用程序收到了 HTTP `403 禁止` 消息。现在，在从登录过程获取访问令牌后，我们将对其进行测试：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Please change the username and password values to those of the user you have
    created in the Keycloak server. You will get a response like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请将用户名和密码值更改为您在 Keycloak 服务器中创建的用户。您将收到以下类似的响应：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I haven’t put the exact JWT here since it is a huge alphanumeric value. Let’s
    explain what these values are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在这里放置确切的 JWT，因为它是一个巨大的字母数字值。让我们解释这些值是什么：
- en: '`access_token`: This is a JWT that the client application can use to access
    protected resources by passing it in the authorization header of HTTP requests.
    It is encoded and contains claims (or assertions) about the authentication and
    authorization of the user. The token itself is opaque to the client but can be
    decoded and verified by the resource server (or any party with the appropriate
    key).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_token`：这是一个客户端应用程序可以使用它通过在 HTTP 请求的授权头中传递它来访问受保护资源的 JWT。它是编码的，并包含有关用户身份验证和授权的声明（或断言）。令牌本身对客户端是透明的，但可以被资源服务器（或任何拥有适当密钥的实体）解码和验证。'
- en: '`expires_in`: Specifies the lifetime of the access token in seconds. After
    this time, the access token will no longer be valid for accessing protected resources.
    In this example, the access token expires in `300` seconds (`5` minutes).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expires_in`：指定访问令牌的生存期（以秒为单位）。在此时间之后，访问令牌将不再有效，无法访问受保护资源。在此示例中，访问令牌在 `300`
    秒（`5` 分钟）后过期。'
- en: '`refresh_expires_in`: Indicates the lifetime of the refresh token in seconds.
    The refresh token can be used to obtain a new access token when the current access
    token expires. Here, it is set to `1800` seconds (`30` minutes).'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_expires_in`：表示刷新令牌的生存期（以秒为单位）。刷新令牌可以在当前访问令牌过期时用于获取新的访问令牌。在这里，它设置为
    `1800` 秒（`30` 分钟）。'
- en: '`refresh_token`: This is another JWT, similar to the access token but used
    solely for obtaining new access tokens without requiring the user to log in again.
    It has a longer validity period than the access token and should be stored securely.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_token`：这是另一个 JWT，与访问令牌类似，但仅用于获取新的访问令牌，而无需用户再次登录。它比访问令牌有更长的有效期，并且应该安全存储。'
- en: '`token_type`: Specifies the type of token issued. In OAuth2, this is typically
    `Bearer`, which means that the bearer of this token is authorized to access the
    resources. The client application should use this token type when constructing
    the authorization header for HTTP requests.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_type`：指定发行的令牌类型。在 OAuth2 中，这通常是 `Bearer`，这意味着持有此令牌的人有权访问资源。客户端应用程序在构造
    HTTP 请求的授权头时应使用此令牌类型。'
- en: '`not-before-policy`: This field is specific to Keycloak and similar authorization
    servers. It indicates a policy or timestamp before which the token should not
    be considered valid. A value of `0` typically means the token is valid immediately
    upon issuance.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not-before-policy`：此字段是 Keycloak 和类似授权服务器特有的。它表示一个策略或时间戳，在此时间戳之前，令牌不应被视为有效。`0`
    的值通常表示令牌在发行时立即有效。'
- en: '`session_state`: A unique identifier for the user session that the token is
    associated with. This can be used by the application for session management or
    tracking purposes.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session_state`：与令牌关联的用户会话的唯一标识符。应用程序可以使用此标识符进行会话管理或跟踪目的。'
- en: '`scope`: Specifies the scope of the access requested. Scopes are space-delimited
    and indicate what access rights the application has been granted. In this case,
    `email profile` means the application can access the user’s email address and
    profile information.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`：指定请求的访问范围。范围由空格分隔，表示应用程序已被授予的访问权限。在这种情况下，`email profile` 表示应用程序可以访问用户的电子邮件地址和简介信息。'
- en: 'Now, we will use this access token and use it in the header of our requests:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个访问令牌，并在我们的请求头中使用它：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will get a list of books as a response. You can also use the same token to
    make requests for the other endpoints. After `5` minutes (`300` seconds), the
    access token will expire, and we need to call the `/login` endpoint one more time
    to gather a new access token.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得一个书籍列表作为响应。您也可以使用相同的令牌对其他端点进行请求。在`5`分钟（`300`秒）后，访问令牌将过期，我们需要再次调用`/login`端点以获取新的访问令牌。
- en: We have finally come to the end of this section. We ran the Keycloak server
    locally and defined a new realm, client, and user. Later, we configured our Spring
    Boot application to communicate with the Keycloak server. After all these configurations
    and implementations, we could gather an access token with our username and password
    and get a valid response from our protected endpoints.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来到了本节的结尾。我们在本地运行了Keycloak服务器，并定义了一个新的领域、客户端和用户。随后，我们配置了我们的Spring Boot应用程序以与Keycloak服务器通信。经过所有这些配置和实现，我们能够使用我们的用户名和密码获取一个访问令牌，并从我们的受保护端点获得有效的响应。
- en: In the next section, we will learn how to define a role and filter the role
    of the request by role; this is an important step to protect our endpoints with
    role-based security.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何定义一个角色，并通过角色过滤请求的角色；这是使用基于角色的安全保护我们的端点的一个重要步骤。
- en: Implementing RBAC in Spring Boot
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Boot中实现RBAC
- en: Making sure that users only get access to the resources that they are entitled
    to is of paramount importance in the landscape of modern web development. This
    is where RBAC comes in. Imagine setting up a series of gates within your application,
    each requiring a specific key that only certain users possess. This is the essence
    of RBAC—ensuring that access is granted based on the roles assigned to a user,
    enhancing both security and usability.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web开发领域，确保用户只能访问他们有权访问的资源至关重要。这就是RBAC发挥作用的地方。想象一下，在您的应用程序中设置一系列门，每个门都需要只有某些用户才拥有的特定钥匙。这就是RBAC的本质——确保基于分配给用户的角色授予访问权限，同时增强安全和可用性。
- en: Why prioritize RBAC in your Spring Boot application with Keycloak? Well, first
    of all, it simplifies the complex task of access management, making it easier
    for developers to define and enforce security policies. This allows your applications
    to tap into Keycloak’s great support for OAuth2 and provides a very structured,
    scalable way to secure endpoints. This will make your application more secure
    and its features clearer when it comes to controlling access to a user. As we
    delve more into setting up RBAC with Keycloak, remember that this isn’t about
    restriction per se; it is more about seamless and secure experiences for your
    user, meaning they get the right tools and permissions to navigate through your
    application with efficacy. Let’s embark on this journey of bringing out the full
    potential of role-based security within our Spring Boot applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在您的Spring Boot应用程序中使用Keycloak优先考虑基于角色的访问控制（RBAC）？首先，它简化了复杂的访问管理任务，使开发人员更容易定义和执行安全策略。这使得您的应用程序能够利用Keycloak对OAuth2的出色支持，并提供了一种非常结构化、可扩展的方式来保护端点。这将使您的应用程序在控制用户访问时更加安全，其功能也更加清晰。当我们更深入地设置Keycloak中的RBAC时，请记住，这并不是关于限制本身；它更多的是关于为用户提供无缝和安全的体验，这意味着他们可以获得正确的工具和权限，有效地在您的应用程序中导航。让我们开始这段旅程，挖掘我们Spring
    Boot应用程序中基于角色安全性的全部潜力。
- en: Defining roles and permissions in Keycloak
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Keycloak中定义角色和权限
- en: 'Defining roles and permissions in Keycloak is important for establishing secure
    applications that offer the management of user access in a very streamlined manner.
    Through this process, you will be able to specifically outline what a certain
    user can perform and thus enhance security and productivity in the system. Here’s
    a straightforward guide to setting up roles and permissions in Keycloak, along
    with insights into what kind of configuration this brings about in terms of your
    security and management:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Keycloak中定义角色和权限对于建立提供非常流畅的用户访问管理功能的 secure 应用程序非常重要。通过这个过程，您将能够具体说明某个用户可以执行的操作，从而增强系统中的安全和生产力。以下是一个关于在Keycloak中设置角色和权限的简单指南，以及关于这种配置如何影响您的安全和管理的见解：
- en: First, log in to the Keycloak Admin Console (`http://localhost:8180`) using
    your administrator credentials. This is our control panel for managing realms,
    users, roles, and permissions.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用您的管理员凭据登录Keycloak管理控制台（`http://localhost:8180`）。这是我们管理领域、用户、角色和权限的控制面板。
- en: Navigate to the **Roles** section—select the realm you wish to configure from
    the drop-down menu, then click on **Roles** in the left-hand menu. Here, you’ll
    see a list of existing roles.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **角色** 部分——从下拉菜单中选择您希望配置的区域，然后在左侧菜单中点击 **角色**。在这里，您将看到现有角色的列表。
- en: '![Figure 5.6: Add Role screen](img/B18400_05_06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：添加角色界面](img/B18400_05_06.jpg)'
- en: 'Figure 5.6: Add Role screen'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：添加角色界面
- en: '**Add roles**: Click on **Add Role**. Enter a name for the user role and a
    description that helps you identify the role’s purpose within your application.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加角色**：点击 **添加角色**。输入用户角色的名称和描述，以帮助您识别角色在应用程序中的用途。'
- en: '**Save**: Click **Save**. You’ve now created a role that can be assigned to
    users.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**：点击 **保存**。您现在已创建了一个可以分配给用户的角色。'
- en: Add one more role called `admin`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `admin` 的角色。
- en: Go to **Users**, select the user you created in the previous step and click
    on **Role Mappings**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **用户**，选择上一步创建的用户，然后点击 **角色映射**。
- en: '![Figure 5.7: Role Mappings screen of the user](img/B18400_05_07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：用户角色映射界面](img/B18400_05_07.jpg)'
- en: 'Figure 5.7: Role Mappings screen of the user'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：用户角色映射界面
- en: Here, you can assign the **User** role to the user. Select the role and click
    **Assign**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您可以给用户分配 **用户** 角色。选择角色并点击 **分配**。
- en: Create a new user and assign the **admin** role to this user.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新用户，并将 **admin** 角色分配给此用户。
- en: With the roles defined and assigned, let’s understand the process of including
    the roles we created in the application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 角色定义和分配后，让我们了解将创建的角色包含到应用程序中的过程。
- en: Tailoring the book store application for role-based access
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为基于角色的访问定制书店应用程序
- en: 'Implementing RBAC in your Spring Boot book store application using Keycloak
    significantly enhances its security, ensuring that users can access only what
    they are permitted to according to their roles. This not only makes your application
    more secure by design but it also sets up a very solid framework for the management
    of user permissions. Let’s follow the steps to include this role-based setup in
    your application, wherein a new class—`KeycloakRoleConverter`—is introduced and
    specific security configurations. The new class will be an adapter between roles
    from Keycloak and roles in Spring Security. Let’s learn step by step how to implement
    this structure into our application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Spring Boot 书店应用程序中使用 Keycloak 实现RBAC显著增强了其安全性，确保用户只能根据其角色访问允许的内容。这不仅通过设计使您的应用程序更加安全，而且为用户权限的管理设置了一个非常稳固的框架。让我们按照以下步骤将基于角色的设置包含到您的应用程序中，其中引入了一个新类——`KeycloakRoleConverter`——以及特定的安全配置。新类将成为
    Keycloak 角色和 Spring Security 角色之间的适配器。让我们一步一步地学习如何将这个结构应用到我们的应用程序中：
- en: '`POST` requests to `/books` and `/authors` to users with the `ROLE_ADMIN` authority
    and configuring the OAuth2 resource server to use a custom JWT authentication
    converter. Open your security configuration class and update the `securityFilterChain`
    bean as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `/books` 和 `/authors` 的 `POST` 请求向具有 `ROLE_ADMIN` 权限的用户发送，并配置 OAuth2 资源服务器使用自定义
    JWT 认证转换器。打开您的安全配置类，并更新 `securityFilterChain` bean，如下所示：
- en: '[PRE12]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`KeycloakRoleConverter` **class**: This class is pivotal as it translates Keycloak
    JWTs into Spring Security’s authentication structure. This custom converter extracts
    roles from the JWT and assigns them as authorities within the Spring Security
    context:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`KeycloakRoleConverter` **类**：这个类至关重要，因为它将 Keycloak JWT 转换为 Spring Security
    的认证结构。这个自定义转换器从 JWT 中提取角色，并将它们作为 Spring Security 上下文中的权限分配：'
- en: '[PRE13]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have introduced a class that implements the `Converter` interface to convert
    a JWT into an `AbstractAuthenticationToken` class, a concept used in Spring Security
    for authentication information. With those changes made, our book store application
    now has a very secure and powerful RBAC system in place. It only lets an authenticated
    user with the right role do a certain action—this significantly increases the
    security and integrity of your application. Also, that setup is granular, and
    it affords the best control of user permissions and eases the management of access
    rights across our application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个实现 `Converter` 接口的类，将 JWT 转换为 `AbstractAuthenticationToken` 类，这是 Spring
    Security 用于认证信息的一个概念。通过这些更改，我们的书店应用程序现在拥有一个非常安全和强大的基于角色的访问控制系统。它只允许具有正确角色的认证用户执行特定操作——这显著提高了应用程序的安全性和完整性。此外，该设置非常细致，它提供了对用户权限的最佳控制，并简化了应用程序中访问权限的管理。
- en: We can test our app now. When we log in using the `user` role and make a `GET`
    request to `/books`, we will get a successful response, but when we try to make
    the `POST` request to `/books` and create a new book, the response will be `forbidden`.
    If we log in with the `admin` role, we will always have success, in the case of
    a request having either `GET` or `POST`. Securing a foothold in this area of RBAC
    for our Spring Boot book store application will open up a way for expanding the
    security architecture very favorably.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试我们的应用程序了。当我们使用`user`角色登录并发出对`/books`的`GET`请求时，我们会得到一个成功的响应，但当我们尝试对`/books`发出`POST`请求并创建一本新书时，响应将是`forbidden`。如果我们使用`admin`角色登录，无论请求是`GET`还是`POST`，我们都会一直成功。在我们的Spring
    Boot书店应用程序的RBAC（基于角色的访问控制）领域确保安全立足点将为我们扩展安全架构开辟一条有利之路。
- en: The next section of our journey is into securing reactive applications. Moving
    forward, this chapter will address how all the principles of security, authentication,
    and authorization apply to a reactive context of programming. This will not only
    help us to gain an expanded scope of understanding the approaches to be utilized
    regarding security in practice but also equip us with the tools that will help
    us to offer adequate protection of our reactive applications. We will learn about
    the depths of reactive security to give our application the resilience needed
    to meet evolving cyber threats.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程的下一部分是确保反应式应用程序的安全。向前推进，本章将讨论所有安全、身份验证和授权原则如何应用于编程的反应式上下文中。这不仅将帮助我们扩大对实际中可利用的安全方法的了解范围，还将为我们提供帮助，以提供足够的保护来保护我们的反应式应用程序。我们将深入了解反应式安全，以使我们的应用程序具有应对不断发展的网络威胁所需的弹性。
- en: Securing reactive applications
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 确保反应式应用程序的安全
- en: In the dynamic landscape of software development, securing reactive applications
    brings with it a new set of challenges and opportunities. Having dived deeper
    into the world of reactive programming, now we need to tweak our security strategies
    to align with the non-blocking, event-driven nature of these applications. Reactive
    systems that are identified to handle a large number of concurrent data streams
    strongly call for a strong yet flexible security approach. This section will try
    to unfold the complications in securing reactive applications and will guide you
    through the essential steps and considerations in order to effectively protect
    your reactive ecosystem.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的动态环境中，确保反应式应用程序的安全带来了一组新的挑战和机遇。在更深入地了解了反应式编程的世界之后，我们现在需要调整我们的安全策略，以适应这些应用程序的非阻塞、事件驱动的特性。那些被识别出来处理大量并发数据流的自反应系统强烈要求采取一种强大而灵活的安全方法。本节将尝试揭示确保反应式应用程序的复杂性，并将指导您通过必要的步骤和考虑，以有效地保护您的反应式生态系统。
- en: We will look into how to use the reactive support provided by Spring Security
    to enable those security features without breaking the reactive principles, ensuring
    high responsiveness and resilience.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用Spring Security提供的反应式支持来启用这些安全功能，同时不破坏反应式原则，确保高响应性和弹性。
- en: Transitioning to the reactive programming territory could mean a challenge in
    terms of security, especially with the full strength Spring Security has to offer.
    Implementing reactive security with Spring Security is actually about adapting
    classic security paradigms to work within this asynchronous, non-blocking model
    of a reactive application. That realignment could be described as a shift, not
    one of any technical change but one in how security processes interact with data
    flows and user requests. The security model is required to be functional in this
    environment, without seeking any compromises with the reactive principles or imposing
    bottlenecks on it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 转向反应式编程领域可能意味着在安全方面的一个挑战，尤其是考虑到Spring Security提供的强大功能。使用Spring Security实现反应式安全实际上是将经典的安全范式适应于反应式应用程序的异步、非阻塞模型。这种重新定位可以描述为一种转变，不是任何技术变化的转变，而是在安全过程与数据流和用户请求交互的方式上的转变。在这个环境中，安全模型需要是功能性的，而不寻求与反应式原则有任何妥协，也不对其施加瓶颈。
- en: One of the key differences in securing reactive applications lies in the way
    authentication and authorization are done. Unlike traditional servlet-based applications
    where usually security contexts are tied to a thread-local, reactive security
    has to be able to handle this type of decoupled, stateless nature of reactive
    programming. Spring Security provides a reactive security context that gets scoped
    to the reactive stream, ensuring that decisions about security in a context-aware
    way are aligned with the flow of the application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保响应式应用的安全性方面，一个关键的区别在于认证和授权的方式。与通常将安全上下文绑定到线程本地的基于 servlet 的传统应用不同，响应式安全性必须能够处理这种解耦、无状态的反应式编程特性。Spring
    Security 提供了一个响应式安全上下文，它被限制在响应流中，确保安全决策在上下文感知的方式上与应用的流程保持一致。
- en: In this series, when we look into the reactive part of Spring Security, we will
    see how to include them effectively within our applications for the reactive system’s
    security. This covers handling the reactive APIs offered by Spring Security, understanding
    who acts as a publisher for making security decisions (`Mono` and `Flux`), and
    making sure your application stays secure, reactive, and scalable. This guide,
    with practical examples and a step-by-step approach, will help you navigate the
    complexities of reactive security to ensure the application is not only secure
    but also performs and scales to the expectations laid down by the reactive programming
    model.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列中，当我们探讨 Spring Security 的响应式部分时，我们将了解如何有效地在我们的应用中包含它们以实现响应式系统的安全性。这包括处理
    Spring Security 提供的响应式 API、理解谁作为发布者来做出安全决策（`Mono` 和 `Flux`），并确保您的应用保持安全、响应式和可扩展。本指南通过实际示例和逐步方法，将帮助您导航响应式安全性的复杂性，确保应用不仅安全，而且符合响应式编程模型所设定的性能和扩展期望。
- en: 'Let’s start implementing security into the reactive application. We will use
    the same project we developed in [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始将安全性实现到响应式应用中。我们将使用我们在 [*第 3 章*](B18400_03.xhtml#_idTextAnchor064) 中开发的项目：
- en: '`build.gradle` file:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build.gradle` 文件：'
- en: '[PRE14]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`application.properties`: Add the following properties to your `application.properties`
    file, replacing placeholders with your actual Keycloak and client details:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`application.properties`：将以下属性添加到您的 `application.properties` 文件中，用您的实际 Keycloak
    和客户端详细信息替换占位符：'
- en: '[PRE15]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`SecurityWebFilterChain` class in your `SecurityConfig` class to specify authorization
    rules and set up the JWT converter for role extraction:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `SecurityConfig` 类中指定授权规则并设置 JWT 转换器以提取角色的 `SecurityWebFilterChain` 类：
- en: '[PRE16]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`KeycloakRoleConverter`: The `KeycloakRoleConverter` class is essential for
    mapping Keycloak roles to Spring Security authorities:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`KeycloakRoleConverter`：`KeycloakRoleConverter` 类对于将 Keycloak 角色映射到 Spring
    Security 权限至关重要：'
- en: '[PRE17]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`token` `LoginController` class to handle authentication requests, utilizing
    Keycloak’s `token` endpoint:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`token` 处理身份验证请求的 `LoginController` 类，利用 Keycloak 的 `token` 端点：'
- en: '[PRE18]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we’ve introduced role-based security filters into our reactive application.
    Almost everything is very similar to traditional applications, only the responses
    are in the reactive realm, such as `Mono` and `Flux`. We can use our previous
    `curl` scripts for the login to get an access token for both `user` and `admin`
    roles, and we can test our `POST` and `GET` endpoints.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将基于角色的安全过滤器引入到我们的响应式应用中。几乎所有内容都与传统应用非常相似，只是响应是在响应式领域，例如 `Mono` 和 `Flux`。我们可以使用我们之前的
    `curl` 脚本进行登录，为 `user` 和 `admin` 角色获取访问令牌，并且我们可以测试我们的 `POST` 和 `GET` 端点。
- en: It means that integrating reactive security into a Spring Boot application requires
    deliberately configuring a sequence of custom implementations with Spring Security
    especially using OAuth2 with Keycloak. From the setup of dependencies and the
    configuration of properties to the security filter chain, ending in a custom role
    converter—every step has been described so that they can be followed to get a
    secure reactive environment for our book store application. This implementation
    not only leverages the non-blocking nature of reactive programming but also ensures
    that our application is secure and scalable for it to be able to handle the demand
    proficiently in a reactive context.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着将响应式安全性集成到 Spring Boot 应用中需要故意配置一系列自定义实现，特别是使用 OAuth2 和 Keycloak。从设置依赖项和配置属性到安全过滤器链，最后到自定义角色转换器——每一步都进行了描述，以便可以遵循以获得我们书店应用的安全响应式环境。这种实现不仅利用了响应式编程的非阻塞特性，而且还确保我们的应用在响应式环境中既安全又可扩展，能够高效地处理需求。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'With this, we shall finish this chapter, which dealt with securing Spring Boot
    applications. We have now finished our journey through Spring Boot security by
    learning about the context and the toolsets that are required to secure our applications
    in an effective manner. Let’s summarize the key learnings from this chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们将结束本章，本章主要讨论了如何确保 Spring Boot 应用程序的安全性。我们现在已经通过了解上下文和所需的安全工具集，有效地保护我们的应用程序，完成了对
    Spring Boot 安全性的探索。让我们总结本章的关键学习内容：
- en: '**Understanding Spring Boot security**: We understood the need for securing
    our Spring Boot applications and the basic tenets of Spring Security.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解 Spring Boot 安全性**：我们理解了保护 Spring Boot 应用程序的需求和 Spring Security 的基本原则。'
- en: '**Implementing with OAuth2**: We learned how to authenticate users using OAuth2
    and manage secure tokens using JWT.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 OAuth2 实现**：我们学习了如何使用 OAuth2 验证用户并使用 JWT 管理安全令牌。'
- en: '**RBAC using Keycloak**: We showed in great detail how to configure Keycloak
    to manage roles and permissions in our system, thus enhancing the security structure
    of our application.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Keycloak 进行 RBAC**：我们详细展示了如何配置 Keycloak 来管理我们系统中的角色和权限，从而增强我们应用程序的安全结构。'
- en: '**Modified security configuration for reactive**: We elaborated on how security
    configurations are customized for the reactive programming model so that our applications
    can be both secure and capable at the same time.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对反应式的修改安全配置**：我们详细阐述了如何针对反应式编程模型定制安全配置，以便我们的应用程序既能保证安全又能具备能力。'
- en: '**Reactive security with Spring Security implementation**: In order to implement
    security in a reactive environment, crucial differences and modifications are
    necessary. This chapter emphasized non-blocking and event-driven security mechanisms.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Spring Security 实现反应式安全**：为了在反应式环境中实现安全性，需要必要的差异和修改。本章强调了非阻塞和事件驱动的安全机制。'
- en: This chapter gave a brief outline of what Spring Security is about. The next
    chapter, Advanced Testing Strategies, drills further into the Spring Boot ecosystem,
    this time getting into the depths of testing. The chapter will delve more into
    the differences between unit and integration testing, which will point out the
    challenges with testing reactive components, leading to a discussion of security
    features testing with a short introduction on the aspect of **Test-Driven Development**
    (**TDD**) with Spring Boot 3.0\. This progression from securing to testing our
    applications really underscores the comprehensive approach that needs to be taken
    for developing resilient, high-quality software ready to meet the demands of modern
    application development.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要概述了 Spring Security 的内容。下一章，高级测试策略，将进一步深入 Spring Boot 生态系统，这次将深入探讨测试。本章将更深入地探讨单元测试和集成测试之间的差异，指出测试反应式组件的挑战，进而讨论安全功能测试，并简要介绍
    Spring Boot 3.0 的**测试驱动开发（TDD**）方面。从确保安全性到测试我们的应用程序的这一进展，真正强调了在开发能够满足现代应用开发需求的健壮、高质量软件时需要采取的全面方法。
