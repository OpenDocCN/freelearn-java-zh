- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Component-Based Approach to Software Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we’re starting a software project, we never know all the requirements that
    the users will throw at us once they are actually using the software. A software
    project is always associated with taking chances and making educated guesses (we
    like to call them “assumptions” to make it sound more professional). The environment
    of a software project is just too volatile to know in advance how everything will
    play out. This volatility is why the Agile movement was born. Agile practices
    make organizations flexible enough to adapt to change.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we create a software architecture that can cope with such an agile
    environment? If everything can change at any time, should we even bother with
    architecture?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we should. As discussed in [*Chapter 1*](B19916_01.xhtml#_idTextAnchor014),
    *Maintainability*, we should make sure that our software architecture enables
    maintainability. A maintainable code base can evolve over time, adapting to external
    factors.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal Architecture takes a big step toward maintainability. It’s creating
    a boundary between our application and the outside world. On the inside of our
    application (within the hexagon), we have our domain code, which provides dedicated
    ports to the outside world. These ports connect the application to adapters, which
    talk to the outside world, translating between the language of our application
    and the languages of outside systems. This architecture enhances maintainability
    because the application can mostly evolve independently of the outside world.
    As long as the ports don’t change, we can evolve anything within the application
    to react to changes in the agile environment.
  prefs: []
  type: TYPE_NORMAL
- en: But, as we learned in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing
    Multiple Bounded Contexts*, Hexagonal Architecture doesn’t help us to create boundaries
    within our application core. We might want to apply a different architecture within
    our application core that helps us in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I’ve heard quite a few times that Hexagonal Architecture feels hard, especially
    for a software project just starting out. It’s hard to get the team on board because
    not everyone understands the value of dependency inversion and the mapping between
    the domain model and the outside world. Hexagonal Architecture might just be overkill
    for a fledgling application.
  prefs: []
  type: TYPE_NORMAL
- en: For cases like this, we might want to start out with a simpler architecture
    style that still provides the modularity we need to evolve into something else
    in the future but that’s simple enough to get everyone on board. I propose that
    a component-based architecture is a good starting point, and we’ll use this chapter
    to discuss this architecture style.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity through components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the drivers of maintainability is modularity. Modularity allows us to
    conquer the complexity of a software system by dividing it into simpler modules.
    We don’t have to understand the whole system to be able to work on one specific
    module. Instead, we can focus on that one module and potentially the modules it
    interfaces with. Modules can evolve mostly independently of each other, as long
    as the interfaces between modules are clearly defined. We’re probably able to
    fit a mental model of one module into our working memory, but good luck with creating
    a mental model if there are no modules in the code base. We would jump around
    in the code rather helplessly.
  prefs: []
  type: TYPE_NORMAL
- en: Only modularity allows us humans to create complex systems. In his book *Modern
    Software Engineering*, Dave Farley talks about the modularity of the Apollo space
    program:[1](#footnote-046)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-046-backlink) Modularity of the Apollo space program*: Modern
    Software Engineering* by Dave Farley, Pearson, 2022, [*Chapter 6*](B19916_06.xhtml#_idTextAnchor056).'
  prefs: []
  type: TYPE_NORMAL
- en: “*This modularity had lots of advantages. It meant that each component could
    be built to focus on one part of the problem and would need to compromise less
    in its design. It allowed different groups – in this case, completely different
    companies – to work on each module largely independently of the others. As long
    as the different groups agreed on how the modules would interface with each other,
    they could work to solve the problems of their module* *without constraint*.”
  prefs: []
  type: TYPE_NORMAL
- en: Modularity allowed us to go to the Moon! Modularity allows us to build cars,
    aircraft, and buildings. It should be no surprise that it also helps us build
    complex software.
  prefs: []
  type: TYPE_NORMAL
- en: But what is a module? I feel the term is overloaded in (object-oriented) software
    development. Everything and its cat is called a “module,” even if it’s just a
    bunch of classes that were haphazardly thrown together to do a useful thing. I
    prefer the term “component” to describe a group of classes that were thoughtfully
    engineered to implement certain functionality that can be composed together with
    other groups of classes to build a complex system. The composition aspect implies
    that components can be composed to form a bigger whole and potentially even re-composed
    to react to changes in the environment. Composability requires a component to
    define a clear interface that tells us what it provides to and needs from the
    outside world (input and output ports, anyone?). Think of LEGO bricks. A LEGO
    brick provides a certain layout of studs for other bricks to attach to, and it
    requires a certain layout of studs to attach to other bricks. All that said, I
    won’t judge you if you use the term “module,” but I’ll refer to “components” in
    the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of this chapter, a component is a set of classes that has a dedicated
    namespace and a clearly defined API. If another component needs this component’s
    functionality, it can call it via its API, but it may not reach into its internals.
    A component may be made up of smaller components. By default, these sub-components
    live inside the internals of the parent component, so that they are not accessible
    from the outside. They can, however, contribute to the parent component’s API
    if they implement functionality that should be accessible from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: Like any other architecture style, component-based architecture is all about
    which dependencies are allowed and which are discouraged. This is illustrated
    in *Figure 14**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 14.1 – Dependencies on an internal package are invalid\uFEFF but dependencies\
    \ on an API package are valid, provided that the API package is not nested in\
    \ an internal package](img/Figure_14.1._B19916.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Dependencies on an internal package are invalid but dependencies
    on an API package are valid, provided that the API package is not nested in an
    internal package
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have two top-level components, A and B. Component A is made up of two
    sub-components, A1 and A2, while component B only has a single sub-component,
    B1.
  prefs: []
  type: TYPE_NORMAL
- en: If A1 needs access to B’s functionality, it can get it by calling B’s API. It
    cannot, however, access B1’s API, because, as a sub-component, it’s part of its
    parent’s internals and thus hidden from the outside. B1 can still contribute functionality
    to its parent’s API, though, by implementing an interface in the parent API. We
    will see this in action in the case study later.
  prefs: []
  type: TYPE_NORMAL
- en: The same rules apply between the sibling components, A1 and A2\. If A1 needs
    access to A2’s functionality, it can call its API, but it cannot call into A2’s
    internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s all there is to component-based architecture. It can be summarized
    in four simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A component has a dedicated namespace to be addressable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A component has a dedicated API and internals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A component’s API may be called from the outside, but its internals may not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A component may contain sub-components as part of its internals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the abstract concrete, let’s see a component-based architecture in real
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – building a “Check Engine” component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a case study for the component-based architecture presented in this chapter,
    I extracted a component from a real software project I worked on into a standalone
    GitHub repository.[2](#footnote-045) The fact alone that I extracted the component
    with relatively little effort and that we can reason about this component without
    knowing anything about the software project it comes from shows that we have successfully
    conquered complexity by applying modularity!
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-045-backlink) The GitHub project with the “check engine” implemented
    in component-based architecture: [https://github.com/thombergs/components-example](https://github.com/thombergs/components-example).'
  prefs: []
  type: TYPE_NORMAL
- en: The component is written in object-oriented Kotlin, but the concepts apply to
    any other object-oriented language.
  prefs: []
  type: TYPE_NORMAL
- en: The component is called “check engine.” It was meant to be a kind of web scraper
    that goes through web pages and runs a set of checks against them. These checks
    can be anything from “check that the HTML on that web page is valid” to “return
    all spelling errors on that web page.”
  prefs: []
  type: TYPE_NORMAL
- en: Since a lot can go wrong when scraping web pages, we decided to run the checks
    asynchronously. That means that the component needs to provide an API to schedule
    checks and an API to retrieve the results of a check after it has been executed.
    This implies a queue in which to store incoming check requests and a database
    in which to store the results of these checks.
  prefs: []
  type: TYPE_NORMAL
- en: From the outside, it doesn’t matter whether we build the check engine “in one
    piece” or split it up into sub-components. As long as the component has a dedicated
    API, these details are hidden from the outside. The requirements above, however,
    outline certain natural boundaries for sub-components within the check engine.
    Breaking the check engine up along these boundaries allows us to manage complexity
    within the check engine component because each sub-component will be simpler to
    manage than the whole problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We came up with three sub-components for the check engine:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue component that wraps the access to a queue to queue and dequeue check
    requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database component that wraps the access to a database to store and retrieve
    check results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A checkrunner component that knows which checks to run and runs them whenever
    a check request comes in from the queue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that these sub-components introduce mostly technical boundaries. Very similarly
    to output adapters in Hexagonal Architecture, we’re hiding away the specifics
    of accessing an external system (the queue and database) in sub-components. But
    then, the check engine component is a very technical component with little to
    no domain code. The only component that we could consider “domain code” is the
    checkrunner, which acts as a controller of sorts. Technical components lend themselves
    very well to a component-based architecture because the boundaries between them
    are clearer than the boundaries between different functional domains.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at an architecture diagram of the check engine component to
    dig into the details (*Figure 14**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – The check engine component is made up of three sub-components
    that contribute to the parent component’s API](img/Figure_14.2._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – The check engine component is made up of three sub-components
    that contribute to the parent component’s API
  prefs: []
  type: TYPE_NORMAL
- en: The diagram mirrors the structure of the code. You can think of each box as
    a Java package (or a simple source code folder in other programming languages).
    If a box is within a larger box, it’s a sub-package of that larger box. The boxes
    at the lowest level, finally, are classes.
  prefs: []
  type: TYPE_NORMAL
- en: The public API of the check engine component consists of the `CheckScheduler`
    and `CheckQueries` interfaces, which allow scheduling a web page check and retrieving
    the check results, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`CheckScheduler` is implemented by the `SqsCheckScheduler` class living in
    the queue component internals. This way, the queue component contributes to the
    parent component’s API. Only when we look at the name of this class does it tell
    us that it’s using Amazon’s Simple Queue Service (SQS). This implementation detail
    is not leaked to the outside of the check engine component. Not even the sibling
    components know which queue technology is used. You might notice that the queue
    component doesn’t even have an API package, so all of its classes are internal!'
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckRequestListener` class, then, listens to incoming requests from the
    queue. For each incoming request, it calls the `CheckRunner` interface in the
    checkrunner sub-component’s API. `DefaultCheckRunner` implements that interface.
    It reads the web page URL from the incoming request, determines which checks to
    run against it, and then runs those checks.
  prefs: []
  type: TYPE_NORMAL
- en: When a check has finished, the `DefaultCheckRunner` class stores the results
    in the database by calling the `CheckMutations` interface of the database sub-component’s
    API. This interface is implemented by the `CheckRepository` class, which handles
    the details of connecting and talking to a database. Again, the database technology
    is not leaked to the outside of the database sub-component.
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckRepository` class also implements the `CheckQueries` interface, which
    is part of the check engine’s public API. This interface provides methods to query
    for check results.
  prefs: []
  type: TYPE_NORMAL
- en: By splitting up the check engine component into three sub-components, we have
    divided the complexity. Each sub-component solves a simpler part of the overall
    problem. It can evolve mostly by itself. A change in queue or database technologies
    because of costs, scalability, or other reasons doesn’t leak into other sub-components.
    We could even replace the sub-components with simple in-memory implementations
    for tests if we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: All this we get by structuring our code into components, following the convention
    of having dedicated API and internal packages.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing component boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventions are good to have, but if that’s all there is, someone will break
    them, and the architecture will erode. We need to enforce the conventions of the
    component architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing about the component architecture is that we can apply a relatively
    simple fitness function to make sure that no accidental dependencies have crept
    into our component architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '*No classes that are outside of an “internal” package should access a class
    inside of that “**internal” package.*'
  prefs: []
  type: TYPE_NORMAL
- en: If we put all the internals of a component into a package called “internal”
    (or a package marked as “internal” in some other way), we just have to check that
    no class in that package is called from outside of that package. For JVM-based
    projects, we can codify this fitness function with ArchUnit:[3](#footnote-044)
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-044-backlink) ArchUnit rule to validate that no code accesses
    code within a certain package: [https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/Internal
    PackageTest.kt](https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/InternalPackageTest.kt).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-14.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We just need a way to identify internal packages during each build and feed
    them all into the function above, and the build will fail if we have accidentally
    introduced a dependency to an internal class.
  prefs: []
  type: TYPE_NORMAL
- en: The fitness function doesn’t even need to know anything about the components
    in our architecture. We just need to follow a convention for identifying internal
    packages and then feed those packages into the function. This means that we don’t
    need to update the test that’s running the fitness function whenever we add or
    remove a component to/from the code base. Very convenient!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This fitness function is an inverted form of the fitness function we introduced
    in [*Chapter 12*](B19916_12.xhtml#_idTextAnchor105)*, Enforcing Architecture Boundaries*.
    In [*Chapter 12*](B19916_12.xhtml#_idTextAnchor105), we verified that classes
    from a certain package don’t access classes outside of that package. Here, we
    verify that classes from outside the package are not accessing classes inside
    the package. This fitness function is much more stable, as we don’t have to add
    exceptions for every library we’re using.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still introduce unwanted dependencies by just not following our convention
    for internal packages, of course. And the rule still allows a loophole: if we
    put classes directly into the “internal” package of a top-level component, the
    classes of any sub-components may access it. So, we might want to introduce another
    rule that disallows any classes directly in the “internal” package of a top-level
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Component-based architecture is very simple. As long as each component has a
    dedicated namespace, dedicated API and internal packages, and classes within an
    internal package are not called from the outside, we get a very maintainable code
    base consisting of many composable and re-composable components. If we add the
    rule that components may be composed of other components, we can build a whole
    application out of smaller and smaller parts where each part solves a simpler
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there are loopholes to get around the rules of the component architecture,
    the architecture itself is so simple that it’s very easy to understand and communicate.
    If it’s easy to understand, it’s easy to maintain. If it’s easy to maintain, the
    loopholes are less likely to be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal Architecture cares about boundaries at the application level. Component-based
    architecture cares about boundaries at the component level. We can use this to
    embed components within a Hexagonal Architecture, or we can choose to start out
    with a simple component-based architecture and evolve it in any other architecture
    should the need arise. A component-based architecture is modular by design and
    modules are easy to move around and refactor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last chapter, we’ll close the discussion around architecture
    and try to answer the question of when we should choose which architecture style.
  prefs: []
  type: TYPE_NORMAL
