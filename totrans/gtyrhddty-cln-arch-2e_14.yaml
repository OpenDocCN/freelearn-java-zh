- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: A Component-Based Approach to Software Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构的组件化方法
- en: When we’re starting a software project, we never know all the requirements that
    the users will throw at us once they are actually using the software. A software
    project is always associated with taking chances and making educated guesses (we
    like to call them “assumptions” to make it sound more professional). The environment
    of a software project is just too volatile to know in advance how everything will
    play out. This volatility is why the Agile movement was born. Agile practices
    make organizations flexible enough to adapt to change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始一个软件项目时，我们永远不知道用户在使用软件时将会一次性抛给我们哪些需求。软件项目总是伴随着冒险和做出有根据的猜测（我们喜欢称之为“假设”，以使其听起来更专业）。软件项目的环境变化无常，无法事先知道一切将如何展开。正是这种变化无常促成了敏捷运动的诞生。敏捷实践使组织足够灵活，能够适应变化。
- en: But how can we create a software architecture that can cope with such an agile
    environment? If everything can change at any time, should we even bother with
    architecture?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何创建一个能够应对如此敏捷环境的软件架构？如果一切都可以随时改变，我们是否还应该关心架构？
- en: Yes, we should. As discussed in [*Chapter 1*](B19916_01.xhtml#_idTextAnchor014),
    *Maintainability*, we should make sure that our software architecture enables
    maintainability. A maintainable code base can evolve over time, adapting to external
    factors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们应该。如[*第1章*](B19916_01.xhtml#_idTextAnchor014)中所述，*可维护性*，我们应该确保我们的软件架构能够实现可维护性。一个可维护的代码库可以随着时间的推移而演变，适应外部因素。
- en: Hexagonal Architecture takes a big step toward maintainability. It’s creating
    a boundary between our application and the outside world. On the inside of our
    application (within the hexagon), we have our domain code, which provides dedicated
    ports to the outside world. These ports connect the application to adapters, which
    talk to the outside world, translating between the language of our application
    and the languages of outside systems. This architecture enhances maintainability
    because the application can mostly evolve independently of the outside world.
    As long as the ports don’t change, we can evolve anything within the application
    to react to changes in the agile environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构在可维护性方面迈出了重要一步。它在我们应用程序和外部世界之间创建了一个边界。在我们应用程序的内部（六边形内），我们有我们的领域代码，它为外部世界提供了专门的端口。这些端口将应用程序连接到适配器，适配器与外部世界通信，在应用程序的语言和外部系统的语言之间进行翻译。这种架构提高了可维护性，因为应用程序可以主要独立于外部世界进行演变。只要端口不改变，我们就可以在应用程序内部演变任何内容，以应对敏捷环境中的变化。
- en: But, as we learned in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing
    Multiple Bounded Contexts*, Hexagonal Architecture doesn’t help us to create boundaries
    within our application core. We might want to apply a different architecture within
    our application core that helps us in this regard.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们在[*第13章*](B19916_13.xhtml#_idTextAnchor112)中学习的，*管理多个边界上下文*，六边形架构并不能帮助我们在我们应用程序的核心内部创建边界。我们可能希望在应用程序核心内部应用不同的架构，以帮助我们在这方面。
- en: Also, I’ve heard quite a few times that Hexagonal Architecture feels hard, especially
    for a software project just starting out. It’s hard to get the team on board because
    not everyone understands the value of dependency inversion and the mapping between
    the domain model and the outside world. Hexagonal Architecture might just be overkill
    for a fledgling application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我多次听说六边形架构感觉很难，尤其是对于一个刚开始的软件项目来说。很难让团队接受，因为并不是每个人都理解依赖倒置的价值以及领域模型与外部世界之间的映射。对于初出茅庐的应用程序来说，六边形架构可能是一种过度设计。
- en: For cases like this, we might want to start out with a simpler architecture
    style that still provides the modularity we need to evolve into something else
    in the future but that’s simple enough to get everyone on board. I propose that
    a component-based architecture is a good starting point, and we’ll use this chapter
    to discuss this architecture style.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类情况，我们可能希望从一个更简单的架构风格开始，这种风格仍然提供了我们未来演变所需的模块化，同时足够简单，以便让每个人都参与其中。我建议组件化架构是一个好的起点，我们将使用本章来讨论这种架构风格。
- en: Modularity through components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组件实现模块化
- en: One of the drivers of maintainability is modularity. Modularity allows us to
    conquer the complexity of a software system by dividing it into simpler modules.
    We don’t have to understand the whole system to be able to work on one specific
    module. Instead, we can focus on that one module and potentially the modules it
    interfaces with. Modules can evolve mostly independently of each other, as long
    as the interfaces between modules are clearly defined. We’re probably able to
    fit a mental model of one module into our working memory, but good luck with creating
    a mental model if there are no modules in the code base. We would jump around
    in the code rather helplessly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性的一个驱动因素是模块化。通过将软件系统划分为更简单的模块，模块化使我们能够征服软件系统的复杂性。我们不需要理解整个系统就能对某个特定的模块进行工作。相反，我们可以专注于那个模块，以及它可能交互的模块。只要模块之间的接口定义得清楚，模块可以相对独立地发展。我们可能能够将一个模块的心理模型放入我们的工作记忆中，但如果没有模块在代码库中，创建心理模型就非常困难了。我们会在代码中无助地跳来跳去。
- en: Only modularity allows us humans to create complex systems. In his book *Modern
    Software Engineering*, Dave Farley talks about the modularity of the Apollo space
    program:[1](#footnote-046)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 只有模块化才使我们人类能够创建复杂的系统。在Dave Farley的《现代软件工程》一书中，他谈到了阿波罗太空计划的模块化：[1](#footnote-046)
- en: '[1](#footnote-046-backlink) Modularity of the Apollo space program*: Modern
    Software Engineering* by Dave Farley, Pearson, 2022, [*Chapter 6*](B19916_06.xhtml#_idTextAnchor056).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-046-backlink) 阿波罗太空计划的模块化：《现代软件工程》由Dave Farley著，Pearson出版社，2022年，[*第6章*](B19916_06.xhtml#_idTextAnchor056)。'
- en: “*This modularity had lots of advantages. It meant that each component could
    be built to focus on one part of the problem and would need to compromise less
    in its design. It allowed different groups – in this case, completely different
    companies – to work on each module largely independently of the others. As long
    as the different groups agreed on how the modules would interface with each other,
    they could work to solve the problems of their module* *without constraint*.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “这种模块化有很多优点。这意味着每个组件都可以专注于解决问题的某个部分，并且在设计上需要妥协得更少。它允许不同的团队——在这种情况下，是完全不同的公司——在主要独立于其他团队的情况下工作在每个模块上。只要不同的团队就模块之间的接口达成一致，他们就可以努力解决他们模块的问题，而无需受到约束。”
- en: Modularity allowed us to go to the Moon! Modularity allows us to build cars,
    aircraft, and buildings. It should be no surprise that it also helps us build
    complex software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化使我们能够登上月球！模块化使我们能够制造汽车、飞机和建筑物。它也帮助我们构建复杂的软件，这并不令人惊讶。
- en: But what is a module? I feel the term is overloaded in (object-oriented) software
    development. Everything and its cat is called a “module,” even if it’s just a
    bunch of classes that were haphazardly thrown together to do a useful thing. I
    prefer the term “component” to describe a group of classes that were thoughtfully
    engineered to implement certain functionality that can be composed together with
    other groups of classes to build a complex system. The composition aspect implies
    that components can be composed to form a bigger whole and potentially even re-composed
    to react to changes in the environment. Composability requires a component to
    define a clear interface that tells us what it provides to and needs from the
    outside world (input and output ports, anyone?). Think of LEGO bricks. A LEGO
    brick provides a certain layout of studs for other bricks to attach to, and it
    requires a certain layout of studs to attach to other bricks. All that said, I
    won’t judge you if you use the term “module,” but I’ll refer to “components” in
    the rest of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但什么是模块呢？我觉得在（面向对象）软件开发中，这个术语被过度使用了。所有东西，包括它的猫，都被称作“模块”，即使它只是一堆随意组合在一起以完成有用事情的课程。我更喜欢用“组件”来描述一组精心设计以实现某些功能，并且可以与其他课程组一起组合起来构建复杂系统的课程。组合方面意味着组件可以组合成更大的整体，甚至可以重新组合以应对环境的变化。可组合性要求组件定义一个清晰的接口，告诉我们它向外界提供什么以及它需要什么（输入和输出端口，对吧？）。想想乐高积木。乐高积木为其他积木提供了一定布局的凸点，并且需要一定布局的凸点来连接到其他积木。话虽如此，我不会因为您使用“模块”这个术语而评判您，但在这章的其余部分，我会使用“组件”这个术语。
- en: For the sake of this chapter, a component is a set of classes that has a dedicated
    namespace and a clearly defined API. If another component needs this component’s
    functionality, it can call it via its API, but it may not reach into its internals.
    A component may be made up of smaller components. By default, these sub-components
    live inside the internals of the parent component, so that they are not accessible
    from the outside. They can, however, contribute to the parent component’s API
    if they implement functionality that should be accessible from the outside.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，一个组件是一组具有专用命名空间和明确定义的API的类。如果另一个组件需要此组件的功能，它可以通过其API调用它，但它可能无法访问其内部。一个组件可能由更小的组件组成。默认情况下，这些子组件位于父组件的内部，因此它们从外部不可访问。然而，如果它们实现了应从外部访问的功能，它们可以贡献给父组件的API。
- en: Like any other architecture style, component-based architecture is all about
    which dependencies are allowed and which are discouraged. This is illustrated
    in *Figure 14**.1*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他架构风格一样，基于组件的架构完全是关于允许哪些依赖以及哪些依赖被劝阻。这在上图*14.1*中得到了说明。
- en: "![Figure 14.1 – Dependencies on an internal package are invalid\uFEFF but dependencies\
    \ on an API package are valid, provided that the API package is not nested in\
    \ an internal package](img/Figure_14.1._B19916.jpg)"
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 对内部包的依赖无效，但只要API包不是嵌套在内部包中，对API包的依赖就有效](img/Figure_14.1._B19916.jpg)'
- en: Figure 14.1 – Dependencies on an internal package are invalid but dependencies
    on an API package are valid, provided that the API package is not nested in an
    internal package
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 对内部包的依赖无效，但只要API包不是嵌套在内部包中，对API包的依赖就有效
- en: Here, we have two top-level components, A and B. Component A is made up of two
    sub-components, A1 and A2, while component B only has a single sub-component,
    B1.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个顶级组件，A和B。组件A由两个子组件A1和A2组成，而组件B只有一个子组件B1。
- en: If A1 needs access to B’s functionality, it can get it by calling B’s API. It
    cannot, however, access B1’s API, because, as a sub-component, it’s part of its
    parent’s internals and thus hidden from the outside. B1 can still contribute functionality
    to its parent’s API, though, by implementing an interface in the parent API. We
    will see this in action in the case study later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果A1需要访问B的功能，它可以通过调用B的API来获取。然而，它无法访问B1的API，因为作为一个子组件，它是其父组件内部的一部分，因此对外部隐藏。尽管如此，B1可以通过在父API中实现一个接口来向其父组件的API贡献功能。我们将在后面的案例研究中看到这一点。
- en: The same rules apply between the sibling components, A1 and A2\. If A1 needs
    access to A2’s functionality, it can call its API, but it cannot call into A2’s
    internals.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的规则适用于兄弟组件A1和A2之间。如果A1需要访问A2的功能，它可以调用其API，但它不能调用A2的内部。
- en: 'And that’s all there is to component-based architecture. It can be summarized
    in four simple rules:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于组件架构的全部内容。它可以总结为四条简单的规则：
- en: A component has a dedicated namespace to be addressable.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件有一个专用命名空间以便可寻址。
- en: A component has a dedicated API and internals.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件有一个专用的API和内部结构。
- en: A component’s API may be called from the outside, but its internals may not.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件的API可以从外部调用，但它的内部结构不能。
- en: A component may contain sub-components as part of its internals.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件可能包含作为其内部部分子组件。
- en: To make the abstract concrete, let’s see a component-based architecture in real
    code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使抽象具体化，让我们看看一个基于组件架构的真实代码示例。
- en: Case study – building a “Check Engine” component
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 – 构建“检查引擎”组件
- en: As a case study for the component-based architecture presented in this chapter,
    I extracted a component from a real software project I worked on into a standalone
    GitHub repository.[2](#footnote-045) The fact alone that I extracted the component
    with relatively little effort and that we can reason about this component without
    knowing anything about the software project it comes from shows that we have successfully
    conquered complexity by applying modularity!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章中介绍的基于组件架构的案例研究，我从我参与的一个真实软件项目中提取了一个组件到一个独立的GitHub仓库。[2](#footnote-045)
    仅仅是我相对容易地提取了组件，并且我们可以对这个组件进行推理，而无需了解它来自哪个软件项目，这表明我们通过应用模块化成功地征服了复杂性！
- en: '[2](#footnote-045-backlink) The GitHub project with the “check engine” implemented
    in component-based architecture: [https://github.com/thombergs/components-example](https://github.com/thombergs/components-example).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-045-backlink) 实现了基于组件架构的“检查引擎”的GitHub项目：[https://github.com/thombergs/components-example](https://github.com/thombergs/components-example)。'
- en: The component is written in object-oriented Kotlin, but the concepts apply to
    any other object-oriented language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件是用面向对象的Kotlin编写的，但这些概念适用于任何其他面向对象的编程语言。
- en: The component is called “check engine.” It was meant to be a kind of web scraper
    that goes through web pages and runs a set of checks against them. These checks
    can be anything from “check that the HTML on that web page is valid” to “return
    all spelling errors on that web page.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件被称为“检查引擎”。它原本打算是一种网络爬虫，它会遍历网页并对它们运行一系列检查。这些检查可以是“检查该网页上的HTML是否有效”到“返回该网页上的所有拼写错误”等。
- en: Since a lot can go wrong when scraping web pages, we decided to run the checks
    asynchronously. That means that the component needs to provide an API to schedule
    checks and an API to retrieve the results of a check after it has been executed.
    This implies a queue in which to store incoming check requests and a database
    in which to store the results of these checks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于抓取网页时可能会出现很多问题，我们决定异步运行检查。这意味着组件需要提供一个用于安排检查的API，以及一个在检查执行后检索检查结果的API。这暗示需要一个用于存储传入检查请求的队列和一个用于存储这些检查结果的数据库。
- en: From the outside, it doesn’t matter whether we build the check engine “in one
    piece” or split it up into sub-components. As long as the component has a dedicated
    API, these details are hidden from the outside. The requirements above, however,
    outline certain natural boundaries for sub-components within the check engine.
    Breaking the check engine up along these boundaries allows us to manage complexity
    within the check engine component because each sub-component will be simpler to
    manage than the whole problem.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，无论是将检查引擎“整体构建”还是将其拆分成子组件，都没有关系。只要组件有一个专门的API，这些细节就会对外隐藏。然而，上述要求为检查引擎内部的子组件定义了某些自然的边界。沿着这些边界拆分检查引擎，使我们能够管理检查引擎组件内部的复杂性，因为每个子组件比整个问题更容易管理。
- en: 'We came up with three sub-components for the check engine:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为检查引擎提出了三个子组件：
- en: A queue component that wraps the access to a queue to queue and dequeue check
    requests.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个队列组件，它封装了对队列的访问以排队和出队检查请求。
- en: A database component that wraps the access to a database to store and retrieve
    check results.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库组件，它封装了对数据库的访问以存储和检索检查结果。
- en: A checkrunner component that knows which checks to run and runs them whenever
    a check request comes in from the queue.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个检查运行器组件，它知道要运行哪些检查，并在队列中有检查请求时运行它们。
- en: Note that these sub-components introduce mostly technical boundaries. Very similarly
    to output adapters in Hexagonal Architecture, we’re hiding away the specifics
    of accessing an external system (the queue and database) in sub-components. But
    then, the check engine component is a very technical component with little to
    no domain code. The only component that we could consider “domain code” is the
    checkrunner, which acts as a controller of sorts. Technical components lend themselves
    very well to a component-based architecture because the boundaries between them
    are clearer than the boundaries between different functional domains.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些子组件主要引入了技术边界。与六边形架构中的输出适配器非常相似，我们在子组件中隐藏了访问外部系统（队列和数据库）的细节。然而，检查引擎组件是一个非常技术性的组件，几乎没有领域代码。唯一可以考虑为“领域代码”的组件是检查运行器，它充当某种控制器。技术组件非常适合基于组件的架构，因为它们之间的边界比不同功能域之间的边界更清晰。
- en: Let’s take a look at an architecture diagram of the check engine component to
    dig into the details (*Figure 14**.2*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看检查引擎组件的架构图，以深入了解细节（*图14.2*）。
- en: '![Figure 14.2 – The check engine component is made up of three sub-components
    that contribute to the parent component’s API](img/Figure_14.2._B19916.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 检查引擎组件由三个子组件组成，这些子组件有助于父组件的API](img/Figure_14.2._B19916.jpg)'
- en: Figure 14.2 – The check engine component is made up of three sub-components
    that contribute to the parent component’s API
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 检查引擎组件由三个子组件组成，这些子组件有助于父组件的API
- en: The diagram mirrors the structure of the code. You can think of each box as
    a Java package (or a simple source code folder in other programming languages).
    If a box is within a larger box, it’s a sub-package of that larger box. The boxes
    at the lowest level, finally, are classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图表反映了代码的结构。你可以把每个框想象成Java包（或在其他编程语言中的简单源代码文件夹）。如果一个框在更大的框内，它就是该更大框的子包。最后，最低层的框是类。
- en: The public API of the check engine component consists of the `CheckScheduler`
    and `CheckQueries` interfaces, which allow scheduling a web page check and retrieving
    the check results, respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 检查引擎组件的公共 API 由 `CheckScheduler` 和 `CheckQueries` 接口组成，分别允许安排网页检查和检索检查结果。
- en: '`CheckScheduler` is implemented by the `SqsCheckScheduler` class living in
    the queue component internals. This way, the queue component contributes to the
    parent component’s API. Only when we look at the name of this class does it tell
    us that it’s using Amazon’s Simple Queue Service (SQS). This implementation detail
    is not leaked to the outside of the check engine component. Not even the sibling
    components know which queue technology is used. You might notice that the queue
    component doesn’t even have an API package, so all of its classes are internal!'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckScheduler` 由位于队列组件内部的 `SqsCheckScheduler` 类实现。这样，队列组件就为父组件的 API 做出了贡献。只有当我们查看这个类的名称时，我们才会知道它正在使用亚马逊的简单队列服务（SQS）。这个实现细节并没有泄露到检查引擎组件的外部。甚至兄弟组件也不知道使用了哪种队列技术。你可能还会注意到，队列组件甚至没有
    API 包，所以它所有的类都是内部的！'
- en: The `CheckRequestListener` class, then, listens to incoming requests from the
    queue. For each incoming request, it calls the `CheckRunner` interface in the
    checkrunner sub-component’s API. `DefaultCheckRunner` implements that interface.
    It reads the web page URL from the incoming request, determines which checks to
    run against it, and then runs those checks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`CheckRequestListener` 类监听来自队列的传入请求。对于每个传入请求，它调用检查运行器子组件 API 中的 `CheckRunner`
    接口。`DefaultCheckRunner` 实现了该接口。它从传入请求中读取网页 URL，确定要对其运行的检查，然后运行这些检查。
- en: When a check has finished, the `DefaultCheckRunner` class stores the results
    in the database by calling the `CheckMutations` interface of the database sub-component’s
    API. This interface is implemented by the `CheckRepository` class, which handles
    the details of connecting and talking to a database. Again, the database technology
    is not leaked to the outside of the database sub-component.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查完成时，`DefaultCheckRunner` 类通过调用数据库子组件 API 的 `CheckMutations` 接口将结果存储在数据库中。这个接口由处理连接和与数据库通信的
    `CheckRepository` 类实现。同样，数据库技术也没有泄露到数据库子组件的外部。
- en: The `CheckRepository` class also implements the `CheckQueries` interface, which
    is part of the check engine’s public API. This interface provides methods to query
    for check results.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckRepository` 类还实现了 `CheckQueries` 接口，这是检查引擎公共 API 的一部分。该接口提供了查询检查结果的方法。'
- en: By splitting up the check engine component into three sub-components, we have
    divided the complexity. Each sub-component solves a simpler part of the overall
    problem. It can evolve mostly by itself. A change in queue or database technologies
    because of costs, scalability, or other reasons doesn’t leak into other sub-components.
    We could even replace the sub-components with simple in-memory implementations
    for tests if we wanted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将检查引擎组件拆分为三个子组件，我们已经将复杂性分解。每个子组件解决整体问题的一个更简单的部分。它主要可以自行进化。由于成本、可扩展性或其他原因，队列或数据库技术的变化不会渗透到其他子组件中。如果我们想的话，甚至可以用简单的内存实现来替换子组件进行测试。
- en: All this we get by structuring our code into components, following the convention
    of having dedicated API and internal packages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，我们都是通过将代码结构化为组件，遵循拥有专用 API 和内部包的惯例来获得的。
- en: Enforcing component boundaries
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制组件边界
- en: Conventions are good to have, but if that’s all there is, someone will break
    them, and the architecture will erode. We need to enforce the conventions of the
    component architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯是好的，但如果只有这些，有人会打破它们，架构就会逐渐退化。我们需要强制执行组件架构的规范。
- en: 'The nice thing about the component architecture is that we can apply a relatively
    simple fitness function to make sure that no accidental dependencies have crept
    into our component architecture:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 组件架构的优点在于，我们可以应用一个相对简单的适应函数来确保没有意外的依赖关系渗透到我们的组件架构中：
- en: '*No classes that are outside of an “internal” package should access a class
    inside of that “**internal” package.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何不属于“内部”包的类都不应该访问该“**内部**”包中的类。*'
- en: If we put all the internals of a component into a package called “internal”
    (or a package marked as “internal” in some other way), we just have to check that
    no class in that package is called from outside of that package. For JVM-based
    projects, we can codify this fitness function with ArchUnit:[3](#footnote-044)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将组件的所有内部内容放入一个名为“internal”的包中（或以其他方式标记为“internal”的包），我们只需检查该包中的任何类都没有从包外部被调用。对于基于JVM的项目，我们可以使用ArchUnit来规范这个适应度函数：[3](#footnote-044)
- en: '[3](#footnote-044-backlink) ArchUnit rule to validate that no code accesses
    code within a certain package: [https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/Internal
    PackageTest.kt](https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/InternalPackageTest.kt).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-044-backlink) 验证特定包内没有代码访问的ArchUnit规则：[https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/InternalPackageTest.kt](https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/InternalPackageTest.kt).'
- en: '![](img/code-14.1.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/code-14.1.jpg)'
- en: We just need a way to identify internal packages during each build and feed
    them all into the function above, and the build will fail if we have accidentally
    introduced a dependency to an internal class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一种方法来识别每次构建过程中的内部包，并将它们全部输入到上面的函数中，如果意外地将依赖引入到内部类中，构建将会失败。
- en: The fitness function doesn’t even need to know anything about the components
    in our architecture. We just need to follow a convention for identifying internal
    packages and then feed those packages into the function. This means that we don’t
    need to update the test that’s running the fitness function whenever we add or
    remove a component to/from the code base. Very convenient!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度函数甚至不需要了解我们架构中的组件。我们只需要遵循一个用于识别内部包的约定，然后将这些包输入到函数中。这意味着我们不需要在添加或从代码库中删除组件时更新运行适应度函数的测试。非常方便！
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This fitness function is an inverted form of the fitness function we introduced
    in [*Chapter 12*](B19916_12.xhtml#_idTextAnchor105)*, Enforcing Architecture Boundaries*.
    In [*Chapter 12*](B19916_12.xhtml#_idTextAnchor105), we verified that classes
    from a certain package don’t access classes outside of that package. Here, we
    verify that classes from outside the package are not accessing classes inside
    the package. This fitness function is much more stable, as we don’t have to add
    exceptions for every library we’re using.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个适应度函数是我们之前在[*第12章*](B19916_12.xhtml#_idTextAnchor105)*，强制执行架构边界*中引入的适应度函数的倒数形式。在第12章中，我们验证了来自某个包的类不会访问该包之外的类。在这里，我们验证外部包的类不会访问包内部的类。这个适应度函数更加稳定，因为我们不需要为使用的每个库添加异常。
- en: 'We can still introduce unwanted dependencies by just not following our convention
    for internal packages, of course. And the rule still allows a loophole: if we
    put classes directly into the “internal” package of a top-level component, the
    classes of any sub-components may access it. So, we might want to introduce another
    rule that disallows any classes directly in the “internal” package of a top-level
    component.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然可以通过不遵循内部包的约定来引入不想要的依赖。规则仍然允许一个漏洞：如果我们直接将类放入顶级组件的“内部”包中，任何子组件的类都可以访问它。因此，我们可能还想引入另一条规则，禁止任何类直接位于顶级组件的“内部”包中。
- en: How does this help me build maintainable software?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Component-based architecture is very simple. As long as each component has a
    dedicated namespace, dedicated API and internal packages, and classes within an
    internal package are not called from the outside, we get a very maintainable code
    base consisting of many composable and re-composable components. If we add the
    rule that components may be composed of other components, we can build a whole
    application out of smaller and smaller parts where each part solves a simpler
    problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的架构非常简单。只要每个组件都有一个专门的命名空间、专门的API和内部包，并且内部包中的类不会被外部调用，我们就得到了一个非常可维护的代码库，由许多可组合和重新组合的组件组成。如果我们添加规则，允许组件由其他组件组成，我们可以构建一个由更小部分组成的应用程序，每个部分解决一个更简单的问题。
- en: Even though there are loopholes to get around the rules of the component architecture,
    the architecture itself is so simple that it’s very easy to understand and communicate.
    If it’s easy to understand, it’s easy to maintain. If it’s easy to maintain, the
    loopholes are less likely to be exploited.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在绕过组件架构规则的漏洞，但架构本身非常简单，因此很容易理解和沟通。如果容易理解，那么维护起来也容易。如果维护起来容易，那么漏洞被利用的可能性就较小。
- en: Hexagonal Architecture cares about boundaries at the application level. Component-based
    architecture cares about boundaries at the component level. We can use this to
    embed components within a Hexagonal Architecture, or we can choose to start out
    with a simple component-based architecture and evolve it in any other architecture
    should the need arise. A component-based architecture is modular by design and
    modules are easy to move around and refactor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构关注应用层面的边界。基于组件的架构关注组件层面的边界。我们可以利用这一点在六边形架构中嵌入组件，或者我们可以选择从一个简单的基于组件的架构开始，并在需要时向任何其他架构演变。基于组件的架构是模块化的，设计上模块易于移动和重构。
- en: In the next and last chapter, we’ll close the discussion around architecture
    and try to answer the question of when we should choose which architecture style.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将结束关于架构的讨论，并尝试回答我们应该在何时选择哪种架构风格的问题。
