<html><head></head><body>
		<div id="_idContainer068">
			<h1 class="chapter-number" id="_idParaDest-154"><a id="_idTextAnchor164"/>9</h1>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor165"/>Writing Tests in Spring Boot</h1>
			<p>In the previous chapter, you have learned about the importance of loggers, their concepts, and how they can help developers debug and maintain applications. You have learned about Log4j2, which is a third-party framework for Spring Boot that offers several features such as <strong class="bold">Appenders</strong>, <strong class="bold">Filters</strong>, and <strong class="bold">Markers</strong> that can assist in making log events categorized and formatted for developers. We have also discussed SLF4J, which is an abstraction of logging frameworks that allows us to switch between different frameworks during runtime or at deployment, and lastly, we have implemented and configured the logging frameworks with XML configuration <span class="No-Break">and Lombok.</span></p>
			<p>This chapter will now focus on writing unit tests for our Spring Boot application; we will discuss the most commonly used testing frameworks with Java, JUnit, and <strong class="bold">AssertJ</strong> and implement them in our application. We will also be integrating Mockito with our unit test for mocking objects <span class="No-Break">and services.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding JUnit <span class="No-Break">and AssertJ</span></li>
				<li>Writing <span class="No-Break">a test</span></li>
				<li>Writing tests in a service <span class="No-Break">using Mockito</span></li>
			</ul>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor166"/>Technical requirements</h1>
			<p>The link to the finished version of this chapter is <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor167"/>Understanding JUnit and AssertJ</h1>
			<p>After every development of an application, testing will always be the next step, and this is one of the most <a id="_idIndexMarker625"/>important tasks before delivering or deploying our application into production for <a id="_idIndexMarker626"/>the world. The testing phase is critical for companies, as this ensures the quality and effectiveness of <span class="No-Break">their products.</span></p>
			<p>As this is one of the essential processes, there should be little room for errors in testing, and manual testing is not enough, as this is prone to human errors and has a more significant chance of missing the existing issues in an application. This is where unit testing comes <a id="_idIndexMarker627"/>to the rescue – unit testing is automated testing that allows the developer to write tests for a single class <span class="No-Break">or entity.</span></p>
			<p>It is a form of <strong class="bold">regression testing</strong> that runs all of the tests to validate whether the code still passes the test <a id="_idIndexMarker628"/>cases after several changes or updates have been applied to the application code. Unit tests help maintain the quality of our applications, as they bring the <span class="No-Break">following benefits:</span></p>
			<ul>
				<li><strong class="bold">Speed</strong>: Unit testing will <a id="_idIndexMarker629"/>be less time-consuming compared to manual testing, as this is programmable and will deliver the results in a <span class="No-Break">short period.</span></li>
				<li><strong class="bold">Cost reduction</strong>: Unit testing is automated, which means fewer testers will be required for testing <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Fewer errors</strong>: Unit testing will significantly reduce the number of errors made, as testing is not done manually <span class="No-Break">by humans.</span></li>
				<li><strong class="bold">Programmable</strong>: Unit tests can produce sophisticated tests that detect hidden information in <span class="No-Break">the application.</span></li>
			</ul>
			<p>Unit tests are widely used now in both frontend and backend development, especially in Java, because of their advantages and testing. There are already several testing frameworks available in Java, but we <a id="_idIndexMarker630"/>will discuss the first and most commonly used <span class="No-Break">framework, </span><span class="No-Break"><strong class="bold">JUnit</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor168"/>JUnit framework</h2>
			<p>JUnit is a regression testing framework mainly used for writing tests and assertions for single classes in a Java <a id="_idIndexMarker631"/>application; it promotes the idea of <em class="italic">first testing and then coding</em>, which states that we need to create test data for a piece of code to be tested before implementation. JUnit is also an open source framework, which makes it <span class="No-Break">more reliable.</span></p>
			<p>There is a large community supporting the framework, it uses assertions to test expected results and annotations to identify the methods for testing, and it can be efficiently utilized and integrated with Maven and <span class="No-Break">Gradle projects.</span></p>
			<p>Let’s discuss the features of JUnit that we will use for <span class="No-Break">writing tests:</span></p>
			<ul>
				<li><strong class="bold">Fixtures</strong>: These are objects <a id="_idIndexMarker632"/>that we can consider constants or the baseline for running tests. The primary use of fixtures is to ensure that variables that have the same value throughout testing will be used. There are two types of fixtures, and these are <span class="No-Break">as follows:</span><ul><li><strong class="source-inline">setUp()</strong>: This method is <a id="_idIndexMarker633"/>executed <em class="italic">before</em> every test <span class="No-Break">is invoked.</span></li><li><strong class="source-inline">tearDown()</strong>: This method <a id="_idIndexMarker634"/>is executed <em class="italic">after</em> every test <span class="No-Break">is invoked:</span><pre class="console">
public class JavaTest extends TestCase {</pre><pre class="console">
   protected int value1, value2;</pre><pre class="console">
   // will run before testSubtract and testMultiply</pre><pre class="console">
   protected void setUp(){</pre><pre class="console">
      value1 = 23;</pre><pre class="console">
      value2 = 10;</pre><pre class="console">
   }</pre><pre class="console">
   public void testSubtract(){</pre><pre class="console">
      double result = value1 - value2;</pre><pre class="console">
      assertTrue(result == 13);</pre><pre class="console">
   }</pre><pre class="console">
   public void testMultiply(){</pre><pre class="console">
      double result = value1 * value2;</pre><pre class="console">
      assertTrue(result == 230);</pre><pre class="console">
   }}</pre></li></ul></li>
			</ul>
			<p>In the preceding code example, we can see that there are two test methods defined, which are <strong class="source-inline">testSubtract()</strong> and <strong class="source-inline">testMultiply()</strong>, before each method is called. The <strong class="source-inline">setUp()</strong> fixture will be called first to assign the values of the <strong class="source-inline">value1</strong> and <span class="No-Break"><strong class="source-inline">value2</strong></span><span class="No-Break"> variables.</span></p>
			<ul>
				<li><strong class="bold">Test suites</strong>: Group several unit test cases and execute them together, using the <strong class="source-inline">@RunWith</strong> and <strong class="source-inline">@Suite</strong> annotations <a id="_idIndexMarker635"/>to run the tests. Let’s have a look at the <span class="No-Break">following example:</span><pre class="console">
//JUnit Suite Test</pre><pre class="console">
@RunWith(Suite.class)</pre><pre class="console">
@Suite.SuiteClasses({</pre><pre class="console">
   TestOne.class, TestTwo.class</pre><pre class="console">
});</pre><pre class="console">
public class JunitTestSuite {</pre><pre class="console">
}</pre><pre class="console">
public class TestOne {</pre><pre class="console">
   int x = 1;</pre><pre class="console">
   int y = 2;</pre><pre class="console">
   @Test</pre><pre class="console">
   public void TestOne() {</pre><pre class="console">
      assertEquals(x + y, 3);</pre><pre class="console">
   }</pre><pre class="console">
}</pre><pre class="console">
public class TestTwo {</pre><pre class="console">
   int x = 1;</pre><pre class="console">
   int y = 2;</pre><pre class="console">
   @Test</pre><pre class="console">
   public void TestTwo() {</pre><pre class="console">
      assertEquals(y - x, 1);</pre><pre class="console">
   }</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the preceding code example, we can see that we have two defined classes with a method with the <strong class="source-inline">@Test</strong> annotation; the test methods will be executed together, as we have bundled them using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Suite.SuiteClasses</strong></span><span class="No-Break"> method.</span></p>
			<ul>
				<li><strong class="bold">Test runners</strong>: Mainly used for running the test cases, we use the <strong class="source-inline">runClasses()</strong> method to <a id="_idIndexMarker636"/>run the test cases inside a specific class. Let’s have a look at a basic <span class="No-Break">example here:</span><pre class="console">
public class JUnitTestRunner {</pre><pre class="console">
   public static void main(String[] args) {</pre><pre class="console">
      Result result =</pre><pre class="console">
        JUnitCore.runClasses(TestJunit.class);</pre><pre class="console">
      for (Failure failure : result.getFailures()) {</pre><pre class="console">
         System.out.println(failure.toString());</pre><pre class="console">
      }</pre><pre class="console">
      System.out.println(result.wasSuccessful());</pre><pre class="console">
   }</pre><pre class="console">
}</pre></li>
				<li><strong class="bold">Classes</strong>: JUnit classes are mainly used for writing the tests for our application; these include <span class="No-Break">the following:</span><ul><li><strong class="bold">Assert</strong>: Includes the set of <span class="No-Break">assert methods</span></li><li><strong class="bold">Test case</strong>: Includes the test <a id="_idIndexMarker637"/>cases that contain the fixtures for running <span class="No-Break">multiple tests</span></li><li><strong class="bold">Test result</strong>: Includes the methods to gather all of the results from an executed <span class="No-Break">test case</span></li></ul></li>
			</ul>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor169"/>Assertions in JUnit</h2>
			<p><strong class="bold">Assertions</strong> are the way <a id="_idIndexMarker638"/>to validate whether our tests are valid by checking the outcome <a id="_idIndexMarker639"/>of the written code. In JUnit, all assertions are under the <strong class="source-inline">Assert</strong> class, and some of the essential methods from Assert are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">void assertTrue(boolean condition)</strong>: Validates whether the condition <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span></li>
				<li><strong class="source-inline">void assertFalse(boolean condition)</strong>: Validates whether the condition <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span></li>
				<li><strong class="source-inline">void assertNotNull(Object obj)</strong>: Checks whether the object is <span class="No-Break">not null</span></li>
				<li><strong class="source-inline">void assertNull(Object obj)</strong>: Checks whether the object <span class="No-Break">is null</span></li>
				<li><strong class="source-inline">void assertEquals(Object obj1, Object obj2)</strong>: Checks whether two objects or primitives <span class="No-Break">are equal</span></li>
				<li><strong class="source-inline">void assertArrayEquals(Array array1, Array array2)</strong>: Validates whether two arrays are equal to <span class="No-Break">each other</span></li>
			</ul>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor170"/>Annotations</h2>
			<p><strong class="bold">Annotations</strong> are meta tags <a id="_idIndexMarker640"/>that we add to methods and classes; this provides additional information to JUnit about which methods should run before and after the test methods and which will be ignored during the <span class="No-Break">test execution.</span></p>
			<p>Here are the annotations that we can use <span class="No-Break">in JUnit:</span></p>
			<ul>
				<li><strong class="source-inline">@Test</strong>: This annotation is used for a <strong class="source-inline">public void</strong> method to signify that the method is a test case that can <span class="No-Break">be executed.</span></li>
				<li><strong class="source-inline">@Ignore</strong>: This annotation is used to ignore a test case not <span class="No-Break">being executed.</span></li>
				<li><strong class="source-inline">@Before</strong>: This annotation is used for a <strong class="source-inline">public void</strong> method to run the method before each test case method. This is commonly used if we want to declare similar objects used by all <span class="No-Break">test cases.</span></li>
				<li><strong class="source-inline">@After</strong>: The annotation is used for a <strong class="source-inline">public void</strong> method to run the method after each test case method; this is commonly used if we want to release or clean several resources before running a new <span class="No-Break">test case.</span></li>
				<li><strong class="source-inline">@BeforeClass</strong>: The annotation allows a <strong class="source-inline">public static void</strong> method to run once before all of the test cases <span class="No-Break">are executed.</span></li>
				<li><strong class="source-inline">@AfterClass</strong>: The annotation allows a <strong class="source-inline">public static void</strong> method to run once all test cases <span class="No-Break">are executed.</span></li>
			</ul>
			<p>Let’s have an example test with annotations and their sequence <span class="No-Break">of execution:</span></p>
			<pre class="source-code">
public class JunitAnnotationSequence {
   //execute once before all test
   @BeforeClass
   public static void beforeClass() {
      System.out.println("beforeClass()");
   }
   //execute once after all test
   @AfterClass
   public static void  afterClass() {
      System.out.println("afterClass()");
   }
   //execute before each test
   @Before
   public void before() {
      System.out.println("before()");
   }
   //execute after each test
   @After
   public void after() {
      System.out.println("after()");
   }
   @Test
   public void testMethod1() {
      System.out.println("testMethod1()");
   }
   @Test
   public void testMethod2() {
      System.out.println("testMethod2();");
   }
}</pre>
			<p>In the preceding code example, we have a <strong class="source-inline">JunitAnnotationSequence</strong> class that has several annotated methods. When we execute the test, we will have the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
beforeClass()
before()
testMethod1()
after()
before()
testMethod2()
after()
afterClass()</pre>
			<p>We can see in the <a id="_idIndexMarker641"/>preceding example that the methods annotated with <strong class="source-inline">@BeforeClass</strong> and <strong class="source-inline">@AfterClass</strong> are only called once and they are called at the start and end of the test execution. On the other hand, the methods annotated with <strong class="source-inline">@Before</strong> and <strong class="source-inline">@After</strong> are called at the beginning and the end of each <span class="No-Break">test method.</span></p>
			<p>We have learned about the basics of JUnit in unit testing; now, let’s discuss the concepts <span class="No-Break">of AssertJ.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor171"/>Using AssertJ</h2>
			<p>We have just explored the <a id="_idIndexMarker642"/>concepts and features of JUnit in the last part, and we have learned that in JUnit alone, we can apply assertions using the <strong class="source-inline">Assert</strong> class, but we can make our assertions more fluent and flexible by using AssertJ. <strong class="bold">AssertJ</strong> is a library mainly <a id="_idIndexMarker643"/>used for writing assertions; its primary goal is to improve the readability of test code and make the maintenance of <span class="No-Break">tests simpler.</span></p>
			<p>Let’s compare how to write assertions in JUnit <span class="No-Break">and AssertJ:</span></p>
			<ul>
				<li>JUnit checking <a id="_idIndexMarker644"/>whether the condition <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span><pre class="console">
Assert.assertTrue(condition)</pre></li>
				<li>AssetJ checking <a id="_idIndexMarker645"/>whether the condition <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span><pre class="console">
Assertions.assertThat(condition).isTrue()</pre></li>
			</ul>
			<p>We can see in the preceding example that in AssertJ, we will always pass the object to be compared in <a id="_idIndexMarker646"/>the <strong class="source-inline">assertThat()</strong> method, and we will call the next method, which <a id="_idIndexMarker647"/>is the actual assertion. Let’s have a look at the different kinds of assertions we can use <span class="No-Break">in AssertJ.</span></p>
			<h3>Boolean assertions</h3>
			<p><strong class="bold">Boolean assertions</strong> are used <a id="_idIndexMarker648"/>to check whether conditions return <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. The assertion methods are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">isTrue()</strong>: Checks <a id="_idIndexMarker649"/>whether the condition <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span><pre class="console">
Assertions.assertThat(4 &gt; 3).isTrue()</pre></li>
				<li><strong class="source-inline">isFalse()</strong>: Checks whether the condition <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span><pre class="console">
Assertions.assertThat(11 &gt; 100).isFalse()</pre></li>
			</ul>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor172"/>Character assertions</h2>
			<p><strong class="bold">Character assertions</strong> are used <a id="_idIndexMarker650"/>to compare the object to a character or check whether the character is in the Unicode table; the assertion methods are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">isLowerCase()</strong>: Reviews <a id="_idIndexMarker651"/>whether the given character <span class="No-Break">is lowercase:</span><pre class="console">
Assertions.assertThat('a').isLowerCase();</pre></li>
				<li><strong class="source-inline">isUpperCase()</strong>: Checks whether the character <span class="No-Break">is uppercase:</span><pre class="console">
Assertions.assertThat('a').isUpperCase();</pre></li>
				<li><strong class="source-inline">isEqualTo()</strong>: Checks whether the two given characters <span class="No-Break">are equal:</span><pre class="console">
Assertions.assertThat('a').isEqualTo('a');</pre></li>
				<li><strong class="source-inline">isNotEqualTo()</strong>: Checks whether the two given characters are <span class="No-Break">not equal:</span><pre class="console">
Assertions.assertThat('a').isEqualTo('b');</pre></li>
				<li><strong class="source-inline">inUnicode()</strong>: Checks <a id="_idIndexMarker652"/>whether the character is included in the <span class="No-Break">Unicode table:</span><pre class="console">
Assertions.assertThat('a').inUniCode();</pre></li>
			</ul>
			<p>These are just some of the <a id="_idIndexMarker653"/>assertions available under <strong class="source-inline">AbstractCharacterAssert</strong>. For the complete documentation, you can go <span class="No-Break">to </span><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html"><span class="No-Break">https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor173"/>Class assertions</h2>
			<p><strong class="bold">Class assertions</strong> are used to check the fields, types, access modifiers, and annotations in <a id="_idIndexMarker654"/>a specific class. The following are some of the class <span class="No-Break">assertion methods:</span></p>
			<ul>
				<li><strong class="source-inline">isNotInterface()</strong>: Verifies that <a id="_idIndexMarker655"/>the class is not <span class="No-Break">an interface:</span><pre class="console">
Interface Hero {}</pre><pre class="console">
class Thor implements Hero {}</pre><pre class="console">
Assertions.assertThat(Thor.class).isNotInterface()</pre></li>
				<li><strong class="source-inline">isInterface()</strong>: Verifies that the class is <span class="No-Break">an interface:</span><pre class="console">
Interface Hero {}</pre><pre class="console">
class Thor implements Hero {}</pre><pre class="console">
Assertions.assertThat(Hero.class).isInterface()</pre></li>
				<li><strong class="source-inline">isPublic()</strong>: Verifies that the class <span class="No-Break">is public:</span><pre class="console">
public class Hero {}</pre><pre class="console">
protected class AntiHero {}</pre><pre class="console">
Assertions.assertThat(Hero.class).isPublic()</pre></li>
				<li><strong class="source-inline">isNotPublic()</strong>: Verifies <a id="_idIndexMarker656"/>that the class is <span class="No-Break">not public:</span><pre class="console">
public class Hero {}</pre><pre class="console">
protected class AntiHero {}</pre><pre class="console">
Assertions.assertThat(Hero.class).isNotPublic()</pre></li>
			</ul>
			<p>These are just some <a id="_idIndexMarker657"/>of the assertions available under <strong class="source-inline">AbstractClassAssert</strong>. For the complete documentation, you can go <span class="No-Break">to </span><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html"><span class="No-Break">https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor174"/>Iterable assertions</h2>
			<p><strong class="bold">Iterable assertions</strong> are used to <a id="_idIndexMarker658"/>verify an iterable or array object based on its length and contents. The following are some of the iterable <span class="No-Break">assertion methods:</span></p>
			<ul>
				<li><strong class="source-inline">contains()</strong>: Demonstrates <a id="_idIndexMarker659"/>that the iterable has the <span class="No-Break">given values:</span><pre class="console">
List test = List.asList("Thor", "Hulk",</pre><pre class="console">
                        "Dr. Strange");</pre><pre class="console">
assertThat(test).contains("Thor");</pre></li>
				<li><strong class="source-inline">isEmpty()</strong>: Verifies whether the given iterable has a length greater <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span><pre class="console">
List test = new List();</pre><pre class="console">
assertThat(test).isEmpty();</pre></li>
				<li><strong class="source-inline">isNotEmpty()</strong>: Verifies whether the given iterable has a length <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span><pre class="console">
List test = List.asList("Thor", "Hulk",</pre><pre class="console">
                        "Dr. Strange");</pre><pre class="console">
assertThat(test).isNotEmpty ();</pre></li>
				<li><strong class="source-inline">hasSize()</strong>: Verifies <a id="_idIndexMarker660"/>whether the length of the iterable is equal to the <span class="No-Break">given value:</span><pre class="console">
List test = List.asList("Thor", "Hulk",</pre><pre class="console">
                        "Dr. Strange");</pre><pre class="console">
assertThat(test).hasSize(3);</pre></li>
			</ul>
			<p>These are just some of the <a id="_idIndexMarker661"/>assertions available under <strong class="source-inline">AbstractIterableAssert</strong>. For the complete documentation, you can go to the link provided <span class="No-Break">here: </span><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html"><span class="No-Break">https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor175"/>File assertions</h2>
			<p><strong class="bold">File assertions</strong> are used to verify <a id="_idIndexMarker662"/>whether a file exists, can be written, or is readable, and also verify its contents. The following are some of the file <span class="No-Break">assertion methods:</span></p>
			<ul>
				<li><strong class="source-inline">exists()</strong>: Proves that the <a id="_idIndexMarker663"/>file or <span class="No-Break">directory exists:</span><pre class="console">
File file = File.createTempFile("test", "txt");</pre><pre class="console">
assertThat(tmpFile).exists();</pre></li>
				<li><strong class="source-inline">isFile()</strong>: Verifies whether the given object is a file (providing a directory will result in a <span class="No-Break">failed test):</span><pre class="console">
File file = File.createTempFile("test", "txt");</pre><pre class="console">
assertThat(tmpFile).isFile();</pre></li>
				<li><strong class="source-inline">canRead()</strong>: Verifies whether the given file is readable by <span class="No-Break">the application:</span><pre class="console">
File file = File.createTempFile("test", "txt");</pre><pre class="console">
assertThat(tmpFile).canRead();</pre></li>
				<li><strong class="source-inline">canWrite()</strong>: Verifies whether the given file is modifiable by <span class="No-Break">the application:</span><pre class="console">
File file = File.createTempFile("test", "txt");</pre><pre class="console">
assertThat(tmpFile).canWrite();</pre></li>
			</ul>
			<p>These are just some <a id="_idIndexMarker664"/>of the assertions available under <strong class="source-inline">AbstractFileAssert</strong>. For the complete documentation, you can go to the link provided <span class="No-Break">here: </span><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html"><span class="No-Break">https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor176"/>Map assertions</h2>
			<p><strong class="bold">Map assertions</strong> are used to <a id="_idIndexMarker665"/>check a map based on its entries, keys, and size. The following are some of the map <span class="No-Break">assertion methods:</span></p>
			<ul>
				<li><strong class="source-inline">contains()</strong>: Verifies whether <a id="_idIndexMarker666"/>the map contains the <span class="No-Break">given entries:</span><pre class="console">
Map&lt;name, Hero&gt; heroes = new HashMap&lt;&gt;();</pre><pre class="console">
Heroes.put(stark, iron_man);</pre><pre class="console">
Heroes.put(rogers, captain_america);</pre><pre class="console">
Heroes.put(parker, spider_man);</pre><pre class="console">
assertThat(heroes).contains(entry(stark, iron_man),</pre><pre class="console">
  entry(rogers, captain_america));</pre></li>
				<li><strong class="source-inline">containsAnyOf()</strong>: Verifies whether the map contains at least one of <span class="No-Break">the entries:</span><pre class="console">
Map&lt;name, Hero&gt; heroes = new HashMap&lt;&gt;();</pre><pre class="console">
Heroes.put(stark, iron_man);</pre><pre class="console">
Heroes.put(rogers, captain_america);</pre><pre class="console">
Heroes.put(parker, spider_man);</pre><pre class="console">
assertThat(heroes).contains(entry(stark, iron_man), entry(odinson, thor));</pre></li>
				<li><strong class="source-inline">hasSize()</strong>: Verifies that the size of the map is equal to the <span class="No-Break">given value:</span><pre class="console">
Map&lt;name, Hero&gt; heroes = new HashMap&lt;&gt;();</pre><pre class="console">
Heroes.put(stark, iron_man);</pre><pre class="console">
Heroes.put(rogers, captain_america);</pre><pre class="console">
Heroes.put(parker, spider_man);</pre><pre class="console">
assertThat(heroes).hasSize(3);</pre></li>
				<li><strong class="source-inline">isEmpty()</strong>: Verifies that the given map <span class="No-Break">is empty:</span><pre class="console">
Map&lt;name, Hero&gt; heroes = new HashMap&lt;&gt;();</pre><pre class="console">
assertThat(heroes).isEmpty();</pre></li>
				<li><strong class="source-inline">isNotEmpty()</strong>: Verifies <a id="_idIndexMarker667"/>that the given map is <span class="No-Break">not empty:</span><pre class="console">
Map&lt;name, Hero&gt; heroes = new HashMap&lt;&gt;();</pre><pre class="console">
Heroes.put(stark, iron_man);</pre><pre class="console">
Heroes.put(rogers, captain_america);</pre><pre class="console">
Heroes.put(parker, spider_man);</pre><pre class="console">
assertThat(heroes).isNotEmpty();</pre></li>
			</ul>
			<p>These are just some <a id="_idIndexMarker668"/>of the assertions available under <strong class="source-inline">AbstractMapAssert</strong>. For the complete documentation, you can go to the link provided <span class="No-Break">here: </span><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html"><span class="No-Break">https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html</span></a><span class="No-Break">.</span></p>
			<p>We have learned about the different assertion methods using AssertJ; now, we will implement and write our unit test in our Spring <span class="No-Break">Boot application.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor177"/>Writing a test</h1>
			<p>In this section, we <a id="_idIndexMarker669"/>will now start writing our unit tests in our <a id="_idIndexMarker670"/>Spring Boot application. As we go back to our application, the <strong class="bold">services</strong> and <strong class="bold">repository</strong> are the essential parts of our application where we need to implement unit tests, as the services contain the business logic and can be modified often, especially when new features are added. The repository includes methods for CRUD and <span class="No-Break">other operations.</span></p>
			<p>We will be implementing two approaches in writing our unit tests. The first method is using an in-memory <a id="_idIndexMarker671"/>database such as H2 to store our created <a id="_idIndexMarker672"/>data when running unit tests. The second method is mocking our objects and repository using the <span class="No-Break">Mockito framework.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor178"/>Testing with the H2 database</h2>
			<p>The first approach that <a id="_idIndexMarker673"/>we will implement in writing our tests is using JUnit and AssertJ with the H2 database. The H2 database is an in-memory database that allows us to store data in the system memory. Once the <a id="_idIndexMarker674"/>application is closed, it will delete all the <a id="_idIndexMarker675"/>stored data. H2 is usually used for <strong class="bold">Proof-of-Concept</strong> or <span class="No-Break">unit testing.</span></p>
			<p>We have already added an H2 database in <a href="B18159_04.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Setting Up the Database and Spring Data JPA</em>, but if you have missed this part, in order for us to add the H2 dependency, we will add the following into our <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file</span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
&lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre>
			<p>After successfully adding the dependency, we will add our <strong class="source-inline">h2</strong> configuration under our <strong class="source-inline">test/java</strong> folder. We will add a new resource bundle and create a new application to accomplish this. A properties file will be used for the unit tests and we will place the <span class="No-Break">following configuration:</span></p>
			<pre class="source-code">
spring.datasource.url=jdbc:h2://mem:testdb;DB_CLOSE_DELAY=-1
spring.datasource.username={username}
spring.datasource.password={password}
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true</pre>
			<p>In the preceding example configuration, first, we have specified that we want to store our data in a <strong class="source-inline">test.mv.db</strong> file using the <strong class="source-inline">spring.datasource.url</strong> property. We can also override the username <a id="_idIndexMarker676"/>and password for our <em class="italic">H2</em> console using the <strong class="source-inline">spring.datasource.username</strong> and <strong class="source-inline">spring.datasource.password</strong> properties, and we have also specified that the tables will be created once the application starts and will be dropped when the <span class="No-Break">application stops.</span></p>
			<h3>Testing a service</h3>
			<p>Now, we will create a <a id="_idIndexMarker677"/>package under our <strong class="source-inline">test/java</strong> folder. This is where we will write our tests. We will create a similar package from our main folder. In this case, we will make <strong class="source-inline">com.example.springbootsuperheroes.superheroes.antiHero.h2.service</strong>. Under the newly created package, we will create a new class named <strong class="source-inline">AntiHeroH2ServiceTest</strong>, where we will start writing our tests <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">AntiHeroService</strong></span><span class="No-Break">.</span></p>
			<p>The first step we need to take is to annotate our class using the <strong class="source-inline">@DataJpaTest</strong> annotation. The annotation allows the service to focus only on the JPA components by disabling the full auto-configuration and just applying the configuration related to the tests. The next step is to add the dependency of our <strong class="source-inline">AntiHeroService</strong>, which is <strong class="source-inline">AntiHeroRepository</strong>. We will declare a new <strong class="source-inline">AntiHeroRepository</strong> and use the <strong class="source-inline">@Autowired</strong> annotation to inject the dependency, and we will also declare <strong class="source-inline">AntiHeroService</strong>, as this is the service that we need to test. We will have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@DataJpaTest
public class AntiHeroH2ServiceTest {
    @Autowired
    private AntiHeroRepository repo;
    private AntiHeroService service;
}</pre>
			<p>After injecting our dependency and annotating our class, the next thing we would want to consider is what the possible properties we want to have before running each of the tests are; in this case, we would like to have an instance of <strong class="source-inline">AntiHeroService</strong> created before running <a id="_idIndexMarker678"/>a test case. To accomplish this, we will make a method annotated with the <strong class="source-inline">@BeforeEach</strong> annotation, and create a new instance of <strong class="source-inline">AntiHeroService</strong> with <strong class="source-inline">AutoWired AntiHeroRepository</strong> as <span class="No-Break">the parameter:</span></p>
			<pre class="source-code">
@BeforeEach
public void setup() {
    service = new AntiHeroService(repo);
}</pre>
			<p>Now, we can write a test case for our service; our goal is to write a test for each method that <span class="No-Break"><strong class="source-inline">AntiHeroService</strong></span><span class="No-Break"> possesses.</span></p>
			<p>Let’s have the list of the methods <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">AntiHeroService</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">Iterable&lt;AntiHeroEntity&gt; findAllAntiHeroes</strong>: Should return the list <span class="No-Break">of anti-heroes.</span></li>
				<li><strong class="source-inline">AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)</strong>: Should add a new <span class="No-Break">anti-hero entity.</span></li>
				<li><strong class="source-inline">void updateAntiHero(UUID id, AntiHeroEntity antiHero)</strong>: Should update the anti-hero based on the <span class="No-Break">given ID.</span></li>
				<li><strong class="source-inline">AntiHeroEntity findAntiHeroById(UUID id)</strong>: Should return the anti-hero with the given ID; if it is not found, it will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">NotFoundException</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">void removeAntiHeroById(UUID id)</strong>: Should remove the anti-hero in the database based on the <span class="No-Break">given ID.</span></li>
			</ul>
			<p>Let’s first write a test for the <strong class="source-inline">findAllAntiHeroes()</strong> method. The possible test case for the method is to check whether the method retrieves all the anti-heroes successfully in the database. To test this <a id="_idIndexMarker679"/>scenario, we would want to add a single entity or a list of test anti-hero entities to our H2 database first. We can call the <strong class="source-inline">findAllAntiHeroes()</strong> method to retrieve the newly added entities in the database. Let’s see the example unit <span class="No-Break">test here:</span></p>
			<pre class="source-code">
@Test
public void shouldFindAllAntiHero() {
    AntiHeroEntity antiHero = new AntiHeroEntity();
    antiHero.setFirstName("Eddie");
    antiHero.setLastName("Brock");
    antiHero.setHouse("MCU");
    service.addAntiHero(antiHero);
    Iterable&lt;AntiHeroEntity&gt; antiHeroList =
      service.findAllAntiHeroes();
    AntiHeroEntity savedAntiHero =
      antiHeroList.iterator().next();
    assertThat(savedAntiHero).isNotNull();
}</pre>
			<p>In the preceding code example, we can see that we have created a new anti-hero instance to be an exemplary piece of data in the database memory first. We have added the data to our database using the <strong class="source-inline">addAntiHero()</strong> method. After successfully inserting the data, we can check or assert whether we can retrieve the newly created anti-hero using the <strong class="source-inline">findAllAntiHeroes()</strong> method. In the scenario here, we have retrieved the first data in our anti-hero list. We used <strong class="source-inline">assertThat(savedAntiHero).isNotNull()</strong> to validate that the first element of the list is <span class="No-Break">not null.</span></p>
			<p>Now, let’s write a test for the <strong class="source-inline">addAntiHero()</strong> method. The test that we will create for the following method is mostly similar to the test that we have created for the <strong class="source-inline">findAllAntiHeroes()</strong> method. The possible test case for the following method is to check whether <a id="_idIndexMarker680"/>the entity is being added to our <span class="No-Break">database successfully.</span></p>
			<p>Let’s have a look at the following example <span class="No-Break">unit test:</span></p>
			<pre class="source-code">
@Test
public void shouldAddAntiHero() {
    AntiHeroEntity antiHero = new AntiHeroEntity();
    antiHero.setFirstName("Eddie");
    antiHero.setLastName("Brock");
    antiHero.setHouse("MCU");
    service.addAntiHero(antiHero);
    Iterable&lt;AntiHeroEntity&gt; antiHeroList =
      service.findAllAntiHeroes();
    AntiHeroEntity savedAntiHero =
      antiHeroList.iterator().next();
    assertThat(antiHero).isEqualTo(savedAntiHero);
}</pre>
			<p>We created a new anti-hero entity in the preceding code example and inserted it into our database using the <strong class="source-inline">addAntiHero()</strong> method. After adding the latest data, we can retrieve the list and validate whether our new data is in the database. In the given scenario, we retrieved the first piece of data in our anti-hero list, and we used <strong class="source-inline">assertThat(antiHero).isEqualTo(savedAntiHero);</strong> to check whether the data we retrieved was equal to the data <span class="No-Break">we instantiated.</span></p>
			<p>Next, let’s now write the test for <strong class="source-inline">updateAntiHeroMethod();</strong>. The possible test case for the following method is to check whether the method successfully modifies a piece of information for a specific entity in <span class="No-Break">our database.</span></p>
			<p>Let’s have a look <a id="_idIndexMarker681"/>at the example unit test that satisfies the test <span class="No-Break">case here:</span></p>
			<pre class="source-code">
@Test
public void shouldUpdateAntiHero() {
    AntiHeroEntity antiHero = new AntiHeroEntity();
    antiHero.setFirstName("Eddie");
    antiHero.setLastName("Brock");
    antiHero.setHouse("MCU");
    AntiHeroEntity savedAntiHero  =
      service.addAntiHero(antiHero);
    savedAntiHero.setHouse("San Francisco");
    service.updateAntiHero(savedAntiHero.getId(),
                           savedAntiHero);
    AntiHeroEntity foundAntiHero =
      service.findAntiHeroById(savedAntiHero.getId());
    assertThat(foundAntiHero.getHouse()).isEqualTo(
      "San Francisco");
}</pre>
			<p>We created a new anti-hero entity in the preceding code example and inserted it into our database using the <strong class="source-inline">addAntiHero()</strong> method. After adding the entity, we updated the added anti-hero’s house information to <strong class="source-inline">"San Francisco"</strong> and saved it in our database using <strong class="source-inline">updateAntiHeroMethod()</strong>. Lastly, we have retrieved the modified anti-hero using its ID and validated that the house information was modified by adding the <strong class="source-inline">assertThat(foundAntiHero.getHouse()).isEqualTo("San </strong><span class="No-Break"><strong class="source-inline">Francisco");</strong></span><span class="No-Break"> assertion.</span></p>
			<p>Next, we would now create a unit test for the <strong class="source-inline">removeAntiHeroById()</strong> method. The possible test <a id="_idIndexMarker682"/>case for the method is to validate whether an entity with a corresponding ID has successfully been deleted from <span class="No-Break">the database.</span></p>
			<p>Let’s have a look at the example unit test that satisfies the <span class="No-Break">test case:</span></p>
			<pre class="source-code">
@Test
public void shouldDeleteAntiHero() {
    assertThrows(NotFoundException.class, new Executable() {
        @Override
        public void execute() throws Throwable {
            AntiHeroEntity savedAntiHero  =
              service.addAntiHero(antiHero);
            service.removeAntiHeroById(
              savedAntiHero.getId());
            AntiHeroEntity foundAntiHero =
              service.findAntiHeroById(
                savedAntiHero.getId());
            assertThat(foundAntiHero).isNull();
        }
    });
}</pre>
			<p>In the preceding example, we can see that we have added some additional elements in writing our unit test; we have created a new instance of <strong class="source-inline">Executable()</strong>, where we have placed our main code. We have asserted our <strong class="source-inline">Executable()</strong> with <strong class="source-inline">NotFoundException.class</strong>. The main reason for this is that we expect that <strong class="source-inline">findAntiHeroByID()</strong> will return the <strong class="source-inline">NotFoundException</strong> error, as we have deleted the entity in <span class="No-Break">our database.</span></p>
			<p>Remember that <a id="_idIndexMarker683"/>when asserting errors, we should <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">assertThrows()</strong></span><span class="No-Break">.</span></p>
			<p>We have successfully written a test for our services and now, we will implement unit tests at the <span class="No-Break">repository level.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor179"/>Testing a repository</h2>
			<p>Writing a test for the repository of our application is mostly the same as how we write our tests at the service <a id="_idIndexMarker684"/>level; we also treat them as services and we test them if there are additional methods added to <span class="No-Break">the repository.</span></p>
			<p>The example that we will take is writing a unit test for our <strong class="source-inline">UserRepository</strong>. Let’s have a recap of the methods that <span class="No-Break"><strong class="source-inline">UserRepository</strong></span><span class="No-Break"> possesses:</span></p>
			<ul>
				<li><strong class="source-inline">Boolean selectExistsEmail(String email)</strong>: Returns <strong class="source-inline">true</strong> when the user exists with the <span class="No-Break">given email</span></li>
				<li><strong class="source-inline">UserEntity findByEmail(String email)</strong>: Returns the user when the given email exists in <span class="No-Break">the database</span></li>
			</ul>
			<p>To start writing our test, first, we will create a new package named <strong class="source-inline">user.repository</strong> under the <strong class="source-inline">com.example.springbootsuperheroes.superheroes</strong> package, and we will make a new class called <strong class="source-inline">UserRepositoryTest</strong>. After successfully creating the repository, we will annotate the class with <strong class="source-inline">@DataJPATest</strong> so that it focuses only on the JPA components and inject <strong class="source-inline">AntiHeroRepostiory</strong> using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Autowired</strong></span><span class="No-Break"> annotation.</span></p>
			<p>Our class will now look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@DataJpaTest
class UserRepositoryTest {
    @Autowired
    private UserRepository underTest;
}</pre>
			<p>Now, we can write <a id="_idIndexMarker685"/>our tests after successfully injecting the repository. First, we want to write a test for the <strong class="source-inline">selectExistsEmail()</strong> method. The possible test case for the method is that it should return <strong class="source-inline">true</strong> if the email exists in <span class="No-Break">our database.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">example code:</span></p>
			<pre class="source-code">
@Test
void itShouldCheckWhenUserEmailExists() {
    // give
    String email = "seiji@gmail.com";
    UserEntity user = new UserEntity(email, "21398732478");
    underTest.save(user);
    // when
    boolean expected = underTest.selectExistsEmail(email);
    // then
    assertThat(expected).isTrue();
}</pre>
			<p>We have added an example user entity into our database in the example unit test. The <strong class="source-inline">selectExistsEmail()</strong> method is expected to return <strong class="source-inline">true</strong>. This should retrieve the added user with the <span class="No-Break">given email.</span></p>
			<p>The next test is for the <strong class="source-inline">findByEmail()</strong> method; this is almost similar to the test we have created for the <strong class="source-inline">selectExistsEmail()</strong> method. The only thing we need to modify is the <a id="_idIndexMarker686"/>assertion, as we are expecting a return value of the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> type.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">example code:</span></p>
			<pre class="source-code">
@Test
void itShouldFindUserWhenEmailExists() {
    // give
    String email = "dennis@gmail.com";
    UserEntity user = new UserEntity(email, "21398732478");
    underTest.save(user);
    // when
    UserEntity expected = underTest.findByEmail(email);
    // then
    assertThat(expected).isEqualTo(user);
}</pre>
			<p>We have successfully written a test for our services and repository with JUnit, AssertJ, and the H2 database. In the <a id="_idIndexMarker687"/>next section, we will use the second implementation on writing unit tests using JUnit and AssertJ <span class="No-Break">with Mockito.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor180"/>Writing tests in a service using Mockito</h1>
			<p>In the previous section, we created our unit tests using the H2 database; in this approach, we will <a id="_idIndexMarker688"/>completely omit the use of the database <a id="_idIndexMarker689"/>and utilize the concept of mocking in creating sample data in our unit tests. We will achieve this by using <strong class="bold">Mockito</strong>. Mockito is a mocking <a id="_idIndexMarker690"/>framework in Java that allows us to test classes in isolation; it does not require <span class="No-Break">any databases.</span></p>
			<p>It will enable us to return dummy data from a mocked object or service. Mockito is very useful, as this makes unit testing less complex, especially for larger applications, as we don’t want to test the services and dependencies simultaneously. The following are the other benefits of <span class="No-Break">using Mockito:</span></p>
			<ul>
				<li><strong class="bold">Supports return values</strong>: Supports mocking <span class="No-Break">return values.</span></li>
				<li><strong class="bold">Supports exceptions</strong>: Can handle <a id="_idIndexMarker691"/>exceptions in <span class="No-Break">unit tests.</span></li>
				<li><strong class="bold">Supports annotation</strong>: Can create mocks <span class="No-Break">using annotation.</span></li>
				<li><strong class="bold">Safe from refactoring</strong>: Renaming method names or changing the order of parameters will not affect the tests, as mocks are created <span class="No-Break">at runtime.</span></li>
			</ul>
			<p>Let’s explore the different features of Mockito for writing <span class="No-Break">unit tests.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor181"/>Adding behavior</h2>
			<p>Mockito contains <a id="_idIndexMarker692"/>the <strong class="source-inline">when()</strong> method where we can mock the object return value. This is one of the most valuable features of Mockito, as we can define a dummy return value of a service or <span class="No-Break">a repository.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
public class HeroTester {
   // injects the created Mock
   @InjectMocks
   HeroApp heroApp = new HeroApp();
   // Creates the mock
   @Mock
   HeroService heroService;
   @Test
   public void getHeroHouseTest(){
      when(heroService.getHouse())).thenReturn(
        "San Francisco ");
   assertThat(heroApp.getHouse()).isEqualTo(
     "San Francisco");
 }
}</pre>
			<p>In the preceding code example, we can see that we have mocked <strong class="source-inline">HeroService</strong> in our test. We have done this <a id="_idIndexMarker693"/>to isolate the class and not test the functionality of <strong class="source-inline">Heroservice</strong> itself; what we want to test is just the functionality of <strong class="source-inline">HeroApp</strong>. We have added behavior for the <strong class="source-inline">heroService.getHouse()</strong> method by specifying a mock return <strong class="source-inline">thenReturn()</strong> method. In this case, we expect that the <strong class="source-inline">getHouse()</strong> method will return a value of <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">San Francisco"</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor182"/>Verifying behavior</h2>
			<p>The next feature that <a id="_idIndexMarker694"/>we can use from Mockito is behavior verification in unit tests. This allows us to verify whether the mocked method is called and executed with parameters. This can be achieved using the <span class="No-Break"><strong class="source-inline">verify()</strong></span><span class="No-Break"> method.</span></p>
			<p>Let’s take the same <span class="No-Break">class example:</span></p>
			<pre class="source-code">
public class HeroTester {
   // injects the created Mock
   @InjectMocks
   HeroApp heroApp = new HeroApp();
   // Creates the mock
   @Mock
   HeroService heroService;
   @Test
   public void getHeroHouseTest(){
      when(heroService.getHouse())).thenReturn(
        "San Francisco ");
   assertThat(heroApp.getHouse()).isEqualTo(
     "San Francisco");
   verify(heroService).getHouse();
 }
}</pre>
			<p>In the preceding <a id="_idIndexMarker695"/>code example, we can see that we have added <strong class="source-inline">verify(heroService).getHouse()</strong> to our code. This validates whether we have called the <strong class="source-inline">getHouse()</strong> method. We can also validate whether the method is called with some <span class="No-Break">given parameters.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor183"/>Expecting calls</h2>
			<p><strong class="bold">Expecting calls</strong> is an <a id="_idIndexMarker696"/>extended feature for behavior verification; we can also check the number of times that the mocked method has been called. We can do so by using the <strong class="source-inline">times(n)</strong> method. At the same time, we can also validate whether it has been called using the <strong class="source-inline">never()</strong> method. </p>
			<p>Let’s have a look at the following <span class="No-Break">example code:</span></p>
			<pre class="source-code">
public class HeroTester {
   // injects the created Mock
   @InjectMocks
   HeroApp heroApp = new HeroApp();
   // Creates the mock
   @Mock
   HeroService heroService;
   @Test
   public void getHeroHouseTest(){
     // gets the values of the house
     when(heroService.getHouse())).thenReturn(
       "San Francisco ");
    // gets the value of the name
    when(heroService.getName())).thenReturn("Stark");
   // called one time
   assertThat(heroApp.getHouse()).isEqualTo(
     "San Francisco");
   // called two times
   assertThat(heroApp.getName()).isEqualTo("Stark");
   assertThat(heroApp.getName()).isEqualTo("Stark");
   verify(heroService, never()).getPowers();
   verify(heroService, times(2)).getName();
 }
}</pre>
			<p>In the preceding <a id="_idIndexMarker697"/>code example, we can see that we have used the <strong class="source-inline">times(2)</strong> method to validate whether the <strong class="source-inline">getName()</strong> method from <strong class="source-inline">heroService</strong> has been called two times. We have also used the <strong class="source-inline">never()</strong> method, which checks that the <strong class="source-inline">getPowers()</strong> method has not <span class="No-Break">been called.</span></p>
			<p>Mockito, other <a id="_idIndexMarker698"/>than <strong class="source-inline">times()</strong> and <strong class="source-inline">never()</strong>, also provides additional methods to validate the expected call counts, and these methods are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">atLeast (int min)</strong>: Validates whether the method is called at least <span class="No-Break"><em class="italic">n</em></span><span class="No-Break"> times</span></li>
				<li><strong class="source-inline">atLeastOnce ()</strong>: Validates whether the method is called at <span class="No-Break">least once</span></li>
				<li><strong class="source-inline">atMost (int max)</strong>: Validates whether the method is called at most <span class="No-Break"><em class="italic">n</em></span><span class="No-Break"> times</span></li>
			</ul>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor184"/>Exception handling</h2>
			<p>Mockito also <a id="_idIndexMarker699"/>provides exception handling in unit tests; it allows us to throw exceptions on mocks to test errors in <span class="No-Break">our application.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">example code:</span></p>
			<pre class="source-code">
public class HeroTester {
   // injects the created Mock
   @InjectMocks
   HeroApp heroApp = new HeroApp();
   // Creates the mock
   @Mock
   HeroService heroService;
   @Test
   public void getHeroHouseTest(){
   doThrow(new RuntimeException("Add operation not
           implemented")).when(heroService.getHouse()))
   .thenReturn("San Francisco ")
  assertThat(heroApp.getHouse()).isEqualTo(
    "San Francisco");
 }
}</pre>
			<p>In the preceding <a id="_idIndexMarker700"/>example, we have configured <strong class="source-inline">heroService.getHouse()</strong>, once it is called, to throw <strong class="source-inline">RunTimeException</strong>. This will allows us to test and cover the error blocks in <span class="No-Break">our application.</span></p>
			<p>We have learned about the different features available in Mockito. Now, let’s proceed with writing our tests in our Spring <span class="No-Break">Boot application.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor185"/>Mockito in Spring Boot</h2>
			<p>In this section, we <a id="_idIndexMarker701"/>will now implement Mockito for writing unit tests in our Spring Boot application. We will be <a id="_idIndexMarker702"/>writing tests for our service again, and we will create another package under our <strong class="source-inline">test/java</strong> folder, which will be used for our unit tests using Mockito; we will make <strong class="source-inline">com.example.springbootsuperheroes.superheroes.antiHero.service</strong>. Under the newly created package, we will create a new class named <strong class="source-inline">AntiHeroServiceTest</strong>, where we will start writing our tests <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">AntiHeroService</strong></span><span class="No-Break">.</span></p>
			<p>After successfully creating our class, we will need to annotate the class with <strong class="source-inline">@ExtendWith(MockitoExtension.class)</strong> to be able to use the Mockito methods and features. The next step is to mock our <strong class="source-inline">AntiHeroRepository</strong> and inject it into our <strong class="source-inline">AntiHeroRepositoryService</strong>. To accomplish this, we would use the <strong class="source-inline">@Mock</strong> annotation with the declared repository and the <strong class="source-inline">@InjectMocks</strong> annotation with the declared service, and our class would now look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@ExtendWith(MockitoExtension.class)
class AntiHeroServiceTest {
    @Mock
    private AntiHeroRepository antiHeroRepository;
    @InjectMocks
    private AntiHeroService underTest;
}</pre>
			<p>In the preceding example, we successfully mocked our repository and injected it into our service. We can now start mocking our repository’s return values and behavior in <span class="No-Break">our tests.</span></p>
			<p>Let’s have some example tests in our <strong class="source-inline">AntiHeroService</strong>; in an example scenario, we will write <a id="_idIndexMarker703"/>a test for <a id="_idIndexMarker704"/>the <strong class="source-inline">addAntiHero()</strong> method. The possible test case for this one is to verify whether the <strong class="source-inline">save()</strong> method from the repository is called and the anti-hero is <span class="No-Break">successfully added.</span></p>
			<p>Let’s have a look at the example <span class="No-Break">code here:</span></p>
			<pre class="source-code">
@Test
void canAddAntiHero() {
    // given
    AntiHeroEntity antiHero = new AntiHeroEntity(
            UUID.randomUUID(),
            "Venom",
            "Lakandula",
            "Tondo",
            "Datu of Tondo",
            new SimpleDateFormat(
              "dd-MM-yyyy HH:mm:ss z").format(new Date())
    );
    // when
    underTest.addAntiHero(antiHero);
    // then
    ArgumentCaptor&lt;AntiHeroEntity&gt;
    antiHeroDtoArgumentCaptor =
      ArgumentCaptor.forClass(
            AntiHeroEntity.class
    );
    verify(antiHeroRepository).save(
      antiHeroDtoArgumentCaptor.capture());
    AntiHeroEntity capturedAntiHero =
      antiHeroDtoArgumentCaptor.getValue();
    assertThat(capturedAntiHero).isEqualTo(antiHero);
}</pre>
			<p>In the preceding example, the first step is always to create a sample entity that we can use as a <a id="_idIndexMarker705"/>parameter for <a id="_idIndexMarker706"/>adding a new anti-hero; after invoking the <strong class="source-inline">addAntiHero()</strong> method that we are testing, we have verified whether the <strong class="source-inline">save()</strong> method of <strong class="source-inline">AntiHeroRepository</strong> has been invoked using the <span class="No-Break"><strong class="source-inline">verify()</strong></span><span class="No-Break"> method.</span></p>
			<p>We have also used <strong class="source-inline">ArgumentCaptor</strong> to capture the argument values we have used in the previous way, which will be used for further assertions. In this case, we have asserted that the captured anti-hero is equal to the anti-hero instance we <span class="No-Break">have created.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor186"/>Summary</h1>
			<p>With this, we have reached the end of this chapter. Let’s have a recap of the valuable things you have learned; you have learned about the concepts of JUnit, which is a testing framework that offers features such as fixtures, test suites, and classes to test the methods in our application. You have also learned about the application of AssertJ with JUnit, which provides a more flexible way of asserting objects in our unit tests; and lastly, you have also learned about the importance of Mockito, which provides us with the ability to mock objects <span class="No-Break">and services.</span></p>
			<p>In the next chapter, we will now develop our frontend application using Angular. We will discuss how to organize our features and modules, structure our components inside our Angular file structure, and add Angular Material to the <span class="No-Break">user interface.</span></p>
		</div>
	

		<div class="Content" id="_idContainer069">
			<h1 id="_idParaDest-177"><a id="_idTextAnchor187"/>Part 3: Frontend Development</h1>
			<p>This part contains a real-world scenario of developing an Angular 13 application. The following chapters are covered in <span class="No-Break">this part:</span></p>
			<ul>
				<li><a href="B18159_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Setting Up Our Angular Project and Architecture</em></li>
				<li><a href="B18159_11.xhtml#_idTextAnchor203"><em class="italic">Chapter 11</em></a>, <em class="italic">Building Reactive Forms</em></li>
				<li><a href="B18159_12.xhtml#_idTextAnchor224"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing States with NgRx</em></li>
				<li><a href="B18159_13.xhtml#_idTextAnchor253"><em class="italic">Chapter 13</em></a>, <em class="italic">Saving, Deleting, and Updating with NgRx</em></li>
				<li><a href="B18159_14.xhtml#_idTextAnchor275"><em class="italic">Chapter 14</em></a>, <em class="italic">Adding Authentication in Angular</em></li>
				<li><a href="B18159_15.xhtml#_idTextAnchor293"><em class="italic">Chapter 15</em></a>, <em class="italic">Writing Tests in Angular</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer070">
			</div>
		</div>
		<div>
			<div id="_idContainer071">
			</div>
		</div>
	</body></html>