- en: 3\. Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 面向对象编程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will consider the way in which Java implements **object-oriented
    programming** (**OOP**) concepts. For these purposes, you will first practice
    creating and instantiating your own classes so that you can later create methods
    that can handle data within them. We will then take you through how to code recursive
    methods, and even how to override existing methods in favor of your own. By the
    end of the chapter, you will be fully equipped to overload the definition of methods
    in order to accommodate different scenarios with different parameters to the same
    method or constructor, and annotate code to inform the compiler about specific
    actions that must be taken.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Java实现面向对象编程（**OOP**）概念的方式。为此，你将首先练习创建和实例化自己的类，以便你可以在以后创建可以处理其中数据的方法。然后我们将带你了解如何编写递归方法，甚至如何覆盖现有方法以使用你自己的方法。到本章结束时，你将完全准备好重载方法的定义，以适应不同场景，并为同一方法或构造函数提供不同的参数，并注释代码以告知编译器必须采取的特定操作。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A Java class is a template that is used to define data types. Classes are composed
    of objects carrying data and methods that are used to perform operations on that
    data. Classes can be self-contained, extend other classes with new functionalities,
    or implement features from other classes. In a way, classes are categories that
    allow us to define what kind of data can be stored within them, as well as the
    ways in which that data can be handled.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java类是一个模板，用于定义数据类型。类由携带数据和用于在该数据上执行操作的方法的对象组成。类可以是自包含的，可以扩展其他类以添加新功能，或实现其他类的功能。从某种意义上说，类是类别，允许我们定义可以存储在其中的数据类型，以及处理这些数据的方式。
- en: Classes tell the compiler how to build a certain object during runtime. Refer
    to the explanation of what objects are in the *Working with Objects in Java* topic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类在运行时告诉编译器如何构建特定的对象。请参考“Java中处理对象”主题中关于对象解释的内容。
- en: 'The basic structure of a class definition looks like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的基本结构如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Class names should start with a capital letter, as in `TheClass`, `Animal`,
    `WordCount`, or any other string that somehow expresses the main purpose of the
    class. If contained in a separate file, the filename containing the source should
    be named like the class: `TheClass.java`, `Animal.java`, and so on.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类名应该以大写字母开头，例如`TheClass`、`Animal`、`WordCount`或任何以某种方式表达类主要目的的字符串。如果包含在单独的文件中，包含源代码的文件名应与类名相同：`TheClass.java`、`Animal.java`等。
- en: The Anatomy of a Class
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类的解剖结构
- en: There are different software components in classes. The following example shows
    a class that includes some of the main ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类中包含不同的软件组件。以下示例展示了一个包含一些主要组件的类。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The outcome of this example is:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的输出结果为：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code listing shows the definition of a basic class called `Computer`,
    which includes variables and methods to deal with one of the properties of the
    class computer – in this case, `cpuSpeed`. The code shows two different classes.
    The first one is the blueprint for how to define objects of the `Computer` type
    in your programs. The second one, `Example01`, is the one that will be executed
    after compilation and will make an instance of the `Computer` class in the form
    of an object called `myPC`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码列表展示了名为`Computer`的基本类的定义，该类包括处理类`Computer`的一个属性（在这种情况下，`cpuSpeed`）的变量和方法。代码展示了两个不同的类。第一个是定义程序中`Computer`类型对象的蓝图。第二个，`Example01`，是在编译后执行的一个，它将创建一个名为`myPC`的`Computer`类的实例。
- en: 'There is one more component inside the class, the constructor, which is optional,
    as Java includes a default constructor for all your classes. `cpuSpeed` variable
    with a value of `0`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类中还有一个可选的组件，即构造函数，因为Java为所有类提供了一个默认构造函数。`cpuSpeed`变量具有`0`的值：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is also possible for constructors to have parameters. You could have the
    constructor of the class be this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数也可以有参数。类的构造函数可以是这样的：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this way, you could call the constructor with:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以使用以下方式调用构造函数：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That would also require a parameter. In addition, classes can have more than
    one constructor. This will be explained later in the chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会需要一个参数。此外，类可以有多个构造函数。这一点将在本章后面进行解释。
- en: Working with Objects in Java
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中处理对象
- en: 'Objects are to classes what variables are to data types. While classes define
    the structure and possible actions of a certain data type, objects are actual
    usable parts of the computer memory containing that data. The action of creating
    an object is known as making an instance of a class. In a sense, it is like making
    a copy of the template and then modifying it by accessing its variables or methods.
    Let''s see this in action:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对象对于类，就像变量对于数据类型一样。虽然类定义了某种数据类型的结构和可能的行为，但对象是包含该数据的计算机内存中的实际可使用部分。创建对象的动作被称为创建类的实例。从某种意义上说，就像制作一个模板的副本，然后通过访问其变量或方法来修改它。让我们看看它是如何工作的：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`myPC` is the actual object. We would say that `myPC` is an object of the `class
    Computer` in colloquial terms.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`myPC` 是实际的对象。我们可以说，在口语中，`myPC` 是 `class Computer` 类的对象。'
- en: 'The different fields and methods inside the class can be accessed by typing
    the name of the object followed by a period and the name of the variable or method
    you want to address. Making any changes to the variables or calling the methods
    will take effect only within the scope of that object. If you had more objects
    of the same class in your program, each one of them would have a piece of memory
    of its own. An example of how to address a method is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类内的不同字段和方法可以通过输入对象名称后跟一个点号和要处理的变量或方法名称来访问。对变量或方法的任何更改或调用都只在该对象的范围内生效。如果你在程序中有相同类的更多对象，每个对象都会有自己的内存部分。以下是如何调用方法的示例：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An example of how to address a variable, on the other hand, would be the following
    assignment:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如何调用变量的示例如下所示：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because of the way the `Computer` class has been defined, the last two code
    listings have the exact same effect. The whole class has been defined—by default—as
    `public`, which means that all the methods, variables, and objects from the class
    are available to be called with the mechanism described previously. It could be
    necessary to prevent users from directly interacting with the variables within
    the class and only allow their modification through certain methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Computer` 类的定义方式，最后两个代码示例具有完全相同的效果。整个类默认定义为 `public`，这意味着类中的所有方法、变量和对象都可以通过之前描述的机制被调用。可能有必要防止用户直接与类内的变量交互，并且只允许通过某些方法进行修改。
- en: 'The different components within a class can be defined as `public` or `private`.
    The former will make the component available to be used as shown so far, while
    the latter will hinder the ability of other developers to access that part. The
    following example shows how to make the `cpuSpeed` variable `private`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类内的不同组件可以定义为 `public` 或 `private`。前者将使组件可用，如之前所示，而后者将阻碍其他开发人员访问该部分。以下示例显示了如何将
    `cpuSpeed` 变量定义为 `private`：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of this code listing is the same as before:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码列表的结果与之前相同：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you tried to access the `cpuSpeed` variable directly from the `Example02`
    class, the program would throw an exception. The following example shows such
    a case. Try it out to see how the debugger informs you when you try to access
    a `private` variable:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试从 `Example02` 类直接访问 `cpuSpeed` 变量，程序将抛出异常。以下示例显示了这种情况。试一试，看看当尝试访问 `private`
    变量时，调试器是如何通知你的：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of this program is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的结果是：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What the compiler shows is an error in the `Computer` class, which has been
    derived from `java.lang`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器显示的错误是在从 `java.lang` 继承的 `Computer` 类中
- en: Checking the Precedence of a Class with instanceof
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `instanceof` 检查类的优先级
- en: 'You can check whether an object is an instance of a specific class. This can
    be convenient for things such as error checking, handling data in different ways
    depending on its precedence, and more. The following example shows the `checkNumber`
    method, which can discriminate between different types of variables and will print
    different messages based on that:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查一个对象是否是特定类的实例。这可以方便地进行错误检查，根据其优先级以不同的方式处理数据，等等。以下示例显示了 `checkNumber` 方法，它可以区分不同类型的变量，并据此打印不同的消息：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The outcome of the previous example is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例的结果是：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Exercise 1: Creating the WordTool Class'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：创建 WordTool 类
- en: '`WordTool` is a class that will help you to perform a series of operations
    on a piece of text, including counting the number of words, looking at the frequency
    of letters, and searching for the occurrence of a specific string:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`WordTool`是一个类，可以帮助您对一段文本执行一系列操作，包括计算单词数量、查看字母频率以及搜索特定字符串的出现：'
- en: 'Open IntelliJ and click on the `File` | `New` | `Project` menu options:![Figure
    3.1: Creating a new project'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IntelliJ并单击`文件`|`新建`|`项目`菜单选项：![图3.1：创建新项目
- en: '](img/C13927_03_01.jpg)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片C13927_03_01.jpg](img/C13927_03_01.jpg)'
- en: 'Figure 3.1: Creating a new project'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.1：创建新项目
- en: 'A new interface unfolds. The default options are meant for creating a Java
    program. You just need to click `Next`:![Figure 3.2: The New Project dialog box'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开一个新的界面。默认选项是用于创建Java程序。您只需点击`下一步`：![图3.2：新建项目对话框
- en: '](img/C13927_03_02.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片C13927_03_02.jpg](img/C13927_03_02.jpg)'
- en: 'Figure 3.2: The New Project dialog box'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.2：新建项目对话框
- en: 'Check the box to create the project from a template. Select the template for
    the `Command Line App`. Click `Next`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开复选框以从模板创建项目。选择`命令行应用程序`模板。点击`下一步`：
- en: '![Figure 3.3: Creating a project from template'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3：从模板创建项目'
- en: '](img/C13927_03_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片C13927_03_03.jpg](img/C13927_03_03.jpg)'
- en: 'Figure 3.3: Creating a project from template'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：从模板创建项目
- en: 'Name the project `WordTool`. Click `Finish`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目命名为`WordTool`。点击`完成`：
- en: '![Figure 3.4: Adding the Project name'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4：添加项目名称'
- en: '](img/C13927_03_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片C13927_03_04.jpg](img/C13927_03_04.jpg)'
- en: 'Figure 3.4: Adding the Project name'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：添加项目名称
- en: 'By default, the template calls your basic class `Main`. Let''s change that
    to `WordTool`. First, navigate within the new project to the `Main.java` file;
    it is displayed as the `main` entry in the list:![Figure 3.5: A template Java
    program'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，模板调用您的基类`Main`。让我们将其更改为`WordTool`。首先，在新项目中导航到`Main.java`文件；它在列表中显示为`main`入口：![图3.5：模板Java程序
- en: '](img/C13927_03_05.jpg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片C13927_03_05.jpg](img/C13927_03_05.jpg)'
- en: 'Figure 3.5: A template Java program'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.5：模板Java程序
- en: 'Right-click on the `Main` entry and, in the drop-down list, select the `Refactor`
    option. Within that, select `Rename…`:![Figure 3.6: Refactoring the Java class'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Main`条目，在下拉列表中，选择`重构`选项。在其中，选择`重命名...`：![图3.6：重构Java类
- en: '](img/C13927_03_06.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片C13927_03_06.jpg](img/C13927_03_06.jpg)'
- en: 'Figure 3.6: Refactoring the Java class'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.6：重构Java类
- en: 'A dialog window pops up. Write in it the name of the class, `WordTool`. The
    checkboxes allow you to choose which parts of the code will be refactored to fit
    the new name of the class:![Figure 3.7: Renaming the class in IntelliJ'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出一个对话框。在其中写入类的名称，`WordTool`。复选框允许您选择哪些代码部分将被重构以适应新类的名称：![图3.7：在IntelliJ中重命名类
- en: '](img/C13927_03_07.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片C13927_03_07.jpg](img/C13927_03_07.jpg)'
- en: 'Figure 3.7: Renaming the class in IntelliJ'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.7：在IntelliJ中重命名类
- en: 'You will see that the class is now called `WordTool` and the file is `WordTool.java`:![Figure
    3.8: WordTool'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会看到类现在被命名为`WordTool`，文件名为`WordTool.java`：![图3.8：WordTool
- en: '](img/C13927_03_08.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片C13927_03_08.jpg](img/C13927_03_08.jpg)'
- en: 'Figure 3.8: WordTool'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.8：WordTool
- en: 'Create the constructor for the class; it will be empty, in this case:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为类创建构造函数；在这种情况下，它将是空的：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a method to count the number of words in a string:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来计算字符串中的单词数量：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a method to count the number of letters in a string, and add the ability
    to count both with and without whitespace characters:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来计算字符串中的字母数量，并添加带空格和不带空格字符的计数能力：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `main` class, create an object of the `WordTool` class and add a `String`
    variable containing some text of your choice:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`类中，创建一个`WordTool`类的对象，并添加一个包含您选择的文本的`String`变量：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add code inside the main method to print out the calculations made by `WordTool`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中添加代码以打印出`WordTool`执行的计算：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the program; the outcome should be as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序；结果应该如下所示：
- en: '[PRE20]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can use the trick presented in this exercise to create classes for all the
    examples in this book, just by using the template and refactoring them to have
    the example name. After that, you will just need to copy the code in a fresh project.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用本练习中介绍的方法，通过使用模板并对它们进行重构以具有示例名称，来创建本书中所有示例的类。之后，您只需将代码复制到新的项目中。
- en: 'Activity 1: Adding the Frequency-of-Symbol Calculation to WordTool'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：将符号频率计算添加到WordTool
- en: 'Add a method to the previously created `WordTool` class to calculate the frequency
    of a certain symbol. To do so, perform the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 向之前创建的`WordTool`类中添加一个方法来计算特定符号的频率。为此，执行以下步骤：
- en: Add a method to count the number of words in a string.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来计算字符串中的单词数量。
- en: Add a method to count the number of letters in a string, and add the possibility
    of separating the case of having whitespaces or not.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来计算字符串中的字母数量，并添加区分是否有空格的情况。
- en: In the `main` class, create an object of the `WordTool` class and add a string
    variable containing a line of text of your choice.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`类中，创建一个`WordTool`类的对象，并添加一个包含你选择的文本行的字符串变量。
- en: Add code inside the main method to print out the calculations made by WordTool.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主方法中添加代码以打印出WordTool所做的计算。
- en: 'The expected outcome of this activity is as follows:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的预期结果如下：
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 534.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第534页找到。
- en: Inheritance in Java
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的继承
- en: Inheritance is a key principle of object-oriented programming. It entails the
    transfer of the existing structure of one class, including its constructor, variables,
    and methods, to a different class. The new class is called the child class (or
    subclass), while the one it's inheriting from is called the parent class (or superclass).
    We say that the child class extends the parent one. The child class is said to
    extend the parent class in the sense that it not only inherits whatever structures
    are defined by the parent, but it also creates new structures. The following example
    shows a parent class and how the child class extends it by adding a new method
    to it. We will take the `Computer` class we defined earlier as a parent and create
    a new class called `Tablet`, which is a type of computer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的一个关键原则。它涉及将一个类的现有结构，包括其构造函数、变量和方法，转移到另一个类。新的类被称为子类（或子类），而它所继承的那个类被称为父类（或超类）。我们说子类扩展了父类。子类扩展父类的意思是，它不仅继承了父类定义的结构，而且还创建了新的结构。以下是一个父类示例以及子类如何通过向其添加新方法来扩展它。我们将使用我们之前定义的`Computer`类作为父类，并创建一个新的类`Tablet`，它是一种计算机。
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how the definition of the `Tablet` class does not include any methods
    called `setCpuSpeed()` or `getCpuSpeed()`; however, when calling them, not only
    does the program not give any errors, but the commands are also successfully launched.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Tablet`类的定义中不包含任何名为`setCpuSpeed()`或`getCpuSpeed()`的方法；然而，当调用它们时，程序不仅不会给出任何错误，而且命令也成功执行。
- en: This is because the definition of the `Tablet` class extends the `Computer`
    class, thus inheriting all its internal objects, variables, and methods. When
    creating an object of the `Tablet` class, such as `myTab`, the JVM reserves space
    in memory for a `cpuSpeed` variable and the setter and getter methods that go
    with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Tablet`类的定义扩展了`Computer`类，从而继承了其所有内部对象、变量和方法。当创建`Tablet`类的一个对象，例如`myTab`时，JVM在内存中为`cpuSpeed`变量及其相应的setter和getter方法预留空间。
- en: Overriding and Hiding Methods
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写和隐藏方法
- en: When extending a class, it is possible to redefine some of the methods that
    are part of it. Overriding means to rewrite something's functionality. This is
    done by making a new declaration of the method with the same name and properties
    of the method from the original class. This is demonstrated in the following example.
    Note that we're continuing, for the sake of clarity, with `Computer` and `Tablet`,
    but they have been cleaned up so as not to make the example programs too long.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展一个类时，可以重新定义其中的一些方法。重写意味着重写某个功能。这是通过创建一个新的具有相同名称和原始类方法属性的方法声明来完成的。以下是一个示例。请注意，为了清晰起见，我们继续使用`Computer`和`Tablet`，但它们已经被简化，以免使示例程序太长。
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since `Tablet` extends `Computer`, you could modify the main class in the program
    to be as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Tablet`类扩展了`Computer`类，你可以将程序中的主类修改如下：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Technically, tablets are computers, which means that you can create an object
    of the `Tablet` class by defining it as `Computer` in the first place. The result
    for both cases will be the same:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，平板电脑是计算机，这意味着你可以首先将其定义为`Computer`，然后创建`Tablet`类的一个对象。这两种情况的结果将是相同的：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The result is the same for both classes because both the child and parent classes
    include a non-static method called `whatIsIt()`. When calling the method, the
    overriding one will have priority. This is done by the JVM at runtime. This principle
    is what we call runtime polymorphism. There can be multiple definitions of the
    same method, and which definition will be executed is decided during the execution
    of the program.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子类和父类都包含一个名为 `whatIsIt()` 的非静态方法，所以这两个类的结果是相同的。当调用方法时，覆盖的方法将具有优先权。这是由JVM在运行时完成的。这个原则就是我们所说的运行时多态。同一个方法可以有多个定义，而哪个定义将被执行是在程序执行过程中决定的。
- en: But what would happen if the method you called was static? This could be a design
    decision taken by the developer who is creating the class you are extending and
    therefore is a situation out of your control. In this case, it is not possible
    to override the method. The child class can, however, hide the method defined
    by the parent using the same mechanism. The next code listing demonstrates this.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你调用的是静态方法会怎样呢？这可能是由创建你扩展的类的开发者做出的设计决策，因此这是一个你无法控制的情况。在这种情况下，无法覆盖该方法。然而，子类可以使用相同的机制隐藏父类定义的方法。接下来的代码示例演示了这一点。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The outcome of this example is:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果是：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The decision of what method should be used with static methods is not taken
    at runtime but during compilation, and this ensures that the method from the parent
    class is the one being called. This action is called `Tablet` class. To do so,
    you should modify the code in the `main` class to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法应该使用哪个方法的决定不是在运行时，而是在编译时做出的，这确保了被调用的是父类的方法。这个动作被称为 `Tablet` 类。要做到这一点，你应该将
    `main` 类中的代码修改如下：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note how we clearly specify the actual class you call for this. The result
    of the modified example is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何清楚地指定你实际调用的类。修改后的示例结果是：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Avoiding Overriding: Final Classes and Methods'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免覆盖：最终类和方法
- en: If you want to stop other developers from overriding parts of your class, you
    can declare the methods you want to protect as `final`. An example of this could
    be a class that deals with temperature. The method that converts from Celsius
    into Fahrenheit is final, as it makes no sense to override such a method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要阻止其他开发者覆盖你类的一部分，你可以将你想要保护的方法声明为 `final`。一个例子是处理温度的类。将摄氏度转换为华氏度的方法被声明为 `final`，因为覆盖这样的方法没有意义。
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This program will give this result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将给出这个结果：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can declare a whole class `final`. A `final` class cannot
    be extended. An example of such a class is `String`. You could ask whether it
    defeats the purpose of object-oriented programming to have a class that cannot
    be extended. But there are some classes that are so fundamental to the programming
    language, such as `String`, that they are better kept as they are.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以声明整个类为 `final`。一个 `final` 类不能被扩展。一个这样的类的例子是 `String`。你可能会问，如果一个类不能被扩展，这会不会违背面向对象编程的目的。但是，有些类对于编程语言来说非常基础，比如
    `String`，它们最好保持原样。
- en: Overloading Methods and Constructors
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重载和构造函数
- en: One very interesting property of Java is how it allows you to define methods
    that have the same conceptual functionality as each other by using the same name
    but changing either the type or number of parameters. Let's see how this could
    work.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Java的一个非常有趣的特性是它允许你通过使用相同的名称但改变参数的类型或数量来定义具有相同概念功能的方法。让我们看看这是如何工作的。
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the highlighted portion in the preceding code. As we are taking the
    integer parameter `month` and dividing it by a number, the result of the operation
    will be a double. To avoid possible errors, you need to convert the integer into
    a floating comma number. This process, called casting, is done by adding the new
    type between brackets in front of the object, variable, or operation we want to
    convert.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面代码中高亮的部分。由于我们正在将整数参数 `month` 除以一个数，所以操作的结果将是一个双精度浮点数。为了避免可能出现的错误，你需要将整数转换为浮点数。这个过程称为类型转换，通过在要转换的对象、变量或操作之前添加括号中的新类型来完成。
- en: 'The result of this example is:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果是：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This shows that both methods modify the `a` variable in the `Age` class by taking
    different sets of parameters. This same mechanism for having conceptually equivalent
    results from different blocks of code can be used for the constructors of a class,
    as shown in the following example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明两种方法通过不同的参数集修改了`Age`类中的`a`变量。从不同的代码块中产生概念上等效结果的同一种机制，可以用于类的构造函数，如下例所示。
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, as a way to show the functionality, instead of instantiating a
    single object and calling the different methods to modify its variables, we had
    to create two different objects, `age1` and `age2`, with one or two parameters,
    as those are the possible options offered by the constructors available in the
    `Age` class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为了展示功能，我们不得不创建两个不同的对象，`age1`和`age2`，并带有一个或两个参数，因为这些是`Age`类中可用的构造函数提供的可能选项。
- en: Recursion
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Programming languages allow the usage of certain mechanisms to simplify solving
    a problem. Recursion is one of those mechanisms. It is the ability of a method
    to call itself. When properly designed, a recursive method can simplify the way
    a solution to a certain problem is expressed using code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言允许使用某些机制来简化问题的解决。递归就是这些机制之一。它是方法调用自身的能力。当设计得当，递归方法可以简化使用代码表达特定问题解决方案的方式。
- en: 'Classic examples in recursion include the computation of the factorial of a
    number or the sorting of an array of numbers. For the sake of simplicity, we are
    going to look at the first case: finding the factorial of a number.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的经典例子包括计算一个数的阶乘或对数字数组进行排序。为了简化，我们将查看第一种情况：找到一个数的阶乘。
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To run this code, you will need to go to the terminal and call the example
    from there with `java Example11 m`, where `m` is the integer whose factorial will
    be calculated. Depending on where you created the project on your computer, it
    could look like this (note that we have shortened the path to the example to keep
    it clean):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码，您需要进入终端，并使用`java Example11 m`调用示例，其中`m`是要计算阶乘的整数。根据您在计算机上创建项目的地方，它可能看起来像这样（请注意，我们已缩短示例的路径以保持其简洁）：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or, it could look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可能看起来像这样：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result of the call is the factorial: `120` is the factorial of `5`, and
    `6` is the factorial of `3`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 调用的结果是阶乘：`120`是`5`的阶乘，而`6`是`3`的阶乘。
- en: 'While it might not seem so intuitive at first sight, the `fact` method calls
    itself in the return line. Let''s take a closer look at this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能看起来不太直观，但`fact`方法在返回行中调用自身。让我们仔细看看这一点：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are a couple of conditions that you need to meet when designing a functional
    recursive method. Otherwise, the recursive method will not converge to anything:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计功能递归方法时，你需要满足一些条件。否则，递归方法将不会收敛到任何东西：
- en: 'There needs to be a base condition. This means you need something that will
    stop the recursion from happening. In the case of the `fact` method, the base
    condition is `n` being equal to 1:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要有一个基本条件。这意味着你需要一些东西来停止递归的发生。在`fact`方法的情况下，基本条件是`n`等于1：
- en: '[PRE39]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There needs to be a way to computationally reach the base condition after a
    certain number of steps. In our case, every time we call fact, we do it with a
    parameter that is one unit smaller than the parameter of the current call to the
    method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一种方法，在经过一定步骤后，在计算上达到基本条件。在我们的例子中，每次调用`fact`时，我们都使用一个比当前方法调用参数小一个单位的参数：
- en: '[PRE40]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Annotations
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: Annotations are a special type of metadata that can be added to your code to
    inform the compiler about relevant aspects of it. Annotations can be used during
    the declaration of classes, fields, methods, variables, and parameters. One interesting
    aspect of annotations is that they remain visible inside classes, indicating whether
    a method is an override to a different one from a parent class, for example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一种特殊的元数据，可以添加到你的代码中，以通知编译器有关其相关方面的信息。注解可以在声明类、字段、方法、变量和参数时使用。注解的一个有趣方面是，它们在类内部保持可见，指示一个方法是否是父类中不同方法的覆盖，例如。
- en: Annotations are declared using the `@` symbol followed by the annotation's name.
    There are some built-in annotations, but it is also possible to declare your own.
    At this point, it is important to focus on some of the built-in ones, as it will
    help you to understand some of the concepts presented so far in this chapter
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是通过使用`@`符号后跟注解的名称来声明的。有一些内置的注解，但也可以声明自己的注解。在这个阶段，重要的是要关注一些内置的注解，因为它将帮助你理解本章中迄今为止所介绍的一些概念
- en: The most relevant built-in annotations are `@Override`, `@Deprecated`, and `@SuppressWarnings`.
    These three commands inform the compiler about different aspects of the code or
    the process of producing it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最相关的内置注解是`@Override`、`@Deprecated`和`@SuppressWarnings`。这三个命令向编译器告知代码或其生成过程的不同方面。
- en: '`@Override` is used to indicate that a method defined in a child class is an
    override of another one in a parent class. It will check whether the parent class
    has a method named the same as the one in the child class and will provoke a compilation
    error if it doesn''t exist. The use of this annotation is displayed in the following
    example, which builds on the code we showcased earlier in the chapter about the
    `Tablet` class extending the `Computer` class.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Override`用于指示在子类中定义的方法是父类中另一个方法的覆盖。它将检查父类中是否存在与子类中相同名称的方法，如果不存在，将引发编译错误。以下示例展示了如何使用这个注解，该示例基于我们在本章关于`Tablet`类扩展`Computer`类的早期示例。'
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`@Deprecated` indicates that the method is about to become obsolete. This typically
    means that it will be removed in a future version of the class. As Java is a living
    language, it is common for core classes to be revised and new methods to be produced,
    and for the functionality of others to cease being relevant and get deprecated.
    The following example revisits the previous code listing, if the maintainer of
    the `Computer` class has decided to rename the `whatIsIt()` method `getDeviceType()`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Deprecated`表示该方法即将变得过时。这通常意味着它将在类的未来版本中被移除。由于Java是一种活的语言，核心类被修订、新方法被产生，以及其他功能变得不再相关并变得过时是很常见的。以下示例重新审视了之前的代码列表，如果`Computer`类的维护者决定将`whatIsIt()`方法重命名为`getDeviceType()`。'
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Calling the compilation of the previous example will issue a warning about
    the fact that the `whatIsIt()` method will soon be no longer used. This should
    help developers plan their programs, as they''ll know that some methods may disappear
    in the future:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 调用上一个示例的编译将会发出一个警告，指出`whatIsIt()`方法将很快不再被使用。这应该有助于开发者规划他们的程序，因为他们会知道一些方法可能在将来消失：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`@SuppressWarnings` makes the compiler hide the possible warnings that will
    be defined in the annotation''s parameters. It should be mentioned that annotations
    can have parameters such as `overrides`, `deprecation`, `divzero`, and `all`.
    There are more types of warnings that can be hidden, but it is too early to introduce
    them. While we are not going to go deeper into this concept at this point, you
    can see an example of this in the following code listing.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SuppressWarnings`使编译器隐藏在注解参数中定义的可能警告。应该指出的是，注解可以有如`overrides`、`deprecation`、`divzero`和`all`之类的参数。还有更多类型的警告可以被隐藏，但现在介绍它们还为时尚早。虽然我们目前不会深入探讨这个概念，但你可以在以下代码列表中看到一个例子。'
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When calling the compilation of the latest example, you will see a difference
    in comparison to the previous one, as the compilation of this one will not produce
    any warnings regarding the deprecation of the `whatIsIt()` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用最新示例的编译时，你会看到与上一个示例的不同之处，因为这次编译不会产生关于`whatIsIt()`方法过时的任何警告。
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should be careful when using `@SuppressWarnings` as it can hide risks derived
    from potential malfunctions of your code. Especially avoid using `@SuppressWarnings("all")`,
    as it could mask warnings that could be producing runtime errors in other parts
    of your code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@SuppressWarnings`时应小心，因为它可以隐藏由代码潜在故障引起的风险。特别是应避免使用`@SuppressWarnings("all")`，因为它可能会掩盖在其他代码部分可能产生运行时错误的警告。
- en: Interfaces
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are reference types in Java. As such, they define the skeleton of
    classes and objects but without including the actual functionality of methods.
    Classes implement interfaces but do not extend them. Let's look at an example
    of a simple interface, further developing the idea of building classes to represent
    different types of computers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，接口是引用类型。因此，它们定义了类和对象的骨架，但没有包括方法的功能。类实现接口，但不扩展它们。让我们看看一个简单接口的例子，进一步发展构建表示不同类型计算机的类的想法。
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you might have guessed, the output for this example is:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，这个例子的输出是：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Some relevant notes on interfaces follow:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的一些相关注意事项如下：
- en: Interfaces can extend other interfaces.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以扩展其他接口。
- en: Unlike classes, which can only extend one class at a time, interfaces can extend
    multiple interfaces at once. You do so by adding the different interfaces separated
    by commas.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与一次只能扩展一个类的类不同，接口可以一次扩展多个接口。您可以通过添加以逗号分隔的不同接口来实现这一点。
- en: Interfaces have no constructors.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口没有构造函数。
- en: Inner Classes
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部类
- en: 'Classes, as we have seen so far, cannot be hidden to other parts of the program.
    In code terms, they cannot be made private. To offer this kind of security mechanism,
    Java developed so-called **inner classes**. This type of class is declared nested
    within other classes. A quick example of this follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，类不能被程序的其他部分隐藏。在代码术语中，它们不能被设置为私有。为了提供这种安全机制，Java 开发了所谓的 **内部类**。这种类型的类是在其他类内部声明的。以下是一个快速示例：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The result of the previous example is:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之前例子的结果是：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The previous example is a case of a non-static inner class. There are two more:
    method-local inner classes (these are defined inside a method) and anonymous classes.
    There is no big difference in how method-local classes are declared in comparison
    to what you''ve seen so far. A method-local inner class''s main characteristic
    is that it is defined only for the scope of that method; it cannot be called by
    other parts of the program.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是一个非静态内部类的例子。还有两个：方法局部内部类（这些是在方法内部定义的）和匿名类。与之前看到的方法局部类的声明相比，没有太大的区别。方法局部内部类的主要特征是它只在该方法的范围内定义；它不能被程序的其他部分调用。
- en: 'When it comes to anonymous inner classes, they make for an interesting case
    that deserves to be studied. The reason for their existence is to make code more
    concise. With anonymous classes, you declare and instantiate the class at the
    same time. This means that for such a class, only one object is created. Anonymous
    classes are typically created by extending existing classes or interfaces. Let''s
    look at an example defining one of these specific types of anonymous classes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到匿名内部类时，它们构成了一个值得研究的有意思的案例。它们存在的原因是为了使代码更加简洁。使用匿名类，您可以在同一时间声明和实例化该类。这意味着对于这样的类，只创建了一个对象。匿名类通常通过扩展现有类或接口来创建。让我们看看一个定义这些特定类型匿名类的例子：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This example shows how an anonymous class can be created in an ad hoc way to
    override a single method from the original class. This is one of the many possible
    applications of this type of inner class. The output of this program is:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何以即兴的方式创建一个匿名类来覆盖原始类的一个方法。这是这种内部类可能应用的许多可能之一。这个程序的输出是：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Documenting with JavaDoc
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JavaDoc 进行文档化
- en: Javadoc is a tool that comes with the JDK that can be used to generate documentation
    of classes directly from properly commented code. It requires the use of a specific
    type of commenting that is different from the ones seen in *Chapter 1*, *Getting
    Started*. There, we saw that comments can be added to code using either `//` or
    `/*` or `*/`. JavaDoc uses a specific type of marking to detect what comments
    were intentionally made for documentation purposes. Javadoc comments are contained
    within `/**` and `*/`.A simple example follows.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 是 JDK 中的一个工具，可以用来从带有适当注释的代码中直接生成类的文档。它需要使用一种与 *第一章*，*入门* 中看到的不同类型的注释。在那里，我们看到可以通过使用
    `//` 或 `/*` 或 `*/` 来向代码中添加注释。JavaDoc 使用一种特定的标记来检测哪些注释是故意为了文档目的而制作的。Javadoc 注释包含在
    `/**` 和 `*/` 之间。以下是一个简单的例子。
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are going to generate documentation from a class, you need to make sure
    the class is public, otherwise, the JavaDoc generator will complain about the
    fact that it makes no sense to document classes that aren't public.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要从类中生成文档，您需要确保该类是公共的，否则，JavaDoc 生成器将抱怨文档化非公共类没有意义。
- en: The new comments include information about the program itself. It is good practice
    to explain, in some detail, what the program does. Sometimes, it may be convenient
    to even add blocks of code. In order to support that extra information, there
    are tags that allow the addition of specific features or metadata to the documentation.
    `@author`, `@version`, and `@since` are examples of such metadata – they determine
    who made the code, the version of the code, and when it was first created, respectively.
    There is a long list of possible tags that you can use; visit [https://packt.live/2J2Px4n](https://packt.live/2J2Px4n)
    for more information.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新的注释包括有关程序本身的信息。详细解释程序做什么是良好的实践。有时，甚至添加代码块可能很方便。为了支持这些额外信息，有一些标签允许向文档添加特定的功能或元数据。`@author`、`@version`
    和 `@since` 是此类元数据的例子——它们分别确定谁编写了代码、代码的版本以及它首次创建的时间。有一个长长的标签列表你可以使用；访问 [https://packt.live/2J2Px4n](https://packt.live/2J2Px4n)
    获取更多信息。
- en: 'JavaDoc renders the documentation as one or more HTML files. Therefore, it
    is possible to also add HTML markup to help messages. You could change the documentation
    part of the previous example as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: JavaDoc 将文档渲染为一个或多个 HTML 文件。因此，也可以添加 HTML 标记以帮助信息。你可以将上一个示例中的文档部分更改如下：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, you can create the documentation file by selecting `Tools` | `Generate
    JavaDoc` from the menu:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过从菜单中选择 `工具` | `生成 JavaDoc` 来创建文档文件：
- en: '![Figure 3.9: Generating JavaDoc](img/C13927_03_09.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9：生成 JavaDoc](img/C13927_03_09.jpg)'
- en: 'Figure 3.9: Generating JavaDoc'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：生成 JavaDoc
- en: 'The JavaDoc generation dialog box will pop up and give you some options. Make
    sure that you insert the folder where you want the documentation file to be stored
    (`/tmp` in the example) and tick the checkboxes for the `@author` and the `@version`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JavaDoc 生成对话框将弹出并给你一些选项。确保你插入你想存储文档文件的文件夹（示例中的 `/tmp`）并勾选 `@author` 和 `@version`
    的复选框：
- en: '![Figure 3.10: Specifying the scope for the JavaDoc'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10：指定 JavaDoc 的作用域]'
- en: '](img/C13927_03_10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C13927_03_10.jpg]'
- en: 'Figure 3.10: Specifying the scope for the JavaDoc'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：指定 JavaDoc 的作用域
- en: 'This will generate an HTML file that is formatted in the same way that official
    Java documentation is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个格式与官方 Java 文档相同的 HTML 文件：
- en: '![Figure 3.11: The generated JavaDoc'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11：生成的 JavaDoc]'
- en: '](img/C13927_03_11.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C13927_03_11.jpg]'
- en: 'Figure 3.11: The generated JavaDoc'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11：生成的 JavaDoc
- en: 'Activity 2: Adding Documentation to WordTool'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二：为 WordTool 添加文档
- en: Create documentation for the class created in *Exercise 1*, *Creating the WordTool
    Class*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为 *练习 1* 中创建的 *WordTool 类* 创建文档。
- en: Make sure you document each one of the examples and add enough metadata for
    people to know how to handle the different methods.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保为每个示例编写文档，并添加足够的元数据，以便人们知道如何处理不同的方法。
- en: Export the resulting documentation file.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出生成的文档文件。
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 536.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 536 页找到。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the core of object-oriented programming—the creation
    of classes and those operations which can be performed with them, such as extending
    them, using them to override parts of the code, or creating local instances.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你介绍了面向对象编程的核心——类的创建以及可以使用它们执行的操作，例如扩展它们、使用它们来覆盖代码的部分，或创建局部实例。
- en: The examples provided here showed you the importance of creating classes to
    better structure your code and improve it economically. If there are several classes
    within a specific context, it is very likely that they will have common characteristics
    that could be described in a parent class or even an interface.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的示例展示了创建类以更好地组织代码并提高其经济性的重要性。如果在特定上下文中存在多个类，它们很可能具有可以在父类或甚至接口中描述的共同特征。
- en: A part of the chapter was dedicated to operations done with the compiler. As
    a developer, you may want to inform others when certain parts of your code will
    be deprecated, or whether a method from a specific class has been overridden.
    Annotating code is a good technique for maintaining communication with others.
    You also saw how to turn off possible warnings coming from annotations that occurred
    during development.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一部分专门介绍了使用编译器进行的操作。作为开发者，你可能想在你的代码的某些部分将要弃用时通知其他人，或者是否有一个特定类的某个方法已被覆盖。注释代码是维护与他人沟通的好方法。你也看到了如何关闭在开发期间发生的注释可能产生的警告。
- en: Finally, we discussed the process of documentation. This is relevant when sharing
    code or passing it over to other people. In the next chapter, we will take a look
    at Java collections framework which will simplify your dealings with complex data
    structures.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了文档化的过程。这在分享代码或将其传递给其他人时是相关的。在下一章中，我们将探讨Java集合框架，这将简化您处理复杂数据结构的工作。
