- en: 3\. Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will consider the way in which Java implements **object-oriented
    programming** (**OOP**) concepts. For these purposes, you will first practice
    creating and instantiating your own classes so that you can later create methods
    that can handle data within them. We will then take you through how to code recursive
    methods, and even how to override existing methods in favor of your own. By the
    end of the chapter, you will be fully equipped to overload the definition of methods
    in order to accommodate different scenarios with different parameters to the same
    method or constructor, and annotate code to inform the compiler about specific
    actions that must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java class is a template that is used to define data types. Classes are composed
    of objects carrying data and methods that are used to perform operations on that
    data. Classes can be self-contained, extend other classes with new functionalities,
    or implement features from other classes. In a way, classes are categories that
    allow us to define what kind of data can be stored within them, as well as the
    ways in which that data can be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Classes tell the compiler how to build a certain object during runtime. Refer
    to the explanation of what objects are in the *Working with Objects in Java* topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of a class definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Class names should start with a capital letter, as in `TheClass`, `Animal`,
    `WordCount`, or any other string that somehow expresses the main purpose of the
    class. If contained in a separate file, the filename containing the source should
    be named like the class: `TheClass.java`, `Animal.java`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The Anatomy of a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different software components in classes. The following example shows
    a class that includes some of the main ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous code listing shows the definition of a basic class called `Computer`,
    which includes variables and methods to deal with one of the properties of the
    class computer – in this case, `cpuSpeed`. The code shows two different classes.
    The first one is the blueprint for how to define objects of the `Computer` type
    in your programs. The second one, `Example01`, is the one that will be executed
    after compilation and will make an instance of the `Computer` class in the form
    of an object called `myPC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more component inside the class, the constructor, which is optional,
    as Java includes a default constructor for all your classes. `cpuSpeed` variable
    with a value of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible for constructors to have parameters. You could have the
    constructor of the class be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, you could call the constructor with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That would also require a parameter. In addition, classes can have more than
    one constructor. This will be explained later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Objects in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects are to classes what variables are to data types. While classes define
    the structure and possible actions of a certain data type, objects are actual
    usable parts of the computer memory containing that data. The action of creating
    an object is known as making an instance of a class. In a sense, it is like making
    a copy of the template and then modifying it by accessing its variables or methods.
    Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`myPC` is the actual object. We would say that `myPC` is an object of the `class
    Computer` in colloquial terms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The different fields and methods inside the class can be accessed by typing
    the name of the object followed by a period and the name of the variable or method
    you want to address. Making any changes to the variables or calling the methods
    will take effect only within the scope of that object. If you had more objects
    of the same class in your program, each one of them would have a piece of memory
    of its own. An example of how to address a method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of how to address a variable, on the other hand, would be the following
    assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because of the way the `Computer` class has been defined, the last two code
    listings have the exact same effect. The whole class has been defined—by default—as
    `public`, which means that all the methods, variables, and objects from the class
    are available to be called with the mechanism described previously. It could be
    necessary to prevent users from directly interacting with the variables within
    the class and only allow their modification through certain methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different components within a class can be defined as `public` or `private`.
    The former will make the component available to be used as shown so far, while
    the latter will hinder the ability of other developers to access that part. The
    following example shows how to make the `cpuSpeed` variable `private`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this code listing is the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you tried to access the `cpuSpeed` variable directly from the `Example02`
    class, the program would throw an exception. The following example shows such
    a case. Try it out to see how the debugger informs you when you try to access
    a `private` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What the compiler shows is an error in the `Computer` class, which has been
    derived from `java.lang`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Precedence of a Class with instanceof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check whether an object is an instance of a specific class. This can
    be convenient for things such as error checking, handling data in different ways
    depending on its precedence, and more. The following example shows the `checkNumber`
    method, which can discriminate between different types of variables and will print
    different messages based on that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of the previous example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 1: Creating the WordTool Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`WordTool` is a class that will help you to perform a series of operations
    on a piece of text, including counting the number of words, looking at the frequency
    of letters, and searching for the occurrence of a specific string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open IntelliJ and click on the `File` | `New` | `Project` menu options:![Figure
    3.1: Creating a new project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_03_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.1: Creating a new project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A new interface unfolds. The default options are meant for creating a Java
    program. You just need to click `Next`:![Figure 3.2: The New Project dialog box'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.2: The New Project dialog box'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the box to create the project from a template. Select the template for
    the `Command Line App`. Click `Next`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3: Creating a project from template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3: Creating a project from template'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the project `WordTool`. Click `Finish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Adding the Project name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.4: Adding the Project name'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the template calls your basic class `Main`. Let''s change that
    to `WordTool`. First, navigate within the new project to the `Main.java` file;
    it is displayed as the `main` entry in the list:![Figure 3.5: A template Java
    program'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_03_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.5: A template Java program'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Right-click on the `Main` entry and, in the drop-down list, select the `Refactor`
    option. Within that, select `Rename…`:![Figure 3.6: Refactoring the Java class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_03_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.6: Refactoring the Java class'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A dialog window pops up. Write in it the name of the class, `WordTool`. The
    checkboxes allow you to choose which parts of the code will be refactored to fit
    the new name of the class:![Figure 3.7: Renaming the class in IntelliJ'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.7: Renaming the class in IntelliJ'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will see that the class is now called `WordTool` and the file is `WordTool.java`:![Figure
    3.8: WordTool'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_03_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.8: WordTool'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the constructor for the class; it will be empty, in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to count the number of words in a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to count the number of letters in a string, and add the ability
    to count both with and without whitespace characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` class, create an object of the `WordTool` class and add a `String`
    variable containing some text of your choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add code inside the main method to print out the calculations made by `WordTool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program; the outcome should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use the trick presented in this exercise to create classes for all the
    examples in this book, just by using the template and refactoring them to have
    the example name. After that, you will just need to copy the code in a fresh project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 1: Adding the Frequency-of-Symbol Calculation to WordTool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a method to the previously created `WordTool` class to calculate the frequency
    of a certain symbol. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a method to count the number of words in a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method to count the number of letters in a string, and add the possibility
    of separating the case of having whitespaces or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` class, create an object of the `WordTool` class and add a string
    variable containing a line of text of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code inside the main method to print out the calculations made by WordTool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected outcome of this activity is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 534.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inheritance in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is a key principle of object-oriented programming. It entails the
    transfer of the existing structure of one class, including its constructor, variables,
    and methods, to a different class. The new class is called the child class (or
    subclass), while the one it's inheriting from is called the parent class (or superclass).
    We say that the child class extends the parent one. The child class is said to
    extend the parent class in the sense that it not only inherits whatever structures
    are defined by the parent, but it also creates new structures. The following example
    shows a parent class and how the child class extends it by adding a new method
    to it. We will take the `Computer` class we defined earlier as a parent and create
    a new class called `Tablet`, which is a type of computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the definition of the `Tablet` class does not include any methods
    called `setCpuSpeed()` or `getCpuSpeed()`; however, when calling them, not only
    does the program not give any errors, but the commands are also successfully launched.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the definition of the `Tablet` class extends the `Computer`
    class, thus inheriting all its internal objects, variables, and methods. When
    creating an object of the `Tablet` class, such as `myTab`, the JVM reserves space
    in memory for a `cpuSpeed` variable and the setter and getter methods that go
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding and Hiding Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When extending a class, it is possible to redefine some of the methods that
    are part of it. Overriding means to rewrite something's functionality. This is
    done by making a new declaration of the method with the same name and properties
    of the method from the original class. This is demonstrated in the following example.
    Note that we're continuing, for the sake of clarity, with `Computer` and `Tablet`,
    but they have been cleaned up so as not to make the example programs too long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Tablet` extends `Computer`, you could modify the main class in the program
    to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, tablets are computers, which means that you can create an object
    of the `Tablet` class by defining it as `Computer` in the first place. The result
    for both cases will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same for both classes because both the child and parent classes
    include a non-static method called `whatIsIt()`. When calling the method, the
    overriding one will have priority. This is done by the JVM at runtime. This principle
    is what we call runtime polymorphism. There can be multiple definitions of the
    same method, and which definition will be executed is decided during the execution
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: But what would happen if the method you called was static? This could be a design
    decision taken by the developer who is creating the class you are extending and
    therefore is a situation out of your control. In this case, it is not possible
    to override the method. The child class can, however, hide the method defined
    by the parent using the same mechanism. The next code listing demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The decision of what method should be used with static methods is not taken
    at runtime but during compilation, and this ensures that the method from the parent
    class is the one being called. This action is called `Tablet` class. To do so,
    you should modify the code in the `main` class to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we clearly specify the actual class you call for this. The result
    of the modified example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Avoiding Overriding: Final Classes and Methods'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to stop other developers from overriding parts of your class, you
    can declare the methods you want to protect as `final`. An example of this could
    be a class that deals with temperature. The method that converts from Celsius
    into Fahrenheit is final, as it makes no sense to override such a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will give this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can declare a whole class `final`. A `final` class cannot
    be extended. An example of such a class is `String`. You could ask whether it
    defeats the purpose of object-oriented programming to have a class that cannot
    be extended. But there are some classes that are so fundamental to the programming
    language, such as `String`, that they are better kept as they are.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading Methods and Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very interesting property of Java is how it allows you to define methods
    that have the same conceptual functionality as each other by using the same name
    but changing either the type or number of parameters. Let's see how this could
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Look at the highlighted portion in the preceding code. As we are taking the
    integer parameter `month` and dividing it by a number, the result of the operation
    will be a double. To avoid possible errors, you need to convert the integer into
    a floating comma number. This process, called casting, is done by adding the new
    type between brackets in front of the object, variable, or operation we want to
    convert.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This shows that both methods modify the `a` variable in the `Age` class by taking
    different sets of parameters. This same mechanism for having conceptually equivalent
    results from different blocks of code can be used for the constructors of a class,
    as shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, as a way to show the functionality, instead of instantiating a
    single object and calling the different methods to modify its variables, we had
    to create two different objects, `age1` and `age2`, with one or two parameters,
    as those are the possible options offered by the constructors available in the
    `Age` class.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages allow the usage of certain mechanisms to simplify solving
    a problem. Recursion is one of those mechanisms. It is the ability of a method
    to call itself. When properly designed, a recursive method can simplify the way
    a solution to a certain problem is expressed using code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classic examples in recursion include the computation of the factorial of a
    number or the sorting of an array of numbers. For the sake of simplicity, we are
    going to look at the first case: finding the factorial of a number.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this code, you will need to go to the terminal and call the example
    from there with `java Example11 m`, where `m` is the integer whose factorial will
    be calculated. Depending on where you created the project on your computer, it
    could look like this (note that we have shortened the path to the example to keep
    it clean):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the call is the factorial: `120` is the factorial of `5`, and
    `6` is the factorial of `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it might not seem so intuitive at first sight, the `fact` method calls
    itself in the return line. Let''s take a closer look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of conditions that you need to meet when designing a functional
    recursive method. Otherwise, the recursive method will not converge to anything:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There needs to be a base condition. This means you need something that will
    stop the recursion from happening. In the case of the `fact` method, the base
    condition is `n` being equal to 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There needs to be a way to computationally reach the base condition after a
    certain number of steps. In our case, every time we call fact, we do it with a
    parameter that is one unit smaller than the parameter of the current call to the
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations are a special type of metadata that can be added to your code to
    inform the compiler about relevant aspects of it. Annotations can be used during
    the declaration of classes, fields, methods, variables, and parameters. One interesting
    aspect of annotations is that they remain visible inside classes, indicating whether
    a method is an override to a different one from a parent class, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations are declared using the `@` symbol followed by the annotation's name.
    There are some built-in annotations, but it is also possible to declare your own.
    At this point, it is important to focus on some of the built-in ones, as it will
    help you to understand some of the concepts presented so far in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: The most relevant built-in annotations are `@Override`, `@Deprecated`, and `@SuppressWarnings`.
    These three commands inform the compiler about different aspects of the code or
    the process of producing it.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Override` is used to indicate that a method defined in a child class is an
    override of another one in a parent class. It will check whether the parent class
    has a method named the same as the one in the child class and will provoke a compilation
    error if it doesn''t exist. The use of this annotation is displayed in the following
    example, which builds on the code we showcased earlier in the chapter about the
    `Tablet` class extending the `Computer` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`@Deprecated` indicates that the method is about to become obsolete. This typically
    means that it will be removed in a future version of the class. As Java is a living
    language, it is common for core classes to be revised and new methods to be produced,
    and for the functionality of others to cease being relevant and get deprecated.
    The following example revisits the previous code listing, if the maintainer of
    the `Computer` class has decided to rename the `whatIsIt()` method `getDeviceType()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the compilation of the previous example will issue a warning about
    the fact that the `whatIsIt()` method will soon be no longer used. This should
    help developers plan their programs, as they''ll know that some methods may disappear
    in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`@SuppressWarnings` makes the compiler hide the possible warnings that will
    be defined in the annotation''s parameters. It should be mentioned that annotations
    can have parameters such as `overrides`, `deprecation`, `divzero`, and `all`.
    There are more types of warnings that can be hidden, but it is too early to introduce
    them. While we are not going to go deeper into this concept at this point, you
    can see an example of this in the following code listing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When calling the compilation of the latest example, you will see a difference
    in comparison to the previous one, as the compilation of this one will not produce
    any warnings regarding the deprecation of the `whatIsIt()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You should be careful when using `@SuppressWarnings` as it can hide risks derived
    from potential malfunctions of your code. Especially avoid using `@SuppressWarnings("all")`,
    as it could mask warnings that could be producing runtime errors in other parts
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are reference types in Java. As such, they define the skeleton of
    classes and objects but without including the actual functionality of methods.
    Classes implement interfaces but do not extend them. Let's look at an example
    of a simple interface, further developing the idea of building classes to represent
    different types of computers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have guessed, the output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Some relevant notes on interfaces follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can extend other interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike classes, which can only extend one class at a time, interfaces can extend
    multiple interfaces at once. You do so by adding the different interfaces separated
    by commas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces have no constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inner Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes, as we have seen so far, cannot be hidden to other parts of the program.
    In code terms, they cannot be made private. To offer this kind of security mechanism,
    Java developed so-called **inner classes**. This type of class is declared nested
    within other classes. A quick example of this follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the previous example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example is a case of a non-static inner class. There are two more:
    method-local inner classes (these are defined inside a method) and anonymous classes.
    There is no big difference in how method-local classes are declared in comparison
    to what you''ve seen so far. A method-local inner class''s main characteristic
    is that it is defined only for the scope of that method; it cannot be called by
    other parts of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to anonymous inner classes, they make for an interesting case
    that deserves to be studied. The reason for their existence is to make code more
    concise. With anonymous classes, you declare and instantiate the class at the
    same time. This means that for such a class, only one object is created. Anonymous
    classes are typically created by extending existing classes or interfaces. Let''s
    look at an example defining one of these specific types of anonymous classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows how an anonymous class can be created in an ad hoc way to
    override a single method from the original class. This is one of the many possible
    applications of this type of inner class. The output of this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Documenting with JavaDoc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Javadoc is a tool that comes with the JDK that can be used to generate documentation
    of classes directly from properly commented code. It requires the use of a specific
    type of commenting that is different from the ones seen in *Chapter 1*, *Getting
    Started*. There, we saw that comments can be added to code using either `//` or
    `/*` or `*/`. JavaDoc uses a specific type of marking to detect what comments
    were intentionally made for documentation purposes. Javadoc comments are contained
    within `/**` and `*/`.A simple example follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to generate documentation from a class, you need to make sure
    the class is public, otherwise, the JavaDoc generator will complain about the
    fact that it makes no sense to document classes that aren't public.
  prefs: []
  type: TYPE_NORMAL
- en: The new comments include information about the program itself. It is good practice
    to explain, in some detail, what the program does. Sometimes, it may be convenient
    to even add blocks of code. In order to support that extra information, there
    are tags that allow the addition of specific features or metadata to the documentation.
    `@author`, `@version`, and `@since` are examples of such metadata – they determine
    who made the code, the version of the code, and when it was first created, respectively.
    There is a long list of possible tags that you can use; visit [https://packt.live/2J2Px4n](https://packt.live/2J2Px4n)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaDoc renders the documentation as one or more HTML files. Therefore, it
    is possible to also add HTML markup to help messages. You could change the documentation
    part of the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can create the documentation file by selecting `Tools` | `Generate
    JavaDoc` from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Generating JavaDoc](img/C13927_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Generating JavaDoc'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaDoc generation dialog box will pop up and give you some options. Make
    sure that you insert the folder where you want the documentation file to be stored
    (`/tmp` in the example) and tick the checkboxes for the `@author` and the `@version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Specifying the scope for the JavaDoc'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.10: Specifying the scope for the JavaDoc'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate an HTML file that is formatted in the same way that official
    Java documentation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: The generated JavaDoc'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.11: The generated JavaDoc'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Adding Documentation to WordTool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create documentation for the class created in *Exercise 1*, *Creating the WordTool
    Class*.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you document each one of the examples and add enough metadata for
    people to know how to handle the different methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export the resulting documentation file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 536.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the core of object-oriented programming—the creation
    of classes and those operations which can be performed with them, such as extending
    them, using them to override parts of the code, or creating local instances.
  prefs: []
  type: TYPE_NORMAL
- en: The examples provided here showed you the importance of creating classes to
    better structure your code and improve it economically. If there are several classes
    within a specific context, it is very likely that they will have common characteristics
    that could be described in a parent class or even an interface.
  prefs: []
  type: TYPE_NORMAL
- en: A part of the chapter was dedicated to operations done with the compiler. As
    a developer, you may want to inform others when certain parts of your code will
    be deprecated, or whether a method from a specific class has been overridden.
    Annotating code is a good technique for maintaining communication with others.
    You also saw how to turn off possible warnings coming from annotations that occurred
    during development.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed the process of documentation. This is relevant when sharing
    code or passing it over to other people. In the next chapter, we will take a look
    at Java collections framework which will simplify your dealings with complex data
    structures.
  prefs: []
  type: TYPE_NORMAL
