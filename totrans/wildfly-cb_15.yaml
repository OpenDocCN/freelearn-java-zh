- en: Chapter 15. Using WildFly with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Docker environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running WildFly in Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging WildFly outside Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running WildFly in domain mode in Docker using different Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start learning the basics of Docker, and how you can
    take advantage of it by deploying your applications along with the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is an open source platform to develop, ship, and run applications. The
    basic idea of Docker is to get rid of the problems that occur when you promote
    your applications (actually the whole thing, such as the runtime environment)
    from environment to environment; that is, from development, to test, to pre-production,
    to quality, till production. There are so many variables involved that even if
    you do your best, something can go wrong in the traditional software life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: With Docker, you can replicate your entire environment at every stage. The word
    "replicate" probably doesn't explain the concept well enough; "resubmit" would
    be better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images**: A Docker image is just like a template. Suppose you have an image
    with Fedora, Java 8, WildFly, and your installed application. Images can be downloaded
    or built with a descriptor file called `Dockerfile`. From images you can run your
    containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registries**: These are the places where images are stored. There can be
    private and public registries, such as Docker Hub ([http://hub.docker.com](http://hub.docker.com)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: They are, essentially, the running component of Docker. Basically,
    it''s a running instance of a Docker image. A container can be started, stopped,
    deleted, and so on. Each container is isolated from the host that is running it
    and from other containers as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the way, how can we achieve a no bad surprises result when promoting our
    application at various stages with Docker? Think of Docker as a tool for creating
    a stack of pluggable layers. The first layer is the OS layer, then comes your
    environment layer (it might be your specific Java runtime version), then your
    application layer—you can have as many layers as you want/need.
  prefs: []
  type: TYPE_NORMAL
- en: Once your stack is all filled in, what you get is your Docker image, which is
    ready to be committed into the registry. After that, you grab your image and install
    that exact image on the production hardware. You then get what you had before,
    when everything was working smoothly—hope you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding of what Docker is, I strongly suggest you read the
    default documentation and user guide at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.docker.com/introduction/understanding-docker](http://docs.docker.com/introduction/understanding-docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.docker.com/userguide](http://docs.docker.com/userguide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within this chapter, we will mainly use the Docker client, available for different
    operating systems, which is the tool that interfaces with the Docker daemon. There
    are so many settings and features to talk about that it would require another
    book. For this reason, I will focus on installing the client tool, and will explain
    the commands and parameters that we will use in our recipes, that is, in some
    basic WildFly scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Docker environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to install Docker and get acquainted with
    the basic commands. You will see how to create and build an image based on Fedora,
    and how you can run it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to have access to the Internet in order to download and install
    Docker and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Docker on Fedora, issue the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The installation should look like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/3744_15_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Okay, now that Docker is installed, let''s run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to start Docker at boot time, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, ensure that your user is in the `docker` group, by executing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In case the `docker` group is not listed, add it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Obviously, replace the user `luigi` with yours.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check Docker''s version by issuing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great, we are now ready to dockerize whatever we want!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, first we need to check if there are any images available, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As there is no image available, we need to look for it by issuing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Docker image we want is the official Fedora 21\. We can download it as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When all the pulls are complete, we get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use our first Fedora Docker image by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How long did it take to start the container with Fedora? Milliseconds? How long
    would it take to start a Fedora VM in a traditional virtualization environment?
    Tens of seconds? What about the overall installation? With Docker, everything
    gets extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have finally installed the Docker tool and downloaded the latest Fedora image
    (which is version 21 while writing this book). We can use this as a base for our
    next recipe, *Running WildFly into Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: When you first install Docker, there are no images available, and you need to
    get them from the Docker registry. The default registry is the online Docker Hub,
    where you can also sign up for free and have your own space to share your Docker
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can pull (that is, download) a Docker image, you need to know at
    least its name. By issuing the command `docker search IMAGE_NAME`, you are essentially
    filtering all the images stored in the DockerHub that have the specified filter
    in the name or in the description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have pulled the image of your choice, you can use it to run a container,
    as per the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we are using the Docker client tool to communicate
    with the Docker daemon, which is active and listening in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we instruct Docker to `run` a container based on the `fedora`
    image, and finally execute the `/bin/bash` command in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specified the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i`: Which enables the STDIN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t`: Which allocates a pseudo-tty, the terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running WildFly in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to run WildFly in a Docker container by creating
    a `Dockerfile`, which describes how the image should be composed. To go through
    this recipe, you need to have a working Docker installation, along with a Fedora
    21 image; if you don't have these installed, please follow the first recipe in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will need an internet connection to download WildFly directly
    from the container. Also, we will need a Java web application to test our WildFly
    installation. If you want, you can use one of my projects from my GitHub account,
    at [https://github.com/foogaro/wildfly-cookbook.git](https://github.com/foogaro/wildfly-cookbook.git).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can `git-clone` the repository or just download it as a ZIP archive:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the source at `~/WFC/github`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There you will find a project called `docker-example`. To compile the project,
    run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `target` folder generated by Maven, you should find the `docker-example.war`
    artifact, ready to be deployed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a folder in which we will place all our Docker files that we will
    create along the way, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's Docker now!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do is create the `Dockerfile` file in the `~/WFC/docker/wildfly`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a text editor and create a file named `Dockerfile`. Now copy and paste
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save it in the previously mentioned folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, with `Dockerfile`, we can build our image, specific for WildFly, and call
    it `foogaro/wildfly`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! We have successfully created our first Docker image named `foogaro/wildfly`.
    Try issuing the following command now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, in addition to the other images, we have ours that has just
    been created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s run WildFly as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now try opening your browser, and point it to `http://127.0.0.1:9990/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The browser should prompt you for the username and password for the WildFly
    `ManagementRealm`; just enter the following credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Username**: `wildfly`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: `cookbook.2015`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding credentials are those specified in the `Dockerfile` file used
    to build the image.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There you go; you are in your dockerized WildFly instance!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have quite a few options to deploy our `docker-example` application.
    We can go to the `Deployments` page of the WildFly Admin Console, add our artifact,
    upload it, and enable it. Or we could ship our application along with Docker itself,
    which is much better, as you will soon find out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the *Getting ready* section, you should have my GitHub `wildfly-cookbook`
    repository installed in a path, which I named `CODE_PATH`. From there, you should
    create another `Dockerfile` in the `docker-example` folder. Fill in the `Dockerfile`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, create a Docker image from it by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! We have successfully created the preceding Docker image, which contains
    WildFly, along with our `docker-example` application. We can also see it listed
    as a Docker image, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we just need to run this image in a container and test our application,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reading the last log entries, we can see that our `docker-example` application
    has been deployed. To see the application in action, open the browser and point
    it to `http://127.0.0.1:8080/docker-example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the following page:![How to do it…](img/3744_15_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: docker-example application running from a Docker container
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Excellent, we have just deployed and run our first application in a Docker container
    running WildFly!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the Docker tool itself, and all that it comes with, there are some relevant
    things to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the WildFly container in the `docker run` command, we used a new
    flag `-p`, followed by some suspicious numbers. The flag `-p` is used to map the
    ports exposed by the container with the local ports; that is, the host''s ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we mapped the ports `8080` and `9990` with the same ones as in
    our host. That's why we could access the WildFly Admin Console with a local address.
    The same thing happened while accessing the `docker-example` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another flag used in the preceding command: `--rm`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--rm` flag instructs the Docker daemon to eliminate the container from
    the list of the container''s history when the container gets stopped. To view
    all containers, even the non-running ones, you can give the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, after a while, the list can get very long. Eventually, you
    can manually remove old containers that you don''t need anymore, by issuing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'List all the containers again, and the container with ID `981dd5f92e24` should
    be gone, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, if we try to run our `foogaro/wildfly` container without the `--rm` flag,
    when we stop the container it should appear in the container's history list.
  prefs: []
  type: TYPE_NORMAL
- en: There is still one more thing to talk about, and that's the second Dockerfile
    that we created, the one used to create the `foogaro/wildfly-docker-example` image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure and the commands used in the file are pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM**: It''s used to declare the base or starting image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MAINTAINER**: It''s used to declare the owner of the Dockerfile; that is,
    the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN**: It''s used to run commands in the container itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXPOSE**: It''s used to expose a set of ports from the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMD**: It''s typically used as the final instruction to run a service/command
    in the container when we start it. This instruction is basically an array of parameters,
    where even the command to execute is a parameter itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many more instructions you can use, and they are all available and
    explained in detail at the Docker site at [https://docs.docker.com/reference/builder](https://docs.docker.com/reference/builder).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that every instruction in the Dockerfile is run sequentially and
    is atomic. Each instruction starts its own temporary container, executes the task
    it has to do, when done it commits its work, and it destroys its temporary container.
    The next instruction will do the same, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great feature because if something goes wrong while building an image,
    you don't need to restart once the bug has been fixed; the instructions previous
    to the error are cached, so you can quickly test and run your build again.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keep in mind that, nowadays, there are plenty of official images in the DockerHub
    registries, such as the official WildFly docker image. To obtain and work on that
    image, you can simply search and pull it from the repository, as depicted in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![See also](img/3744_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Logging WildFly outside Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with an application server, and thus web applications, often we
    really need to look at the logs. As we have seen in the previous recipe, we have
    run WildFly in a container and we have looked at the logs automatically because
    of the terminal flag being enabled (`-t` when executing the `docker run` command).
  prefs: []
  type: TYPE_NORMAL
- en: Without the terminal flag enabled, we would have needed to access the container
    (`docker attach` `CONTAINER_ID` or `docker logs CONTAINER_ID` command). That's
    not the most comfortable way to look at logs, and we would like to store our logs
    locally, on our host, and group them.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to store your application logs outside the
    container, and store them on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to follow this recipe, you need to have followed the previous one,
    which is about running WildFly in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to create a directory on the host to store our logs,
    and enable the container-writable permissions to access the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal window and execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in a different terminal window, run a container using our `foogaro/wildfly`
    Docker image, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the terminal where we created the `/opt/docker/wildfly/logs` folder, list
    the contents of the folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great, our `server.log` file is there!!!
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is not the best way to handle logs in general; you should look
    at integrating with `syslog`, `rsyslog`, `logstash`, and other tools with more
    powerful and higher performance features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take this recipe as an example to deal with folders that are outside the container.
    Nonetheless, in a development environment, people might want to have the logs
    stored on their PCs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we needed to create a directory to store the WildFly logs, and
    then add the same user and group that we used in the `Dockerfile` to build the
    `foogaro/wildfly` Docker image. As a matter of fact, in the `Dockerfile` there
    was the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds a group and a user in the container environment, and
    it creates them using a fixed group ID and user ID. Thus, to allow the container
    to have read-write permissions on the host, we need to use the same user and group
    for the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Once everything was configured, we launched the `docker run` command using the
    `-v` flag, which is about mounting volumes with the `from:to` pattern. That is,
    everything from the host `from` (at the specified path) will be present in the
    container environment in the specified path, `:to`. Furthermore, every update
    made in the specified folder would have persisted in the host folder.
  prefs: []
  type: TYPE_NORMAL
- en: Running WildFly in domain mode in Docker using different Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to run WildFly in the domain mode using containers.
    We will use one container to act as the domain-controller and two other containers,
    each to act as the servers of a server-group.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To properly follow and understand the topics treated in this recipe, we need
    to know what the WildFly domain mode is, along with its principles. You can also
    refer to [Chapter 3](ch03.html "Chapter 3. Running WildFly in Domain Mode"), *Working
    with XAML*, which is about running WildFly in the domain mode.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you need to have followed the first two recipes of this chapter,
    of having a working Docker installation and a WildFly image available for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, to simplify our recipe, we will rely on the WildFly default configuration
    files: `domain.xml`, `host-master.xml` and `host-slave.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to create a new `Dockerfile` based on the `foogaro/wildfly`
    image, which will contain the entire configuration needed to run WildFly in the
    domain mode. Following is the whole file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To build the image, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the build process is done, we can run the `foogaro/wildfly-domain` image
    in a container. The first thing we are going to run is the domain controller without
    any operative servers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you can access the Admin Console from the host at `http://localhost:9990/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see from the following image, in the **Domain** | **Topology** section,
    there is no running server:![How to do it…](img/3744_15_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WildFly in domain mode running into a Docker container
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's run another container with the WildFly default configuration provided
    by the `host-slave.xml` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a new terminal window and execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the container has successfully launched WildFly, refresh the topology overview
    section of the Admin Console that we loaded earlier, and you should now see two
    running servers, as depicted in the following image:![How to do it…](img/3744_15_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WildFly's domain mode topology showing two servers running on a different Docker
    container
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we saw some new `Dockerfile` instructions, such as `ENTRYPOINT`.
    This instruction is almost like the `CMD` one; it is used to run a service. The
    `ENTRYPOINT` instruction uses the `CMD` instruction to hold the command parameters.
    As a matter of fact, you can specify both the instructions with the option to
    override the `CMD` instruction from the command line, which is exactly what we
    have done when running the host-controller.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `sed` command to modify the `host-slave.xml` file; further information
    on this command is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: As you should already know, communication between the domain controller and
    the host controller needs to be verified. Thus, I inserted the hashed password
    of the `wildfly` user of `ManagementRealm`—the first and second `sed`. The third
    `sed` basically instructs the host controller to authenticate the domain controller
    with the `wildfly` user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that if you do not specify the `username` attribute in the `remote`
    XML element, the name of the host, `<host name="slave">`, will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: The last two `sed` commands instruct which address and port to use to connect
    to the domain controller. As we don't know which IP the container would have,
    we can rely on Docker's environment variables, which it automatically sets when
    it starts. This particular mapping is due to the `--link` flag used when launching
    the second container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the first container, we used the `--name` flag to give it a significant name,
    like `DC`. Then we used that same name with the `--link` flag to bind that container
    with the second one and map it to the `DOMAIN_CONTROLLER` alias.
  prefs: []
  type: TYPE_NORMAL
- en: There is more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When running a container, you can specify the hostname that it will have. In
    our example, we could have run the slaves, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the topology overview, we would have seen the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There is more…](img/3744_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The slave running in a Docker container with a significant name host-1
  prefs: []
  type: TYPE_NORMAL
- en: This is a nice feature that can be handy, instead of trying to remember which
    hash a host belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the same kind of mechanism used in this recipe to configure and
    run the domain mode could be used to run a WildFly cluster.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about linking Docker containers can be found at [https://docs.docker.com/userguide/dockerlinks/](https://docs.docker.com/userguide/dockerlinks/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
