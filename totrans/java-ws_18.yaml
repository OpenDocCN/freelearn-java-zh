- en: 18\. Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on testing with JUnit, one of the primary testing frameworks
    for Java. In its earliest sections and exercises, you will learn to write a successful
    unit test with JUnit to test your code, using assertions to verify that your code
    is correct. You will then be introduced to parameterized tests—a type of unit
    test which allows you to run the same test on a set of data inputs—which you will
    also learn to write. Finally, the chapter will define mocking, which is the technique
    whereby you will practice how to 'mock out' external dependencies so that you
    can concentrate on testing a single Java class.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing allows you to make sure your Java code performs correctly. For example,
    if you were calculating employees' pay, you would want the code to be accurate;
    otherwise, your organization may face legal consequences. While not every programming
    issue leads to legal doom, it is still a good idea to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests while you code, as opposed to when you are done, can speed up
    your work. This is because you won't be spending time trying to figure out why
    things don't seem to work. Instead, you will know exactly what part of the code
    isn't correct. This is especially useful for any code that requires complex logic.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, as new enhancements are added to the code, you will want
    to make sure that nothing in the new code breaks the old functionality. Having
    a suite of well-written unit tests can really help in this regard. If you are
    a new developer hired into a team that has been working on an application for
    some time, a good suite of tests is a sign that your team follows engineering
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test tests one unit of code. In Java terms, this usually means that a
    unit test tests a single Java class. The test should run quickly, so you know
    whether there are any problems as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: A unit test is a separate Java class designed just for testing. You should write
    separate test methods for each part of the original class you want to test. Typically,
    the more fine-grained the test, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, due to necessity, a unit test will test more than one class. That's
    OK and not something to worry about. In general, though, you want to concentrate
    on writing separate tests for each class in your Java application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Writing your Java classes so that they are easy to test will improve your code.
    You'll have better code organization, clearer code, and better quality as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests, on the other hand, test a part of the entire system, including
    external dependencies. For example, a unit test should not access a database.
    That's the job of integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests go further and test an entire system all in one, such as an
    online banking application or a retail store application. This is sometimes called
    end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Software development job interviews tend to go badly if you say you do not believe
    in writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JUnit provides the most widely used test framework for Java code. Now on version
    5, JUnit has been around for years.
  prefs: []
  type: TYPE_NORMAL
- en: 'With JUnit, your tests reside in test classes, that is, classes that use JUnit''s
    framework to validate your code. These test classes reside outside of the main
    application code. That''s why both Maven and Gradle projects have two subdirectories
    under the `src` directory: main, for your application code, and test, for the
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, tests are not part of your built application. So, if you build a
    JAR file for your application, the tests will not be part of that JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit has been around for a long time, and you will find the official documentation
    at [https://packt.live/2J9seWE](https://packt.live/2J9seWE) and the official site
    at [https://packt.live/31xFtXu](https://packt.live/31xFtXu).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Another popular test framework is called Spock. Spock uses the Groovy language,
    which is a JVM language that is similar to Java. You can refer to [https://packt.live/2P4fPqG](https://packt.live/2P4fPqG)
    for more information about Spock. TestNG is another Java unit testing framework.
    You can refer to [https://packt.live/33X2nct](https://packt.live/33X2nct) for
    more information about TestNG.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Unit Tests with JUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oozie is a workflow scheduler for the Hadoop big data clusters. Oozie workflows
    are jobs that perform tasks on potentially massive amounts of data stored in Hadoop
    clusters. Oozie coordinator jobs run workflow jobs on a schedule.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining a schedule, you typically set three values:'
  prefs: []
  type: TYPE_NORMAL
- en: The starting timestamp, which defines when the coordinator should start a workflow
    job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ending timestamp, which defines when the coordinator should end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A frequency, in minutes, at which the coordinator should launch jobs. For example,
    a frequency of 60 specifies launching a workflow job every 60 minutes (that is,
    each hour), from the starting timestamp to the ending timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can refer to [https://packt.live/2BzqlOJ](https://packt.live/2BzqlOJ) for
    more information about Oozie coordinators and even more scheduling options. For
    now, we'll just concentrate on validating the coordinator scheduling information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we're going to define a simple JavaBean class that holds the scheduling
    information and then write a JUnit test to validate a coordinator schedule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic bean looks like the following (with the getters, setters, and constructors
    not shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The starting and ending timestamps are `String` values based on an assumption
    that this bean would hold data read in from a configuration file. It also allows
    us to validate the `String` format for the timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that IntelliJ can generate constructors along with the getter and setter
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider what you would want to test, along with how you would write those
    tests. Testing edge cases is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a coordinator, here are the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The ending timestamp must be after the starting timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both timestamps must be in UTC in the format of `yyyy-MM-ddTHH:mmZ` (this is
    the ISO 8601 format).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frequency must be less than 1,440 (that is, the number of minutes in a normal
    day). Oozie provides alternative configuration settings to go beyond this limitation.
    For now, we'll just test against this limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frequency should be greater than 5 (this is an arbitrary rule designed to
    prevent new workflows starting while another workflow is still running).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a test, you create a separate test class. Test classes should have
    a single no-argument constructor. Test classes cannot be abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you work with the Maven build tool (refer to *Chapter 6*, *Libraries, Packages,
    and Modules*), then your test classes should all have names that end in `Test`,
    `Tests`, or `TestCase`. All test classes in this chapter have names ending in
    `Test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit uses the `@Test` annotation to identify a test method. You can add a
    `@DisplayName` annotation to specify the text to be displayed should the test
    fail. This can make your test reports easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside your test methods, use the `Assertions` class methods to validate the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: JUnit provides a few other assertion methods, such as `assertEquals()` and `assertAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Writing a First Unit Test'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example will show the basics of writing a JUnit unit test. For this exercise,
    we will simply test whether the properties are correct; though, typically, you
    would also test program logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `New` and then `Project…` from the `File` menu in IntelliJ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Gradle` for the type of project. Click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Group Id`, enter `com.packtpub.testing`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Artifact Id`, enter `chapter18`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Version`, enter `1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the default settings on the next pane. Click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the project name as `chapter18`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call up `build.gradle` in the IntelliJ text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `sourceCompatibility` so that it is set to `12`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the JUnit dependency defined in the `build.gradle` file (it is for an
    older version). Replace that dependency with the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This brings in JUnit 5 to our project, rather than JUnit 4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following to `build.gradle` after the dependencies section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This ensures that you use the JUnit 5 test platform for running tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `src/main/java` folder, create a new Java package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `com.packtpub.testing` as the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `src/test/java` folder, create a new Java package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the same name, `com.packtpub.testing`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `src/test/java` folder is where you will place your test classes. The `src/main/java`
    folder is where the application classes are located.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on this package in the `src/main/java` folder and create a new Java
    class named `CoordSchedule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter two constants that we''ll use to validate the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the properties of this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the editor cursor inside the class (that is, between the starting and ending
    curly braces), right-click and choose `Generate…`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `Constructor` and then select all three properties. You should see a
    constructor like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, with the editor cursor inside the class (that is, between the starting
    and ending curly braces), right-click and choose `Generate…`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Getter` and `Setter` and then select all three properties. You will
    then see the `get` and `set` methods for each of the three properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following method to parse the `String` timestamp value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following two utility methods to return the `Date` objects for the
    two timestamps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These methods allow other code to get the timestamps in date format, rather
    than as a string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now have the Java class that we are going to test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is to create a unit test class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on this package in the `src/test/java` folder and create a new Java
    class named `CoordScheduleTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this test should fail because we use a maximum value of `50` instead
    of the actual requirement, which is a maximum of `1,440`. It is good to see what
    failure will look like first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the `Gradle` pane. Expand `Tasks` and then expand `verification`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on `Test`. This runs the Gradle `test` task. This will show an
    output like the following (with most of the stack trace omitted for clarity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This isn''t a very nice test report. Luckily, JUnit provides a much nicer report.
    Click on the Gradle elephant icon and the test report will appear in your web
    browser:![Figure 18.1: The IntelliJ Run pane with the Gradle icon shown'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_18_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 18.1: The IntelliJ Run pane with the Gradle icon shown'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switch to your web browser and you will see the test report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.2: The test report as displayed in the browser](img/C13927_18_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.2: The test report as displayed in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: You will see a list of failed tests with the text from the `DisplayName` annotation.
    For each failed test, you can drill down into the test. This provides a much better
    format with which to display the test results.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll fix the broken test and validate the other rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Writing a Successful Test'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a test that fails, we''ll need to fix the test and add test
    methods to verify the starting and ending timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `CoordScheduleTest` in IntelliJ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `testFrequency()` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a test method to check for an incorrectly formatted date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a test method to verify that the ending timestamp is later than the starting
    timestamp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the `Gradle` pane. Expand `Tasks` and then expand `verification`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on `Test`. This runs the Gradle `test` task. This will show an
    output like the following (with most of the stack trace omitted for clarity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the incorrectly formatted timestamp shows an exception stack trace
    (truncated here for length). This was expected (the input timestamp was not correct),
    so it is not an error. These tests should succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding What to Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can always write more tests, so, sooner or later, you need to decide on
    what you really do need to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is normally a good idea to focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: What code, if in error, would cause the greatest impact?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What code is depended on the most by other code? This code should get extra
    tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you checking for edge cases, such as maximum and minimum values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to simplify writing better tests, and especially to deal with a few
    edge cases, you may want to use parameterized tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Parameterized Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A parameterized test is a unit test that accepts parameters. Instead of all
    the test values being set in the `test` method, you can pass parameters. This
    makes it much easier to test multiple cases. For example, when processing string
    data, you may want to test multiple strings, including null and empty strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a parameterized test, you need to specify the parameters you want to pass
    to the test. JUnit will pass these parameters as actual method parameters to your
    test. For example, look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you use a `@ParameterizedTest` annotation instead of `@Test`.
    This tells JUnit to look for the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@ValueSource` annotation defines two values to get passed to the `test`
    method: `10000` and `11000`. In both cases, this test assumes that the passed-in
    parameters will each result in the `hasMetGoal()` method returning `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized tests make JUnit much more acceptable to someone who uses Spock.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit will call the `test` method once for each value in the `@ValueSource`
    list, so two times in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ValueSource` annotation expects a list of values to pass to the test method.
    If you have more complex values, you can use the `@CsvSource` annotation instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@CsvSource` annotation takes a comma-separated set of values. For example,
    look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the first call to `testHasMetStepGoal()` will return `10` for
    the `steps` parameter and `false` for the `expected` parameter. Note that JUnit
    converts the types for you. Similar to `@ValueSource`, each data line results
    in a separate call to the `test` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`@CsvSource` is very handy if you want to pass in a number of values to be
    compared against each other, or in the case here, where you would want to pass
    both good and bad values, along with a parameter that indicates whether the test
    is expected to be `true` or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the values within `@CsvSource` are stored as strings, you need some
    special syntax to handle empty strings, null strings, and strings with spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first line has a string with spaces. Use single quote characters (`'`) to
    delimit strings with spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The third line has just a comma for the first parameter. JUnit will pass `null`
    for this construct.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth line has two single quotes used to generate an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `@CsvSource`, you can load the data from an external comma-separated
    value (CSV) file using the `@CsvFileSource` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: JUnit supports a few other ways to get the parameter values, including from
    a separate file, from a method you write, and more. You can refer to [https://packt.live/2J8oXGU](https://packt.live/2J8oXGU)
    for more information about parameterized tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Writing a Parameterized Test'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume that you are writing code that accesses a wearable fitness device.
    One of the things the device tracks is the number of steps the wearer takes on
    a given day. You can then compare the number of steps taken against a daily goal.
    Has the wearer met this goal?
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates how to write a parameterized test, based on the daily
    step goal from *Chapter 6*, *Libraries, Packages, and Modules*:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `build.gradle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the dependencies block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This dependency brings in support for the parameterized tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.testing` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `DailyGoal` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code for this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the class we will test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.testing` package in the `src/test/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `DailyGoalTest` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following constant for the device wearer''s daily step goal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, enter a `test` method for step counts that meet or exceed the daily goal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With a daily step goal of `10000` steps, `10000` and `11000` both meet this
    goal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we''ll test the result when the step count is lower than the daily step
    goal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `9999` is just one step below the goal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, enter a test method using the `@CsvSource` values for the test parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test method is a bit more complicated. Each call to the test passes two
    parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The lambda expression in the call to `Assertions.assertTrue()` is the error
    message. Using a lambda expression means that the error message won't get evaluated
    unless the test assertion fails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you run this test class, it should succeed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When Tests Won't Work—Disabling Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@Disabled` annotation allows you to disable a test. Normally, it is not
    good practice to simply disable any test that fails. This defeats the whole idea
    of testing. However, you may come across times where, due to some condition outside
    of your control, you just must disable tests. For example, if you are using the
    code from another group, and that group has broken an expectation or introduced
    a bug in its code, you may need to—temporarily—disable tests that depend on that
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can add the `@Disabled` annotation to an entire test class, or just to a
    test method, as shown in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: Test Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many tests, you may need to perform some setup work, as well as cleanup work
    after the test. For example, you may want to initialize the objects that are needed
    for the test. JUnit provides a number of life cycle annotations to support such
    work.
  prefs: []
  type: TYPE_NORMAL
- en: If you annotate a method with `@BeforeEach`, JUnit will run that method before
    running each test method. Similarly, methods annotated with `@AfterEach` are run
    after each test method. If you want to run the setup or clean up the code just
    once for a test class, you can use `@BeforeAll` and `@AfterAll`. These two methods
    come with some restrictions, though.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit creates a new instance of your test class for each test method. This ensures
    your tests run in isolation and avoid what is called test pollution, where one
    test impacts another test. Normally, this is a good thing, because tracking down
    test failures that depend on the order of the test execution is particularly frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: Because JUnit creates a new instance of the test class for each test method,
    the `@BeforeAll` and `@AfterAll` methods must be `static`. Additionally, the data
    that these methods initialize or clean up should also be `static`.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to create `static` methods, you can change JUnit's policy
    of creating a new instance of the test class for each test method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you annotate your test class with the following, JUnit will create just
    one instance of the test class shared by all the test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You'll see an example of this in the *Mocking* section.
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 4*, *Using Test Setup and Cleanup Methods* demonstrates how to code
    these setup and cleanup methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Using Test Setup and Cleanup Methods'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise demonstrates a simple unit test with placeholder methods for
    both setting up and cleaning up. The test will verify a simple class that converts
    Celsius temperature values to Fahrenheit:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.testing` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `TempConverter` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the `com.packtpub.testing` package in the `src/test/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `TempConverterTest` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following test method that checks for `-40.0` degrees on both temperature
    scales:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This temperature is unpleasant regardless of the temperature scale used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice how this test uses the `assertEquals()` assertion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter another test method to ensure the conversion works when the temperature
    is `100.0` degrees Celsius:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, enter a method to be run before all the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this method must be static (or you must use the class-level annotation
    listed previously).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Normally, you would use this method to set up complex test data instead of just
    printing a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter a method to be run after all the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, this method must be static.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, enter a method to be run before each of the two test methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, enter a method to be run after each test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the green arrow by the class statement and select `Run 'TempConverterTest'`.
    The test should run without errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see an output like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `@BeforeAll` method is only run once. Then, with each test method,
    the `@BeforeEach` and `@AfterEach` methods are executed. Finally, the `@AfterAll`
    method is executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A unit test is supposed to test just one Java class. There are times, however,
    where a class is heavily dependent on other classes, and perhaps even external
    systems such as databases or handheld devices. In these cases, a technique called
    mocking proves useful. Mocking is where you mock out the other dependencies so
    that you can test just the class you want to look at.
  prefs: []
  type: TYPE_NORMAL
- en: A **mock** is a class used just for testing that pretends to be some external
    dependency. With a mocking framework, you can examine a mocked class to ensure
    that the right methods were called the right number of times with the right parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking works great when you have code that queries for data in a database or
    external system. What you do is create an instance that is a mock for a particular
    class. Then, when the query method gets called, you have the mock return arbitrary
    test data. This avoids the dependency on the external system.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking also works great when you want to verify that a particular method was
    called, without actually calling that method. Think of an email notifier that
    sends email messages on some kind of failure. In a unit test, you don't want actual
    email messages to get sent. (In an integration or functional test, however, you
    should verify that the messages do get sent.)
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Mocks Using Mockito
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mockito is a great framework for adding mocks to your testing. Say that you
    have an application that monitors workflows running in a big data cluster; these
    could be Oozie workflows mentioned previously, or any other type of workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Your application gets the status of the workflows by calling a remote web service.
    In your unit tests, you don't want to call the remote web service. Instead, you
    just want to mock out the external system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we want to test will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, the code calls a remote web service to get the status of a workflow,
    based on the workflow ID. Then, if the workflow status is not OK, the code sends
    an email message. For unit tests, we need to mock both the call to `getStatus()`
    and the call to `sendFailureEmail()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `WorkflowClient` class manages the HTTP communication to the remote web
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to the `getStatus()` method with a workflow ID returns the status of
    that given workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to *Chapter 9*, *Working with HTTP*, for more information about
    HTTP and web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Mockito, the first thing you need to do is to create a mock of the `WorkflowClient`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to stub out the call to `getStatus()`. In Mockito terminology,
    when something happens, then a particular result is returned. In this case, the
    stubbed code should return a prebuilt `WorkflowStatus` object with the desired
    status of a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first set up a string of the workflow ID and then construct
    a `WorkflowStatus` object with a successful status (`OK`). The crucial code starts
    with `when()`. Read this code when the `getStatus` call is made with the given
    ID on the mock `WorkflowClient` class, and then return our prebuilt `WorkflowStatus`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, Mockito is looking for an exact match. The passed-in workflow
    ID must match, or the mock will not return the specified result. You can also
    specify that the mock should return the result with any input workflow ID, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `anyString()` call means any string value passed in will match.
    Note that Mockito has other calls, such as `anyInt()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Mockito includes very good documentation at [https://packt.live/2P6ogl9](https://packt.live/31xFtXu).
    You can do a lot more with mocks than the examples shown here, but you should
    avoid the temptation to mock everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the call to the external web service mocked out, the next step is to check
    whether a failure email gets sent. To do this, mock the class that sends email
    failure messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code we want to test, the email message is sent only on failures. So,
    we will want to test two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The email is not sent if the status is OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The email is sent if the status is *not* OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, we will use Mockito to check the number of times the `sendFailureEmail()`
    method gets called. If it is zero times, then no email is sent. If it is one or
    more times, then an email message is sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that no email message was sent, use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code checks that the `sendFailureEmail()` method was called zero times,
    that is, not called at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the email message was sent, you can specify the number of times
    as `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use Mockito''s shortcut, which assumes the method gets called
    just once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In more complex tests, you may want to ensure a method gets called a few times.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, JUnit creates a new instance of your test class for
    each test method. When mocking, you may want to set up the mocks once, instead
    of every time a test method runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell JUnit to create just one instance of the test class and share it among
    all test methods, add the following annotation to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `setUpMocks()` method will get called once before all the test methods run.
    It sets up the two mock classes and then passes the mock objects to the constructor
    for the `WorkflowMonitor` class.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise shows all these classes together, using Mockito-based
    mocks in the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Using Mocks when Testing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise creates a `WorkflowMonitor` class and then uses mock objects
    to handle external dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `src/main/java` folder in the IntelliJ `Project` pane, create a new Java
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `com.packtpub.workflow` as the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `src/test/java` folder, create a new Java package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the same name, `com.packtpub.workflow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `build.gradle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the dependencies block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `WorkflowStatus` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code for this simple value object class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a real system, this class would hold additional values, such as when the
    workflow started, when it stopped, and other information on the workflow. The
    status information was simplified for this exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `EmailNotifier` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a real application, this would send email messages. For simplicity, we'll
    leave that blank.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `WorkflowClient` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, this is simplified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.workflow` package in the `src/main/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `WorkflowMonitor` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the class, choose `Generate…` and then choose `Constructor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select both properties and then click on `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the method we will test using mock objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.workflow` package in the `src/test/java` folder.
    Select `New` and `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `WorkflowMonitorTest` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Annotate the class so that we can create a `@BeforeAll` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following properties and set up the `@BeforeAll` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets up the mock objects and then instantiates a `WorkflowMonitor` object
    using the mocked dependencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the following test method to test a case when the workflow is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should also test a case where the workflow status is not OK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the following test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the green arrow by the class statement and select `Run 'WorkflowMonitorTest'`.
    The test should run without errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Activity 1: Counting the Words in the String'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Word count is of paramount value in the publishing industry. Write a class that,
    given a string, will count all the words in the string.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `split()` method to break up the string into words, using the
    `\s+` regular expression to separate the words, which matches whitespace characters(that
    is, spaces and tabs). Name this class `WordCount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trim the input string to remove any spaces at the beginning or end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that an empty string should generate zero for the word count; so should
    a `null` string. Input strings that are all spaces should generate zero as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have the class written, write a parameterized unit test for that class.
    Use the parameters and `@CsvSource` to pass in a string along with the expected
    word count. Be sure to include punctuation such as commas and periods in your
    input strings. In addition to this, be sure to include input strings with null
    strings and empty strings in the input parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 569.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced unit testing. Testing is good and you want to write
    tests for all your Java code. If you write successful tests, then you can feel
    confident your code was written correctly.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit provides the most popular testing framework for writing Java unit tests,
    though there are other frameworks you can try as well. The `@Test` annotation
    on a method tells JUnit that the given code is considered a test. JUnit will execute
    the test and see whether it succeeds. The JUnit assertions class contains a few
    `static` methods that you can use to verify the test results.
  prefs: []
  type: TYPE_NORMAL
- en: A parameterized test is a test into which you pass a few parameters. This is
    very useful when writing tests for code that you want to ensure can handle a variety
    of inputs. Mocking is a technique where you mock out external dependencies so
    that a unit test can concentrate on testing just one class.
  prefs: []
  type: TYPE_NORMAL
