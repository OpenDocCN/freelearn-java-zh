<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Persisting Data Using a Database</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will look at choosing a database management system. The choice of systems depends on various factors, such as visualization and reporting, security, scalability, and cost, to name a few. There are also various kinds of databases, and one of them is the relational database. This kind of database is designed in such a way that it recognizes relations within the stored information. In most cases, SQL is used to query and maintain relational databases systems. Additionally, we will learn to develop the data in that database along with your application and implement data access with Spring.</p>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Choose a database management system</li>
<li>Develop the data in that database along with your application</li>
<li>Implement data access with the help of Spring</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Relational Databases and SQL</h1>
                </header>
            
            <article>
                
<p>The final chapter of this book is about persistence, in other words, using a database.</p>
<p>There is software that does not need to store any state. Some software is just fired up for a certain task; it performs it and returns its results; some lies in the middle of other components and relays messages back and forth. Many software systems, however, need to store some state; they are said to <strong>persist</strong> the state. There are different forms of data storage, but we will focus on what is most prevalent in business applications.</p>
<p>Many different answers may come up. A saved game file on your hard disk may not sound like persistence at first, but it is a very valid answer. It is important that you understand that most software need some amount of storage, and that the form of storage differs widely.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Relational Database Management Systems (RDBMS)</h1>
                </header>
            
            <article>
                
<p><strong>Relational Database Management Systems</strong>, <strong>RDBMS</strong> for short, are systems that can store data in a relational database. Strictly speaking, the <strong>database</strong> is only the data within that is managed by the system. Very often, we do not make this distinction in everyday speech and just call this <strong>management system</strong> a <strong>relational database</strong>, or even just database.</p>
<p>Without diving deep into database theory, relational in this context refers to relational algebras as introduced by Edgar F Codd in 1970. In short, it means we store data in tables, pre-defining the set of columns for a table (with names and types), with each entity taking up a row in it. Databases such as these are almost invariably described and queried using the query language SQL; therefore, they are sometimes called <strong>SQL databases</strong>.</p>
<div class="packt_infobox"><br/>
The well-founded semantics of relational algebras are the basis of how to store data in an RDBMS and also how to query such data. The original work that is the foundation of database theory can be found in Edgar F Codd's 1970 work '<em>A Relational Model of Data for Large Shared Data Banks', Communications of the ACM, 13 (6): 377–387</em> (<a href="https://doi.org/10.1145%2F362384.362685">https://doi.org/10.1145%2F362384.362685</a>).<br/>
There are many good articles on this for different levels of expertise, which can be found on Wikipedia or universities' websites. It is worthwhile reading even if you are already familiar with SQL databases.</div>
<p>Relational databases are the industry standard, with popular open source software such as PostgresQL and MySQL, and expensive enterprise-grade solutions such as Oracle and MS SQL Server. They are the best solution for many challenges, and still a very good solution for most others, and this has made them prevalent. However, for a number of special cases, they are deemed to be too inflexible or too slow. This has given rise to a large number of alternative solutions that are often collectively known as <strong>NoSQL</strong> to differentiate them from the more standard SQL databases. The increased speed or flexibility comes with some cost, so they are not a general replacement. Even though Spring offers support for some of them, none of this is in scope for this book.</p>
<p>Instead, we will focus on SQL databases and the excellent support Spring has for these in a number of aspects. We will see how to connect to an RDBMS (even to integrate one), how to evolve the database alongside our code, and how to access the data. This last aspect in particular, is facilitated, as we will see shortly. But, first, we need an RDBMS to connect to.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The H2 Embedded Database</h1>
                </header>
            
            <article>
                
<p>Many database systems are heavyweight, can store terabytes of data (or, for some, that is the memory they take up, and they can store petabytes), they have fail-over and backup strategies built in, and an elaborate security concept. Sometimes, all of this is too much.</p>
<p><strong>H2</strong> is special in that it is small, it is written in Java, it can be embedded in your program, and it can store all the data in-memory. Yes, that's right— it will be all in one place, and it will work out of the box. H2 can be used in production systems, if required, since it is fast and supports most of SQL. Often, however, it will be used only during development.</p>
<p>Let's dive right in and use it in our project!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing the H2 Console</h1>
                </header>
            
            <article>
                
<p>The aim here is to embed the in-memory H2 database. You want to add persistence to your application. Since you are newly developing the application, you need some playground, so you decide not to access your company's enterprise database, but to start with an in-memory solution that can be swapped for an external database as the need arises.</p>
<p>Before beginning, locate the blogmania app from the folder present at <a href="https://bit.ly/2qIrUEE">https://bit.ly/2qIrUEE</a>. The steps for completion are as follows:</p>
<ol>
<li>In the POM, in a convenient spot within the <kbd>&lt;dependencies&gt;</kbd> element, add the following dependencies:</li>
</ol>
<pre style="padding-left: 60px">&lt;!-- Database access --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>&lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>&lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>&lt;scope&gt;runtime&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<div class="packt_infobox"><br/>
Upon starting, Spring Boot will auto-discover the database and give you access to a pre-configured database instance through the use of injected DataSource beans. Everything you need is now there!<br/>
However, there is not much to be seen just yet. Let's turn to another feature that can be very helpful during development: the H2 console. This comes with the H2 database and is enabled in Spring Boot when the Spring Boot Devtools are available (which they are in our application). Go to <a href="https://bit.ly/2QpSiP0">https://bit.ly/2QpSiP0</a> to access the complete code for the <kbd>BlogmaniaApplication.java</kbd> file.</div>
<ol start="2">
<li>Now start the application. Point your browser to <kbd>http://localhost:8080/h2-console</kbd>, and — voilà! — you are now seeing the H2 console login screen:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d38304fd-9edb-4ec6-ab9f-7b03bfc76eee.png" style="width:32.08em;height:22.92em;" width="442" height="315"/></div>
<ul>
<li>This console could be used to access any SQL database. The fields are prefilled with exactly the correct values to go into the embedded in-memory test database, so just click the <span class="packt_screen">Connect</span> button.</li>
<li>The next screen is a bit overwhelming at first. To help you get started, find the 'Sample SQL Script' section in the middle of the screen; when you click on it, the script will be copied to the SQL statement window at the top. Press the <span class="packt_screen">Run</span> button to actually run the script:</li>
</ul>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/0cdd20e1-d542-42a0-9529-12765719df92.png" style="width:33.42em;height:29.58em;" width="867" height="767"/></div>
<ul>
<li>You have now created a table, put some data in it, and updated it! The new table called TEST will now appear in the tree to the left. You may want to explore the console to get familiar with it.</li>
</ul>
<p>As you have witnessed, now there is a database that can be used and viewed for debugging. However, detailed knowledge of this is outside the scope of this book.</p>
<p>Unfortunately, the console does not play well with Spring Security. So, if we had that enabled, we would have to relax access a bit. In the security configuration, you must perform one change in the configure (<kbd>WebSecurity</kbd>) method to just take the H2 console out of the security loop. That method should then look like this:</p>
<pre>@Override<br/>public void configure(WebSecurity web) {<br/>   web<br/>        .ignoring()<br/>        .requestMatchers(PathRequest.toH2Console());<br/>}</pre>
<p class="mce-root">Before going into production, it would be a good idea to undo these changes.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Gist of SQL</h1>
                </header>
            
            <article>
                
<p>SQL is a database language to define, create, read, update, and delete data. The initialism has no official meaning. However, it is usually thought to be an abbreviation of <strong>Structured Query Language</strong>, and it is sometimes pronounced "sequel" but this is, in fact, a relic of its predecessor.</p>
<p>SQL handles data in tables. These tables have a defined number of columns, each with a specific type. The database system is strongly typed and can even check constraints over the values in a table. A part of SQL referred to as the <strong>Data Definition Language</strong> (<strong>DDL</strong>) is responsible for declaring and creating these tables.</p>
<p>Another part of the language, the <strong>Data Manipulation Language</strong> (<strong>DML</strong>), is responsible for working on the data. The two sub-languages are only logically separated; they share much of their syntax.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">DDL Table Creation</h1>
                </header>
            
            <article>
                
<p>We have seen the language in action in the last exercise. Let's look closer:</p>
<pre>CREATE TABLE test(id INT PRIMARY KEY, name VARCHAR(255));</pre>
<p>This bit of DDL defines a table called test with two columns: one column called <kbd>id</kbd>, and another one called <kbd>name</kbd>. The id column has the type INT, which can store integer values. The name column, on the other hand, can store strings of a variable number of characters, up to a maximum length of 255.</p>
<div class="packt_infobox"><br/>
It is customary to write all SQL keywords in uppercase. This, however, is only a convention, and SQL is case-agnostic.<br/>
Slightly contested, but still widespread is the convention to use lowercase for identifiers. SQL is case-agnostic here as well.</div>
<p>The id column is meant to store an identifier for the row. This is also called a <kbd>key</kbd> in databases. Identifiers should be unique within a table and adding the keywords PRIMARY KEY will make the database enforce this constraint.</p>
<div class="packt_tip"><span><br/>
Most databases can be forced to use identifiers with only the specified case. This is asking for trouble. </span><br/>
<span>There is a lot of standardization in SQL, but, unfortunately, each database has its quirks or extensions. For instance, the normal type for storing strings of characters is called VARCHAR2 in Oracle, and it cannot store empty strings, because empty strings are handled the same as the special NULL values.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">DML Data Manipulation</h1>
                </header>
            
            <article>
                
<p>The next lines, in contrast, are DML and manipulate data:</p>
<pre>INSERT INTO test VALUES(1, 'Hello');<br/>INSERT INTO test VALUES(2, 'World');<br/>SELECT * FROM test ORDER BY id;<br/>UPDATE test SET name = 'Hi' WHERE id = 1;<br/>DELETE FROM test WHERE id = 2;</pre>
<p>These lines are quite self-explanatory. Note that SELECT statements can also have a WHERE clause. This little SQL is enough to carry us through the remainder of the chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing the Database from Java with JDBC and JdbcTemplate</h1>
                </header>
            
            <article>
                
<p>Before we actually access data, it is good to have some data to play around with. Normally, data is persistent, but in our current setup, H2 will be empty on each start of the application. In cases such as these, Spring Boot offers to execute certain SQL scripts upon application start.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Importing Initial Data</h1>
                </header>
            
            <article>
                
<p>The first script is called <kbd>schema.sql</kbd> and contain SQL statements (DDL) to create the tables used in our application (usually CREATE TABLE statements). The second one is <kbd>data.sql</kbd> and contains SQL statements (DML) to create some data (usually INSERT statements). As resource files, they live in the <kbd>src/main/resources</kbd> folder. The example files for this chapter can be found at <a href="https://bit.ly/2Dzb03G">https://bit.ly/2Dzb03G</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Plain JDBC</h1>
                </header>
            
            <article>
                
<p>JDBC is the standard interface to use relational databases from Java. The initialism means Java Database Connectivity. The standard provides a uniform API to access RDBMS from different vendors. The database driver containing the actual low-level implementation is supplied by the vendor, while the interfaces and common classes are part of the standard Java runtime environment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Plain JDBC Examples</h1>
                </header>
            
            <article>
                
<p>Most of what is found in the API is easy to follow through and well documented. However, it turns out to be quite cumbersome to use. Users need to take a close look at database resources such as connections, and failure to properly close those may exhaust the configured connection limit of the database. All this is complicated by the use of checked exceptions, even in places where nothing can be done about the failure by the application programmer. Consider the following excerpt (full code for all examples to be found in the <kbd>JdbcDemonstratingRepository</kbd> class):</p>
<pre>Connection connection = null;<br/>try {<br/>  connection = dataSource.getConnection();<br/>  Statement statement = null;<br/><br/>  try {<br/>    // […] }<br/>} catch (SQLException e) {<br/>  log.error("Some SQL problem while getting connection", e);<br/>} finally {<br/>  if (connection != null) {<br/>      // close connection and handle exception while closing<br/>  }<br/>}</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2Qm2tnM">https://bit.ly/2Qm2tnM</a> to access the complete code for the <kbd>JdbcDemonstratingRepository.java file</kbd>. This is surely not the way we want to write code. All it does is retrieve a single number!</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Plain JDBC Since Java 7</h1>
                </header>
            
            <article>
                
<p>The bulk of this code is concerned with error handling. Complex queries will require more work on the result set but the same amount of error handling, so the ratio will improve, but for small queries, the overhead is unpardonable. Most people decide not to catch the exceptions in the smallest possible scope, abandoning a bit of accuracy in error reporting. Fortunately, all the mentioned classes implement <kbd>AutoClosable</kbd>, which allows us to write this:</p>
<pre>try (Connection connection = dataSource.getConnection();<br/>    Statement statement = connection.createStatement();<br/>    ResultSet resultSet = statement.executeQuery(SQL_QUERY)) {<br/>   resultSet.next();<br/>   int result = resultSet.getInt(1);<br/>   log.info("plainJdbcTryWithResources success {}", result);<br/>} catch (SQLException e) {<br/>   log.error("Some SQL problem, somewhere", e);<br/>}</pre>
<p>This is really much better and as good as it gets for simple queries. The try-with-resources mechanism ensures that, no matter what errors may arise, all resources will be closed.</p>
<div class="packt_tip"><br/>
For a discussion of possible complications, you may refer to this question on StackOverflow: <a href="https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc">https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">JDBC Resources to Handle</h1>
                </header>
            
            <article>
                
<p>These JDBC resources are as follows:</p>
<ul>
<li>A connection to the database. Everything runs in the context of this, and it incurs network traffic to establish the connection (in the case of a remote database). Transactions and rollback, if required, are on the connection level.</li>
<li>A statement that encapsulates a single SQL statement.</li>
<li>A set of results of the operation. Transmission of this result over the network may well be in chunks and batches; the result may be big (as big as your whole database), so take care to process it correctly.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring to the Rescue – JdbcTemplate</h1>
                </header>
            
            <article>
                
<p>The <kbd>JdbcTemplate</kbd> class is the central class in the Spring JDBC package. It simplifies the use of JDBC and helps to avoid common errors. It can do all the work for simple use cases and provides extension points for callback interfaces for more advanced use cases. In addition, it performs <strong>exception translation</strong>, the usefulness of which will be discussed later in this chapter.</p>
<div class="packt_infobox"><br/>
The name of the class contains the word <strong>template</strong> and is often not well understood. It refers to the <strong>template method</strong> design pattern, which is one of the 23 well-known patterns described in the book <em>Design Patterns</em> (Gamma, Helm, Johnson, Vlissides; Addison-Wesley 1994; ISBN 0-201-63361-2).<br/>
In short, the complete workflow of JDBC (getting the connection, creating a statement, …, closing statement, and returning the connection) is performed within <kbd>JdbcTemplate</kbd>. To make the behavior flexible, this workflow calls callback functions at various places that the user of <kbd>JdbcTemplate</kbd> can optionally provide.</div>
<p>Let's have a look at how simple database access can be:</p>
<pre>int result = jdbcTemplate.queryForObject(SQL_QUERY, Integer.<br/>class);<br/>log.info("jdbcTemplateExample success {}", result);</pre>
<p>Yes, that is really a one-liner!</p>
<p>Of course, this example was trimmed a bit to increase the effect. Nevertheless, even complex scenarios are much easier to handle with <kbd>JdbcTemplate</kbd> than with plain JDBC.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">In detail: Creating the JdbcTemplate</h1>
                </header>
            
            <article>
                
<p>We left out the details of how to get the <kbd>JdbcTemplate</kbd> instance and what side effects will arise. Let's catch up on that now. The following is again an excerpt from the same class:</p>
<pre>@Slf4j<br/>@Repository<br/>@RequiredArgsConstructor<br/>public class JdbcDemonstratingRepository {<br/><br/>  private static final String SQL_QUERY = "select 42 from dual";<br/>  private final DataSource dataSource;<br/><br/>  public void jdbcTemplateExample() {<br/>    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);<br/>    Integer result = jdbcTemplate.queryForObject(<br/>            SQL_QUERY, Integer.class);<br/>    log.info("jdbcTemplateExample success {}", result);<br/>  }<br/>}</pre>
<p>The <kbd>@Repository</kbd> annotation is a Spring annotation that is itself annotated with <kbd>@Component</kbd> and will mark this class as a Spring bean (we have already seen it in <em><a href="9c691a93-c936-4976-b836-8ec08d62bffb.xhtml">Chapter 1</a>: Spring Project and Framework</em>). It is just a more semantic version, just like the <kbd>@Service</kbd> annotation. It will prepare the whole code for exception translation when using JPA, but this is outside the scope of this book.</p>
<p>Spring will wire in an instance of <kbd>javax.sql.DataSource</kbd> for us. This is not a Spring-specific class, but Spring Boot will create it automatically for us in our simple configuration (remember, all we did was add two dependencies to the POM) and connect it to our database, the embedded H2 instance. Such a <kbd>DataSource</kbd> has only one purpose: to acquire database connections.</p>
<p>This DataSource is then used to create an instance of <kbd>JdbcTemplate</kbd>. It is customary to create the instance in the constructor and reuse it throughout the class. It is thread-safe. There may be a need to further configure the template, but when the defaults are fine, there is one even easier way: just autowire the global <kbd>JdbcTemplate</kbd> bean (that is the approach taken in the other repository classes in the example application).</p>
<p>Now we have the instance of the central workhorse of Spring JDBC support and can perform the simple query (it will be explained later). This is the simplest way to use <kbd>JdbcTemplate</kbd>; for more advanced needs, there are a plethora of options that we will explore shortly. But, first, let's turn our attention to a case when there is a failure.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exception Translation</h1>
                </header>
            
            <article>
                
<p>Normally, JDBC throws checked exceptions in the <kbd>SQLException</kbd> hierarchy in the event of a problem. There was and is great debate on whether checked exceptions ever were a good idea in Java. The majority tends to prefer unchecked (or <strong>runtime</strong>) exceptions these days. Spring's <kbd>JdbcTemplate</kbd> will translate these into exceptions in the <kbd>DataAccessException</kbd> hierarchy, which are Spring-specific and unchecked.</p>
<p>As an added benefit, these exceptions are database technology-agnostic. You will also get the same set of exceptions for JPA or access to NoSQL databases.</p>
<p>The exceptions in the <kbd>DataAccessException</kbd> hierarchy are more detailed than those in the <kbd>SQLException</kbd> hierarchy. The following table lists some of the most important ones:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/48093b75-b337-4e8a-917b-0d4c850c2e80.png" style="width:34.50em;height:31.83em;" width="708" height="654"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced Queries</h1>
                </header>
            
            <article>
                
<p>While exploring the <kbd>JdbcTemplate</kbd> class, we come across many methods, most of them overloaded. This is overwhelming at first, but there is a certain multi-dimensional order to it. We have already seen the basic <kbd>queryForObject()</kbd> method in its simplest form, and we are now going to look at some of the overloaded versions.</p>
<p>First of all, it is important to note that <kbd>queryForObject()</kbd>, in all its variants, is supposed to return exactly one object. That means the SQL must return one row, and in the basic version, we have seen, only a single column. Otherwise, it will throw <kbd>IncorrectResultSizeDataAccessException</kbd>. It will not return null except when the query returns an SQL NULL.</p>
<p>The examples up to now built upon a simple SQL query that you can find in <kbd>JdbcDemonstratingRepository: SELECT 42 FROM dual</kbd>. This query does not contain any variable parts, it will return exactly one row with exactly one column of the integer type. First, let's add some variation by introducing variables.</p>
<div class="packt_infobox"><br/>
What is <strong>dual</strong>? A standard SQL SELECT query requires not only the values or column names (right after the SELECT), but also a table expression to draw the data from. Many databases are generous in what they accept here, and you can just leave out the FROM part when selecting constant values.</div>
<p class="mce-root">Other RDBMS, however, are strict, notably Oracle. You have to give a table here, and take note that the constant will be returned once for each row in the table. For that purpose, Oracle comes with a predefined table, DUAL. It has one column, DUMMY, defined to be VARCHAR2(1), and contains one row with a value X. Others RDBMS have adopted this, as you have seen with H2 here.</p>
<p class="mce-root">Variable parts in queries are marked with a single question mark, which substitutes an SQL expression. We can change the SQL query like this:</p>
<pre>SELECT 42 + ? FROM dual</pre>
<p>The intention is clear, but how do we pass a value to this? The <kbd>queryForObject()</kbd> method is overloaded for this purpose with an <kbd>Object... args</kbd> parameter, so the simplest thing to do is just add the additional value at the end of the call! (There is also another overloaded version, taking an <kbd>Object[] args</kbd> parameter, that stems from before <kbd>var-arg</kbd> parameters were introduced in Java. We will ignore this version.)</p>
<pre>Integer result = jdbcTemplate.queryForObject(<br/>       "SELECT 42 + ? FROM dual", Integer.class, 23);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other Result Types</h1>
                </header>
            
            <article>
                
<p>All our queries up to now contained a single <kbd>Integer.class</kbd> parameter to map the result from the database to a Java type. Most SQL types map into Java types quite naturally, and there is a lot of flexibility; we could have used <kbd>BigDecimal.class</kbd> or even <kbd>double.class</kbd> instead. To demonstrate that, let's query the database for its current time:</p>
<pre>log.info("{}", jdbcTemplate.queryForObject(<br/>       "SELECT now() FROM dual", Timestamp.class));<br/>log.info("{}", jdbcTemplate.queryForObject(<br/>       "SELECT now() FROM dual", LocalDateTime.class));</pre>
<p>This demonstrates nicely that we can either use <kbd>java.sql.Timestamp</kbd>, a low-level type created to match closely the values that an SQL database driver may return, or the new <kbd>Java 8 DateTime-API type LocalDateTime</kbd>. These conversions are conveniently performed for us by Spring!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Returning Multiple Values</h1>
                </header>
            
            <article>
                
<p>If there is more than just one value in the result set, or if there may be zero, it is better to request a list of results, and <kbd>JdbcTemplate</kbd> offers just such a method:</p>
<pre>log.info("{}", jdbcTemplate.queryForList(<br/>       "SELECT fullname FROM author", String.class));</pre>
<p>This will get us a list of all the full names of all the authors in the database (remember they were imported in the <kbd>data.sql startup</kbd> script): [Administrator, Peter Quinn, Paul Nipkow, Catherine Sakai].</p>
<p>The restriction that remains is that the query may only return a single column to convert into the given type. The next step is to query multiple columns at once.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Returning Structured Data</h1>
                </header>
            
            <article>
                
<p>A query that returns more than one column poses the problem of how to represent these columns in Java. There are two approaches to tackle this—return the data as a map or make use of callback functions. The map approach is very convenient for one-off queries:</p>
<pre>log.info("{}", jdbcTemplate.queryForMap(<br/><br/>      "SELECT username, fullname FROM author WHERE id = 1"));</pre>
<p>The result is a <kbd>Map&lt;String, Object&gt;</kbd>, which in this case contains <kbd>{USERNAME=admin, FULLNAME=Administrator}</kbd>. (Note that H2 returns column names all in uppercase, even if it accepts them as lowercase in the query.)</p>
<p>The corresponding call to get a list is this:</p>
<pre>log.info("{}", jdbcTemplate.queryForList(<br/>       "SELECT username, fullname FROM author"));</pre>
<div class="packt_tip"><br/>
Note that there is a slight asymmetry here; to get a map instead of a single object, we have to change <kbd>queryForObject()</kbd> into <kbd>queryForMap()</kbd>, while to get a list of maps instead a list of single objects, we use the same <kbd>queryForList()</kbd> call, but leave out the expected type.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mapping Rows</h1>
                </header>
            
            <article>
                
<p>Using maps is simple, but we would prefer proper objects for our application instead of these maps. Instead of taking the maps and converting them afterward, Spring allows us to tap into the process of mapping each row of a result into a list element, using the <kbd>RowMapper&lt;T&gt;</kbd> interface. This interface is generic; its type parameter determines the type of the return value of the query method:</p>
<pre>RowMapper&lt;Author&gt; authorRowMapper = new RowMapper&lt;Author&gt;() {<br/>  @Override<br/>  public Author mapRow(ResultSet rs, int rowNum) throws<br/>SQLException {<br/>  return Author.builder()<br/>          .username(rs.getString("username"))<br/>          .fullName(rs.getString("fullname"))<br/>          .build();<br/>  }<br/>};<br/>log.info("{}", jdbcTemplate.query(<br/>       "SELECT username, fullname FROM author", authorRowMapper));</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mapping Rows (short)</h1>
                </header>
            
            <article>
                
<p>Luckily, <kbd>RowMapper&lt;T&gt;</kbd> is and always has been an interface with just one abstract method, which allows us to use it as a functional interface in Java 8. Thus, the previous code can be shortened to the following:</p>
<pre>log.info("{}", jdbcTemplate.query(<br/>       "SELECT username, fullname FROM author",<br/>       (rs, rowNum) -&gt; Author.builder()<br/>               .username(rs.getString("username"))<br/>               .fullName(rs.getString("fullname"))<br/>               .build()));</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Of course, the mere mention of <kbd>RowMapper&lt;Author&gt;</kbd> in the extended version also serves as a kind of documentation; the second version mentions neither the type nor the actual mapping of rows. This is made worse by the fact that the <kbd>query()</kbd> method allows two further callbacks to be given: <kbd>RowCallbackHandler</kbd> and <kbd>ResultSetExtractor&lt;T&gt;</kbd>. So, look out for the two parameters <kbd>rs</kbd> and <kbd>rowNum</kbd> to spot the <kbd>RowMapper&lt;T&gt;</kbd> or store the mapper in a variable. Often, the following may be the most readable compromise:</p>
<pre>RowMapper&lt;Author&gt; authorRowMapper =<br/>    (rs, rowNum) -&gt; Author.builder()<br/>        .username(rs.getString("username"))<br/>        .fullName(rs.getString("fullname"))<br/>        .build();<br/>log.info("{}", jdbcTemplate.query(<br/>        "SELECT username, fullname FROM author",<br/><br/>        authorRowMapper));</pre>
<p>One other very important thing to note is that a <kbd>RowMapper&lt;T&gt;</kbd> is supposed to directly map one row to one object. In particular, authors are not supposed to <kbd>call next()</kbd> on the given SQL <kbd>ResultSet</kbd>. In many cases, this is just what we want.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced Mapping: Row-Spanning</h1>
                </header>
            
            <article>
                
<p>Sometimes, more than one row of the <kbd>ResultSet</kbd> will be mapped into just one entity in our application. This technique has been used in <kbd>AuthorRepository</kbd> in the database-intro application. Why would we want that?</p>
<p>An author can have more than one role, and the way to map this into tables in an RDBMS is to split the entity in two tables: one for the author proper, and one for the roles. To fetch the author by name, there are two methods.</p>
<p>First, fetch the author's row from the author table by name and look up the ID. Then, using that ID, fetch the roles from the role table. This is very straightforward but requires two trips to the database.</p>
<p>We can fetch from both the author and the role table at once using an SQL JOIN operation. For an author with just one role, this is straightforward as well, but when an author has more than one role, then the operation will return the author data more than once. Therefore, we need to advance the result set and de-duplicate it.</p>
<p>The overhead caused by the data duplication in the second method is usually less than that from the two round trips to the database. Of course, all this optimization is unnecessary for our small application, and often even for big applications.</p>
<p>In our repository, we use <kbd>ResultSetExtractor&lt;Author&gt;</kbd> to create author instances. In contrast to what happens in <kbd>RowMapper&lt;T&gt;</kbd>, the <kbd>extractData(ResultSet rs)</kbd> method has the result set as its only parameter and can process it in whatever way it wishes. This is closer to handwritten JDBC code; in particular, this time we need to call <kbd>next()</kbd> on the <kbd>ResultSet</kbd> to advance the cursor.</p>
<p>Note that both in <kbd>RowMapper&lt;T&gt;</kbd> and in <kbd>ResultSetExtractor&lt;T&gt;</kbd>, we do not have to worry about exceptions, since the <kbd>JdbcTemplate</kbd> will take over the exception translation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CRUD Operations</h1>
                </header>
            
            <article>
                
<p>The acronym <strong>CRUD</strong> reminds us of the types of database operations that we usually perform. The four letters stand for <strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong>, and <strong>Delete</strong>. They more or less correspond to the SQL keywords <kbd>INSERT</kbd>, <kbd>SELECT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd>. Up to now, we have only covered reading, so we now turn to the other three.</p>
<p>Reading is different than the others in that it returns data, while the other three return an update count at most. In a wider sense, creating rows and deleting them is also an update to the database, and so there is only one call in <kbd>JdbcTemplate</kbd> to cater for all these needs— <kbd>update()</kbd>. Its use is very straightforward:</p>
<pre>int updateCount = jdbcTemplate.update(<br/>"INSERT INTO role(author_id, role) VALUES(4, 'ADMIN')");<br/>log.info("{} rows updated", updateCount);</pre>
<p>This statement will add a role the user cate by inserting a row with that value into the database. The call returns the number of updated rows, which is one, as expected.</p>
<p><kbd>UPDATE</kbd> and <kbd>DELETE</kbd> work just the same.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Schema Updates</h1>
                </header>
            
            <article>
                
<p>Only a short-lived application has no need to change. If you have a long-lived application, the requirements will change over time. And as your requirements change, so does your application. Finally, you will find that your data model needs to evolve as well.</p>
<p>In this latter example, adding the new table is not enough; we also need to migrate the existing data from the old column to the new table and subsequently drop the old, now useless, column.</p>
<p class="mce-root"/>
<p>You need to make sure that your code and your database stay compatible. Doing this with the methods we have seen so far is difficult and error-prone. We want to keep the schema and the code close, within the same code base, and not tell the operations department to perform certain steps during deployment. For very simple cases only, we can use the <kbd>execute()</kbd> method on <kbd>JdbcTemplate</kbd> to perform schema changes.</p>
<p>There are tools and libraries to support us in this endeavor. There is <strong>Flyway</strong>, which we will look at in a minute, and <strong>Liquibase</strong>. Both are available both as a Java library and as a command-line tool. Liquibase has a lot more features, but, as is so often the case, it is also quite a lot more complicated. Many users find that they have no need for all the advanced features. The general advice is to stick to Flyway, and to keep Liquibase at the back of your mind in case you ever find that you actually need more.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Database Migrations with Flyway</h1>
                </header>
            
            <article>
                
<p>Flyway helps to keep your code and your database schema in sync by keeping both of them in the same place, your source code repository. Our introductory app sported something similar, yet quite trivial—the <kbd>schema.sql</kbd> file that contains the SQL to create the database schema, is part of the source code. This, however, assumes an empty database. For an in-memory database which is started alongside the application, that is good enough.</p>
<p>In most applications, the data in the database will far outlive the runtime of the application; this is, in fact, the whole point of using a DBMS in the first place assuming an empty database will not cut it. When we release a new version of our software, we have to change the database accordingly to match this. One very effective way to do that is to run this change upon the first start of the new application before it actually reads any data. This change in the schema and data is called a <strong>migration</strong>.</p>
<p>Take a look at how Java and SQL evolved side by side:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/3bdcb03e-e531-4f98-9d25-4c66c5ca209d.png" style="width:30.00em;height:41.75em;" width="594" height="828"/></div>
<p>Of course, we need to keep track of which changes are already in the database. This is where Flyway comes into the game. Each migration necessary for keeping the database in sync with the application is stored alongside the application, and Flyway remembers that a migration has already run, and will run it only once.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing Flyway</h1>
                </header>
            
            <article>
                
<p>The aim is to utilize Flyway for schema migrations. You want to add migrate your schema alongside your application. You want that<br/>
to happen automatically on startup, so you decide to use Flyway and Spring Boot's excellent support for it.</p>
<p>Before beginning, locate the database-intro app at <a href="https://bit.ly/2zeKkl7">https://bit.ly/2zeKkl7</a>. The steps for completion are as follows:</p>
<ol>
<li>In the POM, in a convenient spot within the <kbd>&lt;dependencies&gt;</kbd> element (right after the other two database dependencies would be just splendid), add the following dependency:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;<br/>    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<ol start="2">
<li>In the <kbd>src/main/resources</kbd> folder, create a new folder, <kbd>db</kbd>.</li>
</ol>
<div class="packt_infobox"><br/>
This is most easily done right from within IntelliJ IDEA: Right-click on <kbd>resources</kbd> in the tree and choose <span class="packt_screen">New Directory</span>.<br/>
In this newly created <kbd>db</kbd> folder, create a new folder, <kbd>migration</kbd>. This is the place where Flyway expects its database migrations by default.</div>
<ol start="3">
<li>Move the <kbd>schema.sql</kbd> and <kbd>data.sql</kbd> files from the <kbd>resources</kbd> folder into the new <kbd>db/migration</kbd> folder.</li>
<li>Rename <kbd>schema.sql</kbd> to <kbd>V01__initial.sql</kbd> and <kbd>rename data.sql</kbd> to <kbd>V02__data.sql</kbd>.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">  Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ac7a20be-26ea-4186-941e-27f43926d675.png" style="width:24.08em;height:28.08em;" width="309" height="361"/></div>
<div class="packt_infobox"><br/>
Renaming can be done in IntelliJ IDEA by pressing <em>Shift + F6</em>. In both cases, the important thing is the prefix before the two underscores (and the <kbd>.sql</kbd> suffix), while the rest of the name is informational.</div>
<ol start="5">
<li>Start the application. It behaves just as before.</li>
</ol>
<p>In the log you will find these lines:</p>
<pre class="mce-root">Successfully validated 2 migrations (execution time 00:00.027s)<br/>Creating Schema History table: "PUBLIC"."flyway_schema_history"<br/>Current version of schema "PUBLIC": &lt;&lt; Empty Schema &gt;&gt;<br/>Migrating schema "PUBLIC" to version 01 - initial<br/>Migrating schema "PUBLIC" to version 02 - data<br/>Successfully applied 2 migrations to schema "PUBLIC" (…)</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2NEFqG9">https://bit.ly/2NEFqG9</a> to access the code for the <kbd>DatabaseIntroApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flyway – Behind the Scenes</h1>
                </header>
            
            <article>
                
<p>The log lines on the application's startup tell the whole story. Flyway records all migrations in a database table called <kbd>flyway_schema_history</kbd>.</p>
<p>You can have a look at the schema history table in the H2 console, if you want. Note, however, that the table really is called <kbd>flyway_schema_history</kbd>, in lowercase. To view everything in it, you can use SQL as follows:</p>
<pre>SELECT * FROM "flyway_schema_history"</pre>
<p>The same is true for all the columns:</p>
<pre>SELECT "installed_rank", "version", "description",<br/>"type", "script", "checksum", "success"<br/><br/>FROM "flyway_schema_history"</pre>
<p>The result will be the following:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d40029c1-8fae-415a-991c-b21a2bcf83e1.png" style="width:33.08em;height:9.25em;" width="490" height="137"/></div>
<p>If the table does not exist yet, Flyway will create it on the fly, and that is what will happen on each start with our in-memory-only database. In such a case, the current version of the schema will be empty as well.</p>
<p>Flyway finds all migrations on the classpath under <kbd>db.migration;</kbd> in our case, there are two files. All migration filenames start with the version number — an uppercase V followed by a number, which may be subdivided by single underscores or dots. Double underscores delimit the version number from an arbitrary name; this is the human-readable part. Flyway orders the migrations by the numerical value of their version. The leading zero in the previous names is only for proper lexical ordering in file views.</p>
<p>Then, Flyway executes all migrations that have not already run (all of them in the initial case). Flyway will also compute a checksum of all of the files. Remember that once applied, a migration will not be executed again. Changing it would have no effect and is likely to be an error, so Flyway will refuse to continue if any checksum does not match anymore.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Non-Trivial Migrations</h1>
                </header>
            
            <article>
                
<p>The migrations seen so far allow you to evolve the database schema alongside the Java source code throughout the lifetime of the application. Flyway has two extensions that allow us to handle exceptional cases.</p>
<p>Sometimes, we may want to support different database systems with our codebase, for instance, an H2 database for testing and an Oracle database for production. Mostly we can use the same SQL, but not always. In this case, we can use vendor-specific SQL. To use that, we need to configure the path to the migrations to contain the vendor. One possible setting in our <kbd>application.properties</kbd> could be this:</p>
<p><kbd>spring.flyway.locations=db/migration/{vendor},db/migration</kbd></p>
<p>The placeholder <kbd>{vendor}</kbd> will be replaced by the real database driver. For instance, when using MySQL, Flyway will search in <kbd>db/migration/mysql</kbd> first and then in <kbd>db/migration</kbd>.</p>
<p>Another case may be when a migration includes complicated computations that cannot be done in SQL alone, or that are much easier to do in Java. For these cases, Flyway also supports Java migrations. Spring Boot makes using these a breeze. All we have to do is create beans that extend <kbd>BaseFlywayCallback</kbd>; the order can be specified with the <kbd>@Order</kbd> annotation. Within the bean, we can have the <kbd>Datasource</kbd> injected and use <kbd>JdbcTemplate</kbd> as we have already seen.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Outlook – Advanced Database Support</h1>
                </header>
            
            <article>
                
<p>To round things up, let's have one final look into some advanced sections that are otherwise outside the scope of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">External Databases</h1>
                </header>
            
            <article>
                
<p>Up to now, we have made use of an in-memory database. Spring Boot did a lot of work for us behind the scenes. The database management system was auto-detected, started, and the connection to the database automatically established.</p>
<p>This setup is perfect for exploring database technology. It can also be used in production. H2 is lightweight and fast. It can also be configured to actually save all data to disk. Then it will be persistent, as long as that file survives. If you only have this one client (your application), and the data fits into your memory, H2 is an option to consider.</p>
<p>Production-ready databases offer a plethora of other features. They can store more data, they can be distributed, have fail-over and backup strategies, security, multitenancy, and much more. These generally run on a host of their own. That brings us to the question of how to access them from Spring Boot. The solution is extremely simple. All we have to do is set three properties: the URL, the user, and the password. Here is an example:</p>
<pre>spring.datasource.url=jdbc:mysql://localhost/test<br/>spring.datasource.username=dbuser<br/>spring.datasource.password=dbpass</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Connection Pooling</h1>
                </header>
            
            <article>
                
<p>Getting a JDBC connection is quite a slow operation for most databases. It can take longer than the query itself. It is not efficient to get a new connection for each JDBC statement. However, using a connection for many statements requires very careful resource management.</p>
<p>The standard technique to solve this challenge is to use a connection pool, where connections are held in a store for later reuse. A number of such pool implementations exist. To use one, we have to do nothing at all!</p>
<p>Spring Boot will automatically use HikariCP as its connection pool when it is on the classpath. Since spring-boot-starter-jdbc depends on HikariCP, it is already found and configured with sensible defaults.</p>
<p>If HikariCP is not on the classpath for some reason, the first fallback will be the Tomcat pooling <kbd>Datasource</kbd>, which you will also have available on a web project. It is actually hard not to get connection pooling with Spring Boot.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other Database Technologies – JPA and Spring Data</h1>
                </header>
            
            <article>
                
<p>JPA is a Java standard to access a database that given a level of abstraction. It maps Java classes to database tables automatically or with the help of annotations, and is therefore also called an object-relational mapper, or ORM. The most widely known implementation of JPA is Hibernate, and the two terms are sometimes used interchangeably (even though falsely).</p>
<p class="mce-root"/>
<p>Spring Boot supports this with the spring-boot-starter-data-jpa POM. In addition to the normal JPA capabilities, this also includes Spring Data, a Spring sub-project that allows us to write DAOs (or repositories) by just creating the interface. Such a repository may just look like this:</p>
<pre>public interface CityRepository extends Repository&lt;City, Long&gt; {<br/>  List&lt;City&gt; findAll();<br/>  City findByNameAndCountryAllIgnoringCase(<br/>        String name, String country);<br/>}</pre>
<p>The <strong>implementation</strong> of this interface will be created on the fly upon startup. JPA may not be the best choice in every project. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other Database Technologies – jOOQ</h1>
                </header>
            
            <article>
                
<p>Accessing the database with JDBC has one serious drawback — by using SQL, we embed another language into our Java programs. The statements are hidden in strings. They will not be checked at compilation time, and they are not type-safe.</p>
<p>There are a number of approaches to tackle this problem. IntelliJ IDEA offers great support for embedded languages in the ultimate edition, but relying solely on the IDE is not a good approach. The alternative is to have a tool that queries the database and generates Java classes from it that reflect the tables in the database.</p>
<p>jOOQ is one such product and it is supported directly by Spring Boot. It offers a fluent API that always starts with an object of the <kbd>DSLContext</kbd> class. If jOOQ is on the classpath, Spring Boot will automatically create such a DSLContext, connected to your global <kbd>Datasource</kbd>, as a Spring Bean. All we have to do is to wire it into a bean of ours and we can use it like this:</p>
<pre>List&lt;LocalDate&gt; = dslContext.selectFrom(AUTHOR)<br/>        .where(AUTHOR.DATE_OF_BIRTH.greaterThan(<br/>                LocalDate.of(1980, Month.JANUARY, 1)))<br/>        .fetch(AUTHOR.DATE_OF_BIRTH);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Creating an SMS Application to Display Multiple Authors</h1>
                </header>
            
            <article>
                
<p><strong>Aim</strong></p>
<p>To create a short message list that can show multiple authors for a single article.</p>
<p><strong>Prerequisites</strong></p>
<p>We build this<span> </span>activity<span> </span>upon the simple message app used in the last two chapters; for simplicity, it is stripped of the login. It already has a human-facing web frontend. You find the source code at <a href="https://bit.ly/2BcfVW1">https://bit.ly/2BcfVW1</a>.</p>
<p><strong>Scenario</strong></p>
<p>You have a working application that needs to evolve; messages can have more than one author now. We need changes to the schema, the existing data, the database access, and the view — we will cover a lot in one go!</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>To start, in the <kbd>ShortMessage</kbd> class, change the author field and change the repository when creating a message.</li>
<li>Change the Thymeleaf <kbd>index.html</kbd> view to accept multiple authors.</li>
<li>Start the app now to verify that everything is displayed as it was before.</li>
<li>Add a new Flyway migration and you need a new table, so copy data from the message and finally drop the column ID.</li>
<li>Add the required code at the start of the <kbd>retrieveAll</kbd> method to make the repository compatible with the database.</li>
<li>Using this map from article IDs to authors, change the query and the implementation for the second <kbd>jdbcTemplate</kbd> execution.</li>
<li>Start the app now to verify that everything is displayed as it was before.</li>
</ol>
<ol start="8">
<li>Use the H2 console in another browser tab to add some co-authors and immediately see the results after reloading in the original tab.</li>
<li>Create a new migration, <kbd>V04__coauthors.sql</kbd>, with message–author links. When you start the application again, these are visible, as shown in this screenshot:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ffbb8d41-9848-4120-9c9f-4ab5381fec2b.png" style="width:33.92em;height:33.25em;" width="996" height="975"/></div>
<p>The short message list can show multiple authors for a single article.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2Mnhjaw">https://bit.ly/2Mnhjaw</a> to access the code for the <kbd>DatabaseIntroApplicationTests.java</kbd> file.<br/>
Go to <a href="https://bit.ly/2OiSCh4">https://bit.ly/2OiSCh4</a> to access the complete code for the <kbd>DatabaseIntroApplication.java</kbd> file for the solution.<br/>
<span>To refer to the detailed steps, go to the <em>Solutions</em> section at the end of </span><span>this book on page 263.<br/></span></div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this final chapter of the Spring Boot book, our focus was on the data that applications process, and in particular on the data that they persist. Storing data in a database is paramount for many types of applications. We had a brief introduction into relational databases, the workhorses of the industry. Spring makes it easy to access those databases. You connected a lightweight in-memory database and saw how to connect to a production database. You then queried data from that database using SQL and Spring's support class, <kbd>JdbcTemplate</kbd>. To evolve the database alongside the application code, you then used Flyway migrations.</p>
<p>This rounds off the book. You have learned how to develop Spring Boot applications, how to develop web pages backed by Spring applications or offer REST APIs to customers, and how to interface with databases. Spring Boot and the Spring project have much more to offer, and that world is now at your fingertips.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Book Summary</h1>
                </header>
            
            <article>
                
<p>In this book, you learnt about the basic building blocks of a Spring application, Spring application creation, and testing Spring applications. Then, we analyzed the MVC pattern, displaying and editing data using Thymeleaf, and RESTful APIs. Lastly, we implemented the basics of web application security and persisting data using a database.</p>
<p>Thank you!</p>
<p>Here are some closing words of wisdom:</p>
<ul>
<li>If in doubt, check <a href="https://stackoverflow.com/">StackOverflow.com</a>!</li>
<li>Read the Javadoc or even source code of the frameworks or libraries you use, it really helps!</li>
<li>Use open source frameworks and contribute patches and bug reports, or just report documentation errors.</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>