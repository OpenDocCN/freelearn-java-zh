- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless Computing and Java’s Concurrent Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless computing has revolutionized application deployment and management,
    allowing developers to focus on writing code while cloud providers handle the
    underlying infrastructure. This chapter explores the essentials of serverless
    computing and how Java’s concurrent capabilities can be effectively utilized in
    this environment. We’ll delve into the fundamental concepts of serverless computing,
    its advantages, specific scenarios where it’s particularly beneficial, and the
    trade-offs involved.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless architectures offer significant benefits in terms of scalability,
    cost efficiency, and reduced operational overhead, but they also come with challenges
    such as cold start latency, resource limits, and vendor lock-in. Understanding
    these trade-offs is crucial for making informed decisions about when and how to
    use serverless computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of serverless computing in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting Java’s concurrency model to serverless environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introducing serverless frameworks and services: AWS SAM, Azure Functions Core
    Tools, Google Cloud Functions, and Oracle Functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Industry examples of Java serverless functions with a focus on concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A practical approach to building with serverless frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll explore how Java’s concurrency features can be adapted to serverless environments,
    enabling the development of scalable and efficient applications. Through practical
    examples and code snippets, you’ll learn how to implement concurrency in Java
    serverless applications, leveraging tools such as ExecutorService, CompletableFuture,
    and parallel streams.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also discuss best practices for optimizing Java serverless applications,
    including minimizing cold starts, efficient resource management, and leveraging
    frameworks such as Spring Cloud Function, Micronaut, and Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be equipped with the knowledge to build and
    optimize Java-based serverless applications, ensuring high performance and responsiveness
    across various cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ll need the AWS **Command Line Interface** (**CLI**) installed and configured:
    [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the instructions for doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit the official AWS CLI installation page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your operating system (Windows, Mac, or Linux) and download the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer and follow the on-screen instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After installation, configure your AWS CLI with credentials using the aws configure
    command. You’ll need your access key ID and secret access key, which can be found
    in your AWS IAM console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’ll also need the AWS Serverless Application Model CLI for deploying serverless
    applications: [https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the instructions for that:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit the official AWS SAM CLI installation page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the instructions for your operating system (Windows, Mac, or Linux).
    These typically involve downloading and running a script or installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After installation, verify the installation by running sam --version in your
    terminal. This should display the installed version of the AWS SAM CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of serverless computing in java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless computing is a cloud-computing execution model that has revolutionized
    the way applications are developed and deployed. In this model, the cloud provider
    dynamically manages the allocation and provisioning of servers, allowing developers
    to focus on writing code without worrying about the underlying infrastructure.
    Although applications still run on servers, the management of these servers, including
    scaling and maintenance, is entirely handled by the cloud provider. This approach
    marks a significant departure from traditional server-based architectures, where
    developers are responsible for managing and maintaining the servers that host
    their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Core concepts of serverless computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serverless architectures are built around several core concepts. One of the
    key concepts is the event-driven approach, where functions are executed in response
    to various triggers such as HTTP requests, database events, and device activity.
    This model is particularly well suited for Java developers because Java’s concurrency
    features, such as multithreading and asynchronous processing, align seamlessly
    with the event-driven nature of serverless computing. Additionally, Java’s extensive
    ecosystem of libraries and tools enhances its integration with cloud functions
    from providers such as Amazon AWS Lambda, Google Cloud, and Azure Functions. These
    attributes make Java a powerful choice for developing scalable and efficient serverless
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another crucial concept is statelessness, which means that functions typically
    execute without retaining any state between invocations. This enables high levels
    of scalability, as multiple instances of a function can run concurrently without
    interfering with each other. However, functions can also be designed to be stateful
    by using external data sources or services, such as AWS Lambda with an external
    database or Kalix for stateful serverless applications. Serverless platforms also
    provide automatic scaling based on demand, eliminating the need for manual scaling
    and ensuring that applications can handle variable workloads efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, serverless computing simplifies backend development by offloading
    routine tasks such as server and database management to the cloud provider, allowing
    developers to focus on writing business logic. Finally, serverless architectures
    are highly compatible with microservice architectures, enabling the independent
    deployment of discrete pieces of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, Java has not been the first choice for serverless computing due
    to its verbose syntax and slower startup times compared to languages such as Python
    or JavaScript. However, recent developments in frameworks such as Quarkus and
    Micronaut have significantly reduced Java’s startup time and memory usage, boosting
    its suitability for serverless environments. While Spring Native initially showed
    promise in this area, it has since been deprecated in favor of the official native
    support integrated into Spring Boot 3+. This new native support within Spring
    Boot 3+ offers enhanced features and capabilities, enabling Java developers to
    create efficient, scalable serverless applications that fully leverage the advantages
    of cloud-native architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of and scenarios for using serverless computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serverless computing offers several compelling advantages, particularly in terms
    of scalability, cost-effectiveness, and reduced operational overhead.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most significant benefits is enhanced scalability. Serverless architectures
    can instantly and automatically scale up or down based on the demand for the application.
    This means that during peak traffic periods, the application can seamlessly handle
    increased loads without any manual intervention. Additionally, the stateless nature
    of serverless functions allows them to run concurrently and in parallel, enabling
    high throughput and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Another key advantage of serverless computing is cost-effectiveness. With a
    pay-per-use pricing model, you only pay for the resources your functions consume
    during their execution time. This eliminates the costs associated with idle compute
    resources, making it an attractive option for applications with variable or sporadic
    workloads. Moreover, serverless computing can reduce the total cost of ownership
    by minimizing the need for ongoing server maintenance and management.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless computing offers the potential for reduced operational overhead.
    By offloading server management tasks such as maintenance, patching, and scaling
    to the cloud provider, developers can focus more on code and functionality. Deployment
    processes are often simplified, allowing for quicker updates and feature releases
    without directly managing infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to note that serverless architectures can introduce
    their own complexities. Managing multiple runtimes for different functions or
    services may require additional configuration and monitoring. This is particularly
    relevant for larger applications where maintaining consistency across diverse
    environments can become challenging. While serverless platforms often provide
    built-in high availability and fault tolerance features, ensuring application
    resilience may still require careful design and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, serverless architectures can easily integrate with other cloud
    services and be automatically triggered by events from these services, enabling
    the creation of highly responsive, event-driven applications and automated workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, serverless computing can be a powerful tool, but it’s important to
    evaluate its suitability for your specific use case and understand the potential
    trade-offs involved.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks and trade-offs of serverless computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While serverless computing offers numerous benefits, it also comes with several
    trade-offs and potential drawbacks that developers must consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cold starts**: One of the most commonly cited drawbacks is the cold start
    latency. When a serverless function is invoked after a period of inactivity, it
    can take some time to initialize, leading to delays in response times. This can
    be particularly problematic for applications requiring low-latency responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource limits**: Serverless platforms impose limits on the execution time,
    memory, and computational resources available to each function. These constraints
    can make it challenging to run long-running processes or compute-intensive tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor lock-in**: Using serverless architectures often ties developers to
    a specific cloud provider’s ecosystem, making it difficult to migrate applications
    to another provider without significant rework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity in debugging and monitoring**: Debugging serverless functions
    can be more complex compared to traditional server-based applications. The ephemeral
    nature of serverless functions and their distributed execution environments can
    complicate the debugging process. Additionally, monitoring and maintaining observability
    across multiple serverless functions requires robust tooling and practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State management**: Serverless functions are inherently stateless, which
    can complicate the management of application state across multiple invocations.
    Developers need to use external storage solutions such as databases or caching
    services to manage state, which can introduce additional complexity and latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost efficiency**: While serverless computing can be cost-effective for many
    use cases, it may not always be the most economical option. High-frequency invocations
    or applications with constant traffic may incur higher costs compared to reserved
    instances or traditional server-based architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security concerns**: The abstraction of infrastructure management in serverless
    computing means that developers have less control over the underlying environment.
    This can introduce security concerns, as vulnerabilities or misconfigurations
    in the cloud provider’s infrastructure can potentially affect the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use serverless?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Combining the advantages outlined previously, here are additional scenarios
    where serverless computing is particularly beneficial:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservice architectures**: Applications designed with microservice architecture,
    where each service is a small, independently deployable unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven applications**: Systems that respond to various events such
    as data streams, user actions, or IoT signals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless processing**: Applications that perform stateless operations, such
    as image processing, data transformation, or **Extract, Transform, Load** (**ETL**)
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it’s important to note that serverless may not be the best fit for
    every scenario. Some situations where serverless might not be ideal include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications with long-running processes or high computational requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workloads that require low-latency responses or have strict performance requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications with complex or stateful workflows that require maintaining server
    state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenarios where you need complete control over the underlying infrastructure
    and operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deciding whether to use serverless, it’s crucial to evaluate your specific
    application requirements, scalability needs, and cost considerations. Serverless
    can offer significant benefits in terms of scalability, cost efficiency, and development
    agility, but it’s important to carefully assess whether it aligns with your application’s
    characteristics and goals.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting Java’s concurrency model to serverless environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless computing presents unique challenges for Java’s traditional concurrency
    model. The ephemeral and stateless nature of serverless functions necessitates
    a shift from long-lived thread pools and shared mutable state to more dynamic
    and isolated concurrency patterns. In this context, developers must focus on designing
    concurrency strategies that align with the short-lived, event-driven nature of
    serverless architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Effective serverless concurrency in Java revolves around maximizing function
    efficiency within strict time and resource constraints. This involves leveraging
    asynchronous operations, particularly through CompletableFuture, to handle non-blocking
    I/O tasks and optimize throughput. Developers should structure their code to process
    events efficiently, a central tenet of serverless design.
  prefs: []
  type: TYPE_NORMAL
- en: When using CompletableFuture for asynchronous processing in serverless functions,
    it’s crucial to consider the function’s execution time limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This demo showcases how to use `CompletableFuture` for asynchronous processing
    in a serverless function. By performing database queries and API calls concurrently,
    the function minimizes the overall execution time and improves responsiveness.
    This is particularly beneficial in serverless environments where reducing execution
    time can lead to cost reduction and better scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For data processing, while parallel streams can be beneficial, it’s important
    to consider the trade-offs in a serverless context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This demo illustrates the use of Java’s parallel streams to process large datasets
    in a serverless function. By conditionally using parallel streams based on the
    data size, the function can efficiently utilize multiple CPU cores to process
    data concurrently. This approach significantly enhances performance for large
    datasets, making the function more scalable and responsive in serverless environments.
  prefs: []
  type: TYPE_NORMAL
- en: As serverless computing continues to gain popularity, Java’s concurrency features
    will play a crucial role in enabling developers to build scalable, responsive,
    and high-performance serverless applications. To further optimize Java serverless
    applications, let’s explore best practices in design and the use of frameworks
    and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Designing efficient Java serverless applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To ensure optimal performance and cost-efficiency in Java serverless applications,
    it’s crucial to follow best practices in design and leverage appropriate frameworks
    and libraries. Here are the key guidelines and recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimizing cold starts**: Cold starts occur when a new instance of a serverless
    function is provisioned. To reduce cold start times, developers can employ several
    techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Lambda SnapStart**: SnapStart optimizes the initialization process by
    taking a snapshot of the initialized execution environment and restoring it when
    needed, significantly reducing cold start latency. To use SnapStart, enable it
    in your Lambda function configuration and ensure your code is compatible with
    serialization.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable provisioned concurrency**: This feature keeps functions warm by pre-initializing
    instances, ensuring quick response times. Set up provisioned concurrency in your
    Lambda function settings based on expected traffic patterns.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize Java Virtual Machine runtime with custom images**: Tools such as
    GraalVM Native Image can compile Java applications into native executables, reducing
    startup time and memory consumption. To use custom images, do the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build your application using GraalVM Native Image.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom Lambda runtime using AWS Lambda Runtime Interface Client.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Package your native executable with the custom runtime.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the package as a Lambda function.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional optimizations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize dependencies in your function to reduce package size
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lazy loading for non-essential resources
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement caching strategies for frequently accessed data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize your code for quick startup, moving initialization logic out of the
    handler method where possible
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient memory and** **resource management**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right-size function memory**: Allocate sufficient memory to avoid performance
    bottlenecks while being mindful of costs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize code execution**: Write efficient code to reduce execution time,
    avoiding heavy initialization logic within the function handler.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection pooling**: Use Amazon RDS Proxy for managing database connections
    effectively, as traditional connection pooling libraries such as HikariCP are
    not recommended for serverless use.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless design**: Design functions to be stateless to ensure scalability
    and avoid state management issues. Use external storage services such as Amazon
    **Simple Storage Service** (**S3**), DynamoDB, or Redis for state persistence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient** **data handling**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use streams for large data**: Stream processing helps to handle large datasets
    without loading all data into memory. Java’s Stream API is useful for this purpose.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize serializations**: Use efficient serialization libraries such as
    Jackson for JSON processing and optimize serialization/deserialization processes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring** **and logging**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated logging**: Use centralized logging services such as AWS CloudWatch
    Logs and structure logs for easy tracing and debugging.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance monitoring**: Tools such as AWS X-Ray are helpful for tracing
    and monitoring the performance of serverless functions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Java-specific optimization techniques for AWS Lambda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Java developers working with AWS Lambda, there are various techniques available
    to optimize the runtime performance of your functions. These techniques can help
    you minimize cold start times, reduce memory usage, and improve overall execution
    speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application class data sharing (AppCDS)**: Improves startup time and memory
    footprint by saving the metadata of loaded classes into an archive file, which
    can be memory-mapped during subsequent JVM startups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+TieredCompilation -XX:TieredStopAtLevel=1`, to balance startup time and
    long-term performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leveraging GraalVM native image**: Compiling your Java application into a
    native executable can significantly reduce cold start times and memory usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frameworks and libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Spring Cloud Function** simplifies serverless development by enabling developers
    to write cloud-agnostic functions using standard Java interfaces and Spring annotations.
    This allows for local creation, testing, and deployment, followed by seamless
    execution on various cloud infrastructures without code modifications. It supports
    an event-driven architecture, handling triggers such as HTTP requests, message
    queues, and timers, while its auto-discovery and registration of functions streamline
    the development process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, consider a simple Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Within this Spring Boot application, Spring Cloud Function automatically registers
    the `uppercase()` method as a function. When triggered, Spring Cloud Function
    maps incoming requests to the corresponding function, executes it with the provided
    input, and returns the result. This abstraction layer allows for seamless deployment
    across diverse serverless environments, freeing developers to focus solely on
    business logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Micronaut**, renowned for its fast startup times and minimal memory footprint,
    presents an ideal choice for building serverless functions. Designed for creating
    lightweight and modular JVM-based applications, Micronaut seamlessly integrates
    with popular serverless platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple Micronaut function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `@FunctionBean("helloFunction")` annotation designates the
    `HelloFunction` class as a Micronaut function bean. The `HelloFunction` class
    extends `FunctionInitializer` and implements the Function interface, specifically
    for processing API Gateway HTTP events (`APIGatewayV2HTTPEvent`).
  prefs: []
  type: TYPE_NORMAL
- en: The overridden `apply()` method efficiently handles incoming requests, returning
    an `APIGatewayV2HTTPResponse` with a status code of 200 and the message `"Hello
    World"` in the body. This setup allows for easy deployment of the function to
    various serverless platforms, including AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '`GraalVM` and `OpenJDK HotSpot`. Its design prioritizes fast boot times and
    low memory consumption, making it a compelling choice for serverless applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a basic Quarkus function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet showcases a serverless function built with Quarkus. The `GreetingLambda`
    class features a `handleRequest()` method specifically crafted to manage incoming
    AWS API Gateway requests (`APIGatewayProxyRequestEvent`). This method processes
    the request and constructs an `APIGatewayProxyResponseEvent`, returning a 200
    status code along with a personalized greeting that incorporates the request body.
  prefs: []
  type: TYPE_NORMAL
- en: While this function is inherently tailored for deployment on AWS Lambda, adapting
    it for Azure Functions or Google Cloud Functions necessitates modifications to
    accommodate the distinct mechanisms these platforms employ for handling HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda Java libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon provides a set of libraries specifically designed for building serverless
    applications on AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/lambda-java.html](https://docs.aws.amazon.com/lambda/latest/dg/lambda-java.html)),
    which greatly simplifies the process of integrating with other AWS services. These
    libraries are tailored to streamline the development of Lambda functions, ensuring
    they can efficiently interact with various AWS resources and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a simple AWS Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code demonstrates how to utilize AWS Lambda Java libraries to build a serverless
    function that responds to S3 events. The `RequestHandler` interface and `S3Event`
    class are provided by the `aws-lambda-java-core` and `aws-lambda-java-events`
    libraries respectively. The `context` object offers runtime information and a
    logger for the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: By adhering to best practices and leveraging the right frameworks and libraries,
    developers can build efficient and scalable Java serverless applications. These
    practices ensure reduced latency, optimal resource usage, and easier maintenance,
    while the frameworks and libraries provide powerful tools to streamline development
    and deployment processes. Moving forward, applying these principles will help
    in achieving high-performance serverless applications that meet modern cloud computing
    demands.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing serverless frameworks and services – AWS SAM, Azure Functions Core
    Tools, Google Cloud Functions, and Oracle Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To effectively manage and deploy serverless applications across different cloud
    platforms, it is crucial to understand the frameworks provided by AWS, Azure,
    and Google Cloud. These frameworks simplify the process of defining, deploying,
    and managing serverless resources, making it easier for developers to build and
    maintain scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Serverless Application Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AWS **Serverless Application Model** (**SAM**) is a framework for building
    serverless applications on AWS. It extends AWS CloudFormation to provide a simplified
    way of defining serverless resources such as AWS Lambda functions, API Gateway
    APIs, DynamoDB tables, and more. This is illustrated in *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: AWS Serverless Application Model](img/B20937_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: AWS Serverless Application Model'
  prefs: []
  type: TYPE_NORMAL
- en: 'The AWS SAM framework diagram illustrates the interactions and components involved
    in a typical serverless architecture using AWS services. Here’s a breakdown of
    the key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Lambda**: A serverless computing service. It lets you run code without
    provisioning or managing servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon API Gateway**: A fully managed service that allows you to create HTTP
    APIs that act as the front door for your serverless applications. Clients can
    invoke your Lambda functions through these APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**: Events trigger the execution of your Lambda functions. These events
    can originate from different sources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP requests via API Gateway
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in data sources such as S3 buckets or DynamoDB tables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled triggers based on time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon DynamoDB**: A NoSQL database service for storing and retrieving data
    at any scale. Your Lambda functions can interact with Amazon DynamoDB to store
    or retrieve data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon S3**: A scalable object storage service. Your Lambda functions can
    interact with Amazon S3 to store or retrieve files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon SNS/SQSimple**: **Simple Notification Service** (**SNS**) is a pub/sub
    messaging service, while **Simple Queue Service** (**SQS**) is a message queuing
    service. Your Lambda functions can use SNS to publish messages to SQS queues or
    subscribe to receive messages from them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Step Functions**: A service for orchestrating workflows made up of multiple
    Lambda functions. It allows you to define the order of execution and handle errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure *9**.1* depicts a serverless application on AWS built with the AWS SAM
    framework. Users initiate interactions through an API Gateway endpoint, which
    then directs those requests to AWS Lambda functions. These Lambda functions can
    access and process data from various sources such as DynamoDB (database), S3 (storage),
    SNS (messaging), and SQS (queuing). Optionally, AWS Step Functions can be used
    to orchestrate complex workflows involving multiple Lambda functions. By leveraging
    AWS SAM and its templates, developers can create scalable and cost-effective serverless
    applications on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'SAM also allows for local testing of Lambda functions. This is a valuable feature
    that can help developers to debug and troubleshoot their code before deploying
    it to production. There are two ways to test Lambda functions locally: using AWS
    Toolkits or running AWS SAM in debug mode. AWS Toolkits are IDE plugins that allow
    you to set breakpoints, inspect variables, and execute code one line at a time.
    SAM also allows you to run AWS SAM in debug mode to attach to third-party debuggers
    such as ptvsd or Delve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on local testing with SAM, please refer to the AWS documentation:
    [https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions Core Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This **command-line interface** (**CLI**) provides a local development environment
    that mimics the Azure Functions runtime. It allows developers to build, test,
    and debug their functions on their machines before deploying them to Azure. Additionally,
    **Azure Functions Core Tools** integrates with continuous deployment pipelines
    using tools such as Azure DevOps or GitHub Actions. Let’s look at *Figure 9**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Azure Functions Core Tools diagram](img/B20937_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Azure Functions Core Tools diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure *9**.2* illustrates the components and workflow involved in developing,
    testing, and deploying Azure Functions using Azure Functions Core Tools. Here
    is a detailed description:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer**: The developer interacts with the local machine to develop, build,
    test, and debug Azure Functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local Machine**: This is the developer’s environment where Azure Functions
    Core Tools are installed. It provides a local development environment that mimics
    Azure Functions runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Functions Runtime**: This component simulates the Azure Functions runtime
    on the local machine, allowing the developer to execute and test functions locally
    before deploying them to Azure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: These are the individual functions created and managed by the
    developer. They are executed by the Azure Functions runtime and can be deployed
    to Azure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure**: This represents the Azure cloud environment where the functions
    are deployed. Once the functions are tested locally, they are deployed to Azure
    for production use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure DevOps**: This is a set of development tools and services for managing
    the entire application lifecycle. It integrates with Azure Functions Core Tools
    to enable continuous deployment of functions to Azure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Actions**: This is a **Continuous Integration** (**CI**) and **Continuous
    Deployment** (**CD**) platform provided by GitHub. It integrates with Azure Functions
    Core Tools to automate the deployment of functions to Azure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 9**.2* represents the complete workflow of using Azure Functions Core
    Tools for local development, testing, and continuous deployment of Azure Functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google Cloud Functions** is a lightweight, event-driven compute service that
    allows you to run your code in response to events. It is designed for building
    and connecting cloud services with simple, single-purpose functions, as shown
    in *Figure 9**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Google Cloud Functions](img/B20937_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Google Cloud Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.3* illustrates the architecture of Google Cloud Functions, showcasing
    its components and their interactions. Google Cloud Functions is the core component
    where the serverless functions reside. These functions can be triggered by various
    **event sources**, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP request**: Functions can be triggered by HTTP requests, enabling web-based
    interactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Pub/Sub**: Functions can process messages from Cloud Pub/Sub, a messaging
    service that allows you to send and receive messages between independent applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud storage**: Functions can be triggered by events in Cloud Storage, such
    as file creation, modification, or deletion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firestore**: Functions can interact with Firestore, a NoSQL document database,
    to read and write data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other event sources**: Functions can also be triggered by other supported
    event sources, providing flexibility in handling various types of events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This architecture allows developers to build event-driven applications using
    serverless functions, eliminating the need to manage server infrastructure. It
    integrates seamlessly with various Google Cloud services, providing a scalable
    and flexible environment for running event-driven code.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Oracle Functions** is a fully managed serverless platform that allows you
    to run your code without provisioning or managing servers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Oracle Functions](img/B20937_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Oracle Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.4* illustrates Oracle Functions’ architecture, highlighting key
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oracle Functions**: Core serverless compute service built on the open source
    Fn Project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraalVM**: High-performance runtime environment is known for excellent cold
    start performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bare Metal Servers**: Underlying infrastructure for enhanced performance
    and predictability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Gateway**: Manages and routes incoming requests to appropriate functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event sources and triggers**: Various origins and activators of function
    execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key advantages include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: GraalVM on bare-metal servers reduces cold start times and
    enhances overall function performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Versatile function triggering and management through API Gateway
    and diverse event sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Better resource utilization by avoiding container overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main differences from traditional serverless architectures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime**: Uses GraalVM instead of traditional JVM runtimes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: Functions run on bare-metal servers, not virtualized environments
    or containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architecture**: Is container-native but containerless, avoiding common container
    overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foundation**: Based on the open source Fn Project, unlike many proprietary
    offerings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features contribute to Oracle Functions’ focus on high performance and
    efficiency, particularly in cold start times and resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Functions’ bare-metal deployment excels in performance-critical scenarios
    where speed and predictable latency are top priorities. However, for cost-conscious
    applications, containerized options such as AWS Lambda may be more appealing.
    If you prioritize cold starts in Java workloads, Oracle Functions, powered by
    GraalVM, offer a potential advantage. For applications processing highly sensitive
    data, bare-metal’s isolation might be preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Industry examples – Java serverless functions with a focus on concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s dive into some real-world examples of how companies are using Java serverless
    functions and how they handle concurrency in their applications. We’ll explore
    industry examples, extract valuable lessons learned, and examine a code example
    to understand the practical aspects of implementing Java serverless applications
    with concurrency in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Airbnb – optimizing property listings with serverless solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Airbnb, a leading online marketplace for lodging and experiences, employs serverless
    architectures to enhance the management of property listings and user interactions.
    Airbnb uses AWS Lambda to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image processing**: When a host uploads images of their property, an AWS
    Lambda function is triggered to process and optimize the images for various device
    formats and resolutions. This task is performed concurrently to handle *multiple*
    *uploads efficiently*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search indexing**: AWS Lambda functions update search indexes in real time
    as new properties are listed or existing ones are updated. This ensures that users
    receive the most accurate and current search results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By leveraging AWS Lambda, Airbnb ensures high performance, flexibility, and
    reliability in their serverless architecture. Image processing and search indexing
    are performed quickly and efficiently, enhancing user experience. The ability
    to deploy and update serverless functions independently allows for rapid iteration
    and deployment of new features. Additionally, serverless functions provide high
    availability and fault tolerance, maintaining a seamless experience for users.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedIn – enhancing data processing with serverless architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LinkedIn, the world’s largest professional network, utilizes serverless architectures
    to manage and process vast amounts of data generated by user interactions, job
    postings, and content sharing. LinkedIn leverages Azure Functions to handle these
    tasks efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-time notifications**: LinkedIn uses Azure Functions to process real-time
    notifications. When a user receives a connection request or a message, an event
    triggers Azure Functions to process and deliver the notification promptly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data analytics**: Azure Functions process data streams in real-time, aggregating
    metrics and generating insights. This allows LinkedIn to provide users with up-to-date
    analytics on their profiles, such as profile views and search appearances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions enables LinkedIn to achieve scalability, efficiency, and cost-effectiveness
    in their serverless architecture. The automatic scaling capabilities of Azure
    Functions ensure that LinkedIn can handle millions of concurrent user interactions.
    Serverless functions reduce infrastructure management overhead, allowing LinkedIn’s
    engineering team to focus on developing new features. Moreover, the pay-per-use
    pricing model helps optimize costs during varying traffic periods.
  prefs: []
  type: TYPE_NORMAL
- en: Expedia – streamlining travel booking with serverless solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expedia, a global travel booking platform, leverages Java-based AWS Lambda
    functions to handle various aspects of its service, ensuring efficient and reliable
    operations across its platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Booking confirmation**: AWS Lambda functions manage booking confirmations
    in real time. When a user completes a booking, an event triggers a Lambda function
    to confirm the reservation, update the inventory, and notify the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Price aggregation**: Expedia uses Lambda to aggregate prices from multiple
    airlines and hotels concurrently. This ensures that users receive the most competitive
    rates in real time, enhancing the booking experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User notifications**: Lambda functions send personalized notifications to
    users about their bookings, including updates, reminders, and special offers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Lambda enables Expedia to achieve scalability, efficiency, and improved
    user experience in its serverless architecture. The automatic scaling capabilities
    of AWS Lambda allow Expedia to handle peaks in booking volumes seamlessly. Serverless
    functions streamline complex processes, such as price aggregation, by handling
    multiple data sources concurrently. Real-time notifications and confirmations
    enhance the overall user experience, providing timely and relevant information
    to travelers.
  prefs: []
  type: TYPE_NORMAL
- en: These case studies demonstrate how industry leaders leverage serverless architectures
    and concurrency management to optimize their applications. By employing serverless
    solutions, companies can achieve scalability, efficiency, cost-effectiveness,
    and enhanced user experiences in their respective domains.
  prefs: []
  type: TYPE_NORMAL
- en: Building with serverless frameworks – a practical approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless frameworks are the developer’s toolbox for crafting efficient and
    robust serverless applications. These frameworks go beyond the core compute services
    offered by cloud providers, providing a comprehensive set of tools and functionalities.
    In this section, we’ll delve into the importance of serverless frameworks and
    how they streamline the development process. To solidify this understanding, we’ll
    explore a real-world example using code demonstrations. Specifically, we’ll see
    how AWS SAM simplifies defining and deploying serverless applications on AWS.
    By the end of this section, you’ll be equipped to leverage the power of serverless
    frameworks in your own projects!
  prefs: []
  type: TYPE_NORMAL
- en: Using AWS SAM to define and deploy a serverless application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll design a simulation of a global travel booking platform that leverages
    Java-based AWS Lambda functions to handle various aspects of their service. This
    includes booking validation, payment processing, security checks, inventory updates,
    data processing, and user notifications. We’ll use AWS Step Functions to orchestrate
    these tasks, DynamoDB for data storage, AWS Cognito for security checks, and API
    Gateway to expose endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please look at *Figure 9**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: A global travel booking system](img/B20937_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: A global travel booking system'
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this task, we’ll utilize AWS cloud services within a serverless
    architecture. Our approach involves coordinating multiple Lambda functions using
    AWS Step Functions, a service designed to orchestrate complex workflows. This
    allows us to define the order of execution for each function and gracefully handle
    potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: In our travel booking system, several specialized Lambda functions collaborate
    within a *Step Functions* workflow. These functions include `BookingValidationFunction`,
    `PaymentProcessingFunction`, `SecurityCheckFunction`, `InventoryUpdateFunction`,
    `DataProcessingFunction`, and `SendNotificationFunction`. Each function handles
    a specific step in the booking process. In this section, we’ll focus on `BookingValidationFunction`
    as an illustrative example. The Java code for this function is presented below,
    while the code for the remaining functions can be found in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: By using Step Functions, we gain the ability to create a more robust and manageable
    system. Step Functions simplify error handling, provide visibility into workflow
    progress, and enable us to retry failed steps automatically. This results in a
    more reliable and scalable solution for managing the complexities of the travel
    booking process.
  prefs: []
  type: TYPE_NORMAL
- en: '`BookingValidationFunction` is responsible for validating the booking request
    data, ensuring that all required fields and data formats are correct. It also
    verifies the availability of requested items or dates by querying the DynamoDB
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Java code for `BookingValidationFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: BookingValidationFunctionApplication is a Spring Boot application that serves
    as a serverless function for validating booking details.
  prefs: []
  type: TYPE_NORMAL
- en: The `bookingValidation()` method, annotated with `@Bean`, is the main function
    that validates the booking details based on the input data. It checks for the
    presence of required fields, verifies the availability of the booking by querying
    `BookingTable` in DynamoDB (placeholder logic), and returns a response map with
    the validation status.
  prefs: []
  type: TYPE_NORMAL
- en: The class also includes placeholder methods for implementing the validation
    logic `validateBooking()` and availability check logic `verifyAvailability()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the necessary resources in the CloudFormation template. The
    DynamoDB tables `BookingTable` and `InventoryTable` store and manage the booking
    and inventory data respectively, enabling efficient and scalable persistence of
    information related to travel bookings and available inventory items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our serverless architecture, we employ Amazon Cognito to handle user authentication
    and authorization. Cognito is a fully managed service that allows you to easily
    add user sign-up, sign-in, and access control to your web and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we’ll create a Cognito user pool (`CognitoUserPool`). This user
    directory serves as the central repository for our application’s user identities.
    When users register or sign in, Cognito securely stores their information and
    handles the authentication process. It provides features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User management**: Create, read, update, and delete user profiles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication**: Verify user credentials and issue secure tokens (e.g.,
    JWTs) for access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Enforce password policies, multi-factor authentication (MFA),
    and other security measures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Define fine-grained access controls based on user attributes
    or groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Federation**: Integrate with external identity providers such as Facebook,
    Google, or enterprise identity systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By leveraging Cognito, we can offload the complexities of user management and
    focus on building the core functionality of our travel booking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data processing is complete, the processed data is uploaded to `ProcessedDataBucket`,
    which is an S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an Amazon SNS topic named `BookingNotificationTopic` to facilitate sending
    notifications related to booking events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an AWS `LambdaExecutionRole` with the necessary permissions for the
    Lambda functions to access and interact with various AWS services, such as DynamoDB,
    S3, SNS, and Cognito:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the function names, handlers, runtime, and code location (S3 bucket
    and key) for each Lambda function. Specify the function names, handlers, runtime,
    and code location (S3 bucket and key) for each Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For each of the other Lambda functions (`PaymentProcessingFunction`, `SecurityCheckFunction`,
    `InventoryUpdateFunction`, `DataProcessingFunction`, and `SendNotificationFunction`),
    you would write similar definitions within the `Resources` section of your CloudFormation
    template, adjusting the `FunctionName`, `Handler`, `CodeUri`, and `Policies` properties
    to match their respective implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the Step Functions state machine in the CloudFormation template.
    Use the `AWS::StepFunctions::StateMachine` resource type and define the state
    machine definition in the `DefinitionString` property using Amazon States Language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This AWS Step Functions state machine definition describes the workflow for
    a travel booking system. The workflow starts with a parallel execution of three
    tasks: `"BookingValidation"`, `"PaymentProcessing"`, and `"SecurityCheck"`. These
    tasks are performed concurrently using separate Lambda functions.'
  prefs: []
  type: TYPE_NORMAL
- en: After the parallel tasks are complete, the workflow proceeds to the `"InventoryUpdate"`
    task, which updates the inventory using the `"InventoryUpdateFunction"` Lambda
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `"DataProcessing"` task is executed using the `"DataProcessingFunction"`
    Lambda function to perform any necessary data processing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `"SendNotification"` task is triggered, which uses the `"SendNotification`
    **Function"** Lambda function to send notifications to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The state machine definition utilizes the previously created Lambda functions
    and specifies the flow and order in which these tasks are executed. This enables
    a structured and coordinated workflow for handling travel bookings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sets up an API gateway for the travel booking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `TravelBookingApi` resource creates a new REST API named `TravelBookingApi`.
    Now, `TravelBookingResource` defines a new resource path `/booking` under this
    API. `TravelBookingMethod` sets up a `POST` method for the `/booking` resource,
    which is integrated with AWS Step Functions to start the travel booking workflow
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the Java code and the CloudFormation stack (prepare your environment).
    Ensure you have an AWS account and the necessary permissions to create resources
    such as DynamoDB tables, API Gateway, Lambda functions, IAM roles, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Install and configure the AWS CLI if you haven’t already. Instructions can be
    found at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html).
  prefs: []
  type: TYPE_NORMAL
- en: Package your Lambda function code into JAR files and upload them to an S3 bucket.
    Note that the S3 bucket name and the keys (paths) where the JAR files are stored.
    You’ll need these when running the CloudFormation script.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, modify the CloudFormation script. Ensure that the `S3Bucket: !Ref
    Bucket Name` and `S3Key: booking-validation-1.0-SNAPSHOT.jar` parameter values
    match the S3 bucket name where your Lambda code is stored and the JAR file name.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the CloudFormation script. Save the CloudFormation script to a file, for
    example, `travel-booking-template.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal or command prompt. Run the following command to create a new
    CloudFormation stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Replace `YOUR_S3_BUCKET_NAME` with the actual name of your S3 bucket, and the
    `stack-name` with your stack name.
  prefs: []
  type: TYPE_NORMAL
- en: The `--parameters` flag is used to pass parameters to the CloudFormation template.
    Parameters are defined in the template and allow you to provide dynamic values
    at stack creation time. In this case, the `--parameters` flag is used to specify
    the S3 bucket name where the Lambda code is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can monitor the progress of your stack creation in the AWS Management Console
    under CloudFormation. Alternatively, you can use the AWS CLI to check the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Replace the stack name `TravelBookingStack` with your stack name.
  prefs: []
  type: TYPE_NORMAL
- en: Once the stack creation is complete, verify that all the resources (DynamoDB
    tables, API Gateway, Lambda functions, IAM roles, etc.) have been created successfully.
    You can navigate to each service in the AWS Management Console to check the resources.
  prefs: []
  type: TYPE_NORMAL
- en: After the resources are deployed, you can test the API Gateway endpoint. The
    API Gateway URL can be found in either the outputs section of the CloudFormation
    stack or directly in the API Gateway service in the AWS Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: We can test API Gateway using a tool such as curl or Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Replace `YOUR_API_GATEWAY_URL` with the actual URL of your API Gateway instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the HTTP method to `POST`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the URL of your API gateway followed by `/booking`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the body of the request, use raw JSON to provide the required booking details.
    Here is an example of a JSON payload:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting the CloudFormation stack will remove all the resources created by
    the stack, helping to avoid unnecessary costs and resource usage. To delete the
    resources created by the CloudFormation stack, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Replace the stack name `TravelBookingStack` with your stack name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section explored serverless frameworks for building travel booking applications.
    We highlighted their advantages and how they streamline development. The key takeaways
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Serverless frameworks simplify development with comprehensive tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We built a Java-based booking validation function using Spring Cloud Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Step Functions orchestrated tasks within the booking workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explored integrating DynamoDB, Cognito, API Gateway, and other AWS services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding these concepts, you’re equipped to leverage serverless frameworks
    for building efficient travel booking applications and explore further functionalities
    offered by these frameworks and AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored serverless computing and its integration with Java’s
    concurrency capabilities. We examined the core concepts of serverless architectures,
    including event-driven processing, statelessness, and automatic scaling, along
    with their advantages and potential drawbacks. Understanding these concepts is
    crucial for effectively leveraging serverless computing in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed adapting Java’s concurrency model to serverless environments, focusing
    on tools such as CompletableFuture and parallel streams. We highlighted the best
    practices for Java serverless applications, including strategies for minimizing
    cold starts, efficient resource management, and leveraging frameworks such as
    Spring Cloud Function, Micronaut, and Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter introduced major serverless platforms such as AWS SAM, Azure Functions
    Core Tools, Google Cloud Functions, and Oracle Functions, highlighting their unique
    features and how they simplify the development and deployment of serverless applications.
    We explored Java-specific optimization techniques to enhance performance and reduce
    latency in serverless environments.
  prefs: []
  type: TYPE_NORMAL
- en: Through real-world examples from companies such as Airbnb, LinkedIn, and Expedia,
    we saw practical applications of serverless architectures and concurrency management.
    These case studies illustrated how industry leaders leverage serverless solutions
    to achieve scalability, efficiency, and enhanced user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we provided a hands-on example of building a travel booking application
    using AWS SAM, demonstrating how to integrate various AWS services and orchestrate
    workflows using AWS Step Functions. This practical approach equipped you with
    the knowledge to deploy and manage serverless applications effectively.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be well-equipped to leverage Java’s concurrency
    features in serverless environments, apply optimization best practices, and make
    informed decisions about using serverless architectures in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we transition from serverless architectures to broader cloud computing paradigms,
    our next chapter will explore another crucial aspect of modern application development:
    auto-scaling. [*Chapter 10*](B20937_10.xhtml#_idTextAnchor256) will delve into
    synchronizing Java’s concurrency models with cloud auto-scaling dynamics, building
    upon the concurrent programming concepts we’ve discussed and applying them to
    the elastic nature of cloud environments. This knowledge will be essential for
    developers looking to create robust, scalable Java applications that can efficiently
    adapt to varying workloads in cloud platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the primary advantage of serverless computing over traditional server-based
    architectures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Higher server management overhead
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual scaling of resources
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatic scaling and reduced operational overhead
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited integration with cloud services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Java concurrency feature is particularly useful for performing asynchronous
    tasks in serverless functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Java Virtual** **Machine** (**JVM**)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: CompletableFuture
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Java Database** **Connectivity** (**JDBC**)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: JavaBeans
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary purpose of the Fork/Join framework in Java serverless applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypting data transfers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling single-threaded operations
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing recursive tasks by dividing them into smaller subtasks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Logging and error handling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following best practices helps minimize cold starts in Java serverless
    applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the heaviest deployment package possible
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimize function size and use provisioned concurrency
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid using any form of concurrency
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable all possible cloud services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a key benefit of using parallel streams in serverless Java functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blocking the main thread for all tasks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Improved performance through concurrent data processing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplifying the deployment process
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reducing the need for error handling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: Mastering Concurrency in the Cloud – The Final Frontier'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we reach the culmination of our journey through Java's concurrency landscape,
    *Part 3* explores the most advanced and forward-looking aspects of concurrent
    programming in cloud environments. This final section synthesizes the knowledge
    gained from previous chapters, applying it to the cutting-edge realm of cloud
    computing and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter offers practical, real-world examples and use cases, allowing readers
    to apply concepts from earlier parts of the book in innovative ways. As we conclude,
    *Part 3* equips readers with the vision and tools to be at the forefront of concurrent
    programming in the age of cloud computing and beyond, transforming them from proficient
    developers into masters of Java concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B20937_10.xhtml#_idTextAnchor256), *Synchronizing Java''s Concurrency
    with Cloud Auto-Scaling Dynamics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B20937_11.xhtml#_idTextAnchor278), *Advanced Java Concurrency
    Practices in Cloud Computing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B20937_12.xhtml#_idTextAnchor295), *The Horizon Ahead*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
