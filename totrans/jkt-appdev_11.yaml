- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servlet Development and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to develop and deploy Java EE Servlets.
    Servlets allow us as application developers to implement server-side logic in
    Java web and enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a servlet?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request forwarding and response redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting application data across requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing initialization parameters to a servlet via annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluggability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring web applications programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2 server push support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch11_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch11_src)
  prefs: []
  type: TYPE_NORMAL
- en: What is a servlet?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `jakarta.servlet.GenericServlet`. This class defines a generic, protocol-independent
    servlet.
  prefs: []
  type: TYPE_NORMAL
- en: By far the most common type of servlet is an HTTP servlet. This type of servlet
    is used when handling HTTP requests and generating HTTP responses. An HTTP servlet
    is a class that extends the `jakarta.servlet.`http.HttpServlet class, which is
    a subclass of `jakarta.servlet.GenericServlet`.
  prefs: []
  type: TYPE_NORMAL
- en: A servlet must implement one or more methods to respond to specific HTTP request
    types. These methods are overridden from the parent `HttpServlet` class. As can
    be seen in *Table 11.1*, these methods are named so that knowing which one to
    use is intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Request** | **HttpServlet Method** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GET | `doGet(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| POST | `doPost(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| PUT | `doPut(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE | `doDelete(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Servlet methods for different HTTP request types
  prefs: []
  type: TYPE_NORMAL
- en: Each of these methods takes the same two parameters, namely an instance of a
    class implementing the `jakarta.servlet.http.HttpServletRequest` interface and
    an instance of a class implementing `jakarta.servlet.http.HttpServletResponse`.
    These interfaces will be covered in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Application developers never call the above methods directly. They are called
    automatically by the application server whenever it receives the corresponding
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Of the four methods listed above, `doGet()` and `doPost()` are, by far, the
    most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP GET request is generated whenever a user types the servlet’s URL in
    the browser, when a user clicks on a link pointing to the servlet’s URL, or when
    a user submits an HTML form using generating an HTTP GET method where the form’s
    action points to the servlet’s URL. In any of these cases, the code inside the
    servlet’s `doGet()` method gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP POST request is typically generated when a user submits an HTML form
    generating an HTTP POST method and an action pointing to the servlet’s URL. In
    this case, the servlet’s code inside the `doPost()` method gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explained how a servlet works, let’s take a look at how to develop
    servlets.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first servlet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will develop a simple servlet to illustrate how to use
    the servlet API. The code for our servlet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `@WebServlet` annotation specifies that our class is a servlet. Its `urlPatterns`
    attribute specifies the relative URL of our servlet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Servlets can also be configured via a `web.xml` deployment descriptor. However,
    since Java EE 6, annotation-based configuration is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Since this servlet is meant to execute when a user enters its URL in the browser
    window, we need to override the `doGet()` method from the parent `HttpServlet`
    class. As explained, this method takes two parameters, an instance of a class
    implementing the `jakarta.servlet.http.HttpServletRequest` interface, and an instance
    of a class implementing the `jakarta.servlet.http.HttpServletResponse` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even though `HttpServletRequest` and `HttpServletResponse` are interfaces, application
    developers don’t typically write classes implementing them. When control goes
    to a servlet from an HTTP request, the application server provides objects implementing
    these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing our `doGet()` method does is to set the content type for the
    `HttpServletResponse` object to `"text/html"`. If we forget to do this, the default
    content type used is `"text/plain"`, which means that the HTML tags used a couple
    of lines down will be displayed on the browser, as opposed to them being interpreted
    as HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: Then we obtain an instance of `java.io.PrintWriter` by calling the `HttpServletResponse.getWriter()`
    method. We can then send text output to the browser by calling the `PrintWriter.print()`
    and `PrintWriter.println()` methods (the preceding example uses `println()` exclusively).
    Since we set the content type to `"text/html"`, any HTML tags are interpreted
    properly by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To verify that the servlet has been properly deployed, we need to point our
    browser to our application’s URL, for example, `http://localhost:8080/simpleapp/simpleservlet`.
    After doing so, we should see a page like the one shown in *Figure 11**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Simple servlet responding to an HTTP GET request](img/B21231_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Simple servlet responding to an HTTP GET request
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we simply displayed some static text in the browser. Servlets
    are typically used to process user-entered data in an HTML form, as illustrated
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Processing HTML forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servlets are rarely accessed by typing their URL directly in the browser. The
    most common use for servlets is to process data entered by users in an HTML form.
    In this section, we illustrate this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant markup for the HTML file containing the form for our application
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value for the form’s `action` attribute must match the value of the servlet’s
    `urlPatterns` attribute in its `@WebServlet` annotation. Since the value of the
    form’s `method` attribute is `"post"`, our servlet’s `doPost()` method will be
    executed when the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at our servlet’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in this example, we obtain a reference to the value the user
    typed by calling the `request.getParameter()` method. This method takes a single
    `String` object as its sole parameter. The value of this string must match the
    name of the input field in the HTML file. In this case, the HTML file has a text
    field named `"enteredValue"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<input type="text"` `name="enteredValue" />`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the servlet has this corresponding line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enteredValue =` `request.getParameter("enteredValue");`'
  prefs: []
  type: TYPE_NORMAL
- en: This is to obtain the text entered by the user and store it in the `String`
    variable named `enteredValue` (the name of the variable does not need to match
    the input field name, but naming it that way is good practice to make it easy
    to remember what value the variable is holding).
  prefs: []
  type: TYPE_NORMAL
- en: 'After packaging the preceding three files in a WAR file called `formhandling.war`,
    followed by deploying the WAR file, we can see the rendered HTML file by entering
    a URL similar to the following in the browser (the exact URL will depend on the
    Jakarta EE application server being used): `http://localhost:8080/formhandling`.'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML form will be rendered as illustrated in *Figure 11**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – HTML form](img/B21231_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – HTML form
  prefs: []
  type: TYPE_NORMAL
- en: After the user enters `some text` in the text field and submits the form (either
    by hitting *Enter* or clicking on the **Submit** button), we should see the output
    of the servlet, as illustrated in *Figure 11**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Servlet form handling](img/B21231_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Servlet form handling
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpServletRequest.getParameter()` method can be used to obtain the value
    of any HTML input field that can only return one value (textboxes, text areas,
    single selects, radio buttons, hidden fields, etc.). The procedure to obtain any
    of these fields’ values is identical. In other words, the servlet doesn’t care
    if the user typed in the value in a text field, selected it from a set of radio
    buttons, and so on. As long as the input field’s name matches the value passed
    to the `getParameter()` method, the preceding code will work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with radio buttons, all related radio buttons must have the same
    name. Calling the `HttpServletRequest.getParameter()` method and passing the name
    of the radio buttons will return the value of the selected radio button.
  prefs: []
  type: TYPE_NORMAL
- en: Some HTML input fields such as checkboxes and multiple select boxes allow the
    user to select more than one value. For these fields, instead of using the `HttpServletRequest.getParameter()`
    method, the `HttpServletRequest.getParameterValues()` method is used. This method
    also takes `String` containing the input field’s name as its only parameter and
    returns an array of strings containing all the values that were selected by the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates this case. The relevant sections of our new
    HTML markup are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The new `HTML` file contains a simple form having three checkboxes and a submit
    button. Notice how every checkbox has the same value for its `name` attribute.
    As we mentioned before, any checkboxes that are clicked by the user will be sent
    to the servlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at the `doPost()` method of the servlet that will handle
    the HTML form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls the `request.getParameterValues()` method and assigns
    its return value to the `selectedOptions` variable. Farther down the `doPost()`
    method, the code traverses the `selectedOptions` array and prints the selected
    values in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: If no checkboxes are clicked, the `request.getParameterValues()` method will
    return `null`, therefore it is a good idea to check for `null` before attempting
    to traverse through this method’s return values.
  prefs: []
  type: TYPE_NORMAL
- en: After packaging our new servlet in a WAR file and deploying it, we can see the
    changes in action by typing its URL in the browser window. In most application
    servers, the URL will be `http://localhost:8080/multiplevaluefields/`. The form
    will be rendered as illustrated in *Figure 11**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – HTML form with multiple value fields](img/B21231_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – HTML form with multiple value fields
  prefs: []
  type: TYPE_NORMAL
- en: 'After submitting the form, control goes to our servlet, and the browser window
    should look something like what’s illustrated in *Figure 11**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Servlet handling fields with multiple values](img/B21231_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Servlet handling fields with multiple values
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the actual message seen in the browser window will depend on what
    checkboxes the user clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to process HTML form data, we’ll focus our attention
    on automatically navigating to a different page via HTTP request forwarding and
    HTTP response redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Request forwarding and response redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many cases, one servlet processes form data, then transfers control to another
    servlet or JSP to do some more processing or displays a confirmation message on
    the screen. There are two ways of doing this: either the request can be forwarded
    or the response can be redirected to another servlet or page.'
  prefs: []
  type: TYPE_NORMAL
- en: Request forwarding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice how the text displayed in the previous section’s example matches the
    value of the value attribute of the checkboxes that were clicked, and not the
    labels displayed on the previous page. This might confuse the users. Let’s modify
    the servlet to change these values so that they match the labels, then forward
    the request to another servlet that will display the confirmation message in the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doPost()` method for the new version of `MultipleValueFieldHandlerServlet`
    is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This version of the servlet iterates through the selected options and adds the
    corresponding label to an `ArrayList` of strings. This string is then attached
    to the request object by calling the `request.setAttribute()` method. This method
    is used to attach any object to the request so that any other code we forward
    the request to can have access to it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'After attaching `ArrayList` to the request, we then forward the request to
    the new servlet in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `String` argument to this method must match the value of the `urlPatterns`
    tag of the target servlet’s `@``WebServlet` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, control goes to our new servlet. Since we are forwarding an
    HTTP POST request, its `doPost()` method is automatically called. The code for
    this new servlet is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code obtains `ArrayList` that was attached to the request by the previous
    servlet. This is accomplished by calling the `request.getAttribute()` method.
    The parameter for this method must match the value used to attach the object to
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: Once the above servlet obtains the list of option labels, it traverses through
    it and displays them in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Request forwarding in action](img/B21231_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Request forwarding in action
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding a request as described only works for other resources (servlets and
    JSP pages) in the same context as the code doing the forwarding. In simple terms,
    the servlet or JSP we want to forward to must be packaged in the same WAR file
    as the code that is invoking the `request.getRequestDispatcher().forward()` method.
    If we need to direct the user to a page in another context (or even another server),
    we can do it by redirecting the response object.
  prefs: []
  type: TYPE_NORMAL
- en: Response redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One disadvantage of forwarding a request as described in the previous section
    is that requests can only be forwarded to other servlets or JSPs in the same context.
    If we need to direct the user to a page in a different context (deployed in another
    WAR file on the same server or deployed on a different server), we need to use
    the `HttpServletResponse.sendRedirect()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate response redirection, let’s develop a simple web application
    that asks the user to select their favorite search engine, and then direct the
    user to their search engine of choice. The HTML form for this application would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML form in the markup code above contains three radio buttons. The value
    for each of them is the URL for the search engine corresponding to the user’s
    selection. Notice how the value for the `name` attribute of each radio button
    is the same, namely `"searchEngine"`. The servlet will obtain the value of the
    selected radio button by calling the `request.getParameter()` method and passing
    the `"searchEngine"` string as a parameter, as is demonstrated in the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By calling `request.getParameter("searchEngine")`, the code shown here assigns
    the URL of the selected search engine to the `url` variable. Then, (after checking
    for `null`, in case the user clicked on the `response.sendRedirect()` and passing
    the `url` variable as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'After packaging the code and deploying it, we can see it in action by typing
    a URL similar to the following in the browser: `http://localhost:8080/responseredirection/`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Response redirection example](img/B21231_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Response redirection example
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the **Submit** button, the user is directed to their favorite
    search engine.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that redirecting the response as illustrated here creates
    a new HTTP request to the page we are redirecting to, therefore any request parameters
    and attributes are lost.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting application data across requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how it is possible to store an object in the
    request by invoking the `HttpRequest.setAttribute()` method, and how later this
    object can be retrieved by invoking the `HttpRequest.getAttribute()` method. This
    approach only works if the request was forwarded to the servlet invoking the `getAttribute()`
    method. If this is not the case, the `getAttribute()` method will return null.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to persist an object across requests. In addition to attaching
    an object to the request object, an object can also be attached to the session
    object or to the servlet context. The difference between these two is that objects
    attached to the session will not be visible to different users, whereas objects
    attached to the servlet context are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attaching objects to the session and servlet context is very similar to attaching
    objects to the request. To attach an object to the session, the `HttpServletRequest.getSession()`
    method must be invoked. This method returns an instance of `jakarta.servlet.http.HttpSession`.
    We then call the `HttpSession.setAttribute()` method to attach the object to the
    session. The following code fragment illustrates the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then retrieve the object from the session by calling the `HttpSession.getAttribute()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the return value of `session.getAttribute()` needs to be cast to
    the appropriate type. This is necessary since the return value of this method
    is `java.lang.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to attach and retrieve objects to and from the servlet context
    is very similar. The servlet needs to call the `getServletContext()` method (defined
    in the class called `GenericServlet`, which is the parent class of `HttpServlet`,
    which in turn is the parent class of our servlets). This method returns an instance
    of `jakarta.servlet.ServletContext`, which defines a `setAttribute()` and a `getAttribute()`
    method. These methods work the same way as their `HttpServletRequest` and `HttpSessionResponse`
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure to attach an object to the servlet context is illustrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code attaches the `foo` object to the servlet context. This object
    will be available to any servlet in our application and will be the same across
    sessions. It can be retrieved by calling the `ServletContext.getAttribute()` method,
    as is illustrated next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code obtains the `foo` object from the request context. Again, a cast is
    needed since the `ServletContext.getAttribute()` method, like its counterparts,
    returns an instance of `java.lang.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Objects attached to the servlet context are said to have a scope of *application*.
    Similarly, objects attached to the session are said to have a scope of *session*,
    and objects attached to the request are said to have a scope of *request*.
  prefs: []
  type: TYPE_NORMAL
- en: Passing initialization parameters to a servlet via annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is useful to pass some initialization parameters to a servlet.
    That way, we can make said servlet behave differently based on the parameters
    that are sent to it. For example, we may want to configure a servlet to behave
    differently in development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the old days, servlet initialization parameters were sent via the `<init-param>`
    parameter in `web.xml`. As of servlet 3.0, initialization parameters can be passed
    to the servlet as the value of the `initParams` attribute of the `@WebServlet`
    annotation. The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the value of the `initParams` attribute of the `@WebServlet`
    annotation is an array of `@WebInitParam` annotations. Each `@WebInitParam` annotation
    has two attributes: `name`, which corresponds to the parameter name, and `value`,
    which corresponds to the parameter value.'
  prefs: []
  type: TYPE_NORMAL
- en: We can obtain the values of our parameters by invoking the `getInitParameter()`
    method on the `jakarta.servlet.ServletConfig` class. This method takes a single
    `String` argument as a parameter, corresponding to the parameter name, and returns
    `String` corresponding to the parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: Each servlet has a corresponding instance of `ServletConfig` assigned to it.
    As we can see in this example, we can obtain this instance by invoking `getServletConfig()`,
    which is a method inherited from `jakarta.servlet.GenericServlet`, the parent
    class of `HttpServlet`, which our servlets extend.
  prefs: []
  type: TYPE_NORMAL
- en: After packaging and deploying our servlet, then pointing the browser to the
    servlet URL, we will see the following page rendered in the browser, as shown
    in *Figure 11**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Servlet initialization parameters](img/B21231_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Servlet initialization parameters
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the rendered values correspond to the values we have set in each
    `@``WebInitParam` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to initialize a servlet, we’ll shift our attention to
    intercepting HTTP requests via servlet filters.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `doGet()` or `doPost()` method finishes, but before the output is sent to
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to configure a filter in earlier servlet specifications was to
    use the `<filter-mapping>` tag in `web.xml`. `@``WebFilter` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the example, the `@WebFilter` annotation has several attributes
    we can use to configure the filter. Of special importance is the `urlPatterns`
    attribute. This attribute takes an array of `String` objects as its value. Each
    element in the array corresponds to a URL that our filter will intercept. In our
    example, we are intercepting a single URL pattern, which corresponds to the servlet
    we wrote in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Other attributes in the `@WebFilter` annotation include the optional `filterName`
    attribute, which we can use to give our filter a name. If we don’t specify a name
    for our filter, then the filter name defaults to the filter’s class name.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in our example servlet filter, we can send initialization parameters
    to a filter. This is done just like we send initialization parameters to a servlet.
    The `@WebFilter` annotation has an `initParams` attribute that takes an array
    of `@WebInitParam` annotations as its value. We can obtain the values of said
    parameters by invoking the `getInitParameter()` method on `jakarta.servlet.FilterConfig`,
    as illustrated in the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our filter is fairly simple; it simply sends some output to the server log
    before and after the servlet is invoked. Inspecting the server log after deploying
    our application and pointing the browser to the servlet’s URL should reveal our
    filter’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Some common uses of servlet filters include profiling web applications, applying
    security, and compressing data, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the lifetime of a typical web application, a number of events take place,
    such as HTTP requests being created or destroyed, request or session attributes
    being added, removed, or modified, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The servlet API provides a number of listener interfaces we can implement in
    order to react to these events. All of these interfaces are in the `jakarta.servlet`
    package. The following table summarizes them.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Listener Interface** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletContextListener` | Contains methods for handling context initialization
    and destruction events. |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletContextAttributeListener` | Contains methods for reacting to any
    attributes added, removed, or replaced in the servlet context (application scope).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletRequestListener` | Contains methods for handling request initialization
    and destruction events. |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletRequestAttributeListener` | Contains methods for reacting to any
    attributes added, removed, or replaced in the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpSessionListener` | Contains methods for handling HTTP session initialization
    and destruction events. |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpSessionAttributeListener` | Contains methods for reacting to any attributes
    added, removed, or replaced in the HTTP session. |'
  prefs: []
  type: TYPE_TB
- en: Table 11.2 – Servlet listener interfaces
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do to handle any of the events handled by the interfaces described
    in the preceding table is to implement one of the interfaces and annotate it with
    the `@WebListener` interface or declare it in the `web.xml` deployment descriptor
    via the `<``listener>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The API for all of the preceding interfaces is fairly straightforward and intuitive.
    We will show an example for one of the interfaces. Others will be very similar.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The JavaDoc for all of the preceding interfaces can be found at [https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/package-summary](https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/package-summary)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to implement the `ServletRequestListener`
    interface, which can be used to perform some action whenever an HTTP request is
    created or destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, all we need to do to activate our listener class is to annotate
    it with the `@WebListener` annotation. Our listener must also implement one of
    the listener interfaces we listed. In our example, we chose to implement `jakarta.servlet.ServletRequestListener`.
    This interface has methods that are automatically invoked whenever an HTTP request
    is initialized or destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServletRequestListener` interface has two methods, `requestInitialized()`
    and `requestDestroyed()`. In the preceding simple implementation, we simply sent
    some output to the log, but of course, we can do anything we need to do in our
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our listener to listen to requests handled by the simple servlet we developed
    earlier in the chapter results in the following output in the Jakarta EE runtime
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the other listener interfaces is just as simple and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the original servlet API was released back in the late 1990s, writing servlets
    was the only way of writing server-side web applications in Java. Since then,
    several Jakarta EE and third-party frameworks have been built on top of the Servlet
    API. Examples of such frameworks include JSP and JSF, Apache Struts, Apache Wicket,
    Spring Web MVC, and several others.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, very few (if any) Java web applications are built using the Servlet
    API directly. Instead, the vast majority of projects utilize one of the available
    Java web application frameworks. All of these frameworks use the servlet API “under
    the covers,” therefore setting up an application to use one of these frameworks
    has always involved making some configuration in the application’s `web.xml` deployment
    descriptor. In some cases, some applications use more than one framework. This
    tends to make the `web.xml` deployment descriptor fairly large and hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet 3.0 introduced the concept of pluggability. Web application framework
    developers now have not one, but two ways to avoid having application developers
    have to modify the `web.xml` deployment descriptor in order to use their framework.
    Framework developers can choose to use annotations instead of `web.xml` to configure
    their servlets. After doing this, all that is needed to use the framework is to
    include the `library jar` file(s) provided by the framework developers in the
    application’s WAR file. Alternatively, framework developers may choose to include
    `web-fragment.xml` as part of the JAR file to be included in web applications
    that use their framework.
  prefs: []
  type: TYPE_NORMAL
- en: '`web-fragment.xml` is almost identical to `web.xml`. The main difference is
    that the root element of `web-fragment.xml` is `<web-fragment>` as opposed to
    `<web-app>`. The following example illustrates a sample `web-fragment.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `web-fragment.xml` is almost identical to typical `web.xml`.
    In this simple example, we only use the `<servlet>` and `<servlet-mapping>` elements,
    but all other usual `web.xml` elements such as `<filter>`, `<filter-mapping>`,
    and `<listener>` are available as well.
  prefs: []
  type: TYPE_NORMAL
- en: As specified in `web-fragment.xml`, our servlet can be invoked via its URL pattern,
    `/WebFragment`, therefore the URL to execute our servlet once deployed as part
    of a web application would be `http://localhost:8080/webfragmentapp/WebFragment`.
    Of course, the hostname, port, and context root must be adjusted as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do for any Jakarta EE-compliant application server to pick up
    the settings in `web-fragment.xml` is to place the file in the `META-INF` folder
    of the library where we pack our servlet, filter, and/or listener, then place
    our library’s `jar` file in the `lib` directory of the WAR file containing our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring web applications programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to allowing us to configure web applications through annotations
    and `web-fragment.xml`, Servlet 3.0 also allows us to configure our web applications
    programmatically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ServletContext` class has new methods to configure servlets, filters,
    and listeners programmatically. The following example illustrates how to configure
    a servlet programmatically at runtime, without resorting to the `@WebServlet`
    annotation or to XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we invoke the `createServlet()` method of `ServletContext`
    to create the servlet that we are about to configure. This method takes an instance
    of `java.lang.Class` corresponding to our servlet’s class. This method returns
    a class implementing `jakarta.servlet.Servlet` or any of its child interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create our servlet, we need to invoke `addServlet()` on our `ServletContext`
    instance to register our servlet with the servlet container. This method takes
    two parameters, the first being `String` corresponding to the servlet name and
    the second being the servlet instance returned by the call to `createServlet()`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have registered our servlet, we need to add a URL mapping to it. In
    order to do this, we need to invoke the `getServletRegistration()` method on our
    `ServletContext` instance, passing the servlet name as a parameter. This method
    returns the servlet container’s implementation of `jakarta.servlet.ServletRegistration`.
    From this object, we need to invoke its `addMapping()` method, passing the URL
    mapping we wish our servlet to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example servlet is very simple. It simply displays a text message in the
    browser. Its `doGet()` method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After packing our code in a WAR file and deploying it to a Jakarta EE runtime,
    then pointing the browser to the appropriate URL (i.e `http://localhost:8080/programmaticservletwebapp/ProgrammaticallyConfiguredServlet`),
    we should see the following message in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**This message was generated from a servlet that was** **configured programmatically.**'
  prefs: []
  type: TYPE_NORMAL
- en: The `ServletContext` interface has methods to create and add servlet filters
    and listeners. They work very similarly to the way the `addServlet()` and `createServlet()`
    methods work, therefore we won’t be discussing them in detail. Refer to the Jakarta
    EE API documentation at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, servlets have created a single thread per request in Java web
    applications. After a request is processed, the thread is made available for other
    requests to use. This model works fairly well for traditional web applications,
    in which HTTP requests are relatively few and far between. However, most modern
    web applications take advantage of **Ajax** (short for **Asynchronous JavaScript
    and XML**), a technique that makes web applications behave much more responsively
    than traditional web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ajax has the side effect of generating a lot more HTTP requests than traditional
    web applications. If some of these threads block for a long time waiting, for
    a resource to be ready or doing anything that takes a long time to process, it
    is possible our application may suffer from thread starvation.
  prefs: []
  type: TYPE_NORMAL
- en: To alleviate the situation described in the previous paragraph, the Servlet
    3.0 specification introduced asynchronous processing. Using this new capability,
    we are no longer limited to a single thread per request. We can now spawn a separate
    thread and return the original thread back to the pool, to be reused by other
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to implement asynchronous processing
    using the new capabilities introduced in Servlet 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do to make sure our asynchronous processing code
    works as expected is to set the `asyncSupported` attribute of the `@WebServlet`
    annotation to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: To actually spawn an asynchronous process, we need to invoke the `startAsync()`
    method on the instance of `HttpServletRequest` that we receive as a parameter
    in the `doGet()` or `doPost()` method in our servlet. This method returns an instance
    of `jakarta.servlet.AsyncContext`. This class has a `start()` method that takes
    an instance of a class implementing `java.lang.Runnable` as its sole parameter.
    In our example, we used an anonymous inner class to implement `Runnable` in line.
    Of course, a standard Java class implementing `Runnable` can be used as well,
    or a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: When we invoke the `start()` method of `AsyncContext`, a new thread is spawned
    and the `run()` method of the `Runnable` instance is executed. This thread runs
    in the background, the `doGet()` method returns immediately, and the request thread
    is immediately available to service other clients. It is important to notice that,
    even though the `doGet()` method returns immediately, the response is not committed
    until after the thread spawned finishes. It can signal it is done processing by
    invoking the `complete()` method on `AsyncContext`.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the message **You should see this after a brief wait** is displayed
    in the browser after 10 seconds, which is how long our spawned thread takes to
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to perform asynchronous processing in servlets, we’ll
    focus our attention on how to implement HTTP/2 server push support.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 server push support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HTTP/2** is the newest version of the HTTP protocol. It offers several advantages
    over HTTP 1.1\. For example, with HTTP/2 there is a single connection between
    the browser and the server, and this connection remains open until the user navigates
    to another page. HTTP/2 also offers multiplexing, meaning that several concurrent
    requests from the browser to the server are allowed. Additionally, HTTP/2 features
    server push, meaning that the server can send resources to the browser without
    the browser specifically having to request them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP/2 server push support was added to the servlet specification in version
    4.0, released as part of Java EE 8\. In this section, we’ll see how we can write
    code to take advantage of HTTP/2’s server push functionality. The following example
    illustrates how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can push resources to the browser via the `PushBuilder` interface, introduced
    in version 4 of the servlet specification. We can obtain an instance of a class
    implementing `PushBuilder` by invoking the new `PushBuilder()` method on the instance
    of `HttpServletRequest` we get as a parameter in our `doPost()` method.
  prefs: []
  type: TYPE_NORMAL
- en: As its name implies, the `PushBuilder` interface implements the Builder pattern,
    meaning that most of its methods return a new instance of `PushBuilder` we can
    use, allowing us to conveniently chain together method invocations.
  prefs: []
  type: TYPE_NORMAL
- en: We indicate the path of the resource we’d like to push to the browser by invoking
    `PushBuilder`’s appropriately named `path()` method. This method takes a single
    `String` argument indicating the path of the resource to push. Paths beginning
    with a forward slash `("/")` indicate an absolute path; all other paths indicate
    a path relative to our application’s context root.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have specified the path of our resource, we can optionally set some
    HTTP headers. In our case, we are pushing an image in PNG format, therefore we
    set the content type as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we invoke the `push()` method on our `PushBuilder` instance to actually
    push our resource to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: What we accomplished with our example was pushing a resource to the browser
    before the browser submitted a request for it. This task was impossible before
    the HTTP/2 protocol was released.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered how to develop, configure, package, and deploy servlets.
    The following topics were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to process HTML form information by accessing the HTTP request object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forwarding HTTP requests from one servlet to another was covered, as well as
    redirecting the HTTP response to a different server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting objects in memory across requests by attaching them to the servlet
    context and the HTTP session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring web applications via annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluggability through `web-fragment.xml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatic servlet configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2 server push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with the knowledge from this chapter, we can now implement server-side
    web application logic using Jakarta servlets.
  prefs: []
  type: TYPE_NORMAL
