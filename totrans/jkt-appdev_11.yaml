- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Servlet Development and Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet开发和部署
- en: In this chapter, we will discuss how to develop and deploy Java EE Servlets.
    Servlets allow us as application developers to implement server-side logic in
    Java web and enterprise applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何开发和部署Java EE Servlets。Servlets允许我们作为应用开发者，在Java Web和企业应用中实现服务器端逻辑。
- en: 'The topics covered include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: What is a servlet?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Servlet？
- en: Request forwarding and response redirection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求转发和响应重定向
- en: Persisting application data across requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求之间持久化应用数据
- en: Passing initialization parameters to a servlet via annotations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注解将初始化参数传递给Servlet
- en: Servlet filters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet过滤器
- en: Servlet listeners
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet监听器
- en: Pluggability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可插拔性
- en: Configuring web applications programmatically
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编程配置Web应用
- en: Asynchronous processing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理
- en: HTTP/2 server push support
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2服务器推送支持
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch11_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch11_src)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch11_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch11_src)
- en: What is a servlet?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Servlet？
- en: A `jakarta.servlet.GenericServlet`. This class defines a generic, protocol-independent
    servlet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`jakarta.servlet.GenericServlet`。这个类定义了一个通用的、协议无关的Servlet。
- en: By far the most common type of servlet is an HTTP servlet. This type of servlet
    is used when handling HTTP requests and generating HTTP responses. An HTTP servlet
    is a class that extends the `jakarta.servlet.`http.HttpServlet class, which is
    a subclass of `jakarta.servlet.GenericServlet`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的Servlet类型是HTTP Servlet。这种类型的Servlet用于处理HTTP请求和生成HTTP响应。HTTP Servlet是一个扩展了`jakarta.servlet.http.HttpServlet`类的类，而`jakarta.servlet.http.HttpServlet`是`jakarta.servlet.GenericServlet`的子类。
- en: A servlet must implement one or more methods to respond to specific HTTP request
    types. These methods are overridden from the parent `HttpServlet` class. As can
    be seen in *Table 11.1*, these methods are named so that knowing which one to
    use is intuitive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet必须实现一个或多个方法来响应特定的HTTP请求类型。这些方法是从父类`HttpServlet`中重写的。如*表11.1*所示，这些方法的命名使得知道使用哪个方法是很直观的。
- en: '| **HTTP Request** | **HttpServlet Method** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP请求** | **HttpServlet方法** |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GET | `doGet(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| GET | `doGet(HttpServletRequest request, HttpServletResponse response)` |'
- en: '| POST | `doPost(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| POST | `doPost(HttpServletRequest request, HttpServletResponse response)`
    |'
- en: '| PUT | `doPut(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| PUT | `doPut(HttpServletRequest request, HttpServletResponse response)` |'
- en: '| DELETE | `doDelete(HttpServletRequest request,` `HttpServletResponse response)`
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | `doDelete(HttpServletRequest request, HttpServletResponse response)`
    |'
- en: Table 11.1 – Servlet methods for different HTTP request types
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 – 不同HTTP请求类型的Servlet方法
- en: Each of these methods takes the same two parameters, namely an instance of a
    class implementing the `jakarta.servlet.http.HttpServletRequest` interface and
    an instance of a class implementing `jakarta.servlet.http.HttpServletResponse`.
    These interfaces will be covered in detail later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都接受相同的两个参数，即实现了`jakarta.servlet.http.HttpServletRequest`接口的类的实例和实现了`jakarta.servlet.http.HttpServletResponse`接口的类的实例。这些接口将在本章后面详细讨论。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Application developers never call the above methods directly. They are called
    automatically by the application server whenever it receives the corresponding
    HTTP request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用开发者永远不会直接调用上述方法。当应用服务器接收到相应的HTTP请求时，这些方法会自动被调用。
- en: Of the four methods listed above, `doGet()` and `doPost()` are, by far, the
    most commonly used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述四种方法中，`doGet()`和`doPost()`到目前为止是最常用的。
- en: An HTTP GET request is generated whenever a user types the servlet’s URL in
    the browser, when a user clicks on a link pointing to the servlet’s URL, or when
    a user submits an HTML form using generating an HTTP GET method where the form’s
    action points to the servlet’s URL. In any of these cases, the code inside the
    servlet’s `doGet()` method gets executed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在浏览器中输入Servlet的URL、点击指向Servlet URL的链接或用户提交使用生成HTTP GET方法的HTML表单（表单的action指向Servlet的URL）时，都会生成一个HTTP
    GET请求。在这些情况下，Servlet的`doGet()`方法中的代码会被执行。
- en: An HTTP POST request is typically generated when a user submits an HTML form
    generating an HTTP POST method and an action pointing to the servlet’s URL. In
    this case, the servlet’s code inside the `doPost()` method gets executed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交一个生成HTTP POST方法和指向servlet URL的操作的HTML表单时，通常会生成一个HTTP POST请求。在这种情况下，`doPost()`方法内部的servlet代码将被执行。
- en: Now that we’ve explained how a servlet works, let’s take a look at how to develop
    servlets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了servlet是如何工作的，让我们看看如何开发servlet。
- en: Writing our first servlet
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的第一个servlet
- en: 'In this section, we will develop a simple servlet to illustrate how to use
    the servlet API. The code for our servlet is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个简单的servlet来展示如何使用servlet API。我们servlet的代码如下：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `@WebServlet` annotation specifies that our class is a servlet. Its `urlPatterns`
    attribute specifies the relative URL of our servlet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebServlet`注解指定我们的类是一个servlet。它的`urlPatterns`属性指定了我们的servlet的相对URL。'
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Servlets can also be configured via a `web.xml` deployment descriptor. However,
    since Java EE 6, annotation-based configuration is preferred.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet也可以通过`web.xml`部署描述符进行配置。然而，自从Java EE 6以来，基于注解的配置更受欢迎。
- en: Since this servlet is meant to execute when a user enters its URL in the browser
    window, we need to override the `doGet()` method from the parent `HttpServlet`
    class. As explained, this method takes two parameters, an instance of a class
    implementing the `jakarta.servlet.http.HttpServletRequest` interface, and an instance
    of a class implementing the `jakarta.servlet.http.HttpServletResponse` interface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个servlet旨在用户在浏览器窗口中输入其URL时执行，我们需要重写父`HttpServlet`类中的`doGet()`方法。正如解释的那样，此方法接受两个参数，一个是实现`jakarta.servlet.http.HttpServletRequest`接口的类的实例，另一个是实现`jakarta.servlet.http.HttpServletResponse`接口的类的实例。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though `HttpServletRequest` and `HttpServletResponse` are interfaces, application
    developers don’t typically write classes implementing them. When control goes
    to a servlet from an HTTP request, the application server provides objects implementing
    these interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`HttpServletRequest`和`HttpServletResponse`是接口，但应用程序开发者通常不会编写实现它们的类。当控制从HTTP请求传递到servlet时，应用程序服务器提供实现这些接口的对象。
- en: The first thing our `doGet()` method does is to set the content type for the
    `HttpServletResponse` object to `"text/html"`. If we forget to do this, the default
    content type used is `"text/plain"`, which means that the HTML tags used a couple
    of lines down will be displayed on the browser, as opposed to them being interpreted
    as HTML tags.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`doGet()`方法的第一件事是为`HttpServletResponse`对象设置内容类型为`"text/html"`。如果我们忘记这样做，将使用默认的内容类型`"text/plain"`，这意味着几行以下的HTML标签将在浏览器上显示，而不是被解释为HTML标签。
- en: Then we obtain an instance of `java.io.PrintWriter` by calling the `HttpServletResponse.getWriter()`
    method. We can then send text output to the browser by calling the `PrintWriter.print()`
    and `PrintWriter.println()` methods (the preceding example uses `println()` exclusively).
    Since we set the content type to `"text/html"`, any HTML tags are interpreted
    properly by the browser.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过调用`HttpServletResponse.getWriter()`方法来获取`java.io.PrintWriter`的实例。然后我们可以通过调用`PrintWriter.print()`和`PrintWriter.println()`方法（前面的例子只使用`println()`）将文本输出到浏览器。由于我们将内容类型设置为`"text/html"`，任何HTML标签都将被浏览器正确解释。
- en: Testing the web application
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Web应用程序
- en: To verify that the servlet has been properly deployed, we need to point our
    browser to our application’s URL, for example, `http://localhost:8080/simpleapp/simpleservlet`.
    After doing so, we should see a page like the one shown in *Figure 11**.1*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证servlet是否已正确部署，我们需要将我们的浏览器指向我们的应用程序的URL，例如，`http://localhost:8080/simpleapp/simpleservlet`。这样做之后，我们应该看到一个类似于*图11**.1*所示的页面。
- en: '![Figure 11.1 – Simple servlet responding to an HTTP GET request](img/B21231_11_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 简单的servlet响应HTTP GET请求](img/B21231_11_01.jpg)'
- en: Figure 11.1 – Simple servlet responding to an HTTP GET request
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 简单的servlet响应HTTP GET请求
- en: In this example, we simply displayed some static text in the browser. Servlets
    are typically used to process user-entered data in an HTML form, as illustrated
    in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是在浏览器中显示了一些静态文本。Servlet通常用于处理用户在HTML表单中输入的数据，如下一节所示。
- en: Processing HTML forms
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理HTML表单
- en: Servlets are rarely accessed by typing their URL directly in the browser. The
    most common use for servlets is to process data entered by users in an HTML form.
    In this section, we illustrate this process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Servlets 很少通过在浏览器中直接键入它们的 URL 来访问。servlet 最常见的用途是处理用户在 HTML 表单中输入的数据。在本节中，我们将说明这个过程。
- en: 'The relevant markup for the HTML file containing the form for our application
    looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 包含我们应用程序表单的 HTML 文件的相应标记如下所示：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value for the form’s `action` attribute must match the value of the servlet’s
    `urlPatterns` attribute in its `@WebServlet` annotation. Since the value of the
    form’s `method` attribute is `"post"`, our servlet’s `doPost()` method will be
    executed when the form is submitted.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的 `action` 属性的值必须与 servlet 的 `urlPatterns` 属性在其 `@WebServlet` 注解中的值匹配。由于表单的
    `method` 属性的值是 `"post"`，因此当表单提交时，我们的 servlet 的 `doPost()` 方法将被执行。
- en: 'Now let’s take a look at our servlet’s code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们的 servlet 代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As can be seen in this example, we obtain a reference to the value the user
    typed by calling the `request.getParameter()` method. This method takes a single
    `String` object as its sole parameter. The value of this string must match the
    name of the input field in the HTML file. In this case, the HTML file has a text
    field named `"enteredValue"`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们通过调用 `request.getParameter()` 方法来获取用户输入的值的引用。此方法仅接受一个 `String` 对象作为其唯一参数。此字符串的值必须与
    HTML 文件中输入字段的名称匹配。在这种情况下，HTML 文件有一个名为 `"enteredValue"` 的文本字段：
- en: '`<input type="text"` `name="enteredValue" />`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input type="text" name="enteredValue" />`'
- en: 'Therefore, the servlet has this corresponding line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，servlet 有相应的这一行：
- en: '`enteredValue =` `request.getParameter("enteredValue");`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`enteredValue = request.getParameter("enteredValue");`'
- en: This is to obtain the text entered by the user and store it in the `String`
    variable named `enteredValue` (the name of the variable does not need to match
    the input field name, but naming it that way is good practice to make it easy
    to remember what value the variable is holding).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了获取用户输入的文本并将其存储在名为 `enteredValue` 的 `String` 变量中（变量的名称不需要与输入字段名称匹配，但这样命名是一种良好的实践，以便于记住变量所持有的值）。
- en: 'After packaging the preceding three files in a WAR file called `formhandling.war`,
    followed by deploying the WAR file, we can see the rendered HTML file by entering
    a URL similar to the following in the browser (the exact URL will depend on the
    Jakarta EE application server being used): `http://localhost:8080/formhandling`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在将前三个文件打包成名为 `formhandling.war` 的 WAR 文件后，接着部署该 WAR 文件，我们可以在浏览器中输入以下类似的 URL
    来查看渲染后的 HTML 文件（确切的 URL 将取决于所使用的 Jakarta EE 应用服务器）：`http://localhost:8080/formhandling`。
- en: The HTML form will be rendered as illustrated in *Figure 11**.2*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 表单将渲染成如图 *图 11.2* 所示。
- en: '![Figure 11.2 – HTML form](img/B21231_11_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – HTML 表单](img/B21231_11_02.jpg)'
- en: Figure 11.2 – HTML form
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – HTML 表单
- en: After the user enters `some text` in the text field and submits the form (either
    by hitting *Enter* or clicking on the **Submit** button), we should see the output
    of the servlet, as illustrated in *Figure 11**.3*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在文本字段中输入 `some text` 并提交表单（无论是按 *Enter* 键还是点击 **提交** 按钮）后，我们应该看到 servlet 的输出，如图
    *图 11.3* 所示。
- en: '![Figure 11.3 – Servlet form handling](img/B21231_11_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Servlet 表单处理](img/B21231_11_03.jpg)'
- en: Figure 11.3 – Servlet form handling
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Servlet 表单处理
- en: The `HttpServletRequest.getParameter()` method can be used to obtain the value
    of any HTML input field that can only return one value (textboxes, text areas,
    single selects, radio buttons, hidden fields, etc.). The procedure to obtain any
    of these fields’ values is identical. In other words, the servlet doesn’t care
    if the user typed in the value in a text field, selected it from a set of radio
    buttons, and so on. As long as the input field’s name matches the value passed
    to the `getParameter()` method, the preceding code will work.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `HttpServletRequest.getParameter()` 方法来获取任何只能返回一个值的 HTML 输入字段的值（文本框、文本区域、单选、单选按钮、隐藏字段等）。获取这些字段值的过程是相同的。换句话说，servlet
    不关心用户是在文本字段中键入值，还是从一组单选按钮中选择值，等等。只要输入字段的名称与传递给 `getParameter()` 方法的值匹配，前面的代码就会工作。
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When dealing with radio buttons, all related radio buttons must have the same
    name. Calling the `HttpServletRequest.getParameter()` method and passing the name
    of the radio buttons will return the value of the selected radio button.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理单选按钮时，所有相关的单选按钮必须具有相同的名称。通过调用 `HttpServletRequest.getParameter()` 方法并传递单选按钮的名称，将返回所选单选按钮的值。
- en: Some HTML input fields such as checkboxes and multiple select boxes allow the
    user to select more than one value. For these fields, instead of using the `HttpServletRequest.getParameter()`
    method, the `HttpServletRequest.getParameterValues()` method is used. This method
    also takes `String` containing the input field’s name as its only parameter and
    returns an array of strings containing all the values that were selected by the
    user.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 HTML 输入字段，如复选框和多个选择框，允许用户选择多个值。对于这些字段，而不是使用 `HttpServletRequest.getParameter()`
    方法，使用 `HttpServletRequest.getParameterValues()` 方法。此方法也接受一个包含输入字段名称的 `String`
    作为其唯一参数，并返回一个包含用户所选所有值的字符串数组。
- en: 'The following example illustrates this case. The relevant sections of our new
    HTML markup are shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了这种情况。我们新的 HTML 标记的相关部分如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The new `HTML` file contains a simple form having three checkboxes and a submit
    button. Notice how every checkbox has the same value for its `name` attribute.
    As we mentioned before, any checkboxes that are clicked by the user will be sent
    to the servlet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `HTML` 文件包含一个简单的表单，有三个复选框和一个提交按钮。注意每个复选框的 `name` 属性值都相同。正如我们之前提到的，用户点击的任何复选框都将发送到
    servlet。
- en: 'Let’s now take a look at the `doPost()` method of the servlet that will handle
    the HTML form:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看将处理 HTML 表单的 servlet 的 `doPost()` 方法：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code calls the `request.getParameterValues()` method and assigns
    its return value to the `selectedOptions` variable. Farther down the `doPost()`
    method, the code traverses the `selectedOptions` array and prints the selected
    values in the browser.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用 `request.getParameterValues()` 方法，并将返回值赋给 `selectedOptions` 变量。在 `doPost()`
    方法的更下方，代码遍历 `selectedOptions` 数组，并在浏览器中打印所选值。
- en: If no checkboxes are clicked, the `request.getParameterValues()` method will
    return `null`, therefore it is a good idea to check for `null` before attempting
    to traverse through this method’s return values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有复选框被点击，`request.getParameterValues()` 方法将返回 `null`，因此在尝试遍历此方法的返回值之前检查 `null`
    是一个好主意。
- en: After packaging our new servlet in a WAR file and deploying it, we can see the
    changes in action by typing its URL in the browser window. In most application
    servers, the URL will be `http://localhost:8080/multiplevaluefields/`. The form
    will be rendered as illustrated in *Figure 11**.4*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的新 servlet 打包成 WAR 文件并部署后，我们可以在浏览器窗口中输入其 URL 来看到实际的变化。在大多数应用服务器中，URL 将是
    `http://localhost:8080/multiplevaluefields/`。表单将如图 *图 11.4* 所示渲染。
- en: '![Figure 11.4 – HTML form with multiple value fields](img/B21231_11_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 具有多个值字段的 HTML 表单](img/B21231_11_04.jpg)'
- en: Figure 11.4 – HTML form with multiple value fields
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 具有多个值字段的 HTML 表单
- en: 'After submitting the form, control goes to our servlet, and the browser window
    should look something like what’s illustrated in *Figure 11**.5*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提交表单后，控制权转到我们的 servlet，浏览器窗口应类似于 *图 11.5* 中所示：
- en: '![Figure 11.5 – Servlet handling fields with multiple values](img/B21231_11_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – Servlet 处理具有多个值的字段](img/B21231_11_05.jpg)'
- en: Figure 11.5 – Servlet handling fields with multiple values
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – Servlet 处理具有多个值的字段
- en: Of course, the actual message seen in the browser window will depend on what
    checkboxes the user clicked on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，浏览器窗口中实际看到的消息将取决于用户点击了哪些复选框。
- en: Now that we’ve seen how to process HTML form data, we’ll focus our attention
    on automatically navigating to a different page via HTTP request forwarding and
    HTTP response redirection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何处理 HTML 表单数据，我们将关注通过 HTTP 请求转发和 HTTP 响应重定向自动导航到不同页面。
- en: Request forwarding and response redirection
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求转发和响应重定向
- en: 'In many cases, one servlet processes form data, then transfers control to another
    servlet or JSP to do some more processing or displays a confirmation message on
    the screen. There are two ways of doing this: either the request can be forwarded
    or the response can be redirected to another servlet or page.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，一个 servlet 处理表单数据，然后转移到另一个 servlet 或 JSP 进行更多处理或显示屏幕上的确认消息。有两种方法可以实现这一点：要么请求可以转发，要么响应可以重定向到另一个
    servlet 或页面。
- en: Request forwarding
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求转发
- en: Notice how the text displayed in the previous section’s example matches the
    value of the value attribute of the checkboxes that were clicked, and not the
    labels displayed on the previous page. This might confuse the users. Let’s modify
    the servlet to change these values so that they match the labels, then forward
    the request to another servlet that will display the confirmation message in the
    browser.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前章节示例中显示的文本与之前页面中点击的复选框的值属性值相匹配，而不是之前页面显示的标签。这可能会让用户感到困惑。让我们修改servlet，将这些值修改为与标签匹配，然后转发请求到另一个servlet，该servlet将在浏览器中显示确认消息。
- en: 'The `doPost()` method for the new version of `MultipleValueFieldHandlerServlet`
    is shown next:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 新版`MultipleValueFieldHandlerServlet`的`doPost()`方法如下所示：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This version of the servlet iterates through the selected options and adds the
    corresponding label to an `ArrayList` of strings. This string is then attached
    to the request object by calling the `request.setAttribute()` method. This method
    is used to attach any object to the request so that any other code we forward
    the request to can have access to it later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的servlet会遍历选中的选项，并将相应的标签添加到一个字符串`ArrayList`中。然后通过调用`request.setAttribute()`方法将这个字符串附加到请求对象上。这个方法用于将任何对象附加到请求上，以便任何其他代码在转发请求后都可以访问它。
- en: 'After attaching `ArrayList` to the request, we then forward the request to
    the new servlet in the following line of code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`ArrayList`附加到请求后，我们然后在以下代码行中转发请求到新的servlet：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `String` argument to this method must match the value of the `urlPatterns`
    tag of the target servlet’s `@``WebServlet` annotation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的`String`参数必须与目标servlet的`@WebServlet`注解中的`urlPatterns`标签的值相匹配。
- en: 'At this point, control goes to our new servlet. Since we are forwarding an
    HTTP POST request, its `doPost()` method is automatically called. The code for
    this new servlet is shown in the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，控制权转交给了我们新的servlet。由于我们正在转发一个HTTP POST请求，其`doPost()`方法会自动被调用。以下示例展示了这个新servlet的代码：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code obtains `ArrayList` that was attached to the request by the previous
    servlet. This is accomplished by calling the `request.getAttribute()` method.
    The parameter for this method must match the value used to attach the object to
    the request.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过调用`request.getAttribute()`方法获取之前servlet附加到请求上的`ArrayList`。这个方法的参数必须与用于将对象附加到请求的值相匹配。
- en: Once the above servlet obtains the list of option labels, it traverses through
    it and displays them in the browser.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上述servlet获取到选项标签列表，它就会遍历这个列表并在浏览器中显示它们。
- en: '![Figure 11.6 – Request forwarding in action](img/B21231_11_06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 请求转发的实际操作](img/B21231_11_06.jpg)'
- en: Figure 11.6 – Request forwarding in action
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 请求转发的实际操作
- en: Forwarding a request as described only works for other resources (servlets and
    JSP pages) in the same context as the code doing the forwarding. In simple terms,
    the servlet or JSP we want to forward to must be packaged in the same WAR file
    as the code that is invoking the `request.getRequestDispatcher().forward()` method.
    If we need to direct the user to a page in another context (or even another server),
    we can do it by redirecting the response object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的请求转发仅适用于与执行转发的代码相同上下文中的其他资源（servlet和JSP页面）。简单来说，我们想要转发的servlet或JSP必须打包在与调用`request.getRequestDispatcher().forward()`方法的代码相同的WAR文件中。如果我们需要将用户引导到另一个上下文中的页面（甚至另一个服务器），我们可以通过重定向响应对象来实现。
- en: Response redirection
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应重定向
- en: One disadvantage of forwarding a request as described in the previous section
    is that requests can only be forwarded to other servlets or JSPs in the same context.
    If we need to direct the user to a page in a different context (deployed in another
    WAR file on the same server or deployed on a different server), we need to use
    the `HttpServletResponse.sendRedirect()` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中描述的请求转发的一个缺点是，请求只能转发到与执行转发的代码相同上下文中的其他servlet或JSP。如果我们需要将用户引导到不同上下文中的页面（部署在同一服务器上的另一个WAR文件中或部署在不同的服务器上），我们需要使用`HttpServletResponse.sendRedirect()`方法。
- en: 'To illustrate response redirection, let’s develop a simple web application
    that asks the user to select their favorite search engine, and then direct the
    user to their search engine of choice. The HTML form for this application would
    look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明响应重定向，让我们开发一个简单的Web应用程序，该程序要求用户选择他们最喜欢的搜索引擎，然后将用户引导到他们选择的搜索引擎。这个应用程序的HTML表单看起来如下所示：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The HTML form in the markup code above contains three radio buttons. The value
    for each of them is the URL for the search engine corresponding to the user’s
    selection. Notice how the value for the `name` attribute of each radio button
    is the same, namely `"searchEngine"`. The servlet will obtain the value of the
    selected radio button by calling the `request.getParameter()` method and passing
    the `"searchEngine"` string as a parameter, as is demonstrated in the code here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的标记代码中的 HTML 表单包含三个单选按钮。每个按钮的值是对应用户选择的搜索引擎的 URL。注意，每个单选按钮的 `name` 属性值相同，即
    `"searchEngine"`。servlet 将通过调用 `request.getParameter()` 方法并传递 `"searchEngine"`
    字符串作为参数来获取所选单选按钮的值，如以下代码所示：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By calling `request.getParameter("searchEngine")`, the code shown here assigns
    the URL of the selected search engine to the `url` variable. Then, (after checking
    for `null`, in case the user clicked on the `response.sendRedirect()` and passing
    the `url` variable as a parameter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `request.getParameter("searchEngine")`，以下代码将所选搜索引擎的 URL 分配给 `url` 变量。然后（在检查
    `null` 之后，以防用户点击了 `response.sendRedirect()` 并将 `url` 变量作为参数传递）。
- en: 'After packaging the code and deploying it, we can see it in action by typing
    a URL similar to the following in the browser: `http://localhost:8080/responseredirection/`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包代码并部署后，我们可以在浏览器中通过输入类似以下 URL 的地址来查看其效果：`http://localhost:8080/responseredirection/`。
- en: '![Figure 11.7 – Response redirection example](img/B21231_11_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 响应重定向示例](img/B21231_11_07.jpg)'
- en: Figure 11.7 – Response redirection example
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 响应重定向示例
- en: After clicking the **Submit** button, the user is directed to their favorite
    search engine.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**提交**按钮后，用户将被引导到他们喜欢的搜索引擎。
- en: It should be noted that redirecting the response as illustrated here creates
    a new HTTP request to the page we are redirecting to, therefore any request parameters
    and attributes are lost.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意，如图所示的重定向响应会创建一个新的 HTTP 请求到我们要重定向到的页面，因此任何请求参数和属性都会丢失。
- en: Persisting application data across requests
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在请求之间持久化应用程序数据
- en: In the previous section, we saw how it is possible to store an object in the
    request by invoking the `HttpRequest.setAttribute()` method, and how later this
    object can be retrieved by invoking the `HttpRequest.getAttribute()` method. This
    approach only works if the request was forwarded to the servlet invoking the `getAttribute()`
    method. If this is not the case, the `getAttribute()` method will return null.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何通过调用 `HttpRequest.setAttribute()` 方法将对象存储在请求中，以及如何通过调用 `HttpRequest.getAttribute()`
    方法稍后检索该对象。这种方法仅在请求被转发到调用 `getAttribute()` 方法的 servlet 时才有效。如果不是这种情况，`getAttribute()`
    方法将返回 null。
- en: It is possible to persist an object across requests. In addition to attaching
    an object to the request object, an object can also be attached to the session
    object or to the servlet context. The difference between these two is that objects
    attached to the session will not be visible to different users, whereas objects
    attached to the servlet context are.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能使对象在请求之间持久化。除了将对象附加到请求对象之外，对象还可以附加到会话对象或 servlet 上下文中。这两种方法之间的区别在于，附加到会话的对象对不同的用户不可见，而附加到
    servlet 上下文的对象是可见的。
- en: 'Attaching objects to the session and servlet context is very similar to attaching
    objects to the request. To attach an object to the session, the `HttpServletRequest.getSession()`
    method must be invoked. This method returns an instance of `jakarta.servlet.http.HttpSession`.
    We then call the `HttpSession.setAttribute()` method to attach the object to the
    session. The following code fragment illustrates the process:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象附加到会话和 servlet 上下文与将对象附加到请求非常相似。要将对象附加到会话，必须调用 `HttpServletRequest.getSession()`
    方法。此方法返回一个 `jakarta.servlet.http.HttpSession` 实例。然后我们调用 `HttpSession.setAttribute()`
    方法将对象附加到会话。以下代码片段说明了这个过程：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then retrieve the object from the session by calling the `HttpSession.getAttribute()`
    method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用 `HttpSession.getAttribute()` 方法从会话中检索对象：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the return value of `session.getAttribute()` needs to be cast to
    the appropriate type. This is necessary since the return value of this method
    is `java.lang.Object`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`session.getAttribute()` 的返回值需要转换为适当的数据类型。这是必要的，因为此方法的返回值是 `java.lang.Object`。
- en: The procedure to attach and retrieve objects to and from the servlet context
    is very similar. The servlet needs to call the `getServletContext()` method (defined
    in the class called `GenericServlet`, which is the parent class of `HttpServlet`,
    which in turn is the parent class of our servlets). This method returns an instance
    of `jakarta.servlet.ServletContext`, which defines a `setAttribute()` and a `getAttribute()`
    method. These methods work the same way as their `HttpServletRequest` and `HttpSessionResponse`
    counterparts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象附加到和从servlet上下文中检索对象的程序非常相似。servlet需要调用`getServletContext()`方法（该方法定义在名为`GenericServlet`的类中，它是`HttpServlet`的父类，而`HttpServlet`又是我们servlets的父类）。此方法返回一个`jakarta.servlet.ServletContext`实例，它定义了`setAttribute()`和`getAttribute()`方法。这些方法的工作方式与它们的`HttpServletRequest`和`HttpSessionResponse`对应方法相同。
- en: 'The procedure to attach an object to the servlet context is illustrated in
    the following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了将对象附加到servlet上下文的程序：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code attaches the `foo` object to the servlet context. This object
    will be available to any servlet in our application and will be the same across
    sessions. It can be retrieved by calling the `ServletContext.getAttribute()` method,
    as is illustrated next:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`foo`对象附加到servlet上下文。此对象将可用于我们应用程序中的任何servlet，并且将在会话之间保持相同。可以通过调用`ServletContext.getAttribute()`方法来检索它，如下所示：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code obtains the `foo` object from the request context. Again, a cast is
    needed since the `ServletContext.getAttribute()` method, like its counterparts,
    returns an instance of `java.lang.Object`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从请求上下文中获取`foo`对象。同样，需要一个转换，因为`ServletContext.getAttribute()`方法，就像它的对应方法一样，返回一个`java.lang.Object`实例。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Objects attached to the servlet context are said to have a scope of *application*.
    Similarly, objects attached to the session are said to have a scope of *session*,
    and objects attached to the request are said to have a scope of *request*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到servlet上下文的对象被称为具有*应用程序*范围。同样，附加到会话的对象被称为具有*会话*范围，而附加到请求的对象被称为具有*请求*范围。
- en: Passing initialization parameters to a servlet via annotations
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过注解将初始化参数传递给servlet
- en: Sometimes it is useful to pass some initialization parameters to a servlet.
    That way, we can make said servlet behave differently based on the parameters
    that are sent to it. For example, we may want to configure a servlet to behave
    differently in development and production environments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将一些初始化参数传递给servlet是有用的。这样，我们可以根据发送给它的参数使servlet表现不同。例如，我们可能希望配置servlet在开发和生产环境中表现不同。
- en: 'In the old days, servlet initialization parameters were sent via the `<init-param>`
    parameter in `web.xml`. As of servlet 3.0, initialization parameters can be passed
    to the servlet as the value of the `initParams` attribute of the `@WebServlet`
    annotation. The following example illustrates how to do this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，servlet初始化参数是通过`web.xml`中的`<init-param>`参数发送的。从servlet 3.0开始，初始化参数可以作为`@WebServlet`注解的`initParams`属性的值传递给servlet。以下示例说明了如何这样做：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we can see, the value of the `initParams` attribute of the `@WebServlet`
    annotation is an array of `@WebInitParam` annotations. Each `@WebInitParam` annotation
    has two attributes: `name`, which corresponds to the parameter name, and `value`,
    which corresponds to the parameter value.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`@WebServlet`注解的`initParams`属性的值是一个`@WebInitParam`注解的数组。每个`@WebInitParam`注解有两个属性：`name`，对应于参数名称，和`value`，对应于参数值。
- en: We can obtain the values of our parameters by invoking the `getInitParameter()`
    method on the `jakarta.servlet.ServletConfig` class. This method takes a single
    `String` argument as a parameter, corresponding to the parameter name, and returns
    `String` corresponding to the parameter value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`jakarta.servlet.ServletConfig`类上调用`getInitParameter()`方法来获取我们参数的值。此方法接受一个`String`类型的单个参数作为参数，对应于参数名称，并返回与参数值对应的`String`。
- en: Each servlet has a corresponding instance of `ServletConfig` assigned to it.
    As we can see in this example, we can obtain this instance by invoking `getServletConfig()`,
    which is a method inherited from `jakarta.servlet.GenericServlet`, the parent
    class of `HttpServlet`, which our servlets extend.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个servlet都有一个对应的`ServletConfig`实例分配给它。正如我们在这个示例中所看到的，我们可以通过调用`getServletConfig()`方法来获取这个实例，这是一个从`jakarta.servlet.GenericServlet`继承而来的方法，`jakarta.servlet.GenericServlet`是`HttpServlet`的父类，我们servlets扩展了这个类。
- en: After packaging and deploying our servlet, then pointing the browser to the
    servlet URL, we will see the following page rendered in the browser, as shown
    in *Figure 11**.8*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包和部署我们的servlet之后，然后指向servlet的URL，我们将在浏览器中看到以下页面渲染，如图*图11.8*所示。8*。
- en: '![Figure 11.8 – Servlet initialization parameters](img/B21231_11_08.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – Servlet初始化参数](img/B21231_11_08.jpg)'
- en: Figure 11.8 – Servlet initialization parameters
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – Servlet初始化参数
- en: As we can see, the rendered values correspond to the values we have set in each
    `@``WebInitParam` annotation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，渲染的值对应于我们在每个`@WebInitParam`注解中设置的值。
- en: Now that we’ve seen how to initialize a servlet, we’ll shift our attention to
    intercepting HTTP requests via servlet filters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何初始化一个servlet，我们将把注意力转向通过servlet过滤器拦截HTTP请求。
- en: Servlet filters
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet过滤器
- en: A `doGet()` or `doPost()` method finishes, but before the output is sent to
    the browser.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`doGet()`或`doPost()`方法完成，但在输出发送到浏览器之前。'
- en: The only way to configure a filter in earlier servlet specifications was to
    use the `<filter-mapping>` tag in `web.xml`. `@``WebFilter` annotation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的servlet规范中配置过滤器的方法是使用`web.xml`中的`<filter-mapping>`标签。`@WebFilter`注解。
- en: 'The following example illustrates how to do this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何进行此操作：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see in the example, the `@WebFilter` annotation has several attributes
    we can use to configure the filter. Of special importance is the `urlPatterns`
    attribute. This attribute takes an array of `String` objects as its value. Each
    element in the array corresponds to a URL that our filter will intercept. In our
    example, we are intercepting a single URL pattern, which corresponds to the servlet
    we wrote in the previous section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在示例中看到的，`@WebFilter`注解有几个我们可以用来配置过滤器的属性。其中特别重要的是`urlPatterns`属性。此属性接受一个`String`对象数组作为其值。数组中的每个元素对应于我们的过滤器将拦截的URL。在我们的示例中，我们正在拦截一个单个URL模式，它对应于我们在上一节中编写的servlet。
- en: Other attributes in the `@WebFilter` annotation include the optional `filterName`
    attribute, which we can use to give our filter a name. If we don’t specify a name
    for our filter, then the filter name defaults to the filter’s class name.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebFilter`注解中的其他属性包括可选的`filterName`属性，我们可以使用它来给我们的过滤器命名。如果我们没有为我们的过滤器指定名称，那么过滤器名称将默认为过滤器的类名。'
- en: As we can see in our example servlet filter, we can send initialization parameters
    to a filter. This is done just like we send initialization parameters to a servlet.
    The `@WebFilter` annotation has an `initParams` attribute that takes an array
    of `@WebInitParam` annotations as its value. We can obtain the values of said
    parameters by invoking the `getInitParameter()` method on `jakarta.servlet.FilterConfig`,
    as illustrated in the example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在示例servlet过滤器中看到的，我们可以向过滤器发送初始化参数。这就像我们向servlet发送初始化参数一样进行。`@WebFilter`注解有一个`initParams`属性，它接受一个`@WebInitParam`注解数组作为其值。我们可以通过在`jakarta.servlet.FilterConfig`上调用`getInitParameter()`方法来获取这些参数的值，如示例所示。
- en: 'Our filter is fairly simple; it simply sends some output to the server log
    before and after the servlet is invoked. Inspecting the server log after deploying
    our application and pointing the browser to the servlet’s URL should reveal our
    filter’s output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤器相当简单；它只是在servlet被调用之前和之后向服务器日志发送一些输出。部署我们的应用程序后检查服务器日志并将浏览器指向servlet的URL应该会揭示我们的过滤器输出：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some common uses of servlet filters include profiling web applications, applying
    security, and compressing data, among others.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的servlet过滤器用途包括分析Web应用、应用安全性和压缩数据等。
- en: Servlet listeners
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet监听器
- en: During the lifetime of a typical web application, a number of events take place,
    such as HTTP requests being created or destroyed, request or session attributes
    being added, removed, or modified, and so on and so forth.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型Web应用的整个生命周期中，会发生许多事件，例如HTTP请求的创建或销毁，请求或会话属性的增加、删除或修改，等等。
- en: The servlet API provides a number of listener interfaces we can implement in
    order to react to these events. All of these interfaces are in the `jakarta.servlet`
    package. The following table summarizes them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: servlet API提供了一些我们可以实现以响应这些事件的监听器接口。所有这些接口都在`jakarta.servlet`包中。以下表格总结了它们。
- en: '| **Listener Interface** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **监听器接口** | **描述** |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ServletContextListener` | Contains methods for handling context initialization
    and destruction events. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `ServletContextListener` | 包含处理上下文初始化和销毁事件的方法。 |'
- en: '| `ServletContextAttributeListener` | Contains methods for reacting to any
    attributes added, removed, or replaced in the servlet context (application scope).
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `ServletContextAttributeListener` | 包含用于响应在servlet上下文（应用范围）中添加、删除或替换的任何属性的的方法。|'
- en: '| `ServletRequestListener` | Contains methods for handling request initialization
    and destruction events. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `ServletRequestListener` | 包含用于处理请求初始化和销毁事件的方法。|'
- en: '| `ServletRequestAttributeListener` | Contains methods for reacting to any
    attributes added, removed, or replaced in the request. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `ServletRequestAttributeListener` | 包含用于响应在请求中添加、删除或替换的任何属性的方法。|'
- en: '| `HttpSessionListener` | Contains methods for handling HTTP session initialization
    and destruction events. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `HttpSessionListener` | 包含用于处理HTTP会话初始化和销毁事件的方法。|'
- en: '| `HttpSessionAttributeListener` | Contains methods for reacting to any attributes
    added, removed, or replaced in the HTTP session. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `HttpSessionAttributeListener` | 包含用于响应在HTTP会话中添加、删除或替换的任何属性的方法。|'
- en: Table 11.2 – Servlet listener interfaces
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 – Servlet监听器接口
- en: All we need to do to handle any of the events handled by the interfaces described
    in the preceding table is to implement one of the interfaces and annotate it with
    the `@WebListener` interface or declare it in the `web.xml` deployment descriptor
    via the `<``listener>` tag.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理前面表中描述的接口所处理的所有事件，我们只需实现其中一个接口，并使用`@WebListener`接口对其进行注解，或者通过`web.xml`部署描述符中的`<listener>`标签声明它。
- en: The API for all of the preceding interfaces is fairly straightforward and intuitive.
    We will show an example for one of the interfaces. Others will be very similar.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面接口的API相当直观和直观。我们将为其中一个接口提供一个示例。其他接口将非常相似。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The JavaDoc for all of the preceding interfaces can be found at [https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/package-summary](https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/package-summary)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面接口的JavaDoc可以在[https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/package-summary](https://jakarta.ee/specifications/platform/10/apidocs/jakarta/servlet/package-summary)找到。
- en: 'The following example illustrates how to implement the `ServletRequestListener`
    interface, which can be used to perform some action whenever an HTTP request is
    created or destroyed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何实现`ServletRequestListener`接口，该接口可以在创建或销毁HTTP请求时执行某些操作：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, all we need to do to activate our listener class is to annotate
    it with the `@WebListener` annotation. Our listener must also implement one of
    the listener interfaces we listed. In our example, we chose to implement `jakarta.servlet.ServletRequestListener`.
    This interface has methods that are automatically invoked whenever an HTTP request
    is initialized or destroyed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，要激活我们的监听器类，我们只需使用`@WebListener`注解对其进行注解。我们的监听器还必须实现我们列出的监听器接口之一。在我们的示例中，我们选择实现`jakarta.servlet.ServletRequestListener`。该接口包含在初始化或销毁HTTP请求时自动调用的方法。
- en: The `ServletRequestListener` interface has two methods, `requestInitialized()`
    and `requestDestroyed()`. In the preceding simple implementation, we simply sent
    some output to the log, but of course, we can do anything we need to do in our
    implementations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServletRequestListener`接口有两个方法，`requestInitialized()`和`requestDestroyed()`。在前面的简单实现中，我们只是向日志发送了一些输出，但当然，我们可以在我们的实现中做任何我们需要做的事情。'
- en: 'Using our listener to listen to requests handled by the simple servlet we developed
    earlier in the chapter results in the following output in the Jakarta EE runtime
    log:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的监听器监听本章前面开发的简单servlet处理请求，将在Jakarta EE运行时日志中产生以下输出：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implementing the other listener interfaces is just as simple and straightforward.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实现其他监听器接口同样简单直接。
- en: Pluggability
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可插拔性
- en: When the original servlet API was released back in the late 1990s, writing servlets
    was the only way of writing server-side web applications in Java. Since then,
    several Jakarta EE and third-party frameworks have been built on top of the Servlet
    API. Examples of such frameworks include JSP and JSF, Apache Struts, Apache Wicket,
    Spring Web MVC, and several others.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当原始servlet API在20世纪90年代末发布时，编写servlet是Java编写服务器端Web应用的唯一方式。从那时起，在Servlet API之上构建了几个Jakarta
    EE和第三方框架。这些框架的例子包括JSP和JSF、Apache Struts、Apache Wicket、Spring Web MVC以及几个其他框架。
- en: Nowadays, very few (if any) Java web applications are built using the Servlet
    API directly. Instead, the vast majority of projects utilize one of the available
    Java web application frameworks. All of these frameworks use the servlet API “under
    the covers,” therefore setting up an application to use one of these frameworks
    has always involved making some configuration in the application’s `web.xml` deployment
    descriptor. In some cases, some applications use more than one framework. This
    tends to make the `web.xml` deployment descriptor fairly large and hard to maintain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，极少数（如果有的话）Java Web应用是直接使用Servlet API构建的。相反，绝大多数项目都使用可用的Java Web应用框架之一。所有这些框架都在“幕后”使用servlet
    API，因此设置一个应用以使用这些框架之一始终涉及到在应用的`web.xml`部署描述符中进行一些配置。在某些情况下，一些应用使用多个框架。这往往使得`web.xml`部署描述符相当大且难以维护。
- en: Servlet 3.0 introduced the concept of pluggability. Web application framework
    developers now have not one, but two ways to avoid having application developers
    have to modify the `web.xml` deployment descriptor in order to use their framework.
    Framework developers can choose to use annotations instead of `web.xml` to configure
    their servlets. After doing this, all that is needed to use the framework is to
    include the `library jar` file(s) provided by the framework developers in the
    application’s WAR file. Alternatively, framework developers may choose to include
    `web-fragment.xml` as part of the JAR file to be included in web applications
    that use their framework.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 3.0引入了可插拔性的概念。Web应用框架的开发者现在有两个选择，而不是一个，以避免应用开发者必须修改`web.xml`部署描述符才能使用他们的框架。框架开发者可以选择使用注解而不是`web.xml`来配置他们的servlet。完成此操作后，要使用框架，只需将框架开发者提供的`library
    jar`文件包含在应用的WAR文件中即可。或者，框架开发者可以选择将`web-fragment.xml`包含在JAR文件中，作为使用他们框架的Web应用的组成部分。
- en: '`web-fragment.xml` is almost identical to `web.xml`. The main difference is
    that the root element of `web-fragment.xml` is `<web-fragment>` as opposed to
    `<web-app>`. The following example illustrates a sample `web-fragment.xml`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`web-fragment.xml`几乎与`web.xml`相同。主要区别在于`web-fragment.xml`的根元素是`<web-fragment>`，而不是`<web-app>`。以下是一个示例`web-fragment.xml`：'
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see, `web-fragment.xml` is almost identical to typical `web.xml`.
    In this simple example, we only use the `<servlet>` and `<servlet-mapping>` elements,
    but all other usual `web.xml` elements such as `<filter>`, `<filter-mapping>`,
    and `<listener>` are available as well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`web-fragment.xml`几乎与典型的`web.xml`相同。在这个简单的示例中，我们只使用了`<servlet>`和`<servlet-mapping>`元素，但所有其他通常的`web.xml`元素，如`<filter>`、`<filter-mapping>`和`<listener>`也是可用的。
- en: As specified in `web-fragment.xml`, our servlet can be invoked via its URL pattern,
    `/WebFragment`, therefore the URL to execute our servlet once deployed as part
    of a web application would be `http://localhost:8080/webfragmentapp/WebFragment`.
    Of course, the hostname, port, and context root must be adjusted as appropriate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如`web-fragment.xml`中指定，我们的servlet可以通过其URL模式`/WebFragment`被调用，因此一旦作为Web应用的一部分部署，执行我们的servlet的URL将是`http://localhost:8080/webfragmentapp/WebFragment`。当然，主机名、端口号和上下文根必须根据实际情况进行调整。
- en: All we need to do for any Jakarta EE-compliant application server to pick up
    the settings in `web-fragment.xml` is to place the file in the `META-INF` folder
    of the library where we pack our servlet, filter, and/or listener, then place
    our library’s `jar` file in the `lib` directory of the WAR file containing our
    application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何符合Jakarta EE规范的应用服务器，要获取`web-fragment.xml`中的设置，我们只需将文件放置在我们打包servlet、过滤器以及/或监听器的库的`META-INF`文件夹中，然后将我们的库的`jar`文件放置在包含我们的应用的WAR文件的`lib`目录中。
- en: Configuring web applications programmatically
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以编程方式配置Web应用
- en: In addition to allowing us to configure web applications through annotations
    and `web-fragment.xml`, Servlet 3.0 also allows us to configure our web applications
    programmatically at runtime.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以通过注解和`web-fragment.xml`配置Web应用之外，Servlet 3.0还允许我们在运行时以编程方式配置我们的Web应用。
- en: 'The `ServletContext` class has new methods to configure servlets, filters,
    and listeners programmatically. The following example illustrates how to configure
    a servlet programmatically at runtime, without resorting to the `@WebServlet`
    annotation or to XML:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServletContext`类有新的方法来以编程方式配置servlet、过滤器（filter）和监听器（listener）。以下示例说明了如何在运行时以编程方式配置servlet，而不需要使用`@WebServlet`注解或XML：'
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we invoke the `createServlet()` method of `ServletContext`
    to create the servlet that we are about to configure. This method takes an instance
    of `java.lang.Class` corresponding to our servlet’s class. This method returns
    a class implementing `jakarta.servlet.Servlet` or any of its child interfaces.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们调用`ServletContext`的`createServlet()`方法来创建我们即将配置的servlet。此方法接受一个与我们的servlet类对应的`java.lang.Class`实例。此方法返回一个实现`jakarta.servlet.Servlet`或其任何子接口的类。
- en: Once we create our servlet, we need to invoke `addServlet()` on our `ServletContext`
    instance to register our servlet with the servlet container. This method takes
    two parameters, the first being `String` corresponding to the servlet name and
    the second being the servlet instance returned by the call to `createServlet()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的servlet，我们需要在我们的`ServletContext`实例上调用`addServlet()`来将我们的servlet注册到servlet容器中。此方法接受两个参数，第一个是与servlet名称对应的`String`，第二个是由`createServlet()`调用返回的servlet实例。
- en: Once we have registered our servlet, we need to add a URL mapping to it. In
    order to do this, we need to invoke the `getServletRegistration()` method on our
    `ServletContext` instance, passing the servlet name as a parameter. This method
    returns the servlet container’s implementation of `jakarta.servlet.ServletRegistration`.
    From this object, we need to invoke its `addMapping()` method, passing the URL
    mapping we wish our servlet to handle.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们注册了我们的servlet，我们需要向其添加URL映射。为了做到这一点，我们需要在我们的`ServletContext`实例上调用`getServletRegistration()`方法，并将servlet名称作为参数传递。此方法返回servlet容器对`jakarta.servlet.ServletRegistration`的实现。从这个对象中，我们需要调用它的`addMapping()`方法，传递我们希望我们的servlet处理的URL映射。
- en: 'Our example servlet is very simple. It simply displays a text message in the
    browser. Its `doGet()` method looks as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例servlet非常简单。它只是简单地显示一个文本消息在浏览器中。它的`doGet()`方法如下所示：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After packing our code in a WAR file and deploying it to a Jakarta EE runtime,
    then pointing the browser to the appropriate URL (i.e `http://localhost:8080/programmaticservletwebapp/ProgrammaticallyConfiguredServlet`),
    we should see the following message in the browser:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的代码打包到WAR文件并部署到Jakarta EE运行时之后，然后指向适当的URL（即`http://localhost:8080/programmaticservletwebapp/ProgrammaticallyConfiguredServlet`），我们应该在浏览器中看到以下消息：
- en: '**This message was generated from a servlet that was** **configured programmatically.**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**此消息是由配置程序的servlet生成的**。'
- en: The `ServletContext` interface has methods to create and add servlet filters
    and listeners. They work very similarly to the way the `addServlet()` and `createServlet()`
    methods work, therefore we won’t be discussing them in detail. Refer to the Jakarta
    EE API documentation at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)
    for details.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServletContext`接口有创建和添加servlet过滤器监听器的方法。它们的工作方式与`addServlet()`和`createServlet()`方法非常相似，因此我们不会详细讨论它们。有关详细信息，请参阅[https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)的Jakarta
    EE API文档。'
- en: Asynchronous processing
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理
- en: Traditionally, servlets have created a single thread per request in Java web
    applications. After a request is processed, the thread is made available for other
    requests to use. This model works fairly well for traditional web applications,
    in which HTTP requests are relatively few and far between. However, most modern
    web applications take advantage of **Ajax** (short for **Asynchronous JavaScript
    and XML**), a technique that makes web applications behave much more responsively
    than traditional web applications.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，servlet在Java Web应用程序中为每个请求创建一个线程。请求处理完毕后，线程被提供给其他请求使用。这种模型对于传统Web应用程序来说效果相当好，因为HTTP请求相对较少且间隔较远。然而，大多数现代Web应用程序都利用了**Ajax**（异步JavaScript和XML的缩写），这是一种使Web应用程序比传统Web应用程序更具有响应性的技术。
- en: Ajax has the side effect of generating a lot more HTTP requests than traditional
    web applications. If some of these threads block for a long time waiting, for
    a resource to be ready or doing anything that takes a long time to process, it
    is possible our application may suffer from thread starvation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax的一个副作用是生成比传统Web应用程序更多的HTTP请求。如果其中一些线程长时间阻塞等待资源就绪或进行任何需要很长时间处理的事情，那么我们的应用程序可能会遭受线程饥饿。
- en: To alleviate the situation described in the previous paragraph, the Servlet
    3.0 specification introduced asynchronous processing. Using this new capability,
    we are no longer limited to a single thread per request. We can now spawn a separate
    thread and return the original thread back to the pool, to be reused by other
    clients.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解前一段描述的情况，Servlet 3.0 规范引入了异步处理。使用这项新功能，我们不再受限于每个请求一个线程的限制。现在我们可以创建一个单独的线程，并将原始线程返回到线程池，以便其他客户端重用。
- en: 'The following example illustrates how to implement asynchronous processing
    using the new capabilities introduced in Servlet 3.0:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何利用 Servlet 3.0 中引入的新功能实现异步处理：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first thing we need to do to make sure our asynchronous processing code
    works as expected is to set the `asyncSupported` attribute of the `@WebServlet`
    annotation to `true`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的异步处理代码按预期工作，我们首先需要将 `@WebServlet` 注解的 `asyncSupported` 属性设置为 `true`。
- en: To actually spawn an asynchronous process, we need to invoke the `startAsync()`
    method on the instance of `HttpServletRequest` that we receive as a parameter
    in the `doGet()` or `doPost()` method in our servlet. This method returns an instance
    of `jakarta.servlet.AsyncContext`. This class has a `start()` method that takes
    an instance of a class implementing `java.lang.Runnable` as its sole parameter.
    In our example, we used an anonymous inner class to implement `Runnable` in line.
    Of course, a standard Java class implementing `Runnable` can be used as well,
    or a lambda expression.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际启动一个异步进程，我们需要在 servlet 的 `doGet()` 或 `doPost()` 方法中作为参数接收到的 `HttpServletRequest`
    实例上调用 `startAsync()` 方法。此方法返回一个 `jakarta.servlet.AsyncContext` 实例。这个类有一个 `start()`
    方法，它接受一个实现 `java.lang.Runnable` 接口的类的实例作为唯一参数。在我们的示例中，我们使用匿名内部类在行内实现了 `Runnable`。当然，也可以使用实现
    `Runnable` 的标准 Java 类，或者使用 lambda 表达式。
- en: When we invoke the `start()` method of `AsyncContext`, a new thread is spawned
    and the `run()` method of the `Runnable` instance is executed. This thread runs
    in the background, the `doGet()` method returns immediately, and the request thread
    is immediately available to service other clients. It is important to notice that,
    even though the `doGet()` method returns immediately, the response is not committed
    until after the thread spawned finishes. It can signal it is done processing by
    invoking the `complete()` method on `AsyncContext`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `AsyncContext` 的 `start()` 方法时，会创建一个新的线程，并执行 `Runnable` 实例的 `run()` 方法。这个线程在后台运行，`doGet()`
    方法立即返回，请求线程立即可用于服务其他客户端。重要的是要注意，尽管 `doGet()` 方法立即返回，但响应直到创建线程的线程完成处理后才会提交。它可以通过在
    `AsyncContext` 上调用 `complete()` 方法来表示处理完成。
- en: In our example, the message **You should see this after a brief wait** is displayed
    in the browser after 10 seconds, which is how long our spawned thread takes to
    complete.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，消息 **您将在短暂等待后看到此信息** 在 10 秒后显示在浏览器中，这是我们创建的线程完成所需的时间。
- en: Now that we’ve seen how to perform asynchronous processing in servlets, we’ll
    focus our attention on how to implement HTTP/2 server push support.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 servlet 中执行异步处理，我们将关注如何实现 HTTP/2 服务器推送支持。
- en: HTTP/2 server push support
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2 服务器推送支持
- en: '**HTTP/2** is the newest version of the HTTP protocol. It offers several advantages
    over HTTP 1.1\. For example, with HTTP/2 there is a single connection between
    the browser and the server, and this connection remains open until the user navigates
    to another page. HTTP/2 also offers multiplexing, meaning that several concurrent
    requests from the browser to the server are allowed. Additionally, HTTP/2 features
    server push, meaning that the server can send resources to the browser without
    the browser specifically having to request them.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP/2** 是 HTTP 协议的最新版本。它相较于 HTTP 1.1 提供了多项优势。例如，在 HTTP/2 中，浏览器和服务器之间只有一个连接，并且这个连接在用户导航到另一个页面之前保持开启状态。HTTP/2
    还提供了多路复用功能，这意味着允许浏览器向服务器发送多个并发请求。此外，HTTP/2 还具有服务器推送功能，这意味着服务器可以在浏览器没有特别请求的情况下向浏览器发送资源。'
- en: 'HTTP/2 server push support was added to the servlet specification in version
    4.0, released as part of Java EE 8\. In this section, we’ll see how we can write
    code to take advantage of HTTP/2’s server push functionality. The following example
    illustrates how this can be done:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 服务器推送支持在 Servlet 规范的第 4.0 版本中添加，该版本作为 Java EE 8 的一部分发布。在本节中，我们将看到如何编写代码以利用
    HTTP/2 的服务器推送功能。以下示例说明了如何实现这一点：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can push resources to the browser via the `PushBuilder` interface, introduced
    in version 4 of the servlet specification. We can obtain an instance of a class
    implementing `PushBuilder` by invoking the new `PushBuilder()` method on the instance
    of `HttpServletRequest` we get as a parameter in our `doPost()` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在servlet规范的第4版中引入的`PushBuilder`接口将资源推送到浏览器。我们可以通过在`doPost()`方法中作为参数获得的`HttpServletRequest`实例上调用新的`PushBuilder()`方法来获取实现`PushBuilder`的类的实例。
- en: As its name implies, the `PushBuilder` interface implements the Builder pattern,
    meaning that most of its methods return a new instance of `PushBuilder` we can
    use, allowing us to conveniently chain together method invocations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`PushBuilder`接口实现了Builder模式，这意味着其大多数方法都返回一个新的`PushBuilder`实例，我们可以使用它，允许我们方便地将方法调用链式连接起来。
- en: We indicate the path of the resource we’d like to push to the browser by invoking
    `PushBuilder`’s appropriately named `path()` method. This method takes a single
    `String` argument indicating the path of the resource to push. Paths beginning
    with a forward slash `("/")` indicate an absolute path; all other paths indicate
    a path relative to our application’s context root.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`PushBuilder`的相应命名的`path()`方法来指示我们希望推送到浏览器的资源的路径。此方法接受一个表示要推送的资源路径的单个`String`参数。以正斜杠`("/")`开头的路径表示绝对路径；所有其他路径表示相对于我们应用程序上下文根的路径。
- en: Once we have specified the path of our resource, we can optionally set some
    HTTP headers. In our case, we are pushing an image in PNG format, therefore we
    set the content type as appropriate.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们指定了资源的路径，我们可以选择性地设置一些HTTP头。在我们的例子中，我们正在推送一个PNG格式的图像，因此我们设置了适当的内容类型。
- en: Finally, we invoke the `push()` method on our `PushBuilder` instance to actually
    push our resource to the browser.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在我们的`PushBuilder`实例上调用`push()`方法，实际上将我们的资源推送到浏览器。
- en: What we accomplished with our example was pushing a resource to the browser
    before the browser submitted a request for it. This task was impossible before
    the HTTP/2 protocol was released.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们完成了在浏览器提交对该资源的请求之前将其推送到浏览器的工作。在HTTP/2协议发布之前，这项任务是不可能的。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered how to develop, configure, package, and deploy servlets.
    The following topics were covered in this chapter:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何开发、配置、打包和部署servlets。本章涵盖了以下主题：
- en: How to process HTML form information by accessing the HTTP request object
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过访问HTTP请求对象来处理HTML表单信息
- en: Forwarding HTTP requests from one servlet to another was covered, as well as
    redirecting the HTTP response to a different server
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HTTP请求从一个servlet转发到另一个servlet，以及将HTTP响应重定向到不同的服务器
- en: Persisting objects in memory across requests by attaching them to the servlet
    context and the HTTP session
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将对象附加到servlet上下文和HTTP会话来在请求之间持久化对象
- en: Configuring web applications via annotations
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注解配置Web应用程序
- en: Pluggability through `web-fragment.xml`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`web-fragment.xml`实现可插拔性
- en: Programmatic servlet configuration
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程式servlet配置
- en: Asynchronous processing
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理
- en: HTTP/2 server push
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2服务器推送
- en: Armed with the knowledge from this chapter, we can now implement server-side
    web application logic using Jakarta servlets.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 带着本章的知识，我们现在可以使用Jakarta servlets实现服务器端Web应用程序逻辑。
