- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a Use Case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s finally look at how we can manifest the architecture we have discussed
    in actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Since the application, web, and persistence layers are so loosely coupled in
    our architecture, we’re totally free to model our domain code as we see fit. We
    can do **Domain-Driven Design** (**DDD**), implement a rich or anemic domain model,
    or invent our own way of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes an opinionated way of implementing use cases within the
    Hexagonal Architecture style we introduced in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As is fitting for a domain-centric architecture, we’ll start with a domain entity
    and then build a use case around it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the domain model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to implement the use case of sending money from one account to another.
    One way to model this in an object-oriented fashion is to create an `Account`
    entity that allows us to withdraw money from a source account and deposit it into
    a target account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Account` entity provides the current snapshot of an actual account. Every
    withdrawal from and deposit to an account is captured in an `Activity` entity.
    Since it would not be wise to always load all activities of an account into memory,
    the `Account` entity only holds a window of the last few days or weeks of activities,
    captured in the `ActivityWindow` value object.
  prefs: []
  type: TYPE_NORMAL
- en: To still be able to calculate the current account balance, the `Account` entity
    additionally has the `baselineBalance` attribute, representing the balance the
    account had just before the first activity of the activity window. The total balance,
    then, is the baseline balance plus the balance of all activities in the window.
  prefs: []
  type: TYPE_NORMAL
- en: With this model, withdrawing and depositing money into an account is a matter
    of adding a new activity to the activity window, as is done in the `withdraw()`
    and `deposit()` methods. Before we can withdraw, we check the business rule that
    says that we cannot overdraw an account.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an `Account` that allows us to withdraw and deposit money,
    we can move outward to build a use case around it.
  prefs: []
  type: TYPE_NORMAL
- en: A use case in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let’s discuss what a use case actually does. Usually, it follows these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the business rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manipulate the model state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A use case takes input from an incoming adapter. You might wonder why I didn’t
    call the first step *Validate input*. The answer is that I believe use case code
    should only be concerned with domain logic and we shouldn’t pollute it with input
    validation. So, we’ll do input validation somewhere else, as we’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The use case is, however, responsible for validating business rules. It shares
    this responsibility with the domain entities. We’ll discuss the distinction between
    **input validation** and **business rule validation** later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If the business rules were satisfied, the use case then manipulates the state
    of the model in one way or another, based on the input. Usually, it will change
    the state of a domain object and pass this new state to a port implemented by
    the persistence adapter to be persisted. If the use case drives other side effects
    than persistence, it invokes an appropriate adapter for each side effect.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to translate the return value from the outgoing adapter into
    an output object, which will be returned to the calling adapter.
  prefs: []
  type: TYPE_NORMAL
- en: With these steps in mind, let’s see how we can implement our *Send money* use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the problem of broad services discussed in [*Chapter 2*](B19916_05.xhtml),
    *What’s Wrong with Layers?*, we’ll create a separate service class for each use
    case instead of putting all use cases into a single service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a teaser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The service implements the `SendMoneyUseCase` incoming port interface and calls
    the `Load` **AccountPort** outgoing port interface to load an account and the
    `UpdateAccountState` **Port** port to persist an updated account state in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: The service also sets the boundary for a database transaction, as implied by
    the `@Transactional` annotation. More about this in [*Chapter 7*](B19916_07.xhtml#_idTextAnchor062)*,
    Implementing a* *Persistence Adapter*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.1* provides a visual overview of the relevant components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A service implements a use case, modifies the domain model,
    and calls an outgoing port to persist the modified state](img/Figure_05.01_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – A service implements a use case, modifies the domain model, and
    calls an outgoing port to persist the modified state
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`UpdateAccountStatePort` and `LoadAccountPort`, in this example, are port interfaces
    implemented by a persistence adapter. If they are often used together, we could
    also combine them into a broader interface. We could even call that interface
    `AccountRepository` to stick with the DDD language. In this example, and in the
    rest of the book, I chose to use the name “Repository” only in the persistence
    adapter, but you may choose different names!'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take care of those `TODO` comments we left in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Validating input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we’re talking about validating input, even though I just claimed that it’s
    not the responsibility of a use case class. I still think, however, that it belongs
    in the application layer, so this is the place to discuss it.
  prefs: []
  type: TYPE_NORMAL
- en: Why not let the calling adapter validate the input before sending it to the
    use case? Well, do we want to trust the caller to have validated everything as
    needed for the use case? Also, the use case might be called by more than one adapter,
    so the validation would have to be implemented by each adapter, and one might
    get it wrong or forget it altogether.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer should care about input validation because, well, otherwise
    it might get invalid input from outside the application core. This might cause
    damage to the state of our model.
  prefs: []
  type: TYPE_NORMAL
- en: But where do we put the input validation if not in the use case class?
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll let the input model take care of it. For the *Send money* use case, the
    input model is the `SendMoneyCommand` class we have already seen in the previous
    code example. More precisely, we’ll do the validation within the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To send money, we need the IDs of the source and target account and the amount
    of money that is to be transferred. None of the parameters may be `null` and the
    amount must be greater than zero. If any of these conditions is violated, we simply
    refuse object creation by throwing an exception during construction.
  prefs: []
  type: TYPE_NORMAL
- en: By using a `SendMoneyCommand`, we make it **immutable**. So, once constructed
    successfully, we can be sure that the state is valid and cannot be changed to
    something invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Since `SendMoneyCommand` is part of the use cases’ API, it’s located in the
    incoming port package. Thus, the validation remains in the core of the application
    (at the edge of the hexagon of our architecture) but does not pollute the sacred
    use case code.
  prefs: []
  type: TYPE_NORMAL
- en: But do we really want to implement each validation check by hand when there
    are libraries that can do the dirty work for us? I have often heard statements
    such as “You shouldn’t use libraries in your model classes.” There’s wisdom in
    reducing dependencies to a minimum, of course, but if we can get away with a small-footprint
    dependency that saves us time, then why not use it? Let’s explore what this might
    look like with Java’s Bean Validation API.[1](#footnote-021)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-021-backlink) Bean Validation: [https://beanvalidation.org/](https://beanvalidation.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bean Validation allows us to express the validation rules we need as annotations
    on the fields of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The class `Validator` provides the method `validate()`, which we simply call
    as the last statement in the constructor. This will evaluate the Bean Validation
    annotations on the fields (`@NotNull`, in this case) and throw an exception in
    case of a violation. If the default Bean Validation annotations are not expressive
    enough for a certain validation, we can implement our own annotations and validators
    as we did with the `@``PositiveMoney` annotation.[2](#footnote-020)
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-020-backlink) You can find the full code implementing the `@PositiveMoney`
    annotation and validator in the GitHub repository at [https://github.com/thombergs/buckpal](https://github.com/thombergs/buckpal).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `Validator` class might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With validation located in the input model, we have created an **anti-corruption
    layer** around our use case implementations. This is not a layer in the sense
    of a layered architecture, calling the next layer below it, but instead a thin,
    protective screen around our use cases that bounces bad input back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the term “command,” as used in the `SendMoneyCommand` class, does
    not match the common interpretation of the “command pattern.”[3](#footnote-019)
    In the `execute()` that actually invokes the use case. In our case, the command
    is just a data transfer object that transfers the required parameters to the use
    case service that executes the command. We could call it `SendMoneyDTO` instead,
    but I like the term “command” to make it very clear that we’re changing the model
    state with this use case.
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-019-backlink) Command pattern: [https://en.wikipedia.org/wiki/Command_pattern](https://en.wikipedia.org/wiki/Command_pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: The power of constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `SendMoneyCommand`, puts a lot of responsibility on its constructor. Since
    the class is immutable, the constructor’s argument list contains a parameter for
    each attribute of the class. And since the constructor also validates the parameters,
    it’s not possible to create an object with an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the constructor has only three parameters. What if we had more
    parameters? Couldn’t we use the builder pattern to make it more convenient to
    use? We could make the constructor with the long parameter list private and hide
    the call to it in the `build()` method of our builder. Then, instead of having
    to call a constructor with 20 parameters, we could build an object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can still let our constructor do the validation so that the builder cannot
    construct an object with an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: Sound good? Think about what happens if we have to add another field to `SendMoneyCommandBuilder`
    (which will happen quite a few times in the lifetime of a software project). We
    add the new field to the constructor and to the builder. Then, a colleague (or
    a phone call, an email, a butterfly…) interrupts our train of thought. After the
    break, we go back to coding and forget to add the new field to the code that calls
    the builder to create an object.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t get a word of warning from the compiler about trying to create an immutable
    object in an invalid state! Sure, at runtime – hopefully in a unit test – our
    validation logic will still kick in and throw an error because we missed a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: But if we use the constructor directly instead of hiding it behind a builder,
    each time a new field is added or an existing field is removed, we can just follow
    the trail of compile errors to reflect that change in the rest of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long parameter lists can even be formatted nicely, and good IDEs help with
    parameter name hints:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.2 – The IDE shows parameter name hints in parameter lists to help\
    \ us \uFEFFto not get lost](img/Figure_05.02_B19916.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The IDE shows parameter name hints in parameter lists to help us
    to not get lost
  prefs: []
  type: TYPE_NORMAL
- en: To make the preceding code even more readable and safer to work with, we can
    introduce immutable `Address` value object, for example, because they belong together.
    We could even go a step further and create `City` and `ZipCode` value objects,
    for example. This would reduce the chance of confusing one `String` parameter
    with another, because the compiler would complain if we tried to pass a `City`
    into a `ZipCode` parameter and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where a builder may be the better solution, though. If some
    parameters in `ClassWithManyFields` from the preceding example were optional,
    for example, we would have to pass `null` values into the constructor, which is
    ugly at best. A builder would allow us to define only the required parameters.
    But if using builders, we should make very sure that the `build()` method fails
    loudly when we forget to define a required parameter because the compiler doesn’t
    check that for us!
  prefs: []
  type: TYPE_NORMAL
- en: Different input models for different use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We might be tempted to use the same input model for different use cases. Let’s
    consider the *Register account* and *Update account details* use cases. Both will
    initially need almost the same input, namely some account details, such as a username
    and email address.
  prefs: []
  type: TYPE_NORMAL
- en: The *Update* use case will need the ID of the account that needs to be updated,
    however, while the *Register* use case does not. If both use cases use the same
    input model, we will always have to pass a `null` account ID into the *Register*
    use case. This is annoying at best, and detrimental at worst, because both use
    cases are coupled to evolve together now.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing `null` as a valid state of a field in our immutable command object
    is a code smell by itself. But more importantly, how are we handling input validation
    now? Validation has to be different for the *Register* and *Update* use cases
    since one needs an ID and the other doesn’t. We’d have to build custom validation
    logic into the use cases themselves, polluting our sacred business code with input
    validation concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Also, what do we do if the account ID field accidentally has a non-null value
    in the *Register account* use case? Do we throw an error? Do we simply ignore
    it? These are the questions the maintenance engineers – including future us –
    will ask when seeing the code.
  prefs: []
  type: TYPE_NORMAL
- en: A dedicated input model for each use case makes the use case much clearer and
    also decouples it from other use cases, preventing unwanted side effects. It comes
    at a cost, however, because we have to map incoming data to different input models
    for different use cases. We’ll discuss this mapping strategy along with other
    mapping strategies in [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081), *Mapping*
    *between Boundaries*.
  prefs: []
  type: TYPE_NORMAL
- en: Validating business rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While validating input is not part of the use case logic, validating business
    rules definitely is. Business rules are the core of the application and should
    be handled with appropriate care. But when are we dealing with input validation
    and when are we dealing with a business rule?
  prefs: []
  type: TYPE_NORMAL
- en: A very pragmatic distinction between the two is that validating a business rule
    requires access to the current state of the domain model while validating input
    does not. Input validation can be implemented declaratively, as we did with the
    `@NotNull` annotations previously, while a business rule needs more context.
  prefs: []
  type: TYPE_NORMAL
- en: We might also say that input validation is a syntactic validation, while a business
    rule is a semantic validation in the context of a use case.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the rule *the source account must not be overdrawn*. As per the previous
    definition, this is a business rule since it needs access to the current state
    of the model to check the balance of the source account.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the rule *the transfer amount must be greater than zero* can be
    validated without access to the model and thus can be implemented as part of the
    input validation.
  prefs: []
  type: TYPE_NORMAL
- en: I’m aware that this distinction may be subject to debate. You might argue that
    the transfer amount is so important that validating it should be considered a
    business rule in any case.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction helps us, however, to place certain validations within the code
    base and easily find them again later on. It’s as simple as answering the question
    of whether the validation needs access to the current model state or not. This
    not only helps us to implement the rule in the first place but it also helps the
    future maintenance engineer to find it again. It’s also a great example of my
    claim from [*Chapter 1*](B19916_01.xhtml#_idTextAnchor014), *Maintainability*,
    that maintainability supports decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we implement a business rule?
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way is to put the business rules into a domain entity as we did for
    the rule *the source account must not* *be overdrawn*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This way, the business rule is easy to locate and reason about because it’s
    right next to the business logic that requires this rule to be honored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it’s not feasible to validate a business rule in a domain entity, we can
    do it in the use case code before it starts working on the domain entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We call a method that does the actual validation and throws a dedicated exception
    if this validation fails. The adapter interfacing with the user can then display
    this exception to the user as an error message or handle it in any other way it
    deems fit.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding case, the validation simply checks whether the source and target
    accounts actually exist in the database. More complex business rules might require
    us to load the domain model from the database first and then do some checks on
    its state. If we have to load the domain model anyway, we should implement the
    business rule in the domain entities themselves, as we did with the rule *the
    source account must not* *be overdrawn*.
  prefs: []
  type: TYPE_NORMAL
- en: Rich versus anemic domain model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our architecture style leaves open how to implement our domain model. This is
    a blessing because we can do what seems right in our context, and a curse because
    we don’t have any guidelines to help us.
  prefs: []
  type: TYPE_NORMAL
- en: A frequent discussion is whether to implement a **rich domain model** following
    the DDD philosophy or an “**anemic**” **domain model**. Let’s discuss how each
    of these fits into our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In a rich domain model, as much of the domain logic as possible is implemented
    within the entities at the core of the application. The entities provide methods
    to change the state and only allow changes that are valid according to the business
    rules. This is the way we pursued the `Account` entity previously. Where is our
    use case implementation in this scenario?
  prefs: []
  type: TYPE_NORMAL
- en: In this case, our use case serves as an entry point to the domain model. A use
    case then only represents the intent of the user and translates it into orchestrated
    method calls to the domain entities, which do the actual work. Many of the business
    rules are located in the entities instead of the use case implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The *Send money* use case service would load the source and target account entities,
    call their `withdraw()` and `deposit()` methods, and send them back to the database.[4](#footnote-018)
  prefs: []
  type: TYPE_NORMAL
- en: '[4](#footnote-018-backlink) Actually, the *Send Money* use case would also
    have to make sure that no other money transfer to and from the source and target
    account was happening at the same time to avoid overdrawing an account.'
  prefs: []
  type: TYPE_NORMAL
- en: In an “anemic” domain model, the entities themselves are very thin. They usually
    only provide fields to hold the state and getter and setter methods to read and
    change the state. They don’t contain any domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the domain logic is implemented in the use case classes. They
    are responsible for validating business rules, changing the state of the entities,
    and passing them into the outgoing ports responsible for storing them in the database.
    The “richness” is contained within the use cases instead of the entities.
  prefs: []
  type: TYPE_NORMAL
- en: Either style, and any number of other styles, can be implemented using the architecture
    approach discussed in this book. Feel free to choose the one that fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Different output models for different use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the use case has done its work, what should it return to the caller?
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the input, it has benefits if the output is as specific to the use
    case as possible. The output should only include the data that is really needed
    for the caller to work.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code of the *Send money* use case, we return a Boolean. This
    is the minimal and most specific value we could possibly return in this context.
  prefs: []
  type: TYPE_NORMAL
- en: We might be tempted to return a complete `Account` with the updated entity to
    the caller. Perhaps the caller is interested in the new balance of the account.
  prefs: []
  type: TYPE_NORMAL
- en: But do we really want to make the *Send money* use case return this data? Does
    the caller really need it? If so, shouldn’t we create a dedicated use case for
    accessing that data that can be used by different callers?
  prefs: []
  type: TYPE_NORMAL
- en: There is no single right answer to these questions. But we should ask them to
    try to keep our use cases as specific as possible. When in doubt, return as little
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the same output model between use cases also tends to tightly couple
    those use cases. If one of the use cases needs a new field in the output model,
    the other use cases have to handle this field as well, even if it’s irrelevant
    to them. Shared models tend to grow tumorously for multiple reasons in the long
    run. Applying the Single Responsibility Principle and keeping models separated
    helps in decoupling use cases.
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, we might want to resist the temptation to use our domain
    entities as the output model. We don’t want our domain entities to change for
    more reasons than necessary. However, we’ll talk more about using entities as
    input or output models in [*Chapter 11*](B19916_11.xhtml#_idTextAnchor096), *Taking*
    *Shortcuts Consciously*.
  prefs: []
  type: TYPE_NORMAL
- en: What about read-only use cases?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of now, we have discussed how we might implement a use case that modifies
    the state of our model. How do we go about implementing read-only cases? Let’s
    assume the UI needs to display the balance of an account. Do we create a specific
    use case implementation for this?
  prefs: []
  type: TYPE_NORMAL
- en: It’s awkward to talk of use cases for read-only operations like this one. Sure,
    the UI needs the data for a use case we might call *View Account Balance*, but
    in some cases, calling this a “use case” is a bit artificial. If this is considered
    a use case in the context of the project, by all means, we should implement it
    just like the other ones.
  prefs: []
  type: TYPE_NORMAL
- en: From the viewpoint of the application core, however, this is a simple query
    for data. So, if it’s not considered a use case in the context of the project,
    we can implement it as a query to set it apart from the real use cases.
  prefs: []
  type: TYPE_NORMAL
- en: One way of doing this within our architecture style is to create a dedicated
    incoming port for the query and implement it in a “query service:”
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-5.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `GetAccountBalanceUseCase` and calls the outgoing port, `LoadAccountPort`,
    to actually load the data from the database. It’s using the `GetAccountBalanceQuery`
    type as its input model.
  prefs: []
  type: TYPE_NORMAL
- en: This way, read-only queries are clearly distinguishable from modifying use cases
    (or “commands”) in our code base. We just have to look at the names of the input
    types to know which we’re dealing with. This plays nicely with concepts such as
    **Command-Query Separation** (**CQS**) and **Command-Query Responsibility** **Segregation**
    (**CQRS**).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the service doesn’t really do any work other than passing
    the query on to the outgoing port. If we use the same model across layers, we
    can take a shortcut and let the client call the outgoing port directly. We’ll
    talk about this shortcut in [*Chapter 11*](B19916_11.xhtml#_idTextAnchor096),
    *Taking* *Shortcuts Consciously*.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our architecture lets us implement the domain logic as we see fit, but if we
    model the input and output of our use cases independently, we avoid unwanted side
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it’s more work than just sharing models between use cases. We have to introduce
    a separate model for each use case and map between this model and our entities.
  prefs: []
  type: TYPE_NORMAL
- en: But use case-specific models allow for a crisp understanding of a use case,
    making it easier to maintain in the long run. Also, they allow multiple developers
    to work on different use cases in parallel without stepping on each other’s toes.
  prefs: []
  type: TYPE_NORMAL
- en: Together with tight input validation, use case-specific input and output models
    go a long way toward a maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re taking a step “outward” from the center of our application
    and will explore building a web adapter that provides a channel for users to talk
    to our use case.
  prefs: []
  type: TYPE_NORMAL
