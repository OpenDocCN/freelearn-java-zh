- en: Chapter 7. Functional Idioms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered implicit parameters and implicit conversions.
    We saw how to enable elegant extension methods for your code. We also had a look
    at how the Scala compiler resolves implicits. Finally, we covered how implicits
    work, how to use them, and what kind of benefits they provide.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll cover the core concepts of functional programming like
    `Pure` functions, immutability, and higher-order functions. We'll build upon this
    understanding and introduce some of the design patterns that are prevalent in
    large functional programs that you'll no doubt run into once you start to use
    Scala libraries that focus on functional programming. Finally, we'll cover two
    popular functional programming libraries called `Cats` and `Doobie`, and use them
    to write some interesting programs.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming languages have been around for a very long time, but
    they have gotten more traction lately, with functional programming concepts being
    adopted by most popular programming languages. A reason for this might be that
    functional programming lends itself easily to solving some problems that are hard
    in imperative languages, such as writing parallelizable programs. Functional programming
    can also increase the modularity of your programs and thus make them easier to
    test, reuse, and reason about, hopefully resulting in code that produces fewer
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the core concepts of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize and implement the popular functional programming design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement Cats and Doobie in your own Scala projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Functional Programming Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the core concepts behind functional programming
    and give you the necessary knowledge to understand and write simple functional
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, you should have a good understanding of the core
    concepts behind functional programming, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing and using pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using immutable classes instead of mutable classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and using higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the very core of functional programming is the concept of a `pure` function.
    A function is pure if it doesn't have any side effects, that is, the function
    simply computes a result based on the arguments to the function and does nothing
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of side effects are modifying variables, setting fields on objects,
    performing input/output operations such as reading or writing a file, printing
    values to the console, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples of both `pure` and `impure` functions to better
    understand the difference. Let''s have a look at two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a simple case class called `Person` with a `name` and an `age`.
    Then, we define two functions that operate on `Person`. Can you see why these
    functions are not pure functions? To test if these functions are pure, we could
    try to invoke them with the same arguments twice to see if we get different results
    – remember, a pure function is a function that simply computes a result based
    on the arguments to the function and does nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `birthday:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alright, so `birthday` isn't a pure function as it's modifying the state of
    the `Person p` passed to the function. We also might have been able to guess this
    as the return type of birthday is `Unit` – as the function doesn't return a value,
    it must be doing some side effects, otherwise the function would be completely
    useless.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's take a look at `getName:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The good news is that the function returns the name value and provides the same
    arguments. However, the function is still not pure as it prints to the console
    whenever it's invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let's have a look at `rename:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Alright, so `rename` is a pure function. When provided with the same argument,
    it produces the same value and doesn't perform any observable side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered the concept of a pure function and seen examples of both
    pure and impure functions. You''ve seen two ways to define what a pure function
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: When provided with the same argument, it produces the same value and doesn't
    perform any observable side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pure function is a function that only consists of referentially transparent
    expressions. An expression is referentially transparent if it can be replaced
    with its value without changing the behavior of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsection, we'll look at immutability, which is another core concept
    that enables the writing of pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the understanding of what a pure function is, it''s time to introduce
    another core concept that enables the writing of pure functions: immutability.
    Something is said to be immutable if you can''t change it – it''s the opposite
    of mutable.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons Scala is so well suited for functional programming is that
    it provides constructs where immutability is guaranteed. Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: If we define a variable or field on a class using the `val` keyword (rather
    than `var`), then the Scala compiler will not allow us to change that value.
  prefs: []
  type: TYPE_NORMAL
- en: Open Terminal on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Scala REPL by typing `scala.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can start pasting in the code after `scala>:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The expected output is shown on the line below `scala>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, Scala can''t guarantee that you don''t modify the state of the value
    that was assigned to a variable, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, if we remove the `var` keyword, Scala will, by default, declare the
    field name using `val` and thus won't allow us to change it, thereby enforcing
    immutability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the standard library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard library in Scala has a whole collection of immutable data structures
    in the `scala.collection.immutable` package.
  prefs: []
  type: TYPE_NORMAL
- en: The most used of these is perhaps `scala.collection.immutable.List`, which is
    imported in `Predef` and thus accessible in Scala programs simply as `List:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that `xs.reverse` returns a new `List` that is reversed and
    leaves `x` `s` unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: Scala provides constructs where immutability is guaranteed and has many defaults
    where immutability is used, such as when defining case classes or using some of
    the immutable collection that is provided by the standard library. In the next
    subsection, we'll look at higher-order functions, which you'll be using extensively
    when writing programs in Scala using functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Higher-order functions are functions that take other functions as arguments.
    This is a technique that is widely used in Scala, and one that you will use all
    the time when you're writing Scala programs. Higher-order functions have already
    been covered previously, but we will include a short recap here for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example of using the higher-order function map on `List` to invoke
    a function on every item of the list to produce a new `List:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that this example uses pure functions, immutability, and higher-order functions
    – the perfect functional program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how to define a higher-order function. It takes a function
    from `A => Boolean` and returns a function of `A => Boolean` that negates the
    result of the original function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll write a higher-order function that finds the second element in a list
    given a predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two examples of using the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, try to write your own higher-order function to get a better feeling for
    how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Scala file in your editor named `HOExample.scala.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Paste in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This higher-order function should find the second element in a list given a predicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the application in your editor, you should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One possible solution is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've gotten a recap of what higher-order functions are and seen how they can
    be used to write generic functions where some of the functionality of the function
    is provided by an argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll move beyond the basic concepts behind functional
    programming and look at some of the functional design patterns that you'll encounter
    when using functional libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve seen three of the cornerstones of functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pure functions**: A function simply computes a result based on the arguments
    to the function and does nothing else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutability**: You''ve seen how Scala has good support for immutability
    and uses it as the default in many cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher-order functions**: Functions that take others as arguments or return
    a function are called higher-order functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are moving beyond the basic concepts behind functional programming
    and looking at some of the functional design patterns that you'll encounter when
    using functional libraries. You will be introduced to `Monoids`, `Functors`, `Monads`,
    and other functional programming patterns that you can use to structure your programs
    – these patterns are the functional programming equivalent of the object-oriented
    design patterns that you might be familiar with from when you first learned about
    OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever heard of category theory? The patterns we'll see in this section
    come from category theory. Each concept (such as a `Monoid`) has a clear mathematical
    definition and set of associated laws.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we won't go into detail regarding these laws, but should you
    want to research this topic further, it's good to know that the field is called
    category theory.
  prefs: []
  type: TYPE_NORMAL
- en: This will set you up for further study of functional design patterns and enable
    you to use some of the most popular functional programming libraries such as `Cats`
    and `Scalaz.`
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections will each introduce an abstract structure, show its
    definition in Scala, and show how to use it when you write your programs – the
    structures might seem very abstract at first, but please be patient, as the examples
    will show you how the structures can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code will heavily use type classes, so please refer back to the
    previous chapters to make sure you have a good understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first structure we'll take a look at is called a `Monoid`. A `Monoid` is
    a very simple structure, but it's one that you'll encounter all the time once
    you've learned to recognize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Monoid` has two operations, `combine` and `empty`. In Scala, the definition
    of a Monoid could be expressed as a type class like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, instances of the `Monoid` type class support two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`combine`: This operation takes two arguments of type `A` and returns an `A`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty`: This operation doesn''t take any arguments but it returns an `A`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In category theory, these operations are called `multiplication` and `unit`.
    This might be useful if you want to learn more about this topic at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: This is very abstract, so let's make it concrete by looking at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one of the instances of the `Monoid` type class to get a better
    feeling for how it works and how you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Define a `Monoid` type class instance for `String`, that is, a `Monoid[String]:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `stringMonoid` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In most cases, you won't refer to a concrete instance of Monoid as explicitly
    as we've done here, but rather you'll use the `Monoid` type class when writing
    polymorphic functions, as you'll see in the example after the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create implicit def for Monoid creation.
  prefs: []
  type: TYPE_NORMAL
- en: Write an instance of `Monoid` for `Int:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write an `implicit def` that can create a `Monoid[List[A]]` for any `A:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Monoids to Write Polymorphic Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the `Monoid` might seem simple, it is immensely useful. The power
    of `Monoid`, and the other structures that you'll be introduced to later, come
    into play when we define polymorphic functions that know nothing about their arguments
    other than the fact that a `Monoid` instance for their types exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a function that takes the sum of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter list is straightforward – it defines that the function takes
    a `List` of the different `A` values. However, the second implicit parameter list
    asks the compiler to find an instance of `Monoid` for `A` and will only allow
    you to invoke `sum[A]` if an instance of `Monoid[A] exists.`
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function, you can take the `sum` of any `List` as long as there is
    an appropriate instance of `Monoid` in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We looked at the first structure, the Monoid. We saw that even though the Monoid
    has a very simple interface, it showed itself to be a useful construct that allowed
    us to write interesting polymorphic functions. In the next section, we'll look
    at `Functors`. Put simply, a Functor is something that you can map over.
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second structure we''ll look at is the `Functor`. Put simply, a `Functor`
    is something that you can map over. In Scala, you''ll be very familiar with this
    operation as you''ve no doubt used it multiple times to manipulate `Lists`, `Options`,
    and so on. In Scala, the type class for `Functors` could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Functor` abstracts over a type constructor, `F` – types that abstract over
    type constructors are called higher types.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be tempted to think of `map` as a convenient way to iterate over
    a collection such as `List` or `Set`, but in the context of Functor, there''s
    a more interesting way to look at it. You should think of `map` as a way of sequencing
    operations on some type that preserves the structure of the type as defined by
    the specificities of the type. The details will vary depending on the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option**: There might not be a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: There might be zero or more values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Either**: There might be an error or there might be a value – not both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at some c oncrete examples to make this more clear.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now evaluate the same thing in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a polymorphic function that abstracts over different Functors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It defines a function, `compute`, that first uses `map` to add `2` to the value
    inside the functor and then uses map to multiply the result by `2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now invoke this method with any value that has a `Functor` instance
    defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this exercise in mind, you can see how Functor allows you to write polymorphic
    functions that know nothing about their arguments other than that there's a map
    function defined for them. It's up to the specific Functor to define what map
    means in its specific context.
  prefs: []
  type: TYPE_NORMAL
- en: Let's define and use a Functor for `List` and `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: Define a `Functor` for `List:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using it would then look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Defining Functor for Option**'
  prefs: []
  type: TYPE_NORMAL
- en: Write an instance of `Functor` for `Option:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution can be found in `Examples/src/main/scala/Functor.scala`, defined
    as `optionFunctor.`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We looked at our second structure, the Functor, which represents things that
    can be mapped over. You saw how to define instances for Functor and how one can
    think of `map` as a way of sequencing operations on some type that preserves the
    structure of the type, as defined by the specificities of the type. In the next
    section, we'll look at Monads – a structure that you might already be familiar
    with without knowing it.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last structure we'll look at is the `Monad`. Most Scala programmers will
    be familiar with Monads, even if they don't know them by name, as the abstraction
    is used whenever you write a `for-comprehension`. A Monad has two operations,
    `pure` and `flatMap:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the category theory names for the `flatMap` operation is `bind,` and
    the name for `pure` is `unit.`
  prefs: []
  type: TYPE_NORMAL
- en: Recall from the previous section that you can think of Functors as a way to
    sequence operations on some type that preserves the structure of the type, as
    defined by the specificities of the type. Well, the same is true of a Monad, expect
    they're a bit more powerful. For Functors, the complications can only occur in
    the beginning of the sequence whereas with Monads, they can occur in any part
    of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What if one of the operations returned an Option?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a value of type `Option[Option[Int]],` which isn't very convenient.
    This is where `Monad` comes in handy. If you have a sequence of operations where
    you want some specificities of some type to be preserved on every step, you'll
    want to use a `Monad`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see from the preceding definition, a Monad is also a Functor, as
    map can be implemented in terms of `flatMap` and `pure.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can define a Monad for Option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`pure` is defined by simply wrapping the value in `Some`. `flatMap` is defined
    by pattern matching on the value and applying the function if it''s `Some,` otherwise
    returning `None.`'
  prefs: []
  type: TYPE_NORMAL
- en: We can avoid the previous inconvenient situation of having an `Option[O` `ption[Int]]:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have seen the definition of the Monad and how it can be used to sequence
    operations in a specific context where each step in the sequence needs to preserve
    some specificities that depend on the instance of the Monad.
  prefs: []
  type: TYPE_NORMAL
- en: Popular Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point, you should have a good understanding of the main concepts behind
    functional programming such as pure functions, immutability, and higher-order
    functions. In addition to that, you should be familiar with some of the most popular
    abstractions used when writing functional programs. With all of this knowledge,
    you are well equipped to start looking into some of the popular functional programming
    libraries in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at some of the popular functional programming
    libraries from the Scala ecosystem. After this section, you should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `Cats``Validated` type class to validate your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Doobie` to talk to databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating Data Using Cats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll get a quick overview of the Cats library and look at
    one of the data types it provides to `Validate` data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on Cats, refer to [https://github.com/typelevel/cats](https://github.com/typelevel/cats).
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you should understand how `Cats` fits into the Scala
    ecosystem and know how to use it in your own projects, specifically to validate
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for Using Cats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to add `Cats` as a dependency to your Scala project. Create a new
    SBT project with the following `build.sbt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As `Cats` relies heavily on implicits to provide type class instances and extension
    methods, you always need to have the following imports in your files when you're
    using `Cats:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Introduction to Cats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cats is a library which provides abstractions for functional programming in
    the Scala programming language. Specifically, it provides definitions for all
    of the patterns you saw in the previous section (Monoid, Monad, and so on) and
    many more. It also contains type class instances for all of the relevant classes
    from the Scala standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The broader goal of Cats is to provide a foundation for an ecosystem of pure,
    typeful libraries to support functional programming in Scala applications.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two different ways to validate data using Cats. The first is `Either,`
    as you know it from the standard library, and the other is `Validated`. You should
    use `Either` if you want your validation to fail-fast and you should use `Validated`
    if you want to accumulate the errors. Which one you should use depends on your
    use case. As you might be familiar with `Either` from the standard library, we'll
    focus on `Validated` in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s have a look at a basic domain model and some constraints we have
    for the data. Let''s assume you have a `User` that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also assume that you have the following rules for this user:'
  prefs: []
  type: TYPE_NORMAL
- en: The username has to contain at least three characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username can only contain alphanumeric characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The age has to be positive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can represent these three errors in Scala using a sealed trait with case
    objects like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at how we could write the preceding rules in Scala using `Validated.`
  prefs: []
  type: TYPE_NORMAL
- en: Validating Using Validated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Validated` data type is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Valid[A]` represents a value of type `A` that passed some kind of validation,
    and `Invalid[A]` represents that some validation failed, producing an error of
    type `E`. Let''s try to implement the rules from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a method, `validateAge`, which takes an `Int` and returns `Validated[NonEmptyList[Error],
    Int]`, meaning that it will either return `Valid(age)` if it's valid or `Invalid(NonEmptyList(ValueTooLow))`
    if it's not. We use the extension methods `validNel` and `invalidNel` that `Cats`
    provides for your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let''s define a validator for the username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're defining two helper functions, `checkLength` and `checkSpecialCharacters`,
    which check that the string is longer than 3 characters and doesn't contain any
    alphanumeric characters. We combine these two checks using the `mapN` extension
    method that Cats provides on tuples. If both checks pass, the `mapN` function
    will be invoked with a tuple containing both the valid values, but we're only
    interested in the username once we simply return the first valid value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s write the method that validates both the username and the age
    and returns a `User` if everything is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use the `mapN` method and pass in a function that should be invoked
    if all checks pass. In this case, we use the `apply` method on `User` to create
    an instance of `User.`
  prefs: []
  type: TYPE_NORMAL
- en: 'If you invoke this, you can see that it accumulates the errors if there are
    any; otherwise, it returns a `User` that has been validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should know how to add Cats to your Scala projects and know how
    to use their `Validated` data type to write validation methods for your domain
    models in a nice, functional way. In the next section, we'll have a look at how
    to use the `Doobie` library to communicate with databases in a functional type-safe
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with Databases Using Doobie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we'll use the `Doobie` library to communicate with databases
    in a functional and type-safe manner. You will be introduced to the core concepts
    of `Doobie` and see how to use it to query, update, and delete rows in your database.
  prefs: []
  type: TYPE_NORMAL
- en: After this subsection, you should be able to use `Doobie` in your own Scala
    projects for simple queries and insertions, and know where to find documentation
    for more advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for Doobie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need to add Doobie as a dependency to your Scala project. Create a new
    SBT project with the following `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Doobie can talk to many different databases, such as MySQL, Postgres, H2, and
    so on. In the following examples, we'll use the in-memory database H2 to simplify
    the setup. Have a look at the documentation to see how to use the other databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database tables we''ll use in these examples are quite simple. There are
    two tables, `user` and `todo`, which have the following SQL definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Doobie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Doobie, to make large programs, you need to write small programs. After creating
    the program, you can directly drop it into your main function and use it as an
    effectful monad.
  prefs: []
  type: TYPE_NORMAL
- en: Doobie has a high-level and a low-level API. In this lecture, we'll focus exclusively
    on the high-level API. In the high-level API, there are only a handful of important
    classes. The two most important are `ConnectionIO` and `Transactor.`
  prefs: []
  type: TYPE_NORMAL
- en: ConnectionIO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common types you will deal with have the form `ConnectionIO[A]`, specifying
    computations that take place in a context where a `java.sql.Connection` is available,
    ultimately producing a value of type `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConnectionIO[A]` is the most common types you will come across, and it specifies
    the calculations that occur where `java.sq` `l.Connection` is available, which
    generates a value of type `A`.'
  prefs: []
  type: TYPE_NORMAL
- en: Transactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Transactor` is a structure which is used for database connectivity, connection
    handouts, and cleanup; it can take a `ConnectionIO[A]` and produce an `IO[A]`,
    which provides an executable code. It specifically provides you an `IO` that,
    when executed, will connect to the database and run the program in a single transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a full example that creates a `Transactor` that can connect to the H2
    database. We then use that `transactor` to perform the simple query `SELECT` `42:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates a `Transactor` using `Transactor.fromDriverManager`
    and then creates a small program that, when provided with a `Connection`, will
    run `SELECT 42`. Finally, the program is turned into an `IO` monad using the transact
    method on `ConnectionIO,` and the `IO` monad is executed using `unsafeRunSync`
    to produce an `Int` that is the result of executing `SELECT 42`. It's important
    to understand that no side effects are occurring until the `IO` monad is executed
    using `unsfaceRunSync.`
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's have a look at how to write queries.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've seen how to use the `ConnectionIO` and `Transactor`, let's have
    a look at some more interesting queries to perform a very simply query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by examining the following expression from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We use the Doobies string interpolation function `sql` to turn a normal `String`
    into a `Fragment`. A `Fragment` is simply Doobie's representation of parts of
    an SQL query, which may include interpolated values. `Fragments` can be composed
    by concatenation, which maintains the correct offset and mappings for interpolated
    values. In this lecture, we won't go into detail with what you can do with `Fragments`,
    but you can find more information in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a `Fragment`, you can turn it into a `Query` using the `query[A]`
    method on `Fragment`. `Query[A, B]` is Doobie's representation for a complete
    SQL query that takes some input of type `A` and produces some output of type B.
    In this specific example, our query doesn't take any input, so the specific type
    `Query0` is returned, which represents a query that doesn't take any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a `ConnectionIO[Int]` is produced by using the `unique` method on `Query`.
    As stated previously, `ConnectionIO[A]` represents computations that take place
    in a context where a `java.sql.Connection` is available, ultimately producing
    a value of type `A`. In this case, we use `unique` as we're only expecting one
    row to be returned. Other interesting methods are `list` and `opti` `on`, which
    return `ConnectionIO[List[A]]` and `ConnectionIO[Option[A]],` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Using Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Doobie, you pass parameters to queries as you would with any string interpolator.
    The parameters are turned into `?` expressions in prepared statements to avoid
    SQL injections. Let''s have a look at how to query using parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the following queries in `lesson-1/doobie-example/src/main/scala/com/example/User.scala.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first query, `allManual`, takes an `Int` and uses it as a parameter to define
    the `LIMIT` of the SQL query. The second query takes a `String` and uses it in
    a `WHERE` clause to select users with that specific username. The `allManual`
    query selects a `Tuple` of ( `Int`, `String`, `Int`) and `maps` over it to produce
    a `User`, whereas `withUsername` uses Doobie's ability to automatically use the
    `apply` method of a case class when querying for rows of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting, Inserting, and Updating Rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting, inserting, and updating works in a similar way. First, let''s look
    at how to delete rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use the SQL string interpolator to define our query and simply refer
    to variables in scope to define parameters to the query. However, instead of using
    the `query[A]` method on `Fragment` to produce a `Query`, we use `update[A]` to
    produce an `Update[A]`. We then use the `run` method on `Update` to produce a
    `ConnectionIO[A]:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Both `setAge` and `create` are similar, but `create` uses an interesting method
    on `Update` named `withUniqueGeneratedKeys`, which returns the `id` of the row
    that was inserted last.
  prefs: []
  type: TYPE_NORMAL
- en: A Complete Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at a full example. You can find it in `lesson-1/doobie-example/src/main/scala/com/example/Main.scala`.
    We''ll look at each section piece by piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, you can see how to chain `ConnectionIO` using `flatMap` through
    Scala `for-comprehensions`. This allows us to nicely construct `ConnectionIO`
    from the result of executing another `ConnectionIO`. In this case, we use it to
    first create a `User` and then use the `userId` in subsequent methods to set the
    user''s age and construct three `Todo` methods for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we will produce `IO` from two `ConnectionIO` instances by
    using the `transact` method in a `for` `-comprehension`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `IO` is executed to produce side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Adding Priority to the Todo List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where a client has told you that he needs priority function
    added to his Todo lists. Design the priority for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the example program in `lesson-1/doobie-example` by adding a priority
    to each of the Todos and use the priority when querying for uncompleted todos
    so that the most important is returned first. You''ll have to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the `Todo case class` with a `priority: Int` field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `Table` definition in `Todo.table.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `Todo.create` method to take an `Int` that represents the priority.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `Todo.uncompleted` so it orders the rows in descending order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the core concepts of functional programming like
    Pure functions, immutability, and higher-order functions. We introduced some of
    the design patterns that are prevalent in large functional programs. Finally,
    we covered two popular functional programming libraries called Cats and Doobie,
    and used them to write some interesting programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how Scala makes it possible to write powerful
    Domain-Specific Languages (DSLs) by providing a few interesting language features.
    We'll have a brief look at what DSLs are in general terms. We'll also cover a
    DSL that you'll very likely be using if you're going to work with Scala professionally.
    Finally, you will implement your own DSL.
  prefs: []
  type: TYPE_NORMAL
