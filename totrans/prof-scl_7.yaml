- en: Chapter 7. Functional Idioms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered implicit parameters and implicit conversions.
    We saw how to enable elegant extension methods for your code. We also had a look
    at how the Scala compiler resolves implicits. Finally, we covered how implicits
    work, how to use them, and what kind of benefits they provide.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll cover the core concepts of functional programming like
    `Pure` functions, immutability, and higher-order functions. We'll build upon this
    understanding and introduce some of the design patterns that are prevalent in
    large functional programs that you'll no doubt run into once you start to use
    Scala libraries that focus on functional programming. Finally, we'll cover two
    popular functional programming libraries called `Cats` and `Doobie`, and use them
    to write some interesting programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming languages have been around for a very long time, but
    they have gotten more traction lately, with functional programming concepts being
    adopted by most popular programming languages. A reason for this might be that
    functional programming lends itself easily to solving some problems that are hard
    in imperative languages, such as writing parallelizable programs. Functional programming
    can also increase the modularity of your programs and thus make them easier to
    test, reuse, and reason about, hopefully resulting in code that produces fewer
    bugs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Identify the core concepts of functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize and implement the popular functional programming design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement Cats and Doobie in your own Scala projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Functional Programming Concepts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the core concepts behind functional programming
    and give you the necessary knowledge to understand and write simple functional
    programs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, you should have a good understanding of the core
    concepts behind functional programming, such as:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Writing and using pure functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using immutable classes instead of mutable classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and using higher-order functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure Functions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the very core of functional programming is the concept of a `pure` function.
    A function is pure if it doesn't have any side effects, that is, the function
    simply computes a result based on the arguments to the function and does nothing
    else.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Examples of side effects are modifying variables, setting fields on objects,
    performing input/output operations such as reading or writing a file, printing
    values to the console, and many more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples of both `pure` and `impure` functions to better
    understand the difference. Let''s have a look at two functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we define a simple case class called `Person` with a `name` and an `age`.
    Then, we define two functions that operate on `Person`. Can you see why these
    functions are not pure functions? To test if these functions are pure, we could
    try to invoke them with the same arguments twice to see if we get different results
    – remember, a pure function is a function that simply computes a result based
    on the arguments to the function and does nothing else.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `birthday:`
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alright, so `birthday` isn't a pure function as it's modifying the state of
    the `Person p` passed to the function. We also might have been able to guess this
    as the return type of birthday is `Unit` – as the function doesn't return a value,
    it must be doing some side effects, otherwise the function would be completely
    useless.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's take a look at `getName:`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The good news is that the function returns the name value and provides the same
    arguments. However, the function is still not pure as it prints to the console
    whenever it's invoked.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let's have a look at `rename:`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alright, so `rename` is a pure function. When provided with the same argument,
    it produces the same value and doesn't perform any observable side effects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered the concept of a pure function and seen examples of both
    pure and impure functions. You''ve seen two ways to define what a pure function
    is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: When provided with the same argument, it produces the same value and doesn't
    perform any observable side effects.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pure function is a function that only consists of referentially transparent
    expressions. An expression is referentially transparent if it can be replaced
    with its value without changing the behavior of the program.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsection, we'll look at immutability, which is another core concept
    that enables the writing of pure functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the understanding of what a pure function is, it''s time to introduce
    another core concept that enables the writing of pure functions: immutability.
    Something is said to be immutable if you can''t change it – it''s the opposite
    of mutable.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons Scala is so well suited for functional programming is that
    it provides constructs where immutability is guaranteed. Let's look at some examples.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If we define a variable or field on a class using the `val` keyword (rather
    than `var`), then the Scala compiler will not allow us to change that value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Open Terminal on your computer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Scala REPL by typing `scala.`
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can start pasting in the code after `scala>:`
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The expected output is shown on the line below `scala>`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, Scala can''t guarantee that you don''t modify the state of the value
    that was assigned to a variable, for example:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, if we remove the `var` keyword, Scala will, by default, declare the
    field name using `val` and thus won't allow us to change it, thereby enforcing
    immutability.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the standard library
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard library in Scala has a whole collection of immutable data structures
    in the `scala.collection.immutable` package.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的标准库在`scala.collection.immutable`包中提供了一整套不可变数据结构。
- en: The most used of these is perhaps `scala.collection.immutable.List`, which is
    imported in `Predef` and thus accessible in Scala programs simply as `List:`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最常用的可能是`scala.collection.immutable.List`，它在`Predef`中导入，因此可以在Scala程序中简单地作为`List`访问。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you can see that `xs.reverse` returns a new `List` that is reversed and
    leaves `x` `s` unmodified.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到`xs.reverse`返回一个新的`List`，它是反转的，并且`x` `s`保持不变。
- en: Scala provides constructs where immutability is guaranteed and has many defaults
    where immutability is used, such as when defining case classes or using some of
    the immutable collection that is provided by the standard library. In the next
    subsection, we'll look at higher-order functions, which you'll be using extensively
    when writing programs in Scala using functional programming.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Scala提供了确保不可变性的构造，并且在许多情况下使用不可变性作为默认值，例如在定义案例类或使用标准库提供的某些不可变集合时。在下一小节中，我们将探讨高阶函数，当你使用函数式编程在Scala中编写程序时，你将广泛使用这些函数。
- en: Higher-Order Functions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Higher-order functions are functions that take other functions as arguments.
    This is a technique that is widely used in Scala, and one that you will use all
    the time when you're writing Scala programs. Higher-order functions have already
    been covered previously, but we will include a short recap here for completeness.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是接受其他函数作为参数的函数。这是在Scala中广泛使用的一种技术，当你编写Scala程序时，你将经常使用它。高阶函数已经在之前讨论过，但为了完整性，我们在这里简要回顾一下。
- en: Here's an example of using the higher-order function map on `List` to invoke
    a function on every item of the list to produce a new `List:`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用高阶函数`map`在`List`上的一个例子，它对列表中的每个元素调用一个函数以生成一个新的`List`：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this example uses pure functions, immutability, and higher-order functions
    – the perfect functional program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子使用了纯函数、不可变性和高阶函数——这是完美的函数式程序。
- en: 'Here''s an example of how to define a higher-order function. It takes a function
    from `A => Boolean` and returns a function of `A => Boolean` that negates the
    result of the original function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何定义一个高阶函数的例子。它接受一个`A => Boolean`类型的函数，并返回一个`A => Boolean`类型的函数，该函数否定原始函数的结果：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll write a higher-order function that finds the second element in a list
    given a predicate:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个高阶函数，它根据给定的谓词在列表中找到第二个元素：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are two examples of using the function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个使用该函数的例子：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, try to write your own higher-order function to get a better feeling for
    how they work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试编写你自己的高阶函数，以更好地理解它们的工作方式。
- en: Create a new Scala file in your editor named `HOExample.scala.`
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中创建一个新的Scala文件，命名为`HOExample.scala`。
- en: 'Paste in the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码粘贴进来：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This higher-order function should find the second element in a list given a predicate.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个高阶函数应该根据给定的谓词在列表中找到第二个元素。
- en: 'When you run the application in your editor, you should see the following output:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在编辑器中运行应用程序时，你应该看到以下输出：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'One possible solution is:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've gotten a recap of what higher-order functions are and seen how they can
    be used to write generic functions where some of the functionality of the function
    is provided by an argument to the function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了高阶函数是什么，并看到了它们如何被用来编写通用函数，其中函数的一些功能由函数的参数提供。
- en: In the next section, we'll move beyond the basic concepts behind functional
    programming and look at some of the functional design patterns that you'll encounter
    when using functional libraries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将超越函数式编程的基本概念，并查看在使用函数式库时可能会遇到的一些函数式设计模式。
- en: 'You''ve seen three of the cornerstones of functional programming:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了函数式编程的三个基石：
- en: '**Pure functions**: A function simply computes a result based on the arguments
    to the function and does nothing else.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：一个函数仅根据函数的参数计算结果，并做其他任何事情。'
- en: '**Immutability**: You''ve seen how Scala has good support for immutability
    and uses it as the default in many cases.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：你已经看到了Scala如何支持不可变性，并在许多情况下将其用作默认值。'
- en: '**Higher-order functions**: Functions that take others as arguments or return
    a function are called higher-order functions.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高阶函数**：接受其他函数作为参数或返回函数的函数称为高阶函数。'
- en: Functional Design Patterns
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式设计模式
- en: In this section, we are moving beyond the basic concepts behind functional programming
    and looking at some of the functional design patterns that you'll encounter when
    using functional libraries. You will be introduced to `Monoids`, `Functors`, `Monads`,
    and other functional programming patterns that you can use to structure your programs
    – these patterns are the functional programming equivalent of the object-oriented
    design patterns that you might be familiar with from when you first learned about
    OOP.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在超越函数式编程的基本概念，并查看在使用函数式库时可能会遇到的一些函数式设计模式。你将介绍`Monoids`、`Functors`、`Monads`和其他你可以用来结构化程序的函数式编程模式——这些模式是当你第一次学习面向对象编程时可能熟悉的面向对象设计模式的函数式编程等价物。
- en: Have you ever heard of category theory? The patterns we'll see in this section
    come from category theory. Each concept (such as a `Monoid`) has a clear mathematical
    definition and set of associated laws.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否听说过范畴论？本节中我们将看到的模式来源于范畴论。每个概念（例如一个`Monoid`）都有一个明确的数学定义和一组相关定律。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, we won't go into detail regarding these laws, but should you
    want to research this topic further, it's good to know that the field is called
    category theory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会详细介绍这些定律，但如果你想要进一步研究这个主题，了解这个领域被称为范畴论是有好处的。
- en: This will set you up for further study of functional design patterns and enable
    you to use some of the most popular functional programming libraries such as `Cats`
    and `Scalaz.`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你进一步学习函数式设计模式做好准备，并使你能够使用一些最受欢迎的函数式编程库，如`Cats`和`Scalaz`。
- en: The following subsections will each introduce an abstract structure, show its
    definition in Scala, and show how to use it when you write your programs – the
    structures might seem very abstract at first, but please be patient, as the examples
    will show you how the structures can be very useful.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将分别介绍一个抽象结构，展示其在Scala中的定义，并展示在编写程序时如何使用它——这些结构一开始可能看起来非常抽象，但请耐心，因为例子将展示这些结构如何非常有用。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code will heavily use type classes, so please refer back to the
    previous chapters to make sure you have a good understanding of them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将大量使用类型类，所以请参考前面的章节，确保你对它们有很好的理解。
- en: Monoids
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Monoids
- en: The first structure we'll take a look at is called a `Monoid`. A `Monoid` is
    a very simple structure, but it's one that you'll encounter all the time once
    you've learned to recognize it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考察的第一个结构被称为`Monoid`。`Monoid`是一个非常简单的结构，但一旦你学会了识别它，你将经常遇到它。
- en: 'A `Monoid` has two operations, `combine` and `empty`. In Scala, the definition
    of a Monoid could be expressed as a type class like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Monoid`有两个操作，`combine`和`empty`。在Scala中，`Monoid`的定义可以像以下这样表达为一个类型类：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That is, instances of the `Monoid` type class support two operations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`Monoid`类型类的实例支持两种操作：
- en: '`combine`: This operation takes two arguments of type `A` and returns an `A`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combine`：这个操作接受两个类型为`A`的参数，并返回一个`A`。'
- en: '`empty`: This operation doesn''t take any arguments but it returns an `A`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty`：这个操作不接受任何参数，但它返回一个`A`。'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In category theory, these operations are called `multiplication` and `unit`.
    This might be useful if you want to learn more about this topic at a later date.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在范畴论中，这些操作被称为`乘法`和`单位`。如果你想在以后学习这个主题，这可能是有用的。
- en: This is very abstract, so let's make it concrete by looking at some examples.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常抽象，所以让我们通过一些例子来具体化它。
- en: Let's look at one of the instances of the `Monoid` type class to get a better
    feeling for how it works and how you can use it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Monoid`类型类的一个实例，以更好地了解它是如何工作的以及你可以如何使用它。
- en: Define a `Monoid` type class instance for `String`, that is, a `Monoid[String]:`
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`String`定义一个`Monoid`类型类实例，即`Monoid[String]`：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the `stringMonoid` as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下定义`stringMonoid`：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In most cases, you won't refer to a concrete instance of Monoid as explicitly
    as we've done here, but rather you'll use the `Monoid` type class when writing
    polymorphic functions, as you'll see in the example after the exercises.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不会像我们在这里这样明确地引用`Monoid`的具体实例，而是当编写多态函数时使用`Monoid`类型类，正如你在练习之后的例子中将会看到的。
- en: Let's create implicit def for Monoid creation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建用于创建`Monoid`的隐式定义。
- en: Write an instance of `Monoid` for `Int:`
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Int`编写一个`Monoid`实例：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Write an `implicit def` that can create a `Monoid[List[A]]` for any `A:`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`implicit def`，可以为任何`A`创建一个`Monoid[List[A]]`：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using Monoids to Write Polymorphic Functions
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Monoids编写多态函数
- en: Even though the `Monoid` might seem simple, it is immensely useful. The power
    of `Monoid`, and the other structures that you'll be introduced to later, come
    into play when we define polymorphic functions that know nothing about their arguments
    other than the fact that a `Monoid` instance for their types exists.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Monoid`可能看起来很简单，但它非常有用。`Monoid`的力量以及你稍后将介绍的其他结构，在我们定义多态函数时发挥作用，这些函数对其参数一无所知，除了它们类型的`Monoid`实例存在。
- en: 'Let''s write a function that takes the sum of a list:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个求列表和的函数：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first parameter list is straightforward – it defines that the function takes
    a `List` of the different `A` values. However, the second implicit parameter list
    asks the compiler to find an instance of `Monoid` for `A` and will only allow
    you to invoke `sum[A]` if an instance of `Monoid[A] exists.`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数列表很简单——它定义了该函数接受一个不同`A`值的`List`。然而，第二个隐式参数列表要求编译器为`A`找到一个`Monoid`实例，并且只有当存在`Monoid[A]`的实例时，你才能调用`sum[A]`。
- en: 'With this function, you can take the `sum` of any `List` as long as there is
    an appropriate instance of `Monoid` in scope:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，只要作用域中存在适当的`Monoid`实例，你就可以对任何`List`求和：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We looked at the first structure, the Monoid. We saw that even though the Monoid
    has a very simple interface, it showed itself to be a useful construct that allowed
    us to write interesting polymorphic functions. In the next section, we'll look
    at `Functors`. Put simply, a Functor is something that you can map over.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了第一个结构，即`Monoid`。我们看到尽管`Monoid`有一个非常简单的接口，但它展示了自己是一个有用的结构，它允许我们编写有趣的泛型函数。在下一节中，我们将查看`Functors`。简单来说，`Functor`是你可以在其上映射的东西。
- en: Functor
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Functor
- en: 'The second structure we''ll look at is the `Functor`. Put simply, a `Functor`
    is something that you can map over. In Scala, you''ll be very familiar with this
    operation as you''ve no doubt used it multiple times to manipulate `Lists`, `Options`,
    and so on. In Scala, the type class for `Functors` could look something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要看的第二个结构是`Functor`。简单来说，`Functor`是你可以在其上映射的东西。在Scala中，你无疑已经多次使用这个操作来操作`Lists`、`Options`等。在Scala中，`Functors`的类型类可能看起来像这样：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Functor` abstracts over a type constructor, `F` – types that abstract over
    type constructors are called higher types.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor`抽象了一个类型构造器`F`——抽象类型构造器的类型被称为高阶类型。'
- en: 'You might be tempted to think of `map` as a convenient way to iterate over
    a collection such as `List` or `Set`, but in the context of Functor, there''s
    a more interesting way to look at it. You should think of `map` as a way of sequencing
    operations on some type that preserves the structure of the type as defined by
    the specificities of the type. The details will vary depending on the type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得`map`是一个方便的方式来迭代集合，如`List`或`Set`，但在`Functor`的上下文中，有一个更有趣的方式来看待它。你应该把`map`看作是对某种类型上的操作进行序列化的方式，它保留了类型结构，正如类型的具体性所定义的那样。细节将根据类型而变化：
- en: '**Option**: There might not be a value.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Option**：可能没有值。'
- en: '**List**: There might be zero or more values.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**List**：可能有零个或多个值。'
- en: '**Either**: There might be an error or there might be a value – not both.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Either**：可能有一个错误或一个值——不会两者都有。'
- en: Let's look at some c oncrete examples to make this more clear.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些具体的例子，以便使这更加清晰。
- en: Let's now evaluate the same thing in different contexts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在不同的上下文中评估相同的东西。
- en: 'Write a polymorphic function that abstracts over different Functors:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个抽象不同`Functors`的多态函数：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It defines a function, `compute`, that first uses `map` to add `2` to the value
    inside the functor and then uses map to multiply the result by `2`.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它定义了一个函数`compute`，该函数首先使用`map`将`2`添加到functor内的值，然后使用`map`将结果乘以`2`。
- en: 'We can now invoke this method with any value that has a `Functor` instance
    defined:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以用任何具有`Functor`实例定义的值调用这个方法：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this exercise in mind, you can see how Functor allows you to write polymorphic
    functions that know nothing about their arguments other than that there's a map
    function defined for them. It's up to the specific Functor to define what map
    means in its specific context.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 思考这个练习，你可以看到`Functor`如何让你编写多态函数，这些函数对其参数一无所知，除了它们有一个为它们定义的`map`函数。具体`Functor`定义了在其特定上下文中`map`的含义。
- en: Let's define and use a Functor for `List` and `Option`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义并使用`List`和`Option`的`Functor`。
- en: Define a `Functor` for `List:`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`List`的`Functor`：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using it would then look something like this:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它看起来可能像这样：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Defining Functor for Option**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**为 Option 定义 Functor**'
- en: Write an instance of `Functor` for `Option:`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Option` 编写一个 `Functor` 实例：
- en: Note
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The solution can be found in `Examples/src/main/scala/Functor.scala`, defined
    as `optionFunctor.`
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '解决方案可以在 `Examples/src/main/scala/Functor.scala` 中找到，定义为 `optionFunctor.` '
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We looked at our second structure, the Functor, which represents things that
    can be mapped over. You saw how to define instances for Functor and how one can
    think of `map` as a way of sequencing operations on some type that preserves the
    structure of the type, as defined by the specificities of the type. In the next
    section, we'll look at Monads – a structure that you might already be familiar
    with without knowing it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了第二个结构，Functor，它代表可以映射的事物。你看到了如何为 Functor 定义实例，以及如何将 `map` 视为在某种类型上按顺序执行操作的一种方式，这种方式保留了类型的结构，正如类型的具体性所定义的那样。在下一节中，我们将讨论
    Monads – 一种你可能已经熟悉但不知道其名称的结构。
- en: Monads
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Monads
- en: The last structure we'll look at is the `Monad`. Most Scala programmers will
    be familiar with Monads, even if they don't know them by name, as the abstraction
    is used whenever you write a `for-comprehension`. A Monad has two operations,
    `pure` and `flatMap:`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将要讨论的最后一个结构是 `Monad`。大多数 Scala 程序员对 Monads 都很熟悉，即使他们不知道这个名字，因为这种抽象在编写 `for-comprehension`
    时总是被使用。一个 Monad 有两个操作，`pure` 和 `flatMap:` '
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the category theory names for the `flatMap` operation is `bind,` and
    the name for `pure` is `unit.`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，范畴论中 `flatMap` 操作的名称是 `bind`，而 `pure` 的名称是 `unit`。
- en: Recall from the previous section that you can think of Functors as a way to
    sequence operations on some type that preserves the structure of the type, as
    defined by the specificities of the type. Well, the same is true of a Monad, expect
    they're a bit more powerful. For Functors, the complications can only occur in
    the beginning of the sequence whereas with Monads, they can occur in any part
    of the sequence.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一节，你可以将 Functors 视为在某种类型上按顺序执行操作的一种方式，这种方式保留了类型的结构，正如类型的具体性所定义的那样。嗯，对于
    Monad 也是如此，只是它们更强大。对于 Functors，复杂性只能发生在序列的开始部分，而对于 Monads，它们可以发生在序列的任何部分。
- en: 'Let''s look at an example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What if one of the operations returned an Option?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个操作返回了一个 Option 值呢？
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we have a value of type `Option[Option[Int]],` which isn't very convenient.
    This is where `Monad` comes in handy. If you have a sequence of operations where
    you want some specificities of some type to be preserved on every step, you'll
    want to use a `Monad`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个 `Option[Option[Int]]` 类型的值，这并不太方便。这就是 `Monad` 发挥作用的地方。如果你有一系列操作，你希望在每个步骤上保留某些类型的特定性，那么你将想要使用一个
    `Monad`。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see from the preceding definition, a Monad is also a Functor, as
    map can be implemented in terms of `flatMap` and `pure.`
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的定义所示，Monad 也是一个 Functor，因为 map 可以用 `flatMap` 和 `pure` 来实现。
- en: 'Here''s how you can define a Monad for Option:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何为 Option 定义一个 Monad：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`pure` is defined by simply wrapping the value in `Some`. `flatMap` is defined
    by pattern matching on the value and applying the function if it''s `Some,` otherwise
    returning `None.`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`pure` 通过简单地用 `Some` 包装值来定义。`flatMap` 通过对值进行模式匹配并在它是 `Some` 时应用函数来定义，否则返回 `None`。'
- en: We can avoid the previous inconvenient situation of having an `Option[O` `ption[Int]]:`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以避免之前不便利的情况，即有一个 `Option[Option[Int]]`：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have seen the definition of the Monad and how it can be used to sequence
    operations in a specific context where each step in the sequence needs to preserve
    some specificities that depend on the instance of the Monad.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Monad 的定义以及它如何可以在需要保留依赖于 Monad 实例的特定性的特定上下文中按顺序执行操作。
- en: Popular Libraries
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行库
- en: By this point, you should have a good understanding of the main concepts behind
    functional programming such as pure functions, immutability, and higher-order
    functions. In addition to that, you should be familiar with some of the most popular
    abstractions used when writing functional programs. With all of this knowledge,
    you are well equipped to start looking into some of the popular functional programming
    libraries in Scala.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对函数式编程背后的主要概念有了很好的理解，例如纯函数、不可变性和高阶函数。除此之外，你应该熟悉在编写函数式程序时使用的最流行的抽象。有了所有这些知识，你就可以开始研究
    Scala 中一些流行的函数式编程库了。
- en: 'In this section, we''ll look at some of the popular functional programming
    libraries from the Scala ecosystem. After this section, you should be able to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 Scala 生态系统中的几个流行的函数式编程库。在本节之后，你应该能够：
- en: Use the `Cats``Validated` type class to validate your data
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Cats` 的 `Validated` 类型类来验证你的数据
- en: Use `Doobie` to talk to databases
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Doobie` 与数据库通信
- en: Validating Data Using Cats
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cats 验证数据
- en: In this section, we'll get a quick overview of the Cats library and look at
    one of the data types it provides to `Validate` data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速概述 Cats 库，并查看它提供用于 `Validate` 数据的一个数据类型。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on Cats, refer to [https://github.com/typelevel/cats](https://github.com/typelevel/cats).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Cats 的信息，请参阅 [https://github.com/typelevel/cats](https://github.com/typelevel/cats)。
- en: By the end of this section, you should understand how `Cats` fits into the Scala
    ecosystem and know how to use it in your own projects, specifically to validate
    your data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你应该了解 `Cats` 如何融入 Scala 生态系统，并知道如何在你的项目中使用它，特别是用于验证数据。
- en: Prerequisites for Using Cats
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cats 的先决条件
- en: 'You need to add `Cats` as a dependency to your Scala project. Create a new
    SBT project with the following `build.sbt` file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将 `Cats` 添加为 Scala 项目的依赖项。创建一个新的 SBT 项目，包含以下 `build.sbt` 文件：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As `Cats` relies heavily on implicits to provide type class instances and extension
    methods, you always need to have the following imports in your files when you're
    using `Cats:`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `Cats` 严重依赖隐式函数来提供类型类实例和扩展方法，因此当你在文件中使用 `Cats` 时，始终需要以下导入：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Introduction to Cats
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cats 简介
- en: Cats is a library which provides abstractions for functional programming in
    the Scala programming language. Specifically, it provides definitions for all
    of the patterns you saw in the previous section (Monoid, Monad, and so on) and
    many more. It also contains type class instances for all of the relevant classes
    from the Scala standard library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 是一个库，它为 Scala 编程语言中的函数式编程提供抽象。具体来说，它为上一节中看到的所有模式（Monoid、Monad 等）提供了定义，并且还有更多。它还包含
    Scala 标准库中所有相关类的类型类实例。
- en: The broader goal of Cats is to provide a foundation for an ecosystem of pure,
    typeful libraries to support functional programming in Scala applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 的更广泛目标是提供一个支持 Scala 应用程序中纯函数式编程的生态系统的基础。
- en: Validating Data
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证数据
- en: There are two different ways to validate data using Cats. The first is `Either,`
    as you know it from the standard library, and the other is `Validated`. You should
    use `Either` if you want your validation to fail-fast and you should use `Validated`
    if you want to accumulate the errors. Which one you should use depends on your
    use case. As you might be familiar with `Either` from the standard library, we'll
    focus on `Validated` in this subsection.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cats 验证数据有两种不同的方式。第一种是 `Either`，正如你从标准库中了解的那样，另一种是 `Validated`。如果你想快速失败验证，你应该使用
    `Either`；如果你想累积错误，你应该使用 `Validated`。你应该使用哪一个取决于你的用例。由于你可能已经熟悉标准库中的 `Either`，我们将在这个子节中重点介绍
    `Validated`。
- en: 'First, let''s have a look at a basic domain model and some constraints we have
    for the data. Let''s assume you have a `User` that looks like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个基本的领域模型和一些我们对该数据的要求。假设你有一个如下所示的 `User`：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s also assume that you have the following rules for this user:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你为这个用户有以下规则：
- en: The username has to contain at least three characters.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名必须至少包含三个字符。
- en: The username can only contain alphanumeric characters.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名只能包含字母数字字符。
- en: The age has to be positive.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄必须是正数。
- en: 'We can represent these three errors in Scala using a sealed trait with case
    objects like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Scala 中的 sealed trait 和 case objects 来表示这三个错误，如下所示：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's look at how we could write the preceding rules in Scala using `Validated.`
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `Validated` 在 Scala 中编写前面的规则。
- en: Validating Using Validated
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Validated 验证
- en: 'The `Validated` data type is defined like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validated` 数据类型定义如下：'
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, `Valid[A]` represents a value of type `A` that passed some kind of validation,
    and `Invalid[A]` represents that some validation failed, producing an error of
    type `E`. Let''s try to implement the rules from the previous section:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Valid[A]` 表示通过某种验证的类型 `A` 的值，而 `Invalid[A]` 表示某些验证失败，产生类型为 `E` 的错误。让我们尝试实现上一节中的规则：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we define a method, `validateAge`, which takes an `Int` and returns `Validated[NonEmptyList[Error],
    Int]`, meaning that it will either return `Valid(age)` if it's valid or `Invalid(NonEmptyList(ValueTooLow))`
    if it's not. We use the extension methods `validNel` and `invalidNel` that `Cats`
    provides for your convenience.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个方法 `validateAge`，它接受一个 `Int` 并返回 `Validated[NonEmptyList[Error],
    Int]`，这意味着如果它有效，则返回 `Valid(age)`；如果它无效，则返回 `Invalid(NonEmptyList(ValueTooLow))`。我们使用
    `Cats` 为您提供的便利扩展方法 `validNel` 和 `invalidNel`。
- en: 'Next up, let''s define a validator for the username:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个用于用户名的验证器：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, we're defining two helper functions, `checkLength` and `checkSpecialCharacters`,
    which check that the string is longer than 3 characters and doesn't contain any
    alphanumeric characters. We combine these two checks using the `mapN` extension
    method that Cats provides on tuples. If both checks pass, the `mapN` function
    will be invoked with a tuple containing both the valid values, but we're only
    interested in the username once we simply return the first valid value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了两个辅助函数，`checkLength` 和 `checkSpecialCharacters`，它们检查字符串是否超过 3 个字符，并且不包含任何字母数字字符。我们使用
    Cats 为元组提供的 `mapN` 扩展方法结合这两个检查。如果两个检查都通过，`mapN` 函数将使用包含两个有效值的元组调用，但我们只对用户名感兴趣，一旦我们简单地返回第一个有效值。
- en: 'Finally, let''s write the method that validates both the username and the age
    and returns a `User` if everything is valid:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们编写一个验证用户名和年龄的方法，并在一切有效的情况下返回一个 `User`：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, we use the `mapN` method and pass in a function that should be invoked
    if all checks pass. In this case, we use the `apply` method on `User` to create
    an instance of `User.`
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用 `mapN` 方法并传递一个函数，如果所有检查都通过，则调用该函数。在这种情况下，我们使用 `User` 上的 `apply` 方法来创建
    `User` 的实例。
- en: 'If you invoke this, you can see that it accumulates the errors if there are
    any; otherwise, it returns a `User` that has been validated:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用这个，你可以看到如果有任何错误，它会累积错误；否则，它返回一个经过验证的 `User`：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By now, you should know how to add Cats to your Scala projects and know how
    to use their `Validated` data type to write validation methods for your domain
    models in a nice, functional way. In the next section, we'll have a look at how
    to use the `Doobie` library to communicate with databases in a functional type-safe
    manner.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该知道如何将 Cats 添加到你的 Scala 项目中，并知道如何使用它们的 `Validated` 数据类型以优雅的函数式方式编写你的领域模型的验证方法。在下一节中，我们将探讨如何使用
    `Doobie` 库以函数式类型安全的方式与数据库进行通信。
- en: Communicating with Databases Using Doobie
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Doobie 与数据库通信
- en: In this subsection, we'll use the `Doobie` library to communicate with databases
    in a functional and type-safe manner. You will be introduced to the core concepts
    of `Doobie` and see how to use it to query, update, and delete rows in your database.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将使用 `Doobie` 库以函数式和类型安全的方式与数据库进行通信。你将了解 `Doobie` 的核心概念，并了解如何使用它来查询、更新和删除数据库中的行。
- en: After this subsection, you should be able to use `Doobie` in your own Scala
    projects for simple queries and insertions, and know where to find documentation
    for more advanced use cases.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节之后，你应该能够在自己的 Scala 项目中使用 `Doobie` 进行简单的查询和插入，并知道在哪里找到更高级用例的文档。
- en: Prerequisites for Doobie
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Doobie 的先决条件
- en: 'You need to add Doobie as a dependency to your Scala project. Create a new
    SBT project with the following `build.sbt` file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将 Doobie 添加到你的 Scala 项目中依赖项。创建一个新的 SBT 项目，包含以下 `build.sbt` 文件：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Doobie can talk to many different databases, such as MySQL, Postgres, H2, and
    so on. In the following examples, we'll use the in-memory database H2 to simplify
    the setup. Have a look at the documentation to see how to use the other databases.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Doobie 可以与许多不同的数据库进行通信，例如 MySQL、Postgres、H2 等。在以下示例中，我们将使用内存数据库 H2 来简化设置。查看文档了解如何使用其他数据库。
- en: 'The database tables we''ll use in these examples are quite simple. There are
    two tables, `user` and `todo`, which have the following SQL definitions:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们将使用的数据库表相当简单。有两个表，`user` 和 `todo`，它们具有以下 SQL 定义：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Doobie
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doobie
- en: In Doobie, to make large programs, you need to write small programs. After creating
    the program, you can directly drop it into your main function and use it as an
    effectful monad.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Doobie 中，为了编写大型程序，你需要编写小的程序。创建程序后，你可以直接将其放入主函数中，并用作有效的 monad。
- en: Doobie has a high-level and a low-level API. In this lecture, we'll focus exclusively
    on the high-level API. In the high-level API, there are only a handful of important
    classes. The two most important are `ConnectionIO` and `Transactor.`
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: ConnectionIO
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common types you will deal with have the form `ConnectionIO[A]`, specifying
    computations that take place in a context where a `java.sql.Connection` is available,
    ultimately producing a value of type `A`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '`ConnectionIO[A]` is the most common types you will come across, and it specifies
    the calculations that occur where `java.sq` `l.Connection` is available, which
    generates a value of type `A`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Transactor
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Transactor` is a structure which is used for database connectivity, connection
    handouts, and cleanup; it can take a `ConnectionIO[A]` and produce an `IO[A]`,
    which provides an executable code. It specifically provides you an `IO` that,
    when executed, will connect to the database and run the program in a single transaction.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Here's a full example that creates a `Transactor` that can connect to the H2
    database. We then use that `transactor` to perform the simple query `SELECT` `42:`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding example creates a `Transactor` using `Transactor.fromDriverManager`
    and then creates a small program that, when provided with a `Connection`, will
    run `SELECT 42`. Finally, the program is turned into an `IO` monad using the transact
    method on `ConnectionIO,` and the `IO` monad is executed using `unsafeRunSync`
    to produce an `Int` that is the result of executing `SELECT 42`. It's important
    to understand that no side effects are occurring until the `IO` monad is executed
    using `unsfaceRunSync.`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's have a look at how to write queries.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Rows
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've seen how to use the `ConnectionIO` and `Transactor`, let's have
    a look at some more interesting queries to perform a very simply query.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by examining the following expression from the previous example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We use the Doobies string interpolation function `sql` to turn a normal `String`
    into a `Fragment`. A `Fragment` is simply Doobie's representation of parts of
    an SQL query, which may include interpolated values. `Fragments` can be composed
    by concatenation, which maintains the correct offset and mappings for interpolated
    values. In this lecture, we won't go into detail with what you can do with `Fragments`,
    but you can find more information in the documentation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a `Fragment`, you can turn it into a `Query` using the `query[A]`
    method on `Fragment`. `Query[A, B]` is Doobie's representation for a complete
    SQL query that takes some input of type `A` and produces some output of type B.
    In this specific example, our query doesn't take any input, so the specific type
    `Query0` is returned, which represents a query that doesn't take any parameters.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a `ConnectionIO[Int]` is produced by using the `unique` method on `Query`.
    As stated previously, `ConnectionIO[A]` represents computations that take place
    in a context where a `java.sql.Connection` is available, ultimately producing
    a value of type `A`. In this case, we use `unique` as we're only expecting one
    row to be returned. Other interesting methods are `list` and `opti` `on`, which
    return `ConnectionIO[List[A]]` and `ConnectionIO[Option[A]],` respectively.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Querying Using Parameters
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Doobie, you pass parameters to queries as you would with any string interpolator.
    The parameters are turned into `?` expressions in prepared statements to avoid
    SQL injections. Let''s have a look at how to query using parameters:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the following queries in `lesson-1/doobie-example/src/main/scala/com/example/User.scala.`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first query, `allManual`, takes an `Int` and uses it as a parameter to define
    the `LIMIT` of the SQL query. The second query takes a `String` and uses it in
    a `WHERE` clause to select users with that specific username. The `allManual`
    query selects a `Tuple` of ( `Int`, `String`, `Int`) and `maps` over it to produce
    a `User`, whereas `withUsername` uses Doobie's ability to automatically use the
    `apply` method of a case class when querying for rows of that type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Deleting, Inserting, and Updating Rows
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting, inserting, and updating works in a similar way. First, let''s look
    at how to delete rows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, we use the SQL string interpolator to define our query and simply refer
    to variables in scope to define parameters to the query. However, instead of using
    the `query[A]` method on `Fragment` to produce a `Query`, we use `update[A]` to
    produce an `Update[A]`. We then use the `run` method on `Update` to produce a
    `ConnectionIO[A]:`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Both `setAge` and `create` are similar, but `create` uses an interesting method
    on `Update` named `withUniqueGeneratedKeys`, which returns the `id` of the row
    that was inserted last.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: A Complete Example
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at a full example. You can find it in `lesson-1/doobie-example/src/main/scala/com/example/Main.scala`.
    We''ll look at each section piece by piece:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this section, you can see how to chain `ConnectionIO` using `flatMap` through
    Scala `for-comprehensions`. This allows us to nicely construct `ConnectionIO`
    from the result of executing another `ConnectionIO`. In this case, we use it to
    first create a `User` and then use the `userId` in subsequent methods to set the
    user''s age and construct three `Todo` methods for the user:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this section, we will produce `IO` from two `ConnectionIO` instances by
    using the `transact` method in a `for` `-comprehension`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, the `IO` is executed to produce side effects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Adding Priority to the Todo List'
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where a client has told you that he needs priority function
    added to his Todo lists. Design the priority for the application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the example program in `lesson-1/doobie-example` by adding a priority
    to each of the Todos and use the priority when querying for uncompleted todos
    so that the most important is returned first. You''ll have to perform the following
    steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `lesson-1/doobie-example` 中的示例程序中为每个 Todo 添加优先级，并在查询未完成的 Todo 时使用该优先级，以便首先返回最重要的
    Todo。你需要执行以下步骤：
- en: 'Extend the `Todo case class` with a `priority: Int` field.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过添加一个 `priority: Int` 字段来扩展 `Todo case class`。'
- en: Update the `Table` definition in `Todo.table.`
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Todo.table.` 中的 `Table` 定义。
- en: Update the `Todo.create` method to take an `Int` that represents the priority.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Todo.create` 方法，使其接受一个表示优先级的 `Int` 类型的参数。
- en: Update `Todo.uncompleted` so it orders the rows in descending order.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Todo.uncompleted` 以按降序排列行。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the core concepts of functional programming like
    Pure functions, immutability, and higher-order functions. We introduced some of
    the design patterns that are prevalent in large functional programs. Finally,
    we covered two popular functional programming libraries called Cats and Doobie,
    and used them to write some interesting programs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了函数式编程的核心概念，如纯函数、不可变性和高阶函数。我们还介绍了一些在大型函数式程序中普遍存在的模式。最后，我们介绍了两个流行的函数式编程库，即
    Cats 和 Doobie，并使用它们编写了一些有趣的程序。
- en: In the next chapter, we will cover how Scala makes it possible to write powerful
    Domain-Specific Languages (DSLs) by providing a few interesting language features.
    We'll have a brief look at what DSLs are in general terms. We'll also cover a
    DSL that you'll very likely be using if you're going to work with Scala professionally.
    Finally, you will implement your own DSL.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Scala 如何通过提供一些有趣的语言特性，使得编写强大的领域特定语言（DSLs）成为可能。我们将简要地看看一般意义上的 DSLs
    是什么。我们还将介绍一个如果你打算专业地使用 Scala 的话，你很可能要使用的 DSL。最后，你将实现你自己的 DSL。
