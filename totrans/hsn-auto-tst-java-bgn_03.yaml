- en: Handling Strings and Their Functions in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中处理字符串及其功能
- en: In this chapter, we'll talk about strings and have a look at the `String` class.
    We will also learn how to define a string and look at the different ways in which
    we can define a string. We will then discuss the different methods in the `String`
    class. Lastly, we will write some simple code to reverse the contents of a string,
    and we will also check whether or not that reversed string is a palindrome.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论字符串，并查看`String`类。我们还将学习如何定义字符串，并查看我们可以用哪些不同的方式定义字符串。然后，我们将讨论`String`类中的不同方法。最后，我们将编写一些简单的代码来反转字符串的内容，并检查反转后的字符串是否是回文。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串介绍
- en: The String class and its methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String类及其方法
- en: Reversing a string's logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转字符串的逻辑
- en: Introducing strings
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串介绍
- en: A string is one of the most important concepts in Java programming. `String`
    is one of the prebuilt classes in Java. So if you want to manipulate strings,
    then you could simply create an object of this `String` class, and using that
    object, you can manipulate the string however you want. You can then break the
    string into two parts, based on the `substring` concept. We can also concatenate
    two strings. All of this can be done with the help of this `String` class.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是Java编程中最重要的概念之一。`String`是Java中预定义的类之一。因此，如果你想操作字符串，那么你可以简单地创建这个`String`类的一个对象，然后通过这个对象，你可以按照你的意愿操作字符串。你可以根据`substring`概念将字符串分成两部分。我们还可以连接两个字符串。所有这些都可以通过这个`String`类来完成。
- en: Let's try manipulating a string ourselves. Create a new Java class and name
    it `stringclassdemo`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试自己操作一个字符串。创建一个新的Java类，并将其命名为`stringclassdemo`。
- en: 'One of the most common questions asked in almost all Java related interviews
    is how a programmer can define strings. The answer is that you can use either
    of the two following ways:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有与Java相关的面试中，最常见的问题之一是程序员如何定义字符串。答案是你可以使用以下两种方式中的任何一种：
- en: By defining the `String` literal
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义字符串字面量
- en: By creating an object of `String`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建String对象
- en: Now let's look at each method, one by one, in order to understand the different
    ways of declaring a string.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个查看每种方法，以便了解声明字符串的不同方式。
- en: Defining the String literal
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义字符串字面量
- en: 'Defining the `String` literal can be done simply, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 定义字符串字面量可以简单地这样做：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We created a string, which is `hello`, and stored it in the variable called
    `a`. This is how we define a `String`, which is the same as defining the `String`
    literal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`hello`的字符串，并将其存储在名为`a`的变量中。这就是我们定义`String`的方式，与定义字符串字面量相同。
- en: 'Let''s say that you have defined one more string, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你定义了另一个字符串，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unfortunately, even the `b` variable has a `hello` string, and the `a` variable
    also has the same string defined. When the Java program compiles this, it creates
    one `String` object called `a`, and assigns `hello`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使`b`变量也有一个`hello`字符串，`a`变量也定义了相同的字符串。当Java程序编译这个时，它创建了一个名为`a`的`String`对象，并赋值为`hello`。
- en: Now, before creating an object for this `hello` string, the `b` variable first
    checks whether there is any `hello` string instance already defined in the `String`
    pool. If it is already defined, it simply refers `a` to the `b` object rather
    than creating one more object separately.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在为这个`hello`字符串创建对象之前，`b`变量首先检查`String`池中是否已经定义了任何`hello`字符串实例。如果已经定义，它将简单地让`a`变量引用`b`对象，而不是单独创建另一个对象。
- en: Creating an object of the String class
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建String类的对象
- en: 'We create an object of the `String` class as shown in the following line of
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下代码行中创建了一个`String`类的对象：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, to create a `hello` string, you could simply pass an argument into the
    `String` class, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个`hello`字符串，你可以简单地传递一个参数给`String`类，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ab` object can now perform all the string manipulations on this `hello`
    string.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ab`对象现在可以对这个`hello`字符串执行所有的字符串操作。'
- en: 'Let''s create another string, called `b`, which also equals to `hello`, as
    follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个名为`b`的字符串，它也等于`hello`，如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, though, there is already one `hello` string created with the `a` object,
    and when the Java compiler comes to the `b` object, it will still create one more
    duplicate `hello` string and assign it to `b`, because here we are explicitly
    forcing it to create an object for this class. Although there is a duplicate already
    present, it will still create an object for this string; however, in defining
    a `String` literal, if the object is already present in the `String` pool, it
    will not create it—instead, it directly refers it to the already created object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里已经使用`a`对象创建了一个`hello`字符串，当Java编译器到达`b`对象时，它还会创建一个额外的重复的`hello`字符串并将其分配给`b`，因为在这里我们明确地强制它为这个类创建一个对象。尽管已经存在一个重复的对象，但它仍然会为这个字符串创建一个对象；然而，在定义一个`String`字面量时，如果对象已经在`String`池中存在，它将不会创建它——相反，它直接引用已经创建的对象。
- en: So that's the basic difference between creating a string with the `String` literal
    object and separately creating an object with the `String` class. Ultimately,
    both support `String` methods, but there is some difference between the two methods
    when it comes to defining a string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是使用`String`字面量对象创建字符串和单独使用`String`类创建对象之间的基本区别。最终，两者都支持`String`方法，但在定义字符串时，两种方法之间有一些区别。
- en: What is the difference between these two methods that we just learned? Both
    strings have access to the `hello` string, but you can see that there is some
    difference between them. If you declare the string in the literal fashion at the
    backend, then Java assigns `hello` to the `a` variable. So this is a more direct
    way of creating a string, rather than using the object creation method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学到的这两种方法有什么区别？这两个字符串都可以访问`hello`字符串，但你可以看到它们之间有一些区别。如果你在后台以字面形式声明字符串，那么Java会将`hello`分配给`a`变量。所以这是一种更直接创建字符串的方法，而不是使用对象创建方法。
- en: In most of our regular Java working experience, we would prefer to use the `String`
    literal. We just state that `a` equals `hello`, and that's it. It's just like
    how you define integers. But `String` is a class, and at the backend, it creates
    a separate object for this `hello` string, whereas an integer is just a reference
    data type, so nothing will happen at its backend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们大多数常规Java工作经验中，我们更愿意使用`String`字面量。我们只需声明`a`等于`hello`，然后就这样。这就像你定义整数一样。但`String`是一个类，在后台，它为这个`hello`字符串创建一个单独的对象，而整数只是一个引用数据类型，所以后台不会发生任何事情。
- en: Let's see what manipulations we can apply to this `hello` string with the object
    we created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用我们创建的对象对这个`hello`字符串进行哪些操作。
- en: The String class and its methods
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`String`类及其方法'
- en: 'We have the `a` variable, and this variable also acts an object. When we type
    `a.` in the editor, it''ll show all the methods that are present in that `String`
    class, as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`a`变量，这个变量也充当一个对象。当我们输入`a.`到编辑器中，它会显示在该`String`类中存在的所有方法，如下面的截图所示：
- en: '![](img/29781683-a824-484c-b21b-fa1150b48d12.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29781683-a824-484c-b21b-fa1150b48d12.png)'
- en: 'It reads the first character in the strings as index zero, the second character
    as index one, and so on. When working on a program, if you want the character
    present on index two, you can get it simply by using the following statement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它将字符串中的第一个字符读取为索引零，第二个字符为索引一，依此类推。当你在程序上工作时，如果你想获取索引二上的字符，你可以简单地使用以下语句：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You print it in the output so that you will see that character. You might be
    wondering why would we need a single character from a string, but the `charAt`
    method is often used. In the next section, we will look at a program that can
    completely reverse the string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你将其打印到输出中，这样你就能看到那个字符。你可能想知道为什么我们需要从字符串中获取单个字符，但`charAt`方法经常被使用。在下一节中，我们将查看一个可以完全反转字符串的程序。
- en: 'For now, we will just go through an overview of the methods. We saw how to
    get a character that is present at a particular index position. Now let''s try
    reversing this. Say that we have the character present and we need to find the
    index value at which the character is present in the string. We do this by using
    the `indexOf` method, shown as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只简要地概述一下这些方法。我们看到了如何获取特定索引位置上存在的字符。现在让我们尝试反转这个字符串。假设我们有存在的字符，我们需要找到该字符在字符串中存在的索引值。我们通过使用以下所示的`indexOf`方法来完成这个操作：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run this program. You can see that the character `l` is at `2`, `H` is at `0`,
    `e` is at index `1`, and `l` is at index `2`. This is how you can extract characters
    and indexes with the help of the `String` methods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序。你可以看到字符 `l` 在 `2`，`H` 在 `0`，`e` 在索引 `1`，`l` 在索引 `2`。这就是如何借助 `String`
    方法提取字符和索引。
- en: 'But what if I want to pull the string only from the first character to the
    third character? Let''s take a look at the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我只想从第一个字符开始提取到第三个字符的字符串呢？让我们看看下面的例子：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We type `a.`, and you can see that there is a `substring`. If you want to pull
    a string that starts at index `3` and ends at index `6`, this means that `j` will
    be at `0`, `a` will be at `1`, and so on. It starts from `2`, and moves on to
    `3`, `4`, and `5`, and it will print something like `vatra`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入 `a.`，你可以看到有一个 `子字符串`。如果你想提取从索引 `3` 开始到索引 `6` 结束的字符串，这意味着 `j` 将在 `0`，`a`
    在 `1`，以此类推。它从 `2` 开始，然后移动到 `3`，`4` 和 `5`，并打印出类似 `vatra` 的内容。
- en: 'If you want to pull out `substring` from the entire string, then give the first
    letter index and the last letter index so that our entire string will be printed
    between that first and last letter. Bear in mind that there is another `substring`
    method, and with this method, if you don''t pass the last index, passing only
    the first index, then it prints from index `5` to the last index, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从整个字符串中提取 `子字符串`，那么给出第一个字母的索引和最后一个字母的索引，这样我们的整个字符串就会在第一个和最后一个字母之间打印出来。记住，还有一个
    `substring` 方法，使用这个方法，如果你不传递最后一个索引，只传递第一个索引，那么它将从索引 `5` 打印到字符串的最后一个索引，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s print the output and see how the `substring` is extracted. The results
    of this are shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印输出并看看 `substring` 是如何提取的。这些结果如下面的截图所示：
- en: '![](img/8b700af8-859e-4349-b4e2-13b364f8e9ab.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/8b700af8-859e-4349-b4e2-13b364f8e9ab.png)'
- en: Here, the index of `e` is `-1`, because there is no alphabetical character called
    `e` in this string. Whenever there is nothing, then it prints a `-1`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`e` 的索引是 `-1`，因为在这个字符串中没有名为 `e` 的字母字符。每当没有内容时，它就会打印 `-1`。
- en: 'That sums up `substring`. If I want to `concat` this string with one more string
    called `rahul teaches`, then I do the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就总结了 `substring`。如果我想将这个字符串与另一个名为 `rahul teaches` 的字符串连接起来，那么我这样做：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `javatraining` string that is present in the `a` variable will be concatenated
    with `rahul teaches`, and it prints the output as `javatrainingrahul teaches`.
    We can also use `a.length()`, which will give the maximum length of this string
    starting from zero. There is one more type called `trim`. Let''s say that there
    are some white spaces in your string, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 存在于 `a` 变量中的 `javatraining` 字符串将与 `rahul teaches` 连接，并打印出 `javatrainingrahul
    teaches` 的输出。我们也可以使用 `a.length()`，这将给出从零开始的字符串的最大长度。还有一个叫做 `trim` 的类型。假设你的字符串中有一些空白字符，如下所示：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the first character of the string is a blank space, and is then followed
    by the rest of the characters. If you want to remove that blank space, you can
    do so by simply using `a.trim`. This blank space is removed when you print the
    output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，字符串的第一个字符是一个空格，然后是其余的字符。如果你想删除这个空格，你可以简单地使用 `a.trim`。当你打印输出时，这个空格就会被删除。
- en: If you want to print all the letters in uppercase, we can use `a.toUpperCase`.
    We can do the same for lowercase by using `a.toLowerCase`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将所有字母打印为大写，我们可以使用 `a.toUpperCase`。我们也可以通过使用 `a.toLowerCase` 来将它们转换为小写。
- en: 'There is one more interesting method to look at, which is `split`. Basically,
    we can split the entire string based on our delimiter. For this, we use `a.split()`.
    In this case, we want to split it based on a slash in the code, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更有趣的方法可以看看，那就是 `split`。基本上，我们可以根据我们的分隔符来分割整个字符串。为此，我们使用 `a.split()`。在这种情况下，我们想要根据代码中的斜杠来分割，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This means that the whole string before the `/` character should be separated
    as one string and the remaining part should be separated as another string. This
    method can not only be used to split across a slash, but can also split across
    whatever we want it to, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 `/` 字符之前的整个字符串应该作为一个字符串分开，剩余的部分应该作为另一个字符串分开。这种方法不仅可以用来在斜杠处分割，还可以根据我们的需求分割，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we want to split our string from `t`, then that means that `java` will be
    one string and `raining` will be another string. As we will have two strings,
    our output will store these two strings in an array, and this array return type
    will be, of course, a `String`, because it''s written in a `String`, as shown
    in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从`t`中分割我们的字符串，那么这意味着`java`将是一个字符串，而`raining`将是另一个字符串。因为我们会有两个字符串，所以我们的输出将存储这两个字符串在一个数组中，而这个数组的返回类型当然是`String`，因为它是在`String`中编写的，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you want to print the first part of the string, then this will be stored
    in the `0` index of the array system, and if you want to print the second part
    of the string, then it will present it in the `1` index of the array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要打印字符串的前一部分，那么它将被存储在数组系统的`0`索引中，而如果你想要打印字符串的第二部分，那么它将在数组的`1`索引中呈现。
- en: 'One final method that we will discuss here is the `replace` method, shown in
    the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的最后一种方法是`replace`方法，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we want to replace the `t` from the string with a random `s`. For this,
    we use `a.replace("t", "s")`, and that's it. On printing this, wherever a `t`
    is present in the string, it will be changed to an `s`, and it will be printed
    in your output.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要将字符串中的`t`替换为一个随机的`s`。为此，我们使用`a.replace("t", "s")`，就是这样。打印出来后， wherever
    a `t` is present in the string, it will be changed to an `s`, and it will be printed
    in your output.
- en: That's pretty much it for `String` methods. You could still play around with
    them by using `a.` and go through different methods step by step, but these are
    the core methods that we use in our Java programming.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`String`方法来说，这基本上就结束了。你仍然可以通过使用`a.`并逐步遍历不同的方法来玩转它们，但这些都是我们在Java编程中使用的核心方法。
- en: Let's try to tackle one example based on the methods that we have learned in
    this section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试根据在本节中学到的方法解决一个例子。
- en: Reversing a string's logic
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转字符串的逻辑
- en: In this section, let's see how we can print a string in reverse. This is one
    of the questions that was asked in the Yahoo interview. Let's create a `reversedemo`
    class for our example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看我们如何以相反的顺序打印一个字符串。这是雅虎面试中的一个问题。让我们为我们的例子创建一个`reversedemo`类。
- en: 'We have a string called `Rahul`, and we want the output to be `luhaR`. There
    is one more concept that we need to be aware of: a palindrome. If you type in
    a string, such as `madam`, and we reverse the string, it would just give `madam`
    as the output. Such types of strings are called **palindromes**. One such instance
    of a palindrome is shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`Rahul`的字符串，我们想要输出为`luhaR`。还有一个概念我们需要注意：回文。如果你输入一个字符串，比如`madam`，并且我们反转这个字符串，它只会给出`madam`作为输出。这种类型的字符串被称为**回文**。以下代码中展示了一个回文的实例：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We would start by creating a string, called `s`, and an empty string, called
    `t`. We create this empty string to concatenate each element after the `for` loop
    to get the output in the console in the form of a string; otherwise, we may get
    it something like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`s`的字符串和一个空字符串，名为`t`。我们创建这个空字符串是为了在`for`循环之后连接每个元素，以便在控制台以字符串的形式输出结果；否则，我们可能会得到如下所示的结果：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using the concatenation logic, we can display the output as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接逻辑，我们可以显示输出如下：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This was a simple logic that is used to reverse our string and display it in
    the form of a string using the empty string logic. We used the `charAt` method
    and implemented our reverse string. Once we have our reverse string, we can easily
    compare it with the original string—in our case, this involves comparing the `t`
    string with the `s` string, and if they both match, then we can print that the
    given string is a palindrome.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的逻辑，用于反转我们的字符串，并使用空字符串逻辑以字符串的形式显示它。我们使用了`charAt`方法并实现了我们的反转字符串。一旦我们有了反转的字符串，我们就可以很容易地将其与原始字符串进行比较——在我们的例子中，这涉及到将`t`字符串与`s`字符串进行比较，如果它们都匹配，那么我们可以打印出给定的字符串是一个回文。
- en: Forget about palindromes. This is the concept of string reversal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记回文。这是字符串反转的概念。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we were introduced to strings, which are one of the more important
    classes in Java. We looked at the different ways to define a string. We then looked
    at the different methods that come under the `String` class. We looked at some
    of the most commonly used methods in the `String` class, and in the final section,
    we looked at an example of reversing a string to better understand the `String`
    class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了字符串，这是Java中较为重要的类之一。我们探讨了定义字符串的不同方法。然后，我们研究了`String`类下的不同方法。我们查看了一些`String`类中最常用的方法，在最后一节中，我们通过一个反转字符串的示例来更好地理解`String`类。
- en: In the next chapter we will understand the important loops and conditions through
    examples.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过示例了解重要的循环和条件。
