- en: Handling Strings and Their Functions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll talk about strings and have a look at the `String` class.
    We will also learn how to define a string and look at the different ways in which
    we can define a string. We will then discuss the different methods in the `String`
    class. Lastly, we will write some simple code to reverse the contents of a string,
    and we will also check whether or not that reversed string is a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The String class and its methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a string's logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A string is one of the most important concepts in Java programming. `String`
    is one of the prebuilt classes in Java. So if you want to manipulate strings,
    then you could simply create an object of this `String` class, and using that
    object, you can manipulate the string however you want. You can then break the
    string into two parts, based on the `substring` concept. We can also concatenate
    two strings. All of this can be done with the help of this `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try manipulating a string ourselves. Create a new Java class and name
    it `stringclassdemo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common questions asked in almost all Java related interviews
    is how a programmer can define strings. The answer is that you can use either
    of the two following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By defining the `String` literal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By creating an object of `String`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at each method, one by one, in order to understand the different
    ways of declaring a string.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the String literal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining the `String` literal can be done simply, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We created a string, which is `hello`, and stored it in the variable called
    `a`. This is how we define a `String`, which is the same as defining the `String`
    literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you have defined one more string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, even the `b` variable has a `hello` string, and the `a` variable
    also has the same string defined. When the Java program compiles this, it creates
    one `String` object called `a`, and assigns `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before creating an object for this `hello` string, the `b` variable first
    checks whether there is any `hello` string instance already defined in the `String`
    pool. If it is already defined, it simply refers `a` to the `b` object rather
    than creating one more object separately.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object of the String class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create an object of the `String` class as shown in the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to create a `hello` string, you could simply pass an argument into the
    `String` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `ab` object can now perform all the string manipulations on this `hello`
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another string, called `b`, which also equals to `hello`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, though, there is already one `hello` string created with the `a` object,
    and when the Java compiler comes to the `b` object, it will still create one more
    duplicate `hello` string and assign it to `b`, because here we are explicitly
    forcing it to create an object for this class. Although there is a duplicate already
    present, it will still create an object for this string; however, in defining
    a `String` literal, if the object is already present in the `String` pool, it
    will not create it—instead, it directly refers it to the already created object.
  prefs: []
  type: TYPE_NORMAL
- en: So that's the basic difference between creating a string with the `String` literal
    object and separately creating an object with the `String` class. Ultimately,
    both support `String` methods, but there is some difference between the two methods
    when it comes to defining a string.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between these two methods that we just learned? Both
    strings have access to the `hello` string, but you can see that there is some
    difference between them. If you declare the string in the literal fashion at the
    backend, then Java assigns `hello` to the `a` variable. So this is a more direct
    way of creating a string, rather than using the object creation method.
  prefs: []
  type: TYPE_NORMAL
- en: In most of our regular Java working experience, we would prefer to use the `String`
    literal. We just state that `a` equals `hello`, and that's it. It's just like
    how you define integers. But `String` is a class, and at the backend, it creates
    a separate object for this `hello` string, whereas an integer is just a reference
    data type, so nothing will happen at its backend.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what manipulations we can apply to this `hello` string with the object
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: The String class and its methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the `a` variable, and this variable also acts an object. When we type
    `a.` in the editor, it''ll show all the methods that are present in that `String`
    class, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29781683-a824-484c-b21b-fa1150b48d12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It reads the first character in the strings as index zero, the second character
    as index one, and so on. When working on a program, if you want the character
    present on index two, you can get it simply by using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You print it in the output so that you will see that character. You might be
    wondering why would we need a single character from a string, but the `charAt`
    method is often used. In the next section, we will look at a program that can
    completely reverse the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will just go through an overview of the methods. We saw how to
    get a character that is present at a particular index position. Now let''s try
    reversing this. Say that we have the character present and we need to find the
    index value at which the character is present in the string. We do this by using
    the `indexOf` method, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run this program. You can see that the character `l` is at `2`, `H` is at `0`,
    `e` is at index `1`, and `l` is at index `2`. This is how you can extract characters
    and indexes with the help of the `String` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if I want to pull the string only from the first character to the
    third character? Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We type `a.`, and you can see that there is a `substring`. If you want to pull
    a string that starts at index `3` and ends at index `6`, this means that `j` will
    be at `0`, `a` will be at `1`, and so on. It starts from `2`, and moves on to
    `3`, `4`, and `5`, and it will print something like `vatra`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to pull out `substring` from the entire string, then give the first
    letter index and the last letter index so that our entire string will be printed
    between that first and last letter. Bear in mind that there is another `substring`
    method, and with this method, if you don''t pass the last index, passing only
    the first index, then it prints from index `5` to the last index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print the output and see how the `substring` is extracted. The results
    of this are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b700af8-859e-4349-b4e2-13b364f8e9ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the index of `e` is `-1`, because there is no alphabetical character called
    `e` in this string. Whenever there is nothing, then it prints a `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That sums up `substring`. If I want to `concat` this string with one more string
    called `rahul teaches`, then I do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `javatraining` string that is present in the `a` variable will be concatenated
    with `rahul teaches`, and it prints the output as `javatrainingrahul teaches`.
    We can also use `a.length()`, which will give the maximum length of this string
    starting from zero. There is one more type called `trim`. Let''s say that there
    are some white spaces in your string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first character of the string is a blank space, and is then followed
    by the rest of the characters. If you want to remove that blank space, you can
    do so by simply using `a.trim`. This blank space is removed when you print the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to print all the letters in uppercase, we can use `a.toUpperCase`.
    We can do the same for lowercase by using `a.toLowerCase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more interesting method to look at, which is `split`. Basically,
    we can split the entire string based on our delimiter. For this, we use `a.split()`.
    In this case, we want to split it based on a slash in the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the whole string before the `/` character should be separated
    as one string and the remaining part should be separated as another string. This
    method can not only be used to split across a slash, but can also split across
    whatever we want it to, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to split our string from `t`, then that means that `java` will be
    one string and `raining` will be another string. As we will have two strings,
    our output will store these two strings in an array, and this array return type
    will be, of course, a `String`, because it''s written in a `String`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you want to print the first part of the string, then this will be stored
    in the `0` index of the array system, and if you want to print the second part
    of the string, then it will present it in the `1` index of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final method that we will discuss here is the `replace` method, shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we want to replace the `t` from the string with a random `s`. For this,
    we use `a.replace("t", "s")`, and that's it. On printing this, wherever a `t`
    is present in the string, it will be changed to an `s`, and it will be printed
    in your output.
  prefs: []
  type: TYPE_NORMAL
- en: That's pretty much it for `String` methods. You could still play around with
    them by using `a.` and go through different methods step by step, but these are
    the core methods that we use in our Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to tackle one example based on the methods that we have learned in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing a string's logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's see how we can print a string in reverse. This is one
    of the questions that was asked in the Yahoo interview. Let's create a `reversedemo`
    class for our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a string called `Rahul`, and we want the output to be `luhaR`. There
    is one more concept that we need to be aware of: a palindrome. If you type in
    a string, such as `madam`, and we reverse the string, it would just give `madam`
    as the output. Such types of strings are called **palindromes**. One such instance
    of a palindrome is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We would start by creating a string, called `s`, and an empty string, called
    `t`. We create this empty string to concatenate each element after the `for` loop
    to get the output in the console in the form of a string; otherwise, we may get
    it something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the concatenation logic, we can display the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This was a simple logic that is used to reverse our string and display it in
    the form of a string using the empty string logic. We used the `charAt` method
    and implemented our reverse string. Once we have our reverse string, we can easily
    compare it with the original string—in our case, this involves comparing the `t`
    string with the `s` string, and if they both match, then we can print that the
    given string is a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: Forget about palindromes. This is the concept of string reversal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to strings, which are one of the more important
    classes in Java. We looked at the different ways to define a string. We then looked
    at the different methods that come under the `String` class. We looked at some
    of the most commonly used methods in the `String` class, and in the final section,
    we looked at an example of reversing a string to better understand the `String`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will understand the important loops and conditions through
    examples.
  prefs: []
  type: TYPE_NORMAL
