- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19793_04.xhtml#_idTextAnchor087), we learned about scope and
    conditional statements in Java. Scope determines the visibility of identifiers
    – in other words, where you can use them. Java uses block scope, which is defined
    by curly braces, `{}`. Scopes can be nested but not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed variations of the `if` statement. Each of these statements evaluates
    a boolean condition, resulting in true or false. If true, then that branch is
    executed and no other branch is evaluated. If false, then the next branch is evaluated.
    Unless an else clause is present, it is possible that no branch at all will be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: For complex `if` statements, Java supports the more elegant `switch` structure.
    We examined `switch` statements, with their *fall-through* behavior, and the use
    of the `break` statement. In addition, we discussed `switch` expressions, where
    a value can be returned, and their use of `yield`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand conditional logic, let us examine iteration (looping).
    Looping constructs enable us to repeat statements and/or blocks of code a finite
    number of times while a boolean condition is true or while there are more entries
    in the array/collection. By the end of this chapter, you will be able to use Java’s
    looping constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do-while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced `for` (`for-each`) loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break` and `continue` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch5](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch5).
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important feature of any programming language is the ability to perform an
    action repeatedly. This is known as “looping”. We may want to repeat a piece of
    code a finite number of times or until some condition is met; for example, the
    user typing in a value that signifies that the loop should terminate. In most
    cases, a boolean expression can be used to determine whether the loop continues
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop is one such looping construct. It repeatedly executes a statement
    or a block of code as long as a boolean expression is true. As soon as the boolean
    expression is false, the loop exits, and the next statement after the `while`
    loop executes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The while loop syntax](img/B19793_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The while loop syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we are assuming a block of code, hence the curly braces
    `{}`. You could, of course, omit the curly braces `{}` and the loop will just
    repeatedly execute one statement (which ends with a semi-colon). Interestingly,
    as the boolean expression could be false to begin with, the `while` loop may not
    execute at all. More formally, a `while` loop executes *zero* or more times. Let
    us look at some examples. *Figure 5**.2* presents a simple `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A simple while loop](img/B19793_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – A simple while loop
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 9 in the preceding figure, a local variable, `x`, is initialized to
    `1`. Line 11 evaluates the boolean expression, `x <= 3`. As `x` is `1`, the boolean
    expression is true and the loop executes. Line 12 outputs `"Loop: 1"` and line
    13 increments `x` to `2`. The `}` symbol on line 14 is reached and the loop condition
    (on line 11) is automatically rechecked to see whether it still holds. As `x`
    is `2` and `2 <= 3`, the condition is true and we re-enter the loop. Line 12 outputs
    `"Loop: 2"` and line 13 increments `x` to `3`. The end of the block is reached
    on line 14, and again, the loop continuation expression is re-evaluated. As the
    expression `3 <= 3` is true, the loop is executed again. Line 12 outputs `"Loop:
    3"` and line 13 increments `x` to `4`. Once again, the end of the code block is
    reached and the loop continuation expression is re-evaluated. As `x` is now `4`
    and as `4 <= 3` is false, the loop exits. This is shown by line 15 outputting
    `"Final x value` `is: 4"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if, on line 9, `x` had been initialized to `11` (as opposed to `1`),
    then the initial boolean expression on line 11 would have been evaluated to false
    and the loop would never have been executed at all.
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop can be very useful when you do *not* know how many times the
    loop is going to iterate. For example, the loop continuation expression may be
    predicated on user input. *Figure 5**.3* is one such loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A while loop that ends based on user input](img/B19793_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – A while loop that ends based on user input
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, an algorithm for summing up a sequence of positive,
    user-inputted numbers is presented. The loop will keep going, totaling up the
    numbers entered by the user, until a negative number is entered. This negative
    number is naturally, not part of the total. Let us discuss it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Line 19 declares a local `int` variable, `sum`, and initializes it to `0`. Line
    20 declares a local boolean variable, `keepGoing`, and sets it to true. The boolean
    expression on line 21 evaluates to true (due to line 20) and, as a result, the
    loop block executes. Line 22 declares our `Scanner` reference, `sc`, pointing
    at the keyboard. Line 23 prompts the user to enter a number while informing the
    user that any negative number terminates the loop. Line 24 uses the `Scanner`
    method, `nextInt()`, to get an integer (whole number) from the user. This number
    is stored in the local variable, `n`. Line 25 checks to see whether a negative
    number has been entered. If so, line 26 sets the `keepGoing` flag to false so
    that the loop will not execute again. If a non-negative integer was entered by
    the user, then the number entered, `n`, is added to the running total, `sum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us walk through an example. We will add the following numbers: `1`, `2`,
    and `3`, totaling 6\. This is what the screen output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let us examine what is happening in the code. The loop (line 21) is entered
    because the `keepGoing` boolean was set to true on line 20\. We are then prompted
    for our first number (line 23). We type in `1`, resulting in `n` being initialized
    to `1` on line 24\. As `n` is `1`, the `if` statement on line 25 is false and
    the `else` block (lines 27-29) is executed; setting `sum` to `1` (0 + 1).
  prefs: []
  type: TYPE_NORMAL
- en: The loop block end is reached (line 30) and the loop continuation expression
    is automatically re-evaluated (line 21). As `keepGoing` is still true, the loop
    continues. We are prompted for our second number; we enter `2` and `sum` is changed
    to `3` (1 + 2).
  prefs: []
  type: TYPE_NORMAL
- en: The loop block end is reached again and, as `keepGoing` is still true, the loop
    continues. We are prompted for our next number; we enter `3` and `sum` is changed
    to `6` (3 + 3).
  prefs: []
  type: TYPE_NORMAL
- en: Again, the loop block end is reached and, as `keepGoing` is still true, the
    loop continues. We are prompted for our next number. This time we enter `-1`.
    As `n` is now negative, the `if` statement on line 25 is true and `keepGoing`
    is set to false (line 26). Now, when the loop continuation expression is next
    evaluated, as `keepGoing` is false, the loop exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, line 31 outputs `"Sum of numbers` `is: 6"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the `while` loop, let us examine its close relative,
    the `do-while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: do-while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen with the `while` loop, the boolean loop continuation expression
    is at the start of the loop. Though similar to the `while` loop, the `do-while`
    loop is different in one critical aspect: in the `do-while` loop, the loop continuation
    expression is at the *end* of the loop. Thus, the `do-while` loop is executed
    at least *once*. More formally, a `do-while` loop executes *one* or more times.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.4* presents the syntax of the `do-while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The do-while loop syntax](img/B19793_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The do-while loop syntax
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the preceding figure, the loop continuation expression is
    at the end of the loop, after one loop iteration. Also note the semi-colon, `;`
    after `)`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.5* presents a `do-while` version of the `while` loop in *Figure
    5**.2*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A do-while loop that ends based on user input](img/B19793_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – A do-while loop that ends based on user input
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the only differences with *Figure 5**.2* are lines
    21 and 30\. On line 21, we simply enter the loop as, unlike in the `while` loop,
    there is no condition preventing us from doing so. Line 30 checks to see whether
    it is okay to re-enter the loop. The rest of the code is the same and the execution
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: While (pardon the pun) the two examples given have no material difference in
    the outcome, let us examine a situation where using a `while` loop as opposed
    to a `do-while` loop is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: while versus do-while
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As already stated, a `do-while` loop executes at least once, whereas a `while`
    loop may not execute at all. This can be very useful in certain situations. Let
    us look at one such example. *Figure 5**.6* presents a `while` loop that checks
    to see whether a person is of the legal age to purchase alcohol (which is 18 in
    Ireland).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A while loop to prevent underage purchasing of alcohol](img/B19793_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A while loop to prevent underage purchasing of alcohol
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, line 49 declares the `Scanner` and points it at the
    keyboard so we can get user input. Line 50 prompts the user to enter their age.
    Line 51 takes in the user input and stores it in a local variable, namely `age`.
    Line 52 is important. The condition prevents the loop from being executed with
    an invalid `age`. The loop itself is trivial and simply outputs a message that
    includes the `age` so we can validate that the loop is executing properly.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 57 to 58 are very important in that they enable us to prompt and get a
    new `age` from the user. The code deliberately overwrites the `age` variable.
    If we did not, then `age` would remain as the first value entered by the user
    and we would have an infinite loop. So, the first age is entered before the `while`
    loop is entered and every other age is entered at the end of the loop. This is
    a common pattern in `while` loops. The condition on line 52 prevents any `age`
    inputthat is < 18, from entering the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first run of the code in *Figure 5**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two lines: the prompt and user input, are before the `while` loop
    and, as 21 >= 18, we enter the loop. The message `As you are 21 years of age,
    you can purchase alcohol.` is perfectly correct. The last two lines: repeating
    the prompt and user input, are from the bottom of the loop. We have entered `12`,
    which causes the `while` loop to terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output if, when prompted for the first age, we enter `12`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Importantly, the message about purchasing alcohol does *not* appear.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at the `do-while` version. *Figure 5**.7* presents the `do-while`
    version of the `while` loop in *Figure 5**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – A do-while loop to prevent underage purchasing of alcohol](img/B19793_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – A do-while loop to prevent underage purchasing of alcohol
  prefs: []
  type: TYPE_NORMAL
- en: 'In the interests of having as much of the code as similar as possible, lines
    49 to 51 are untouched. Lines 52 and 59 are all that have changed. The condition
    is now at the end of the loop, after one iteration of the loop. This has implications
    when we start with an age of `12`, as can be seen in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The third line in the output is the issue. Obviously, 12 is too young to buy
    alcohol but the `do-while` loop would require an `if` statement to protect its
    code, whereas the `while` loop provides that protection automatically. Therefore,
    in this example, there is a material advantage in using the `while` loop over
    the `do-while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered `while` and `do-while` loops, let us now discuss `for`
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop comes in two styles: the *traditional* `for` loop and the *enhanced*
    `for` loop. The enhanced `for` loop is also known as the `for-each` loop and is
    specifically designed to work with arrays and collections. We will start by examining
    the traditional `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of `for` loop is extremely useful when you know how many iterations
    you wish to perform beforehand. Its syntax is detailed in *Figure 5**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The traditional for loop](img/B19793_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The traditional for loop
  prefs: []
  type: TYPE_NORMAL
- en: 'The code block in the preceding figure is optional. We could simply control
    one statement, such as `System.out.println("Looping");`, and omit `{}`. The `for`
    header is the section inside `()`. It consists of three parts, delimited by semi-colons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`, `j`, `k`, and so forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` loop and a traditional `for` loop are interchangeable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increment/decrement section**: This is where you increment/decrement your
    loop control variables (declared in the initialization section) so that the loop
    terminates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must understand the order of execution of the loop. In other words, which
    part is executed and when. *Figure 5**.9*, which presents a simple `for` loop,
    will help in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – A simple traditional for loop](img/B19793_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – A simple traditional for loop
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, the order of execution of the code is represented in numerical
    order as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`, is declared and initialized to `1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Boolean expression**: Evaluate the boolean expression to see whether it is
    okay to execute the loop. As 1 <= 3, it is okay to enter the loop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` to the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`i` is incremented (by 1) from `1` to `2` and then execution pops over to the
    boolean expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluate the boolean expression**: As 2 <= 3, the loop is executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2` to the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Increment i from 2 to 3**: and then pop over to the boolean expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluate the boolean expression**: As 3 <= 3, the loop is executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3` to the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Increment i from 3 to 4**: and then pop over to the boolean expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluate the boolean expression**: As 4 is not <= 3, the loop exits.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, the initialization section is executed only once, at the start of
    the loop. The boolean expression is evaluated and, assuming it is true, the loop
    body is executed, followed by the increment/decrement section. The boolean expression
    is again evaluated and, again, assuming it is true, the loop body is executed,
    followed by the increment/decrement section. This repetition of the execution
    of the loop body followed by the increment/decrement section continues until the
    boolean expression fails and the loop exits.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.10* presents a `for` loop that goes from `3` down to `1` in decrements
    of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – A simple for loop that operates in descending order](img/B19793_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – A simple for loop that operates in descending order
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we initialize `i` to `3` and check the boolean expression.
    As 3 >= 1, we enter the loop and output `3`. We then decrement `i` by 1 to `2`
    and check the boolean expression again. As 2 >= 1, we output `2` and then decrement
    `i` to `1`. As the boolean expression is still true; we output `1` and `i` is
    decremented to `0`. At this point, as `i` is `0`, the boolean expression is false
    and the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.11* presents some code samples enabling us to discuss this looping
    construct further.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Additional traditional for loops](img/B19793_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Additional traditional for loops
  prefs: []
  type: TYPE_NORMAL
- en: In the first loop of the preceding figure (lines 20-22), the important thing
    to notice is the `;` symbol, which is just after the `)` symbol of the `for` header.
    This loop controls an empty statement! Even though the indentation may suggest
    otherwise, the block of code that follows has nothing to do with the loop at all,
    and as a result, `"Looping"` appears only once in the output. In effect, the loop
    iterates three times, doing nothing each time. The block of code surrounding line
    21 is not predicated on any condition and just executes once (as normal).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second loop (lines 24-26), the loop control variable, `i`, starts out
    at `10` and goes up in increments of 10 until it reaches `60`, at which point
    the loop terminates. Each valid value of `i` is output to the screen – in other
    words, `10`, `20`, `30`, `40`, and `50`. Note that line 27 does *not* compile,
    as each of the `i` variables declared in the preceding loops only have the scope
    of their individual loop. For example, the `i` variable declared on line 20 is
    only available until line 22; similarly, the `i` variable declared on line 24
    is only available until line 26\. Note: obviously, line 27 must be commented out
    for the code to compile and run.'
  prefs: []
  type: TYPE_NORMAL
- en: The last loop (lines 29-31) shows that we can declare multiple loop control
    variables and use them throughout the loop. In this loop, we declare `i` and `j`
    and initialize them both to `0`. The boolean expression is true as both `i < 1`
    and `j < 1` are true (true && true == true). Thus, we execute the loop and output
    `0` and `0`. Both `i` and `j` are then incremented to `1`. The loop condition
    fails and the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: While arrays will be discussed in detail in [*Chapter 6*](B19793_06.xhtml#_idTextAnchor118),
    `for` loops are such a natural fit for arrays that we have inserted some examples
    here as well. Let us first examine how a traditional `for` loop can be used to
    process an array.
  prefs: []
  type: TYPE_NORMAL
- en: Processing an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any `for` loop is useful for iterating over an array. An array is simply an
    area of memory set aside and given an identifier name for ease of reference. An
    array consists of elements which are organized in consecutive memory locations
    – in other words, the array elements are right beside each other in memory. This
    makes it easy to process arrays using loops.
  prefs: []
  type: TYPE_NORMAL
- en: Each element in an array is accessed by an index. Crucially, array indices start
    at `0` and go up in steps of 1\. Therefore, the last valid index is the size of
    the array minus one. For example, an array of size `5` has valid indices of `0`,
    `1`, `2`, `3`, and `4`. *Figure 5**.12* is a loop processing an array.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Processing an array using a traditional for loop](img/B19793_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Processing an array using a traditional for loop
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 33 declares an `int` array containing the values `1`, `2`,
    and `3` in indices `0`, `1`, and `2`, respectively. The length of the array, accessible
    using the `length` property, is `3`. The `for` loop (lines 34-35) processes the
    array, outputting each location one by one. Thus, when `i` is `0`, `ia[0]` outputs
    `1` to the screen; when `i` is `1`, `ia[1]` outputs `2`, and when `i` is `2`,
    `ia[2]` outputs `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the traditional `for` loop, let us examine the enhanced
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, the enhanced `for` loop, also known as the `for-each` loop,
    is ideal for processing arrays and/or collections. We will discuss collections
    is detail in [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317). For the moment,
    just imagine a collection as a *list* of items. The enhanced `for` loop enables
    you to iterate over the list one element at a time. The syntax of the enhanced
    `for` loop is outlined in *Figure 5**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Enhanced for loop syntax](img/B19793_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Enhanced for loop syntax
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that a variable is declared. The variables
    type matches the type of array/collection. For example, if the array is an array
    of `String`, then `String` is the data type of the variable. The variable name
    is of course, up to us. Again, the code block is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at an example to help explain further. *Figure 5**.14* is an enhanced
    `for` loop version of the traditional `for` loop presented in *Figure 5**.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Processing an array using an enhanced for loop](img/B19793_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Processing an array using an enhanced for loop
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, line 38 reads as follows: *for each int n in (the array) ia*.
    Thus, on the first iteration, `n` is `1`; on the second iteration, `n` is `2`,
    and on the last iteration, `n` is `3`. In the enhanced `for` loop, we do not have
    to keep track of a loop control variable ourselves. While this is useful, be aware
    that you are limited to starting at the beginning of the array/collection and
    progressing one element at a time, until you reach the end. With the traditional
    `for` loop, none of these restrictions apply.'
  prefs: []
  type: TYPE_NORMAL
- en: However, with the traditional `for` loop, if you code the increment/decrement
    section incorrectly, you could end up in an infinite loop. This is not possible
    in the enhanced `for` version.
  prefs: []
  type: TYPE_NORMAL
- en: Nested loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loops can, of course, be nested. In other words, loops can be coded within other
    loops. *Figure 5**.15* presents one such example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Nested for loops](img/B19793_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Nested for loops
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this program is presented in *Figure 5**.16*. In the preceding
    figure, we are representing an array of `int` values, namely `data`, as a histogram
    (represented as a row of stars). The array is declared on line 12\. Line 14 outputs
    a line of text so the output from the program is easier to interpret. The output
    has three columns: the current array index, the value in the `data` array at that
    index, and the histogram. Note that the output is tab-delimited. This is achieved
    by the use of the `\t` escape sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: Escape sequences
  prefs: []
  type: TYPE_NORMAL
- en: 'An escape sequence is a character preceded by a backslash. For example, `\t`
    is a valid escape sequence. When the compiler sees `\`, it peeks ahead at the
    next character and checks to see whether the two characters together form a valid
    escape sequence. Popular escape sequences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\t`: Insert a tab at this point in the text'
  prefs: []
  type: TYPE_NORMAL
- en: '`\b`: Insert a backspace at this point in the text'
  prefs: []
  type: TYPE_NORMAL
- en: '`\n`: Insert a newline at this point in the text'
  prefs: []
  type: TYPE_NORMAL
- en: '`\"`: Insert a double quote at this point in the text'
  prefs: []
  type: TYPE_NORMAL
- en: '`\\`: Insert a backslash at this point in the text'
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be very useful in certain situations. For example, if we wanted to
    output the text *My name is “Alan”* (including the double quotes) to the screen,
    we would say:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println("My name` `is \"Alan\"");`'
  prefs: []
  type: TYPE_NORMAL
- en: If we did not escape the double quote before the `A` in `Alan` (in other words,
    if we tried `System.out.println("My name is "Alan"");`), then the double quote
    before the `A` would have been matched with the first `"` at the start of the
    string. This would have resulted in a compiler error with the `A` in `Alan`.
  prefs: []
  type: TYPE_NORMAL
- en: By escaping the double quote before the `A` in `Alan`, the compiler no longer
    treats that double quote as an end-of-string double quote and instead inserts
    `"` into the string to be output. The same happens to the double quote after the
    `n` in `Alan`–it is also escaped and therefore ignored as an end-of-string double
    quote and inserted into the string to be output. The double quote just before
    the `)` is not escaped however, and is used to match the opening double quote
    for the string, namely the one just after the `(`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outer loop (lines 15-21) loops through the `data` array. As the array has
    4 elements, the valid indices are `0`, `1`, `2`, and `3`. These are the values
    that the `i` loop control variable, declared on line 15, will represent. Line
    16 outputs two of the columns: the current array index and the value at that index
    in the `data` array. For example, when `i` is `0` , `data[0]` is `9`, so `"0\t9\t"`
    is output; when `i` is `1`, `data[1]` is `3`, so `"1\t3\t"` is output, and so
    forth.'
  prefs: []
  type: TYPE_NORMAL
- en: The inner loop (lines 17-19) outputs the actual histogram as a horizontal row
    of stars. The inner loop control variable, `j`, goes from `1` to the value of
    `data[i]`. So, for example, if `i` is `0`, `data[i]` is `9`; therefore, `j` goes
    from `1` to `9`, outputting a star each time. Note that the `print()` method is
    used as opposed to `println()` – this is because `println()` automatically brings
    you on to the next line, whereas `print()` does not. As we want the stars to output
    horizontally, `print()` is exactly what we need. When we have our row of stars
    output, we execute `System.out.println()` (line 20), which brings us on to the
    next line.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.16* represents the output from the code in *Figure 5**.15*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Output from the code in Figure 5.15](img/B19793_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Output from the code in Figure 5.15
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, you can see that the first column is the array index. The second
    column is the value in the `data` array at that index, and the third column is
    the histogram of stars based on the second column. So, for example, when `i` is
    `2`, `data[2]` is `5`, and we output a histogram of `5` stars.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand loops, we will move on to two keywords that are particularly
    relevant to loops, namely `break` and `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: break and continue statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the `break` and `continue` statements can be used in loops but with very
    different semantics. In the code examples presented, nested loops will be used
    to contrast the labeled versions with the non-labeled versions. We will start
    with the `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: break statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already encountered `break` in `switch` statements. When used in a loop,
    the loop exits immediately. *Figure 5**.17* presents nested `for` loops with a
    `break` in the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Showing break inside a loop](img/B19793_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Showing break inside a loop
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the outer loop, controlled by `i`, loops from `1` to `3` in
    steps of 1\. The inner loop, controlled by `j`, loops from `1` to `5` in steps
    of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement on line 16 becomes true when `j` is `3`. At this point,
    the `break` statement on line 17 is executed. A `break` without a label exits
    the nearest enclosing loop. In other words, the `break` on line 17 refers to the
    loop on line 15 (controlled by `j`). As there is no code between the closing `}`
    of both loops (lines 20 and 21), when `break` is executed in this program, the
    next line of code executed is the `}` for the outer loop (line 21). Automatically,
    the next iteration of the outer loop, `i++` (line 14), starts. In effect, there
    is never any `j` value of `3` or higher in the output because, when `j` is `3`,
    we `break` out of the inner loop and start with the next value of `i`. The output
    reflects this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Without any break statement, in other words, if we had commented out lines
    16 to 18, the output would be as follows (note the values of `j` go from 1 to
    5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before we discuss the labeled `break`, we will quickly discuss the label itself.
  prefs: []
  type: TYPE_NORMAL
- en: Label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A label is a case-sensitive identifier followed by a colon that immediately
    precedes the loop being identified. For example, the following code defines a
    valid label, `OUTER`, for the loop controlled by `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now let us look at the labeled `break` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Labeled break
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `break` that uses a label exits the loop identified by that label. The labeled
    `break` statement must be in the scope of the loop identified. In other words,
    you cannot `break` to a loop somewhere else in the code, completely unrelated
    to the current scope. *Figure 5**.18* is closely related to the code in *Figure
    5**.17*, except this time, a label and a labeled `break` are used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Labeled break](img/B19793_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Labeled break
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have labeled, on line 26, the outer loop as `OUTERLOOP`.
    Yes, it took a while to come up with that identifier! Note that it is a compiler
    error to have any code between the label and the loop. That is why line 25 precedes
    the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop control variables, `i` and `j`, behave as before; `i` goes from `1`
    to `3` in steps of 1, and within each step of `i`, `j` goes from `1` to `5` in
    steps of 1\. This time, however, when `j` is `3` in the inner loop, rather than
    breaking out of the inner loop, we are breaking out of the outer loop. After the
    labeled `break` (line 30) is executed, there are no more iterations of `i` and
    the next line executed is `System.out.println("here")` on line 35\. As a result,
    the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, once `j` reaches `3`, the outer loop exits, and `here` is output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at `continue` statements.
  prefs: []
  type: TYPE_NORMAL
- en: continue statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `continue` statement can only occur inside a loop. When executed, `continue`
    says “skip to the *next* iteration” of the loop. Any other statements remaining
    in the current iteration are bypassed. There is a labeled version also. We will
    examine the unlabeled version first. *Figure 5**.19* presents an example of `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – A continue example](img/B19793_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – A continue example
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, the nested loops are the same as before – the outer
    loop iterates from `1` to `3`; within that, the inner loop iterates from `1` to
    `5`. On this occasion, when `j` is `3`, we execute `continue`. What that means
    is that we jump to the end of the loop and the next statement executed is `j++`.
    This means that as line 38 is skipped, j with a value of 3 will never be output.
    The output demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, `j` with a value of `3` is never output. Now, let us examine
    the labeled `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: labeled continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `continue` that uses a label continues the next iteration of the loop identified
    by that label. All other statements are bypassed. As with the labeled `break`,
    the labeled `continue` must be in the scope of the loop identified. *Figure 5**.20*
    is closely related to the code in *Figure 5**.19*, except this time, a label and
    a labeled `continue` are used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – A labeled continue example](img/B19793_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – A labeled continue example
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, line 29 gives the `OUTERLOOP` label to the outer loop starting
    on line 30\. Now, when `j` is `3` and `continue OUTERLOOP` executes, the next
    line to code to execute is `i++`. Thus, every time `j` reaches `3`, we start with
    the next value of `i`. So, there are no values of `j` greater than `2` output,
    as can be seen in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That completes our explanations on the various looping constructs and the `break`
    and `continue` statements used with them. Let us now put that knowledge into practice
    to reinforce the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can iterate, it’s time to do some similar tasks to the chapters
    before but iterate for multiple values!
  prefs: []
  type: TYPE_NORMAL
- en: 'Be creative on how to implement these ones and add context where you need it.
    As always, there’s not one right answer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of our dinosaurs are unique. Okay, we cloned their DNA, but still. Let’s
    say they have unique personalities. That’s why the IDs of all our dinosaurs are
    unique too: they are called `dino1`, `dino2`, `dino3`, and so on. Write a `for`
    loop that prints out the IDs of the first 100 dinosaurs in the park.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of our dinosaurs have large appetites! Write a `do-while` loop that continues
    to feed a dinosaur until it is no longer hungry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We all love the thrill of waiting for the park to open. Use a `while` loop to
    print out a countdown to the park’s opening time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For planning purposes, it’s essential to know the total weight of all dinosaurs
    in a specific enclosure. Write a `for` loop that calculates this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ticket selling can get hectic during the peak season. Write a `while` loop that
    simulates the park’s ticket-selling process until tickets are sold out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security is our topmost priority. Use a `do-while` loop to simulate a security
    check process that continues until all security measures are met.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Dino meal planner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dinosaurs are not easy animals to keep. This is very advanced pet ownership.
    The right nutrition is difficult to manage, but it’s vital to their health and
    well-being. Therefore, you are asked to create a system that can manage the feeding
    schedule of our various dinosaur residents.
  prefs: []
  type: TYPE_NORMAL
- en: The project’s primary goal is to create a program that calculates the meal portions
    and feeding times for each dinosaur. Since we haven’t covered arrays yet, we’ll
    focus on a single dinosaur for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by declaring a variable to hold the current time; let’s say it’s an integer
    and it goes from `0` (midnight) to `23` (last hour of the day).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define variables for each dinosaur species with different feeding times. For
    example, T-Rex could eat at 8 (morning), 14 (afternoon), and 20 (evening), while
    the Brachiosaurus could eat at 7 (morning), 11 (mid-morning), 15 (afternoon),
    and 19 (evening).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, establish a conditional statement (such as an `if-else` block) to check
    whether it’s feeding time for each species, comparing the current time with their
    feeding times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s define the feeding portions for our dinosaurs. We can assume that
    each species requires a different amount of food, depending on their sizes. For
    instance, the T-Rex requires 100 kg of food per meal, while the Brachiosaurus
    requires 250 kg of food per meal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, using an `if-else` block, check which species you are dealing with
    and assign the food portions accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, print the result. For instance, `"It's 8:00 - Feeding time for T-Rex
    with 100kg` `of food"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap all of the preceding information inside a loop that runs from `0` to `23`,
    simulating the 24 hours in a day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On behalf of the hungry dinosaurs in the park: thank you so much for putting
    your Java skills to use!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how Java implements iteration (looping). We started
    with the `while` loop, which, because the condition is at the start of the loop,
    will execute zero or more times. In contrast, the `do-while` loop, where the condition
    is at the end of the loop, will execute one or more times. The `while` and `do-while`
    loops are very useful when you do not know how many times a loop will iterate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the traditional `for` loop is extremely useful when you do know
    how often you want a loop executed. The traditional `for` loop’s header consists
    of three parts: the initialization section, the boolean expression, and the increment/decrement
    section. Thus, we can iterate a discrete number of times. This makes the traditional
    `for` loop ideal for processing arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: The enhanced `for` (`for-each`) loop is even more suitable for processing arrays
    (and collections), provided you are not interested in the current loop iteration
    index. Being concise, succinct, and easy to write, it is a more elegant `for`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: In effect, if you need to loop a specific number of times, use the traditional
    `for` loop. If you need to process an array/collection from the beginning all
    the way through to the end, with no concern for the loop index, use the enhanced
    `for` version.
  prefs: []
  type: TYPE_NORMAL
- en: All loops can, of course, be nested, and we looked at one such example. We defined
    a label as a case-sensitive identifier followed by a colon that immediately precedes
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Nested loops and labels prepared us for our discussion regarding the `break`
    and `continue` keywords. Where `break` can also be used in a `switch` statement,
    `continue` can only be used inside loops. There are labeled and non-labeled versions
    of both. Regarding `break`, the unlabeled version exits the current loop, whereas
    the labeled version exits the identified loop. With regard to `continue`, the
    unlabeled version continues with the next iteration of the current loop, whereas
    the labeled version continues with the next iteration of the identified loop.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on iteration. In this chapter, we touched upon
    arrays. Moving on to our next chapter, [*Chapter 6*](B19793_06.xhtml#_idTextAnchor118),
    we will cover arrays in detail.
  prefs: []
  type: TYPE_NORMAL
