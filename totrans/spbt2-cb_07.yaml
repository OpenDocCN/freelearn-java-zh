- en: Health Monitoring and Data Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom health indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring management context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emitting metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring Spring Boot via JMX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Spring Boot via SSHd Shell and writing custom remote Shell commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Micrometer metrics with Graphite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Micrometer metrics with Dashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned a few techniques to efficiently package
    and get the application ready for deployment and we looked at a number of techniques
    to provide an environmental configuration without changing the code. With the
    deployment and configuration woes behind us, the last (but not least) important
    step remains—ensuring that we have complete visibility, monitoring, and management
    control of our application, as it is running in the production environment and
    is exposed to the harsh environment of customers' (ab)use.
  prefs: []
  type: TYPE_NORMAL
- en: Just as airline pilots don't like to fly blind, developers don't get excited
    if they can't see how their beloved application, that they worked hard on, performs
    in production. We want to know, at any given time, what the CPU utilization is
    like, how much memory we are consuming, whether our connection to the database
    is up and available, the number of customers who use the system in any given time
    interval, and so on. Not only do we want to know all these things, but we also
    want to be able to see it in pretty charts, graphs, and visual dashboards. These
    come in very handy to put on the big Plasma displays for monitoring as well as
    impressing your boss, so as to show that you are on the top of things and have
    it all under control.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you learn the necessary techniques to enhance our application
    in order to expose custom metrics, health statuses, and so on, as well as how
    to get the monitoring data out of our application and either store it in Graphite
    for historical reference or use this data to create real-time monitoring dashboards
    using the Dashing and Grafana frameworks. We will also take a look at the capability
    to connect to running instances and perform various management tasks using the
    powerful CRaSH framework integration.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom health indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing the state of the application that is running in production, especially
    in a large-scale distributed system, is just as (if not more) important as having
    things such as automated testing and deployment. In today's fast-paced IT world,
    we can't really afford much downtime, so we need to have the information about
    the health of the application at our fingertips, ready to go at a minute's notice.
    If the all-so-important database connections go down, we want to see it right
    away and be able to quickly remedy the situation; the customers are not going
    to be waiting around for long before they go to another site.
  prefs: []
  type: TYPE_NORMAL
- en: We will resume working on our `BookPub` application in the state in which we
    left it in the previous chapter. In this recipe, we will add the necessary Spring
    Boot starters to enable the monitoring and instrumentation of our application
    and will even write our own health indicator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is add a dependency to the Spring Boot Actuator
    starter in our `build.gradle` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding this dependency alone already gives us the ability to access the Spring
    management `/actuator/*` endpoints, such as `/env`, `/info`, `/metrics`, and `/health`,
    (though they are disabled by default, unless a `management.endpoints.web.exposure.include=*`
    property is configured in the `application.properties` file). So, let''s start
    our application by executing the `./gradlew clean bootRun` command line and then
    we can access the newly available `/health` endpoint by opening our browser and
    going to `http://localhost:8080/actuator/health` so as to see the new endpoint
    in action, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fed372cf-11a0-4774-8904-4d532e658b25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get more details about the health state of our application, let''s configure
    it to show the detailed health output by adding the `management.endpoint.health.show-details=always`
    property to the `application.properties` file and then restarting our application.
    Now, when we go to `http://localhost:8080/actuator/health` in the browser, we
    should see something similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbf41ff6-7cba-4f01-b691-c33a8e068754.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the `actuator` dependency added, and detailed `/health` endpoint configured,
    we can now add and perform all kinds of monitoring functions on our application.
    Let''s go ahead and populate the `/info` endpoint with some data by adding a directive
    to the `build.gradle` file located at the root of our project with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a new properties file named `gradle.properties` in the
    root directory of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will also add `rootProject.name='BookPub-ch7'` to the `settings.gradle` file
    located in the root directory of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s start our application by executing `./gradlew clean bootRun` and
    then we can access the newly available `/info` endpoint by opening our browser
    and going to `http://localhost:8080/actuator/info` to see the new endpoint in
    action, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a847adf-f02e-454c-9e45-901943fd86fd.png)'
  prefs: []
  type: TYPE_IMG
- en: As we have got the hang of how things work, let's go ahead and make our custom
    health indicator, which will be accessible via the `/health` endpoint in order
    to report the count status of the entries for each of our repositories. If they
    are greater than or equal to zero, we are `UP`, otherwise we are not really sure
    what's going on. Obviously, if an exception has occurred, we would be reporting
    `DOWN`. Let's start by relaxing the `getRepositoryName(...)` method visibility
    from `private` to `protected` in the `DbCountRunner.java` file located in the
    `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount` directory
    at the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will add the same dependency to the `compile("org.springframework.boot:spring-boot-starter-actuator")`
    library in the `build.gradle` file in the `db-count-starter` directory at the
    root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will create a new file named `DbCountHealthIndicator.java` in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will modify the `@Import` annotation in the `EnableDbCounting.java`
    file located in the `db-count starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the automatic registration of our `HealthIndicator` class, we
    will enhance the `DbCountAutoConfiguration.java` file located in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s start our application by executing the `./gradlew clean bootRun`
    command line, and then we can access the `/health` endpoint by opening our browser
    and going to `http://localhost:8080/actuator/health` to see our new `HealthIndicator`
    class in action, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ddc9b6d-b0f2-4080-a5d3-96b34cd5486f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Boot Actuator starter adds a number of important features that give
    insight into the runtime state of the application. The library contains a number
    of autoconfigurations that add and configure the various endpoints to access the
    runtime monitoring data and health of the application. Those endpoints all share
    a common context path: `/actuator`. To expose any other endpoints besides `/info`
    and `/health`, we need to explicitly expose them by setting the `management.endpoints.web.exposure.include=*`
    property. When the value is set to `*`, it will expose all of the endpoints. The
    following endpoints are available to aid us in getting an insight into the application
    runtime state and configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/env`: This endpoint enables us to query the application about all of the
    environment variables that the application has access to via the environment implementation,
    which we have seen earlier. It is very useful when you need to debug a particular
    issue and want to know a value of any given configuration property. If we access
    the endpoint by going to `http://localhost:8080/actuator/env`, we will see a number
    of different configuration sections, for example, the class path resource `[tomcat.https.properties]`,
    `applicationConfig: [classpath:/application.properties]`, `commonsConfig`, `systemEnvironment`,
    `systemProperties`, and others. They all represent an instance of an individual
    `PropertySource` implementation that is available in the environment and depending
    on their place in the hierarchy, may or may not be used to provide the value resolution
    at the runtime. To find out exactly which entry is used to resolve a particular
    value, for example, for the `book.count.rate` property, we can query it by going
    to the `http://localhost:8080/actuator/env/book.counter.rate` URL. By default,
    we should get 10,000 as a result unless, of course, a different value was set
    via the system environment or command-line arguments as an override. If you really
    want to dig deep into the code, the `EnvironmentEndpoint` class is responsible
    for handling the logic behind this capability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/configprops`: This endpoint provides you with an insight into the settings
    of the various configuration property objects, such as our `WebConfiguration.TomcatSslConnectorProperties` starter.
    It is slightly different from the `/env` endpoint as it provides insight into
    the configuration object bindings. If we open the browser to go to `http://localhost:8080/actuator/configprops`
    and search for `custom.tomcat.https`, we will see the entry for our configuration
    property object that we will use to configure `TomcatSslConnector`, which was
    automatically populated and bound for us by Spring Boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/conditions`: This endpoint serves as a web-based analog to the AutoConfiguration
    Report, which we saw in [Chapter 4](6139967b-794e-479a-8461-d3197eb0322e.xhtml),
    *Writing Custom Spring Boot Starters*. This way, we can get the report using the
    browser at any time without having to start the application with the specific
    flags to get it printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/beans`: This endpoint is designed to list all the beans that have been created
    by Spring Boot and are available in application context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mappings`: This endpoint exposes a list of all the URL mappings that are
    supported by the application as well as a reference to the `HandlerMapping` bean
    implementation. This is very useful for answering the question of where would
    a specific URL get routed to. Try going to `http://localhost:8080/actuator/mappings`
    to see the list of all the routes that our application can handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/threaddump`: This endpoint allows extraction of the Thread Dump information
    from the running application. It is rather useful when trying to diagnose a potential
    thread deadlock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/heapdump`: This endpoint is similar to `/dump` with the exception that it
    produces Heap Dump information instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/info`: This endpoint shows the basic description and application information
    that we added and we''ve seen this in action, so it should be familiar to us as
    of now. The nice support in the build tools gives us the ability to configure
    additional or replace existing values inside our `build.gradle` configuration,
    which would then be propagated to be consumed by the `/info` endpoint. Additionally,
    any properties defined in the `application.properties` file, that start with `info.`
    will be displayed while accessing the `/info` endpoint, so you are definitely
    not limited to only the `build.gradle` configuration. Configuring this specific
    endpoint in order to return the relevant information can be very helpful when
    building various automated discovery and monitoring tools as it is a great way
    to expose application-specific information in the form of a nice JSON RESTful
    API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/actuator`: This endpoint gives a nice JSON-formatted list of links in a **Hypertext
    Application Language** (**HAL**) style for all the available actuator endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/health`: This endpoint provides information about the general application
    health status as well as a detailed breakdown and health status of the individual
    components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/metrics`: This endpoint gives an overview of all the various data points
    that are emitted by the metrics subsystem. You can experiment with it by accessing
    it via the `http://localhost:8080/actuator/metrics` URL in the browser. We will
    cover this in more detail in the next recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know in general what is being provided for us by Spring Boot Actuator,
    we can move on to take a look at the details of what we did to get our custom
    `HealthIndicator` class working and how the whole health monitoring subsystem
    in Spring Boot functions.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw, getting the basic `HealthIndicator` interface to work is very easy;
    all we have to do is create an implementing class that will return a `Health`
    object upon a call to the `health()` method. All you have to do is expose the
    instance of the `HealthIndicator` class as `@Bean` for Spring Boot to pick it
    up and add it to the `/health` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we went a step further because we had to deal with the need to
    create `HealthIndicator` for each `CrudRepository` instance. To accomplish this,
    we created an instance of `CompositeHealthIndicator` to which we added all the
    instances of `DbHealthIndicator` for each `CrudRepository`. We then returned this
    as `@Bean` and this is what was used by Spring Boot to represent the health status.
    Being a composite, it preserved the inner hierarchy as is evident from the returned
    JSON data representing the health status. We also added some extra data element
    to provide the indication of the entry count as well as the name of each particular
    repository so that we can tell them apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the code, you are probably wondering: what is this `HealthAggregator`
    instance that we''ve wired in? The reason that we needed a `HealthAggregator`
    instance is because `CompositeHealthIndicator` needs to know how to decide if
    the inner composition of all the nested `HeathIndicators` represents good or bad
    health as a whole. Imagine that all the repositories, but one, return `UP` but
    one is `DOWN`. What does this mean? Is the composite indicator healthy as a whole
    or should it also report `DOWN` because one inner repository has issues?'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring Boot already creates and uses an instance of `HealthAggregator`,
    so we just autowired it and used it in our use case as well. We did have to explicitly
    add the import of the `HealthIndicatorAutoConfiguration` and `MetricsDropwizardAutoConfiguration`
    classes in order to satisfy the bean dependency during slice tests for `DataJpaTest`
    and `WebMvcTest`, since those only partially instantiate the context, and the
    actuator autoconfigurations are missing.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the default implementation is an instance of `OrderedHealthAggregator`,
    which just collects all the inner status responses and chooses the lowest on the
    priority level out of `DOWN`, `OUT_OF_SERVICE`, `UP`, and `UNKNOWN`, it doesn't
    always have to be that way. For example, if the composite indicator consists of
    the indicators for redundant service connections, your combined result could be
    `UP` as long as at least one of the connections is healthy. Creating a custom
    `HealthAggregator` interface is very easy; all you have to do is either extend
    `AbstractHealthAggregator` or implement a `HealthAggregator` interface itself.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring management context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot Actuator out of the box creates a set of management endpoints and
    the supporting beans in the main application context and those endpoints are available
    on the `server.port` configured HTTP port. There are, however, cases where for
    security or isolation reasons we would want to separate the main application context
    from the management one or expose the management endpoints on a different port
    than the main application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides us with an ability to configure a separate child application
    context for the management beans, which would inherit everything from the main
    application context, but allow for defining beans that are only available for
    the management functions as well. The same goes for exposing the endpoints on
    a different port or even using different connector security in such a way that
    the main application could be using SSL, but the management endpoints are accessible
    using plain HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that, for whatever reason, we want to change our JSON converter
    to output field names using `SNAKE_CASE` (all lowercase letters separating words
    with an underscore).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a class holding our configuration for the management context
    named `ManagementConfiguration.java` located in the `src/main/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add this class to `spring.factories` located in the `src/main/resources/META-INF`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid our configuration being detected by the component scan for the main
    application context, we need to exclude it by adding the following to `BookPubApplication.java`
    located in the `src/main/java/com/example/bookpub` directory at the root of our
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To have a separate management context, we need to launch it using a different
    port, so let''s amend `application.properties` located in the `src/main/resources`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's start our application by executing `./gradlew clean bootRun`
    and then we can access the `/threaddump` endpoint by opening our browser and going
    to `http://localhost:8081/actuator/threaddump` to see our new configuration take
    place. The field names of the returned JSON should all be in lowercase and words
    should be separated using an underscore, or in `SNAKE_CASE`, as it is called.
    Alternatively, by going to the `http://localhost:8080/books/978-1-78528-415-1`
    endpoint, we should continue seeing JSON field names in the `LOWER_CAMEL_CASE`
    format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot recognizes that there are many reasons and it needs to be able to
    provide separate configuration for the way management endpoints and other actuator
    components work, which is different from the main application. The first level
    of such configurations can be achieved by setting the myriad of available properties
    that intuitively start with `management.*`. We have used one such property, `management.server.port`,
    to set the port for the management interface to be `8081`. We could also set things
    like the SSL configuration, security settings, or network IP interface address
    to bind the listener to. We also have the capability to configure each individual
    `actuator` endpoint by setting their corresponding properties, which start with
    `management.endpoint.<name>.*` and have a variety of settings, depending on the
    specific endpoint goals.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, the data that is exposed by the various management endpoints,
    especially the ones from sensitive ones such as `/health`, `/env`, and others
    can be very lucrative for malicious people on the outside. To prevent this from
    happening, Spring Boot provides us with the ability to configure if we want the
    endpoints to be available via `management.endpoint.<name>.enabled=false`. We can
    specify which individual endpoints we want to disable by setting an appropriate
    `management.endpoint<name>.enabled=false` property as well, or using `management.endpoints.web.exposure.exclude=<name>`
    to tell Spring Boot if this endpoint should be enabled, but not exposed via the
    WEB HTTP API method of access.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can set `management.server.port=-1` to disable the HTTP exposure
    of these endpoints or use a different port number in order to have the management
    endpoints and live services on different ports. If we want to enable access only via
    a localhost, we can achieve this by configuring `management.server.address=127.0.0.1`
    to prevent external access. Even the context URL path can be configured to something
    else, say `/admin`, via `management.server.context-path=/admin`. This way, to
    get access to a `/health` endpoint, we would go to `http://127.0.0.1/admin/health`
    instead of the default `/actuator` context path. This can be useful if you want
    to control and restrict access via the firewall rules, so you can just add a filter
    to block external access to anything, `/admin/*`, for all the applications from
    the outside. With the addition of Spring Security, an authentication can also
    be configured to require a user login to get access to the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In situations when controlling behavior using properties is not enough, Spring
    Boot provides a mechanism to provide alternative application context configuration
    via the use of `spring.factories` and the accompanying `ManagementContextConfiguration`
    annotation. This enables us to tell Spring Boot which configurations should be
    automatically loaded when management context is being created. The intended use
    of this annotation is to have the configuration live in a separate, sharable dependency
    library, outside of the main application's code.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, because we put it in the same codebase (for simplicity), we
    had to do an extra step and define the exclusion filter in the `BookPubApplication.java`
    file to exclude the `ManagementContextConfiguration` classes from component scan
    when setting up the main application. The reason we had to do that is simple—if
    we look inside the `ManagementContextConfiguration` annotation definition, we
    will see that it is a meta-annotation with the `@Configuration` annotation inside
    it. What this means is that when our main application is being configured, the
    component scan will automatically detect all the classes in the classpath tree
    of the application code that are annotated with `@Configuration`, and as such,
    it will put all the configurations marked with `ManagementContextConfiguration`
    in the main context as well. We have avoided that using the exclusion filter.
    Alternatively, a better way is to have those configurations in a separate library
    using a different package hierarchy, which would prevent the component scan picking
    them up, but the autoconfiguration will still works because of the `spring.factories`
    entry for `org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration`
    telling Spring Boot to automatically add those configurations to the management
    context.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have the management context separate from the main application,
    it is necessary to configure it to run on a separate port using the `management.server.port`
    property. Without this setting, all of the objects will be using shared application
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe gave an overview of the capabilities provided by Spring
    Boot Actuators. We played with different management endpoints such as `/info` and `/health` and
    even created our own health metrics to add to the default set. However, besides
    the health status, there are a number of things that we, as developers and operations
    folks, want to be able to see and monitor on an ongoing basis, and just knowing
    that the uplink is functional is not good enough. We would also like to see the
    number of open sessions, concurrent requests to the application, latency, and
    so on. In this recipe, you will learn about the metric reporting facilities in
    Spring Boot as well as how to add our own metrics and some quick and simple ways
    of visualizing them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help us visualize the metrics better, we will use a great open source project,
    `spring-boot-admin`, located at [https://github.com/codecentric/spring-boot-admin](https://github.com/codecentric/spring-boot-admin).
    It provides a simple web UI on top of the Spring Boot Actuators to give a nicer
    view of the various data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a simple admin application in Gradle using the instructions
    from [https://github.com/codecentric/spring-boot-admin#server-application](https://github.com/codecentric/spring-boot-admin#server-application) by
    performing the following simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [start.spring.io](http://start.spring.io) and create a new application
    template with the following fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generate a: Gradle Project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Boot: 2.0.0 (SNAPSHOT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Group: `org.sample.admin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Artifact: `spring-boot-admin-web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: `Spring Boot Admin Web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: `Spring Boot Admin Web Application`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package Name: `org.sample.admin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Version: 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the Actuator option under Search for dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Generate Project alt + to download the application template archive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the contents from the directory of your choice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the extracted directory, execute the `gradle wrapper` command line to generate
    a gradlew script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `build.gradle` file, add the following dependencies to the `dependencies`
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update the `repositories` block with a reference to use the
    `snapshots` repository (as the time of writing, the SBA is not yet released):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `SpringBootAdminWebApplication.java` file located in the `src/main/java/spring-boot-admin-web`
    directory and add the following annotations to the `SpringBootAdminWebApplication`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `application.properties` file located in the `src/main/resources`
    directory and add the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to start our Admin Web Console by running `./gradlew bootRun`
    and open the browser to `http://localhost:8090` to see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3cbd2f7b-868f-499d-95a3-4cdf96c0e1af.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the **Admin Web** up and running, we are now ready to start adding various
    metrics to our `BookPub` application. Let''s expose the same information about
    our data repositories as we did in `HealthIndicators`, but this time, we will
    expose the counts data as a metric. We will continue to add code to our `db-count-starter`
    subproject. So, let''s create a new file named `DbCountMetrics.java` in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, for the automatic registration of `DbCountMetrics`, we will enhance `DbCountAutoConfiguration.java`
    located in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for the Thread Dump to properly display in the Spring Boot Admin UI,
    we need to change our JSON converter from `SNAKE_CASE` to `LOWER_CAMEL_CASE` by
    changing `ManagementConfiguration.java` located in the `src/main/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s start our application by executing `./gradlew clean bootRun` and
    then we can access the `/metrics` endpoint by opening our browser and going to
    `http://localhost:8081/actuator/metrics` to see our new `DbCountMetrics` class
    added to the existing metrics list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/939b9e18-ff5c-4881-bfe7-16e7b8b5e968.png)'
  prefs: []
  type: TYPE_IMG
- en: Our next step would be to get our application to appear in the Spring Boot Admin
    Web, which we created earlier. To make this happen, we will need to add a dependency
    on the `compile("de.codecentric:spring-boot-admin-starter-client:2.0.0-SNAPSHOT")`
    library to `build.gradle` in the directory at the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Additionally, `application.properties` located in the `src/main/resources`
    directory in the root of our project needs to be enhanced with the following entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, let''s start our application by executing `./gradlew clean bootRun`,
    and if we now go to Spring Boot Admin Web by directing our browser to `http://localhost:8090`,
    we should see a new entry for our application named `BookPub Catalog Application`
    appear in the list. If we click on the Details button on the right-hand side and
    scroll down to the Health section, we will see our custom health indicators along
    with the others reported in a form of nicer looking hierarchical entries in a
    table, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a78eec07-1892-49b9-a071-d877d0628db6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few words about Spring Boot Admin Web before we delve into the details of
    creating and emitting metrics. It is a simple web GUI that, in the backend, uses
    the same endpoints exposed by Spring Boot Actuator, which we learned about in
    the previous recipe. The data is extracted from the application as we click on
    the various links in Admin Web and displayed in a nice graphical way—no magic!
  prefs: []
  type: TYPE_NORMAL
- en: 'We only had to configure a few properties in addition to adding the client
    library dependency in order to get our application to connect and register with
    Admin Web:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.application.name=BookPub Catalog Application`: This configures the
    name of the application that we have chosen to use. It is also possible to take
    the value from the description property defined in `gradle.properties` using the
    resource processing task in Gradle. Admin Web uses this value when displaying
    the application list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.boot.admin.client.url=http://localhost:8090`: This configures the location
    of the Admin Web application so that our application knows where to go in order
    to register itself. As we are running on port `8080`, we chose to configure Admin
    Web to listen on port `8090`, but any port can be chosen as desired. You can see
    more configuration options by visiting [https://codecentric.github.io/spring-boot-admin/current/](https://codecentric.github.io/spring-boot-admin/current/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we also want to enable the logging level control through the UI, we will
    need to add a Jolokia JMX library to our `compile("org.jolokia:jolokia-core:+")` build
    dependency as well as a `logback.xml` file in the `src/main/resources` directory
    in the root of the project with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The metrics facility in Spring Boot is very powerful and extendable, offering
    a number of different approaches for emitting and consuming metrics. Starting
    with Spring Boot 2.0, the `Micrometer.io` library is being used under the hood
    to provide a very comprehensive monitoring solution. Out of the box, Spring Boot
    already configures a number of data metrics that monitor the system resources,
    such as heap memory, thread counts, system uptime, and many others as well as
    the database usage and HTTP session counts. The MVC endpoints are also instrumented
    to gauge the request latency, which is measured in milliseconds, as well as a
    counter for each endpoint request status.
  prefs: []
  type: TYPE_NORMAL
- en: Various metrics, such as gauges, counters, timers, and so on, are emitted via
    the `MeterRegistry` implementation that is provided by Spring Boot at runtime.
    The registry can be easily autowired into any Spring-managed object and be used
    to emit metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can easily count the number of times a particular method gets
    invoked. All we need to do is to autowire an instance of `MeterRegistry` into
    our object during creation, and place the following line at the beginning of the
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Each time the method gets called, the particular metric count will be incremented.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach will give us the counts that we can increment, but if we want
    to measure latency or any other arbitrary value, we will need to use `Gauge` to
    submit our metrics. To measure how long it will take for our method to execute,
    we can use `MeterRegistry` and at the beginning of the method, record the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then place our code and before the return, capture the time again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will emit the metric `meterRegistry.gauge("objectName.methodName.latency",
    end - start);`, which will update the last. The use of `gauge` for timing purposes
    is very rudimentary and `MeterRegistry` actually provides a specialized type of
    meter—Timer. The Timer meter, for example, provides the ability to wrap runnable
    or callable lambdas and automatically time the execution. Another benefit of using
    a Timer instead of `Gauge` is that a Timer meter keeps both the event counts as
    well as the latency it took to execute each occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: The `MeterRegistry` implementation covers most of the simple use cases and is
    very handy when we operate in our own code and have the flexibility to add them
    where we need to. However, it is not always the case, and in these cases, we will
    need to resort to wrapping whatever it is we want to monitor by creating a custom
    implementation of `MeterBinder`. In our case, we will use it to expose the counts
    for each of the repositories in the database as we can't insert any monitoring
    code into the `CrudRepository` proxy implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever the `MeterRegistry` implementation does not provide enough flexibility,
    for example, when there is a need to wrap an object in a meter like `Gauge`, most
    meter implementations provide fluid builders to gain more flexibility. In our
    example, to wrap the repository metrics, we used a `Gauge` fluid builder to construct
    `Gauge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The main builder method takes the following three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`metricName`: This specifies the name to use to uniquely identify this metric'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repository`: This provides an object on which we invoke the method that should
    return a numeric value that `gauge` will report'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CrudRepository::count`: This is the method that should be called on the `repository`
    object to get the current count of entries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enables us to build flexible wrappers because all we have to do is provide
    an object that would expose the necessary numeric value and a function reference
    to a function that should be called on the instance to get that value during the `gauge`
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: The `MeterBinder` interface, used to export the Meter, has only one method defined,
  prefs: []
  type: TYPE_NORMAL
- en: '`void bindTo(MeterRegistry);`, which the implementer needs to code with the
    definition of what exactly is being monitored. The implementation class needs
    to be exposed as `@Bean`, and it will automatically be picked up and processed
    during the application initialization. Assuming that one actually registered the
    created `Meter` instance with the provided `MeterRegistry` implementation, typically
    by terminating the fluid builder''s chain by calling `.builder(...).register(registry)`,
    the metrics will be exposed via `MetricsEndpoint`, which will expose all the meters
    registered with the registry every time the `/metrics` actuator is called.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that we have created the `MeterBinder` and `HealthIndicator`
    beans inside the main application context and not in the management one. The reason
    being that even though the data is being exposed via the management endpoints,
    the endpoint beans, such as `MetricsEndpoint`, get defined in the main application
    context, and thus expect all the other autowired dependencies to be defined there
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is safe because in order to get access to the information, one
    needs to go through the `WebMvcEndpointHandlerMapping` implementation facade,
    which is created in the management context and use the delegate endpoint from
    the main application context. Take a look at the `MetricsEndpoint` class and the
    corresponding `@Endpoint` annotation to see the details.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Spring Boot via JMX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's day and age, the RESTful HTTP JSON services are a de facto way of
    accessing data, but this is not the only way to do so. Another fairly popular
    and common way of managing systems in real time is via JMX. The good news is that
    Spring Boot already comes with the same level of support to expose the management
    endpoints over JMX as it does over HTTP. Actually, these are exactly the same
    endpoints; they are just wrapped around the MBean container.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at how to retrieve the same information
    via JMX as we did via HTTP as well as how to expose some MBeans, which are provided
    by third-party libraries through HTTP using the Jolokia JMX library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't done so already for the previous recipe, then add the Jolokia
    JMX library to our `compile("org.jolokia:jolokia-core:+")` build dependency and
    add the `management.jolokia.enabled=true` property to `application.properties`,
    as we will need them to expose MBeans via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we add the Jolokia JMX dependency, all we need to do is build and start
    our application by executing `./gradlew clean bootRun` and now we can simply launch
    jConsole to see the the various endpoints exposed under the `org.springframework.boot`
    domain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45a84151-7fc1-4cfb-804e-49e48dfa700c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having the Jolokia JMX library added to the classpath, Spring Boot also enables
    the accessing of all the registered MBeans via HTTP API using the `/jolokia` endpoint.
    To find out the `maxThreads` setting for our Tomcat HTTP port `8080` connector,
    we can either look it up using jConsole by selecting the `maxThreads` attribute
    on the `Tomcat:type=ThreadPool,name="http-nio-8080"` MBean to get the value of
    `200` or we can use Jolokia JMX HTTP by opening our browser and going to `http://localhost:8081/actuator/jolokia/read/Tomcat:type=ThreadPool,name=%22http-nio-8080%22/maxThreads`
    and we should see the following JSON response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the Spring Boot Actuator, when added to the application, comes with
    all the endpoints and management services enabled. This includes the JMX access
    as well. If, for some reason, one would like to disable the exposure of a particular
    endpoint via JMX, this can easily be configured by adding `management.endpoints.jmx.exclude=<id>`
    or in order to disable the exporting of all the Spring MBeans, we can configure
    the `spring.jmx.enabled=false` setting in `application.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of the Jolokia library in the classpath triggers Spring Boot `JolokiaManagementContextConfiguration`,
    which would automatically configure `ServletRegistrationBean` accepting requests
    on the `/jolokia` actuator path. It is also possible to set various Jolokia-specific
    configuration options via the `management.endpoint.jolokia.config.*` set of properties.
    A complete list is available at [https://jolokia.org/reference/html/agents.html#agent-war-init-params](https://jolokia.org/reference/html/agents.html#agent-war-init-params).
    In case you would like to use Jolokia, but want to manually set it up, we can
    tell Spring Boot to ignore its presence by configuring a `management.endpoint.jolokia.enabled=false`
    property setting in `application.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Spring Boot via SSHd Shell and writing custom remote Shell commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you are probably reminiscing about the good old days where all the administration
    was done via SSH directly on the machine, where one has complete flexibility and
    control, or even using SSH to connect to a management port and apply whatever
    changes were needed directly to a running application. Even though Spring Boot
    has removed native integration with the CRaSH Java Shell in version 2.0, there
    is an open source project, `sshd-shell-spring-boot`, which brings back that ability.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will use the health indicator and management endpoint, which
    we created earlier in this chapter. We will expose the same capabilities via the
    SSH console access.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to getting SSHd Shell to work is to add the necessary dependency
    starters to our `build.gradle` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to explicitly enable it by setting the following property in `application.properties`,
    located in the `src/main/resources` directory in the root of our project it needs
    to be enhanced with the following entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's start our application by executing `./gradlew clean bootRun` and
    then connect to it via SSH by executing `ssh -p 8022 admin@localhost`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will be prompted for a password so let''s find the autogenerated hash key
    in the application startup log, which would look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If the password is entered correctly, we will be greeted by the following welcome
    prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will invoke our existing `/health` endpoint by typing health and we
    should get the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Typing `help` will show the list of all the existing commands so you can play
    with some of them to see what they do and then we will proceed with adding our
    own SSHd Shell command, which will enable us to add new publishers to the system
    via the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new directory named commands in `src/main/java/com/example/bookpub/command`
    at the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a file named `Publishers.java` in the `src/main/java/com/example/bookpub/command`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the commands built up, now let's start our application by executing `./gradlew
    clean bootRun` and then connect to it via SSH by executing `ssh -p 8022 admin@localhost`
    and log in using the generated password hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we type publishers, we will see the list of all the possible commands,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a publisher by typing `publishers add Fictitious Books` and we should
    see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we will now type publishers list, we will get a list of all the books:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Removing a publisher is a simple command `publishers remove 2` that should respond
    with the `"Removed publisher 2"` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just to confirm that the publisher is really gone, execute publishers list
    and we should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SSHd Shell integration with Spring Boot provides you with many commands
    out of the box. We can invoke the same management end points that were available
    to us over HTTP and JMX. We can get access to the JVM information, make changes
    to the logging configuration, and even interact with the JMX server and all the
    registered MBeans. The list of all the possibilities is really impressive and
    very rich in functionalities, so I would definitely advise you to read the reference
    documentation on SSHd Shell by going to [https://github.com/anand1st/sshd-shell-spring-boot](https://github.com/anand1st/sshd-shell-spring-boot).
  prefs: []
  type: TYPE_NORMAL
- en: In Spring Boot, the expectation is that any class annotated with `@SshdShellCommand`
    will be automatically picked up and registered as an SSHd Shell command. The value
    of the annotation attribute translates into the main command name. In our case,
    we set the class annotation attribute value field to `publishers` and this became
    the top-level command name in the SSH Shell console.
  prefs: []
  type: TYPE_NORMAL
- en: If the command contains sub-commands, as in our publishers command example,
    then, the methods of the class that are also annotated with `@SshdShellCommand`
    get registered as sub-commands to the main command. If a class has only one method,
    it will automatically become the only command for a given class that would be
    executed when the command name is typed. If we want multiple sub-commands to reside
    in the class command, as we did with publishers, each method that translates into
    a command needs to be annotated with `@SshdShellCommand`.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, SSHd Shell framework has a limitation of being able to pass only
    one attribute argument to the command, but there is work going on to expand on
    that capability. In the mean time, it is recommended that JSON payload is used
    to communicate with the commands as inputs or outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attributes are available on the annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: This attribute defines the command or sub-command name. Even though
    the name of the method does not need to match the name of the command, it is a
    good convention for keeping the two in sync to make the code more readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This attribute defines the text that gets displayed when the `help`
    command is invoked. It is a good place to communicate with the users how the command
    is expected to be used, what inputs it takes, and so on. It is a good idea to
    provide as much description and documentation as possible as in the Shell, one
    would like to clearly educate the users of what needs to happen and how to call
    the command. The man pages are great so keep the documentation top notch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roles`: This attribute enables us to define a security constraint on who is
    allowed to execute the given command. If Spring Security is also used, SSHd Shell
    provides the ability to configure a custom or specific `AuthenticationProvider`
    to be used for handling user authentication and role binding. For example, it
    would be easy to connect your application to the company''s LDAP server and allow
    developers to use their regular credentials and also configure different role
    access controls, based on the needs of the particular organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each command can be queried for its usage by using help, or in the case of a
    command containing sub-commands, by typing the name of the top-level command.
  prefs: []
  type: TYPE_NORMAL
- en: While SSHd Shell comes with many built-in commands, one can easily add custom
    commands, taking advantage of standard Spring / Spring Boot programming style,
    using the `@Autowired` and `@Component` annotations to get the necessary dependencies
    to be wired in and automatically configured during the application start life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: SSHd Shell also provides a nice functionality enabling the use of post-processors,
    invoked by a pipe (`|`) symbol. The current support allows for output highlighting `|
    h packt`, which will highlight the word `packt` in the output, or emailing response
    output  `| m` `my@email.com`, which will email the response of a command to the
    specified email address, given that **Spring Mail** is also configured and available.
  prefs: []
  type: TYPE_NORMAL
- en: It would be great if we could chain different commands together, like in Linux
    proper, so as to help process the output and filter out the necessary data when
    the amount of information tends to get overwhelming. Imagine that our publishers
    list command returns not `2`, but `2000` publishers. From this list, we want to
    find the ones that start with `Pa`.
  prefs: []
  type: TYPE_NORMAL
- en: Even though SSHd Shell does not provide this type of functionality out of the
    box, it does offer us an ability to implement our own post-processors by defining
    beans that extend the `BaseUserInputProcessor` class. Let's create one that would
    provide support for filtering JSON responses, something similar to how the `jq`
    command-line utility works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, let''s create another class named `JsonPathUserInputProcessor.java`
    in the `src/main/java/com/example/bookpub/command` directory at the root of our
    project with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the pipe functionality, we can easily chain the `publishers list` command
    with the `jq` command in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, this should return us only one record, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: While it is not a full-fledged pipe functionality, the use of input processors
    allows for adding functionalities such as sorting, filtering, and displaying rendering,
    which give more flexibility to modularize and reuse common behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSHd Shell Spring Boot integration comes with a number of configuration
    options allowing us to disable the component, configure authentication settings,
    and specify usernames, passwords, and even key certificates. For example, if we
    want to use a specific username and password, we can do so by configuring the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In a real-world enterprise environment, it is more common to use the shared
    keys for restricted access and these can be configured using the `sshd.shell.publicKeyFile=<key
    path>` or `sshd.shell.hostKeyFile=<key path>` properties. Alternatively, and probably
    a better approach, as was already mentioned earlier, using a custom `AuthenticationProvider`
    implementation together with Spring Security allows the integrate of authentication
    mechanisms into the company's authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Micrometer metrics with Graphite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned about the monitoring capabilities that
    are provided by Spring Boot. We saw examples of writing custom `HealthIndicators`,
    creating metrics, and using `MeterRegistry` to emit data. The simple Spring Boot
    Admin Web framework gave us some nice graphical UI to visualize the data, but
    all of these metrics were in-the-moment, with no long-term retention and historical
    access. Not being able to observe the trends, detect the deviations from the baseline,
    and compare today with last week is not a very good strategy, especially for an
    enterprise-complex system. We all want to be able to have access to the time series
    data going weeks, if not months, back and set up alarms and thresholds, if something
    goes unplanned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe will introduce us to an amazing time series graphical tool: Graphite.
    Graphite is a two-part system. It provides storage for numeric time series data
    as well as a service to render this data in a form of on-demand graphs or expose
    the graph data as a JSON stream. You will learn how to integrate and configure
    Spring''s Micrometer monitoring framework with Graphite in order to send the monitoring
    data from a Spring Boot application to Graphite and play a bit with Graphite to
    visualize the different statistics that we''ve gathered.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphite is an application that is written in Python and is, thus, capable of
    running on virtually any system supporting Python and its libraries. There are
    multiple ways of installing Graphite on any given system, ranging from compilation
    from a source, using `pip` all the way, to prebuilt RPMs for various Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: For all the different installation strategies, take a look at the Graphite documentation
    at [http://graphite.readthedocs.org/en/latest/install.html](http://graphite.readthedocs.org/en/latest/install.html).
    OS X users can read a very good step-by-step guide located at [https://gist.github.com/relaxdiego/7539911](https://gist.github.com/relaxdiego/7539911).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this recipe, we will use a premade Docker container containing
    Graphite as well as its counterpart Grafana. While there is an abundance of various
    prebuilt variants of Docker images containing combinations of Graphite and Grafana,
    we will use the one from [https://registry.hub.docker.com/u/alexmercer/graphite-grafana/](https://registry.hub.docker.com/u/alexmercer/graphite-grafana/)
    as it contains all the right configurations that will make it easy for us to get
    started quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step will be to download the desired Docker container image. We will
    do this by executing `docker pull alexmercer/graphite-grafana`. The container
    size is about 500 MB; so the download might take a few minutes depending on your
    connection speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both Graphite and Grafana store their data in the database files. We will need
    to create external directories, which will reside outside the container, and we
    will connect them to a running instance via Docker data volumes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a directory for the Graphite data anywhere in your system, for example,
    in `<user_home>/data/graphite`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a directory for the Grafana data, for example, in `<user_home>/data/grafana`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this container, the Graphite data will go to `/var/lib/graphite/storage/whisper`,
    while Grafana stores its data in `/usr/share/grafana/data`. So, we will use these
    paths as internal volume mount destinations when starting the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the container by executing `docker run -v <user_home>/data/graphite:/var/lib/graphite/storage/whisper
    -v <user_home>/data/grafana:/usr/share/grafana/data -p 2003:2003 -p 3000:3000
    -p 8888:80 -d alexmercer/graphite-grafana`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Docker, the `-v` option configures a volume mount binding. In our example,
    we configured the external `<user_home>/data/graphite` directory to be the same
    as the `/var/lib/graphite/storage/whisper` directory reference in the container.
    The same goes for the `<user_home>/data/grafana` mapping. We can even look in
    the `<user_home>/data/graphite or data/grafana` directories to see them contain
    the subdirectories and files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-p` option configures the port mappings similar to the directory volumes.
    In our example, we mapped the following three different ports to be accessible
    from outside the container to the internal ports to which the various services
    are bound:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2003:2003`: This port mapping externalizes the Graphite data stream listener
    known as **Carbon-Cache Line Receiver**, to which we will connect in order to
    send the metrics data.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3000:3000`: This port mapping externalizes the Grafana Web Dashboard UI, which
    we will use to create visual dashboards on top of the Graphite data.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`8888:80`: This port mapping externalizes the Graphite Web UI. Though it is
    running on port `80` in the container, it is unlikely that on our development
    machine, port `80` is open; so it is better to map it to some other higher number
    port such as `8080` or `8888` in our case, as `8080` is already taken by our `BookPub`
    application.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If everything has gone according to the plan, Graphite and Grafana should be
    up and running and thus, we can access Graphite by pointing our browser to `http://localhost:8888`
    and we should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1714b0f1-661c-4b52-ae20-2779dbb1d2d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To see Grafana, point the browser to `http://localhost:3000` so as to see the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8dae836b-455e-477f-a3f0-8dd6870e0883.png)'
  prefs: []
  type: TYPE_IMG
- en: The default login and password for Grafana are `admin`/`admin` and can be changed
    via the Web UI Admin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the OS X users who use boot2docker, the IP would not be of the `localhost`,
    but rather a result of the boot2docker IP call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are in Grafana, we will need to add our Graphite instance as `DataSource`,
    so click on the icon, go to Data Sources, and add a new source of the `Type Graphite,
    Url http://localhost:80, Access`  proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfda06db-afca-4e90-bf61-8cdd8e23eec9.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Graphite and Grafana up and running, we are now ready to start configuring
    our application in order to send the metrics to the Graphite listener on port
    `2003`. To do this, we will use the Codahale/Dropwizard metrics library, which
    is fully supported by Spring Boot and thus requires a minimum amount of configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing on our list is to add the necessary library dependencies. Extend
    the dependencies block in the `build.gradle` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `MonitoringConfiguration.java` in the `src/main/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to add the configuration property settings for our Graphite
    instance to the `application.properties` file in the `src/main/resources` directory
    at the root of our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's build and run our application by executing `./gradlew clean bootRun`
    and if we have configured everything correctly, it should start without any issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the application up and running, we should start seeing some data that is
    in the Graphite and `bookpub` data nodes getting added to the tree under metrics.
    To add some more realism, let's open our browser and load a book URL, `http://localhost:8080/books/978-1-78528-415-1/`,
    a few dozen times to generate some metrics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and look at some of the metrics in Graphite and set the data
    time range to 15 minutes in order to get some close-look graphs, which will look
    similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d7ccfc50-6bb0-40c8-a426-a3a92e5f7311.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also create some fancy looking dashboards using this data in Grafana
    by creating a new dashboard and adding a Graph panel, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac6f0880-0768-48bb-a84e-7dd6dee1ffd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The newly created Graph panel will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2840eb11-b5f1-4535-9534-ad4a4dac34ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the no title (click here) label, choose edit, and enter the metric
    name `bookpub.app.http.server.requests.exception.None.method.GET.status.200.uri._books__isbn_.count`
    in the text field as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/398fcd94-9ce8-4ef1-8243-8a5bec4e6c00.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on Dashboard will take you out of the edit mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a more detailed tutorial, visit [http://docs.grafana.org/guides/gettingstarted/](http://docs.grafana.org/guides/gettingstarted/).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable exporting metrics via Graphite, we added an extra dependency on the `io.micrometer:micrometer-registry-graphite`
    library. Under the hood, however, it depends on the Dropwizard metrics library
    to provide Graphite integration, so it will add the following new dependencies
    to our `build` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io.dropwizard.metrics:metrics-core`: This dependency adds the basic Dropwizard
    functionality, `MetricsRegistry`, common API interfaces, and base classes. This
    is the bare minimum that is required to get Dropwizard working and integrated
    into Spring Boot to handle the metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.dropwizard.metrics:metrics-graphite`: This adds support for `GraphiteReporter`
    and is needed in order to configure Dropwizard to send the monitoring data that
    it collects to our Graphite instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to keep things clean and nicely separated, we created a separate configuration
    class with all the monitoring-related beans and settings: `MonitoringConfiguration`.
    In this class, we configured three `@Bean` instances: a custom `MeterRegistryCustomizer` implementation
    to customize the `GraphiteMeterRegistry` instance, `HigherarchicalNameMapper`,
    and `NamingConvention` to go along with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we had to create our own customization is twofold. We wanted
    to comply with the classic Graphite metric naming scheme, which uses the dot (`.`)
    notation to separate metric names in a hierarchy. Unfortunately, for whatever
    reason, Micrometer Graphite implementation has opted for using the `camelCase`
    collapsing notation instead, which made metric names like `counter.datasource.BookRepository`
    translate into the `counterDatasourceBookRepository` name to be displayed inside
    Graphite. Having such a long name, without hierarchical tree makes for a very
    difficult search and discovery inside Graphite UI, when many metrics are present.
    Also, all the metrics get placed under a root (`/`) tree, without creating a dedicated
    application folder, which also leads to poor readability and usage. We have added
    code to our `HigherarchicalNameMapper` instance to prepend the application prefix
    to all the metrics being exported to Graphite so that they all get put into `subtree:
    /bookpub/app/*.`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `NamingConvention` provides precise configuration about how to convert particular
    Meter names, keys, values, and tags into proper Graphite variants. Inside the `format(String
    name)` method, we declare that we want to use a dot (`.`) separation between elements
    via the `NamingConvention.dot` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `management.metrics.export.graphite` group of properties define how to send
    the data to the Graphite instance. We configured it to do so every 1 minute, translate
    all the time duration intervals, such as the latency measurements, into milliseconds
    and all the variable rates, such as the number of requests per some time frame,
    into seconds. Most of these values have their default configuration settings for
    Graphite provided, but can be changed, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we've used the `@ConditionalOnClass` annotation to indicate that
    we only want to apply this `@Configuration` if the Micrometer Graphite provided
    class `GraphiteMeterRegistry.class` is present in the classpath. This is needed
    to not try to instantiate Graphite beans during tests, as there might not be a
    Graphite instance running and available in the testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the available metrics from Graphite UI, there are many metrics
    that are provided out of the box. Some notable ones are about JVM and OS metrics,
    which expose the memory and thread metrics to Graphite in the memory and threads
    data nodes among other data. They can be found in `Metrics/bookpub/app/jvm`, `Metrics/bookpub/app/process`,
    or `Metrics/bookpub/app/system` in the Graphite tree.
  prefs: []
  type: TYPE_NORMAL
- en: Micrometer core library provides a number of meter binders for additional system
    metrics. If there is a need to export things like thread or executor information,
    or get a view into the file descriptors, one can export additional beans by simply
    declaring a method returning `new JvmThreadMetrics()` or `new FileDescriptorMetrics()` for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: The running application will gather all the metrics registered with `MeterRegistry`
    and every configured exporter (in our case, `GraphiteMeterRegistry`) reports all
    these metrics at a timed interval to its destination. The proper exporter implementations
    run in a separate `ThreadPool`, thus outside of the main application threads and
    not interfering with them. However, this should be kept in mind in case the Meter
    implementations use some `ThreadLocal` data internally, which would not be available
    to exporters.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Micrometer metrics with Dashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe has given us a glimpse of how we can collect the various
    metrics from our application during its runtime. We've also seen how powerful
    the ability to visualize this data as a set of graphs of historical trends can
    be.
  prefs: []
  type: TYPE_NORMAL
- en: While Grafana and Graphite offer us the very powerful capability of manipulating
    the data in the form of graphs and building elaborate dashboards that are full
    of thresholds, applied data functions, and much more, sometimes we want something
    simpler, more readable, and something widgety. This is exactly the kind of dashboard
    experience that is provided by Dashing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dashing** is a popular dashboard framework developed by Shopify and written
    in Ruby/Sinatra. It provides you with an ability to create an assortment of dashboards
    that are comprised of different types of widgets. We can have things such as graphs,
    meters, lists, numeric values, or just plain text to display the information.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will install the Dashing framework, learn how to create dashboards,
    send and consume the data to report from an application directly as well as fetch
    it from Graphite, and use the Dashing API to push the data to the Dashing instance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get Dashing to run, we will need to have an environment that has
    a Ruby 1.9+ installed with RubyGems.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, Ruby should be available on any common distribution of Linux and
    OS X. If you are running Windows, I would suggest using [http://rubyinstaller.org](http://rubyinstaller.org)
    in order to get the installation bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have such an environment available, we will install Dashing and create
    a new dashboard application for our use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Dashing is very easy; simply execute the gem install dashing command
    to install Dashing RubyGems on your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the RubyGem successfully installed, we will create the new dashboard named
    `bookpub_dashboard` by executing the dashing new `bookpub_dashboard` command in
    the directory where you want the dashboard application to be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the dashboard application has been generated, go to the `bookpub_dashboard`
    directory and execute the `bundle` command to install the required dependency
    gems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the gems bundle has been installed, we can start the dashboard application
    by executing the `dashing start` command and then pointing our browser to `http://localhost:3030`
    to see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10c6167a-a909-4e1a-a0d7-dbb50453f232.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look carefully at the URL of our shiny new dashboard, you will see that
    it actually says `http://localhost:3030/sample` and displays a sample dashboard
    that was automatically generated. We will use this sample dashboard to make some
    changes in order to display some metrics from our application directly as well
    as get some raw metrics from the Graphite data API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to connect the data from the application `/actuator/metrics`
    endpoint so as to display it in the Dashing dashboard, we will change the `Buzzwords`
    widget to display the counts of our data repositories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, we will need to add the `'httparty', '>= 0.13.3'` gem to the `Gemfile`
    file located in the `bookpub_dashboard` directory, which will enable us to use
    an HTTP client in order to extract the monitoring metrics from the HTTP endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the gem, run the `bundle` command one more time to install the
    newly added gem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will need to modify the `sample.erb` dashboard definition located in
    the `bookpub_dashboard/dashboards` directory, replacing `<div data-id="buzzwords"
    data-view="List" data-unordered="true" data-title="Buzzwords" data-moreinfo="#
    of times said around the office"></div>` with `<div data-id="repositories" data-view="List"
    data-unordered="true" data-title="Repositories Count" data-moreinfo="# of entries
    in data repositories"></div>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the widget replaced, we will create a new data provisioning job file named
    `repo_counters.rb` in the `bookpub_dashboard/jobs` directory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the code changes in place, let''s start our dashboard by executing
    the `dashing start` command. Go to `http://localhost:3030/sample` in the browser
    to see our new widget displaying the data as shown in the following icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b360ec9-ce6b-4d45-ba47-bc3f576b422f.png)'
  prefs: []
  type: TYPE_IMG
- en: If we use the remote Shell to log in to the application, as we did earlier in
    this chapter, and add a publisher, we would see the counter on the dashboard increase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to push the data to the dashboard is to use their RESTful API.
    Let''s update the text in the top left text widget by executing `curl -d ''{ "auth_token":
    "YOUR_AUTH_TOKEN", "text": "My RESTful dashboard update!" }'' http://localhost:3030/widgets/welcome`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything has worked correctly, we should see the text updated to our new
    value, `My RESTful dashboard update!`, under the Hello title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In an environment where multiple instances of the same application kind are
    running, it is probably not a good idea to directly pull the data from each node,
    especially if they are very dynamic and can come and go as they please. It is
    advised that you consume the data from a more static and well-known location,
    such as a Graphite instance. To get a demonstration of volatile data metrics,
    we will consume the memory pool data for the `Eden`, `Survivor`, and `OldGen`
    spaces and display them instead of the Convergence, Synergy, and Valuation graph
    dashboards. We will start by replacing the content of the `sample.rb` job file
    located in the `bookpub_dashboard/jobs` directory with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `sample.erb` template located in the `bookpub_dashboard/dashboards`
    directory, we will replace the Synergy, Valuation, and Convergence graphs with
    the following alternatives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<div data-id="synergy" data-view="Meter" data-title="Synergy" data-min="0"
    data-max="100"></div>` gets replaced with `<div data-id="heap_survivor" data-view="Meter"
    data-title="Heap: Survivor" data-min="0" data-max="100" data-moreinfo="In megabytes"></div>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<div data-id="valuation" data-view="Number" data-title="Current Valuation"
    data-moreinfo="In billions" data-prefix="$"></div>` gets replaced with `<div data-id="heap_oldgen"
    data-view="Number" data-title="Heap: OldGen" data-moreinfo="In bytes" ></div>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<div data-id="convergence" data-view="Graph" data-title="Convergence" style="background-color:#ff9618"></div>`
    gets replaced with `<div data-id="heap_eden" data-view="Graph" data-title="Heap:
    Eden" style="background-color:#ff9618" data-moreinfo="In bytes"></div>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After all the changes are made, we can restart the dashboard application and
    reload our browser to `http://localhost:3030` to see the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37b6ceef-0e4a-4208-9b87-67d91838806b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have seen how to extract the data directly from our application
    and via Graphite, and render it using the Dashing dashboard as well as pushing
    information directly to Dashing using their RESTful API. It is no secret that
    it is better to see something once than hear about it seven times. This is true
    when it comes to trying to get a holistic picture of the key metrics that represent
    how the systems behave at runtime and to be able to act on the data quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going in to great detail about the internals of Dashing, it is still
    important to mention a few things about how data gets in to Dashing. This can
    happen in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheduled jobs**: This is used to pull data from the external sources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESTful API**: This is used to push data to Dashing from outside'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scheduled jobs are defined in the jobs directory in the generated dashboard
    application. Each file has a piece of ruby code wrapped in the `SCHEDULER.every`
    block, which computes the data points and sends an event to an appropriate widget
    with the new data for an update.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our recipe, we created a new job named `repo_counters.rb` where we used
    the `httparty` library in order to make a direct call to our application instance''s
    `/actuator/metrics/#{name}` endpoint and extracted the counters for each of the
    predefined repositories. Looping over the metrics, we created a `repo_counts`
    collection with data for each repository containing a label display and a value
    count. The resulting collection was sent to the repositories widget for an update
    in the form of `event: send_event(''repositories'', { items: repo_counts })`.'
  prefs: []
  type: TYPE_NORMAL
- en: We configured this job to get executed every 10 seconds, but if the rate of
    data change is not very frequent, the number can be changed to a few minutes or
    even hours. Every time the scheduler runs our job, the repositories widget is
    updated via the client-side websockets communication with the new data. Looking
    in dashboards/`sample.erb`, we can find the widget's definition using `data-id="repositories"`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides adding our own new job, we also changed the existing `sample.rb` job
    to pull data from Graphite using Graphite's RESTful API to populate the different
    types of widgets in order to display the memory heap data. As we were not pulling
    data directly from the application instance, it was a good idea not to put the
    code in the same job because the jobs could—and in our case, do—have different
    time intervals. As we send data to Graphite only once every minute, it does not
    make sense to pull it any less frequently than this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the data out of Graphite, we used the following API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following parameters mentioned in the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target`: This parameter is a repeated value that defines a list of all the
    different metrics that we want to retrieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from`: This parameter specifies the time range; in our case, we asked for
    data going back 11 minutes to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: This parameter configures the desired output format. We chose JSON
    but many others are available. Refer to [http://graphite.readthedocs.org/en/latest/render_api.html#format](http://graphite.readthedocs.org/en/latest/render_api.html#format).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxDataPoints`: This parameter indicates how many entries we want to get.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason we asked for 11 entries and not 10 is due to a frequent occurrence
    where the last entry of short-ranged requests, which consist of only a few minutes,
    sometimes get returned as empty. We just use the first 10 entries and ignore the
    most recent ones to avoid weird data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating over the target data, we will populate the appropriate widgets such
    as `heap_eden`, `heap_survivor`, and `heap_oldgen`, with their designated data,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`heap_eden`: This is a `Graph` widget, as defined in the `sample.erb` template
    in the form of a `data-view="Graph" ` attribute, so it wants a data input in the
    form of the points collection containing a value for `x` and `y`. The `x` value
    represents a timestamp, which conveniently gets returned to us by Graphite and
    is automatically converted to the minutes display value by the Graph widget. The
    `y` value represents the memory pool utilization in bytes. As the value from Graphite
    is in the form of a decimal number, we will need to convert it to a whole number
    so as to make it look better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heap_survivor`: This is a `Meter` widget, as defined in the `sample.erb` template
    in the form of a `data-view="Meter"` attribute, so it wants a data input as a
    simple value number between a template configured range. In our case, the range
    is set as the `data-min="0" data-max="100"` attribute. Even though we chose to
    round the number to two decimal positions, it could probably just be an integer
    as it is precise enough for the purpose of a dashboard display. You will also
    notice that inside `sample.rb`, we convert the raw value, which is in bytes, into
    megabytes, for better readability— `current_survivor = current_survivor / 1048576`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heap_oldgen`: This is a `Number` widget, as defined in the `sample.erb` template
    in the form of a `data-view="Number"` attribute, so it wants a data input as a
    current value and optionally a last value; in this case, a percentage change with
    the change direction will be displayed as well. As we get the last 10 entries,
    we have no issues in retrieving both the current and last values so we can easily
    satisfy this requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we also experimented with Dashing''s RESTful API by trying
    to use a `curl` command to update the value of the welcome widget. This was a
    push operation and can be used in situations where there is no data API exposed,
    but you have the capability of creating some sort of a script or piece of code
    that could send the data to Dashing instead. To achieve this, we used the following
    command: `curl -d ''{ "auth_token": "YOUR_AUTH_TOKEN", "text": "My RESTful dashboard
    update!" }'' http://localhost:3030/widgets/welcome`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dashing API accepts data in a JSON format, sent via a POST request that
    contains the following parameters needed for the widgets as well as the widget
    ID, which is a part of the URL path itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auth_token`: This allows for a secure data update and can be configured in
    the dashboard root directory in the `config.ru` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: This is a `widget` property that is being changed. As we are updating
    a `Text` widget, as defined in the `sample.erb` template in the form of a `data-view="Text"`
    attribute, we need to send it to text to update.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/widgets/<widget id>`: This URL path identifies the particular widget where
    the update is destined to. The `id` corresponds to a declaration in the `sample.erb`
    template. In our case, it looks like `data-id="welcome"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of the various widgets can also be manipulated and a very rich
    collection of the various widgets has been created by the community, which is
    available at [https://github.com/Shopify/dashing/wiki/Additional-Widgets](https://github.com/Shopify/dashing/wiki/Additional-Widgets).
    The widgets get installed in the widgets directory in the dashboard and can be
    installed by simply running `dashing install <GIST>`, where `GIST` is the hash
    of the GitHub Gist entry.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard template files, similar to our `sample.erb` template, can be modified
    in order to create the desired layout for each particular dashboard as well as
    multiple dashboard templates, which can be rotated or directly loaded manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each dashboard represents a grid in which the various widgets get placed. Each
    widget is defined by a `<div>` entry with the appropriate configuration attributes
    and it should be nested in the `<li>` grid element. We can use the data element
    attributes to control the positioning of each widget in the grid, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data-row`: This represents the row number where the widget should be positioned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-col`: This represents the column number where the widget should be positioned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-sizex`: This defines the number of columns the widget will span horizontally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-sizey`: This defines the number of rows the widget will span vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existing widgets can be modified to change their look and feel as well as
    extend their functionality; so the sky is the limit for what kind of information
    display we can have. You should definitely check out [http://dashing.io](http://dashing.io)
    for more details.
  prefs: []
  type: TYPE_NORMAL
