- en: Health Monitoring and Data Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康监控和数据可视化
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Writing custom health indicators
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义健康指标
- en: Configuring management context
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理上下文
- en: Emitting metrics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射指标
- en: Monitoring Spring Boot via JMX
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JMX监控Spring Boot
- en: Managing Spring Boot via SSHd Shell and writing custom remote Shell commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SSHd Shell管理Spring Boot并编写自定义远程Shell命令
- en: Integrating Micrometer metrics with Graphite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微米级指标与Graphite集成
- en: Integrating Micrometer metrics with Dashing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微米级指标与Dashing集成
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned a few techniques to efficiently package
    and get the application ready for deployment and we looked at a number of techniques
    to provide an environmental configuration without changing the code. With the
    deployment and configuration woes behind us, the last (but not least) important
    step remains—ensuring that we have complete visibility, monitoring, and management
    control of our application, as it is running in the production environment and
    is exposed to the harsh environment of customers' (ab)use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了一些高效打包应用程序并使其准备就绪以进行部署的技术，我们还探讨了提供环境配置而无需更改代码的多种技术。随着部署和配置问题的解决，最后一个（但同样重要）的步骤是确保我们对应用程序在生产环境中的运行有完整的可见性、监控和管理控制，因为它暴露在客户（滥用）的恶劣环境中。
- en: Just as airline pilots don't like to fly blind, developers don't get excited
    if they can't see how their beloved application, that they worked hard on, performs
    in production. We want to know, at any given time, what the CPU utilization is
    like, how much memory we are consuming, whether our connection to the database
    is up and available, the number of customers who use the system in any given time
    interval, and so on. Not only do we want to know all these things, but we also
    want to be able to see it in pretty charts, graphs, and visual dashboards. These
    come in very handy to put on the big Plasma displays for monitoring as well as
    impressing your boss, so as to show that you are on the top of things and have
    it all under control.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如飞行员不喜欢盲目飞行一样，开发者如果看不到他们辛勤工作的应用程序在生产中的表现，也不会感到兴奋。我们希望在任何给定时间，都能了解CPU的利用率如何，我们消耗了多少内存，我们的数据库连接是否正常可用，在任何给定时间间隔内使用系统的客户数量等等。我们不仅想知道所有这些信息，还希望能够通过漂亮的图表、图形和可视化仪表板来查看它们。这些对于在大屏幕等离子显示器上进行监控以及给老板留下深刻印象非常有用，以便表明你一切尽在掌握之中。
- en: This chapter will help you learn the necessary techniques to enhance our application
    in order to expose custom metrics, health statuses, and so on, as well as how
    to get the monitoring data out of our application and either store it in Graphite
    for historical reference or use this data to create real-time monitoring dashboards
    using the Dashing and Grafana frameworks. We will also take a look at the capability
    to connect to running instances and perform various management tasks using the
    powerful CRaSH framework integration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你学习必要的技巧来增强我们的应用程序，以便暴露自定义指标、健康状态等，以及如何从我们的应用程序中获取监控数据，并将其存储在Graphite中进行历史参考，或者使用这些数据通过Dashing和Grafana框架创建实时监控仪表板。我们还将探讨使用强大的CRaSH框架集成连接到运行实例并执行各种管理任务的能力。
- en: Writing custom health indicators
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义健康指标
- en: Knowing the state of the application that is running in production, especially
    in a large-scale distributed system, is just as (if not more) important as having
    things such as automated testing and deployment. In today's fast-paced IT world,
    we can't really afford much downtime, so we need to have the information about
    the health of the application at our fingertips, ready to go at a minute's notice.
    If the all-so-important database connections go down, we want to see it right
    away and be able to quickly remedy the situation; the customers are not going
    to be waiting around for long before they go to another site.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解生产环境中运行的应用程序的状态，尤其是在大规模分布式系统中，这和拥有自动化测试和部署等事物一样（如果不是更重要的话）重要。在当今快节奏的IT世界中，我们真的无法承受太多的停机时间，因此我们需要随时掌握应用程序的健康状况信息，以便在第一时间采取行动。如果至关重要的数据库连接出现问题，我们希望立即看到并能够迅速解决问题；客户不会在等待很长时间后才去其他网站。
- en: We will resume working on our `BookPub` application in the state in which we
    left it in the previous chapter. In this recipe, we will add the necessary Spring
    Boot starters to enable the monitoring and instrumentation of our application
    and will even write our own health indicator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前一章结束时的状态继续工作在我们的 `BookPub` 应用程序中。在这个菜谱中，我们将添加必要的 Spring Boot starters 以启用我们应用程序的监控和仪表化，甚至将编写我们自己的健康指标。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first thing that we need to do is add a dependency to the Spring Boot Actuator
    starter in our `build.gradle` file with the following content:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在我们的 `build.gradle` 文件中添加对 Spring Boot Actuator starter 的依赖项，内容如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Adding this dependency alone already gives us the ability to access the Spring
    management `/actuator/*` endpoints, such as `/env`, `/info`, `/metrics`, and `/health`,
    (though they are disabled by default, unless a `management.endpoints.web.exposure.include=*`
    property is configured in the `application.properties` file). So, let''s start
    our application by executing the `./gradlew clean bootRun` command line and then
    we can access the newly available `/health` endpoint by opening our browser and
    going to `http://localhost:8080/actuator/health` so as to see the new endpoint
    in action, as shown in the following screenshot:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅添加此依赖项就已经使我们能够访问 Spring 管理的 `/actuator/*` 端点，例如 `/env`、`/info`、`/metrics` 和
    `/health`（尽管它们默认是禁用的，除非在 `application.properties` 文件中配置了 `management.endpoints.web.exposure.include=*`
    属性）。因此，让我们通过执行 `./gradlew clean bootRun` 命令来启动我们的应用程序，然后我们可以通过打开浏览器并访问 `http://localhost:8080/actuator/health`
    来访问新可用的 `/health` 端点，以便查看新端点的实际操作，如下面的截图所示：
- en: '![](img/fed372cf-11a0-4774-8904-4d532e658b25.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fed372cf-11a0-4774-8904-4d532e658b25.png)'
- en: 'To get more details about the health state of our application, let''s configure
    it to show the detailed health output by adding the `management.endpoint.health.show-details=always`
    property to the `application.properties` file and then restarting our application.
    Now, when we go to `http://localhost:8080/actuator/health` in the browser, we
    should see something similar to the following screenshot:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取我们应用程序健康状态的更多详细信息，让我们配置它以显示详细的健康输出，通过向 `application.properties` 文件添加 `management.endpoint.health.show-details=always`
    属性并重新启动我们的应用程序。现在，当我们通过浏览器访问 `http://localhost:8080/actuator/health` 时，我们应该看到类似于以下截图的内容：
- en: '![](img/cbf41ff6-7cba-4f01-b691-c33a8e068754.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbf41ff6-7cba-4f01-b691-c33a8e068754.png)'
- en: 'With the `actuator` dependency added, and detailed `/health` endpoint configured,
    we can now add and perform all kinds of monitoring functions on our application.
    Let''s go ahead and populate the `/info` endpoint with some data by adding a directive
    to the `build.gradle` file located at the root of our project with the following
    content:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了 `actuator` 依赖项并详细配置了 `/health` 端点后，我们现在可以在我们的应用程序上添加和执行所有类型的监控功能。让我们继续操作，通过向位于我们项目根目录的
    `build.gradle` 文件中添加以下内容的指令来填充 `/info` 端点：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will create a new properties file named `gradle.properties` in the
    root directory of our project with the following content:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们项目的根目录下创建一个名为 `gradle.properties` 的新属性文件，其内容如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will also add `rootProject.name='BookPub-ch7'` to the `settings.gradle` file
    located in the root directory of our project.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将向位于项目根目录的 `settings.gradle` 文件中添加 `rootProject.name='BookPub-ch7'`。
- en: 'Now, let''s start our application by executing `./gradlew clean bootRun` and
    then we can access the newly available `/info` endpoint by opening our browser
    and going to `http://localhost:8080/actuator/info` to see the new endpoint in
    action, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行 `./gradlew clean bootRun` 来启动我们的应用程序，然后我们可以通过打开浏览器并访问 `http://localhost:8080/actuator/info`
    来访问新可用的 `/info` 端点，以查看新端点的实际操作，如下所示：
- en: '![](img/3a847adf-f02e-454c-9e45-901943fd86fd.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a847adf-f02e-454c-9e45-901943fd86fd.png)'
- en: As we have got the hang of how things work, let's go ahead and make our custom
    health indicator, which will be accessible via the `/health` endpoint in order
    to report the count status of the entries for each of our repositories. If they
    are greater than or equal to zero, we are `UP`, otherwise we are not really sure
    what's going on. Obviously, if an exception has occurred, we would be reporting
    `DOWN`. Let's start by relaxing the `getRepositoryName(...)` method visibility
    from `private` to `protected` in the `DbCountRunner.java` file located in the
    `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount` directory
    at the root of our project.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经掌握了事情的工作原理，让我们继续创建我们的自定义健康指标，它将通过`/health`端点访问，以便报告每个存储库条目的计数状态。如果它们大于或等于零，我们认为是`UP`，否则我们并不真正清楚发生了什么。显然，如果发生了异常，我们将报告`DOWN`。让我们首先将位于项目根目录下的`db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`目录中的`DbCountRunner.java`文件中的`getRepositoryName(...)`方法可见性从`private`更改为`protected`。
- en: Next, we will add the same dependency to the `compile("org.springframework.boot:spring-boot-starter-actuator")`
    library in the `build.gradle` file in the `db-count-starter` directory at the
    root of our project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在项目根目录下的`db-count-starter`目录中的`build.gradle`文件中添加相同的依赖项`compile("org.springframework.boot:spring-boot-starter-actuator")`。
- en: 'Now, we will create a new file named `DbCountHealthIndicator.java` in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在项目根目录下的`db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`目录中创建一个名为`DbCountHealthIndicator.java`的新文件，其内容如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will modify the `@Import` annotation in the `EnableDbCounting.java`
    file located in the `db-count starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改位于项目根目录下的`db-count starter/src/main/java/com/example/bookpubstarter/dbcount`目录中的`EnableDbCounting.java`文件，其内容如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, for the automatic registration of our `HealthIndicator` class, we
    will enhance the `DbCountAutoConfiguration.java` file located in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了自动注册我们的`HealthIndicator`类，我们将在项目根目录下的`db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`目录中的`DbCountAutoConfiguration.java`文件中添加以下内容：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, let''s start our application by executing the `./gradlew clean bootRun`
    command line, and then we can access the `/health` endpoint by opening our browser
    and going to `http://localhost:8080/actuator/health` to see our new `HealthIndicator`
    class in action, as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们通过执行`./gradlew clean bootRun`命令来启动我们的应用程序，然后我们可以通过打开浏览器并访问`http://localhost:8080/actuator/health`来查看我们的新`HealthIndicator`类在行动中的效果，如下所示：
- en: '![](img/6ddc9b6d-b0f2-4080-a5d3-96b34cd5486f.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ddc9b6d-b0f2-4080-a5d3-96b34cd5486f.png)'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Spring Boot Actuator starter adds a number of important features that give
    insight into the runtime state of the application. The library contains a number
    of autoconfigurations that add and configure the various endpoints to access the
    runtime monitoring data and health of the application. Those endpoints all share
    a common context path: `/actuator`. To expose any other endpoints besides `/info`
    and `/health`, we need to explicitly expose them by setting the `management.endpoints.web.exposure.include=*`
    property. When the value is set to `*`, it will expose all of the endpoints. The
    following endpoints are available to aid us in getting an insight into the application
    runtime state and configuration:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator starter添加了多个重要功能，这些功能可以让我们深入了解应用程序的运行状态。该库包含多个自动配置，这些配置添加并配置了各种端点以访问应用程序的运行监控数据和健康状态。这些端点都共享一个公共上下文路径：`/actuator`。要公开除`/info`和`/health`之外的其他端点，我们需要通过设置`management.endpoints.web.exposure.include=*`属性来显式公开它们。当该值设置为`*`时，它将公开所有端点。以下端点可供我们深入了解应用程序的运行状态和配置：
- en: '`/env`: This endpoint enables us to query the application about all of the
    environment variables that the application has access to via the environment implementation,
    which we have seen earlier. It is very useful when you need to debug a particular
    issue and want to know a value of any given configuration property. If we access
    the endpoint by going to `http://localhost:8080/actuator/env`, we will see a number
    of different configuration sections, for example, the class path resource `[tomcat.https.properties]`,
    `applicationConfig: [classpath:/application.properties]`, `commonsConfig`, `systemEnvironment`,
    `systemProperties`, and others. They all represent an instance of an individual
    `PropertySource` implementation that is available in the environment and depending
    on their place in the hierarchy, may or may not be used to provide the value resolution
    at the runtime. To find out exactly which entry is used to resolve a particular
    value, for example, for the `book.count.rate` property, we can query it by going
    to the `http://localhost:8080/actuator/env/book.counter.rate` URL. By default,
    we should get 10,000 as a result unless, of course, a different value was set
    via the system environment or command-line arguments as an override. If you really
    want to dig deep into the code, the `EnvironmentEndpoint` class is responsible
    for handling the logic behind this capability.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/env`: 此端点使我们能够查询应用程序通过环境实现可以访问的所有环境变量，这是我们之前看到的。当您需要调试特定问题并想知道任何给定配置属性的值时，它非常有用。如果我们通过访问
    `http://localhost:8080/actuator/env` 端点，我们将看到多个不同的配置部分，例如，类路径资源 `[tomcat.https.properties]`、`applicationConfig:
    [classpath:/application.properties]`、`commonsConfig`、`systemEnvironment`、`systemProperties`
    以及其他。它们都代表环境中的一个单独的 `PropertySource` 实例实现，根据它们在层次结构中的位置，可能或可能不被用于在运行时提供值解析。要找出用于解析特定值的确切条目，例如，对于
    `book.count.rate` 属性，我们可以通过访问 `http://localhost:8080/actuator/env/book.counter.rate`
    URL 来查询它。默认情况下，我们应该得到 10,000 作为结果，除非当然，通过系统环境或命令行参数设置了不同的值作为覆盖。如果您真的想深入了解代码，`EnvironmentEndpoint`
    类负责处理此功能背后的逻辑。'
- en: '`/configprops`: This endpoint provides you with an insight into the settings
    of the various configuration property objects, such as our `WebConfiguration.TomcatSslConnectorProperties` starter.
    It is slightly different from the `/env` endpoint as it provides insight into
    the configuration object bindings. If we open the browser to go to `http://localhost:8080/actuator/configprops`
    and search for `custom.tomcat.https`, we will see the entry for our configuration
    property object that we will use to configure `TomcatSslConnector`, which was
    automatically populated and bound for us by Spring Boot.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/configprops`: 此端点向您展示了各种配置属性对象的设置，例如我们的 `WebConfiguration.TomcatSslConnectorProperties`
    启动器。它与 `/env` 端点略有不同，因为它提供了对配置对象绑定的洞察。如果我们打开浏览器访问 `http://localhost:8080/actuator/configprops`
    并搜索 `custom.tomcat.https`，我们将看到用于配置 `TomcatSslConnector` 的配置属性对象的条目，该对象由 Spring
    Boot 自动填充并为我们绑定。'
- en: '`/conditions`: This endpoint serves as a web-based analog to the AutoConfiguration
    Report, which we saw in [Chapter 4](6139967b-794e-479a-8461-d3197eb0322e.xhtml),
    *Writing Custom Spring Boot Starters*. This way, we can get the report using the
    browser at any time without having to start the application with the specific
    flags to get it printed.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/conditions`: 此端点作为我们在第 4 章“编写自定义 Spring Boot 启动器”中看到的自动配置报告的基于网络的类似物。这样，我们可以随时使用浏览器获取报告，而无需启动应用程序并使用特定的标志来打印它。'
- en: '`/beans`: This endpoint is designed to list all the beans that have been created
    by Spring Boot and are available in application context.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/beans`: 此端点旨在列出由 Spring Boot 创建并可在应用程序上下文中使用的所有 bean。'
- en: '`/mappings`: This endpoint exposes a list of all the URL mappings that are
    supported by the application as well as a reference to the `HandlerMapping` bean
    implementation. This is very useful for answering the question of where would
    a specific URL get routed to. Try going to `http://localhost:8080/actuator/mappings`
    to see the list of all the routes that our application can handle.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mappings`: 此端点公开了应用程序支持的所有 URL 映射列表以及 `HandlerMapping` bean 实现的引用。这对于回答特定
    URL 将被路由到何处的问题非常有用。尝试访问 `http://localhost:8080/actuator/mappings` 以查看应用程序可以处理的所有路由列表。'
- en: '`/threaddump`: This endpoint allows extraction of the Thread Dump information
    from the running application. It is rather useful when trying to diagnose a potential
    thread deadlock.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/threaddump`: 这个端点允许从运行中的应用程序中提取线程转储信息。当尝试诊断潜在的线程死锁时，它非常有用。'
- en: '`/heapdump`: This endpoint is similar to `/dump` with the exception that it
    produces Heap Dump information instead.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/heapdump`: 这个端点与 `/dump` 类似，但不同的是它产生堆转储信息。'
- en: '`/info`: This endpoint shows the basic description and application information
    that we added and we''ve seen this in action, so it should be familiar to us as
    of now. The nice support in the build tools gives us the ability to configure
    additional or replace existing values inside our `build.gradle` configuration,
    which would then be propagated to be consumed by the `/info` endpoint. Additionally,
    any properties defined in the `application.properties` file, that start with `info.`
    will be displayed while accessing the `/info` endpoint, so you are definitely
    not limited to only the `build.gradle` configuration. Configuring this specific
    endpoint in order to return the relevant information can be very helpful when
    building various automated discovery and monitoring tools as it is a great way
    to expose application-specific information in the form of a nice JSON RESTful
    API.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/info`: 这个端点显示了我们所添加的基本描述和应用程序信息，我们已经看到了它的实际应用，因此现在应该对我们来说很熟悉。构建工具中的良好支持使我们能够配置额外的或替换
    `build.gradle` 配置中的现有值，然后这些值将被传播以由 `/info` 端点消费。此外，在访问 `/info` 端点时，任何以 `info.`
    开头的 `application.properties` 文件中定义的属性都将显示出来，所以您绝对不仅限于 `build.gradle` 配置。配置此特定端点以返回相关信息在构建各种自动化发现和监控工具时非常有帮助，因为它是一种以漂亮的
    JSON RESTful API 形式公开应用程序特定信息的好方法。'
- en: '`/actuator`: This endpoint gives a nice JSON-formatted list of links in a **Hypertext
    Application Language** (**HAL**) style for all the available actuator endpoints.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/actuator`: 这个端点以 **超文本应用语言**（**HAL**）风格的 JSON 格式列表提供了所有可用执行器端点的链接。'
- en: '`/health`: This endpoint provides information about the general application
    health status as well as a detailed breakdown and health status of the individual
    components.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/health`: 这个端点提供了有关应用程序总体健康状况以及各个组件的详细分解和健康状况的信息。'
- en: '`/metrics`: This endpoint gives an overview of all the various data points
    that are emitted by the metrics subsystem. You can experiment with it by accessing
    it via the `http://localhost:8080/actuator/metrics` URL in the browser. We will
    cover this in more detail in the next recipe.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/metrics`: 这个端点提供了由指标子系统发出的所有各种数据点的概述。您可以通过在浏览器中访问 `http://localhost:8080/actuator/metrics`
    URL 来实验它。我们将在下一道菜中更详细地介绍这一点。'
- en: Now that we know in general what is being provided for us by Spring Boot Actuator,
    we can move on to take a look at the details of what we did to get our custom
    `HealthIndicator` class working and how the whole health monitoring subsystem
    in Spring Boot functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Spring Boot Actuator 为我们提供了哪些一般性信息，我们就可以继续查看我们如何使自定义 `HealthIndicator`
    类工作以及 Spring Boot 中的整个健康监控系统是如何工作的细节。
- en: As you saw, getting the basic `HealthIndicator` interface to work is very easy;
    all we have to do is create an implementing class that will return a `Health`
    object upon a call to the `health()` method. All you have to do is expose the
    instance of the `HealthIndicator` class as `@Bean` for Spring Boot to pick it
    up and add it to the `/health` endpoint.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使基本的 `HealthIndicator` 接口工作非常简单；我们只需创建一个实现类，当调用 `health()` 方法时，它将返回一个
    `Health` 对象。您只需将 `HealthIndicator` 类的实例作为 `@Bean` 暴露出来，Spring Boot 就会将其拾取并添加到
    `/health` 端点。
- en: In our case, we went a step further because we had to deal with the need to
    create `HealthIndicator` for each `CrudRepository` instance. To accomplish this,
    we created an instance of `CompositeHealthIndicator` to which we added all the
    instances of `DbHealthIndicator` for each `CrudRepository`. We then returned this
    as `@Bean` and this is what was used by Spring Boot to represent the health status.
    Being a composite, it preserved the inner hierarchy as is evident from the returned
    JSON data representing the health status. We also added some extra data element
    to provide the indication of the entry count as well as the name of each particular
    repository so that we can tell them apart.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们更进一步，因为我们必须处理为每个`CrudRepository`实例创建`HealthIndicator`的需求。为了实现这一点，我们创建了一个`CompositeHealthIndicator`的实例，并向其中添加了每个`CrudRepository`的所有`DbHealthIndicator`实例。然后我们将这个实例作为`@Bean`返回，这就是Spring
    Boot用来表示健康状态的方式。作为一个组合体，它保留了内部层次结构，正如从表示健康状态的返回JSON数据中可以明显看出。我们还添加了一些额外的数据元素，以提供入口计数以及每个特定存储库的名称，这样我们就可以区分它们。
- en: 'Looking at the code, you are probably wondering: what is this `HealthAggregator`
    instance that we''ve wired in? The reason that we needed a `HealthAggregator`
    instance is because `CompositeHealthIndicator` needs to know how to decide if
    the inner composition of all the nested `HeathIndicators` represents good or bad
    health as a whole. Imagine that all the repositories, but one, return `UP` but
    one is `DOWN`. What does this mean? Is the composite indicator healthy as a whole
    or should it also report `DOWN` because one inner repository has issues?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看着代码，你可能想知道：我们连接的这个`HealthAggregator`实例是什么？我们需要`HealthAggregator`实例的原因是`CompositeHealthIndicator`需要知道如何决定所有嵌套`HeathIndicators`的内部组合是否代表整体良好的或不良的健康状态。想象一下，所有存储库都返回`UP`，只有一个返回`DOWN`。这意味着什么？组合指标整体健康吗？或者它也应该报告`DOWN`，因为有一个内部存储库有问题？
- en: By default, Spring Boot already creates and uses an instance of `HealthAggregator`,
    so we just autowired it and used it in our use case as well. We did have to explicitly
    add the import of the `HealthIndicatorAutoConfiguration` and `MetricsDropwizardAutoConfiguration`
    classes in order to satisfy the bean dependency during slice tests for `DataJpaTest`
    and `WebMvcTest`, since those only partially instantiate the context, and the
    actuator autoconfigurations are missing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot已经创建并使用了一个`HealthAggregator`的实例，所以我们只是自动注入并在我们用例中使用了它。我们确实必须显式添加`HealthIndicatorAutoConfiguration`和`MetricsDropwizardAutoConfiguration`类的导入，以满足`DataJpaTest`和`WebMvcTest`切片测试期间的bean依赖关系，因为那些只部分实例化了上下文，并且缺少了actuator自动配置。
- en: Even though the default implementation is an instance of `OrderedHealthAggregator`,
    which just collects all the inner status responses and chooses the lowest on the
    priority level out of `DOWN`, `OUT_OF_SERVICE`, `UP`, and `UNKNOWN`, it doesn't
    always have to be that way. For example, if the composite indicator consists of
    the indicators for redundant service connections, your combined result could be
    `UP` as long as at least one of the connections is healthy. Creating a custom
    `HealthAggregator` interface is very easy; all you have to do is either extend
    `AbstractHealthAggregator` or implement a `HealthAggregator` interface itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认实现是一个`OrderedHealthAggregator`的实例，它只是收集所有内部状态响应，并从`DOWN`、`OUT_OF_SERVICE`、`UP`和`UNKNOWN`中选择优先级最低的，但这并不总是必须这样。例如，如果组合指标由冗余服务连接的指标组成，只要至少有一个连接是健康的，你的组合结果可以是`UP`。创建自定义`HealthAggregator`接口非常简单；你所要做的就是要么扩展`AbstractHealthAggregator`，要么实现`HealthAggregator`接口本身。
- en: Configuring management context
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理上下文
- en: Spring Boot Actuator out of the box creates a set of management endpoints and
    the supporting beans in the main application context and those endpoints are available
    on the `server.port` configured HTTP port. There are, however, cases where for
    security or isolation reasons we would want to separate the main application context
    from the management one or expose the management endpoints on a different port
    than the main application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator默认在主应用程序上下文中创建了一组管理端点和支持bean，这些端点在配置的HTTP端口`server.port`上可用。然而，由于安全或隔离的原因，我们可能希望将主应用程序上下文与管理上下文分开，或者在不同的端口上公开管理端点。
- en: Spring Boot provides us with an ability to configure a separate child application
    context for the management beans, which would inherit everything from the main
    application context, but allow for defining beans that are only available for
    the management functions as well. The same goes for exposing the endpoints on
    a different port or even using different connector security in such a way that
    the main application could be using SSL, but the management endpoints are accessible
    using plain HTTP.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为我们提供了一个配置独立子应用程序上下文的能力，该上下文将继承主应用程序上下文的所有内容，但允许定义仅对管理功能可用的bean。同样，对于在不同的端口上公开端点或使用不同的连接器安全性的方式，主应用程序可以使用SSL，而管理端点可以使用纯HTTP进行访问。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's imagine that, for whatever reason, we want to change our JSON converter
    to output field names using `SNAKE_CASE` (all lowercase letters separating words
    with an underscore).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设，出于某种原因，我们想要将我们的JSON转换器更改为使用`SNAKE_CASE`（所有单词之间用下划线分隔的小写字母）输出字段名称。
- en: 'First, let''s create a class holding our configuration for the management context
    named `ManagementConfiguration.java` located in the `src/main/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`ManagementConfiguration.java`的类，该类包含我们的管理上下文配置，位于项目根目录`src/main/java/com/example/bookpub`目录下，并包含以下内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also need to add this class to `spring.factories` located in the `src/main/resources/META-INF`
    directory at the root of our project with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将此类添加到位于项目根目录`src/main/resources/META-INF`目录下的`spring.factories`文件中，并添加以下内容：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To avoid our configuration being detected by the component scan for the main
    application context, we need to exclude it by adding the following to `BookPubApplication.java`
    located in the `src/main/java/com/example/bookpub` directory at the root of our
    project:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免我们的配置被主应用程序上下文的组件扫描检测到，我们需要通过在项目根目录`src/main/java/com/example/bookpub`目录下的`BookPubApplication.java`文件中添加以下内容来排除它：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To have a separate management context, we need to launch it using a different
    port, so let''s amend `application.properties` located in the `src/main/resources`
    directory at the root of our project with the following content:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要有一个独立的管理上下文，我们需要使用不同的端口来启动它，因此让我们修改位于项目根目录`src/main/resources`目录下的`application.properties`文件，并添加以下内容：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, let's start our application by executing `./gradlew clean bootRun`
    and then we can access the `/threaddump` endpoint by opening our browser and going
    to `http://localhost:8081/actuator/threaddump` to see our new configuration take
    place. The field names of the returned JSON should all be in lowercase and words
    should be separated using an underscore, or in `SNAKE_CASE`, as it is called.
    Alternatively, by going to the `http://localhost:8080/books/978-1-78528-415-1`
    endpoint, we should continue seeing JSON field names in the `LOWER_CAMEL_CASE`
    format.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过执行`./gradlew clean bootRun`来启动我们的应用程序，然后我们可以通过打开浏览器并访问`http://localhost:8081/actuator/threaddump`端点来查看我们的新配置生效。返回的JSON的字段名称都应该全部是小写，并且单词应该使用下划线分隔，或者称为`SNAKE_CASE`。或者，通过访问`http://localhost:8080/books/978-1-78528-415-1`端点，我们应该继续看到`LOWER_CAMEL_CASE`格式的JSON字段名称。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spring Boot recognizes that there are many reasons and it needs to be able to
    provide separate configuration for the way management endpoints and other actuator
    components work, which is different from the main application. The first level
    of such configurations can be achieved by setting the myriad of available properties
    that intuitively start with `management.*`. We have used one such property, `management.server.port`,
    to set the port for the management interface to be `8081`. We could also set things
    like the SSL configuration, security settings, or network IP interface address
    to bind the listener to. We also have the capability to configure each individual
    `actuator` endpoint by setting their corresponding properties, which start with
    `management.endpoint.<name>.*` and have a variety of settings, depending on the
    specific endpoint goals.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot认识到存在许多原因，它需要能够为管理端点和其他执行器组件的工作方式提供单独的配置，这与主应用程序不同。这种配置的第一级可以通过设置大量以`management.*`开头的直观属性来实现。我们已经使用了一个这样的属性，即`management.server.port`，来设置管理接口的端口号为`8081`。我们还可以设置诸如SSL配置、安全设置或网络IP接口地址等，以便将监听器绑定到。我们还有能力通过设置相应的属性来配置每个单独的`actuator`端点，这些属性以`management.endpoint.<name>.*`开头，并具有各种设置，具体取决于特定端点的目标。
- en: For security reasons, the data that is exposed by the various management endpoints,
    especially the ones from sensitive ones such as `/health`, `/env`, and others
    can be very lucrative for malicious people on the outside. To prevent this from
    happening, Spring Boot provides us with the ability to configure if we want the
    endpoints to be available via `management.endpoint.<name>.enabled=false`. We can
    specify which individual endpoints we want to disable by setting an appropriate
    `management.endpoint<name>.enabled=false` property as well, or using `management.endpoints.web.exposure.exclude=<name>`
    to tell Spring Boot if this endpoint should be enabled, but not exposed via the
    WEB HTTP API method of access.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，各种管理端点暴露的数据，尤其是来自敏感端点（如`/health`、`/env`等）的数据，可能对外部恶意人员非常有价值。为了防止这种情况发生，Spring
    Boot为我们提供了配置端点是否通过`management.endpoint.<name>.enabled=false`可用的能力。我们可以通过设置适当的`management.endpoint<name>.enabled=false`属性来指定我们想要禁用的单个端点，或者使用`management.endpoints.web.exposure.exclude=<name>`来告诉Spring
    Boot是否应该启用此端点，但不要通过WEB HTTP API访问方法暴露。
- en: Alternatively, we can set `management.server.port=-1` to disable the HTTP exposure
    of these endpoints or use a different port number in order to have the management
    endpoints and live services on different ports. If we want to enable access only via
    a localhost, we can achieve this by configuring `management.server.address=127.0.0.1`
    to prevent external access. Even the context URL path can be configured to something
    else, say `/admin`, via `management.server.context-path=/admin`. This way, to
    get access to a `/health` endpoint, we would go to `http://127.0.0.1/admin/health`
    instead of the default `/actuator` context path. This can be useful if you want
    to control and restrict access via the firewall rules, so you can just add a filter
    to block external access to anything, `/admin/*`, for all the applications from
    the outside. With the addition of Spring Security, an authentication can also
    be configured to require a user login to get access to the endpoints.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以设置`management.server.port=-1`来禁用这些端点的HTTP暴露，或者使用不同的端口号，以便管理端点和实时服务在不同的端口上。如果我们只想通过localhost访问，我们可以通过配置`management.server.address=127.0.0.1`来防止外部访问。甚至可以将上下文URL路径配置为其他路径，例如通过`management.server.context-path=/admin`配置为`/admin`。这样，要访问`/health`端点，我们将访问`http://127.0.0.1/admin/health`而不是默认的`/actuator`上下文路径。这在你想要通过防火墙规则控制和限制访问时可能很有用，因此你只需添加一个过滤器来阻止外部访问所有应用程序的`/admin/*`。随着Spring
    Security的添加，还可以配置身份验证，要求用户登录才能访问端点。
- en: In situations when controlling behavior using properties is not enough, Spring
    Boot provides a mechanism to provide alternative application context configuration
    via the use of `spring.factories` and the accompanying `ManagementContextConfiguration`
    annotation. This enables us to tell Spring Boot which configurations should be
    automatically loaded when management context is being created. The intended use
    of this annotation is to have the configuration live in a separate, sharable dependency
    library, outside of the main application's code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用属性控制行为不足以应对的情况中，Spring Boot 提供了一种机制，通过使用 `spring.factories` 和相应的 `ManagementContextConfiguration`
    注解来提供替代应用程序上下文配置。这使得我们能够告知 Spring Boot 在创建管理上下文时应自动加载哪些配置。此注解的预期用途是将配置保存在一个独立的、可共享的依赖库中，位于主应用程序代码之外。
- en: In our example, because we put it in the same codebase (for simplicity), we
    had to do an extra step and define the exclusion filter in the `BookPubApplication.java`
    file to exclude the `ManagementContextConfiguration` classes from component scan
    when setting up the main application. The reason we had to do that is simple—if
    we look inside the `ManagementContextConfiguration` annotation definition, we
    will see that it is a meta-annotation with the `@Configuration` annotation inside
    it. What this means is that when our main application is being configured, the
    component scan will automatically detect all the classes in the classpath tree
    of the application code that are annotated with `@Configuration`, and as such,
    it will put all the configurations marked with `ManagementContextConfiguration`
    in the main context as well. We have avoided that using the exclusion filter.
    Alternatively, a better way is to have those configurations in a separate library
    using a different package hierarchy, which would prevent the component scan picking
    them up, but the autoconfiguration will still works because of the `spring.factories`
    entry for `org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration`
    telling Spring Boot to automatically add those configurations to the management
    context.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，因为我们将其放在相同的代码库中（为了简单起见），我们不得不进行额外的一步，并在 `BookPubApplication.java` 文件中定义排除过滤器，在设置主应用程序时排除
    `ManagementContextConfiguration` 类的组件扫描。我们必须这样做的原因很简单——如果我们查看 `ManagementContextConfiguration`
    注解的定义，我们会看到它是一个带有内部 `@Configuration` 注解的元注解。这意味着当我们的主应用程序正在配置时，组件扫描将自动检测应用程序代码的类路径树中所有带有
    `@Configuration` 注解的类，并且因此，它将所有标记为 `ManagementContextConfiguration` 的配置放入主上下文中。我们已经通过排除过滤器避免了这种情况。或者，更好的方法是使用不同的包层次结构将这些配置放在一个单独的库中，这将防止组件扫描捕获它们，但由于
    `spring.factories` 中为 `org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration`
    的条目，自动配置仍然有效，因为它告诉 Spring Boot 自动将这些配置添加到管理上下文中。
- en: In order to have the management context separate from the main application,
    it is necessary to configure it to run on a separate port using the `management.server.port`
    property. Without this setting, all of the objects will be using shared application
    context.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使管理上下文与主应用程序分离，有必要配置它使用 `management.server.port` 属性在单独的端口上运行。如果没有此设置，所有对象都将使用共享的应用程序上下文。
- en: Emitting metrics
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射指标
- en: The previous recipe gave an overview of the capabilities provided by Spring
    Boot Actuators. We played with different management endpoints such as `/info` and `/health` and
    even created our own health metrics to add to the default set. However, besides
    the health status, there are a number of things that we, as developers and operations
    folks, want to be able to see and monitor on an ongoing basis, and just knowing
    that the uplink is functional is not good enough. We would also like to see the
    number of open sessions, concurrent requests to the application, latency, and
    so on. In this recipe, you will learn about the metric reporting facilities in
    Spring Boot as well as how to add our own metrics and some quick and simple ways
    of visualizing them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方概述了 Spring Boot Actuators 提供的功能。我们玩转了不同的管理端点，如 `/info` 和 `/health`，甚至创建了自己的健康指标以添加到默认集合中。然而，除了健康状态之外，作为开发人员和运维人员，我们还想能够持续查看和监控许多其他内容，仅仅知道链路是功能性的还不够。我们还想看到打开会话的数量、对应用程序的并发请求、延迟等。在本配方中，你将了解
    Spring Boot 的指标报告功能，以及如何添加我们自己的指标和一些快速简单的方式来可视化它们。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To help us visualize the metrics better, we will use a great open source project,
    `spring-boot-admin`, located at [https://github.com/codecentric/spring-boot-admin](https://github.com/codecentric/spring-boot-admin).
    It provides a simple web UI on top of the Spring Boot Actuators to give a nicer
    view of the various data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化指标，我们将使用一个位于 [https://github.com/codecentric/spring-boot-admin](https://github.com/codecentric/spring-boot-admin)
    的优秀开源项目 `spring-boot-admin`。它提供了一个简单的 Web UI，在 Spring Boot Actuators 之上，以提供更美观的各种数据视图。
- en: 'We will create a simple admin application in Gradle using the instructions
    from [https://github.com/codecentric/spring-boot-admin#server-application](https://github.com/codecentric/spring-boot-admin#server-application) by
    performing the following simple steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据 [https://github.com/codecentric/spring-boot-admin#server-application](https://github.com/codecentric/spring-boot-admin#server-application)
    中的说明，在 Gradle 中创建一个简单的管理应用程序。执行以下简单步骤：
- en: 'Go to [start.spring.io](http://start.spring.io) and create a new application
    template with the following fields:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [start.spring.io](http://start.spring.io) 并创建一个新的应用程序模板，以下字段如下：
- en: 'Generate a: Gradle Project'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个：Gradle 项目
- en: With: Java
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用：Java
- en: 'Spring Boot: 2.0.0 (SNAPSHOT)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot：2.0.0 (SNAPSHOT)
- en: 'Group: `org.sample.admin`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`org.sample.admin`
- en: 'Artifact: `spring-boot-admin-web`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件：`spring-boot-admin-web`
- en: 'Name: `Spring Boot Admin Web`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`Spring Boot Admin Web`
- en: 'Description: `Spring Boot Admin Web Application`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：`Spring Boot Admin Web 应用程序`
- en: 'Package Name: `org.sample.admin`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名：`org.sample.admin`
- en: 'Packaging: Jar'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包：Jar
- en: 'Java Version: 8'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 版本：8
- en: Select the Actuator option under Search for dependencies
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“搜索依赖项”下选择Actuator选项
- en: Click on Generate Project alt + to download the application template archive
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“生成项目”快捷键 alt + 下载应用程序模板存档
- en: Extract the contents from the directory of your choice
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您选择的目录中提取内容
- en: In the extracted directory, execute the `gradle wrapper` command line to generate
    a gradlew script
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提取的目录中，执行 `gradle wrapper` 命令行以生成 gradlew 脚本
- en: 'In the `build.gradle` file, add the following dependencies to the `dependencies`
    block:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.gradle` 文件中，将以下依赖项添加到 `dependencies` 块中：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to update the `repositories` block with a reference to use the
    `snapshots` repository (as the time of writing, the SBA is not yet released):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更新 `repositories` 块，以引用使用 `snapshots` 存储库（截至编写时，SBA 尚未发布）：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the `SpringBootAdminWebApplication.java` file located in the `src/main/java/spring-boot-admin-web`
    directory and add the following annotations to the `SpringBootAdminWebApplication`
    class:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `src/main/java/spring-boot-admin-web` 目录下的 `SpringBootAdminWebApplication.java`
    文件，并将以下注解添加到 `SpringBootAdminWebApplication` 类中：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open the `application.properties` file located in the `src/main/resources`
    directory and add the following settings:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `src/main/resources` 目录下的 `application.properties` 文件，并添加以下设置：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We are now ready to start our Admin Web Console by running `./gradlew bootRun`
    and open the browser to `http://localhost:8090` to see the following output:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好通过运行 `./gradlew bootRun` 来启动 Admin Web 控制台，并在浏览器中打开 `http://localhost:8090`
    以查看以下输出：
- en: '![](img/3cbd2f7b-868f-499d-95a3-4cdf96c0e1af.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3cbd2f7b-868f-499d-95a3-4cdf96c0e1af.png)'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the **Admin Web** up and running, we are now ready to start adding various
    metrics to our `BookPub` application. Let''s expose the same information about
    our data repositories as we did in `HealthIndicators`, but this time, we will
    expose the counts data as a metric. We will continue to add code to our `db-count-starter`
    subproject. So, let''s create a new file named `DbCountMetrics.java` in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着 **Admin Web** 的运行，我们现在可以开始向我们的 `BookPub` 应用程序添加各种指标。让我们像在 `HealthIndicators`
    中做的那样，公开我们的数据存储库的相同信息，但这次我们将公开计数数据作为指标。我们将在 `db-count-starter` 子项目中继续添加代码。因此，让我们在项目根目录下的
    `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount` 目录中创建一个名为
    `DbCountMetrics.java` 的新文件，并添加以下内容：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, for the automatic registration of `DbCountMetrics`, we will enhance `DbCountAutoConfiguration.java`
    located in the `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    directory at the root of our project with the following content:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了自动注册 `DbCountMetrics`，我们将在项目根目录下的 `db-count-starter/src/main/java/com/example/bookpubstarter/dbcount`
    目录中的 `DbCountAutoConfiguration.java` 文件中添加以下内容：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order for the Thread Dump to properly display in the Spring Boot Admin UI,
    we need to change our JSON converter from `SNAKE_CASE` to `LOWER_CAMEL_CASE` by
    changing `ManagementConfiguration.java` located in the `src/main/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使线程转储在 Spring Boot Admin UI 中正确显示，我们需要将我们的 JSON 转换器从 `SNAKE_CASE` 更改为 `LOWER_CAMEL_CASE`，通过更改位于我们项目根目录
    `src/main/java/com/example/bookpub` 目录中的 `ManagementConfiguration.java` 文件，内容如下：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, let''s start our application by executing `./gradlew clean bootRun` and
    then we can access the `/metrics` endpoint by opening our browser and going to
    `http://localhost:8081/actuator/metrics` to see our new `DbCountMetrics` class
    added to the existing metrics list, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们通过执行 `./gradlew clean bootRun` 来启动我们的应用程序，然后我们可以通过打开浏览器并访问 `http://localhost:8081/actuator/metrics`
    来访问 `/metrics` 端点，以查看我们添加到现有指标列表中的新 `DbCountMetrics` 类，如下所示：
- en: '![](img/939b9e18-ff5c-4881-bfe7-16e7b8b5e968.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/939b9e18-ff5c-4881-bfe7-16e7b8b5e968.png)'
- en: Our next step would be to get our application to appear in the Spring Boot Admin
    Web, which we created earlier. To make this happen, we will need to add a dependency
    on the `compile("de.codecentric:spring-boot-admin-starter-client:2.0.0-SNAPSHOT")`
    library to `build.gradle` in the directory at the root of our project.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下一步要做的是让我们的应用程序出现在我们之前创建的 Spring Boot Admin Web 中。为了实现这一点，我们需要在我们的项目根目录的 `build.gradle`
    文件中添加对 `compile("de.codecentric:spring-boot-admin-starter-client:2.0.0-SNAPSHOT")`
    库的依赖。
- en: 'Additionally, `application.properties` located in the `src/main/resources`
    directory in the root of our project needs to be enhanced with the following entries:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，位于我们项目根目录 `src/main/resources` 目录中的 `application.properties` 需要添加以下条目：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once again, let''s start our application by executing `./gradlew clean bootRun`,
    and if we now go to Spring Boot Admin Web by directing our browser to `http://localhost:8090`,
    we should see a new entry for our application named `BookPub Catalog Application`
    appear in the list. If we click on the Details button on the right-hand side and
    scroll down to the Health section, we will see our custom health indicators along
    with the others reported in a form of nicer looking hierarchical entries in a
    table, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，让我们通过执行 `./gradlew clean bootRun` 来启动我们的应用程序，如果我们现在通过将浏览器指向 `http://localhost:8090`
    访问 Spring Boot Admin Web，我们应该在我们的应用程序列表中看到一个名为 `BookPub Catalog Application` 的新条目。如果我们点击右侧的详细信息按钮并滚动到健康部分，我们将看到我们的自定义健康指标以及其他以更美观的层次结构条目形式报告的指标，如下所示：
- en: '![](img/a78eec07-1892-49b9-a071-d877d0628db6.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a78eec07-1892-49b9-a071-d877d0628db6.png)'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A few words about Spring Boot Admin Web before we delve into the details of
    creating and emitting metrics. It is a simple web GUI that, in the backend, uses
    the same endpoints exposed by Spring Boot Actuator, which we learned about in
    the previous recipe. The data is extracted from the application as we click on
    the various links in Admin Web and displayed in a nice graphical way—no magic!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解创建和发布指标细节之前，让我们简单谈谈 Spring Boot Admin Web。它是一个简单的网页图形用户界面，在后台使用与我们在前一个菜谱中了解的
    Spring Boot Actuator 相同的端点。当我们点击 Admin Web 中的各种链接时，数据从应用程序中提取出来，并以图形化的方式展示——没有魔法！
- en: 'We only had to configure a few properties in addition to adding the client
    library dependency in order to get our application to connect and register with
    Admin Web:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加客户端库依赖项之外，我们只需配置几个属性，就可以让我们的应用程序连接并注册到 Admin Web：
- en: '`spring.application.name=BookPub Catalog Application`: This configures the
    name of the application that we have chosen to use. It is also possible to take
    the value from the description property defined in `gradle.properties` using the
    resource processing task in Gradle. Admin Web uses this value when displaying
    the application list.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.application.name=BookPub Catalog Application`：此配置指定了我们选择使用的应用程序名称。也可以使用在
    `gradle.properties` 中定义的描述属性值，通过 Gradle 的资源处理任务来实现。Admin Web 在显示应用程序列表时使用此值。'
- en: '`spring.boot.admin.client.url=http://localhost:8090`: This configures the location
    of the Admin Web application so that our application knows where to go in order
    to register itself. As we are running on port `8080`, we chose to configure Admin
    Web to listen on port `8090`, but any port can be chosen as desired. You can see
    more configuration options by visiting [https://codecentric.github.io/spring-boot-admin/current/](https://codecentric.github.io/spring-boot-admin/current/).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.boot.admin.client.url=http://localhost:8090`: 这配置了Admin Web应用程序的位置，以便我们的应用程序知道如何注册自己。由于我们运行在端口`8080`上，我们选择将Admin
    Web配置为监听端口`8090`，但可以选择任何所需的端口。您可以通过访问[https://codecentric.github.io/spring-boot-admin/current/](https://codecentric.github.io/spring-boot-admin/current/)来查看更多配置选项。'
- en: 'If we also want to enable the logging level control through the UI, we will
    need to add a Jolokia JMX library to our `compile("org.jolokia:jolokia-core:+")` build
    dependency as well as a `logback.xml` file in the `src/main/resources` directory
    in the root of the project with the following content:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想通过UI启用日志级别控制，我们需要将Jolokia JMX库添加到我们的`compile("org.jolokia:jolokia-core:+")`构建依赖中，并在项目根目录的`src/main/resources`目录中添加一个`logback.xml`文件，内容如下：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The metrics facility in Spring Boot is very powerful and extendable, offering
    a number of different approaches for emitting and consuming metrics. Starting
    with Spring Boot 2.0, the `Micrometer.io` library is being used under the hood
    to provide a very comprehensive monitoring solution. Out of the box, Spring Boot
    already configures a number of data metrics that monitor the system resources,
    such as heap memory, thread counts, system uptime, and many others as well as
    the database usage and HTTP session counts. The MVC endpoints are also instrumented
    to gauge the request latency, which is measured in milliseconds, as well as a
    counter for each endpoint request status.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot中的度量设施非常强大且可扩展，提供了多种不同的方法来发布和消费度量。从Spring Boot 2.0开始，底层使用`Micrometer.io`库提供了一个非常全面的监控解决方案。Spring
    Boot默认配置了一些数据度量，用于监控系统资源，如堆内存、线程计数、系统运行时间等，以及数据库使用情况和HTTP会话计数。MVC端点也被度量以测量请求延迟，该延迟以毫秒为单位，以及每个端点请求状态的计数器。
- en: Various metrics, such as gauges, counters, timers, and so on, are emitted via
    the `MeterRegistry` implementation that is provided by Spring Boot at runtime.
    The registry can be easily autowired into any Spring-managed object and be used
    to emit metrics.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Spring Boot在运行时提供的`MeterRegistry`实现，发出各种度量，如度量、计数器、计时器等。该注册器可以轻松地自动装配到任何Spring管理的对象中，并用于发布度量。
- en: 'For example, we can easily count the number of times a particular method gets
    invoked. All we need to do is to autowire an instance of `MeterRegistry` into
    our object during creation, and place the following line at the beginning of the
    method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以轻松地计算特定方法被调用的次数。我们只需要在创建对象期间自动装配`MeterRegistry`的实例，并在方法的开始处放置以下行：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each time the method gets called, the particular metric count will be incremented.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每次方法被调用时，特定的度量计数将增加。
- en: 'This approach will give us the counts that we can increment, but if we want
    to measure latency or any other arbitrary value, we will need to use `Gauge` to
    submit our metrics. To measure how long it will take for our method to execute,
    we can use `MeterRegistry` and at the beginning of the method, record the time:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将给我们计数，但如果我们想测量延迟或其他任意值，我们需要使用`Gauge`来提交我们的度量。为了测量我们的方法执行所需的时间，我们可以在方法开始时使用`MeterRegistry`记录时间：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will then place our code and before the return, capture the time again:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在代码和返回之前再次捕获时间：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, we will emit the metric `meterRegistry.gauge("objectName.methodName.latency",
    end - start);`, which will update the last. The use of `gauge` for timing purposes
    is very rudimentary and `MeterRegistry` actually provides a specialized type of
    meter—Timer. The Timer meter, for example, provides the ability to wrap runnable
    or callable lambdas and automatically time the execution. Another benefit of using
    a Timer instead of `Gauge` is that a Timer meter keeps both the event counts as
    well as the latency it took to execute each occurrence.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将发出度量`meterRegistry.gauge("objectName.methodName.latency", end - start);`，这将更新最后。使用`gauge`进行计时是非常基础的，而`MeterRegistry`实际上提供了一种专门的度量类型——Timer。例如，Timer度量提供了包装可运行或可调用的lambda表达式并自动计时执行的能力。使用Timer而不是`Gauge`的另一个好处是，Timer度量会保留事件计数以及每次发生的延迟。
- en: The `MeterRegistry` implementation covers most of the simple use cases and is
    very handy when we operate in our own code and have the flexibility to add them
    where we need to. However, it is not always the case, and in these cases, we will
    need to resort to wrapping whatever it is we want to monitor by creating a custom
    implementation of `MeterBinder`. In our case, we will use it to expose the counts
    for each of the repositories in the database as we can't insert any monitoring
    code into the `CrudRepository` proxy implementations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeterRegistry`实现涵盖了大多数简单用例，并且在我们自己代码中操作并且有灵活性将其添加到所需位置时非常方便。然而，情况并不总是如此，在这些情况下，我们将需要通过创建`MeterBinder`的自定义实现来包装我们想要监控的任何内容。在我们的情况下，我们将使用它来公开数据库中每个存储库的计数，因为我们不能在`CrudRepository`代理实现中插入任何监控代码。'
- en: 'Whenever the `MeterRegistry` implementation does not provide enough flexibility,
    for example, when there is a need to wrap an object in a meter like `Gauge`, most
    meter implementations provide fluid builders to gain more flexibility. In our
    example, to wrap the repository metrics, we used a `Gauge` fluid builder to construct
    `Gauge`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MeterRegistry`实现没有足够的灵活性时，例如，当需要将对象包装在像`Gauge`这样的仪表中时，大多数仪表实现都提供了流畅的构建器以获得更多灵活性。在我们的例子中，为了包装存储库指标，我们使用了一个`Gauge`流畅构建器来构建`Gauge`：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The main builder method takes the following three arguments:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构建方法接受以下三个参数：
- en: '`metricName`: This specifies the name to use to uniquely identify this metric'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metricName`: 这指定了用于唯一标识此指标的名字。'
- en: '`repository`: This provides an object on which we invoke the method that should
    return a numeric value that `gauge` will report'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repository`: 这提供了一个对象，我们可以在其上调用方法，该方法应返回一个数值，该数值是`gauge`将报告的。'
- en: '`CrudRepository::count`: This is the method that should be called on the `repository`
    object to get the current count of entries'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CrudRepository::count`: 这是应该调用`repository`对象的方法，以获取当前条目数。'
- en: This enables us to build flexible wrappers because all we have to do is provide
    an object that would expose the necessary numeric value and a function reference
    to a function that should be called on the instance to get that value during the `gauge`
    evaluation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够构建灵活的包装器，因为我们所需要做的只是提供一个对象，该对象将公开必要的数值，以及一个函数引用，该函数引用应在实例上调用以在`gauge`评估期间获取该值。
- en: The `MeterBinder` interface, used to export the Meter, has only one method defined,
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 用于导出仪表的`MeterBinder`接口定义了一个方法，
- en: '`void bindTo(MeterRegistry);`, which the implementer needs to code with the
    definition of what exactly is being monitored. The implementation class needs
    to be exposed as `@Bean`, and it will automatically be picked up and processed
    during the application initialization. Assuming that one actually registered the
    created `Meter` instance with the provided `MeterRegistry` implementation, typically
    by terminating the fluid builder''s chain by calling `.builder(...).register(registry)`,
    the metrics will be exposed via `MetricsEndpoint`, which will expose all the meters
    registered with the registry every time the `/metrics` actuator is called.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`void bindTo(MeterRegistry);`，实现者需要根据确切监控的内容进行编码。实现类需要以`@Bean`的形式公开，它将在应用程序初始化期间自动被拾取和处理。假设确实使用提供的`MeterRegistry`实现注册了创建的`Meter`实例，通常是通过调用`.builder(...).register(registry)`来终止流畅构建器的链，那么指标将通过`MetricsEndpoint`公开，每次调用`/metrics`操作器时，都会公开注册到注册表的仪表。'
- en: It is important to mention that we have created the `MeterBinder` and `HealthIndicator`
    beans inside the main application context and not in the management one. The reason
    being that even though the data is being exposed via the management endpoints,
    the endpoint beans, such as `MetricsEndpoint`, get defined in the main application
    context, and thus expect all the other autowired dependencies to be defined there
    as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，我们已经在主应用程序上下文中创建了`MeterBinder`和`HealthIndicator`豆子，而不是在管理上下文中。原因是尽管数据是通过管理端点公开的，但端点豆子，如`MetricsEndpoint`，是在主应用程序上下文中定义的，因此期望所有其他自动装配的依赖关系也在这里定义。
- en: This approach is safe because in order to get access to the information, one
    needs to go through the `WebMvcEndpointHandlerMapping` implementation facade,
    which is created in the management context and use the delegate endpoint from
    the main application context. Take a look at the `MetricsEndpoint` class and the
    corresponding `@Endpoint` annotation to see the details.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很安全，因为为了获取信息，需要通过 `WebMvcEndpointHandlerMapping` 实现外观，它在管理上下文中创建，并使用主应用程序上下文中的代理端点。查看
    `MetricsEndpoint` 类和相应的 `@Endpoint` 注解以了解详细信息。
- en: Monitoring Spring Boot via JMX
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 JMX 监控 Spring Boot
- en: In today's day and age, the RESTful HTTP JSON services are a de facto way of
    accessing data, but this is not the only way to do so. Another fairly popular
    and common way of managing systems in real time is via JMX. The good news is that
    Spring Boot already comes with the same level of support to expose the management
    endpoints over JMX as it does over HTTP. Actually, these are exactly the same
    endpoints; they are just wrapped around the MBean container.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今这个时代，RESTful HTTP JSON 服务是访问数据的事实标准方式，但这并不是唯一的方式。另一种相当流行且常见的管理实时系统的方式是通过
    JMX。好消息是 Spring Boot 已经提供了与通过 HTTP 相同级别的支持来暴露管理端点。实际上，这些确实是相同的端点；它们只是被 MBean 容器包装起来。
- en: In this recipe, we will take a look at how to retrieve the same information
    via JMX as we did via HTTP as well as how to expose some MBeans, which are provided
    by third-party libraries through HTTP using the Jolokia JMX library.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将探讨如何通过 JMX 获取与通过 HTTP 相同的信息，以及如何通过 Jolokia JMX 库使用 HTTP 暴露一些由第三方库提供的
    MBeans。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't done so already for the previous recipe, then add the Jolokia
    JMX library to our `compile("org.jolokia:jolokia-core:+")` build dependency and
    add the `management.jolokia.enabled=true` property to `application.properties`,
    as we will need them to expose MBeans via HTTP.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有为之前的配方添加 Jolokia JMX 库，那么请将 `compile("org.jolokia:jolokia-core:+")` 构建依赖项添加到我们的构建中，并将
    `management.jolokia.enabled=true` 属性添加到 `application.properties` 文件中，因为我们需要它们来通过
    HTTP 暴露 MBeans。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After we add the Jolokia JMX dependency, all we need to do is build and start
    our application by executing `./gradlew clean bootRun` and now we can simply launch
    jConsole to see the the various endpoints exposed under the `org.springframework.boot`
    domain:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加 Jolokia JMX 依赖项后，我们只需要通过执行 `./gradlew clean bootRun` 来构建和启动我们的应用程序，现在我们可以简单地启动
    jConsole 来查看在 `org.springframework.boot` 域下暴露的各种端点：
- en: '![](img/45a84151-7fc1-4cfb-804e-49e48dfa700c.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45a84151-7fc1-4cfb-804e-49e48dfa700c.png)'
- en: 'Having the Jolokia JMX library added to the classpath, Spring Boot also enables
    the accessing of all the registered MBeans via HTTP API using the `/jolokia` endpoint.
    To find out the `maxThreads` setting for our Tomcat HTTP port `8080` connector,
    we can either look it up using jConsole by selecting the `maxThreads` attribute
    on the `Tomcat:type=ThreadPool,name="http-nio-8080"` MBean to get the value of
    `200` or we can use Jolokia JMX HTTP by opening our browser and going to `http://localhost:8081/actuator/jolokia/read/Tomcat:type=ThreadPool,name=%22http-nio-8080%22/maxThreads`
    and we should see the following JSON response:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Jolokia JMX 库添加到类路径后，Spring Boot 还启用了通过 `/jolokia` 端点使用 HTTP API 访问所有已注册的
    MBeans。为了找出我们的 Tomcat HTTP 端口 `8080` 连接器的 `maxThreads` 设置，我们可以通过选择 `Tomcat:type=ThreadPool,name="http-nio-8080"`
    MBean 上的 `maxThreads` 属性来使用 jConsole 查找它，以获取 `200` 的值，或者我们可以使用 Jolokia JMX HTTP，通过打开浏览器并访问
    `http://localhost:8081/actuator/jolokia/read/Tomcat:type=ThreadPool,name=%22http-nio-8080%22/maxThreads`
    来获取以下 JSON 响应：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By default, the Spring Boot Actuator, when added to the application, comes with
    all the endpoints and management services enabled. This includes the JMX access
    as well. If, for some reason, one would like to disable the exposure of a particular
    endpoint via JMX, this can easily be configured by adding `management.endpoints.jmx.exclude=<id>`
    or in order to disable the exporting of all the Spring MBeans, we can configure
    the `spring.jmx.enabled=false` setting in `application.properties`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当 Spring Boot Actuator 添加到应用程序中时，会自带所有端点和管理服务启用。这包括 JMX 访问。如果出于某种原因，有人想通过
    JMX 禁露特定的端点，这可以通过添加 `management.endpoints.jmx.exclude=<id>` 来轻松配置；或者为了禁用所有 Spring
    MBeans 的导出，我们可以在 `application.properties` 中配置 `spring.jmx.enabled=false` 设置。
- en: The presence of the Jolokia library in the classpath triggers Spring Boot `JolokiaManagementContextConfiguration`,
    which would automatically configure `ServletRegistrationBean` accepting requests
    on the `/jolokia` actuator path. It is also possible to set various Jolokia-specific
    configuration options via the `management.endpoint.jolokia.config.*` set of properties.
    A complete list is available at [https://jolokia.org/reference/html/agents.html#agent-war-init-params](https://jolokia.org/reference/html/agents.html#agent-war-init-params).
    In case you would like to use Jolokia, but want to manually set it up, we can
    tell Spring Boot to ignore its presence by configuring a `management.endpoint.jolokia.enabled=false`
    property setting in `application.properties`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类路径中Jolokia库的存在触发了Spring Boot的`JolokiaManagementContextConfiguration`，这将自动配置接受`/jolokia`操作路径请求的`ServletRegistrationBean`。也可以通过`management.endpoint.jolokia.config.*`属性集设置各种Jolokia特定的配置选项。完整的列表可在[https://jolokia.org/reference/html/agents.html#agent-war-init-params](https://jolokia.org/reference/html/agents.html#agent-war-init-params)找到。如果你想使用Jolokia，但想手动设置它，我们可以通过在`application.properties`中配置`management.endpoint.jolokia.enabled=false`属性设置来告诉Spring
    Boot忽略其存在。
- en: Managing Spring Boot via SSHd Shell and writing custom remote Shell commands
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过SSHd Shell管理Spring Boot和编写自定义远程Shell命令
- en: Some of you are probably reminiscing about the good old days where all the administration
    was done via SSH directly on the machine, where one has complete flexibility and
    control, or even using SSH to connect to a management port and apply whatever
    changes were needed directly to a running application. Even though Spring Boot
    has removed native integration with the CRaSH Java Shell in version 2.0, there
    is an open source project, `sshd-shell-spring-boot`, which brings back that ability.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能正在回忆那些美好的旧时光，那时所有的管理都是通过直接在机器上使用SSH完成的，那时一个人拥有完全的灵活性和控制权，或者甚至使用SSH连接到管理端口，直接对运行中的应用程序应用所需的任何更改。尽管Spring
    Boot在2.0版本中移除了与CRaSH Java Shell的本地集成，但有一个开源项目，`sshd-shell-spring-boot`，它恢复了这种能力。
- en: For this recipe, we will use the health indicator and management endpoint, which
    we created earlier in this chapter. We will expose the same capabilities via the
    SSH console access.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用我们在本章早期创建的健康指示器和管理端点。我们将通过SSH控制台访问公开相同的功能。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The first step to getting SSHd Shell to work is to add the necessary dependency
    starters to our `build.gradle` file, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让SSHd Shell工作起来的第一步是在我们的`build.gradle`文件中添加必要的依赖启动项，如下所示：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to explicitly enable it by setting the following property in `application.properties`,
    located in the `src/main/resources` directory in the root of our project it needs
    to be enhanced with the following entries:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要显式地启用它，通过在项目根目录下的`src/main/resources`目录中的`application.properties`文件中设置以下属性，需要增强以下条目：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's start our application by executing `./gradlew clean bootRun` and
    then connect to it via SSH by executing `ssh -p 8022 admin@localhost`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行`./gradlew clean bootRun`来启动我们的应用程序，然后通过执行`ssh -p 8022 admin@localhost`来通过SSH连接到它。
- en: 'We will be prompted for a password so let''s find the autogenerated hash key
    in the application startup log, which would look as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将被提示输入密码，所以让我们在应用程序启动日志中找到自动生成的哈希密钥，它看起来如下：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the password is entered correctly, we will be greeted by the following welcome
    prompt:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密码输入正确，我们将看到以下欢迎提示：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will invoke our existing `/health` endpoint by typing health and we
    should get the following result:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过输入`health`来调用我们现有的`/health`端点，我们应该得到以下结果：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Typing `help` will show the list of all the existing commands so you can play
    with some of them to see what they do and then we will proceed with adding our
    own SSHd Shell command, which will enable us to add new publishers to the system
    via the command line.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`help`将显示所有现有命令的列表，这样你可以尝试一些命令来查看它们的功能，然后我们将继续添加我们自己的SSHd Shell命令，这将使我们能够通过命令行添加新的发布者到系统中。
- en: Make a new directory named commands in `src/main/java/com/example/bookpub/command`
    at the root of our project.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下的`src/main/java/com/example/bookpub/command`中创建一个名为`commands`的新目录。
- en: 'Add a file named `Publishers.java` in the `src/main/java/com/example/bookpub/command`
    directory at the root of our project with the following content:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下的`src/main/java/com/example/bookpub/command`目录中添加一个名为`Publishers.java`的文件，内容如下：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the commands built up, now let's start our application by executing `./gradlew
    clean bootRun` and then connect to it via SSH by executing `ssh -p 8022 admin@localhost`
    and log in using the generated password hash.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建了命令之后，现在让我们通过执行`./gradlew clean bootRun`来启动我们的应用程序，然后通过执行`ssh -p 8022 admin@localhost`通过SSH连接到它，并使用生成的密码散列登录。
- en: 'When we type publishers, we will see the list of all the possible commands,
    as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们输入发布者时，我们会看到所有可能的命令列表，如下所示：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s add a publisher by typing `publishers add Fictitious Books` and we should
    see the following message:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过输入`publishers add Fictitious Books`来添加一个发布者，我们应该看到以下消息：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we will now type publishers list, we will get a list of all the books:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在输入`publishers list`，我们将获得所有书籍的列表：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Removing a publisher is a simple command `publishers remove 2` that should respond
    with the `"Removed publisher 2"` message.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除发布者是一个简单的命令`publishers remove 2`，它应该响应`"Removed publisher 2"`消息。
- en: 'Just to confirm that the publisher is really gone, execute publishers list
    and we should see the following output:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认发布者确实已经删除，执行`publishers list`，我们应该看到以下输出：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The SSHd Shell integration with Spring Boot provides you with many commands
    out of the box. We can invoke the same management end points that were available
    to us over HTTP and JMX. We can get access to the JVM information, make changes
    to the logging configuration, and even interact with the JMX server and all the
    registered MBeans. The list of all the possibilities is really impressive and
    very rich in functionalities, so I would definitely advise you to read the reference
    documentation on SSHd Shell by going to [https://github.com/anand1st/sshd-shell-spring-boot](https://github.com/anand1st/sshd-shell-spring-boot).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot与SSHd Shell的集成提供了许多开箱即用的命令。我们可以调用通过HTTP和JMX向我们开放的相同管理端点。我们可以获取JVM信息，更改日志配置，甚至与JMX服务器和所有注册的MBeans进行交互。所有可能性的列表非常令人印象深刻，功能非常丰富，所以我肯定会建议您通过访问[https://github.com/anand1st/sshd-shell-spring-boot](https://github.com/anand1st/sshd-shell-spring-boot)来阅读SSHd
    Shell的参考文档。
- en: In Spring Boot, the expectation is that any class annotated with `@SshdShellCommand`
    will be automatically picked up and registered as an SSHd Shell command. The value
    of the annotation attribute translates into the main command name. In our case,
    we set the class annotation attribute value field to `publishers` and this became
    the top-level command name in the SSH Shell console.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot中，预期任何注解了`@SshdShellCommand`的类都将自动被拾取并注册为SSHd Shell命令。注解属性值转换为主命令名称。在我们的例子中，我们将类注解属性值字段设置为`publishers`，这成为了SSH
    Shell控制台中的顶级命令名称。
- en: If the command contains sub-commands, as in our publishers command example,
    then, the methods of the class that are also annotated with `@SshdShellCommand`
    get registered as sub-commands to the main command. If a class has only one method,
    it will automatically become the only command for a given class that would be
    executed when the command name is typed. If we want multiple sub-commands to reside
    in the class command, as we did with publishers, each method that translates into
    a command needs to be annotated with `@SshdShellCommand`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令包含子命令，例如在我们的发布者命令示例中，那么，类中同样注解了`@SshdShellCommand`的方法将被注册为子命令。如果一个类只有一个方法，它将自动成为给定类中唯一的命令，当输入命令名称时执行。如果我们想在类命令中放置多个子命令，就像我们处理发布者一样，每个转换为命令的方法都需要注解`@SshdShellCommand`。
- en: Currently, SSHd Shell framework has a limitation of being able to pass only
    one attribute argument to the command, but there is work going on to expand on
    that capability. In the mean time, it is recommended that JSON payload is used
    to communicate with the commands as inputs or outputs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，SSHd Shell框架有一个限制，只能将一个属性参数传递给命令，但正在进行工作以扩展该功能。在此期间，建议使用JSON有效载荷与命令进行通信，作为输入或输出。
- en: 'The following attributes are available on the annotations:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注解上可用的以下属性：
- en: '`value`: This attribute defines the command or sub-command name. Even though
    the name of the method does not need to match the name of the command, it is a
    good convention for keeping the two in sync to make the code more readable.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：此属性定义了命令或子命令名称。尽管方法名称不需要与命令名称匹配，但将两者保持同步以使代码更易读是一个好习惯。'
- en: '`description`: This attribute defines the text that gets displayed when the `help`
    command is invoked. It is a good place to communicate with the users how the command
    is expected to be used, what inputs it takes, and so on. It is a good idea to
    provide as much description and documentation as possible as in the Shell, one
    would like to clearly educate the users of what needs to happen and how to call
    the command. The man pages are great so keep the documentation top notch.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：此属性定义了在调用 `help` 命令时显示的文本。这是一个与用户沟通如何使用命令、它接受哪些输入等的好地方。在 Shell
    中提供尽可能多的描述和文档是一个好主意，这样用户就可以清楚地了解需要发生什么以及如何调用命令。手册页面很棒，所以请保持文档质量上乘。'
- en: '`roles`: This attribute enables us to define a security constraint on who is
    allowed to execute the given command. If Spring Security is also used, SSHd Shell
    provides the ability to configure a custom or specific `AuthenticationProvider`
    to be used for handling user authentication and role binding. For example, it
    would be easy to connect your application to the company''s LDAP server and allow
    developers to use their regular credentials and also configure different role
    access controls, based on the needs of the particular organization.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles`：此属性使我们能够定义对执行给定命令的权限的安全约束。如果也使用了 Spring Security，SSHd Shell 提供了配置自定义或特定
    `AuthenticationProvider` 的能力，用于处理用户身份验证和角色绑定。例如，连接到公司的 LDAP 服务器并允许开发者使用他们的常规凭证，同时根据特定组织的需要配置不同的角色访问控制将变得非常容易。'
- en: Each command can be queried for its usage by using help, or in the case of a
    command containing sub-commands, by typing the name of the top-level command.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用帮助命令或输入顶级命令的名称来查询每个命令的用法。
- en: While SSHd Shell comes with many built-in commands, one can easily add custom
    commands, taking advantage of standard Spring / Spring Boot programming style,
    using the `@Autowired` and `@Component` annotations to get the necessary dependencies
    to be wired in and automatically configured during the application start life
    cycle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SSHd Shell 内置了许多命令，但我们可以轻松地添加自定义命令，利用标准的 Spring / Spring Boot 编程风格，通过使用 `@Autowired`
    和 `@Component` 注解来获取在应用启动生命周期中自动配置的必要依赖。
- en: SSHd Shell also provides a nice functionality enabling the use of post-processors,
    invoked by a pipe (`|`) symbol. The current support allows for output highlighting `|
    h packt`, which will highlight the word `packt` in the output, or emailing response
    output  `| m` `my@email.com`, which will email the response of a command to the
    specified email address, given that **Spring Mail** is also configured and available.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: SSHd Shell 还提供了一种很好的功能，允许使用通过管道符号 (`|`) 调用的后处理器。当前的支持允许输出高亮 `| h packt`，这将突出显示输出中的单词
    `packt`，或者通过电子邮件发送响应输出 `| m my@email.com`，这将把命令的响应发送到指定的电子邮件地址，前提是 **Spring Mail**
    也已配置并可用。
- en: It would be great if we could chain different commands together, like in Linux
    proper, so as to help process the output and filter out the necessary data when
    the amount of information tends to get overwhelming. Imagine that our publishers
    list command returns not `2`, but `2000` publishers. From this list, we want to
    find the ones that start with `Pa`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将不同的命令链接在一起，就像在 Linux 中那样，这将非常棒，有助于在信息量变得过于庞大时处理输出和过滤必要的数据。想象一下，我们的出版商列表命令返回的不是
    `2`，而是 `2000` 个出版商。从这个列表中，我们想要找到以 `Pa` 开头的那些。
- en: Even though SSHd Shell does not provide this type of functionality out of the
    box, it does offer us an ability to implement our own post-processors by defining
    beans that extend the `BaseUserInputProcessor` class. Let's create one that would
    provide support for filtering JSON responses, something similar to how the `jq`
    command-line utility works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 SSHd Shell 并未提供此类功能作为默认选项，但它确实允许我们通过定义扩展 `BaseUserInputProcessor` 类的 bean
    来实现自己的后处理器。让我们创建一个提供对过滤 JSON 响应的支持的后处理器，类似于 `jq` 命令行工具的工作方式。
- en: 'To achieve this, let''s create another class named `JsonPathUserInputProcessor.java`
    in the `src/main/java/com/example/bookpub/command` directory at the root of our
    project with the following content:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，让我们在项目根目录的 `src/main/java/com/example/bookpub/command` 目录中创建另一个名为 `JsonPathUserInputProcessor.java`
    的类，其内容如下：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using the pipe functionality, we can easily chain the `publishers list` command
    with the `jq` command in the following way:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道功能，我们可以轻松地将 `publishers list` 命令与 `jq` 命令链接起来：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In our example, this should return us only one record, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，这应该只返回一条记录，如下所示：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While it is not a full-fledged pipe functionality, the use of input processors
    allows for adding functionalities such as sorting, filtering, and displaying rendering,
    which give more flexibility to modularize and reuse common behaviors.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不是完整的管道功能，但输入处理器的使用允许添加诸如排序、过滤和显示渲染等功能，这为模块化和重用常见行为提供了更多灵活性。
- en: 'The SSHd Shell Spring Boot integration comes with a number of configuration
    options allowing us to disable the component, configure authentication settings,
    and specify usernames, passwords, and even key certificates. For example, if we
    want to use a specific username and password, we can do so by configuring the
    following properties:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: SSHd Shell Spring Boot集成提供了一些配置选项，允许我们禁用组件、配置身份验证设置以及指定用户名、密码，甚至密钥证书。例如，如果我们想使用特定的用户名和密码，我们可以通过配置以下属性来实现：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In a real-world enterprise environment, it is more common to use the shared
    keys for restricted access and these can be configured using the `sshd.shell.publicKeyFile=<key
    path>` or `sshd.shell.hostKeyFile=<key path>` properties. Alternatively, and probably
    a better approach, as was already mentioned earlier, using a custom `AuthenticationProvider`
    implementation together with Spring Security allows the integrate of authentication
    mechanisms into the company's authentication system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的企业环境中，更常见的是使用共享密钥进行受限访问，这些可以通过`sshd.shell.publicKeyFile=<key path>`或`sshd.shell.hostKeyFile=<key
    path>`属性进行配置。或者，正如之前已经提到的，使用自定义的`AuthenticationProvider`实现与Spring Security结合使用，可以将身份验证机制集成到公司的身份验证系统中。
- en: Integrating Micrometer metrics with Graphite
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Micrometer指标与Graphite集成
- en: Earlier in this chapter, you learned about the monitoring capabilities that
    are provided by Spring Boot. We saw examples of writing custom `HealthIndicators`,
    creating metrics, and using `MeterRegistry` to emit data. The simple Spring Boot
    Admin Web framework gave us some nice graphical UI to visualize the data, but
    all of these metrics were in-the-moment, with no long-term retention and historical
    access. Not being able to observe the trends, detect the deviations from the baseline,
    and compare today with last week is not a very good strategy, especially for an
    enterprise-complex system. We all want to be able to have access to the time series
    data going weeks, if not months, back and set up alarms and thresholds, if something
    goes unplanned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你学习了Spring Boot提供的监控能力。我们看到了编写自定义`HealthIndicators`、创建指标以及使用`MeterRegistry`来发射数据的示例。简单的Spring
    Boot Admin Web框架为我们提供了一些很好的图形用户界面来可视化数据，但这些指标都是即时的，没有长期保留和历史访问。无法观察趋势、检测基准线的偏差以及将今天与上周进行比较并不是一个好的策略，尤其是对于企业级复杂系统来说。我们都希望能够访问过去几周甚至几个月的时间序列数据，并在出现意外情况时设置警报和阈值。
- en: 'This recipe will introduce us to an amazing time series graphical tool: Graphite.
    Graphite is a two-part system. It provides storage for numeric time series data
    as well as a service to render this data in a form of on-demand graphs or expose
    the graph data as a JSON stream. You will learn how to integrate and configure
    Spring''s Micrometer monitoring framework with Graphite in order to send the monitoring
    data from a Spring Boot application to Graphite and play a bit with Graphite to
    visualize the different statistics that we''ve gathered.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向我们介绍一个惊人的时间序列图形工具：Graphite。Graphite是一个两部分的系统。它为数值时间序列数据提供存储，并提供一个服务以按需图形或以JSON流的形式公开这些数据。你将学习如何将Spring的Micrometer监控框架与Graphite集成和配置，以便将Spring
    Boot应用程序的监控数据发送到Graphite，并稍微玩一下Graphite来可视化我们所收集的不同统计数据。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Graphite is an application that is written in Python and is, thus, capable of
    running on virtually any system supporting Python and its libraries. There are
    multiple ways of installing Graphite on any given system, ranging from compilation
    from a source, using `pip` all the way, to prebuilt RPMs for various Linux distributions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Graphite是一个用Python编写的应用程序，因此能够在几乎任何支持Python及其库的系统上运行。在给定的系统上安装Graphite有多种方式，从从源代码编译，使用`pip`，到为各种Linux发行版预构建的RPM。
- en: For all the different installation strategies, take a look at the Graphite documentation
    at [http://graphite.readthedocs.org/en/latest/install.html](http://graphite.readthedocs.org/en/latest/install.html).
    OS X users can read a very good step-by-step guide located at [https://gist.github.com/relaxdiego/7539911](https://gist.github.com/relaxdiego/7539911).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有不同的安装策略，请查看Graphite文档在[http://graphite.readthedocs.org/en/latest/install.html](http://graphite.readthedocs.org/en/latest/install.html)。OS
    X用户可以阅读位于[https://gist.github.com/relaxdiego/7539911](https://gist.github.com/relaxdiego/7539911)的一个非常好的分步指南。
- en: 'For the purposes of this recipe, we will use a premade Docker container containing
    Graphite as well as its counterpart Grafana. While there is an abundance of various
    prebuilt variants of Docker images containing combinations of Graphite and Grafana,
    we will use the one from [https://registry.hub.docker.com/u/alexmercer/graphite-grafana/](https://registry.hub.docker.com/u/alexmercer/graphite-grafana/)
    as it contains all the right configurations that will make it easy for us to get
    started quickly:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，我们将使用一个包含Graphite及其对应Grafana的预制Docker容器。虽然有许多预制的Docker镜像包含Graphite和Grafana的组合，但我们将使用来自[https://registry.hub.docker.com/u/alexmercer/graphite-grafana/](https://registry.hub.docker.com/u/alexmercer/graphite-grafana/)的一个，因为它包含所有正确的配置，这将使我们能够快速开始：
- en: The first step will be to download the desired Docker container image. We will
    do this by executing `docker pull alexmercer/graphite-grafana`. The container
    size is about 500 MB; so the download might take a few minutes depending on your
    connection speed.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步将是下载所需的Docker容器镜像。我们将通过执行`docker pull alexmercer/graphite-grafana`来完成此操作。容器大小约为500
    MB；因此，下载可能需要几分钟，具体取决于你的连接速度。
- en: Both Graphite and Grafana store their data in the database files. We will need
    to create external directories, which will reside outside the container, and we
    will connect them to a running instance via Docker data volumes.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Graphite和Grafana都将它们的数据存储在数据库文件中。我们需要创建外部目录，这些目录将位于容器外部，并且我们将通过Docker数据卷将它们连接到一个正在运行的实例。
- en: Make a directory for the Graphite data anywhere in your system, for example,
    in `<user_home>/data/graphite`.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的系统中的任何位置创建一个Graphite数据目录，例如，在`<user_home>/data/graphite`。
- en: Make a directory for the Grafana data, for example, in `<user_home>/data/grafana`.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`<user_home>/data/grafana`创建一个Grafana数据目录。
- en: In this container, the Graphite data will go to `/var/lib/graphite/storage/whisper`,
    while Grafana stores its data in `/usr/share/grafana/data`. So, we will use these
    paths as internal volume mount destinations when starting the container.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个容器中，Graphite数据将存储在`/var/lib/graphite/storage/whisper`，而Grafana将数据存储在`/usr/share/grafana/data`。因此，我们将使用这些路径作为启动容器时的内部卷挂载目标。
- en: Run the container by executing `docker run -v <user_home>/data/graphite:/var/lib/graphite/storage/whisper
    -v <user_home>/data/grafana:/usr/share/grafana/data -p 2003:2003 -p 3000:3000
    -p 8888:80 -d alexmercer/graphite-grafana`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`docker run -v <user_home>/data/graphite:/var/lib/graphite/storage/whisper
    -v <user_home>/data/grafana:/usr/share/grafana/data -p 2003:2003 -p 3000:3000
    -p 8888:80 -d alexmercer/graphite-grafana`来运行容器。
- en: In Docker, the `-v` option configures a volume mount binding. In our example,
    we configured the external `<user_home>/data/graphite` directory to be the same
    as the `/var/lib/graphite/storage/whisper` directory reference in the container.
    The same goes for the `<user_home>/data/grafana` mapping. We can even look in
    the `<user_home>/data/graphite or data/grafana` directories to see them contain
    the subdirectories and files.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中，`-v`选项配置卷挂载绑定。在我们的示例中，我们将外部`<user_home>/data/graphite`目录配置为与容器中`/var/lib/graphite/storage/whisper`目录引用相同。同样适用于`<user_home>/data/grafana`映射。我们甚至可以在`<user_home>/data/graphite`或`data/grafana`目录中查看它们包含的子目录和文件。
- en: 'The `-p` option configures the port mappings similar to the directory volumes.
    In our example, we mapped the following three different ports to be accessible
    from outside the container to the internal ports to which the various services
    are bound:'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`选项配置端口映射，类似于目录卷。在我们的示例中，我们将以下三个不同的端口映射为从容器外部可访问的内部端口，这些端口绑定到各种服务：'
- en: '`2003:2003`: This port mapping externalizes the Graphite data stream listener
    known as **Carbon-Cache Line Receiver**, to which we will connect in order to
    send the metrics data.'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`2003:2003`：这个端口映射将Graphite数据流监听器（称为**Carbon-Cache Line Receiver**）外部化，我们将连接到它以发送指标数据。'
- en: '`3000:3000`: This port mapping externalizes the Grafana Web Dashboard UI, which
    we will use to create visual dashboards on top of the Graphite data.'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`8888:80`: This port mapping externalizes the Graphite Web UI. Though it is
    running on port `80` in the container, it is unlikely that on our development
    machine, port `80` is open; so it is better to map it to some other higher number
    port such as `8080` or `8888` in our case, as `8080` is already taken by our `BookPub`
    application.'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If everything has gone according to the plan, Graphite and Grafana should be
    up and running and thus, we can access Graphite by pointing our browser to `http://localhost:8888`
    and we should see the following output:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1714b0f1-661c-4b52-ae20-2779dbb1d2d7.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'To see Grafana, point the browser to `http://localhost:3000` so as to see the
    following output:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8dae836b-455e-477f-a3f0-8dd6870e0883.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: The default login and password for Grafana are `admin`/`admin` and can be changed
    via the Web UI Admin.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the OS X users who use boot2docker, the IP would not be of the `localhost`,
    but rather a result of the boot2docker IP call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are in Grafana, we will need to add our Graphite instance as `DataSource`,
    so click on the icon, go to Data Sources, and add a new source of the `Type Graphite,
    Url http://localhost:80, Access`  proxy:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfda06db-afca-4e90-bf61-8cdd8e23eec9.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Graphite and Grafana up and running, we are now ready to start configuring
    our application in order to send the metrics to the Graphite listener on port
    `2003`. To do this, we will use the Codahale/Dropwizard metrics library, which
    is fully supported by Spring Boot and thus requires a minimum amount of configuration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing on our list is to add the necessary library dependencies. Extend
    the dependencies block in the `build.gradle` file with the following content:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a file named `MonitoringConfiguration.java` in the `src/main/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will also need to add the configuration property settings for our Graphite
    instance to the `application.properties` file in the `src/main/resources` directory
    at the root of our project:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let's build and run our application by executing `./gradlew clean bootRun`
    and if we have configured everything correctly, it should start without any issues.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the application up and running, we should start seeing some data that is
    in the Graphite and `bookpub` data nodes getting added to the tree under metrics.
    To add some more realism, let's open our browser and load a book URL, `http://localhost:8080/books/978-1-78528-415-1/`,
    a few dozen times to generate some metrics.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and look at some of the metrics in Graphite and set the data
    time range to 15 minutes in order to get some close-look graphs, which will look
    similar to the following screenshot:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d7ccfc50-6bb0-40c8-a426-a3a92e5f7311.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'We can also create some fancy looking dashboards using this data in Grafana
    by creating a new dashboard and adding a Graph panel, as shown in the following
    screenshot:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac6f0880-0768-48bb-a84e-7dd6dee1ffd9.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'The newly created Graph panel will look like this:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2840eb11-b5f1-4535-9534-ad4a4dac34ea.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'Click on the no title (click here) label, choose edit, and enter the metric
    name `bookpub.app.http.server.requests.exception.None.method.GET.status.200.uri._books__isbn_.count`
    in the text field as shown in the following screenshot:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/398fcd94-9ce8-4ef1-8243-8a5bec4e6c00.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Clicking on Dashboard will take you out of the edit mode.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a more detailed tutorial, visit [http://docs.grafana.org/guides/gettingstarted/](http://docs.grafana.org/guides/gettingstarted/).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable exporting metrics via Graphite, we added an extra dependency on the `io.micrometer:micrometer-registry-graphite`
    library. Under the hood, however, it depends on the Dropwizard metrics library
    to provide Graphite integration, so it will add the following new dependencies
    to our `build` file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`io.dropwizard.metrics:metrics-core`: This dependency adds the basic Dropwizard
    functionality, `MetricsRegistry`, common API interfaces, and base classes. This
    is the bare minimum that is required to get Dropwizard working and integrated
    into Spring Boot to handle the metrics.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.dropwizard.metrics:metrics-graphite`: This adds support for `GraphiteReporter`
    and is needed in order to configure Dropwizard to send the monitoring data that
    it collects to our Graphite instance.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to keep things clean and nicely separated, we created a separate configuration
    class with all the monitoring-related beans and settings: `MonitoringConfiguration`.
    In this class, we configured three `@Bean` instances: a custom `MeterRegistryCustomizer` implementation
    to customize the `GraphiteMeterRegistry` instance, `HigherarchicalNameMapper`,
    and `NamingConvention` to go along with it.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we had to create our own customization is twofold. We wanted
    to comply with the classic Graphite metric naming scheme, which uses the dot (`.`)
    notation to separate metric names in a hierarchy. Unfortunately, for whatever
    reason, Micrometer Graphite implementation has opted for using the `camelCase`
    collapsing notation instead, which made metric names like `counter.datasource.BookRepository`
    translate into the `counterDatasourceBookRepository` name to be displayed inside
    Graphite. Having such a long name, without hierarchical tree makes for a very
    difficult search and discovery inside Graphite UI, when many metrics are present.
    Also, all the metrics get placed under a root (`/`) tree, without creating a dedicated
    application folder, which also leads to poor readability and usage. We have added
    code to our `HigherarchicalNameMapper` instance to prepend the application prefix
    to all the metrics being exported to Graphite so that they all get put into `subtree:
    /bookpub/app/*.`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `NamingConvention` provides precise configuration about how to convert particular
    Meter names, keys, values, and tags into proper Graphite variants. Inside the `format(String
    name)` method, we declare that we want to use a dot (`.`) separation between elements
    via the `NamingConvention.dot` implementation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamingConvention` 提供了关于如何将特定的度量名称、键、值和标签转换为适当的 Graphite 变体的精确配置。在 `format(String
    name)` 方法中，我们声明我们想要使用点（`.`）分隔元素，通过 `NamingConvention.dot` 实现来执行。'
- en: The `management.metrics.export.graphite` group of properties define how to send
    the data to the Graphite instance. We configured it to do so every 1 minute, translate
    all the time duration intervals, such as the latency measurements, into milliseconds
    and all the variable rates, such as the number of requests per some time frame,
    into seconds. Most of these values have their default configuration settings for
    Graphite provided, but can be changed, if desired.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`management.metrics.export.graphite` 属性组定义了如何将数据发送到 Graphite 实例。我们配置它每分钟这样做一次，将所有时间间隔，如延迟测量，转换为毫秒，以及所有变量速率，如某些时间框架内的请求数量，转换为秒。大多数这些值都有
    Graphite 提供的默认配置设置，但如果需要，可以更改。'
- en: Notice that we've used the `@ConditionalOnClass` annotation to indicate that
    we only want to apply this `@Configuration` if the Micrometer Graphite provided
    class `GraphiteMeterRegistry.class` is present in the classpath. This is needed
    to not try to instantiate Graphite beans during tests, as there might not be a
    Graphite instance running and available in the testing environment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `@ConditionalOnClass` 注解来指示我们只想在 Micrometer Graphite 提供的类 `GraphiteMeterRegistry.class`
    存在于类路径上时应用此 `@Configuration`。这是必要的，以避免在测试期间尝试实例化 Graphite bean，因为在测试环境中可能没有运行并可供使用的
    Graphite 实例。
- en: As you can see from the available metrics from Graphite UI, there are many metrics
    that are provided out of the box. Some notable ones are about JVM and OS metrics,
    which expose the memory and thread metrics to Graphite in the memory and threads
    data nodes among other data. They can be found in `Metrics/bookpub/app/jvm`, `Metrics/bookpub/app/process`,
    or `Metrics/bookpub/app/system` in the Graphite tree.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 Graphite UI 可用的指标中可以看到，有许多指标是开箱即用的。其中一些值得注意的是关于 JVM 和 OS 指标，它们将内存和线程指标暴露在内存和线程数据节点中的其他数据中。它们可以在
    Graphite 树中的 `Metrics/bookpub/app/jvm`、`Metrics/bookpub/app/process` 或 `Metrics/bookpub/app/system`
    中找到。
- en: Micrometer core library provides a number of meter binders for additional system
    metrics. If there is a need to export things like thread or executor information,
    or get a view into the file descriptors, one can export additional beans by simply
    declaring a method returning `new JvmThreadMetrics()` or `new FileDescriptorMetrics()` for
    example.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer 核心库提供了一系列用于额外系统指标的度量绑定器。如果需要导出诸如线程或执行器信息之类的数据，或查看文件描述符，可以通过简单地声明一个返回
    `new JvmThreadMetrics()` 或 `new FileDescriptorMetrics()` 等的方法来导出额外的 bean。
- en: The running application will gather all the metrics registered with `MeterRegistry`
    and every configured exporter (in our case, `GraphiteMeterRegistry`) reports all
    these metrics at a timed interval to its destination. The proper exporter implementations
    run in a separate `ThreadPool`, thus outside of the main application threads and
    not interfering with them. However, this should be kept in mind in case the Meter
    implementations use some `ThreadLocal` data internally, which would not be available
    to exporters.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的应用程序将收集所有注册到 `MeterRegistry` 的指标以及每个配置的导出器（在我们的案例中，`GraphiteMeterRegistry`）在定时间隔内向其目的地报告所有这些指标。适当的导出器实现运行在单独的
    `ThreadPool` 中，因此不在主应用程序线程之外，也不会干扰它们。然而，如果度量实现内部使用某些 `ThreadLocal` 数据，则应记住这一点，因为这些数据对导出器不可用。
- en: Integrating Micrometer metrics with Dashing
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Micrometer 指标与 Dashing 集成
- en: The previous recipe has given us a glimpse of how we can collect the various
    metrics from our application during its runtime. We've also seen how powerful
    the ability to visualize this data as a set of graphs of historical trends can
    be.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方让我们窥见了如何在应用程序运行时收集各种指标。我们还看到了将此数据可视化为一系列历史趋势图的能力是多么强大。
- en: While Grafana and Graphite offer us the very powerful capability of manipulating
    the data in the form of graphs and building elaborate dashboards that are full
    of thresholds, applied data functions, and much more, sometimes we want something
    simpler, more readable, and something widgety. This is exactly the kind of dashboard
    experience that is provided by Dashing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Dashing** is a popular dashboard framework developed by Shopify and written
    in Ruby/Sinatra. It provides you with an ability to create an assortment of dashboards
    that are comprised of different types of widgets. We can have things such as graphs,
    meters, lists, numeric values, or just plain text to display the information.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will install the Dashing framework, learn how to create dashboards,
    send and consume the data to report from an application directly as well as fetch
    it from Graphite, and use the Dashing API to push the data to the Dashing instance.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get Dashing to run, we will need to have an environment that has
    a Ruby 1.9+ installed with RubyGems.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Typically, Ruby should be available on any common distribution of Linux and
    OS X. If you are running Windows, I would suggest using [http://rubyinstaller.org](http://rubyinstaller.org)
    in order to get the installation bundle.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have such an environment available, we will install Dashing and create
    a new dashboard application for our use, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Installing Dashing is very easy; simply execute the gem install dashing command
    to install Dashing RubyGems on your system.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the RubyGem successfully installed, we will create the new dashboard named
    `bookpub_dashboard` by executing the dashing new `bookpub_dashboard` command in
    the directory where you want the dashboard application to be created.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the dashboard application has been generated, go to the `bookpub_dashboard`
    directory and execute the `bundle` command to install the required dependency
    gems.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the gems bundle has been installed, we can start the dashboard application
    by executing the `dashing start` command and then pointing our browser to `http://localhost:3030`
    to see the following result:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10c6167a-a909-4e1a-a0d7-dbb50453f232.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look carefully at the URL of our shiny new dashboard, you will see that
    it actually says `http://localhost:3030/sample` and displays a sample dashboard
    that was automatically generated. We will use this sample dashboard to make some
    changes in order to display some metrics from our application directly as well
    as get some raw metrics from the Graphite data API endpoint.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to connect the data from the application `/actuator/metrics`
    endpoint so as to display it in the Dashing dashboard, we will change the `Buzzwords`
    widget to display the counts of our data repositories, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, we will need to add the `'httparty', '>= 0.13.3'` gem to the `Gemfile`
    file located in the `bookpub_dashboard` directory, which will enable us to use
    an HTTP client in order to extract the monitoring metrics from the HTTP endpoints.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the gem, run the `bundle` command one more time to install the
    newly added gem.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will need to modify the `sample.erb` dashboard definition located in
    the `bookpub_dashboard/dashboards` directory, replacing `<div data-id="buzzwords"
    data-view="List" data-unordered="true" data-title="Buzzwords" data-moreinfo="#
    of times said around the office"></div>` with `<div data-id="repositories" data-view="List"
    data-unordered="true" data-title="Repositories Count" data-moreinfo="# of entries
    in data repositories"></div>`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the widget replaced, we will create a new data provisioning job file named
    `repo_counters.rb` in the `bookpub_dashboard/jobs` directory with the following
    content:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With all the code changes in place, let''s start our dashboard by executing
    the `dashing start` command. Go to `http://localhost:3030/sample` in the browser
    to see our new widget displaying the data as shown in the following icon:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b360ec9-ce6b-4d45-ba47-bc3f576b422f.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: If we use the remote Shell to log in to the application, as we did earlier in
    this chapter, and add a publisher, we would see the counter on the dashboard increase.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to push the data to the dashboard is to use their RESTful API.
    Let''s update the text in the top left text widget by executing `curl -d ''{ "auth_token":
    "YOUR_AUTH_TOKEN", "text": "My RESTful dashboard update!" }'' http://localhost:3030/widgets/welcome`.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything has worked correctly, we should see the text updated to our new
    value, `My RESTful dashboard update!`, under the Hello title.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In an environment where multiple instances of the same application kind are
    running, it is probably not a good idea to directly pull the data from each node,
    especially if they are very dynamic and can come and go as they please. It is
    advised that you consume the data from a more static and well-known location,
    such as a Graphite instance. To get a demonstration of volatile data metrics,
    we will consume the memory pool data for the `Eden`, `Survivor`, and `OldGen`
    spaces and display them instead of the Convergence, Synergy, and Valuation graph
    dashboards. We will start by replacing the content of the `sample.rb` job file
    located in the `bookpub_dashboard/jobs` directory with the following content:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `sample.erb` template located in the `bookpub_dashboard/dashboards`
    directory, we will replace the Synergy, Valuation, and Convergence graphs with
    the following alternatives:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<div data-id="synergy" data-view="Meter" data-title="Synergy" data-min="0"
    data-max="100"></div>` gets replaced with `<div data-id="heap_survivor" data-view="Meter"
    data-title="Heap: Survivor" data-min="0" data-max="100" data-moreinfo="In megabytes"></div>`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<div data-id="valuation" data-view="Number" data-title="Current Valuation"
    data-moreinfo="In billions" data-prefix="$"></div>` gets replaced with `<div data-id="heap_oldgen"
    data-view="Number" data-title="Heap: OldGen" data-moreinfo="In bytes" ></div>`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<div data-id="convergence" data-view="Graph" data-title="Convergence" style="background-color:#ff9618"></div>`
    gets replaced with `<div data-id="heap_eden" data-view="Graph" data-title="Heap:
    Eden" style="background-color:#ff9618" data-moreinfo="In bytes"></div>`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After all the changes are made, we can restart the dashboard application and
    reload our browser to `http://localhost:3030` to see the following result:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37b6ceef-0e4a-4208-9b87-67d91838806b.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have seen how to extract the data directly from our application
    and via Graphite, and render it using the Dashing dashboard as well as pushing
    information directly to Dashing using their RESTful API. It is no secret that
    it is better to see something once than hear about it seven times. This is true
    when it comes to trying to get a holistic picture of the key metrics that represent
    how the systems behave at runtime and to be able to act on the data quickly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going in to great detail about the internals of Dashing, it is still
    important to mention a few things about how data gets in to Dashing. This can
    happen in the following two ways:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheduled jobs**: This is used to pull data from the external sources'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESTful API**: This is used to push data to Dashing from outside'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scheduled jobs are defined in the jobs directory in the generated dashboard
    application. Each file has a piece of ruby code wrapped in the `SCHEDULER.every`
    block, which computes the data points and sends an event to an appropriate widget
    with the new data for an update.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'In our recipe, we created a new job named `repo_counters.rb` where we used
    the `httparty` library in order to make a direct call to our application instance''s
    `/actuator/metrics/#{name}` endpoint and extracted the counters for each of the
    predefined repositories. Looping over the metrics, we created a `repo_counts`
    collection with data for each repository containing a label display and a value
    count. The resulting collection was sent to the repositories widget for an update
    in the form of `event: send_event(''repositories'', { items: repo_counts })`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We configured this job to get executed every 10 seconds, but if the rate of
    data change is not very frequent, the number can be changed to a few minutes or
    even hours. Every time the scheduler runs our job, the repositories widget is
    updated via the client-side websockets communication with the new data. Looking
    in dashboards/`sample.erb`, we can find the widget's definition using `data-id="repositories"`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Besides adding our own new job, we also changed the existing `sample.rb` job
    to pull data from Graphite using Graphite's RESTful API to populate the different
    types of widgets in order to display the memory heap data. As we were not pulling
    data directly from the application instance, it was a good idea not to put the
    code in the same job because the jobs could—and in our case, do—have different
    time intervals. As we send data to Graphite only once every minute, it does not
    make sense to pull it any less frequently than this.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the data out of Graphite, we used the following API call:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Take a look at the following parameters mentioned in the preceding code snippet:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '`target`: This parameter is a repeated value that defines a list of all the
    different metrics that we want to retrieve.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from`: This parameter specifies the time range; in our case, we asked for
    data going back 11 minutes to.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: This parameter configures the desired output format. We chose JSON
    but many others are available. Refer to [http://graphite.readthedocs.org/en/latest/render_api.html#format](http://graphite.readthedocs.org/en/latest/render_api.html#format).'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxDataPoints`: This parameter indicates how many entries we want to get.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason we asked for 11 entries and not 10 is due to a frequent occurrence
    where the last entry of short-ranged requests, which consist of only a few minutes,
    sometimes get returned as empty. We just use the first 10 entries and ignore the
    most recent ones to avoid weird data visualization.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating over the target data, we will populate the appropriate widgets such
    as `heap_eden`, `heap_survivor`, and `heap_oldgen`, with their designated data,
    as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '`heap_eden`: This is a `Graph` widget, as defined in the `sample.erb` template
    in the form of a `data-view="Graph" ` attribute, so it wants a data input in the
    form of the points collection containing a value for `x` and `y`. The `x` value
    represents a timestamp, which conveniently gets returned to us by Graphite and
    is automatically converted to the minutes display value by the Graph widget. The
    `y` value represents the memory pool utilization in bytes. As the value from Graphite
    is in the form of a decimal number, we will need to convert it to a whole number
    so as to make it look better.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heap_survivor`: This is a `Meter` widget, as defined in the `sample.erb` template
    in the form of a `data-view="Meter"` attribute, so it wants a data input as a
    simple value number between a template configured range. In our case, the range
    is set as the `data-min="0" data-max="100"` attribute. Even though we chose to
    round the number to two decimal positions, it could probably just be an integer
    as it is precise enough for the purpose of a dashboard display. You will also
    notice that inside `sample.rb`, we convert the raw value, which is in bytes, into
    megabytes, for better readability— `current_survivor = current_survivor / 1048576`.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heap_oldgen`: This is a `Number` widget, as defined in the `sample.erb` template
    in the form of a `data-view="Number"` attribute, so it wants a data input as a
    current value and optionally a last value; in this case, a percentage change with
    the change direction will be displayed as well. As we get the last 10 entries,
    we have no issues in retrieving both the current and last values so we can easily
    satisfy this requirement.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we also experimented with Dashing''s RESTful API by trying
    to use a `curl` command to update the value of the welcome widget. This was a
    push operation and can be used in situations where there is no data API exposed,
    but you have the capability of creating some sort of a script or piece of code
    that could send the data to Dashing instead. To achieve this, we used the following
    command: `curl -d ''{ "auth_token": "YOUR_AUTH_TOKEN", "text": "My RESTful dashboard
    update!" }'' http://localhost:3030/widgets/welcome`.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dashing API accepts data in a JSON format, sent via a POST request that
    contains the following parameters needed for the widgets as well as the widget
    ID, which is a part of the URL path itself:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '`auth_token`: This allows for a secure data update and can be configured in
    the dashboard root directory in the `config.ru` file.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: This is a `widget` property that is being changed. As we are updating
    a `Text` widget, as defined in the `sample.erb` template in the form of a `data-view="Text"`
    attribute, we need to send it to text to update.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/widgets/<widget id>`: This URL path identifies the particular widget where
    the update is destined to. The `id` corresponds to a declaration in the `sample.erb`
    template. In our case, it looks like `data-id="welcome"`.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of the various widgets can also be manipulated and a very rich
    collection of the various widgets has been created by the community, which is
    available at [https://github.com/Shopify/dashing/wiki/Additional-Widgets](https://github.com/Shopify/dashing/wiki/Additional-Widgets).
    The widgets get installed in the widgets directory in the dashboard and can be
    installed by simply running `dashing install <GIST>`, where `GIST` is the hash
    of the GitHub Gist entry.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard template files, similar to our `sample.erb` template, can be modified
    in order to create the desired layout for each particular dashboard as well as
    multiple dashboard templates, which can be rotated or directly loaded manually.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Each dashboard represents a grid in which the various widgets get placed. Each
    widget is defined by a `<div>` entry with the appropriate configuration attributes
    and it should be nested in the `<li>` grid element. We can use the data element
    attributes to control the positioning of each widget in the grid, which is as
    follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '`data-row`: This represents the row number where the widget should be positioned'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-col`: This represents the column number where the widget should be positioned'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-sizex`: This defines the number of columns the widget will span horizontally'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-sizey`: This defines the number of rows the widget will span vertically'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existing widgets can be modified to change their look and feel as well as
    extend their functionality; so the sky is the limit for what kind of information
    display we can have. You should definitely check out [http://dashing.io](http://dashing.io)
    for more details.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
