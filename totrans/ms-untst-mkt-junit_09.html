<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;Solving Test Puzzles"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Solving Test Puzzles</h1></div></div></div><div class="blockquote"><blockquote class="blockquote1"><p class="calibre20">"We make a living by what we get, but we make a life by what we give."</p><p class="calibre20">—Winston Churchill</p></blockquote></div><p class="calibre9">You may have worked in greenfield development projects that were written using <span class="strong"><strong class="calibre10">test-driven development</strong></span> (<span class="strong"><strong class="calibre10">TDD</strong></span>) and also in brownfield development or maintenance projects that were not written with TDD. You must have noticed<a id="id669" class="calibre1"/> that the test-first code written with TDD is easier to extend than the code with no unit test or unit tests written after coding.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre9">A greenfield project <a id="id670" class="calibre1"/>starts building from scratch and doesn't consider any prior work.</p><p class="calibre9">A brownfield project is an<a id="id671" class="calibre1"/> extension of prior work or rebuilding a project from an existing project.</p></div><p class="calibre9">This chapter covers the importance of unit testing in greenfield and brownfield projects. The following topics are covered in depth:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Working with legacy code</li><li class="listitem">Designing for testability</li><li class="listitem">Working with greenfield code</li></ul></div><p class="calibre9">The <span class="strong"><em class="calibre11">Working with legacy code</em></span> section covers the legacy code and explains how to unit test and refactor the legacy code. The <span class="strong"><em class="calibre11">Designing for testability</em></span> section explains how to design for testability. The <span class="strong"><em class="calibre11">Working with greenfield code</em></span> section elaborates on TDD, the TDD life cycle, refactoring, and concludes with an example of TDD.</p></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Solving Test Puzzles">
<div class="book" title="Working with the legacy code"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec48" class="calibre1"/>Working with the legacy code</h1></div></div></div><p class="calibre9">The term <span class="strong"><strong class="calibre10">legacy</strong></span> is frequently used, as slang, to describe complex code, which is difficult to understand, is rigid and fragile in nature, and is almost impossible to enhance.</p><p class="calibre9">However, the fact is that any code with no automated unit tests is legacy code. A piece of code can be well written. It can also follow coding guidelines, might be easy to understand, can be clean, loosely coupled, and very easy to extend. However, if it doesn't have automated unit tests, then it is legacy code.</p><p class="calibre9">Statistically, fixing bugs or adding new features to a legacy project is quite difficult than doing the same to a greenfield project. In legacy code, either automated unit tests do not exist or very few tests are written; the code is not designed for testability.</p><p class="calibre9">We inherit legacy code from some other source, maybe from a very old project, from another team that cannot maintain the code, or we acquire it from another company, but it is our duty to improve the quality.</p><p class="calibre9">Unit tests give us some level of assurance that our code is doing what the code is expected to do, and they allow us to change the code quickly and verify the change faster.</p><p class="calibre9">In general, legacy code is not<a id="id672" class="calibre1"/> testable and requires changes to the code structure (refactoring) to make it testable. However, the dilemma, most of the time, is that the legacy system is so crucial to the business that no one dares to touch the code. It makes no sense to modify an existing crucial module unless something is seriously wrong. Stalemate! You cannot refactor the code unless you have the automated test suite, and you cannot write tests as the code needs refactoring.</p><p class="calibre9">Sometimes it feels as though the legacy code, even with unit tests, are hard to understand, maintain, and enhance; hence, we need to be careful to make our tests readable and to avoid close coupling with the actual implementation details.</p></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Solving Test Puzzles">
<div class="book" title="Working with the legacy code">
<div class="book" title="Working with testing impediments"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec44" class="calibre1"/>Working with testing impediments</h2></div></div></div><p class="calibre9">This section explains the nature or quality of code that makes unit testing difficult. Automated tests<a id="id673" class="calibre1"/> help us develop software quickly even when we have a large code base to work on. However, automated<a id="id674" class="calibre1"/> tests should be executed very fast so that tests<a id="id675" class="calibre1"/> can give us quick feedback. We cannot unit test code when it exhibits any of the following features:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It performs long running operations</li><li class="listitem">It connects to a database and modifies database records</li><li class="listitem">It performs remote computing</li><li class="listitem">It looks up JNDI resources or web/app server objects</li><li class="listitem">It accesses the filesystem</li><li class="listitem">It works with native objects or graphical widgets (UI components, alert, Java Swing components, and so on)</li><li class="listitem">It accesses network resources such as the LAN printer and downloads data from the Internet</li></ul></div><p class="calibre9">Unit tests should<a id="id676" class="calibre1"/> not wait for a long running process to complete; it will defeat the purpose of quick feedback.</p><p class="calibre9">Unit tests<a id="id677" class="calibre1"/> should be reliable, and they should fail if and only if the production code is broken. However, if your unit test verifies an I/O operation, such as connecting to a LAN printer, which is slow, error prone, and unpredictable, then your unit test may fail due to some network issue, but it will incorrectly signal that the code is broken. So, unit testing a network operation defeats<a id="id678" class="calibre1"/> the test reliability principle.</p><p class="calibre9">Unit tests run automatically, so it doesn't make any sense to open a modal dialog or show an alert message during test execution because the test will wait, unless the UI dialog or the alert is closed.</p><p class="calibre9">So, the preceding features in the production code are barriers during unit testing. The following example shows how to avoid test impediments:</p><div class="informalexample"><pre class="programlisting">public class MovieTicketPro {

 public void book(Movie movie, ShowTime time, int noOfTickets) {
  MovieDao dao = new MovieDao();
  MovieHall hall = dao.findMovie(movie, time);
  if (hall != null) {
    List&lt;String&gt; seats = dao.getAvilableSeats(movie, time);
    if (seats.size() &lt; noOfTickets) {
      BookingErrorController.createAndShowTicketNotAvailableError();
      return;
    }
    int booked = 0;
    String bookedSeats = "";
    for (String aSeat : seats) {
      try {
        dao.book(hall, time, aSeat);
        bookedSeats += " " + aSeat;
        booked++;
        if (booked == noOfTickets) {
          BookingErrorController.createAndShowBookedMsg(bookedSeats);
          break;
        }
      } catch (BookingException e) {
        if (e.getType().equals(ErrorType.SeatAlreadyBooked)) {
          BookingErrorController.createAndShowTicketNotAvailableError();
          if (BookingErrorController.createAndShowAdjacentSeatsNotAvaialble()){
            continue;
          }
          break;
        }
      } catch (Exception e) {
        BookingErrorController.createAndShowDatabaseSaveError();
        break;
      }
    }
  }else{
    BookingErrorController.createAndShowMovieOrShowTimeNotAvailableError();
  }
}</pre></div><p class="calibre9">The <code class="literal">book()</code> method <a id="id679" class="calibre1"/>in the preceding example takes a movie, a show time, and the number of tickets to book, and it books the tickets or shows an error message. If an invalid movie or show time is passed to the <code class="literal">book</code> method, it shows an error message that states the movie or <a id="id680" class="calibre1"/>show time is not available. The following is<a id="id681" class="calibre1"/> the ticket booking logic:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, the book method finds a movie hall for the movie and the movie's show time, for example, the movie <span class="strong"><em class="calibre11">The HOBBIT</em></span>, with show time <span class="strong"><em class="calibre11">Evening</em></span> is being screened in <span class="strong"><em class="calibre11">SCREEN 2</em></span>. If the movie is not being played, an error message is shown.</li><li class="listitem" value="2">It then retrieves the available seats, for example, 40 seats are available in <span class="strong"><em class="calibre11">SCREEN 2</em></span> in the evening.</li><li class="listitem" value="3">If the requested numbers of seats are greater than the available number of seats, an error message is shown, for example, request for 10 tickets but only two seats available.</li><li class="listitem" value="4">If the seats requested are available, then it loops through the seats and books them.</li><li class="listitem" value="5">If any error occurs during seat booking, such as someone concurrently books the seat or some runtime<a id="id682" class="calibre1"/> error occurs, the relevant error message is displayed.</li></ol><div class="calibre17"/></div><p class="calibre9">The <code class="literal">BookingErrorController</code> class<a id="id683" class="calibre1"/> is responsible for displaying error messages. The following is the <code class="literal">BookingErrorController</code> class:</p><div class="informalexample"><pre class="programlisting">public class BookingErrorController {
  public static void createAndShowTicketNotAvailableError() {
    <span class="strong"><strong class="calibre10">JOptionPane.showMessageDialog</strong></span>(null, "Ticket is not available","Booking message",  JOptionPane.WARNING_MESSAGE);
  }

  public static void createAndShowDatabaseSaveError() {
    <span class="strong"><strong class="calibre10">JOptionPane.showMessageDialog</strong></span>(null, "Could not book ticket",  "Booking Error", JOptionPane.ERROR_MESSAGE);
  }

  public static void createAndShowBookedMsg(String seats) {
    <span class="strong"><strong class="calibre10">JOptionPane.showMessageDialog</strong></span>(null, "Following tickets" + seats+ " Booked", "Booking Info", JOptionPane.ERROR_MESSAGE);
  }
  //other methods are ignored for brevity 
}</pre></div><p class="calibre9">Each method calls <code class="literal">JOptionPane</code> to display messages. <code class="literal">JOptionPane</code> shows the modal dialog box, and the user has to click on the close button or the <span class="strong"><strong class="calibre10">Yes</strong></span>/<span class="strong"><strong class="calibre10">No</strong></span> button to close the dialog. If the user doesn't close the dialog box, the program keeps waiting for the user action.</p><p class="calibre9">So, you cannot unit test the movie ticket booking logic unless you separate the error message display from the code logic.</p><p class="calibre9">The second thing to note is the <code class="literal">MovieDao</code> creation constructor:</p><div class="informalexample"><pre class="programlisting">MovieDao dao = new MovieDao();</pre></div><p class="calibre9">The <code class="literal">book()</code> method instantiates a database access object and invokes methods on it. We should separate the direct database access object creation from code so that we can pass a mock data access object and stub out the database calls; otherwise, the <code class="literal">book()</code> method will instantiate the real <code class="literal">MovieDao</code> object and the test will take time to execute. For now, we'll unit test the code with the real data access logic and later refactor the code to separate the <code class="literal">MovieDao</code> object instantiation.</p><p class="calibre9">Create a <code class="literal">MovieTicketProTest</code> test class and add a sanity check method to call the <code class="literal">book</code> method with null objects. The following is the code snippet:</p><div class="informalexample"><pre class="programlisting">public class MovieTicketProTest {
  MovieTicketPro movieTicketPro= new MovieTicketPro();
  
  @Test
  public void sanity() throws Exception {
    movieTicketPro.book(null, null, 1);
  }
  
}</pre></div><p class="calibre9">When we execute the<a id="id684" class="calibre1"/> test in Eclipse, it shows an error message pop up, and the test waits for user action. The following is the Eclipse output, and you can see that the test is waiting for the pop up:</p><div class="mediaobject"><img src="../images/00115.jpeg" alt="Working with testing impediments" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">If we include the test on our automation suite, the automation suite will run forever and wait for user intervention. We can localize the problem; extract the protected methods for each <code class="literal">BookingErrorController</code> method call. This change will allow us to create a <code class="literal">MovieTicketPro</code> fake object and replace the protected methods with empty implementations. However, the problem is how do we verify the error conditions? We can extract an error message interface, create a generic error message method, and pass and refactor the <code class="literal">BookingErrorController</code> class to implement the interface. The following are the interface details:</p><div class="informalexample"><pre class="programlisting">package com.packt.legacy;

public interface ErrorMessageDisplayer {
  void showMessage(String title, String message, int messageType);
  boolean showConfirmMessage(String title, String message);
}</pre></div><p class="calibre9">Modify the <code class="literal">BookingErrorController</code> class to implement the interface. The following is the implementation:</p><div class="informalexample"><pre class="programlisting">public class BookingErrorController implements ErrorMessageDisplayer{
  
  @Override
  public void showMessage(String title, String message, int messageType) {
    JOptionPane.showMessageDialog(null, message, title, messageType);
  }

  @Override
  public boolean showConfirmMessage(String title, String message) {
    int output = JOptionPane.showConfirmDialog(null,message, title, JOptionPane.YES_NO_OPTION);
    return output == JOptionPane.YES_OPTION;
  }
  //other methods are ignored for brevity
}</pre></div><p class="calibre9">Modify the <code class="literal">MovieTicketPro</code> class and,<a id="id685" class="calibre1"/> inline, all the <code class="literal">BookingErrorController</code> calls. The following is an example of such a change:</p><div class="informalexample"><pre class="programlisting">} catch (Exception e) {
      JOptionPane.showMessageDialog(null, "Could not book ticket", "Booking Error", JOptionPane.ERROR_MESSAGE);
      break;
    }
  }
}else {
  JOptionPane.showMessageDialog(null, "Movie or showtime not available","Booking message", JOptionPane.WARNING_MESSAGE);
}</pre></div><p class="calibre9">Note that the <code class="literal">BookingErrorController.createAndShowDatabaseSaveError()</code> and <code class="literal">BookingErrorController.createAndShowMovieOrShowTimeNotAvailableError()</code> methods are replaced by the original method content.</p><p class="calibre9">Now remove the static error message methods from the <code class="literal">BookingErrorController</code> class. You should not get any<a id="id686" class="calibre1"/> compilation errors.</p><p class="calibre9">Create a getter method in <code class="literal">MovieTicketPro</code> to return an implementation of <code class="literal">ErrorMessageDisplayer</code>. The following is the method body:</p><div class="informalexample"><pre class="programlisting">  protected ErrorMessageDisplayer getErrorMessageDisplayer() {
    return new BookingErrorController();
  }</pre></div><p class="calibre9">Replace all contents of the <code class="literal">JOptionPane.showMessageDialog</code> code with <code class="literal">getErrorMessageDisplayer()</code>. The following is the modified code:</p><div class="informalexample"><pre class="programlisting">public class MovieTicketPro {
  public void book(Movie movie, ShowTime time, int noOfTickets) {
    MovieDao dao = new MovieDao();
    MovieHall hall = dao.findMovie(movie, time);
    if (hall != null) {
      List&lt;String&gt; seats = dao.getAvilableSeats(movie, time);
      if (seats.size() &lt; noOfTickets) {
        <span class="strong"><strong class="calibre10">getErrorMessageDisplayer().showMessage("Booking message",</strong></span>          <span class="strong"><strong class="calibre10">"Ticket is not available", JOptionPane.WARNING_MESSAGE);</strong></span>
       return;
      }
      int booked = 0;
      String bookedSeats = "";
      for (String aSeat : seats) {
        try {
          dao.book(hall, time, aSeat);
          bookedSeats += " " + aSeat;
          booked++;
          if (booked == noOfTickets) {
            <span class="strong"><strong class="calibre10">getErrorMessageDisplayer().showMessage("Booking Info",</strong></span>             <span class="strong"><strong class="calibre10">"Following tickets" + bookedSeats + " Booked",</strong></span>              <span class="strong"><strong class="calibre10">JOptionPane.ERROR_MESSAGE);</strong></span>
            break;
          }
        } catch (BookingException e) {
          if (e.getType().equals(ErrorType.SeatAlreadyBooked)) {
            <span class="strong"><strong class="calibre10">getErrorMessageDisplayer().showMessage(</strong></span>              <span class="strong"><strong class="calibre10">"Booking message", "Ticket is not available",</strong></span>              <span class="strong"><strong class="calibre10">JOptionPane.WARNING_MESSAGE);</strong></span>
            boolean yes = <span class="strong"><strong class="calibre10">getErrorMessageDisplayer().showConfirmMessage("Booking message","Adjacent seats not available.Can I book any other seat?")</strong></span>;

            if (yes) {
              <span class="strong"><strong class="calibre10">getErrorMessageDisplayer().showMessage("Booking information","Going to auto allocate seats.", JOptionPane.INFORMATION_MESSAGE);</strong></span>
              break;
            }

          }
      } catch (Exception e) {
        <span class="strong"><strong class="calibre10">getErrorMessageDisplayer().showMessage("Booking Error","Could not book ticket", JOptionPane.ERROR_MESSAGE);</strong></span>
        break;
      }
    }
  } else {
    <span class="strong"><strong class="calibre10">getErrorMessageDisplayer().showMessage("Booking message","Movie or showtime not available",JOptionPane.WARNING_MESSAGE);</strong></span>
    }
  }

  protected ErrorMessageDisplayer getErrorMessageDisplayer() {
    return new BookingErrorController();
  }
}</pre></div><p class="calibre9">We can unit test<a id="id687" class="calibre1"/> the code as shown in the following code snippet. Create a fake object and override the <code class="literal">getErrorMessageDisplayer()</code> method to return a <code class="literal">ErrorMessageDisplayer</code> mock. We can verify the error messages indirectly from the <code class="literal">mock</code> object arguments:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class MovieTicketProTest {
  @Mock   ErrorMessageDisplayer messageDisplayer;

  MovieTicketPro movieTicketPro = new MovieTicketPro() {
    <span class="strong"><strong class="calibre10">protected ErrorMessageDisplayer getErrorMessageDisplayer() {</strong></span>
<span class="strong"><strong class="calibre10">      return messageDisplayer;</strong></span>
<span class="strong"><strong class="calibre10">    }</strong></span>
  };
  @Test   public void when_invalid_movie_shows_error_message(){
    movieTicketPro.book(null, null, 1);
    ArgumentCaptor&lt;String&gt; stringArgCaptor = ArgumentCaptor.forClass(String.class);
    ArgumentCaptor&lt;Integer&gt; intArgCaptor = ArgumentCaptor.forClass(Integer.class);

    <span class="strong"><strong class="calibre10">verify(messageDisplayer).showMessage(stringArgCaptor.capture(), stringArgCaptor.capture(), intArgCaptor.capture());</strong></span>
<span class="strong"><strong class="calibre10">    assertEquals("Movie or showtime not available", stringArgCaptor.getAllValues().get(1));</strong></span>
  }
}</pre></div><p class="calibre9">We need to <a id="id688" class="calibre1"/>separate the database access, create a getter method to return the <code class="literal">MovieDao</code> object, and call the getter method from the <code class="literal">book</code> method. From test, we can create a fake object and override the <code class="literal">getMovieDao()</code> method to return a mock data access object.</p><p class="calibre9">The following are the changes in the code:</p><div class="informalexample"><pre class="programlisting">  protected MovieDao getMovieDao() {
    return <span class="strong"><strong class="calibre10">new MovieDao()</strong></span>;
  }
  public void book(Movie movie, ShowTime time, int noOfTickets) {
    MovieDao dao = <span class="strong"><strong class="calibre10">getMovieDao()</strong></span>;
    //code ignored for brevity
  }</pre></div><p class="calibre9">The following is the modified test:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class MovieTicketProTest {
  <span class="strong"><strong class="calibre10">@Mock ErrorMessageDisplayer messageDisplayer;</strong></span>
<span class="strong"><strong class="calibre10">  @Mock MovieDao movieDao;</strong></span>
  
  MovieTicketPro movieTicketPro = new MovieTicketPro() {
    protected ErrorMessageDisplayer getErrorMessageDisplayer() {
      <span class="strong"><strong class="calibre10">return messageDisplayer;</strong></span>
    }
    
    <span class="strong"><strong class="calibre10">protected MovieDao getMovieDao() {</strong></span>
<span class="strong"><strong class="calibre10">      return movieDao;</strong></span>
<span class="strong"><strong class="calibre10">    }</strong></span>
  };
  }
  </pre></div><p class="calibre9"> After this change, the test execution finishes very quickly. The following is the test execution output:</p><div class="mediaobject"><img src="../images/00116.jpeg" alt="Working with testing impediments" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">The next section covers designing for testability.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Designing for testability"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec49" class="calibre1"/>Designing for testability</h1></div></div></div><p class="calibre9">We learned about testing impediments and how to refactor them. We cannot unit test code when testing impediments are present; we refactor the code and move the impediments out (to another class or methods), and during testing, the impediments are replaced with mock objects.</p><p class="calibre9">However, sometimes we cannot mock out the external dependencies because of testing an unfriendly design. This section covers the design for testability, or rather matters to avoid in code. The following Java constructs go up against mocking the testing impediments:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Constructors initialize testing impediments</li><li class="listitem">Class-level variable declaration and initialization</li><li class="listitem">The <code class="literal">private</code> methods</li><li class="listitem">The <code class="literal">final</code> methods</li><li class="listitem">The <code class="literal">static</code> methods</li><li class="listitem">The <code class="literal">final</code> classes</li><li class="listitem">Use of <code class="literal">new</code></li><li class="listitem">Static variable declaration and initialization</li><li class="listitem">Static initialization blocks</li></ul></div><p class="calibre9">You cannot unit test the legacy code because either it is tightly coupled or testing unfavorable language constructs hide the testing impediments. The following section explains the testing unfavorable constructs.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre9">To show a testing impediment, we'll throw a <a id="id689" class="calibre1"/>special runtime exception <code class="literal">TestingImpedimentException</code>. If your test fails with a <code class="literal">TestingImpedimentException</code>, then that means you cannot automate the test as your code has unfavorable features for testing.</p></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Identifying constructor issues"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec45" class="calibre1"/>Identifying constructor issues</h2></div></div></div><p class="calibre9">To build a test, we need to instantiate the class in the test harness, but the problem with legacy code is that it is difficult to break dependency and instantiate a class in a test harness. One such example is in a <a id="id690" class="calibre1"/>constructor, where the class instantiates many objects, reads from the properties file, or even creates a database connection. There can be many callers of the class, so you cannot change the constructor to pass dependencies; otherwise, it will cause a series of compilation errors.</p><p class="calibre9">We will take a look at a sample legacy code and try to write a test for the class.</p><p class="calibre9">Suppose we have a <code class="literal">TestingUnfavorableConstructor</code> class with two external dependencies <code class="literal">DatabaseDependency</code> and <code class="literal">FileReadDependency</code>. Both the dependencies are slow in nature and are testing impediments. <code class="literal">TestingUnfavorableConstructor</code> creates dependencies in the constructor. Ideally, the dependencies represent the database access and the file reads from the <code class="literal">TestingUnfavorableConstructor</code> constructor. The following is the <code class="literal">TestingUnfavorableConstructor</code> class:</p><div class="informalexample"><pre class="programlisting">public class TestingUnfavorableConstructor {
  private DatabaseDependency dependency1;
  private FileReadDependency dependency2;
  
  public TestingUnfavorableConstructor() {
    this.dependency1 = new DatabaseDependency();
    this.dependency2 = new FileReadDependency();
  }

  
  public Object testMe(Object arg) {
    return arg;
  }

}</pre></div><p class="calibre9">If we want to unit test the <code class="literal">testMe()</code> behavior of the class, then we need to create an object of the <code class="literal">TestingUnfavorableConstructor</code> class. However, when we try to create an instance in a unit test, the class fails to indicate that the class cannot be instantiated from an automated test suite. The following is the output:</p><div class="mediaobject"><img src="../images/00117.jpeg" alt="Identifying constructor issues" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">To overcome this, you should inject the dependencies through a constructor instead of creating them in a <a id="id691" class="calibre1"/>constructor.</p><p class="calibre9">We cannot modify the default constructor because the class is invoked from many other clients. We cannot break the clients. The other two options are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Keep the default constructor as it is. Create another constructor and inject dependencies through this new constructor; from test, we can call this new constructor.</li><li class="listitem">Create a protected method, move the dependency instantiation to that method, create two setter methods, and initialize the dependencies through the setter injection. In the test, create a fake object of the main class and override the protected method to do nothing, and pass the dependencies through the setter methods.</li></ul></div><p class="calibre9">The first option is relatively straight forward. We'll apply the second approach.</p><p class="calibre9">The following is the modified code:</p><div class="informalexample"><pre class="programlisting">public class TestingUnfavorableConstructor {
  private DatabaseDependency dependency1;
  private FileReadDependency dependency2;
  
  public TestingUnfavorableConstructor() {
    createDependencies();
  }

  protected void createDependencies() {
    this.dependency1 = new DatabaseDependency();
    this.dependency2 = new FileReadDependency();
  }
  
  public void setDependency1(DatabaseDependency dependency1) {
    this.dependency1 = dependency1;
  }

  public void setDependency2(FileReadDependency dependency2) {
    this.dependency2 = dependency2;
  }

  public Object testMe(Object arg) {
    return arg;
  }
}</pre></div><p class="calibre9">The following unit test <a id="id692" class="calibre1"/>overrides the <code class="literal">TestingUnfavorableConstructor</code> and provides an empty implementation of the <code class="literal">createDependencies()</code> method, creates mock dependencies, and calls setter methods to set the mock dependencies:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class TestingUnfavorableConstructorTest {
  @Mock DatabaseDependency dep1;
  @Mock FileReadDependency dep2;
  TestingUnfavorableConstructor unfavorableConstructor;
  @Before  public void setUp() {
    unfavorableConstructor= new <span class="strong"><strong class="calibre10">TestingUnfavorableConstructor() {</strong></span>
<span class="strong"><strong class="calibre10">      protected void createDependencies() {</strong></span>
<span class="strong"><strong class="calibre10">      }</strong></span>
<span class="strong"><strong class="calibre10">    }</strong></span>;

    unfavorableConstructor.<span class="strong"><strong class="calibre10">setDependency1(dep1)</strong></span>;
    unfavorableConstructor.<span class="strong"><strong class="calibre10">setDependency2(dep2)</strong></span>;
  }
  
  @Test   public void sanity() throws Exception {
  }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre9">Do not instantiate dependencies in the constructor; the dependencies may exhibit testing impediments and make the class nontestable. Instead of instantiating the dependencies in the constructor, you can pass the real implementations (real dependencies) to the constructor or the setter method of the code under the test.</p></div></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Realizing initialization issues"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec46" class="calibre1"/>Realizing initialization issues</h2></div></div></div><p class="calibre9">Class-level variable declaration and object instantiation at the same time creates problems. You don't get the<a id="id693" class="calibre1"/> chance to mock out the variable. The following example explains the problem:</p><p class="calibre9">The <code class="literal">VariableInitialization</code> class has a database dependency, and the dependency is instantiated where it is declared, as follows:</p><div class="informalexample"><pre class="programlisting">Public class VariableInitialization {
  <span class="strong"><strong class="calibre10">DatabaseDependency dependency1 = new DatabaseDependency();</strong></span>
  public void testMe(Object obj) {
    
  }
}</pre></div><p class="calibre9">When you instantiate the <code class="literal">VariableInitialization</code> class in test, the test fails. The following is the output:</p><div class="mediaobject"><img src="../images/00118.jpeg" alt="Realizing initialization issues" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">The following is the test class:</p><div class="informalexample"><pre class="programlisting">public class VariableInitializationTest {
  VariableInitialization initialization;

  @Before public void setUp() throws Exception {
    initialization = new VariableInitialization();
  }
  @Test   public void sanity() throws Exception {
  }
}</pre></div><p class="calibre9">To overcome the class-level variable initialization, you can try out the following options:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Add a default constructor and move the dependency instantiation to the default constructor. Create another constructor and inject the dependencies through this new constructor; from test, we <a id="id694" class="calibre1"/>can call this the new constructor.</li><li class="listitem">Add a default constructor, and move the dependency instantiation to a protected method and call the method from the default constructor. Create a setter method and initialize the dependency through a setter injection. In the test, create a fake object of the main class and override the protected method to do nothing, and pass the dependencies through the setter methods.<div class="note" title="Note"><h3 class="title2"><a id="tip19" class="calibre1"/>Tip</h3><p class="calibre9">Do not instantiate variables at the class level.</p></div></li></ul></div></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Working with private methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec47" class="calibre1"/>Working with private methods</h2></div></div></div><p class="calibre9">The <code class="literal">private</code> methods are useful for hiding<a id="id695" class="calibre1"/> the internal state and encapsulation, but they can also hide the testing impediments. The following example explains the details:</p><p class="calibre9">The <code class="literal">PrivateMethod</code> class has a <code class="literal">private</code> method named <code class="literal">showError()</code>. This <code class="literal">private</code> method hides a test impediment. When<a id="id696" class="calibre1"/> we unit test the <code class="literal">validate()</code> method with a <code class="literal">null</code> object, the <code class="literal">validate()</code> method calls the <code class="literal">showError</code> message, as follows:</p><div class="informalexample"><pre class="programlisting">public class PrivateMethod {
  public Object validate(Object arg) {
    if(arg == null) {
      showError("Null input");
    }
    return arg;
  }

  private void showError(String msg) {
    GraphicalInterface.showMessage(msg);
  }
}</pre></div><p class="calibre9">The following is the test output:</p><div class="mediaobject"><img src="../images/00119.jpeg" alt="Working with private methods" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">You can extract the testing impediments to a protected method, or you can separate the concern. Create a new<a id="id697" class="calibre1"/> class, move the testing impediment to that <a id="id698" class="calibre1"/>class, and inject the new class as a dependency.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip20" class="calibre1"/>Tip</h3><p class="calibre9">Do not hide testing impediments in private methods.</p></div><p class="calibre9">The following code refactors the testing impediments and makes the class unit testable:</p><div class="informalexample"><pre class="programlisting">public class PrivateMethodRefactored {
  public Object validate(Object arg) {
    if(arg == null) {
      showError("Null input");
    }
    
    return arg;
  }

  protected void showError(String msg) {
    GraphicalInterface.showMessage(msg);
  }
}</pre></div><p class="calibre9">The <code class="literal">showError</code> method's access specifier is changed to <code class="literal">protected</code>.</p><p class="calibre9">The following test code extends the class with an anonymous implementation, and it overrides the protected method with an empty implementation. The test code invokes the <code class="literal">validate()</code> method on the new anonymous implementation of the <code class="literal">PrivateMethodRefactored</code> class. In turn, the polymorphic behavior will call the empty implementation. Hence, the test will always bypass the testing impediments by calling the overridden empty implementation of the testing impediment, but the real production code will always invoke<a id="id699" class="calibre1"/> the protected method:</p><div class="informalexample"><pre class="programlisting">public class PrivateMethodRefactoredTest {

  PrivateMethodRefactored privateMethod;
  
  @Before
  public void setUp() {
    privateMethod = new PrivateMethodRefactored() {
      protected void showError(String msg) {
        
      }
    };
  }
  
  @Test
  public void validate() throws Exception {
    privateMethod.validate(null);
  }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip21" class="calibre1"/>Tip</h3><p class="calibre9">This approach of bypassing<a id="id700" class="calibre1"/> the testing impediments with overridden versions of the testing impediments is known as faking or fake object. If the code under test contains many testing impediments, then it is not possible to override all of them in an anonymous class. Instead, we can create an inner class, and extend the code under test and override all the testing unfriendly methods.</p></div></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Working with final methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec48" class="calibre1"/>Working with final methods</h2></div></div></div><p class="calibre9">When a method is final, you cannot override it. If the final method hides any testing impediment, you cannot<a id="id701" class="calibre1"/> unit test the class. The following example explains the issue:</p><p class="calibre9">The <code class="literal">FinalDependency</code> class has a final method named <code class="literal">doSomething</code>. This method hides a testing unfriendly feature. The following is the class definition:</p><div class="informalexample"><pre class="programlisting">public class FinalDependency {

  public final void doSomething() {
    throw new TestingImpedimentException("Final methods cannot be overriden");
  }
}</pre></div><p class="calibre9">The <code class="literal">FinalMethodDependency</code> class has a dependency on <code class="literal">FinalDependency</code>, and in the <code class="literal">testMe</code> method, it calls the <code class="literal">doSomething</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public class FinalMethodDependency {

  private final FinalDependency dependency;

  public FinalMethodDependency(FinalDependency dependency) {
    this.dependency = dependency;
  }  
  public void testMe() {
    dependency.doSomething();
  }
}</pre></div><p class="calibre9">In the test, we'll mock the<a id="id702" class="calibre1"/> dependency and unit test the code as follows:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class FinalMethodDependencyTest {
  @Mock
  FinalDependency finalDependency;
  FinalMethodDependency methodDependency;

  @Before
  public void setUp() {
    methodDependency = new FinalMethodDependency(finalDependency);
  }

  @Test
  public void testSomething() throws Exception {
    methodDependency.testMe();
  }
}</pre></div><p class="calibre9">When we run the test, the test still accesses the testing impediment, as the mock object cannot stub a final method. When we try to stub the method, we get an error. The following test stubs the final method call:</p><div class="informalexample"><pre class="programlisting">  @Test
  public void testSomething() throws Exception {
    doNothing().when(finalDependency).doSomething();
    methodDependency.testMe();
  }</pre></div><p class="calibre9">When we run the test, we get the following error message thrown by the Mockito framework:</p><div class="mediaobject"><img src="../images/00120.jpeg" alt="Working with final methods" class="calibre12"/></div><p class="calibre13"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip22" class="calibre1"/>Tip</h3><p class="calibre9">Do not hide the testing impediments in final methods. You cannot override or stub a final method.</p></div><p class="calibre9">The only possible<a id="id703" class="calibre1"/> way to overcome this is extracting the content of the final method to a protected method; call the protected method from the final method, and override the protected method in test. Otherwise, you can use the PowerMock or PowerMockito framework if you cannot touch the class at all; for example, when you only have a JAR file.</p></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Exploring static method issues"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec49" class="calibre1"/>Exploring static method issues</h2></div></div></div><p class="calibre9">The <code class="literal">static</code> methods<a id="id704" class="calibre1"/> are good for utility classes, but unnecessary use of <code class="literal">static</code> can hide the testing impediments<a id="id705" class="calibre1"/> and create problems in unit testing. The following example sheds light on the issue:</p><p class="calibre9">The <code class="literal">SingletonDependency</code> class<a id="id706" class="calibre1"/> is an implementation of the <a id="id707" class="calibre1"/>
<span class="strong"><strong class="calibre10">Gang of Four</strong></span> (<span class="strong"><strong class="calibre10">GoF</strong></span>) singleton design pattern. It has a <code class="literal">private</code> constructor and a static <code class="literal">getInstance()</code> method<a id="id708" class="calibre1"/> to create only a single instance of the class. The static <code class="literal">callMe()</code> method hides a testing impediment. Note that the GoF singleton pattern doesn't define methods as <code class="literal">static</code>, but in this example, we are defining the <code class="literal">callMe()</code> method as <code class="literal">static</code> to display a drawback of the <code class="literal">static</code> methods. The following is the singleton implementation:</p><div class="informalexample"><pre class="programlisting">public class SingletonDependency {
  private static SingletonDependency singletonDependency;

  private SingletonDependency() {
  }

  public synchronized static SingletonDependency getInstance() {
    if (singletonDependency == null) {
      singletonDependency = new SingletonDependency();
    }

    return singletonDependency;
  }

  Public static void callMe() {
    throw new TestingImpedimentException("we dont need singleton");
  }
}</pre></div><p class="calibre9">The <code class="literal">VictimOfAPatternLover</code> class has a dependency on <code class="literal">SingletonDependency</code>. The following are the class details:</p><div class="informalexample"><pre class="programlisting">public class VictimOfAPatternLover {
  private final SingletonDependency dependency;

  public VictimOfAPatternLover(SingletonDependency dependency) {
    this.dependency = dependency;
  }

  public void testMe() {
    dependency.callMe();
  }
}</pre></div><p class="calibre9">Mockito cannot stub a static<a id="id709" class="calibre1"/> method. When we try to stub the static <code class="literal">callMe()</code> method, it still calls the original method and fails for the testing impediment. You cannot stub a <code class="literal">static</code> method.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre9">Do not hide testing impediments in static methods. You cannot stub static methods.</p></div><p class="calibre9">The only way to overcome this issue is to create a <code class="literal">protected</code> method and wrap the <code class="literal">static</code> call. From the code, call the wrapped method and from the test, override the <code class="literal">protected</code> method.</p><p class="calibre9">Add a <code class="literal">static</code> wrapper method in the dependency class and call the <code class="literal">static</code> method from it, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  public static void callMe() {
    throw new TestingImpedimentException("Common we dont need singleton");
  }
  
  <span class="strong"><strong class="calibre10">protected void wrapper() {</strong></span>
    <span class="strong"><strong class="calibre10">callMe();</strong></span>
  }</pre></div><p class="calibre9">In the code, call<a id="id710" class="calibre1"/> the <code class="literal">wrapper</code> method as follows:</p><div class="informalexample"><pre class="programlisting">  public void testMe() {
    dependency.wrapper();
  }</pre></div><p class="calibre9">Stub the <code class="literal">wrapper</code> method in the test as follows:</p><div class="informalexample"><pre class="programlisting">@Test
  public void testMe() throws Exception {
    Mockito.doNothing().when(dependency).wrapper();
    aPatternLover.testMe();
  }</pre></div></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Working with final classes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch09lvl2sec50" class="calibre1"/>Working with final classes</h2></div></div></div><p class="calibre9">You cannot override a <code class="literal">final</code> class, so you can hide testing unfavorable features in a <code class="literal">final</code> class. The<a id="id711" class="calibre1"/> following example explains the problem:</p><p class="calibre9">The final class hides a testing<a id="id712" class="calibre1"/> impediment as follows:</p><div class="informalexample"><pre class="programlisting">public final class FinalDepencyClass {

  public void poison() {
    throw new TestingImpedimentException("Finals cannot be mocked");
  }
}</pre></div><p class="calibre9">The code under test has a dependency on the final class as follows:</p><div class="informalexample"><pre class="programlisting">public class FinalClassDependency {
  private final FinalDepencyClass finalDepencyClass;

  public FinalClassDependency(FinalDepencyClass <span class="strong"><strong class="calibre10">    finalDepencyClass</strong></span>) {
    <span class="strong"><strong class="calibre10">this.finalDepencyClass = finalDepencyClass;</strong></span>
  }
  
  public void testMe() {
    finalDepencyClass.poison();
  }
}</pre></div><p class="calibre9">In test, we'll try to<a id="id713" class="calibre1"/> stub the <code class="literal">poison</code> method as<a id="id714" class="calibre1"/> follows:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class FinalClassDependencyTest {
  @Mock
  FinalDepencyClass finalDependency;
  
  FinalClassDependency test;

  @Before
  public void setUp() {
    test = new FinalClassDependency(finalDependency);
  }
  @Test
  public void testMe() throws Exception {
    Mockito.doNothing().when(finalDependency).poison();
    test.testMe();
  }
}</pre></div><p class="calibre9">The test fails with a <span class="strong"><strong class="calibre10">MockitoException</strong></span> as Mockito cannot mock a final class. The following is the JUnit output:</p><div class="mediaobject"><img src="../images/00121.jpeg" alt="Working with final classes" class="calibre12"/></div><p class="calibre13"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre9">Do not hide testing impediments in final classes. You cannot mock a final class.</p></div><p class="calibre9">Final classes <a id="id715" class="calibre1"/>are important for framework or architecture design so that no one can hack the behavior, but it <a id="id716" class="calibre1"/>can create a serious problem for unit testing. Consider it before you choose to make a class final.</p></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Learning the new attribute"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch09lvl2sec51" class="calibre1"/>Learning the new attribute</h2></div></div></div><p class="calibre9">Java instantiates classes using the <code class="literal">new</code> operator, but a <code class="literal">new</code> operator <a id="id717" class="calibre1"/>can create problems for unit testing.</p><p class="calibre9">The following example<a id="id718" class="calibre1"/> explains the issue. The <code class="literal">PoisonIvy</code> constructor has a testing impediment such as calls fetch data from a database table or reads from a filesystem; we represented the testing impediment with the <code class="literal">TestingImpedimentException</code>:</p><div class="informalexample"><pre class="programlisting">public class PoisonIvy {

  public PoisonIvy() {
    throw new TestingImpedimentException(
      "Do not instantiate concrete class, use interfaces");
  }

  public void poison() {

  }
}</pre></div><p class="calibre9">The following is the code that calls the <code class="literal">PoisonIvy</code> constructor:</p><div class="informalexample"><pre class="programlisting">public class NewExpressionDependency {

  public void testMe() {
    PoisonIvy ivy = new PoisonIvy();
    ivy.poison();
  }
}</pre></div><p class="calibre9">When we unit test the <code class="literal">testMe()</code> code, it fails. The<a id="id719" class="calibre1"/> <code class="literal">testMe()</code> method directly creates an instance of dependency and calls the <code class="literal">poison()</code> method. You cannot override this <code class="literal">new</code> expression. If we want to unit test the <code class="literal">testMe()</code> method, first we need to move the <code class="literal">new</code> operator outside of <code class="literal">testMe()</code> as we cannot instantiate the <code class="literal">PoisonIvy</code> class. The constructor of <code class="literal">PoisonIvy</code> throws an exception. Hence, we cannot unit test the <code class="literal">testMe</code> behavior unless we move the object creation out of <code class="literal">testMe</code>. Instead of creating a new instance of <code class="literal">PoisonIvy</code> inside <code class="literal">testMe()</code>, we can pass an instance of <code class="literal">PoisonIvy</code> as a method argument, or create a class-level dependency and pass <code class="literal">PoisonIvy</code> as the constructor or setter dependency argument.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre9">Program to an interface, not to an implementation. Rather than hardcoding the instantiation of the subtype into the code, assign the concrete implementation object at runtime.</p></div><p class="calibre9">What is "program to an interface, not to an implementation"?</p><p class="calibre9">This means program<a id="id720" class="calibre1"/> to a supertype rather than a subtype. You can interchange the implementation at runtime. In the collection framework, we have the <code class="literal">List</code> interface and its many implantations. In your class, always define a variable of the <code class="literal">List</code> type and not <code class="literal">ArrayList</code>; at runtime, you can assign any implementation you want.</p><p class="calibre9">In this example, you can pass <code class="literal">PoisonIvy</code> as a constructor or setter dependency, and at runtime (during testing), you can pass a mock or a fake implementation to suppress the testing impediments.</p></div></div>

<div class="book" title="Designing for testability">
<div class="book" title="Exploring static variables and blocks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch09lvl2sec52" class="calibre1"/>Exploring static variables and blocks</h2></div></div></div><p class="calibre9">Static initializations and <code class="literal">static</code> blocks are executed during class loading. You cannot override them. If you initialize <a id="id721" class="calibre1"/>a testing impediment in a <code class="literal">static</code> block, then you cannot unit test the class. The following example explains the issue:</p><p class="calibre9">The <a id="id722" class="calibre1"/>
<code class="literal">StaticBlockOwner</code> class has a static variable named <code class="literal">StaticBlockDependency</code>, and it initializes the variable in a<a id="id723" class="calibre1"/> <code class="literal">static</code> block. The following is the class:</p><div class="informalexample"><pre class="programlisting">public class StaticBlockOwner {
  private static StaticBlockDependency blockDependency;
  static {
    <span class="strong"><strong class="calibre10">blockDependency = new StaticBlockDependency();</strong></span>
    <span class="strong"><strong class="calibre10">blockDependency.loadTime = new Date();</strong></span>
  }
  public void testMe() {
  }
}</pre></div><p class="calibre9">When we unit test the class, it fails. The following is the unit test:</p><div class="informalexample"><pre class="programlisting">public class StaticBlockOwnerTest {
  StaticBlockOwner owner;
  @Before public void setUp()  {
    owner = new StaticBlockOwner();
  }
  @Test   public void clean() throws Exception {
    owner.testMe();
  }
}</pre></div><p class="calibre9">The test fails with a <code class="literal">java.lang.ExceptionInInitializationError</code>, as it tries to instantiate the dependency in a <code class="literal">static</code> block<a id="id724" class="calibre1"/> and the dependency throws an<a id="id725" class="calibre1"/> exception.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre9">Do not instantiate dependencies in the static block. You cannot override the testing impediments.</p></div><p class="calibre9">The book <span class="strong"><em class="calibre11">Working Effectively with Legacy Code</em></span>, <span class="strong"><em class="calibre11">Pearson Education</em></span>, by Michael Feathers explains the legacy code and how effectively you can refactor the legacy code. You can read the e-book at <a class="calibre1" href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052</a>.</p></div></div>
<div class="book" title="Working with greenfield code"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec50" class="calibre1"/>Working with greenfield code</h1></div></div></div><p class="calibre9">This section illustrates the three-step rhythm of writing a failing test, coding enough to make it work, and then refactoring it. This is implied greenfield coding as opposed to working with an existing legacy code.</p><p class="calibre9">TDD is an evolutionary<a id="id726" class="calibre1"/> development approach. It offers test-first development where the production code is written only to satisfy a test, and the code is refactored to improve the code quality. In TDD, unit tests drive the design. You write the code to satisfy a failing test, so it limits the code you write to only what is needed. The tests provide fast automated regression for refactoring and new enhancements.</p><p class="calibre9">Kent Beck is the originator of Extreme Programming and TDD. He has authored many books and papers. Visit <a class="calibre1" href="http://en.wikipedia.org/wiki/Kent_Beck">http://en.wikipedia.org/wiki/Kent_Beck</a> for details.</p><p class="calibre9">The following diagram represents the <a id="id727" class="calibre1"/>TDD life cycle:</p><div class="mediaobject"><img src="../images/00122.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">First, we write a failing test, then add code to satisfy the failing test, and then refactor the code and again start with another test.</p><p class="calibre9">The following section<a id="id728" class="calibre1"/> provides an example of TDD. We'll build a program to conduct an election survey and forecast the result. The program will compile the survey<a id="id729" class="calibre1"/> result and display the opinion poll.</p><p class="calibre9">The result should present the zone-wise (geographically) poll opinion and overall opinion, such as if there are two zones, east and west, then the result will be presented in the following format:</p><div class="mediaobject"><img src="../images/00123.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">Let's look at the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a test <a id="id730" class="calibre1"/>class named <code class="literal">SurveyResultCompilerTest</code> and add a <code class="literal">when_one_opinion_then_result_forecasts_the_opinion()</code>test to compile the overall survey result.<div class="note" title="Note"><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre9">We'll follow this convention for the test method names, for example, <code class="literal">when_some_condition_then_this_happens</code>. We will use the underscore symbol as a separator.</p></div></li><li class="listitem" value="2">In this new test method, type in <code class="literal">SurveyResultCompiler()</code>. The compiler will complain that the <code class="literal">SurveyResultCompiler</code> class doesn't exist. Hover the mouse over <code class="literal">SurveyResultCompiler</code>; Eclipse will suggest a quick fix for you. Choose <span class="strong"><strong class="calibre10">Create class 'SurveyResultCompiler'</strong></span>, and create the class in the <code class="literal">com.packt.tdd.survey</code> package under the <code class="literal">src</code> source folder, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00124.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="3"><code class="literal">SurveyResultCompiler</code> is ready. We need to pass an opinion to <code class="literal">SurveyResultCompiler</code> so that it can compile a result. Modify the test to call <code class="literal">willVoteFor</code> and <a id="id731" class="calibre1"/>pass an opinion. The compiler will complain that the method doesn't exist. Add the method to <code class="literal">SurveyResultCompiler</code> by following the quick fix options. The following is the test method:<div class="informalexample"><pre class="programlisting">  @Test
  public void when_one_opinion_then_result_forecasts_the_opinion() {
    new SurveyResultCompiler().willVoteFor("Party A");
  } </pre></div></li><li class="listitem" value="4">We need a compiled result after the survey. The result should give us the party name and winning percentage. We can think of a <code class="literal">Map</code> data type. Modify the test again to obtain the result. The following is the modified test:<div class="informalexample"><pre class="programlisting">  @Test
  public void when_one_opinion_then_result_forecasts_the_opinion() {
    SurveyResultCompiler surveyResultCompiler = new     
        SurveyResultCompiler();
    surveyResultCompiler.willVoteFor("Party A");
    Map&lt;String, BigDecimal&gt; result 
      =surveyResultCompiler.forecastResult();
  }</pre></div></li><li class="listitem" value="5">Add the <code class="literal">forecastResult</code> method to the <code class="literal">SurveyResultCompiler</code> class. The following is the <a id="id732" class="calibre1"/><code class="literal">SurveyResultCompiler</code> class:<div class="informalexample"><pre class="programlisting">public class SurveyResultCompiler {
  public void willVoteFor(String opinion) {
  }
  public Map&lt;String, BigDecimal&gt; forecastResult() {
    return null;
  }
}</pre></div></li><li class="listitem" value="6">Verify that when only one person participates in a survey, then the survey result should return a 100 <a id="id733" class="calibre1"/>percent winning chance for the political party that the person votes for. The following assertion verifies our assumption:<div class="informalexample"><pre class="programlisting">@Test
public void when_one_opinion_then_result_forecasts_the_opinion() {
  SurveyResultCompiler surveyResultCompiler = new SurveyResultCompiler();
  String opinion = "Party A";
  surveyResultCompiler.willVoteFor(opinion);

  <span class="strong"><strong class="calibre10">Map&lt;String, BigDecimal&gt; result =surveyResultCompiler.forecastResult();</strong></span>

<span class="strong"><strong class="calibre10">  assertEquals(new BigDecimal("100"),       </strong></span>
<span class="strong"><strong class="calibre10">    result.get(opinion));</strong></span>
}</pre></div></li><li class="listitem" value="7">When we run the test, it fails with a <code class="literal">NullPointerException</code>. We need to modify the code as follows to return a result:<div class="informalexample"><pre class="programlisting">  public Map&lt;String, BigDecimal&gt; forecastResult() {
    <span class="strong"><strong class="calibre10">Map&lt;String, BigDecimal&gt; result = new HashMap&lt;String, BigDecimal&gt;();</strong></span>
<span class="strong"><strong class="calibre10">    return result;</strong></span>
  }</pre></div></li><li class="listitem" value="8">Rerun the test. It fails for an <code class="literal">AssertionError</code>. The following is the output:<div class="mediaobject"><img src="../images/00125.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="9">We need to modify the code to return 100 percent for <code class="literal">Party A</code>. The following is the <a id="id734" class="calibre1"/>modified code:<div class="informalexample"><pre class="programlisting">  public Map&lt;String, BigDecimal&gt; forecastResult() {
    Map&lt;String, BigDecimal&gt; result = new HashMap&lt;String, BigDecimal&gt;();
    <span class="strong"><strong class="calibre10">result.put("Party A", new BigDecimal("100"));</strong></span>
    return result;
  }</pre></div></li><li class="listitem" value="10">Rerun the test. It will show you a green bar. The following is the output:<div class="mediaobject"><img src="../images/00126.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="11">Now we need to add another test to verify that when two persons participate in a poll, and they vote for two different political parties, then the result should portray 50 percent chance for each party. Add a <code class="literal">when_different_opinions_then_forecasts_50_percent_chance_for_each_party</code> test, and add the following lines to verify the assumption:<div class="informalexample"><pre class="programlisting">  @Test   public void when_different_opinions_then_forecasts_50_percent_chance_for_each_party() {
    SurveyResultCompiler surveyResultCompiler = new SurveyResultCompiler();
    String opinionA = "Party A";
    surveyResultCompiler.willVoteFor(opinionA);
    String opinionB = "Party B";
    surveyResultCompiler.willVoteFor(opinionB);
    Map&lt;String, BigDecimal&gt; result = surveyResultCompiler.forecastResult();
    <span class="strong"><strong class="calibre10">assertEquals(new BigDecimal("50"), result.get(opinionA));</strong></span>
<span class="strong"><strong class="calibre10">    assertEquals(new BigDecimal("50"), </strong></span>
<span class="strong"><strong class="calibre10">    result.get(opinionB));</strong></span>
  }</pre></div></li><li class="listitem" value="12">When we run the test, it fails. It expects 50 percent but gets 100 percent, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00127.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="13">We need to <a id="id735" class="calibre1"/>modify the code to return 50 percent for <code class="literal">Party A</code> and 50 percent for <code class="literal">Party B</code>. The following is the modified code:<div class="informalexample"><pre class="programlisting">  public Map&lt;String, BigDecimal&gt; forecastResult() {
    Map&lt;String, BigDecimal&gt; result = new HashMap&lt;String, BigDecimal&gt;();
    <span class="strong"><strong class="calibre10">result.put("Party A", new BigDecimal("50"));</strong></span>
<span class="strong"><strong class="calibre10">    result.put("Party B", new BigDecimal("50"));</strong></span>
    return result;
  }</pre></div></li><li class="listitem" value="14">Rerun the test. The second test passes but the first test fails, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00128.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="15">We broke the first test. Now we need to revert the changes, but then the second test will fail. We need an algorithm to calculate the percentage. First, we need to store the opinions. Add a <code class="literal">List</code> to the <code class="literal">SurveyResultCompiler</code> class and store each opinion. The following is the code:<div class="informalexample"><pre class="programlisting">public class SurveyResultCompiler {
  List&lt;String&gt; opinions = new ArrayList&lt;String&gt;();

  public void willVoteFor(String opinion) {
    opinions.add(opinion);
  }
  //the result method is ignored for brevity
}</pre></div></li><li class="listitem" value="16">Now we need to <a id="id736" class="calibre1"/>modify the <code class="literal">forecastResult</code> method to calculate the percentage. First, loop through the opinions to get the party-wise vote count, such as 10 voters for <code class="literal">Party A</code> and 20 voters for <code class="literal">Party B</code>. Then, we can compute the percentage as <span class="strong"><em class="calibre11">vote count * 100 / total votes</em></span>. The following is the code:<div class="informalexample"><pre class="programlisting">public Map&lt;String, BigDecimal&gt; forecastResult() {

  Map&lt;String, BigDecimal&gt; result = new HashMap&lt;String, BigDecimal&gt;();
  Map&lt;String, Integer&gt; countMap = new HashMap&lt;String, Integer&gt;();
  for(String party:opinions) {
    Integer count = countMap.get(party);
    if(count == null) {
      count = 1;
    }else {
      count++;
    }
    countMap.put(party, count);
  }

  for(String party:countMap.keySet()) {
    Integer voteCount = countMap.get(party);
    int totalVotes = opinions.size();
    BigDecimal percentage = new BigDecimal((voteCount*100)/totalVotes);
    result.put(party, percentage);
  }
  
   return result;
}</pre></div></li><li class="listitem" value="17">Rerun the test. You will get a green bar, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00129.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="18">Now add a test<a id="id737" class="calibre1"/> for three participants. The following is the test:<div class="informalexample"><pre class="programlisting">  @Test
  public void when_three_different_opinions_then_forecasts_33_percent_chance_for_each_party() {
    SurveyResultCompiler surveyResultCompiler = new SurveyResultCompiler();
    String opinionA = "Party A";
    surveyResultCompiler.willVoteFor(opinionA);
    String opinionB = "Party B";
    surveyResultCompiler.willVoteFor(opinionB);
    String opinionC = "Party C";
    surveyResultCompiler.willVoteFor(opinionC);
    Map&lt;String, BigDecimal&gt; result =surveyResultCompiler.forecastResult();
    assertEquals(new BigDecimal("33"), result.get(opinionA));
    assertEquals(new BigDecimal("33"), result.get(opinionB));
    assertEquals(new BigDecimal("33"), result.get(opinionC));
  }</pre></div></li><li class="listitem" value="19">Look at the test class, and you will find the duplicate code in each test method; clean them. Move the <code class="literal">SurveyResultCompiler</code> object instantiation to a <code class="literal">setUp</code> method instead of instantiating the class in each test method. Inline are the <code class="literal">opinion</code> variables, such as <code class="literal">opinionA</code>. The following is the refactored test class:<div class="informalexample"><pre class="programlisting">public class SurveyResultCompilerTest {

  SurveyResultCompiler surveyResultCompiler;
  
  @Before
  public void setUp() {
    surveyResultCompiler = new SurveyResultCompiler();
  }

  @Test public void when_one_opinion_then_result_forecasts_the_opinion() {

    surveyResultCompiler.willVoteFor("Party A");
    Map&lt;String, BigDecimal&gt; result =surveyResultCompiler.forecastResult();
    assertEquals(new BigDecimal("100"), result.get("Party A"));
  }
  
  @Test public void when_two_different_opinions_then_forecasts_50_percent_chance_for_each_party() {

    surveyResultCompiler.willVoteFor("Party A");
    surveyResultCompiler.willVoteFor("Party B");
    
    Map&lt;String, BigDecimal&gt; result =surveyResultCompiler.forecastResult();
    
    assertEquals(new BigDecimal("50"), result.get("Party A"));
    assertEquals(new BigDecimal("50"), result.get("Party B"));
  }
  
  @Test public void when_three_different_opinions_then_forecasts_33_percent_chance_for_each_party() {

    surveyResultCompiler.willVoteFor("Party A");
    surveyResultCompiler.willVoteFor("Party B");
    surveyResultCompiler.willVoteFor("Party C");

    Map&lt;String, BigDecimal&gt; result =surveyResultCompiler.forecastResult();
    
    assertEquals(new BigDecimal("33"), result.get("Party A"));
    assertEquals(new BigDecimal("33"), result.get("Party B"));
    assertEquals(new BigDecimal("33"), result.get("Party C"));
  }
}</pre></div></li><li class="listitem" value="20">The test class looks clean now. Rerun the test to make sure nothing is broken. The following is the test output:<div class="mediaobject"><img src="../images/00130.jpeg" alt="Working with greenfield code" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="21">Revisit the <code class="literal">SurveyResultCompiler</code> class. It works with a <code class="literal">List</code> and two <code class="literal">Map</code> attributes. Do we really need to keep the <code class="literal">List</code> attribute? Instead of calculating the votes from <code class="literal">List</code>, we <a id="id738" class="calibre1"/>can directly store the opinions in <code class="literal">Map</code> and keep the opinion count up to date. The following is the refactored code:<div class="informalexample"><pre class="programlisting">public class SurveyResultCompiler {
  private Map&lt;String, Integer&gt; opinions = new HashMap&lt;String, Integer&gt;();
  private long participationCount = 0;
  public void willVoteFor(String opinion) {
    Integer sameOpinionCount = opinions.get(opinion);
    if (sameOpinionCount == null) {
      sameOpinionCount = 1;
    } else {
      sameOpinionCount++;
    }
    opinions.put(opinion, sameOpinionCount);
    participationCount++;
  }

  public Map&lt;String, BigDecimal&gt; forecastResult() {
    Map&lt;String, BigDecimal&gt; result = new HashMap&lt;String, BigDecimal&gt;();

    for (String opinion : opinions.keySet()) {
      Integer sameOpinionCount = opinions.get(opinion);
      BigDecimal opinionPercentage = new BigDecimal((sameOpinionCount * 100) / participationCount);
      result.put(opinion, opinionPercentage);
    }
    return result;
  }
}</pre></div></li><li class="listitem" value="22">Rerun the test to make sure nothing is broken. If anything breaks, then immediately revert the changes. The tests should run fine, so we are good to go.</li><li class="listitem" value="23">One feature is complete. Now we<a id="id739" class="calibre1"/> need to develop a new feature—zone-wise calculation. The existing test cases will safeguard our code. If you break any existing test, immediately revisit your change.</li></ol><div class="calibre17"/></div><p class="calibre9">What we just completed is TDD. It has the following benefits:</p><div class="book"><ul class="itemizedlist"><li class="listitem">TDD gives us clean, testable, and maintainable code.</li><li class="listitem">We document and update the<a id="id740" class="calibre1"/> code, but we forget to update the documentation; this creates confusion. You can document your code and keep it updated, or write your code and unit tests in such a way that anybody can understand the intent. In TDD, tests are written to provide enough documentation of code. So, the test is our documentation, but we need to clean the tests too to keep them readable and maintainable.</li><li class="listitem">We can write many tests with boundary value conditions, null, zero, negative numbers, and so on, and verify our code. And by passing these boundary values, you're trying to break your own code. No need to package the whole application and ship it to<a id="id741" class="calibre1"/> <span class="strong"><strong class="calibre10">Quality Assurance</strong></span> (<span class="strong"><strong class="calibre10">QA</strong></span>) or the customer to discover issues.</li><li class="listitem">You also avoid over engineering the classes you write. Just write what's needed to make all tests green.</li><li class="listitem">Another benefit to incrementally build your code is that your API is easier to work with because the code is written and used at the same time.</li></ul></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec51" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This chapter explained the unit testing strategy for the legacy code and new development. It covered the legacy code issues, refactored the legacy code, illustrated design for testability, described the TDD concepts and TDD life cycle, demonstrated TDD examples, and refactoring.</p><p class="calibre9">Now the reader should be able to write unit tests for legacy code, refactor the legacy code to improve the design of the existing code, and start writing simple, clean, and maintainable code that follows TDD, and refactor the code to improve its quality.</p><p class="calibre9">The next chapter covers the best practices of unit testing.</p></div></body></html>