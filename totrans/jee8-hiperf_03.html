<html><head></head><body>
      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Monitor Your Application</h1>
            
         </header>
         
         
         <article>
            
            
            <p>When it comes to an application's performance, you will quickly need to know what
               your application does and get the metrics of performance. In this chapter, we will
               identify a few ways to get insights on applications.
            </p>
            
            <p>Thus, i<span>n this chapter, we will learn how to monitor our application's behavior in order to
                  be able to compare it with the response times and execution times we observe</span>. This will therefore show you the following:
            </p>
            
            <ul>
               
               <li style="font-weight: 400">How to add monitoring or profiling to an existing application</li>
               
               <li style="font-weight: 400">How to read important figures corresponding to the monitoring of an application</li>
               
               <li style="font-weight: 400">How to ensure that the application performance is monitored and that any unexpected
                  changes are visible
               </li>
               
            </ul>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Java tools to know what my application is doing</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Two critical factors are directly linked to performance when you take an application
               as a black box:
            </p>
            
            <ul>
               
               <li style="font-weight: 400"><strong>Memory usage</strong>: If too much memory is consumed, it can slow down the application or even make it
                  dysfunctional
               </li>
               
               <li style="font-weight: 400"><strong>CPU time</strong>: If an operation is too slow, it will consume a lot of CPU cycles and impact the
                  overall performance
               </li>
               
            </ul>
            
            <p>Without too much external tooling (except the <strong>Java Development Kit</strong> (<strong>JDK</strong>) and/or operating system tools), you can easily extract a lot of information and
               start working on the performance.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The jcmd command – the small command line utility that does a lot</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Since Java 8, the JDK has been coming with the <kbd>jcmd</kbd> command, which allows you to execute commands on a local Java instance using the
               same user/group as the instance you want to check.
            </p>
            
            <p>The usage of <kbd>jcmd</kbd>, although command-based, <span>is quite simple</span>. To understand it, we will first start our quote manager application with the command
               we saw in <a href="f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml">Chapter 1</a>, <em>Money – The Quote Manager Application</em>:
            </p>
            <pre><strong>mvn clean package embedded-glassfish:run</strong></pre>
            <p>Now in another console, just execute <kbd>jcmd</kbd>. On my system, it will dump what follows:
            </p>
            <pre><strong>$ jcmd</strong><br/><strong>4981 com.intellij.idea.Main</strong><br/><strong>7704 sun.tools.jcmd.JCmd</strong><br/><strong>7577 org.codehaus.plexus.classworlds.launcher.Launcher clean package embedded-glassfish:run</strong><br/><strong>5180 org.jetbrains.idea.maven.server.RemoteMavenServer</strong></pre>
            <p>The first column is the <strong>process ID</strong> (<strong>PID</strong>) of the program and what follows is the launching command (main and parameters).
               Since we launched our server with maven, we can identify it with the maven main (<kbd>org.codehaus.plexus.classworlds.launcher.Launcher</kbd>) or with the parameters that exactly match the command we launched (<kbd>clean package embedded-glassfish:run</kbd>).
            </p>
            
            <p>If you launch a standalone GlassFish, you will probably have a line like the following:</p>
            <pre>7877 com.sun.enterprise.glassfish.bootstrap.ASMain -upgrade false -domaindir /home/dev/glassfish5/glassfish/domains/domain1 -read-stdin true -asadmin-args --host,,,localhost,,,--port,,,4848,,,--secure=false,,,--terse=false,,,--echo=false,,,--interactive=true,,,start-domain,,,--verbose=false,,,--watchdog=false,,,--debug=false,,,--domaindir,,,/home/dev/glassfish5/glassfish/domains,,,domain1 -domainname domain1 -instancename server -type DAS -verbose false -asadmin-classpath /home/dev/glassfish5/glassfish/lib/client/appserver-cli.jar -debug false -asadmin-classname com.sun.enterprise.admin.cli.AdminMain</pre>
            <p>This one is pretty verbose but you can identify that the main (first string) references
               <kbd>glassfish</kbd> and you can find the domains directory to distinguish between multiple instances.
            </p>
            
            <p>To just give you another idea, if you use Apache Tomcat or TomEE, you will identify
               it with this line:
            </p>
            <pre><strong>8112 org.apache.catalina.startup.Bootstrap start</strong></pre>
            <p>Now, we have the PID of our Java process; we can pass it to <kbd>jcmd</kbd>:
            </p>
            <pre><strong>jcmd &lt;PID&gt; help</strong></pre>
            <p>For example, for our previous maven GlassFish instance, it will look like the following:</p>
            <pre><strong>jcmd 7577 help</strong></pre>
            <p>The output should look like the following:</p>
            <pre><strong>7577:</strong><br/><strong>The following commands are available:</strong><br/><strong>JFR.stop</strong><br/><strong>JFR.start</strong><br/><strong>JFR.dump</strong><br/><strong>JFR.check</strong><br/><strong>VM.native_memory</strong><br/><strong>VM.check_commercial_features</strong><br/><strong>VM.unlock_commercial_features</strong><br/><strong>ManagementAgent.stop</strong><br/><strong>ManagementAgent.start_local</strong><br/><strong>ManagementAgent.start</strong><br/><strong>GC.rotate_log</strong><br/><strong>Thread.print</strong><br/><strong>GC.class_stats</strong><br/><strong>GC.class_histogram</strong><br/><strong>GC.heap_dump</strong><br/><strong>GC.run_finalization</strong><br/><strong>GC.run</strong><br/><strong>VM.uptime</strong><br/><strong>VM.flags</strong><br/><strong>VM.system_properties</strong><br/><strong>VM.command_line</strong><br/><strong>VM.version</strong><br/><strong>help</strong></pre>
            <p>As you can see, the output is basically a list of commands that you can invoke using
               <kbd>jcmd</kbd>. A lot of these commands are informative, such as <kbd>VM.version</kbd> (which will just log which JVM you are using), but some commands are actual actions,
               such as <kbd>GC.run</kbd> (which will call <kbd>System.gc()</kbd>). Concerning the performance, we are interested in <kbd>Thread.print</kbd>, which is a replacement of <kbd>jstack</kbd>. GC data commands, such as <kbd>GC.class_histogram</kbd>, are related to the garbage collection data, while the <kbd>JFR</kbd> commands are related to <strong>Java Flight Recorder</strong>.
            </p>
            
            <p>Let's start with the most basic but also probably the most important command: <kbd>Thread.print</kbd>. This will allow us to see what our application is doing by digging into the <em>current</em> thread stack of our application.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Thread.print</h1>
            
         </header>
         
         
         <article>
            
            
            <p>If you execute the <kbd>Thread.print</kbd> command, the output will look like the following:
            </p>
            <pre>$ jcmd 7577 Thread.print<br/>7577:<br/>2017-09-10 16:39:12<br/>Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed mode):<br/><br/>"....." #xxx [daemon] prio=xxx os_prio=xxx tix=0x.... nid=0x.... [condition]<br/>  java.lang.Thread.State: XXXXX<br/>  at ......<br/>  at ......<br/>  ...<br/><br/><br/>"....." #xxx [daemon] prio=xxx os_prio=xxx tix=0x.... nid=0x.... [condition]<br/>  java.lang.Thread.State: XXXXX<br/>  at ......<br/>  at ......<br/>  ...<br/><br/><br/>"....." #xxx [daemon] prio=xxx os_prio=xxx tix=0x.... nid=0x.... [condition]<br/>  java.lang.Thread.State: XXXXX<br/>  at ......<br/>  at ......<br/>  ...</pre>
            <p>Since reproducing the full output of this command will take the entire chapter, it
               has been replaced by a skeleton of sorts of the thread stacks. What is important here
               is to identify that each block starting with a line that has quotes is a thread.
            </p>
            
            <p>Therefore, the dump repeats this pattern:</p>
            <pre>"thread_name" #thread_id_as_int [daemon if the thread is daemon] prio=java_priority os_prio=native_priority tid=thread_id_pointer_format nid=native_id [state]<br/>   thread_stack_trace</pre>
            <p>When the server is idle—that is, when it is not serving any request or executing any
               scheduled tasks—we can identify that most of the threads are just waiting for a task
               (in thread pools):
            </p>
            <pre>"dol-jar-scanner" #50 daemon prio=5 os_prio=0 tid=0x00007f3b7dd0a000 nid=0x1ddf waiting on condition [0x00007f3ae6bae000]<br/>   java.lang.Thread.State: WAITING (parking)<br/>  at sun.misc.Unsafe.park(Native Method)<br/>  - parking to wait for &lt;0x00000000877529a8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)<br/>  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)<br/>  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)<br/>  at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)<br/>  at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)<br/>  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)<br/>  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br/>  at java.lang.Thread.run(Thread.java:748)</pre>
            <p>To understand this dump, you will need to know how <kbd>ExecutorService</kbd> works. It basically creates threads with tasks called <em>Workers</em>, and each work can take some tasks from a queue (to simplify things). Here we can
               see the following:
            </p>
            
            <ul>
               
               <li><kbd>ThreadPoolExecutor$Work</kbd>, which means that we are in a thread pool task handler
               </li>
               
               <li><kbd>LinkedBlockingQueue.take</kbd>, which means that the thread is waiting for a new task
               </li>
               
            </ul>
            
            <p>We can also identify in this dump some incoming requests in the I/O layer, such as
               waiting for a socket to connect to an NIO <kbd>Selector</kbd>:
            </p>
            <pre>"http-listener-kernel(1) SelectorRunner" #27 daemon prio=5 os_prio=0 tid=0x00007f3b7cfe7000 nid=0x1dc8 runnable [0x00007f3b1eb7d000]<br/>   java.lang.Thread.State: RUNNABLE<br/>  at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)<br/>  at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)<br/>  at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)<br/>  at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)<br/>  - locked &lt;0x000000008675cc20&gt; (a sun.nio.ch.Util$3)<br/>  - locked &lt;0x000000008675cc10&gt; (a java.util.Collections$UnmodifiableSet)<br/>  - locked &lt;0x000000008675c1f8&gt; (a sun.nio.ch.EPollSelectorImpl)<br/>  at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)<br/>  at org.glassfish.grizzly.nio.DefaultSelectorHandler.select(DefaultSelectorHandler.java:115)<br/>  at org.glassfish.grizzly.nio.SelectorRunner.doSelect(SelectorRunner.java:339)<br/>  at org.glassfish.grizzly.nio.SelectorRunner.run(SelectorRunner.java:279)<br/>  at org.glassfish.grizzly.threadpool.AbstractThreadPool$Worker.doWork(AbstractThreadPool.java:593)<br/>  at org.glassfish.grizzly.threadpool.AbstractThreadPool$Worker.run(AbstractThreadPool.java:573)<br/>  at java.lang.Thread.run(Thread.java:748)</pre>
            <p>An important line here is either <kbd>epollWait</kbd> (if you are familiar with OS natives) or <kbd>Selector*.select</kbd> (if you are more familiar with the Java side of the code, which means it is waiting
               for a connection).
            </p>
            
            <p><span>Now, if we inject some requests into our application (let's just use Apache Bench
                  or <strong>AB</strong> to undertake some</span> <kbd>GET</kbd><span> requests on our</span> <kbd>findById</kbd> <span>endpoint), we can see some threads that are actually working. (Note that because of
                  its length and to avoid having several pages of thread stacktrace, the</span> <kbd>[...]</kbd> <span>have been shortened):</span></p>
            <pre>"http-listener(3)" #23 daemon prio=5 os_prio=0 tid=0x00007f3b7d063800 nid=0x1dc4 runnable [0x00007f3b1ef7d000]<br/>   java.lang.Thread.State: RUNNABLE<br/>  [...]<br/>  at com.sun.enterprise.connectors.ConnectionManagerImpl.internalGetConnection(ConnectionManagerImpl.java:254)<br/>  [...]<br/>  at com.sun.gjc.spi.base.AbstractDataSource.getConnection(AbstractDataSource.java:115)<br/>  at org.eclipse.persistence.sessions.JNDIConnector.connect(JNDIConnector.java:135)<br/>  [...]<br/>  at org.eclipse.persistence.queries.ObjectLevelReadQuery.executeDatabaseQuery(ObjectLevelReadQuery.java:1221)<br/>  at org.eclipse.persistence.queries.DatabaseQuery.execute(DatabaseQuery.java:911)<br/>  at org.eclipse.persistence.queries.ObjectLevelReadQuery.execute(ObjectLevelReadQuery.java:1180)<br/>  at org.eclipse.persistence.queries.ReadAllQuery.execute(ReadAllQuery.java:464)<br/>  [...]<br/>  at org.eclipse.persistence.indirection.IndirectSet.size(IndirectSet.java:624)<br/>  [...]<br/>  at java.util.Optional.map(Optional.java:215)<br/>  at com.github.rmannibucau.quote.manager.front.QuoteResource.findById(QuoteResource.java:48)<br/>  [...]<br/>  at org.glassfish.jersey.servlet.WebComponent.service(WebComponent.java:370)<br/>  at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:389)<br/>  [...]<br/>  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)<br/>  at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:256)<br/>  at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:160)<br/>  [...]<br/>  at org.glassfish.grizzly.http.server.HttpHandler.runService(HttpHandler.java:206)<br/>  at org.glassfish.grizzly.http.server.HttpHandler.doHandle(HttpHandler.java:180)<br/>  [...]<br/>  at org.glassfish.grizzly.threadpool.AbstractThreadPool$Worker.doWork(AbstractThreadPool.java:593)<br/>  at org.glassfish.grizzly.threadpool.AbstractThreadPool$Worker.run(AbstractThreadPool.java:573)<br/>  at java.lang.Thread.run(Thread.java:748)<br/><br/></pre>
            <p>There are other kinds of thread stacks but this one is particularly interesting, as
               we can identify most of our endpoint stacks. Keep in mind that we are calling a JAX-RS
               endpoint that calls JPA to find a quote that will rely on <kbd>DataSource</kbd> to connect to the current database. We can identify the JAX-RS layer with <kbd>org.glassfish.jersey lines</kbd>, the JPA layer with the <kbd>org.eclipse.persistence</kbd> lines, our application with our own package (<kbd>com.github.rmannibucau</kbd>, in this example), and the datasource connection retrieval with the <kbd>ConnectionManager</kbd> lines. We can also identify that Jersey (JAX-RS implementation of GlassFish) is deployed
               over Tomcat, thanks to the <kbd>org.apache.catalina</kbd> packages (but only for the application pipeline management) and Grizzly for I/O handling
               (<kbd>org.glassfish.grizzly</kbd> packages).
            </p>
            
            <p>This analysis is interesting as it shows something you need to take care of in Java
               EE: Java EE defines APIs but the runtime actually runs implementations. You rarely
               see <kbd>javax.*</kbd> entries in thread dumps, so you may need to check which implementations your server
               uses to make your analysis easier and faster.
            </p>
            
            <p>Now the question is, can we conclude anything about this stack? Yes, of course! We
               can conclude that our application goes through the stack we expected. However, in
               terms of the performance, it doesn't mean anything. What will be impacting is how
               often you see the same stack being called. Concretely, if you see 30 threads over
               100 waiting in a particular call, it may mean that this is a good place to optimize.
               If the stack even adds BLOCKED next to the line, it means that you need to ensure
               it is normal for the application to lock here and, maybe, change something (either
               the code or the configuration).
            </p>
            
            <p>Before going on to the next section, keep in mind that you can get the same kind of
               output in multiple ways. The <kbd>jstack</kbd> tool is another Java tool that you can use for doing more or less the same thing,
               but an interesting tip is to use Linux (or Windows) native tools to get exactly the
               same information. If you have JRE (Java without the development tools) instead of
               JDK, here is how to do it on Linux:
            </p>
            <pre><strong>kill -3 $JAVA_SERVER_PID</strong></pre>
            
            
            </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Memory</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The <kbd>GC.class_histogram</kbd> command allows you to get a heap histogram. We will deal with this in the coming
               sections. But just to sum up very quickly, the heap is where most of your Java objects
               will go. Therefore, it is important to see how it is used.
            </p>
            
            <p>If we execute the <span><kbd>GC.class_histogram</kbd> </span>command in our process, the output will look as follows:
            </p>
            <pre><strong>$ jcmd 7577 GC.class_histogram</strong><br/><strong>7577:</strong><br/><br/><strong> num #instances #bytes class name</strong><br/><strong>----------------------------------------------</strong><br/><strong>   1: 192795 16202648 [C</strong><br/><strong>   2: 10490 4667040 [B</strong><br/><strong>   3: 191582 4597968 java.lang.String</strong><br/><strong>   4: 38779 3412552 java.lang.reflect.Method</strong><br/><strong>   5: 20107 2243296 java.lang.Class</strong><br/><strong>   6: 70045 2241440 java.util.HashMap$Node</strong><br/><strong>   7: 24429 2078312 [Ljava.util.HashMap$Node;</strong><br/><strong>   8: 47188 1887520 java.util.LinkedHashMap$Entry</strong><br/><strong>   9: 28134 1745104 [Ljava.lang.Object;</strong><br/><strong>  38: 2175 121800 com.sun.tools.javac.file.ZipFileIndex$DirectoryEntry</strong><br/><strong>  39: 1890 120960 com.mysql.jdbc.ConnectionPropertiesImpl$BooleanConnectionProperty</strong><br/><strong>1739: 6 192 java.util.regex.Pattern$3</strong><br/><strong>2357: 1 96 com.sun.crypto.provider.SunJCE</strong><br/><strong>2478: 4 96 org.glassfish.jersey.server.AsyncContext$State</strong><br/><strong>2548: 1 88 org.glassfish.ejb.startup.EjbDeployer</strong><br/><strong>2558: 2 80 [Lcom.mysql.jdbc.StringUtils$SearchMode;</strong><br/><strong>2649: 2 80 org.glassfish.kernel.embedded.EmbeddedDomainPersistence</strong><br/><strong>2650: 2 80 org.glassfish.persistence.jpa.PersistenceUnitInfoImpl</strong><br/><strong>2652: 1 80 org.hibernate.validator.internal.engine.ConfigurationImpl</strong><br/><strong>2655: 5 80 org.jboss.weld.manager.BeanManagerImpl</strong><br/><strong>2678: 1 72 [Lorg.glassfish.jersey.uri.UriComponent$Type;</strong><br/><strong>2679: 2 72 [Lsun.security.jca.ProviderConfig;</strong><br/><strong>2680: 1 72 com.github.rmannibucau.quote.manager.model.Quote</strong><br/><strong>2689: 3 72 com.sun.enterprise.container.common.impl.ComponentEnvManagerImpl$FactoryForEntityManagerWrapper</strong><br/><strong>2770: 3 72 org.eclipse.persistence.jpa.jpql.parser.TableExpressionFactory</strong><br/><strong>6925: 1 16 sun.reflect.ReflectionFactory</strong><br/><strong>Total 1241387 61027800</strong></pre>
            <p>Here again, it is a partial output (truncated in multiple places) since it is too
               verbose for this book. If we find most of the environments we know, it is important
               to notice the following things:
            </p>
            
            <ul>
               
               <li><kbd>com.mysql</kbd> for the JDBC driver our application uses
               </li>
               
               <li><kbd>com.github.rmannibucau</kbd> for our application (the quote entity in particular)
               </li>
               
               <li><kbd>com.sun.enterprise</kbd> for the GlassFish server
               </li>
               
               <li><kbd>org.jboss.weld</kbd> for the CDI container of GlassFish
               </li>
               
               <li><kbd>org.hibernate.validator</kbd> for the GlassFish bean validation implementation
               </li>
               
               <li><kbd>sun</kbd>, <kbd>com.sun</kbd>, <kbd>java</kbd>, and so on for the JVM
               </li>
               
            </ul>
            
            <p>Now, an important thing is to be able to interpret these figures. The first column
               is not very important but the next two are. As written in the table header, they represent
               the number of instances and their size in bytes.
            </p>
            
            <p>If you run several concurrent requests on your server and filter the output for your
               quote entity, you can see the following:
            </p>
            <pre><strong> 138:           591          42552  com.github.rmannibucau.quote.manager.model.Quote</strong></pre>
            <p>This line means that the heap currently has 591 instances of <kbd>Quote</kbd> and it takes 42,552 bytes.
            </p>
            
            <p>This means that it is a statistic you can check in real time while the server is running.
               But as it is written in the command help, it impacts the server (slows it down), so
               you need to use it for tuning purposes only.
            </p>
            
            <p>The last interesting figure of the <kbd><span>GC.class_histogram</span></kbd> command is the total size of the heap, which is the last number printed. In our previous
               output, it was 61,027,800 bytes (about 61 MB).
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">JVisualVM – the UI for JVM monitoring</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The <kbd>jcmd</kbd> command is a great command-line tool but is a bit raw. However, the JVM provides
               additional tooling to yield metrics linked to performance and, in particular, the
               CPU and memory. <kbd>JVisualVM</kbd> and <kbd>JConsole</kbd> are two such tools packaged with the JDK (not the JRE). Since both are pretty similar,
               we will only deal with <kbd>JVisualVM</kbd> in this section, but most of the information and tools can be used with <kbd>JConsole</kbd> as well.
            </p>
            
            <p>To launch <kbd>JVisualVM</kbd>, you just have to execute a command of the same name:
            </p>
            <pre><strong>$ $JAVA_HOME/bin/jvisualvm</strong></pre>
            <p>Once launched, you will see the welcome screen of <kbd>jvisualvm</kbd>:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/d7a26942-48ca-4a2f-b280-6b95d6291fae.png"/></div>
            
            <p>To start using <kbd>jvisualvm</kbd>, you will need to select a JVM. This is done through the tree on the left-hand side
               of the screen. The two options are <span class="packt_screen">Local</span> and <span class="packt_screen">Remote</span>. In this case, we'll run the server on our local machine, so it is automatically
               detected by <kbd>jvisualvm</kbd> (just ensure to start it from the same JDK as the one the server is using). In the
               previous screenshot, you can see three processes:
            </p>
            
            <ul>
               
               <li><kbd>VisualVM</kbd>: This is a Java process and detects itself.
               </li>
               
               <li><kbd>GlassFish</kbd>: This is a standalone GlassFish server.
               </li>
               
               <li><kbd>org.codehaus.plexus.classworlds.launcher.Launcher</kbd>: This is a maven process. If you start GlassFish with maven, as we saw in <a href="f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml">Chapter 1</a>, <em>Money – The Quote Manager Application</em>, this is the process to choose.
               </li>
               
            </ul>
            
            <p>Once you have identified your process in the list, you need to double-click on it
               and you will get the following screen showing high-level information about the process:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/7ea6385a-b6ba-40fb-b27a-d48215f06c26.png"/></div>
            
            <p>Once you have selected a JVM on the left, the right pane will show information about
               the JVM. It is organized in tabs:
            </p>
            
            <ul>
               
               <li style="font-weight: 400"><span class="packt_screen">Overview</span>: This gives high-level information about the JVM (process ID, main class, arguments,
                  Java version, system properties, and so on).
               </li>
               
               <li style="font-weight: 400"><span class="packt_screen">Monitor</span>: This gives an overview of the CPU usage, the memory usage (in particular, the heap),
                  the number of classes loaded, and the number of threads.
               </li>
               
               <li style="font-weight: 400"><span class="packt_screen">Threads</span>: This gives a live view of the existing threads managed by the JVM and shows the
                  thread state over time (whether it is idled or active). Here is a screenshot:
               </li>
               
            </ul>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/aaa560d5-7b79-43dc-ad75-58df9d02a6a5.png"/></div>
            
            <p style="padding-left: 60px">The legend is in the bottom-right corner and uses colors to help this view to be readable: green
               for running, purple for sleeping, yellow for wait, red for fork, and orange for monitor.
            </p>
            
            <p style="padding-left: 60px">What is interesting are the green blocks. This is when a thread does something. If
               you take the <span class="packt_screen">http-listener(x)</span> threads for instance, you can see that they are orange and green. The orange part
               is when the threads are waiting for requests and the green part is when they are serving
               something. This view must be coupled with the thread dumps (or thread stack view)
               to ensure that the waiting threads are actually waiting for something relevant (such
               as waiting for some I/O), which the application does not control.
            </p>
            
            <ul>
               
               <li><span class="packt_screen">Sampler</span>: This tab is very interesting and allows you to capture what the server is doing
                  in terms of CPU and memory. We find some information that we had with <kbd>jcmd</kbd>, but this is easier to use. All you need to do is to click on the <span class="packt_screen">CPU</span> or <span class="packt_screen">Memory</span> button and <kbd>jvisualvm</kbd> will start capturing the related information. Here is the memory view that you will
                  get once some samples have been captured:
               </li>
               
            </ul>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/9a972a09-dc1f-46ae-a3a8-57e670c2de75.png"/></div>
            
            <p style="padding-left: 60px">This view is really close to the GC histogram command of <kbd>jcmd</kbd>; you'll find the class name, the corresponding size in bytes, and the number of instances.
               You can filter the visible classes at the bottom using any pattern related to your
               application; in this screenshot, we filtered by <span class="packt_screen">Quote</span>.
            </p>
            
            <p style="padding-left: 60px">If you capture some CPU samples, the view is centered on the methods and their execution
               time:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/6b32bad0-b22b-4ecd-81ba-b667df2bf656.png"/></div>
            
            <p style="padding-left: 60px">The first column is the method identifier and the other columns show the corresponding
               time for the respective methods. <span class="packt_screen">Self Time</span> is the time of the method itself. <span class="packt_screen">Self Time (CPU)</span> is the same but ignores waiting time (locks and so on). Same goes for the <span class="packt_screen">Total Time</span> columns. What is the main difference between the <span class="packt_screen">Self Time</span> and the <span class="packt_screen">Total Time</span> columns? The <span class="packt_screen">Total Time</span> columns include further method calls, which the <span class="packt_screen">Self Time</span> columns don't.
            </p>
            
            <div class="packt_tip">While on the CPU view, you can click on <span class="packt_screen">Thread Dump</span> to get a thread dump, the same as for <kbd>jcmd</kbd> but it is directly accessible in <kbd>jvisualvm</kbd>.
            </div>
            
            <ul>
               
               <li><span class="packt_screen">Profiler</span>: This is the last tab of the JVM view and provides more or less the same view as
                  the <span class="packt_screen">Sampler</span> tab. The main difference is the way it captures the data. Don't worry if <span>the time between your click and the first data you can see is quite long in</span> <span class="packt_screen">Profiler</span>. While the <span class="packt_screen">Sampler</span> tab just takes a <em>screenshot</em> of the JVM (memory or thread stacks) from time to time and generates approximate
                  statistics from them, the <span class="packt_screen">Profiler</span> tab modifies the classes (actual bytecode) to capture accurate data. This implies
                  that the sampling overhead is not very huge but the profiling overhead can be if it
                  affects all the codebase, including the fast methods (which are instrumented by default).
                  If you want precise metrics, you will need to use the profiler, but it is recommended
                  that you hit the <span class="packt_screen">Settings</span> checkbox to precisely tune which classes you want to get the metrics for and not
                  let the defaults, which are too wide to not affect the system.
               </li>
               
            </ul>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">How to connect remotely</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Connecting locally is easy since <kbd>jvisualvm</kbd> will just locally look up the running JVM. But for connecting remotely, you will
               need some more setup.
            </p>
            
            <p>All the communication relies on JMX and, therefore, you need to set up a remote JMX
               connection. This relies on what is called a connector (can be seen as a small embedded
               JMX server). There are multiple protocols available but out of the box; they rely
               on RMI communications and system properties to be configured.
            </p>
            
            <p>To add these system properties, the fastest and easiest way is as follows:</p>
            <pre><strong>-Dcom.sun.management.jmxremote.port=1234</strong><br/><strong>-Dcom.sun.management.jmxremote.ssl=false</strong><br/><strong>-Dcom.sun.management.jmxremote.authenticate=false</strong></pre>
            <p>It will enable JMX on port 1234 and disable SSL and security. For performances, we
               don't need more, but if you want to keep it in production, you may need to configure
               the security and SSL. For more details on how to do so, you can refer to the Oracle
               website at <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html">https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html</a>.
            </p>
            
            <p>Once this is configured, you just have to right-click on the <span class="packt_screen">Local</span> item in the tree on the left side, select <span class="packt_screen">Add JMX Connection</span>, and fill in the related information (host/port and the potential credentials if
               you've configured the security).
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Java Mission Control</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Since Java 7u40, the JDK has included the Java Flight Recorder tool. If you remember
               the available commands in <kbd>jcmd</kbd>, you had some <kbd>JFR.*</kbd> options, which are directly related to this tool. It allows you to capture a set
               of JVM events. It is coupled with <strong>Java Mission Control</strong> (<strong>JMC</strong>), which enables you to analyze and exploit the JVM events.
            </p>
            
            <p>Launching it is easy<span>:</span></p>
            <pre><strong>$ $JAVA_HOME/bin/jmc</strong></pre>
            <p>Once it is launched, you'll get a welcome screen; the view looks similar to the <kbd>jvisualvm</kbd> view, with a list of the available processes on the left-hand side:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/88479a83-56f5-41db-91d6-ac8e0c6883f4.png"/></div>
            
            <p>You can use the same kind of hints as for <kbd>jvisualvm</kbd> <span>to identify the process. </span>If you are not quite sure, don't hesitate to use the <kbd>jps -v</kbd> command, which will show you the command line and its PID for each running JVM (which
               will allow you to identify the number in parentheses in JMC).
            </p>
            
            <p>Once you've identified your process, you can right-click on it and select the <span class="packt_screen">Start JMX</span> console to have a view similar to <kbd>jvisualvm</kbd> and specific to the selected JVM:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/eb6fd349-8bd8-410e-a755-1a0333595293.png"/></div>
            
            <p>You find the CPU (processor here), the memory, and thread information, and also the
               MBean view, which is how the JVM can export the internal data in a standard manner.
            </p>
            
            <p><span>One interesting thing is when you go to</span> the <span class="packt_screen">Diagnostic Commands</span> <span>tab you will recognize the </span><kbd>jcmd</kbd><span> commands listed:</span></p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="538" src="assets/90602a7e-d088-4c1f-951d-74ce83713c37.png" width="451"/></div>
            
            <p>This pane allows you to execute the <kbd>jcmd</kbd> commands directly from the UI. Here, we are interested in the <span><strong>Java Flight Recorder</strong> </span>(<strong>JFR</strong>) commands, as we want more information about our JVM.
            </p>
            
            <p>In the previous screenshot, you may have noted that there is a <span class="packt_screen">Flight Recorder</span> item on the left tree. It provides a UI for these commands. However, if you hit <span class="packt_screen">Start Recording</span>, you will get the following error:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="207" src="assets/43cd46f7-8ad2-4d86-958f-727a669504d1.png" width="422"/></div>
            
            <p>To use Java Flight Recorder, you need to add the following options to your JVM:</p>
            <pre><strong>-XX:+UnlockCommercialFeatures -XX:+FlightRecorder</strong></pre>
            <p class="mce-root">These two options will activate the Java Flight Recorder features. To add them to
               GlassFish, you can edit the <kbd>$GLASSFISH_HOME/glassfish/domains/domain1/config/domain.xml</kbd> file and add it to the <kbd>java-config</kbd> block after <kbd>jvm-options</kbd>. Alternatively, you can use the <kbd>create-jvm-options</kbd> command line's <kbd>glassfish</kbd> command. In any case, you will need to restart (or start) your server after this
               modification.
            </p>
            
            <p>If you want to test it using our maven GlassFish, you can just add them to <kbd>MAVEN_OPTS</kbd>:
            </p>
            <pre><strong>$ MAVEN_OPTS="-XX:+UnlockCommercialFeatures -XX:+FlightRecorder" mvn embedded-glassfish:run</strong></pre>
            <p>Now the options are activated on the JVM; you can go back to Java Mission Control
               and hit <span class="packt_screen">Start Recording</span> on the <span class="packt_screen">Start Flight Recorder</span> item. It will ask you a file location to store the recording and either a duration
               or a limit (size/age) for the recording. Finally, you can select whether you want
               to profile your server or just to monitor it. Here again, the difference is in the
               associated overhead. Let's select profiling for now. You can then hit <span class="packt_screen">Next</span> and select what you want to monitor. An important parameter is the heap one, but
               if you continue through the wizard, you will see that you can precisely customize
               what you monitor, including the I/O. Once everything is well configured, simply hit
               <span class="packt_screen">Finish</span>. It will proceed with the recording and open it once done.
            </p>
            
            <div class="packt_tip">For the first time, select <span class="packt_screen">1 min</span> as the recording duration; it will prevent you from waiting for too long.
            </div>
            
            <p class="mce-root">After the recording is done, you should get a view similar to the following one, showing
               the captured data:
            </p>
            
            <div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/2c39e00f-0dbb-4552-b92d-c6da0799d962.png"/></div>
            
            <p>Looking at the top, we can see the event timeline. You can click on it to refine the
               time-slot selection. The counters show the summary of the capture in terms of memory
               and CPU. Finally, at the bottom, you have the CPU and memory graph.
            </p>
            
            <p>What makes this tool more advanced than the previous one is the fact that you can
               visualize the code hotspot in the <span class="packt_screen">Code</span> tab (the tabs are on the left in this tool) and the I/O in a single tool. The in-built
               JDK also makes it quite easy to use, whereas the overhead is not as important (if
               you select continuous monitoring, a counterpart is that the statistics won't be very
               accurate but close enough so as to give you an idea). <span>A major strength of this tool is the</span> <span class="packt_screen">Call Tree</span> <span>view of the <span class="packt_screen">Code</span></span> tab<span>. It allows you to associate, through a stack, the method execution time cost with
                  the method calls. For instance, while the server was running, this capture shows that
                  the cost of our</span> <kbd>findAll</kbd> <span>method is mainly related to the way we are mapping each</span> quote that requires using the JPA layer (eclipselink) and the database:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/a5185f39-2577-4661-8380-12f600d29bba.png"/></div>
            
            <p>This view is a really great way to investigate the hotspots of the application. It
               kind of merges the thread dumps and the profiling views (sometimes called <em>Path Tracking</em>) and enables you to get directly to the costly operations.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">GlassFish ad hoc monitoring</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Many servers have inbuilt monitoring capabilities. This depends highly on the server,
               but it can give some interesting insights without having to use another tool. This
               is precious when you don't control the machine or don't have the permissions to access/configure
               the server.
            </p>
            
            <p>To illustrate this kind of monitoring, let's use our Java EE reference implementation:
               GlassFish.
            </p>
            
            <p>Once started with the normal<span> </span><kbd>./bin/asadmin start-domain</kbd><span> command, you can activate monitoring with this additional command:</span></p>
            <pre>$ ./bin/asadmin enable-monitoring<br/><strong>Command enable-monitoring executed successfully.</strong></pre>
            <p>Indeed, there is a symmetric command if you want to deactivate monitoring:</p>
            <pre><span><strong>$./bin/asadmin disable-monitoring</strong><br/></span></pre>
            <p>You can list the monitors available with the <kbd>get</kbd> command:
            </p>
            <pre><strong>$ ./bin/asadmin get server.monitoring-service.*</strong><br/><strong>server.monitoring-service.module-monitoring-levels.cloud=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.cloud-elasticity=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.cloud-orchestrator=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.cloud-tenant-manager=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.cloud-virt-assembly-service=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.connector-connection-pool=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.connector-service=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.deployment=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.ejb-container=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.http-service=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.jdbc-connection-pool=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.jersey=HIGH</strong><br/><strong>server.monitoring-service.module-monitoring-levels.jms-service=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.jpa=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.jvm=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.orb=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.security=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.thread-pool=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.transaction-service=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.web-container=OFF</strong><br/><strong>server.monitoring-service.module-monitoring-levels.web-services-container=OFF</strong><br/><strong>server.monitoring-service.dtrace-enabled=false</strong><br/><strong>server.monitoring-service.mbean-enabled=true</strong><br/><strong>server.monitoring-service.monitoring-enabled=true</strong><br/><strong>Command get executed successfully.</strong></pre>
            <p>This output shows that the Jersey monitoring level is <kbd>HIGH</kbd> but other ones are disabled (<kbd>OFF</kbd>).
            </p>
            
            <p>An alternative is to use the administration UI (by default on <kbd>http://localhost:4848</kbd>, for a standalone installation). Going to your configuration part on the left tree,
               you will have a <span class="packt_screen">Monitoring</span> item where you can access the exact same entries:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/4e9ffa0f-3b31-410a-8722-aa4d3308a839.png"/></div>
            
            <p>Selecting the level you want on the left of the table for the corresponding module
               will activate the associated monitoring. Once the monitoring is activated, you'll
               generally need to restart the server to let GlassFish take it into account.
            </p>
            
            <p>Once it is done, you can access the associated information through the <span class="packt_screen">Monitoring Data</span> item of the left tree:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/6d6d1771-f9b8-49be-80b4-9579ca0fae1c.png"/></div>
            
            <p>Here, you can see the monitored instances. (If you use a standalone GlassFish, you
               will probably have a single entry.) The <span class="packt_screen">View Monitoring Data</span> column will let you select the data you want to see. If you click on <span class="packt_screen">Application</span>, for instance, you will obtain the corresponding screen with the information filled
               in, depending on the monitoring level you activated before. Here is a sample screenshot:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img src="assets/606466a5-ce14-4b6b-8fb7-200cf0cb782c.png"/></div>
            
            <p>Depending on the application, this is more or less useful. However, for us (a JAX-RS
               service), the <span class="packt_screen">Request Statistics</span> block is interesting even if it gives high-level information. We can use it to monitor
               the <span>maximum </span>response time and error count. By itself, it will not be enough to improve the performance,
               but it will enable us to compare it with the client-side information; we can then
               easily obtain and validate our performance testing.
            </p>
            
            <p>It is important to keep in mind that servers often give aggregated performance figures
               for recent production monitoring, not performance tuning. This doesn't mean that it
               is useless but that you will only rely on ad hoc monitoring to validate your performance
               measurement pipeline (your client or your request injector, to put it simply).
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Libraries monitor your application</h1>
            
         </header>
         
         
         <article>
            
            
            <p>We saw what the JVM provides us with tools and what the server gives us performance
               hints, but there are a lot of libraries intended to help you work on the performance.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Counters, gauges, timers, and more</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The most famous library is probably <em>Metrics</em> from Dropwizard (<a href="http://metrics.dropwizard.io">http://metrics.dropwizard.io</a>) but all libraries share more or less the same sort of API. The metrics are centered
               around a few important concepts:
            </p>
            
            <ul>
               
               <li style="font-weight: 400"><strong>Gauges</strong>: These provide the measure of a value at a certain time. They are intended to build
                  a time series. Most famous examples are the CPU or memory usages.
               </li>
               
               <li style="font-weight: 400"><strong>Counters</strong>: These are long values, often associated with a gauges in order to build time series.
               </li>
               
               <li style="font-weight: 400"><strong>Histogram</strong>: This structure allows you to compute the statistics around a value, for instance,
                  the mean or the percentiles of request lengths.
               </li>
               
               <li style="font-weight: 400"><strong>Timers</strong>: These are a bit like histograms; they compute other metrics based on one metric.
                  Here, the goal is to have information about the rate of a value.
               </li>
               
               <li style="font-weight: 400"><strong>Health checks</strong>: These are less related to the performance; they allows you to validate that a resource
                  (such as a database) is working or not. Health checks throw a warning/error if the
                  resource isn't working.
               </li>
               
            </ul>
            
            <p>All these libraries provide different ways to export/expose the collected data. Common
               configurations are related to JMX (through MBeans), Graphite, Elasticsearch, and so
               on, or just the console/logger as the output.
            </p>
            
            <p>How can these concepts be linked to the performance? The most important features for
               us will be the gauges and the counters. The gauges will enable us to make sure the
               server is doing well (for example, the CPU is not always at 100%, the memory is well
               released, and so on). The counters will enable us to measure the execution time. They
               will also enable us to export the data in an aggregated storage if you test against
               multiple instances, allowing you to detect some potential side effects of one instance
               on another one (if you have any clustering for example).
            </p>
            
            <p>Concretely, we want to measure some important segments of our code. In the extreme
               case, if you don't know anything about the application, you will likely want to measure
               all parts of the code then refine it when you have more knowledge about your application.
            </p>
            
            <p>To be very concrete and illustrate what we are trying to achieve, we want to replace
               application methods by this kind of pattern:
            </p>
            <pre><span>@GET<br/></span><span>@Path</span>(<span>"{id}"</span>)<br/><span>public </span>JsonQuote findById(<span>@PathParam</span>(<span>"id"</span>) <span>final long </span>id) {<br/>    final Timer.Context metricsTimer = getMonitoringTimer("findById").time();<br/>    try {<br/>        <span>return defaultImpl()</span>;<br/>    } finally {<br/>        metricsTimer.stop();<br/>    }<br/>}</pre>
            <p>In other words, we want to surround our business code with a timer to collect statistics
               about our execution time. One common and <em>poor man</em> solution you can be tempted to start with is to use loggers to do it. It often looks
               as follows:
            </p>
            <pre><span>@GET<br/></span><span>@Path</span>(<span>"{id}"</span>)<br/><span>public </span>JsonQuote findById(<span>@PathParam</span>(<span>"id"</span>) <span>final long </span>id) {<br/>    final long start = System.nanoTime();<br/>    try {<br/>        <span>return defaultImpl()</span>;<br/>    } finally {<br/>        final long end = System.nanoTime();<br/>        MONITORING_LOGGER.info("perf(findById) = " +<br/>        TimeUnit.NANOSECONDS.toMillis(end - start) + "ms");<br/>    }<br/>}</pre>
            <p>The preceding code manually measures the execution time of the method and, then, dumps
               the result with a description text in a specific logger to identify the code portion
               it is related to.
            </p>
            
            <p>In doing so, the issue you will encounter is that you will not get any statistics
               about what you measure and will need to preprocess all the data you collect, delaying
               the use of the metrics to identify the hotspots of your application and work on them.
               This may not seem like a big issue, but as you are likely to do it many times during
               a benchmark phase, you will not want to do it manually.
            </p>
            
            <p>Then, the other issues are related to the fact that you need to add this sort of code
               in all the methods you want to measure. Thus, you will pollute your code with monitoring
               code, which is rarely worth it. It impacts even more if you add it temporarily to
               get metrics and remove it later. This means that you will try to avoid this kind of
               work as much as possible.
            </p>
            
            <p>The final issue is that you can miss the server or library (dependency) data, as you
               don't own this code. That means that you may spend hours and hours working on a code
               block that is, in fact, not the slowest one.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Instrumenting the code</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The immediate question is <em>how do you instrument the code you want to measure without having to modify it?</em> The first goal is to avoid being too intrusive in the code and, also, to avoid affecting
               the entire application just for the duration of a benchmark. The second goal is to
               be able to <em>toggle</em> the instrumentation and to be able to deactivate it in order to measure the application
               without monitoring (particularly, if you put it everywhere) and ignore the associated
               overhead on the metrics you take.
            </p>
            
            <p>Nowadays, in Java and Java EE state, you have several options to instrument the code.
               We will browse through most of them, but here is an overview of the choices you have:
            </p>
            
            <ul>
               
               <li><strong>Choice 1 – manual</strong>: In this solution, you wrap the instance you use with a <em>Factory</em> of the monitoring framework you rely on, and the returned instance is wrapped in
                  a monitored proxy (new instance delegating to the original one). Concretely, it can
                  look like the following:
               </li>
               
            </ul>
            <pre style="padding-left: 90px">@ApplicationScoped<br/>public class QuoteResource {<br/>    @Inject<br/>    private QuoteService service;<br/><br/>    @PostConstruct<br/>    private void monitorOn() {<br/>        service = MonitoringFactory.monitor(service);<br/>    }<br/>}</pre>
            <p style="padding-left: 60px">From what we talked about earlier, this has a drawback of impacting the code and limiting
               the instrumentation to the code you own (or can modify). However, the big advantage
               is that it is simple to integrate and works with any kind of code (managed by the
               EE container or not). Concretely, most of the monitoring libraries will have such
               a utility and often just use it internally in other kinds of integrations.
            </p>
            
            <ul>
               
               <li><strong>Choice 2 – through CDI (or the interceptor API)</strong>: The Java EE standard way to <em>inject</em> logic into a service is to use an interceptor. We will detail how it works in a dedicated
                  part but the overall idea is to flag a method as being monitored. Here again, the
                  limitation will be to have access to the code you want to monitor through the CDI
                  container. However, it is less impacting than the previous solution in terms of coding.
               </li>
               
            </ul>
            
            <div class="packt_tip">If your application relies on Spring, the Spring framework has the same kind of tooling
               (referenced as <em>AOP</em> in their documentation). So, the same concept applies even if it is activated a bit
               differently.
            </div>
            
            <ul>
               
               <li><strong>Choice 3 – through a javaagent</strong>: The javaagent is the most powerful way to instrument the code. The drawback is that
                  you need to configure it directly on the JVM, while the good point is that you can
                  monitor almost every class (except for a few of the JVM itself).
               </li>
               
            </ul>
            
            <div class="packt_tip">Some containers (such as Tomcat/TomEE for instance) allow you to configure <kbd>java.lang.instrument.ClassFileTransformer</kbd>. <span>This will basically enable you to perform bytecode instrumentation at load time (dynamically).
                  This allows you to benefit from almost the same power as that of a javaagent, except
                  that you will not be able to instrument the container—and potentially, a part of the
                  JVM—but only the classes of the application. However, it is still more powerful than
                  CDI instrumentation as it sees all the classes of the application, not only the ones
                  that the CDI processes.</span></div>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">CDI instrumentation</h1>
            
         </header>
         
         
         <article>
            
            
            <p>If we focus back on the Metrics library, we will find several CDI integrations. The
               global idea is to decorate the code with some annotation and automatically get the
               metrics associated with the executed code. Clearly, it will impact your code this
               way (using <a href="https://github.com/astefanutti/metrics-cdi">https://github.com/astefanutti/metrics-cdi</a> for instance):
            </p>
            <pre><span>@Transactional<br/></span><span>@ApplicationScoped<br/></span><span>public class </span>QuoteService {<br/>    <span>@PersistenceContext<br/></span><span>    </span><span>private </span>EntityManager <span>entityManager</span>;<br/><br/>    @Timed(name = "create")<br/>    <span>public </span>Quote create(<span>final </span>Quote newQuote) {<br/>        <span>entityManager</span>.persist(newQuote);<br/>        <span>entityManager</span>.flush();<br/>        <span>return </span>newQuote;<br/>    }<br/>}</pre>
            <p>The <kbd>@Timed</kbd> annotation will automatically wrap the method execution in a Metrics timer and will
               therefore provide the statistics about the execution time of the method. The relevant
               code of the interceptor associated with the <kbd>@Timed</kbd> annotation is very close to this logic:
            </p>
            <pre>private Object onInvocation(InvocationContext context) throws Exception {
    Timer.Context time = findTimer(context).time();
    try {
        return context.proceed();
    } finally {
        time.stop();
    }
}</pre>
            <p>This is exactly what we want to achieve but it has one trap we didn't think about
               yet: the exception handling. To understand this point, we can compare the code used
               in the retired project (called Apache Sirona), which had the following differently
               implemented feature:
            </p>
            <pre><span>protected </span>Object doInvoke(<span>final InvocationContext</span><span> </span>context) <span>throws </span>Throwable {<br/>    <span>final </span>Context ctx = before(context);<br/>    Throwable error = <span>null</span>;<br/>    <span>try </span>{<br/>        <span>return </span>proceed(context);<br/>    } <span>catch </span>(<span>final </span>Throwable t) {<br/>        error = t;<br/>        <span>throw </span>t;<br/>    } <span>finally </span>{<br/>        <span>if </span>(error == <span>null</span>) {<br/>            ctx.stop();<br/>        } <span>else </span>{<br/>            ctx.stopWithException(error);<br/>        }<br/>    }<br/>}</pre>
            <p>What is important to see here is that the code path changes in the case of an exception.
               In terms of statistics, this implies that failures will have a different marker from
               successful calls in the metrics report. This is important to notice because the execution
               time of a failure is rarely comparable to a success, even for simple methods. Let's
               take a simple finder example from our quote manager application and observe this.
               Here is the line we will investigate:
            </p>
            <pre><span>entityManager</span>.find(Quote.<span>class</span>, id)</pre>
            <p>A normal call with a valid ID will be around 6 to 7 ms (on my reference machine, with
               my personal configuration). The <kbd>EntityManager#find</kbd> method can take any type for the identifier, so if we pass a wrong type (such as <kbd>String</kbd> instead of <kbd>long</kbd> ) then the call should compile and execute. Eclipselink will complain with an exception
               but the performance impact is something interesting: 0 ms! Indeed, this example is
               very extreme and is a bug, but if you have some rate limiting on an endpoint or some
               sanity checks at the beginning of the methods, the same impact can be observed.
            </p>
            
            <p>This means that if the framework you are using is putting all the invocations (with
               errors or not) in the same bucket, you can have a very good performance but a very
               slow application, since the average of the success/failure makes the figures look
               good.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Implementing your own configurable monitoring interceptor</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Implementing a CDI interceptor is not that complicated. Thus, you may want to have
               your own if you do not find a library matching your expectations. It can have two
               kinds of direct impact on the way you use monitoring:
            </p>
            
            <ul>
               
               <li>Be able to control the counters you use depending on the case you are in. This includes
                  success/failure handling, but it can also be tenant-related (if your application is
                  handling multiple tenants). This can be very important if you do not use the exact
                  same system as the tenant (one can have a slower database than the other, for instance).
               </li>
               
               <li>Be able to configure the monitored beans. Yes, with CDI you can also avoid having
                  to decorate the beans you want to monitor and just do it automatically from a configuration.
               </li>
               
            </ul>
            
            <p>The first step to create a CDI interceptor is to have what CDI calls <em>interceptor binding</em>. It is the annotation you will use on your beans that will mark the method as being
               monitored. Here is a simple one:
            </p>
            <pre><span>@InterceptorBinding<br/></span><span>@Target</span>({ElementType.<span>TYPE</span>, ElementType.<span>METHOD</span>})<br/><span>@Retention</span>(RetentionPolicy.<span>RUNTIME</span>)<br/><span>public </span>@<span>interface </span><span>Monitored </span>{<br/>}</pre>
            <p>It is a normal annotation that you can put in a method (or a class to mark all the
               methods as being monitored). The only particular thing is its <kbd>@InterceptorBinding</kbd> marker.
            </p>
            
            <p>Then, to link this interceptor bind to the actual interceptor implementation, you
               create an interceptor with the same annotation:
            </p>
            <pre><span>@Interceptor<br/></span><span>@Monitored<br/>@Priority(Interceptor.Priority.PLATFORM_BEFORE)<br/></span><span>public class </span>MonitoredInterceptor implements Serializable {<br/>    <span>@AroundInvoke<br/></span><span>    @AroundTimeout<br/></span><span>    </span><span>public </span>Object monitor(<span>final </span>InvocationContext invocationContext) <span>throws </span>Exception {<br/>        <span>final </span>Context ctx = newContext(invocationContext);<br/>        Exception error = <span>null</span>;<br/>        <span>try </span>{<br/>            <span>return </span>invocationContext.proceed();<br/>        } <span>catch </span>(<span>final </span>Exception t) {<br/>            error = t;<br/>            <span>throw </span>t;<br/>        } <span>finally </span>{<br/>            <span>if </span>(error == <span>null</span>) {<br/>                ctx.stop();<br/>            } <span>else </span>{<br/>                ctx.stopWithException(error);<br/>            }<br/>        }<br/>    }<br/>}</pre>
            <p>The method being decorated with <kbd>@AroundInvoke</kbd> will handle the method invocation, and being decorated with <kbd>@AroundTimeout</kbd>, it will also support EJB timer callbacks (<kbd>@Timeout</kbd>).
            </p>
            
            <p>Note that if you also want to monitor the constructors, you can do so, but you will
               need to implement an <kbd>@AroundConstruct</kbd> method (with the same sort of implementation as our <kbd>monitor</kbd> method). The fact that our interceptor is decorated with <kbd>@Priority</kbd> automatically enables it, and you do not need to activate it in <kbd>beans.xml</kbd>.
            </p>
            
            <p>With this code, you can decorate any method with <kbd>@Monitored</kbd> and, assuming that your <kbd>Context</kbd> stores the metrics, you will get your figures in the reporting solution you used.
            </p>
            
            <p>However, one goal of writing a custom implementation was also to be able to configure
               it. With CDI, it can be done with <kbd>Extension</kbd>. The global idea will be to observe the application types/methods, and if one is
               configured to be monitored, we will add <kbd>@Monitored</kbd> automatically. This way, we'll have no code impact in the application and we can
               easily activate/deactivate monitoring by simply changing our configuration. For the
               configuration, we can just start with a <kbd>performance.properties</kbd> resource as follows <span>(note that it will be easy to change to a particular file outside the application)</span>:
            </p>
            <pre><span>public class </span>PerformanceExtension <span>implements </span>Extension {<br/>    <span>private final </span><span>Annotation </span><span>monitored </span>= <span>new<br/>    AnnotationLiteral&lt;Monitored&gt;</span>() {};<br/>    private final Properties configuration = new Properties();<br/>    private boolean enabled;<br/><br/>    <span>void </span>loadConfiguration(<span>final </span><span>@Observes </span>BeforeBeanDiscovery<br/>    beforeBeanDiscovery) {<br/>        try (final InputStream configStream =<br/>        Thread.currentThread().getContextClassLoader()<br/>                                                 <br/>        .getResourceAsStream("performances.properties")) {<br/>            if (configStream != null) {<br/>                configuration.load(configStream);<br/>            }<br/>        }   catch (final IOException ioe) {<br/>            throw new IllegalArgumentException(ioe);<br/>        }<br/>        enabled =<br/>        Boolean.parseBoolean(configuration.getProperty("enabled",<br/>        "true"));<br/>    }<br/><br/>    &lt;<span>A</span>&gt; <span>void </span>processAnnotatedType(<span>final </span><span>@Observes <br/></span>    ProcessAnnotatedType&lt;<span>A</span>&gt; pat) {<br/>        <span>if </span>(!<span>enabled</span>) {<br/>            <span>return</span>;<br/>        }<br/><br/>        <span>final </span>String beanClassName =<br/>        pat.getAnnotatedType().getJavaClass().getName();<br/>        if(Boolean.parseBoolean(configuration.getProperty(beanClassName<br/>        + ".monitor", "false"))) {<br/>            pat.setAnnotatedType(new WrappedAnnotatedType&lt;&gt;<br/>            (pat.getAnnotatedType(), monitored));<br/>        }<br/>    }<br/>}</pre>
            <p>This code uses the <kbd>BeforeBeanDiscovery</kbd> event (beginning of the CDI lifecycle) to load our configuration. Here, you can read
               from whatever place you want. A small optimization is to have a special key to check
               whether the extension is activated or not. If it is set to something other than true,
               then we will just skip all other events. In case it is enabled, we'll observe all
               the discovered types through the <kbd>ProcessAnnotatedType</kbd> event. If the bean should be monitored (our test is very simple here, we just check
               whether the class name suffixed with<em> monitor</em> is true in our configuration), then we override <kbd>AnnotatedType</kbd>, keeping all its information but adding <kbd>@Monitored</kbd> into the set of the class's annotations.
            </p>
            
            <div class="packt_tip">You can do exactly the same at the method level, wrapping <kbd>AnnotatedMethod</kbd> returned by <kbd>AnnotatedType#getMethods</kbd>. The logic is the same; you just need to have one more configuration level (for methods).
            </div>
            
            <p>The <kbd>WrappedAnnotatedType</kbd> implementation is a simple delegation implementation, except for the annotation accessors,
               where a new set is used instead of the original one:
            </p>
            <pre><span>public class </span>WrappedAnnotatedType&lt;<span>A</span>&gt; <span>implements </span>AnnotatedType&lt;<span>A</span>&gt; {<br/>    <span>private final </span>AnnotatedType&lt;<span>A</span>&gt; <span>delegate</span>;<br/>    <span>private final </span>Set&lt;Annotation&gt; <span>annotations</span>;<br/><br/>    <span>public </span>WrappedAnnotatedType(<span>final </span>AnnotatedType&lt;<span>A</span>&gt; at, <span>final<br/>    </span>Annotation additionalAnnotation) {<br/>        <span>this</span>.<span>delegate </span>= at;<br/><br/>        <span>this</span>.<span>annotations </span>= <span>new </span>HashSet&lt;Annotation<br/>        &gt;(at.getAnnotations().size() + 1);<br/>        this.annotations.addAll(at.getAnnotations());<br/>        <span>this</span>.<span>annotations</span>.add(additionalAnnotation);<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public </span>Set&lt;Annotation&gt; getAnnotations() {<br/>        <span>return </span><span>annotations</span>;<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public </span>&lt;<span>T </span><span>extends </span>Annotation&gt; <span>T </span>getAnnotation(<span>final </span>Class&lt;<span>T</span>&gt;<br/>    annotationType) {<br/>        <span>for </span>(<span>final </span>Annotation ann : <span>annotations</span>) {<br/>            <span>if </span>(ann.annotationType() == annotationType) {<br/>                <span>return </span>annotationType.cast(ann);<br/>            }<br/>        }<br/>        <span>return null</span>;<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public boolean </span>isAnnotationPresent(<span>final </span>Class&lt;? <span>extends<br/>    </span>Annotation&gt; annotationType) {<br/>        <span>return </span>getAnnotation(annotationType) != <span>null</span>;<br/>    }<br/><br/>    // other methods fully delegate the invocations to the delegate<br/>    instance<br/>}</pre>
            <p>As you can see, the only logic is in <kbd>getAnnotation</kbd> and in the constructor where a new set of annotations is created to replace the original
               one.
            </p>
            
            <p>Finally, to enable<span> </span><kbd>Extension</kbd> <span>and </span>let the CDI find it, we just put its qualified name in <kbd>META-INF/services/javax.enterprise.inject.spi.Extension</kbd> in our project resources.
            </p>
            
            <p>Once this extension is added to your application (you can develop it as a library
               and just add the <kbd>jar</kbd> file inside your <kbd>war</kbd> package if you want), you can configure it through <kbd>performances.properties</kbd>.
            </p>
            
            <p>In our case, monitoring our quote service looks like this:</p>
            <pre># activate the monitoring<br/>enabled = true<br/><br/># monitor the QuoteService class<br/>com.github.rmannibucau.quote.manager.service.QuoteService.monitor = true</pre>
            <p>What's more, you can add a line by the class you want to monitor. Don't forget to
               restart between updates in this file, since the configuration and the CDI model's
               wrapping is done only at startup.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Javaagent – a complex but powerful instrumentation</h1>
            
         </header>
         
         
         <article>
            
            
            <p>If you go back again to metrics, you can find existing javaagents even if they are
               less numerous, since writing an agent is a bit more complicated.
            </p>
            
            <p>A javaagent is a particular kind of the main method provided by the JVM that enables
               you to <span>register </span><kbd>ClassFileTransformer</kbd>, <span>which </span>is a way to modify the classes' bytecode before they get loaded. In other words, you
               will write some code and compile it, but the JVM will never execute it. Instead, it
               will execute a rewritten version of the code.
            </p>
            
            <p>We will not detail how to do it here. In fact, it is more complicated than writing
               an interceptor (you need to take care of the classloaders, write low-level bytecode
               with the ASM library or an equivalent, and so on). However, it is important to see
               that the scope of a javaagent is the JVM—not an application, not a container, but
               the full JVM. For technical reasons, as you may guess, you can not instrument all
               the JVM classes, but all the classes that are loaded after the javaagent are started
               (which is already far enough).
            </p>
            
            <p><span>Instrumenting</span><span> </span><kbd>java.net.HttpURLConnection</kbd> is a good example of instrumentation using a javaagent<span>.</span></p>
            
            <p>This class is often used to implement a Java HTTP client, but it is often hidden by
               libraries (such as a JAX-RS client implementation). Therefore, it is not easy to have
               the current request and framework time if you cannot measure this specific class.
            </p>
            
            <p>That is how a javaagent will be way more powerful than a CDI or a Spring instrumentation.</p>
            
            <p>To give you an idea of what you can do with a javaagent, we will configure the Sirona
               project in our quote manager application.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Sirona javaagent</h1>
            
         </header>
         
         
         <article>
            
            
            <p>To keep it simple and easy to understand, we will use maven, but you can follow the
               same steps on any application server, since javaagent is set up on the JVM and not
               on a particular server.
            </p>
            
            <p>The first step is to download the javaagent <kbd>jar</kbd> file. To do so with maven, you can just add the dependency maven plugin in your <kbd>pom.xml</kbd>:
            </p>
            <pre><span>&lt;</span><span>plugin</span><span>&gt;</span><br/>  <span>&lt;</span><span>groupId</span><span>&gt;</span>org.apache.maven.plugins<span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>  <span>&lt;</span><span>artifactId</span><span>&gt;</span>maven-dependency-plugin<span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>  <span>&lt;</span><span>version</span><span>&gt;</span>3.0.2<span>&lt;/</span><span>version</span><span>&gt;</span><br/>  <span>&lt;</span><span>executions</span><span>&gt;</span><br/>    <span>&lt;</span><span>execution</span><span>&gt;</span><br/>      <span>&lt;</span><span>id</span><span>&gt;</span>sirona<span>&lt;/</span><span>id</span><span>&gt;</span><br/>      <span>&lt;</span><span>goals</span><span>&gt;</span><br/>        <span>&lt;</span><span>goal</span><span>&gt;</span>copy<span>&lt;/</span><span>goal</span><span>&gt;</span><br/>      <span>&lt;/</span><span>goals</span><span>&gt;</span><br/>      <span>&lt;</span><span>configuration</span><span>&gt;</span><br/>        <span>&lt;</span><span>artifactItems</span><span>&gt;</span><br/>          <span>&lt;</span><span>artifactItem</span><span>&gt;</span><br/>            <span>&lt;</span><span>groupId</span><span>&gt;</span>com.github.rmannibucau.sirona<span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>            <span>&lt;</span><span>artifactId</span><span>&gt;</span>sirona-javaagent<span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>            <span>&lt;</span><span>version</span><span>&gt;</span>0.6<span>&lt;/</span><span>version</span><span>&gt;</span><br/>            <span>&lt;</span><span>type</span><span>&gt;</span>jar<span>&lt;/</span><span>type</span><span>&gt;</span><br/>            <span>&lt;</span><span>classifier</span><span>&gt;</span>shaded<span>&lt;/</span><span>classifier</span><span>&gt;</span><br/>            <span>&lt;</span><span>overWrite</span><span>&gt;</span>true<span>&lt;/</span><span>overWrite</span><span>&gt;</span><br/>            <span>&lt;</span><span>outputDirectory</span><span>&gt;</span>${project.basedir}<span>&lt;/</span><span>outputDirectory</span><span>&gt;</span><br/>            <span>&lt;</span><span>destFileName</span><span>&gt;</span>sirona-javaagent.jar<span>&lt;/</span><span>destFileName</span><span>&gt;</span><br/>          <span>&lt;/</span><span>artifactItem</span><span>&gt;</span><br/>        <span>&lt;/</span><span>artifactItems</span><span>&gt;</span><br/>      <span>&lt;/</span><span>configuration</span><span>&gt;</span><br/>    <span>&lt;/</span><span>execution</span><span>&gt;</span><br/>  <span>&lt;/</span><span>executions</span><span>&gt;</span><br/><span>&lt;/</span><span>plugin</span><span>&gt;</span></pre>
            <p>It is configured to download sirona-javaagent shaded JAR (all in one bundle). Now,
               if you execute this maven command, you should obtain the javaagent JAR in your maven
               project:
            </p>
            <pre><strong>$ mvn dependency:copy@sirona</strong></pre>
            <p>Once this command is executed, you should find a <kbd>sirona-javaagent.jar</kbd> file next to your pom.
            </p>
            
            <p>Now that we have the javaagent, we need to configure it. To make it simple, sirona
               supports a <kbd>sirona.properties</kbd> configuration file in the current directory, so we will use it. Here's what it will
               contain to activate monitoring in our application:
            </p>
            <pre><span>com.github.rmannibucau.sirona.javaagent.listener.CounterListener.includes</span>=<span>prefix:com.github.rmannibucau.quote.manager<br/></span><span>com.github.rmannibucau.sirona.javaagent.listener.CounterListener.excludes</span>=<span>container:jvm<br/></span><span><br/></span><span>com.github.rmannibucau.sirona.store.counter.CounterDataStore</span>=<span>com.github.rmannibucau.sirona.store.counter.CsvLoggingCounterDataStore<br/></span><span><br/></span><span>com.github.rmannibucau.sirona.csvlogging.counter.period</span>=<span>5000<br/></span><span>com.github.rmannibucau.sirona.csvlogging.counter.clearAfterCollect</span>=<span>true<br/></span><span><br/></span><span>com.github.rmannibucau.sirona.javaagent.path.tracking.activate</span>=<span>false<br/></span></pre>
            <p>The <kbd>CounterListener</kbd>-related configuration is about the scope of the monitoring: what is instrumented
               and what is not. Here, we just instrument our application package and make Sirona
               ignoring the JVM classes (<em>container</em> is an alias for a set of built-in exclusions). Then, we configure <kbd>CounterDataStore</kbd> where the metrics are stored. In this example, we use a logging flavor (the metrics
               will then be outputted in a logger) and a CSV formatting. This is the simplest way,
               but you can also configure it to output the data in Elasticsearch, Graphite or any
               external system. Then, we configure our storage to log every 5 seconds (5000 ms)—this
               is mainly for demonstration, but in real life, you will probably want to wait for
               a minute or so. Next, we request the storage to be cleared after collection. This
               last point means that every time the data is logged, the data is reset. It avoids
               keeping the startup data from having side-effects on the runtime data. Finally, the
               last line deactivates the path tracking feature of Sirona, which is built in with
               the javaagent, but we do not need it here.
            </p>
            
            <p>Now that everything is configured, we just need to ensure that our application is
               ready to run (you can re-execute <kbd>mvn clean package</kbd> if you have a doubt) and then launch it with the javaagent on the JVM (maven if you
               launch GlassFish with maven or directly GlassFish if you use a standalone instance):
            </p>
            <pre>MAVEN_OPTS="-javaagent:sirona-javaagent.jar" mvn embedded-glassfish:run</pre>
            <p class="mce-root">As you can see, adding a javaagent is as simple as adding the <kbd>-javaagent</kbd> option on the JVM, followed by the path of the JAR.
            </p>
            
            <div class="packt_tip">If the agent is natively developed and not done in Java, the command would be quite
               similar (but using <kbd>-agentlib</kbd>). This is how you can distinguish between Java and native agents, but the principle
               remains the same.
            </div>
            
            <p>Once you have started the server, if you wait for a few seconds (~5 seconds as for
               our configuration), you will start getting some output related to the metrics Sirona
               took:
            </p>
            <pre>sept. 23, 2017 12:16:32 PM com.github.rmannibucau.sirona.store.counter.LoggingCounterDataStore pushCountersByBatch<br/>INFOS: "com.github.rmannibucau.quote.manager.service.ProvisioningService$Data.getQuoteSummary()";"performances";70;1;3045.0;157.0;842.514285714286;58976.0;622.1554571298391<br/>sept. 23, 2017 12:16:32 PM com.github.rmannibucau.sirona.store.counter.LoggingCounterDataStore pushCountersByBatch<br/>INFOS: "com.github.rmannibucau.quote.manager.service.QuoteService$Proxy$_$$_WeldSubclass.weld$$$46()";"performances";1;1;6054.0;6054.0;6054.0;6054.0;0.</pre>
            <p>The output format depends on the logger configuration. Out of the box, it is not that
               fancy, but if you configure your logger, you will get a plain CSV output. By default
               in Sirona, the logger name will be <kbd>com.github.rmannibucau.sirona.counters</kbd>. If you want to configure this particular logger in a specific file without a specific
               formatter pattern, you will have to use the logger name and not the class name.
            </p>
            
            <p class="mce-root">To keep it simple for us, we will just change the <kbd>SimpleFormatter</kbd> format in the JVM (it will affect all loggers using this formatter):
            </p>
            <pre>MAVEN_OPTS="-Djava.util.logging.SimpleFormatter.format=%5\$s%6\$s%n -javaagent:sirona-javaagent.jar"</pre>
            <p>Note that depending on your operating system, you may (or may not) need to escape
               the dollars, as in the previous example (it was for Linux).
            </p>
            
            <p>Once the server starts with this new configuration, the output is more readable:</p>
            <pre>"com.github.rmannibucau.quote.manager.service.QuoteService$Proxy$_$$_WeldSubclass.weld$$$94()";"performances";1;1;4347.0;4347.0;4347.0;4347.0;0.0<br/>"com.github.rmannibucau.quote.manager.service.QuoteService$Proxy$_$$_WeldSubclass.weld$$$98()";"performances";1;1;3842.0;3842.0;3842.0;3842.0;0.0<br/>"com.github.rmannibucau.quote.manager.service.QuoteService$Proxy$_$$_WeldSubclass.weld$$$102()";"performances";1;1;4186.0;4186.0;4186.0;4186.0;0.0<br/>"com.github.rmannibucau.quote.manager.model.Quote._persistence_new(org.eclipse.persistence.internal.descriptors.PersistenceObject)";"performances";11;1;15760.0;4272.0;8134.545454545455;89480.0;3191.1807959949983<br/>"com.github.rmannibucau.quote.manager.service.QuoteService.mutate(java.lang.String,java.util.function.Function)";"performances";10;1;1.3095653E7;5517805.0;9319597.6;9.3195976E7;2502831.398655584<br/>"com.github.rmannibucau.quote.manager.service.ProvisioningService$Data.getQuoteSummary()";"performances";70;1;7909.0;519.0;1455.4142857142854;101879.0;1239.6496056226922</pre>
            <p>What is interesting here is that you can directly import this in a CSV editor, including
               Microsoft Excel or LibreOffice Calc, and work on the data (sort it, compare it, and
               so on).
            </p>
            
            <p>To efficiently work on the data, you need to know what the columns are. For this particular
               datastore, here is the header list:
            </p>
            
            <ul>
               
               <li>Timer/counter name</li>
               
               <li>Timer/counter role (<em>performance</em> means the execution time is measured, <em>failure</em> means an exception has occurred)
               </li>
               
               <li>Hits (indicates how often the method has been called in the measuring window)</li>
               
               <li>Max concurrency (indicates what the maximum of a concurrent call for a method in the
                  measuring window is)
               </li>
               
               <li>Max (gives the maximum execution time)</li>
               
               <li>Min (gives the minimum execution time)</li>
               
               <li>Mean (gives the the average execution time)</li>
               
               <li>Sum (gives the sum of all the execution times)</li>
               
               <li>Standard deviation of all the execution times of the window</li>
               
            </ul>
            
            <p>In your investigations into finding the bottleneck of a method to dig into (in order
               to optimize the performance), you will have to take multiple datasets into account.
               The first data will be the <em>sum</em>. If you sort by <em>sum</em> (decreasing order), the first method will be the one consuming a lot of time for
               your application. However, you need to validate it against the number of hits. For
               instance, if you have a single hit, then you know that caching this method's data
               will not be helpful. The standard deviation (or comparing the min/max range) will
               also give you an idea of the method’s behavior. If the range is high, then you need
               to investigate what this method does, and why it is fast sometimes and slow some other
               times.
            </p>
            
            <p>Once you've found a good method to investigate, you can reuse the tools we talked
               about earlier to dig into the method. Having this level of information to start working
               is generally easier to deal with and more centered on the application overview than
               the detailed view, which can be hard (or long) to organize. It is always easier to
               drill down the performance data than starting from the detailed view.
            </p>
            
            <p>Now, to show you how powerful a javaagent can be, we will temporarily change our sirona
               configuration a bit. We will exclude the Oracle package (just to override the default
               exclusion, which is the whole JVM), and we will include <kbd>HttpURLConnection</kbd>.
            </p>
            
            <p>The goal for our application can be to compare the time we spend in the provisioning
               versus the current network cost, which we can not optimize as it is linked to our
               environment, which we assume to be constant during the benchmark phase.
            </p>
            
            <p>Here is what the configuration looks like now:</p>
            <pre><span>com.github.rmannibucau.sirona.javaagent.listener.CounterListener.includes</span>=<span>prefix:com.github.rmannibucau.quote.manager,</span><span>\<br/></span><span>    prefix:sun.net.www.protocol.http.HttpURLConnection<br/></span><span>com.github.rmannibucau.sirona.javaagent.listener.CounterListener.excludes</span>=<span>prefix:oracle<br/></span><span><br/></span><span>com.github.rmannibucau.sirona.store.counter.CounterDataStore</span>=<span>com.github.rmannibucau.sirona.store.counter.CsvLoggingCounterDataStore<br/></span><span><br/></span><span>com.github.rmannibucau.sirona.csvlogging.counter.period</span>=<span>5000<br/></span><span>com.github.rmannibucau.sirona.csvlogging.counter.clearAfterCollect</span>=<span>true<br/></span><span><br/></span><span>com.github.rmannibucau.sirona.javaagent.path.tracking.activate</span>=<span>false<br/></span></pre>
            <p>Only the two first lines change, and you can see that the JVM is no more excluded
               to be able to instrument the sum package and that <kbd>HttpUrlConnection</kbd> is now included in the white list of instrumented classes.
            </p>
            
            <p>We relaunch our server, and after the provisioning, we get these new outputs:</p>
            <pre><strong>"sun.net.www.protocol.http.HttpURLConnection.plainConnect()";"performances";1;1;1.288844214E9;1.288844214E9;1.288844214E9;1.288844214E9;0.0</strong><br/><strong>"sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(java.net.URL,java.net.Proxy,int)";"performances";1;1;1.288132398E9;1.288132398E9;1.288132398E9;1.288132398E9;0.0</strong><br/><strong>....</strong></pre>
            <p>The configuration change includes the JVM HTTP client monitoring, and we can now have
               a part of the time spent in the actual network as well as the time spent in the client
               code itself, with retries and all the logic it embeds. This is the kind of information
               you cannot get without a javaagent.
            </p>
            
            <p><em>Modern</em> architectures tend to encourage microservices. This means that you will mainly split
               your overall system into subsystems with a clear responsibility separation. It implies
               a lot of issues, such as the requirement to handle transactions across different systems
               (what XA was doing in its time), the addition of multiple remote communications, which
               slows down the overall process, and so on, but it comes with the advantage of allowing
               you to develop systems more rapidly and to go into production more easily in general.
               There is always a trade-off.
            </p>
            
            <p>In any case, if you work on the performance, you may have to deal with such a system
               now and, therefore, need to know which tools can help you.
            </p>
            
            <p>There are mainly two kinds of solutions that will help a lot:</p>
            
            <ul>
               
               <li><strong>Data aggregation</strong>: All the data of all the applications will be aggregated in a single system. For
                  instance, the previously captured execution times of N instances will be stored in
                  a single <em>database</em> (such as InfluxDB or Elasticsearch).
               </li>
               
               <li><strong>Tracing</strong>: The entire system will propagate a single <em>transaction ID</em> (also called <em>request ID</em>), which will enable you to identify the request (user action) across all the systems
                  and the stage you are at (third system of the pipeline, for instance).
               </li>
               
            </ul>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">SQL Monitoring</h1>
            
         </header>
         
         
         <article>
            
            
            <p>In a lot of applications, most of the time will be taken by the SQL queries' execution.
               Therefore, it is important to monitor them. You can use one of the previous techniques
               but there are also some specific ways to monitor them.
            </p>
            
            <p>Generally, the idea is to replace the native driver you use (the Oracle, MySQL ones,
               for instance) with a monitoring driver, which will wrap the default driver and delegate
               all the logic to the original one, adding some metrics on top of it.
            </p>
            
            <p>For instance, using sirona JDBC <span>driver </span>(<a href="http://repo.maven.apache.org/maven2/com/github/rmannibucau/sirona/sirona-jdbc/0.6/">http://repo.maven.apache.org/maven2/com/github/rmannibucau/sirona/sirona-jdbc/0.6/</a>) for our datasource, we will define the application DataSource this way:
            </p>
            <pre>@DataSourceDefinition(<br/>        name = "java:app/jdbc/quote_manager",<br/>        className = "com.github.rmannibucau.sirona.jdbc.SironaDriver",<br/>        url = "jdbc:sirona:mysql://localhost:3306/quote_manager?delegateDriver=com.mysql.jdbc.Driver",<br/>        user = "root",<br/>        password = "password"<br/>)<br/>public class DataSourceConfiguration {<br/>}</pre>
            <p>The driver's class name is now the monitoring one, and the URL changed a bit to configure
               the monitoring driver. Here, with Sirona, you append <kbd>sirona</kbd> before the native driver URL and after the <kbd>jdbc:</kbd> prefix, and you add the <kbd>delegateDriver</kbd> <span>query parameter </span>to the URL with the classname of the native driver as the value.
            </p>
            
            <p>Once done, Sirona will automatically create counters for each statement and add it
               to its report.
            </p>
            
            <div class="packt_tip">This kind of solution works very well with prepared statements, as you will reuse
               the same <em>key</em> (the SQL value). This is generally what any JPA provider does.
            </div>
            
            <p>This visualization, between Java and the database, can help determine the slow queries.
               There are a lot of implementations of such a type. Just pick the one you prefer, between
               Sirona, Jamon, JavaSimon, Log4jJDBC, P6Spy, and others.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Data aggregation</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Microservices—or more generally services with small scopes<span>—</span>are fast-moving applications in general, and it is easy to add/remove them in a global
               system. In this condition, the performance will need to be comparable and validatable
               against any change of the sibling services (which can impact the central service by
               overusing or misusing it).
            </p>
            
            <p>Being able to have a centralized vision of all the systems is a key to understanding
               how optimizing another application can make your application go faster. The corollary
               of this statement is that when you depend on another application, which is too slow
               for your SLA, you need to be aware of it as soon as possible. Once identified, you
               can add caching or alternative ways to make your application less dependent on others
               and behave faster.
            </p>
            
            <p>It is not always possible—for instance, in our quote manager application, we can't
               get data about Yahoo<span>—</span>but in a microservice structure, you will often get a company policy or at least contacts
               to be able to discuss it and implement it.
            </p>
            
            <p>In practice, it is mainly about agreeing on a way of identifying the application (which
               is just about defining a convention in the overall system, shared by all the subsystems)
               and the data format put inside the aggregator. For instance, you can say that you
               will use the <kbd>Company-ID</kbd> <span>HTTP </span><span>header </span><span>as a request identifier and the log format will be </span><kbd>${Company-Id} | ${Tenant-Id} | ${Machine-Id} | ${Execution-Time} | ${action/method}
                  | ${message}</kbd><span>.</span></p>
            
            <p>This is just a simple example, but the idea is to be able to browse the log across
               applications pretty quickly.
            </p>
            
            <p>Once you know what you will log, you need to select a system to store your data. Here,
               you have a lot of choices but do not forget to check whether you can exploit the data
               once it is stored. It means that you need to ensure you have a good user interface
               <span>that will fulfill your expectations </span>on top of the storage.
            </p>
            
            <p>The most known are these:</p>
            
            <ul>
               
               <li style="font-weight: 400">Elastic stack: It is based on Elasticsearch to store the data and Kibana to visualize
                  it. It is available for free.
               </li>
               
               <li style="font-weight: 400">Splunk: It is a custom stack dedicated to the aggregation of data.</li>
               
               <li style="font-weight: 400">Grafana: It is mainly a UI tool, but it is pluggable on most of the monitoring databases,
                  including Elasticsearch, Graphite or InfluxDB.
               </li>
               
            </ul>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Tracing</h1>
            
         </header>
         
         
         <article>
            
            
            <p>There are multiple options for tracing (Zipkin, Dapper, and others) but a few of them
               seem to have become mainstream. One of them is the OpenTracing initiative (<a href="http://opentracing.io/">http://opentracing.io/</a>). All share more or less the same design based on spans.
            </p>
            
            <p>The global idea is to let each transaction’s actors mark their presence with a span.
               A span contains an identifier, some metadata about the invocation, and the execution
               time. The identifier is generally composed of multiple values representing the overall
               trace identifier (the request marker), the span identifier, and, often, the parent
               identifier.
            </p>
            
            <p>When correctly installed, the tracing happens on the client and server sides, so you
               have a full vision of the system handling, and it is associated with the processing
               time of each part of the system. It is really about ensuring that every part of your
               system is properly instrumented—each time you exit or enter a system, you must be
               set up to handle the associated tracing. This includes HTTP clients/servers, and also
               the JDBC or NoSQL drivers.
            </p>
            
            <p>As for the monitoring libraries, this relies on storage, but there are also local
               implementations (a bit like our CSV logger when we talked about the Sirona javaagent)
               you can use to test your configuration or use as fallbacks if you can’t have a real
               monitoring database. However, using local outputs with such systems will make your
               work harder and longer, since it is really about aggregating multiple data to have
               a consolidated vision. What you need to understand is that you shouldn't hesitate
               to invest in setting a server dedicated to the data collection. It will not only help
               you for performance, but also for tracing your system. So, it is a worthy investment!
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">APM</h1>
            
         </header>
         
         
         <article>
            
            
            <p>You can find tools called <span><strong>Application Performance Management</strong> </span>(<strong>APM</strong>) on the market. These are really the Rolls Royce of monitoring tools and allow you
               to trace completely all the steps of the application, to go back in time to understand
               what happened, and to deduce the cause of a support issue very quickly. The paid offers
               generally include the infrastructure as well, which is not a negligible point, since
               it leads to a lot of data manipulation.
            </p>
            
            <p>Technically, they reuse several of the previous techniques but are really an all-in-one
               solution, which makes them very valuable. However, they are generally expensive and
               rarely open source.
            </p>
            
            <p class="mce-root"/>
            
            <p>Nonetheless, you can find a few open source implementations, such as PinPoint(<a href="https://github.com/naver/pinpoint">https://github.com/naver/pinpoint</a>), InspectIT(<a href="https://github.com/inspectIT/inspectIT">https://github.com/inspectIT/inspectIT</a>), and Glowroot(<a href="https://glowroot.org/">https://glowroot.org/</a>). In terms of a leading proprietary, solution you can find New Relic (<a href="https://newrelic.com/java">https://newrelic.com/java</a>), DripStat (<a href="https://dripstat.com">https://dripstat.com</a>), or DynaTrace (<a href="https://www.dynatrace.com/">https://www.dynatrace.com/</a>).
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Summary</h1>
            
         </header>
         
         
         <article>
            
            
            <p>In this part, we saw a lot of ways to gather information about the JVM and your application.
               We also saw that the JVM itself provides a set of tools to give you information about
               the memory, CPU, and garbage collection. Most of them are available through the command
               line (which can be very handy when benchmarking a machine without any UI), but they
               also come with several user interfaces, enabling you to get the information easily
               once you can connect to the JVM. One of these tools is the JMC: it gives you a lot
               of information and even allows you to drill down into the method invocations to have
               a detailed view of your application.
            </p>
            
            <p>However, it is not enough and you may need to get access to the server information
               about the pool usage, and in this case, the server can give you some more information
               about configuration issues (such as a pool configured too small). Then, a set of libraries
               allows you to get the monitoring information in a more efficient and performance-oriented
               way, which enables you to investigate the application without a deep knowledge or
               any assumption about it. Note that these tools (such as Metrics or Sirona) also aggregate
               more data and often have plugins for the servers, which can prevent you from using
               the server-specific monitoring to get a more global vision.
            </p>
            
            <p>Finally, we saw that in multisystem applications, you will need to ensure you can
               monitor your applications and also the ones linked to them so that you can identify
               the impacts on your own applications and try to decrease them if too impacting.
            </p>
            
            <p>All of these tools, in some way, have some kind of overlap, but they all fulfill different
               needs and answer to a different trade-off between ease, information completeness,
               and investment. Depending on the knowledge you have about the application you are
               working on, and the investment you can afford for the code and infrastructure of the
               application of the benchmarking platform, you will pick a solution.
            </p>
            
            <p>In the next chapter, we will investigate the impact of resources on applications and
               their performance. We will go through the Java memory management and the server resource
               handling, such as <kbd>DataSource</kbd> and <kbd>ConnectionFactory</kbd>.
            </p>
            
            <p class="mce-root"/>
            
            
            
         </article>
         
         
         
      </section>
      
   </body></html>