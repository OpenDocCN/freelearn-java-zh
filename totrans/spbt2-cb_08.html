<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Spring Boot DevTools</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>Adding Spring Boot DevTools to a project</li>
<li>Configuring LiveReload</li>
<li>Configuring dynamic application restart triggers</li>
<li>Using Remote Update</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In a world of DevOps, agile software development practices, the introduction of microservices, and with more and more teams doing continuous development and deployment, it becomes even more important to be able to quickly see the code changes to an application without going through the whole process of re-compiling the entire project, rebuilding, and restarting the application.</p>
<p>The arrival of containerization services such as Docker has also presented a challenge in terms of access to the actual application running environment. It has changed the notion of a machine by abstracting and encapsulating the runtime environment, removing the ability to use any port to get access.</p>
<p>Spring Boot DevTools provides the ability to do selective class reloading and debugging applications running inside Docker containers using HTTP remote debug tunnel, in order to give developers a quick feedback loop to see their changes reflected in the running application without long rebuild and restart cycles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Spring Boot DevTools to a project</h1>
                </header>
            
            <article>
                
<p>Starting with Spring Boot 1.3, we have the ability to take advantage of DevTools components in our projects to enable things like automatic application restarts upon code change, reloading the browser windows for the UI, or remotely reloading applications.</p>
<p>The DevTools module is available for both Maven and Gradle, and works nicely with either Eclipse or IntelliJ IDEA editors.</p>
<div class="packt_infobox">In this chapter, we will cover integration with Gradle and IntelliJ IDEA, but for detailed information about using Spring Boot DevTools, take a look at the documentation at <span class="URLPACKT"><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html">http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html</a></span>.<a href="http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Continuing with our <kbd>BookPub</kbd> project, we will be adding a DevTools module to the main build configuration by performing the following steps:</p>
<ol>
<li>Add the following content to the <kbd>build.gradle</kbd> file located at the root of the project:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
    ... 
    compile("io.dropwizard.metrics:metrics-graphite:3.1.0") 
    compile("org.springframework.boot:spring-boot-devtools") 
    runtime("com.h2database:h2") 
    ... 
} </pre>
<ol start="2">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd>.</li>
<li>After application startup, you might notice in the console log an output warning about the inability to register with Spring Boot admin (unless you have one running) that looks like this: <span class="packt_screen">Failed to register application as Application...</span>. Let's make a live change to the <kbd>application.properties</kbd> file located in the <kbd>build/resources/main</kbd> directory from the root of our project and add a property entry with the following content:</li>
</ol>
<pre style="padding-left: 60px">spring.boot.admin.auto-registration=false </pre>
<ol start="4">
<li>Without doing anything else, upon saving the file, we should see the console log showing us that the application context is being restarted.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you have probably learned by now, when we add a <kbd>spring-boot-devtools</kbd> module as a dependency there is some autoconfiguration magic that takes place to add a number of components. A number of listeners and autoconfigurations extend the application context to handle the code changes and do appropriate restarts and reloads, both local and remote.</p>
<p>In our recipe, we did a quick test to make sure the restart functionality worked and everything had been configured by making a property change in the <kbd>application.properties</kbd> file. You have probably noticed that instead of making the change in <kbd>src/main/resources/application.properties</kbd>, we made the change to the compiled version located under the <kbd>build/resources/main</kbd> directory. The reason for this was because of the property placeholder replacements for the <kbd>info.</kbd> block that we used during the Gradle build phase. If we were to only make a change in the original file and use the IntelliJ compile option, it would not perform the required replacements and thus result in a restart failure.</p>
<p>When the DevTools are enabled, the application after being started, begins to monitor the classpath for changes to the classes that are on that classpath. When any class or a resource changes, it will serve as a trigger for DevTools to reload the application by refreshing the classloader containing the project's codebase (which is not the same classloader that holds the classes from the static dependency artifacts).</p>
<div class="packt_infobox">See the detailed explanation of the inner workings at the following link:<br/>
<span class="URLPACKT"><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart">http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart</a></span></div>
<p>After the reloadable classloader has completed the refresh, the application context gets restarted automatically, thus effectively causing the application restart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring LiveReload</h1>
                </header>
            
            <article>
                
<p>Those who work on frontend web applications will probably agree that being able to automatically reload the page once the backend code or resource change has taken place will save a few clicks and prevent situations where a forgotten reload leads to wasteful debugging efforts and chasing an error that does not exist. Thankfully, DevTools comes to the rescue by providing a LiveReload server implementation, which can be used together with a LiveReload browser extention to automatically reload the page when the backend change occurs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>If the DevTools module is added to the build dependencies, the LiveReload server has been automatically started. We do, however, need to install and enable the browser extensions by performing the following steps:</p>
<ol>
<li>Unless the browser already has the LiveReload extension installed, go to <a href="http://livereload.com/extensions/">http://livereload.com/extensions/</a> and install the appropriate extension for your browser of choice (Firefox, Safari, and Chrome are supported).</li>
</ol>
<div class="packt_infobox">For Internet Explorer users, there is a third-party extension available that can be found at <span class="URLPACKT"><a href="https://github.com/dvdotsenko/livereload_ie_extension/downloads">https://github.com/dvdotsenko/livereload_ie_extension/downloads</a>.<a href="https://github.com/dvdotsenko/livereload_ie_extension/downloads"/></span></div>
<ol start="2">
<li>After the extension is installed, it typically needs to be enabled on the page by clicking a button in the toolbar. This is what it would look like in the Chrome browser:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="63" src="assets/8114390a-7101-4692-b995-d33a1fe19d56.png" width="111"/></div>
</li>
<li>After enabling the extension, we can go ahead and make another change as we did in the previous recipe (or any other code or resource change), or simply execute the <kbd>touch build/resources/main/application.properties</kbd> command. We should see the application reload taking place on the backend as well as the browser page reloading after.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>With the addition of the LiveReload browser extension, and a running LiveReload server embedded into our <kbd>BookPub</kbd> application, the browser is now capable of connecting to the backend server using a web socket to monitor changes. When the Spring Boot DevTools detects a change that should trigger a reload, it will trigger the reload as well as send a notification to the browser to reload the page as well.</p>
<div class="packt_tip">If there is ever a need to disable the LiveReload part of the DevTools functionality, it can easily be achieved by adding the  <kbd>spring.devtools.livereload.enabled=false</kbd> property via any of the supported configuration options, be that a property file, environment variable, or a system property.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring dynamic application restart triggers</h1>
                </header>
            
            <article>
                
<p>In the previous recipes, we have looked into the basic capabilities of DevTools when it comes to restarting the application upon code or resource change and communicating to the browser to reload the page. This section will address the various configuration options that we can leverage to indicate to Spring Boot DevTools exactly what we want those events to be triggered by, and when. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>By default, adding a DevTools module to a project will make it monitor all the classes or resources, which could become undesired behavior, especially when it comes to multi-module repositories. This becomes true when building and launching projects from within an IDE like IntelliJ or Eclipse. We need to tell DevTools to exclude the <kbd>db-count-starter</kbd> sub-module in our project from the watch list by adjusting the configuration settings:</p>
<ol>
<li>Let's create a file named <kbd>spring-devtools.properties</kbd> under the <kbd>db-count-starter/src/main/resources/META-INF</kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">restart.exclude.db-count-starter=/db-count-starter/build/(classes|resources)/main </pre>
<ol start="2">
<li>Next we need to launch our application from within an IDE by opening the <kbd>BookPubApplication</kbd> class located under the <kbd>src/main/java/com/example/bookpub</kbd> directory from the root of our project and starting the <kbd>main(String[] args)</kbd> method either in <strong>run</strong> or <strong>debug</strong> mode</li>
</ol>
<ol start="3">
<li>With the <kbd>db-count-starter</kbd> module excluded, we can safely make a change to a file, for example a <kbd>spring.factories</kbd> resource located under the <kbd>db-count-starter/build/resources/main/META-INF</kbd> directory from the root of our project, only to see the application not being restarted</li>
<li>If we want to completely disable the restart capability, we can do so by adding the following property to <kbd>application.properties</kbd> located under the <kbd>src/main/resources</kbd> directory from the root of our project:</li>
</ol>
<pre style="padding-left: 60px">spring.devtools.restart.enabled=false </pre>
<ol start="5">
<li>After relaunching our application, even the changes to the <kbd>build/resources/main/application.properties</kbd> file, which is what's being loaded from the classpath, will not trigger the application restart</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we have looked at a number of different reload trigger configurations, so let's look at each of them individually to understand where best to use them:</p>
<ul>
<li><kbd>spring.devtools.restart.enabled</kbd>: This property offers the simplest of controls, fully enabling or disabling the restart functionality of DevTools. With the value of <kbd>false</kbd>, no restart of the application will take place, regardless of the class or resource changes on the classpath.</li>
<li><kbd>spring.devtools.restart.exclude</kbd>: This property provides an ability to stop specific classpaths from being reloaded. This property accepts values in a comma-separated form using the Ant Path matching pattern style. The default exclude value is <kbd>"META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties"</kbd>.</li>
<li><kbd>spring.devtools.restart.additional-exclude</kbd>: This property provides the convenience of being able to add to the default excludes list without having to copy/paste the default values, but rather simply adding to them while retaining the original defaults. It takes the same comma-separated Ant Path matching pattern style of input.</li>
<li><kbd>spring.devtools.restart.additional-paths</kbd>: This property provides the ability to watch for resources that are outside of the classpath. For example, this could be a <kbd>config</kbd> directory that gets loaded at application startup, and you want to restart the application if the config entry changes. It takes a comma-separated list of absolute file paths.</li>
<li><kbd>spring.devtools.restart.poll-interval</kbd>: This property specifies how long to pause, in milliseconds, between checking for classpath changes. The default value is <kbd>1000</kbd> milliseconds, but if there is a need to save some CPU cycles, this will do the trick.</li>
<li><kbd>spring.devtools.restart.quiet-period</kbd>: This property controls how much time should pass, in milliseconds, without any changes to the classpath before the restart will take place. This is needed to ensure the restarts don't get overwhelming if there are continuous changes taking place. The default value is <kbd>400</kbd> milliseconds, but it can be changed if needed.</li>
<li><kbd>spring.devtools.restart.trigger-file</kbd>: This property provides explicit control over when a restart happens by watching a <kbd>trigger</kbd> file for change. This is useful for situations where the classpath gets continuously changed, and you don't want to get caught in a restart loop.</li>
</ul>
<p>All the preceding property settings listed are usually shared between all the application projects that developers work on, so DevTools provides the ability to have global properties defined in this, making it convenient to share the development configurations across many projects without having to copy/paste the same values in all the different codebases.</p>
<div class="packt_infobox">Internally, this capability is implemented as <kbd>PropertySource</kbd>, which gets added to the top of the configuration precedence hierarchy. This means that not only the <kbd>spring.devtools</kbd> configuration family, but any property added to the global file will be applied to all applications using DevTools.</div>
<p>Another way to control reload triggers is with the use of <kbd>META-INF/spring-devtools.properties</kbd> with the <kbd>restart.exclude.&lt;name&gt;</kbd> and <kbd>restart.include.&lt;name&gt;</kbd> configurations inside them. By default, the restart of the application only gets triggered by changes to the actual classes or resources that are directly on the classpath and not bundled into JARs. This allows you to keep the majority of the classes in the non-reloadable base classloader, greatly limiting the number of entries that need to be monitored for changes.</p>
<p>In situations where developers work with multiple projects that are dependent on each other, or work in a multi-module repository, like the <kbd>BookPub</kbd> one, it might be desirable to add some JARs into a reloadable classloader and watch them for change. This would typically be applied to dependencies that point to the <kbd>build/libs</kbd> or <kbd>target</kbd> directories, where the JARs inside them are a direct result of a build task execution and typically get rebuilt frequently.</p>
<p>Another use case, which we explored in this recipe, is the inclusion or exclusion of <kbd>build/classes</kbd> or <kbd>target/classes</kbd> from the watch list. If a multi-module project is loaded in an IDE, it is common for the classpath to contain direct reference to the build directories of the sub-modules instead of the compiled JAR artifact, and depending on the use case, we might or might not choose to include or exclude those from triggering the reload.</p>
<p>The <kbd>&lt;name&gt;</kbd> part of the keys is not important as long as it is unique, because all the <kbd>META-INF/spring-devtools.properties</kbd> files will be loaded as composites, regardless whether if they live inside the JARs or right in the project. The suggested approach is to use a sub-module/artifact name, as it will typically ensure uniqueness. If more than one pattern applies, the name can be appended with a sequence number, for example <kbd>restart.exclude.db-count-starter-1</kbd> and <kbd>restart.exclude.db-count-starter-2</kbd>. The value of each key should contain a valid regex pattern that can be evaluated against every entry in the classpath to determine whether that particular classpath URL should go into the reloadable or base classloader.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Remote Update</h1>
                </header>
            
            <article>
                
<p>With the growing popularity of Docker, more and more applications are being built and deployed as Docker containers. One of the great features of Docker is the isolation of the runtime environment from the host OS, but that same isolation makes it difficult to make continuous changes and test your application in a true environment. Each time there is a change to a property file or a Java class, one needs to rebuild everything, create a new Docker image, restart the container, and so on. That's a lot of work to be doing for every change.</p>
<p>Even though, unfortunately, as of version 2.0, Spring Boot has removed the capability of doing a remote debug, there is still the very helpful ability to remotely reload the code changes from within your IDE as you work on the code, without the need to at least rebuild the application JAR and Docker image.</p>
<p>The <strong>Remote Restart</strong> capability provides a solution for better continuous development and makes it possible to do dynamic application restarts remotely, as if it were on a local machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>As you have probably guessed, Remote Restart involves an agent running locally and sending instructions to the remote client. DevTools provides an implementation of such an agent—<kbd>RemoteSpringApplication</kbd>:</p>
<ol>
<li>In order to enable Remote Restart, we need to add a property to <kbd>application.properties</kbd> located under the <kbd>src/main/resources</kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">spring.devtools.remote.secret=our-secret </pre>
<ol start="2">
<li>The next step would be to create a Java application launch configuration for the <kbd>RemoteSpringApplication</kbd> class in the IDE.</li>
</ol>
<div class="packt_infobox">It is important to make sure the program arguments field has the base URL of the application you are trying to debug together with the port. Ensure that the working directory points to the main project, and the classpath of the module is pointing to the main project module as well.</div>
<p>The figure on the next page shows what such a configuration would look like in IntelliJ IDEA. The Eclipse IDE would have a similar form as well.</p>
<div class="CDPAlignCenter CDPAlign"><img height="426" src="assets/7503253b-f437-48e8-a5be-cbd5facb2aea.png" width="491"/></div>
<ol start="3">
<li>After filling out all the fields, we need to start <kbd>RemoteSpringApplication</kbd> from within our IDE by clicking <span class="packt_screen">Run</span>. If all has been configured correctly, we should see a similar output in the log:</li>
</ol>
<pre>    <strong>  .   ____          _                                              __ _ _</strong>
    <strong> /\ / ___'_ __ _ _(_)_ __  __ _          ___               _         </strong>
    <strong>( ( )___ | '_ | '_| | '_ / _` |        | _ ___ _ __  ___| |_ ___    </strong>
    <strong> \/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  / _   _/ -_) ) ) ) )</strong>
    <strong>  '  |____| .__|_| |_|_| |___, |        |_|____|_|_|____/_____|/ / / /</strong>
    <strong> =========|_|==============|___/===================================/_/_/_/</strong>
    <strong> :: Spring Boot Remote ::  (v2.0.0.BUILD-SNAPSHOT)</strong>
    
    <strong>2017-12-26 21:33:28.520  INFO o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication v2.0.0.BUILD-SNAPSHOT ...</strong>
    <strong>2017-12-26 21:33:28.524  INFO o.s.b.devtools.RemoteSpringApplication   : No active profile set, falling back to default profiles: default</strong>
    <strong>2017-12-26 21:33:28.781  INFO s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6babf3bf: startup date [Tue Dec 26 21:33:28 CST 2017]; root of context hierarchy</strong>
    <strong>2017-12-26 21:33:29.295  WARN o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://127.0.0.1:8080 is insecure. You should use a URL starting with 'https://'.</strong>
    <strong>2017-12-26 21:33:29.368 DEBUG o.s.b.devtools.restart.ChangeableUrls    : Matching URLs for reloading : [file:/.../ch8/build/classes/main/, file:/.../ch8/build/resources/main/]</strong>
    <strong>2017-12-26 21:33:29.401  INFO o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729</strong>
    <strong>2017-12-26 21:33:29.443  INFO o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 1.497 seconds (JVM running for 2.248)</strong>
  </pre>
<ol start="4">
<li>To simulate remoteness, we will launch the application in a separate command shell, executing the <kbd>./gradlew clean bootJar</kbd> command followed by executing <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd>.</li>
<li>Once the application has started, take a look at one of the last lines in the log that should look something like the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>INFO 50926 --- [           main] ication$$EnhancerBySpringCGLIB$$11c0ff63 : Value of my.config.value property is:</strong></pre>
<ol start="6">
<li>The property value of <kbd>my.config.value</kbd> is not being set, because we don't have one defined in our <kbd>application.properties </kbd> file, and we didn't use any environment variables or startup system property settings to set it.</li>
<li>Let's pretend we need to do a live change and modify our <kbd>application.properties</kbd> file located under the <kbd>build/resources/main</kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">my.config.value=Remote Change </pre>
<ol start="8">
<li>Now we should see in the console that our application has automatically restarted and, after all is done, we should see something similar to the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>INFO 50926 --- [  restartedMain] ication$$EnhancerBySpringCGLIB$$11c0ff63 : Value of my.config.value property is: Remote Change</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>It might look like voodoo magic, but the science behind the Remote Restart functionality is pretty straightforward. Under the hood, when a DevTools module is included, the HTTP endpoint handler for <kbd>/.~~spring-boot!~/restart</kbd> automatically gets added. This allows the <kbd>RemoteSpringApplication</kbd> process to send the code change payload via an HTTP tunnel to the remote application and back.</p>
<p>To make sure that no malicious outside debug connection gets to connect to our remote application, the value of the <kbd>spring.devtools.remote.secret</kbd> property gets sent across and verified to establish the authenticity of the request.</p>
<p>In <em>step 2</em> of the recipe, we launched the <kbd>RemoteSpringApplication</kbd> process with a program arguments value of <kbd>http://127.0.0.1:8080</kbd>, which is how <kbd>RemoteSpringApplication</kbd> knows how to communicate with our remote application. The <kbd>RemoteSpringApplication</kbd> class itself scans for the local file changes from an IDE by monitoring the classpath.</p>
<p>In <em>step 6</em> of the recipe, when we added the property to our config in the code, it is very important to note that we made the change to the <kbd>application.properties</kbd> file located in the running classpath of the <kbd>RemoteSpringApplication</kbd> class not under <kbd>src/main/resources</kbd>, but under the <kbd>build/resources/main</kbd> directory, where Gradle has placed all the compiled files—hopefully that's the same directory your IDE is using as a classpath to run <kbd>RemoteSpringApplication</kbd>. If that's not the path your IDE is using, you should make the change in the appropriate folder, where the IDE has compiled the classes—for IntelliJ IDEA that would be the <kbd>out/production/resources</kbd> directory by default.</p>
<p>If DevTools needs to be enabled inside an application running as a Docker container, we need to explicitly configure the <kbd>build</kbd> script to do so by adding the following to the <kbd>build.gradle</kbd> file in the main project:</p>
<pre>bootJar { 
    ... 
    excludeDevtools = false 
} </pre>
<p>The reason we need to do this is because, by default, when a Spring Boot application gets re-packaged for production deployment, which is the case when building a Docker container image, the DevTools module is excluded from the classpath during build time. To prevent this from happening, we need to tell the build system to not exclude the module in order to take advantage of its capabilities, namely the Remote Restart.</p>


            </article>

            
        </section>
    </body></html>