<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">GUI Programming Using JavaFX</h1>
                </header>
            
            <article>
                
<p>In this chapter we will cover the following recipes:</p>
<ul>
<li>Creating a GUI using JavaFX controls</li>
<li>Using the FXML markup to create a GUI</li>
<li>Using CSS to style elements in JavaFX</li>
<li>Creating a bar chart</li>
<li>Creating a pie chart</li>
<li>Creating a line chart</li>
<li>Creating an area chart</li>
<li>Creating a bubble chart</li>
<li>Creating a scatter chart</li>
<li>Embedding HTML in an application</li>
<li>Embedding media in an application</li>
<li>Adding effects to controls</li>
<li>Using the new TIFF I/O API to read TIFF images</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>GUI programming has been in Java since JDK 1.0, via the API called <strong>Abstract Window Toolkit</strong> (<strong>AWT</strong>). This was a remarkable thing during those times, but it had its own limitations, a few of which are as follows: </p>
<ul>
<li>It had a limited set of components </li>
<li>You couldn't create custom reusable components because AWT was using native components</li>
<li>The look and feel of the components couldn't be controlled and they took the look and feel of the host OS</li>
</ul>
<p>Then, in Java 1.2, a new API for GUI development called <strong>Swing</strong> was introduced, which worked on the deficiencies of AWT by providing the following:</p>
<ul>
<li>A richer components library.</li>
<li>Support for creating custom components.</li>
<li>Native look and feel and support for plugging in a different look and feel. Some of the know Java look and feel themes are Nimbus, Metal, Motif, and the system default.  </li>
</ul>
<p>A lot of desktop applications that make use of Swing have been built, and a lot of them are still being used. However, with time, technology has to evolve; otherwise, it will eventually be outdated and seldom used. In 2008, Adobe's Flex started gaining attention. It was a framework for building <strong>Rich Internet applications</strong> (<strong>RIAs</strong>). The desktop applications were always rich component-based UIs but the web applications were not that amazing to use. Adobe introduced a framework called Flex, which enabled web developers to create rich, immersive UIs on the web. So the web applications were no longer boring. </p>
<p>Adobe also introduced a rich internet application runtime environment for the desktop called Adobe AIR, which allowed running Flex applications on the desktop. This was a major blow to the age-old Swing API. In order to come back to the market, in 2009, Sun Microsystems introduced something called JavaFX. This framework was inspired by Flex (which used XML for defining the UI) and introduced its own scripting language called JavaFX script, somewhat closer to JSON and JavaScript. One could invoke Java APIs from the JavaFX script. There was a new architecture introduced, which had a new Windowing toolkit and a new graphics engine. It was a much better alternative to Swing but had a drawback--developers had to learn JavaFX script to develop JavaFX-based applications. In addition to Sun Microsystems not being able to invest more on JavaFX and the Java platform, in general, JavaFX never took off as envisioned. </p>
<p>Oracle (after acquiring Sun Microsystems) announced a new JavaFX version 2.0, which was an entire rewrite of JavaFX, thereby eliminating the scripting language and making JavaFX an API within the Java platform. This has made using the JavaFX API similar to using Swing APIs. Also, one can embed JavaFX components within Swing, thereby making Swing-based applications more functional. Since then, there has been no looking back for JavaFX. </p>
<p>In this chapter, we will focus entirely on the recipes around JavaFX. We will try to cover as many recipes as possible to give you all a good experience of using JavaFX. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a GUI using JavaFX controls</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will look at creating a simple GUI application using JavaFX controls. We will build an app that will help you compute your age by providing your date of birth. Optionally, you can even enter your name and the app will greet you and display your age. It is a pretty simple example, which tries to show how you can create a GUI by using layouts, components, and event handling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> Getting ready</h1>
                </header>
            
            <article>
                
<p>The JDK you have installed comes with the JavaFX modules, so there isn't anything needed to be done to start using JavaFX. Various modules that contain the JavaFX classes are as follows:</p>
<ul>
<li><kbd>javafx.base</kbd></li>
<li><kbd>javafx.controls</kbd></li>
<li><kbd>javafx.fxml</kbd></li>
<li><kbd>javafx.graphics</kbd></li>
<li><kbd>javafx.media</kbd></li>
<li><kbd>javafx.swing</kbd></li>
<li><kbd>javafx.web</kbd></li>
</ul>
<p>In our recipe, we will be using a few modules as and when required from the preceding list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a class, which extends the <kbd>javafx.application.Application</kbd>. The <kbd>Application</kbd> class manages the lifecycle of the JavaFX application. The <kbd>Application</kbd> class has an abstract method, <kbd>start(Stage stage)</kbd>, which one has to implement. This would be our starting point for our JavaFX UI:</li>
</ol>
<pre>        public class CreateGuiDemo extends Application{
          public void start(Stage stage){
            //to implement in new steps
          }
        }</pre>
<p style="padding-left: 60px">The class can also be the starting point for the application by providing a <kbd>public static void main(String [] args) {}</kbd> method:</p>
<pre>        public class CreateGuiDemo extends Application{
<span>          public void start(Stage stage){
</span><span>            //to implement in new steps
</span><span>          }
</span>          public static void main(String[] args){
            //launch the JavaFX application
          }
        }</pre>
<p style="padding-left: 60px"><span>The code for the subsequent steps has to be written within the <kbd>start(Stage stage)</kbd> method.</span></p>
<ol start="2">
<li>Let's create a container layout to properly align the components that we will be adding. In this case, we will use <kbd>javafx.scene.layout.GridPane</kbd> to lay the components in the form of a grid of rows and columns:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<p style="padding-left: 60px">Along with creating the <kbd>GridPane</kbd> instance, we are setting its layout properties, such as the alignment of <kbd>GridPane</kbd>, the horizontal and vertical spaces between the rows and columns, and the padding within each cell of the grid.</p>
<ol start="3">
<li>Create a new label, which will show the name of our application, specifically, <kbd>Age calculator</kbd>, and add it to <kbd>gridPane</kbd>, which we created in the preceding step:</li>
</ol>
<pre>        Text appTitle = new Text("Age calculator");
        appTitle.setFont(Font.font("Arial", FontWeight.NORMAL, 15));
        gridPane.add(appTitle, 0, 0, 2, 1);</pre>
<ol start="4">
<li>Create a label and a text input combination, which will be used for accepting the user's name. Then add these two components to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        Label nameLbl = new Label("Name");
        TextField nameField = new TextField();
        gridPane.add(nameLbl, 0, 1);
        gridPane.add(nameField, 1, 1);</pre>
<ol start="5">
<li>Create a label and a date picker combination, which will be used for accepting the user's date of birth:</li>
</ol>
<pre>        Label dobLbl = new Label("Date of birth");
        gridPane.add(dobLbl, 0, 2);
        DatePicker dateOfBirthPicker = new DatePicker();
        gridPane.add(dateOfBirthPicker, 1, 2);</pre>
<ol start="6">
<li>Create a button, which will be used by the user to trigger the age calculation, and add it to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        Button ageCalculator = new Button("Calculate");
        gridPane.add(ageCalculator, 1, 3);</pre>
<ol start="7">
<li>Create a component to hold the result of the computed age:</li>
</ol>
<pre>        Text resultTxt = new Text();
        resultTxt.setFont(Font.font("Arial", FontWeight.NORMAL, 15));
        gridPane.add(resultTxt, 0, 5, 2, 1);</pre>
<ol start="8">
<li>Now, we need to bind an action to the button created in step 6. The action would be to get the name entered in the name field and the date of birth entered in the date picker field. If the date of birth is provided, then use the Java time APIs to compute the period between now and the date of birth. If there is a name provided, then prepend a greeting, <kbd>Hello, &lt;name&gt;</kbd>, to the result:</li>
</ol>
<pre>        ageCalculator.setOnAction((event) -&gt; {
          String name = nameField.getText();
          LocalDate dob = dateOfBirthPicker.getValue();
          if ( dob != null ){
            LocalDate now = LocalDate.now();
            Period period = Period.between(dob, now);
            StringBuilder resultBuilder = new StringBuilder();
            if ( name != null &amp;&amp; name.length() &gt; 0 ){
              resultBuilder.append("Hello, ")
                         .append(name)
                         .append("n");
            }
            resultBuilder.append(String.format(
              "Your age is %d years %d months %d days",
              period.getYears(), 
              period.getMonths(), 
              period.getDays())
            );
            resultTxt.setText(resultBuilder.toString());
          }
        });</pre>
<ol start="9">
<li>Create an instance of the <kbd>Scene</kbd> class by providing the <kbd>gridPane</kbd> object we created in step 2 and the dimensions, the width and height of the scene:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 300, 250);</pre>
<p style="padding-left: 60px">An instance of <kbd>Scene</kbd> holds the graph of the UI components, called scene graph. </p>
<ol start="10">
<li>We have seen that the <kbd>start()</kbd> method provides us with a reference to a <kbd>Stage</kbd> object. The <kbd>Stage</kbd> object is the top-level container in JavaFX, something like a JFrame. We set the <kbd>Scene</kbd> object to the <kbd>Stage</kbd> object and use its <kbd>show()</kbd> method to render the UI:</li>
</ol>
<pre>        stage.setTitle("Age calculator");
        stage.setScene(scene);
        stage.show();</pre>
<ol start="11">
<li>Now, we need to launch this JavaFX UI from the main method. We use the <kbd>launch(String[] args)</kbd> method of the <kbd>Application</kbd> class to launch the JavaFX UI:</li>
</ol>
<pre>        public static void main(String[] args) {
          Application.launch(args);
        }</pre>
<p>The complete code can be found at <kbd>chp9/1_create_javafx_gui</kbd>.</p>
<p>We have provided two scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, in <span><kbd>chp9/1_create_javafx_gui</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>, and you will see the GUI as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="195" width="209" class="image-border" src="assets/fad34879-3c71-4d00-bbb5-f747cf1c635d.png"/></div>
<p>Enter the name and date of birth and click on <kbd>Calculate</kbd> to view the age:</p>
<div class="CDPAlignCenter CDPAlign"><img height="176" width="189" class="image-border" src="assets/bacb4220-3851-4d61-8e84-e29c1ef47490.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before going into the other details, let's give you a brief overview of the JavaFX architecture. We have taken the following image describing the architecture stack from the JavaFX documentation (<a href="http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788">http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788</a>):</p>
<div class="CDPAlignCenter CDPAlign"><img height="129" width="402" class="image-border" src="assets/5a9a9b29-e0fd-47fd-b21a-36aa95e815e2.png"/></div>
<p>Let's start from the top of the stack:</p>
<ul>
<li><strong>The JavaFX APIs and Scene graph</strong>: This is the starting point of the application and most of our focus will be around this part. This provides APIs for different components, layout, and other utilities to facilitate developing a JavaFX-based UI. The scene graph holds the visual elements of the application. </li>
<li><strong>Prism, quantum toolkit, and the other stuff in blue</strong>: These components manage the rendering of the UI and provide a bridge between the underlying operating system and JavaFX. This layer provides software rendering in the cases where the graphics hardware is unable to provide hardware-accelerated rendering of rich UI and 3D elements.</li>
<li><strong>The Glass Windowing Toolkit</strong>: This is the windowing toolkit, just like the AWT used by Swing.</li>
<li><strong>The media engine</strong>: This supports media in JavaFX.</li>
<li><strong>The web engine</strong>: This supports the web component, which allows complete HTML rendering.</li>
<li><strong>The JDK APIs and JVM</strong>: These integrate with the Java API and compile the code down to byte code to run on the JVM.</li>
</ul>
<p>Let's get back to explaining the recipe. The <kbd>javafx.application.Application</kbd> class is the entry point for launching the JavaFX applications. It has the following methods that map to the lifecycle of the application (in their invocation order):</p>
<ul>
<li><strong><kbd>init()</kbd></strong>: This method is invoked immediately after the instantiation of <span><kbd>javafx.application.Application</kbd>. One can override this method to do some initialization before the start of the application. By default, this method does nothing.</span></li>
<li><kbd>start(javafx.stage.Stage)</kbd>: This method is called immediately after <kbd>init()</kbd> and after the system has done the required initialization to run the application. This method is passed with a <kbd>javafx.stage.Stage</kbd> instance, which is the primary stage on which the components are rendered. One can create other <kbd>javafx.stage.Stage</kbd> objects but the one provided by the application is the primary stage.</li>
<li><kbd>stop()</kbd>: This method is called when the application should stop. One can do the necessary exit-related operations.</li>
</ul>
<div class="packt_infobox">A stage is a top-level JavaFX container. The primary stage passed as an argument to the <kbd>start()</kbd> method is created by the platform, and the application can create other <kbd>Stage</kbd> containers as and when required.</div>
<p>The other important method related to <kbd>javafx.application.Application</kbd> is the <kbd>launch()</kbd> method. There are two variants of this:</p>
<ul>
<li><kbd>launch(Class&lt;? extends Application&gt; appClass, String... args)</kbd></li>
<li><kbd>launch(String... args)</kbd></li>
</ul>
<p>This method is called from the main method and should be called only once. The first variant takes the name of the class that extends the <kbd>javafx.application.Application</kbd> class along with the arguments passed to the main method, and the second variant doesn't take the name of the class and, instead, should be invoked from within the class that extends the <span><kbd>javafx.application.Application</kbd> class. In our recipe, we have made use of the second variant. </span></p>
<p>We have created a class, <kbd>CreateGuiDemo</kbd>, which extends <kbd>javafx.application.Application</kbd>. This will be the entry point for JavaFX  UI and we also added a main method to the class, making it an entry point for our application.</p>
<p>A layout construct determines how your components are laid out. There are multiple layouts supported by JavaFX, as follows: </p>
<ul>
<li><kbd>javafx.scene.layout.HBox</kbd> and <kbd><span>javafx.scene.layout.</span>VBox</kbd>: These are used to align the components horizontally and vertically</li>
<li><kbd><span>javafx.scene.layout.</span>BorderPane</kbd>: This allows placing the components in the top, right, bottom, left, and center positions</li>
<li><kbd><span>javafx.scene.layout.</span>FlowPane</kbd>: This layout allows placing the components in a flow, that is, beside each other, wrapping at the flow pane's boundary</li>
<li><kbd><span>javafx.scene.layout.</span>GridPane</kbd>: This layout allows placing the components in a grid of rows and columns</li>
<li><kbd><span>javafx.scene.layout.</span>StackPane</kbd>: This layout places the components in a back-to-front stack</li>
<li><kbd><span>javafx.scene.layout.</span>TilePane</kbd>: This layout places the components in a grid of uniformly sized tiles</li>
</ul>
<p>In our recipe, we have made use of <kbd>GridPane</kbd> and configured the layout so that we can achieve the following:</p>
<ul>
<li>The grid is placed at the center (<kbd>gridPane.setAlignment(Pos.CENTER);</kbd>)</li>
<li>Set the gap between the columns to 10 (<kbd>gridPane.setHgap(10);</kbd>)</li>
<li>Set the gap between the rows to 10 (<kbd>gridPane.setVgap(10);</kbd>)</li>
<li>Set the padding within the cell of the grid (<kbd>gridPane.setPadding(new Insets(25, 25, 25, 25));</kbd>)</li>
</ul>
<p>A <kbd>javafx.scene.text.Text</kbd> component's font can be set using the <kbd>javafx.scene.text.Font</kbd> object as shown here: <kbd>appTitle.setFont(Font.font("Arial", FontWeight.NORMAL, 15));</kbd></p>
<p>While adding the component to <kbd><span>javafx.scene.layout.</span>GridPane</kbd>, we have to mention the column number, row number, and column span, that is, how many columns the component occupies, and the row span, that is, how many rows the component occupies in that order. The column span and row span are optional. In our recipe, we have placed <kbd>appTitle</kbd> in the first row and column, and it occupies two column spaces and one row space, as shown in the code here: <kbd>appTitle.setFont(Font.font("Arial", FontWeight.NORMAL, 15));</kbd></p>
<p>The other important part in this recipe is the setting of the event for the <kbd>ageCalculator</kbd> button. We make use of the <kbd>setOnAction()</kbd> method of the <kbd>javafx.scene.control.Button</kbd> class to set the action performed when the button is clicked. This accepts an implementation of the <kbd>javafx.event.EventHandler&lt;ActionEvent&gt;</kbd> interface. As <kbd>javafx.event.EventHandler</kbd> is a functional interface, its implementation can be written in the form a lambda expression, as follows:</p>
<pre>ageCalculator.setOnAction((event) -&gt; {
  //event handling code here
});</pre>
<p>The preceding syntax looks similar to your anonymous inner classes widely used during the times of Swing. You can learn more about functional interfaces and lambda expressions in the recipes in <a href="039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml">Chapter 4</a>, <em>Going Functional</em>. </p>
<p>In our event handling code, we get the values from <kbd>nameField</kbd> and <kbd>dateOfBirthPicker</kbd> by using the methods, <kbd>getText()</kbd> and <kbd>getValue()</kbd>, respectively. <kbd>DatePicker</kbd> returns the date selected as an instance of <kbd>java.time.LocalDate</kbd>. This is one of the new date-time APIs added to Java 8. It represents a date, that is, year, month, and day, without any timezone-related information. We then make use of the <kbd>java.time.Period</kbd> class to find the duration between the current date and the selected date, as follows:</p>
<pre>LocalDate now = LocalDate.now();
Period period = Period.between(dob, now);</pre>
<p><kbd>Period</kbd> represents the date-based duration in terms of years, months, and days, that is, for example, 3 years, 2 months, and 3 days. This is exactly what we are trying to extract with this line of code: <kbd>String.format("Your age is %d years %d months %d days",  period.getYears(), period.getMonths(), period.getDays())</kbd>.</p>
<p>We have already mentioned that the UI components in JavaFX are represented in the form of a scene graph and this scene graph is then rendered on to a container, called <kbd>Stage</kbd><em>.</em> The way to create a scene graph is by using the <kbd>javafx.scene.Scene</kbd> class. We create a <kbd>javafx.scene.Scene</kbd> instance by passing the root of the scene graph and also by providing the dimensions of the container in which the scene graph is going to be rendered. </p>
<p>We make use of the container provided to the <kbd>start()</kbd> method, which is nothing but an instance of <kbd>javafx.stage.Stage</kbd>. Setting the scene for the <kbd>Stage</kbd> object and then calling its <kbd>show()</kbd> methods makes the complete scene graph rendered on the display:</p>
<pre>stage.setScene(scene);
stage.show();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the FXML markup to create a GUI</h1>
                </header>
            
            <article>
                
<p>In our first recipe, we looked at using Java APIs to build a UI. It often happens that the person who is adept at Java might not be a good UI designer, that is, he may be poor at identifying the best user experience for their app. In the world of web development, we have developers working on the frontend, based on the designs given by the UX designer and the other set of developers working on the backend to build services that are consumed by the frontend. </p>
<p>Both the developer parties agree on a set of APIs and a common data interchange model. The frontend developers work by using some mock data based on the data interchange model and also integrate the UI with the required APIs. On the other hand, the backend developers work on implementing the APIs so that they return the data in the interchange model agreed upon.  So, both the parties work simultaneously using the expertise in their work areas. </p>
<p>It would be amazing if the same could be replicated (at least to some extent) on desktop applications. A step in this direction was the introduction of an XML-based language, called FXML. This enables a declarative method of UI development, where the developer can independently develop the UI using the same JavaFX components but available as XML tags. The different properties of the JavaFX components are available as attributes of the XML tags. Event handlers can be declared and defined in the Java code and then referred from FXML. </p>
<p>In this recipe, we will guide you through building the UI using FXML and then integrating FXML with the Java code for binding the action and for launching the UI defined in the FXML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There is nothing much required if you have been able to implement the previous recipe. If you are coming directly to this recipe, there is nothing much to do either. The JavaFX APIs come with OpenJDK, which you must already have installed on your systems. </p>
<p>We will develop a simple age calculator app. This app will ask for the user's name (which is optional) and the date of birth, and calculate the age from the given date of birth and display it to the user. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>All the FXML files should end with the <kbd>.fxml</kbd> extension. Let's create an empty <kbd>fxml_age_calc_gui.xml</kbd> file in the location, <kbd>src/gui/com/packt</kbd>. In the subsequent steps, we will update this file with the XML tags for the JavaFX components.</li>
<li>Create a <kbd>GridPane</kbd> layout, which will hold all the components in a grid of rows and columns. We will also provide the required spacing between the rows and the columns using the <kbd>vgap</kbd> and <kbd>hgap</kbd> attributes. Also, we will provide <kbd>GridPane</kbd>, which is our root component, with the reference to the Java class where we will add the required event handling. This Java class will be like the controller for the UI:</li>
</ol>
<pre>        &lt;GridPane alignment="CENTER" hgap="10.0" vgap="10.0"
          
          fx:controller="com.packt.FxmlController"&gt;
        &lt;/GridPane&gt;</pre>
<ol start="3">
<li>We will provide the padding within each cell of the grid by defining a <kbd>padding</kbd> tag with <kbd>Insets</kbd> within <kbd>GridPane</kbd>:</li>
</ol>
<pre>        &lt;padding&gt;
          &lt;Insets bottom="25.0" left="25.0" right="25.0" top="25.0" /&gt;
        &lt;/padding&gt;</pre>
<ol start="4">
<li>Next is to add a <kbd>Text</kbd> tag, which displays the title of the application: <kbd>Age Calculator</kbd>. We provide the required style information in the <kbd>style</kbd> attribute and the placement of the <kbd>Text</kbd> component within <kbd>GridPane</kbd> using the <kbd>GridPane.columnIndex</kbd> and <kbd>GridPane.rowIndex</kbd> attributes. The cell occupancy information can be provided using the <kbd>GridPane.columnSpan</kbd> and <kbd>GridPane.rowSpan</kbd> attributes:</li>
</ol>
<pre>        &lt;Text style="-fx-font: NORMAL 15 Arial;" text="Age calculator"
          GridPane.columnIndex="0" GridPane.rowIndex="0" 
          GridPane.columnSpan="2" GridPane.rowSpan="1"&gt;
        &lt;/Text&gt;</pre>
<ol start="5">
<li>We then add the <kbd>Label</kbd> and <kbd>TextField</kbd> components for accepting the name. Note the use of the <kbd>fx:id</kbd> attribute in <kbd>TextField</kbd>. This helps in binding this component in the Java controller by creating a field with the same name as that of the <kbd>fx:id</kbd> value:</li>
</ol>
<pre>        &lt;Label text="Name" GridPane.columnIndex="0" 
          GridPane.rowIndex="1"&gt;
        &lt;/Label&gt;
        &lt;TextField fx:id="nameField" GridPane.columnIndex="1" 
          GridPane.rowIndex="1"&gt;
        &lt;/TextField&gt;</pre>
<ol start="6">
<li>We add the <kbd>Label</kbd> and <kbd>DatePicker</kbd> components for accepting the date of birth:</li>
</ol>
<pre>        &lt;Label text="Date of Birth" GridPane.columnIndex="0" 
          GridPane.rowIndex="2"&gt;
        &lt;/Label&gt;
        &lt;DatePicker fx:id="dateOfBirthPicker" GridPane.columnIndex="1" 
          GridPane.rowIndex="2"&gt;
        &lt;/DatePicker&gt;</pre>
<ol start="7">
<li>Then, we add a <kbd>Button</kbd> object and set its <kbd>onAction</kbd> attribute to the name of the method in the Java controller that handles the click event of this button:</li>
</ol>
<pre>        &lt;Button onAction="#calculateAge" text="Calculate"
          GridPane.columnIndex="1" GridPane.rowIndex="3"&gt;
        &lt;/Button&gt;</pre>
<ol start="8">
<li>Finally we add a <kbd>Text</kbd> component to display the calculated age:</li>
</ol>
<pre>        &lt;Text fx:id="resultTxt" style="-fx-font: NORMAL 15 Arial;"
          GridPane.columnIndex="0" GridPane.rowIndex="5"
          GridPane.columnSpan="2" GridPane.rowSpan="1"
        &lt;/Text&gt;</pre>
<ol start="9">
<li>The next step is to implement the Java class, which is directly related to the XML-based UI components created in the preceding steps. Create a class named <kbd>FxmlController</kbd>. This will contain the code that is relevant to the FXML UI; that is, it will contain the references to the components created in the FXML action handlers for the components created in the FXML:</li>
</ol>
<pre>        public class FxmlController {
          //to implement in next few steps
        }</pre>
<ol start="10">
<li>We need references to the <kbd>nameField</kbd>, <kbd>dateOfBirthPicker</kbd>, and <kbd>resultText</kbd> components . We use the first two to get the entered name and date of birth, respectively, and the third to display the result of age calculation:</li>
</ol>
<pre>        @FXML private Text resultTxt;
        @FXML private DatePicker dateOfBirthPicker;
        @FXML private TextField nameField;</pre>
<ol start="11">
<li>The next step is to implement the <kbd>calculateAge</kbd> method, which is registered as the action event handler for the <kbd>Calculate</kbd> button. The implementation is similar to the one in the previous recipe. The only difference is that it is a method, unlike the previous recipe, where it was a lambda expression:</li>
</ol>
<pre>        @FXML
        public void calculateAge(ActionEvent event){
          String name = nameField.getText();
          LocalDate dob = dateOfBirthPicker.getValue();
          if ( dob != null ){
            LocalDate now = LocalDate.now();
            Period period = Period.between(dob, now);
            StringBuilder resultBuilder = new StringBuilder();
            if ( name != null &amp;&amp; name.length() &gt; 0 ){
              resultBuilder.append("Hello, ")
                           .append(name)
                           .append("n");
            }
            resultBuilder.append(String.format(
              "Your age is %d years %d months %d days", 
              period.getYears(), 
              period.getMonths(), 
              period.getDays())
            );
            resultTxt.setText(resultBuilder.toString());
          }
        }</pre>
<ol start="12">
<li>In both steps 10 and 11, we have used an annotation, <kbd>@FXML</kbd>. This annotation indicates that the class or the member is accessible to the FXML-based UI.</li>
<li>Next, we'll create another Java class, <kbd><span>FxmlGuiDemo</span></kbd>, which is responsible for rendering the FXML-based UI and which would also be the entry point for launching the application:</li>
</ol>
<pre>        public class FxmlGuiDemo extends Application{ 
          //code to launch the UI + provide main() method
        }</pre>
<ol start="14">
<li>Now we need to create a scene graph from the FXML UI definition by overriding the <kbd>start(Stage stage)</kbd> method of the <span><kbd>javafx.application.Application</kbd> class</span> and then render the scene graph within the passed <kbd>javafx.stage.Stage</kbd> object:</li>
</ol>
<pre>        @Override
        public void start(Stage stage) throws IOException{
          FXMLLoader loader = new FXMLLoader();
          Pane pane = (Pane)loader.load(getClass()
              .getModule()
              .getResourceAsStream("com/packt/fxml_age_calc_gui.fxml")
          );
    
          Scene scene = new Scene(pane,300, 250);
          stage.setTitle("Age calculator");
          stage.setScene(scene);
          stage.show();
        }</pre>
<ol start="15">
<li>Finally, we provide the <kbd>main()</kbd> method implementation:</li>
</ol>
<pre>        public static void main(String[] args) {
          Application.launch(args);
        }</pre>
<p>The complete code can be found at the location, <kbd>chp9/2_fxml_gui</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, in <span><kbd>chp9/2_fxml_gui</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>, and you will see the GUI as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="181" width="193" class="image-border" src="assets/759c00ef-26b6-4caf-ae90-ef377a3ce8cc.png"/></div>
<p>Enter the name and date of birth and click on <kbd>Calculate</kbd> to view the age:</p>
<div class="CDPAlignCenter CDPAlign"><img height="216" width="234" class="image-border" src="assets/4346fd9e-8e35-405f-aa5b-b5126d3584ae.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>There is no XSD defining the schema for the FXML document. So, to know the tags to be used, they follow a simple naming convention. The Java class name of the component is also the name of the XML tag. For example, the XML tag for the <kbd>javafx.scene.layout.GridPane</kbd> layout is <kbd>&lt;GridPane&gt;</kbd>, for <kbd>javafx.scene.control.TextField</kbd>, it is <kbd>&lt;TextField&gt;</kbd>, and for <kbd>javafx.scene.control.DatePicker</kbd>, it is <kbd>&lt;DatePicker&gt;</kbd>:</p>
<pre>Pane pane = (Pane)loader.load(getClass()
    .getModule()
    .getResourceAsStream("com/packt/fxml_age_calc_gui.fxml")
 );</pre>
<p>The preceding line of code makes use of an instance of <kbd>javafx.fxml.FXMLLoader</kbd> to read the FXML file and get the Java representation of the UI components. <kbd>FXMLLoader</kbd> uses an event-based SAX parser to parse the FXML file. Instances of the respective Java classes for the XML tags are created via reflection and the values of attributes of the XML tags are populated into the respective properties of the Java classes. </p>
<p>As the root of our FXML is <kbd>javafx.scene.layout.GridPane</kbd>, which extends <kbd>javafx.scene.layout.Pane</kbd>, we can cast the return value from <kbd>FXMLoader.load()</kbd> to <kbd>javafx.scene.layout.Pane</kbd>. </p>
<p>The other interesting thing in this recipe is the <kbd>FxmlController</kbd> class. This class acts as an interface to FXML. We indicate the same in FXML by using the <kbd>fx:controller</kbd> attribute to the <kbd>&lt;GridPane&gt;</kbd> tag. We can get hold of the UI components defined in FXML by using the <kbd>@FXML</kbd> annotation against the member fields of the <kbd>FxmlController</kbd> class, as we did in this recipe:</p>
<pre>@FXML private Text resultTxt;
@FXML private DatePicker dateOfBirthPicker;
@FXML private TextField nameField;</pre>
<p>The name of the member is the same as that of the <kbd>fx:id</kbd> attribute value in FXML, and the type of the member is the same as that of the tag in FXML. For example, the first member is bound to the following:</p>
<pre>&lt;Text fx:id="resultTxt" style="-fx-font: NORMAL 15 Arial;"
  GridPane.columnIndex="0" GridPane.rowIndex="5" 
  GridPane.columnSpan="2" GridPane.rowSpan="1"&gt;
&lt;/Text&gt;</pre>
<p>On similar lines, we created an event handler in <kbd>FxmlController</kbd> and annotated it with <kbd>@FXML</kbd>, and the same has been referenced in FXML with the <kbd>onAction</kbd> attribute of <kbd>&lt;Button&gt;</kbd>. Note that we have added <kbd>#</kbd> to the beginning of the method name in the <kbd>onAction</kbd> attribute value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also </h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe of this chapter:</p>
<ul>
<li>Creating a GUI using JavaFX controls</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using CSS to style elements in JavaFX</h1>
                </header>
            
            <article>
                
<p>Those from a web development background will be able to appreciate the usefulness of the <strong>Cascading Style Sheets</strong> (<strong>CSS</strong>), and for those who are not, we will provide an overview of what they are and how they are useful, before diving into CSS application in JavaFX. </p>
<p>The elements or the components that you see on web pages are often styled according to the theme of the website. This styling is possible by using a language called CSS. CSS consists of a group of name:value pairs, separated by semi colons. These name:value pairs, when associated with an HTML element, say, <kbd>&lt;button&gt;</kbd>, give it the required styling.</p>
<p>There are multiple ways to associate these name:value pairs to the element, the simplest being when you put this name:value pair within the style attribute of your HTML element. For example, to give the button a blue background, we can do the following:</p>
<pre>&lt;button style="background-color: blue;"&gt;&lt;/button&gt;</pre>
<p>There are predefined names for different styling properties, and these take a specific set of values; that is, the property, <kbd>background-color</kbd>, will only take valid color values. </p>
<p>The other approach is to define these groups of name:value pairs in a different file with a <kbd>.css</kbd> extension. Let's call this group of name:value pairs as CSS properties. We can associate these CSS properties with different selectors, that is, selectors for choosing the elements on the HTML page to apply the CSS properties to. There are three different ways of providing the selectors:</p>
<ol>
<li>By directly giving the name of the HTML element, that is, whether it is an anchor tag (<kbd>&lt;a&gt;</kbd>), button, or input. In such cases, the CSS properties are applied to all the types of HTML elements in the page.</li>
<li>By using the <kbd>id</kbd> attribute of the HTML element. Suppose, we have a button with <kbd>id="btn1"</kbd>, then we can define a selector, <kbd>#btn1</kbd>, against which we provide the CSS properties. Take a look at the following example:</li>
</ol>
<pre>        #btn1 { background-color: blue; }</pre>
<ol start="3">
<li>By using the class attribute of the HTML element. Suppose we have a button with <kbd>class="blue-btn"</kbd>, then we can define a selector, <kbd>.blue-btn</kbd><span>, </span>against which, we provide the CSS properties. Check out the following example:</li>
</ol>
<pre>        .<span>blue-btn</span> { background-color: blue; }</pre>
<p>The advantage of using a different CSS file is that we can independently evolve the appearance of the web pages without getting tightly coupled to the location of the elements. Also, this encourages the reuse of CSS properties across different pages, thereby giving them a uniform look across all the pages.</p>
<p>When we apply a similar approach to JavaFX, we can leverage the CSS knowledge already available with our web designers to build CSS for JavaFX components, and this helps in styling the components more easily than with the use of Java APIs. When this CSS is mixed with FXML, then it becomes a known domain for web developers.</p>
<p>In this recipe, we will look at styling a few JavaFX components using an external CSS file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There is a small difference in defining the CSS properties for the JavaFX components. All the properties must be prefixed with <kbd>-fx-</kbd>, that is, <kbd>background-color</kbd> becomes <kbd>-fx-background-color</kbd>. The selectors, that is, <kbd>#id</kbd> and <kbd>.class</kbd>-name still remain the same in the JavaFX world as well. We can even provide multiple classes to the JavaFX components, thereby applying all these CSS properties to the components.</p>
<p>The CSS that I have used in this recipe is based on a popular CSS framework called Bootstrap (<a href="http://getbootstrap.com/css/">http://getbootstrap.com/css/</a>). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's create <kbd>GridPane</kbd>, which will hold the components in a grid of rows and columns:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="2">
<li>First, we will create a button and add two classes, <kbd>btn</kbd> and <kbd>btn-primary</kbd>, to it. In the next step, we will define these selectors with the required CSS properties:</li>
</ol>
<pre>        Button primaryBtn = new Button("Primary");
        primaryBtn.getStyleClass().add("btn");
        primaryBtn.getStyleClass().add("btn-primary");
        gridPane.add(primaryBtn, 0, 1);</pre>
<ol start="3">
<li>Now, let's provide the required CSS properties for the classes, <kbd>btn</kbd> and <kbd>btn-primary</kbd>. The selector for the classes are of the form <kbd>.&lt;class-name&gt;</kbd>:</li>
</ol>
<pre>        .btn{
          -fx-border-radius: 4px;
          -fx-border: 2px;
          -fx-font-size: 18px;
          -fx-font-weight: normal;
          -fx-text-align: center;
        }
        .btn-primary {
          -fx-text-fill: #fff;
          -fx-background-color: #337ab7;
          -fx-border-color: #2e6da4;
        }</pre>
<ol start="4">
<li>Let's create another button with a different CSS class:</li>
</ol>
<pre>        Button successBtn = new Button("Sucess");
        successBtn.getStyleClass().add("btn");
        successBtn.getStyleClass().add("btn-success");
        gridPane.add(successBtn, 1, 1);</pre>
<ol start="5">
<li>Now we define the CSS properties for the <kbd>.btn-success</kbd> selector as follows:</li>
</ol>
<pre>        .btn-success {
          -fx-text-fill: #fff;
          -fx-background-color: #5cb85c;
          -fx-border-color: #4cae4c;
        }</pre>
<ol start="6">
<li>Let's create yet another button with a different CSS class:</li>
</ol>
<pre>        Button dangerBtn = new Button("Danger");
        dangerBtn.getStyleClass().add("btn");
        dangerBtn.getStyleClass().add("btn-danger");
        gridPane.add(dangerBtn, 2, 1);</pre>
<ol start="7">
<li>We will define the CSS properties for the selector <kbd>.btn-danger</kbd>:</li>
</ol>
<pre>        .btn-danger {
          -fx-text-fill: #fff;
          -fx-background-color: #d9534f;
          -fx-border-color: #d43f3a;
        }</pre>
<ol start="8">
<li>Now, let's add some labels with different selectors, namely <kbd>badge</kbd>, <kbd>badge-info</kbd>:</li>
</ol>
<pre>        Label label = new Label("Default Label");
        label.getStyleClass().add("badge");
        gridPane.add(label, 0, 2);

        Label infoLabel = new Label("Info Label");
        infoLabel.getStyleClass().add("badge");
        infoLabel.getStyleClass().add("badge-info");
        gridPane.add(infoLabel, 1, 2);</pre>
<ol start="9">
<li>The CSS properties for the previous selectors are:</li>
</ol>
<pre>        .badge{
          -fx-label-padding: 6,7,6,7;
          -fx-font-size: 12px;
          -fx-font-weight: 700;
          -fx-text-fill: #fff;
          -fx-text-alignment: center;
          -fx-background-color: #777;
          -fx-border-radius: 4;
        }<br/><br/>        .badge-info{
          -fx-background-color: #3a87ad;
        }<br/>        .badge-warning {
          -fx-background-color: #f89406;
        }</pre>
<ol start="10">
<li>Let's add <kbd>TextField</kbd> with a <kbd>big-input</kbd> class:</li>
</ol>
<pre>        TextField bigTextField = new TextField();
        bigTextField.getStyleClass().add("big-input");
        gridPane.add(bigTextField, 0, 3, 3, 1);</pre>
<ol start="11">
<li>We define CSS properties so that the content of the text box is large in size and red in color:</li>
</ol>
<pre>        .big-input{
          -fx-text-fill: red;
          -fx-font-size: 18px;
          -fx-font-style: italic;
          -fx-font-weight: bold;
        }</pre>
<ol start="12">
<li>Let's add some radio buttons:</li>
</ol>
<pre>        ToggleGroup group = new ToggleGroup();
        RadioButton bigRadioOne = new RadioButton("First");
        bigRadioOne.getStyleClass().add("big-radio");
        bigRadioOne.setToggleGroup(group);
        bigRadioOne.setSelected(true);
        gridPane.add(bigRadioOne, 0, 4);<br/>        RadioButton bigRadioTwo = new RadioButton("Second");
        bigRadioTwo.setToggleGroup(group);
        bigRadioTwo.getStyleClass().add("big-radio");
        gridPane.add(bigRadioTwo, 1, 4);</pre>
<ol start="13">
<li>We define CSS properties so that the labels of the radio button are large in size and green in color:</li>
</ol>
<pre>        .big-radio{
          -fx-text-fill: green;
          -fx-font-size: 18px;
          -fx-font-weight: bold;
          -fx-background-color: yellow;
          -fx-padding: 5;
        }</pre>
<ol start="14">
<li>Finally, we add <kbd>javafx.scene.layout.GridPane</kbd> to the scene graph and render the scene graph on <kbd>javafx.stage.Stage</kbd>. We also need to associate the <kbd>stylesheet.css</kbd> with the <kbd>Scene</kbd>:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 600, 500);
        scene.getStylesheets().add("com/packt/stylesheet.css");
        stage.setTitle("Age calculator");
        stage.setScene(scene);
        stage.show();</pre>
<ol start="15">
<li>Add a <kbd>main()</kbd> method to launch the GUI:</li>
</ol>
<pre>        public static void main(String[] args) {
          Application.launch(args);
        }</pre>
<p>The complete code can be found at the location, <kbd>chp9/3_css_javafx</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <span><kbd>chp9/3_css_javafx</kbd>. The <kbd>run.bat</kbd> will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>, and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="225" width="212" class="image-border" src="assets/5bf193de-fa8c-41cf-98e4-0d6f9203a1a1.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we make use of class names and their corresponding CSS selectors to associate components with different styling properties. JavaFX supports a subset of CSS properties and there are different properties applicable to different types of JavaFX components. The JavaFX CSS reference guide (<a href="http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html</a>) will help you identify the supported CSS properties.</p>
<p>All the scene graph nodes extend from an abstract class, <kbd>javax.scene.Node</kbd>. This abstract class provides an API, <kbd>getStyleClass()</kbd>, which returns a list of class names (which are plain <kbd>String</kbd>) added to the node or the JavaFX component. As this is a simple list of class names, we can even add more class names to it by using <kbd>getStyleClass().add("new-class-name")</kbd>.</p>
<p>The advantage of using class names is that it allows us to group similar components by a common class name. This technique is widely used in the web development world. Suppose I have a list of buttons on the HTML page and I want a similar action to be performed on the click of each button. To achieve this, I will assign each of the buttons the same class, say, <kbd>my-button</kbd>, and then use <kbd>document.getElementsByClassName('my-button')</kbd> to get an array of these buttons. Now we can loop through the array of buttons obtained and add the required action handlers. </p>
<p>After assigning a class to the component, we need to write the CSS properties for the given class name. These properties then get applied to all the components with the same class name. </p>
<p>Let's pick one of the components from our recipe and see how we went about styling the same. Consider the following component with two classes, <kbd>btn</kbd> and <kbd>btn-primary</kbd>:</p>
<pre>primaryBtn.getStyleClass().add("btn");
primaryBtn.getStyleClass().add("btn-primary");</pre>
<p>We have used the selectors, <kbd>.btn</kbd> and <kbd>.btn-primary</kbd>, and we have grouped all the CSS properties under these selectors, as follows:</p>
<pre>.btn{
  -fx-border-radius: 4px;
  -fx-border: 2px;
  -fx-font-size: 18px;
  -fx-font-weight: normal;
  -fx-text-align: center;
}</pre>
<pre>.btn-primary {
  -fx-text-fill: #fff;
  -fx-background-color: #337ab7;
  -fx-border-color: #2e6da4;
}</pre>
<p>Note that in CSS, we have a <kbd>color</kbd> property, and its equivalent in JavaFX is <kbd>-fx-text-fill</kbd>. The rest of the CSS properties, namely <kbd>border-radius</kbd>, <kbd>border</kbd>, <kbd>font-size</kbd>, <kbd>font-weight</kbd>, <kbd>text-align</kbd>, <kbd>background-color</kbd>, and <kbd>border-color</kbd>, are prefixed with <kbd>-fx-</kbd>. </p>
<p>The important part is how you associate the stylesheet with the Scene component. The <kbd>scene.getStylesheets().add("com/packt/stylesheet.css");</kbd> line of code associates stylesheets with the Scene component. As <kbd>getStylesheets()</kbd> returns a list of strings, we can add multiple strings to it, which means that we can associate multiple stylesheets to a Scene. </p>
<p>The documentation of <kbd>getStylesheets()</kbd> states the following:</p>
<div class="packt_quote">The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL does not have a [scheme:] component, the URL is considered to be the [path] component only. Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to the root of the application's classpath.</div>
<p>In our recipe, we are using the <kbd>path</kbd> component only, and, hence, it looks for the file in the classpath. This is the reason why we have added the stylesheet in the same package as that of the scene. This is an easier way of making it available on the classpath. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a bar chart</h1>
                </header>
            
            <article>
                
<p>Data, when represented in the form of tables, is very hard to understand, but the same, when represented graphically by using charts, is comfortable for the eyes and easy to understand. We have seen a lot of charting libraries for web applications. However, the same support was lacking on the desktop application front. Swing didn't have native support for creating charts and we had to rely on third-party applications such as <strong>JFreeChart</strong> (<a href="http://www.jfree.org/jfreechart/">http://www.jfree.org/jfreechart/</a>). With JavaFX though, we have native support for creating charts, and we are going to show you how to represent the data in the form of charts using the JavaFX chart components. </p>
<p>JavaFX supports the following chart types:</p>
<ul>
<li>Bar chart</li>
<li>Line chart</li>
<li>Pie chart</li>
<li>Scatter chart</li>
<li>Area chart</li>
<li>Bubble chart</li>
</ul>
<p>In the next few recipes, we will cover the construction of each chart type. This segregation of each chart type into a recipe of its own will help us in explaining the recipes in a simpler way and will aid better understanding. </p>
<p>This recipe will be all about bar charts. A sample bar chart looks something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="233" width="326" class="image-border" src="assets/150d29df-9cf5-4710-bf6e-5f12ef97d960.png"/></div>
<p>Bar charts can have a single bar or multiple bars (like the preceding image) for each value on the <em>x</em>-axis. Multiple bars help us in comparing multiple value points for each value on the <em>x</em>-axis. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will make use of a subset of data from the student performance machine learning repository (<a href="https://archive.ics.uci.edu/ml/datasets/Student+Performance">https://archive.ics.uci.edu/ml/datasets/Student+Performance</a>). The dataset consists of student performance in two subjects, Mathematics and Portuguese, along with their social background information, such as their parents' occupation and education, among other information. There are quite a lot of attributes in the dataset, but we will pick the following:</p>
<ul>
<li>Student's gender</li>
<li>Student's age</li>
<li>Father's education</li>
<li>Father's occupation</li>
<li>Mother's education</li>
<li>Mother's occupation</li>
<li>Whether the student has taken extra classes</li>
<li>First term grades</li>
<li>Second term grades</li>
<li>Final grades</li>
</ul>
<p>As we mentioned earlier, there are a lot of attributes captured in the data, but we should be good with a few important attributes that will help us in plotting some useful charts. Due to this, we have extracted the information from the dataset available in the machine learning repository into a separate file, which can be found at the location, <kbd>chp9/4_bar_charts/src/gui/com/packt/students</kbd>, in the code download for the book. An excerpt from the students file is as follows:</p>
<pre>"F";18;4;4;"at_home";"teacher";"no";"5";"6";6
"F";17;1;1;"at_home";"other";"no";"5";"5";6
"F";15;1;1;"at_home";"other";"yes";"7";"8";10
"F";15;4;2;"health";"services";"yes";"15";"14";15
"F";16;3;3;"other";"other";"yes";"6";"10";10
"M";16;4;3;"services";"other";"yes";"15";"15";15</pre>
<p>The entries are semicolon (<kbd>;</kbd>) separated. Each entry has been explained for what it represents. The education information (fields 3 and 4) is a numeric value, where each number represents the level of education, as follows:</p>
<ul>
<li><span>0: None</span></li>
<li>1: Primary education (fourth grade)</li>
<li>2: Fifth to ninth grade</li>
<li>3: Secondary education</li>
<li>4: Higher education</li>
</ul>
<p>We have created a module for processing the student file. The module name is <kbd>student.processor</kbd> and its code can be found at <kbd>chp9/101_student_data_processor</kbd>. So, if you want to change any code there, you can rebuild the JAR by running the <kbd>build-jar.bat</kbd> or <kbd>build-jar.sh</kbd> file. This will create a modular JAR, <kbd>student.processor.jar</kbd>, in the <kbd>mlib</kbd> directory. Then, you have to replace this modular JAR with the one present in the <kbd>mlib</kbd> directory of this recipe, that is, <kbd>chp9/4_bar_charts/mlib</kbd>.</p>
<div class="packt_tip">We recommend you to build the student.processor modular jar from the source available in <kbd>chp9/101_student_data_processor</kbd>. We have provided <kbd>build-jar.bat</kbd> and <kbd>build-jar.sh</kbd> scripts to help you with building the jar. You just have to run the script relevant to your platform. And then copy the jar build in <kbd>101_student_data_processor/mlib</kbd> to <kbd>4_bar_charts/mlib</kbd>.</div>
<p>This way, we can reuse this module across all the recipes on charts. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, create <kbd>GridPane</kbd> and configure it to place the charts that we will be creating:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="2">
<li>Use the <kbd>StudentDataProcessor</kbd> class from the <kbd>student.processor</kbd> module to parse the student file and load the data into <kbd>List</kbd> of <kbd>Student</kbd>:</li>
</ol>
<pre>        StudentDataProcessor sdp = new StudentDataProcessor();
        List&lt;Student&gt; students = sdp.loadStudent();</pre>
<ol start="3">
<li>The raw data, that is, the list of <kbd>Student</kbd> objects is not useful for plotting a chart, so we need to process the students' grades by grouping the students according to their mothers' and fathers' education and computing the average of those students' grades (all three terms). For this, we will write a simple method, which accepts <kbd>List&lt;Student&gt;</kbd>, a grouping function, that is, the value on which the students need to be grouped, and a mapping function, that is, the value that has to be used to compute the average:</li>
</ol>
<pre>        private Map&lt;ParentEducation, IntSummaryStatistics&gt; summarize(
          List&lt;Student&gt; students,
          Function&lt;Student, ParentEducation&gt; classifier,
          ToIntFunction&lt;Student&gt; mapper
        ){
          Map&lt;ParentEducation, IntSummaryStatistics&gt; statistics =
            students.stream().collect(
              Collectors.groupingBy(
                classifier,
                Collectors.summarizingInt(mapper)
              )
          );
          return statistics;
        }</pre>
<p style="padding-left: 60px">The preceding method uses the new Stream-based APIs. These APIs are so powerful that they group the students by using <kbd>Collectors.groupingBy()</kbd> and then compute the statistics of their grades by using <kbd>Collectors.summarizingInt()</kbd>. </p>
<ol start="4">
<li>The data for the bar chart is provided as an instance of <kbd>XYChart.Series</kbd>. Each series results in one <kbd>Y</kbd> value for a given <kbd>X</kbd> value, which is one bar for a given <kbd>X</kbd> value. We will have multiple series, one for each term, that is, first term grades, second term grades, and the final grades. Let's create a method that takes in the statistics of each term grades and the <kbd>seriesName</kbd> and returns a <kbd>series</kbd> object:</li>
</ol>
<pre>        private XYChart.Series&lt;String,Number&gt; getSeries(
            String seriesName,
            Map&lt;ParentEducation, IntSummaryStatistics&gt; statistics
        ){
          XYChart.Series&lt;String,Number&gt; series = new XYChart.Series&lt;&gt;();
          series.setName(seriesName);
          statistics.forEach((k, v) -&gt; {
            series.getData().add(
              new XYChart.Data&lt;String, Number&gt;(
                k.toString(),v.getAverage()
              )
            );
          });
          return series;
        }</pre>
<ol start="5">
<li>We will create two bar charts: one for the average grade by mother's education and the other for the average grade by father's education. For this, we will create a method that will take <kbd>List&lt;Student&gt;</kbd> and a classifier, that is, a function that will return the value to be used to group the students. This method will do the necessary computations and return us a <kbd>BarChart</kbd> object:</li>
</ol>
<pre>        private BarChart&lt;String, Number&gt; getAvgGradeByEducationBarChart(
          List&lt;Student&gt; students,
          Function&lt;Student, ParentEducation&gt; classifier
        ){
          final CategoryAxis xAxis = new CategoryAxis();
          final NumberAxis yAxis = new NumberAxis();
          final BarChart&lt;String,Number&gt; bc = 
                new BarChart&lt;&gt;(xAxis,yAxis);
          xAxis.setLabel("Education");
          yAxis.setLabel("Grade");
          bc.getData().add(getSeries(
            "G1",
            summarize(students, classifier, Student::getFirstTermGrade)
          ));
          bc.getData().add(getSeries(
            "G2",
            summarize(students, classifier, Student::getSecondTermGrade)
          ));
          bc.getData().add(getSeries(
            "Final",
            summarize(students, classifier, Student::getFinalGrade)
          ));
          return bc;
        }</pre>
<ol start="6">
<li>Create <kbd>BarChart</kbd> for the average grades by mother's education, and add it to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        BarChart&lt;String, Number&gt; avgGradeByMotherEdu = 
                        getAvgGradeByEducationBarChart(
          students, 
          Student::getMotherEducation
        );
        avgGradeByMotherEdu.setTitle("Average grade by Mother's<br/>                                      Education");
        gridPane.add(avgGradeByMotherEdu, 1,1);</pre>
<ol start="7">
<li>Create <kbd>BarChart</kbd> for average grades by father's education and add it to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        BarChart&lt;String, Number&gt; avgGradeByFatherEdu = 
                      getAvgGradeByEducationBarChart(
          students, 
          Student::getFatherEducation
        );
        avgGradeByFatherEdu.setTitle("Average grade by Father's <br/>                                      Education");
        gridPane.add(avgGradeByFatherEdu, 2,1);</pre>
<ol start="8">
<li>Create a scene graph using <kbd>gridPane</kbd> and set it to <kbd>Stage</kbd>:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 800, 600);
        stage.setTitle("Bar Charts");
        stage.setScene(scene);
        stage.show();</pre>
<p>The complete code can be found at <kbd>chp9/4_bar_charts</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <span><kbd>chp9/4_bar_charts</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>, and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="296" width="519" class="image-border" src="assets/3135a8b1-82ec-4656-9fb4-185d09904c91.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's first see what it takes to create <kbd>BarChart</kbd>. <kbd>BarChart</kbd> is a two axes-based chart, where the data is plotted on two axes, namely the <em>x</em> axis (horizontal axis) and the <em>y</em> axis (vertical axis). The other two axes-based charts are area chart, bubble chart, and line chart.</p>
<p>In JavaFX, there are two types of axes supported:</p>
<ul>
<li><kbd>javafx.scene.chart.CategoryAxis</kbd>: This supports string values on the axes</li>
<li><kbd>javafx.scene.chart.NumberAxis</kbd>: This supports numeric values on the axes</li>
</ul>
<p>In our recipe, we created <kbd>BarChart</kbd> with <kbd>CategoryAxis</kbd> as the <em>x</em> axis, where we plot the education, and <kbd>NumberAxis</kbd> as the <em>y</em> axis, where we plot the grade, as follows:</p>
<pre>final CategoryAxis xAxis = new CategoryAxis();
final NumberAxis yAxis = new NumberAxis();
final BarChart&lt;String,Number&gt; bc = new BarChart&lt;&gt;(xAxis,yAxis);
xAxis.setLabel("Education");
yAxis.setLabel("Grade");</pre>
<p>In the next few paragraphs, we show you how the plotting of <kbd>BarChart</kbd> works.</p>
<p>The data to be plotted on <kbd>BarChart</kbd> should be a pair of values, where each pair represents <em>(x, y)</em> values, that is, a point on the <em>x</em> axis and a point on the <em>y</em> axis. This pair of values is represented by <kbd>javafx.scene.chart.XYChart.Data</kbd>. <kbd>Data</kbd> is a nested class within <kbd>XYChart</kbd>, which represents a single data item for a two axes-based chart. An <kbd>XYChart.Data</kbd> object can be created quite simply, as follows:</p>
<pre>XYChart.Data item = new XYChart.Data("Cat1", "12");</pre>
<p>This is just one-data item. A chart can have multiple data items, that is, a series of data items. To represent a series of data items, JavaFX provides a class called <kbd>javafx.scene.chart.XYChart.Series</kbd>. This <kbd>XYChart.Series</kbd> object is a named series of <kbd>XYChart.Data</kbd> items. Let's create a simple series, as follows:</p>
<pre>XYChart.Series&lt;String,Number&gt; series = new XYChart.Series&lt;&gt;();
series.setName("My series");
series.getData().add(
  new XYChart.Data&lt;String, Number&gt;("Cat1", 12)
);
series.getData().add(
  new XYChart.Data&lt;String, Number&gt;("Cat2", 3)
);
series.getData().add(
  new XYChart.Data&lt;String, Number&gt;("Cat3", 16)
);</pre>
<p><kbd>BarChart</kbd> can have multiple series of data items. If we provide it with multiple series, then there will be multiple bars for each data point on the <em>x</em> axis. For our demonstration of how this works, we will stick with one series. But the <kbd>BarChart</kbd> class in our recipe uses multiple series. Let's add the series to the <kbd>BarChart</kbd> and then render it onto the screen:</p>
<pre>bc.getData().add(series);
Scene scene = new Scene(bc, 800, 600);
<span>stage.setTitle("Bar Charts");
</span><span>stage.setScene(scene);
</span><span>stage.show();</span></pre>
<p>This results in the following chart:</p>
<div class="CDPAlignCenter CDPAlign"><img height="331" width="362" class="image-border" src="assets/49e71ed2-c2fa-4572-b24d-fdc56cd1b795.png"/></div>
<p>The other interesting part of this recipe is the grouping of students based on the education of mother and father and then computing the average of their first term, second term, and final grades. The line of code that does the grouping and average computation is as follows:</p>
<pre>Map&lt;ParentEducation, IntSummaryStatistics&gt; statistics =
        students.stream().collect(
  Collectors.groupingBy(
    classifier,
    Collectors.summarizingInt(mapper)
  )
);</pre>
<p>The preceding line of code does the following:</p>
<ul>
<li>It creates a stream from <kbd>List&lt;Student&gt;</kbd>.</li>
<li>It reduces this stream to the required grouping by using the <kbd>collect()</kbd> method.</li>
<li>One of the overloaded versions of <kbd>collect()</kbd> takes two parameters. The first one is the function that returns the value on which the students need to be grouped. The second parameter is an additional mapping function, which maps the grouped student object into the required format. In our case, the required format is to get <span><kbd>IntSummaryStatistics</kbd> for the group of students on any of their grade values. </span></li>
</ul>
<p>The preceding two pieces (setting up the data for a bar chart and creating the required objects to populate a <kbd>BarChart</kbd> instance) are important parts of the recipe; understanding them will give you a clearer picture of the recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes of this chapter:</p>
<ul>
<li>Creating an area chart</li>
<li>Creating a bubble chart</li>
<li>Creating a line chart</li>
<li>Creating a scatter chart</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a pie chart</h1>
                </header>
            
            <article>
                
<p>Pie charts, as the name suggests, are circular charts with slices (either joined or separated out), where each slice and its size indicates the magnitude of the item that the slice represents. Pie charts are used to compare the magnitudes of different classes, categories, products, and the like. This is how a sample pie chart looks:</p>
<div class="CDPAlignCenter CDPAlign"><img height="251" width="230" class="image-border" src="assets/89fcaedc-0219-43c3-ab55-5da501bac4bf.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will make use of the same student data (taken from the machine learning repository and processed at our end) that we had discussed in the recipe, <em>Creating a bar chart</em>. For this, we have created a module, <kbd>student.processor</kbd>, which will read the student data and provide us with a list of <kbd>Student</kbd> objects. The source code for the module can be found at <kbd>chp9/101_student_data_processor</kbd>. We have provided the modular jar for the <kbd>student.processor</kbd> module at <kbd>chp9/5_pie_charts/mlib</kbd> of this recipe's code. </p>
<div class="packt_tip">We recommend you to build the <kbd>student.processor</kbd> modular jar from the source available in <kbd>chp9/101_student_data_processor</kbd>. We have provided <kbd>build-jar.bat</kbd> and <kbd>build-jar.sh</kbd> scripts to help you with building the jar. You just have to run the script relevant to your platform. And then copy the jar build in <kbd>101_student_data_processor/mlib</kbd> to <kbd>4_bar_charts/mlib</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's first create and configure <kbd>GridPane</kbd> to hold our pie charts:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="2">
<li>Create an instance of <kbd>StudentDataProcessor</kbd> (which comes from the <kbd>student.processor</kbd> module) and use it to load <kbd>List</kbd> of <kbd>Student</kbd>:</li>
</ol>
<pre>        StudentDataProcessor sdp = new StudentDataProcessor();
        List&lt;Student&gt; students = sdp.loadStudent();</pre>
<ol start="3">
<li>Now, we need to get the count of students by their mother's and father's profession. We will write a method, which will take a list of students and a classifier, that is, the function that returns the value on which the students need to be grouped. The method returns an instance of <kbd>PieChart</kbd>:</li>
</ol>
<pre>        private PieChart getStudentCountByOccupation(
            List&lt;Student&gt; students,
            Function&lt;Student, String&gt; classifier
        ){
          Map&lt;String, Long&gt; occupationBreakUp = 
                  students.stream().collect(
            Collectors.groupingBy(
              classifier,
              Collectors.counting()
            )
          );
          List&lt;PieChart.Data&gt; pieChartData = new ArrayList&lt;&gt;();
          occupationBreakUp.forEach((k, v) -&gt; {
            pieChartData.add(new PieChart.Data(k.toString(), v));
          });
          PieChart chart = new PieChart(
            FXCollections.observableList(pieChartData)
          );
          return chart;
        }</pre>
<ol start="4">
<li>We will invoke the preceding method twice - one with the mother's occupation as the classifier and the other with the father's occupation as the classifier. We then add the returned <kbd>PieChart</kbd> instance to <kbd>gridPane</kbd>. This should be done from within the <kbd>start()</kbd> method:</li>
</ol>
<pre>        PieChart motherOccupationBreakUp = getStudentCountByOccupation(
          students, Student::getMotherJob
        );
        motherOccupationBreakUp.setTitle("Mother's Occupation");
        gridPane.add(motherOccupationBreakUp, 1,1);

        PieChart fatherOccupationBreakUp = getStudentCountByOccupation(
          students, Student::getFatherJob
        );
        fatherOccupationBreakUp.setTitle("Father's Occupation");
        gridPane.add(fatherOccupationBreakUp, 2,1);</pre>
<ol start="5">
<li>Next is to create the scene graph using <kbd>gridPane</kbd> and add it to <kbd>Stage</kbd>:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 800, 600);
        stage.setTitle("Pie Charts");
        stage.setScene(scene);
        stage.show();</pre>
<ol start="6">
<li>The UI can be launched from the main method by invoking the <kbd>Application.launch</kbd> method:</li>
</ol>
<pre>        public static void main(String[] args) {
          Application.launch(args);
        }</pre>
<p>The complete code can be found at <kbd>chp9/5_pie_charts</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <span><kbd>chp9/5_pie_charts</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd> and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="321" width="576" class="image-border" src="assets/95ecc014-5354-4387-9329-8996fe42a38b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The most important method that does all the work in this recipe is the <span><kbd>getStudentCountByOccupation()</kbd>. It does the following:</span></p>
<ol>
<li>Group the number of students by profession. This can be done in a single line of code using the power of the new streaming APIs (added as part of Java 8):</li>
</ol>
<pre>        Map&lt;String, Long&gt; occupationBreakUp = 
                    students.stream().collect(
          Collectors.groupingBy(
            classifier,
            Collectors.counting()
          )
        );</pre>
<ol start="2">
<li>Build data required for <kbd>PieChart</kbd>. The <kbd>PieChart</kbd> instance's data is <kbd>ObservableList</kbd> of <kbd>PieChart.Data</kbd>. We first make use of <kbd>Map</kbd> obtained in the preceding step to create <kbd>ArrayList</kbd> of <kbd>PieChart.Data</kbd>. Then, we use the <kbd>FXCollections.observableList()</kbd> API to obtain <kbd>ObservableList&lt;PieChart.Data&gt;</kbd> from <kbd>List&lt;PieChart.Data&gt;</kbd>:</li>
</ol>
<pre>        List&lt;PieChart.Data&gt; pieChartData = new ArrayList&lt;&gt;();
        occupationBreakUp.forEach((k, v) -&gt; {
          pieChartData.add(new PieChart.Data(k.toString(), v));
        });
        PieChart chart = new PieChart(
          FXCollections.observableList(pieChartData)
        );</pre>
<p>The other important thing in the recipe is the classifiers we use: <kbd>Student::getMotherJob</kbd> and <kbd>Student::getFatherJob</kbd>. These are the two method references that invoke the <kbd>getMotherJob</kbd> and <kbd>getFatherJob</kbd> methods on the different instances of <kbd>Student</kbd> in the list of <kbd>Student</kbd>.</p>
<p>Once we get the <kbd>PieChart</kbd> instances, we add them to <kbd>GridPane</kbd> and then construct the scene graph using <kbd>GridPane</kbd>. The scene graph has to be associated with <kbd>Stage</kbd> for it to be rendered on the screen. </p>
<p>The main method launches the UI by invoking the <kbd>Application.launch(args);</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a line chart</h1>
                </header>
            
            <article>
                
<p><span>A line chart is a two-axis chart similar to the bar chart; instead of having bars, the data is plotted on the X-Y plane using points, and the points are joined together to depict the change of data. Line charts are used to get an understanding of how a certain variable is performing and when combined with multiple variables, that is, by using multiple series, we can see how each variable is performing when compared to other variables. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will make use of crude oil and brent oil price variation over the last three years. This data can be found at the locations, <kbd>chp9/6_line_charts/src/gui/com/packt/crude-oil</kbd> and <kbd>chp9/6_line_charts/src/gui/com/packt/brent-oil</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We will create a <strong>Plain Old Java Object</strong> (<strong>POJO</strong>) to represent the oil price in a given month and year:</li>
</ol>
<p> </p>
<pre>        public class OilPrice{
          public String period;
          public Double value;
        }</pre>
<ol start="2">
<li>Next is to write a <kbd>getOilData(String oilType)</kbd> method, which will read the data from the given file and construct <kbd>List&lt;OilPrice&gt;</kbd>:</li>
</ol>
<p> </p>
<pre>        private List&lt;OilPrice&gt; getOilData(String oilType)
                throws IOException{
          Scanner reader = new Scanner(getClass()
                      .getModule()
                      .getResourceAsStream("com/packt/"+oilType)
          );
          List&lt;OilPrice&gt; data = new LinkedList&lt;&gt;();
          while(reader.hasNext()){
            String line = reader.nextLine();
            String[] elements = line.split("t");
            OilPrice op = new OilPrice();
            op.period = elements[0];
            op.value = Double.parseDouble(elements[1]);
            data.add(op);
          }
          Collections.reverse(data);
          return data;
        }</pre>
<ol start="3">
<li>Next, we will write a method, which will take the name of the series and the data to be populated in the series:</li>
</ol>
<p> </p>
<pre>        private XYChart.Series&lt;String,Number&gt; getSeries(
          String seriesName, List&lt;OilPrice&gt; data
        ) throws IOException{
          XYChart.Series&lt;String,Number&gt; series = new XYChart.Series&lt;&gt;();
          series.setName(seriesName);
          data.forEach(d -&gt; {
            series.getData().add(new XYChart.Data&lt;String, Number&gt;(
              d.period, d.value
            ));
          });
          return series;
        }</pre>
<ol start="4">
<li>Create an empty <kbd>start(Stage stage)</kbd>  method, which we will override in the next few steps:</li>
</ol>
<pre>        @Override
        public void start(Stage stage) throws IOException {
          //code to be added here from the next few steps
        }</pre>
<ol start="5">
<li>Create and configure <kbd>GridPane</kbd>:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="6">
<li>Create <kbd>CategoryAxis</kbd> as the <em>x</em> axis and <kbd>NumberAxis</kbd> as the <em>y</em> axis, and label them accordingly:</li>
</ol>
<pre>        final CategoryAxis xAxis = new CategoryAxis();
        final NumberAxis yAxis = new NumberAxis();
        xAxis.setLabel("Month");
        yAxis.setLabel("Price");</pre>
<ol start="7">
<li>Initialize a <kbd>LineChart</kbd> instance with the axes created in the preceding step:</li>
</ol>
<pre>        final LineChart&lt;String,Number&gt; lineChart = 
        new LineChart&lt;&gt;(xAxis,yAxis);</pre>
<ol start="8">
<li>Load the crude oil data into <kbd>List&lt;OilPrice&gt;</kbd>:</li>
</ol>
<pre>        List&lt;OilPrice&gt; crudeOil = getOilData("crude-oil");</pre>
<ol start="9">
<li>Load Brent oil data into <kbd>List&lt;OilPrice&gt;</kbd>:</li>
</ol>
<pre>        List&lt;OilPrice&gt; brentOil = getOilData("brent-oil");</pre>
<ol start="10">
<li>Create a series, each for crude oil and Brent oil, and add it to <kbd>lineChart</kbd>:</li>
</ol>
<pre>        lineChart.getData().add(getSeries("Crude Oil", crudeOil));
        lineChart.getData().add(getSeries("Brent Oil", brentOil));</pre>
<ol start="11">
<li>Add <kbd>LineChart</kbd> to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        gridPane.add(lineChart, 1, 1);</pre>
<ol start="12">
<li>Create a scene graph with <kbd>GridPane</kbd> as the root and set the size as required:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 800, 600);</pre>
<ol start="13">
<li>Set the properties for the <kbd>Stage</kbd> object passed into the <kbd>start(Stage stage)</kbd> method and associate the scene graph created in the preceding step:</li>
</ol>
<pre>        stage.setTitle("Line Charts");
        stage.setScene(scene);
        stage.show();</pre>
<ol start="14">
<li>Launch the UI by invoking the <kbd>javafx.application.Application.launch()</kbd> method from the <kbd>main</kbd> method:</li>
</ol>
<pre>        public static void main(String[] args) {
          Application.launch(args);
        }</pre>
<p>The complete code can be found at <kbd>chp9/6_line_charts</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <span><kbd>chp9/6_line_charts</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>, and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="347" width="419" class="image-border" src="assets/3822235a-49d3-44e3-aaa6-9ea275983fce.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Like any other two-axis chart, the line chart has the <em>x</em> axis and <em>y</em> axis. These axes can be of string types or numeric. String values are represented by <kbd>javafx.scene.chart.CategoryAxis</kbd> and numeric values by <kbd><span>javafx.scene.chart.</span>NumberAxis</kbd>. </p>
<p>A new <kbd>LineChart</kbd> is created by providing the <em>x</em> axis and <em>y</em> axis objects as parameters to its constructor:</p>
<pre>final CategoryAxis xAxis = new CategoryAxis();
final NumberAxis yAxis = new NumberAxis();
xAxis.setLabel("Category");
yAxis.setLabel("Price");
final LineChart&lt;String,Number&gt; lineChart = new LineChart&lt;&gt;(xAxis,yAxis);</pre>
<p>Data to <kbd>LineChart</kbd> is provided in the form of an instance of <kbd>XYChart.Series</kbd>. So, if <kbd>LineChart</kbd> uses <kbd>String</kbd> on the <em>x</em> axis and <kbd>Number</kbd> on the <em>y</em> axis, then we create an instance of <kbd>XYChart.Series&lt;String, Number&gt;</kbd>, as follows:</p>
<pre>XYChart.Series&lt;String,Number&gt; series =  new XYChart.Series&lt;&gt;();
series.setName("Series 1");</pre>
<p><kbd>XYChart.Series</kbd> contains data of the <kbd>XYChart.Data</kbd> type, so <kbd>XYChart.Series&lt;String, Number&gt;</kbd> will contain data of the <kbd>XYChart.Data&lt;String, Number&gt;</kbd> type. Let's add some data to the series created in the preceding step:</p>
<pre>series.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 1", 10));
<span>series.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 2", 20));
</span><span>series.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 3", 30));
</span><span>series.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 4", 40));</span></pre>
<p>We then add the series to the <kbd>lineChart</kbd>'s data:</p>
<pre>lineChart.getData().add(series);</pre>
<p>We can create one more series on similar lines:</p>
<pre>XYChart.Series&lt;String, Number&gt; series2 = new XYChart.Series&lt;&gt;();
series2.setName("Series 2");
<span>series2</span>.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 1", 40));
<span>series2.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 2", 30));
</span><span>series2.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 3", 20));
</span><span>series2.getData().add(new XYChart.Data&lt;String, Number&gt;("Cat 4", 10));
</span><span>lineChart.getData().add(series2);</span></pre>
<p>The chart created looks like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="313" width="349" class="image-border" src="assets/03f0f574-091f-43a4-8ccf-a54f8c9cc620.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes of this chapter:</p>
<ul>
<li>Creating a bar chart</li>
<li>Creating an area chart</li>
<li>Creating a bubble chart</li>
<li>Creating a scatter chart</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an area chart</h1>
                </header>
            
            <article>
                
<p>An area chart is similar to a line chart, the only difference being the area between the plotted line and the axis is colored, with different series being colored by different colors. In this recipe, we will look at creating an area chart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will make use of the crude oil and Brent oil price variation data from the previous recipe (<em>Creating a line chart</em>) to plot an area chart. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We will create a POJO to represent the oil price in a given month and year:</li>
</ol>
<pre>        public class OilPrice{
          public String period;
          public Double value;
        }</pre>
<ol start="2">
<li>Next, we'll write a method, <kbd>getOilData(String oilType)</kbd>, which will read the data from the given file and construct <kbd>List&lt;OilPrice&gt;</kbd>:</li>
</ol>
<pre>        private List&lt;OilPrice&gt; getOilData(String oilType)
                  throws IOException{
          Scanner reader = new Scanner(getClass()
                           .getModule()
                           .getResourceAsStream("com/packt/"+oilType)
          );
          List&lt;OilPrice&gt; data = new LinkedList&lt;&gt;();
          while(reader.hasNext()){
            String line = reader.nextLine();
            String[] elements = line.split("t");
            OilPrice op = new OilPrice();
            op.period = elements[0];
            op.value = Double.parseDouble(elements[1]);
            data.add(op);
          }
          Collections.reverse(data);
          return data;
        }</pre>
<ol start="3">
<li>Next, we will write a method that will take the name of the series and the data to be populated in the series:</li>
</ol>
<pre>        private XYChart.Series&lt;String,Number&gt; getSeries(
          String seriesName, List&lt;OilPrice&gt; data
        ) throws IOException{
          XYChart.Series&lt;String,Number&gt; series = new XYChart.Series&lt;&gt;();
          series.setName(seriesName);
          data.forEach(d -&gt; {
            series.getData().add(new XYChart.Data&lt;String, Number&gt;(
              d.period, d.value
            ));
          });
          return series;
        }</pre>
<ol start="4">
<li>Create an empty <kbd>start(Stage stage)</kbd>  method, which we will override in the next few steps:</li>
</ol>
<pre>        @Override
        public void start(Stage stage) throws IOException {
          //code to be added here from the next few steps
        }</pre>
<ol start="5">
<li>Create and configure <kbd>GridPane</kbd>:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="6">
<li>Create <kbd>CategoryAxis</kbd> as the <em>x</em> axis and <kbd>NumberAxis</kbd> as the <em>y</em> axis and label them accordingly:</li>
</ol>
<pre>        final CategoryAxis xAxis = new CategoryAxis();
        final NumberAxis yAxis = new NumberAxis();
        xAxis.setLabel("Month");
        yAxis.setLabel("Price");</pre>
<ol start="7">
<li>Initialize <kbd>AreaChart</kbd> with the axes created in the preceding steps:</li>
</ol>
<pre>        final AreaChart&lt;String,Number&gt; areaChart = 
                        new AreaChart&lt;&gt;(xAxis,yAxis);</pre>
<ol start="8">
<li>Load crude oil data into <kbd>List&lt;OilPrice&gt;</kbd>:</li>
</ol>
<pre>        List&lt;OilPrice&gt; crudeOil = getOilData("crude-oil");</pre>
<ol start="9">
<li>Load Brent oil data into <kbd>List&lt;OilPrice&gt;</kbd>:</li>
</ol>
<pre>        List&lt;OilPrice&gt; brentOil = getOilData("brent-oil");</pre>
<ol start="10">
<li>Create a series each for crude oil and brent oil, and add it to <kbd>AreaChart</kbd>:</li>
</ol>
<pre>        areaChart.getData().add(getSeries("Crude Oil", crudeOil));
        areaChart.getData().add(getSeries("Brent Oil", brentOil));</pre>
<ol start="11">
<li>Add <kbd>AreaChart</kbd> to <kbd>GridPane</kbd>:</li>
</ol>
<pre>        gridPane.add(areaChart, 1, 1);</pre>
<ol start="12">
<li>Create a scene graph with <kbd>GridPane</kbd> as the root and set the size as required:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 800, 600);</pre>
<ol start="13">
<li>Set the properties for the <kbd>Stage</kbd> object passed into the <kbd>start(Stage stage)</kbd> method and associate the scene graph created in the preceding step:</li>
</ol>
<pre>        stage.setTitle("Area Charts");
        stage.setScene(scene);
        stage.show();</pre>
<ol start="14">
<li>Launch the UI by invoking the <kbd>javafx.application.Application.launch()</kbd> method from the <kbd>main</kbd> method:</li>
</ol>
<pre>        public static void main(String[] args) {
          Application.launch(args);
        }</pre>
<p>The complete code can be found at <kbd>chp9/7_area_charts</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under<kbd> </kbd><span><kbd>chp9/7_area_charts</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd> and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="275" width="357" class="image-border" src="assets/60a95f3c-aaa8-42ff-a4b4-0e55264b4547.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Area charts are similar to line charts so we would highly recommend reading the recipe, <em>Creating a line chart</em>. An area chart is made up of two axes with data plotted on the <em>x</em> and <em>y</em> axis. The data to be plotted is provided as an instance of <kbd>XYChart.Series</kbd>. The axis of the chart can be either <kbd>javafx.scene.chart.CategoryAxis</kbd> or <kbd>javafx.scene.chart.NumberAxis</kbd>. </p>
<p><kbd>XYChart.Series</kbd> contains data encapsulated in instances of <kbd>XYChart.Data</kbd>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes of this chapter:</p>
<ul>
<li>Creating a bar chart</li>
<li>Creating an area chart</li>
<li>Creating a bubble chart</li>
<li>Creating a pie chart</li>
<li>Creating a scatter chart</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a bubble chart</h1>
                </header>
            
            <article>
                
<p>A Bubble chart is also a two-axis chart with a third dimension to the data, that is, the radius of the bubble. Bubble chart supports only <kbd>NumberAxis</kbd>, so we can have only numbers on both <em>x</em> and <em>y</em> axes. </p>
<p>In this recipe, we will create a simple bubble chart. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We have provided a sample store visit data at different times during the day along with the sales information during that hour. This sample data file can be found at the location, <kbd>chp9/8_bubble_charts/src/gui/com/packt/store</kbd>. Each line in the data file consists of three parts:</p>
<ol>
<li>The hour of the day</li>
<li>The number of visits </li>
<li>Total sales</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's create a method to read the data from the file into <kbd>StoreVisit</kbd> objects:</li>
</ol>
<pre>        private List&lt;StoreVisit&gt; getData()<span> throws IOException{
</span>          Scanner reader = new Scanner(getClass()
                        .getModule()
                        .getResourceAsStream("com/packt/store")
          );
          List&lt;StoreVisit&gt; data = new LinkedList&lt;&gt;();
          while(reader.hasNext()){
            String line = reader.nextLine();
            String[] elements = line.split(",");
            StoreVisit sv = new StoreVisit(elements);
            data.add(sv);
          }
          return data;
        }</pre>
<ol start="2">
<li>We also need the maximum sale value during any part of the day. So, let's create a method, which accepts the <kbd>List&lt;StoreVisit&gt;</kbd> and returns the maximum sale. We will use this maximum sale to determine the radius of the bubble in the chart:</li>
</ol>
<pre>        private Integer getMaxSale(List&lt;StoreVisit&gt; data){
          return data.stream()
                     .mapToInt(StoreVisit::getSales)
                     .max()
                     .getAsInt();
        }</pre>
<ol start="3">
<li>Create and configure a <kbd>GridPane</kbd> object where we will place the chart:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="4">
<li>Create two <kbd>NumberAxis</kbd> objects for <em>x</em> and <em>y</em> axis and give them corresponding names:</li>
</ol>
<pre>        final NumberAxis xAxis = new NumberAxis();
        final NumberAxis yAxis = new NumberAxis();
        xAxis.setLabel("Hour");
        yAxis.setLabel("Visits");</pre>
<ol start="5">
<li>Create an instance of <kbd>BubbleChart</kbd> with these two axes:</li>
</ol>
<pre>        final BubbleChart&lt;Number,Number&gt; bubbleChart = 
                          new BubbleChart&lt;&gt;(xAxis,yAxis);</pre>
<ol start="6">
<li>Create an <kbd>XYChart.Series</kbd> from the store visit data, read from the file:</li>
</ol>
<pre>        List&lt;StoreVisit&gt; data = getData();
        Integer maxSale = getMaxSale(data);
        XYChart.Series&lt;Number,Number&gt; series = 
                       new XYChart.Series&lt;&gt;();
        series.setName("Store Visits");
        data.forEach(sv -&gt; {
          series.getData().add(
            new XYChart.Data&lt;Number, Number&gt;(
              sv.hour, sv.visits, (sv.sales/(maxSale * 1d)) * 2
            )
          );
        });</pre>
<ol start="7">
<li>Populate <kbd>bubbleChart</kbd> with the series created in the preceding step and add it to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        bubbleChart.getData().add(series);
        gridPane.add(bubbleChart, 1, 1);</pre>
<ol start="8">
<li>Render the chart by creating a scene graph with <kbd>gridPane</kbd> and set it to the <kbd>Stage</kbd> object passed into the <kbd>start(Stage stage)</kbd> method:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 600, 400);
        stage.setTitle("Bubble Charts");
        stage.setScene(scene);
        stage.show();</pre>
<p>The complete code can be found at <kbd>chp9/8_bubble_charts</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <span><kbd>chp9/8_bubble_charts</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd> and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="276" width="398" class="image-border" src="assets/6586b333-8141-4ed5-b65c-5c90a79dc4e0.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Bubble chart is another two-axis chart just like area chart, line chart, and bar chart. The only difference being that the <kbd>XYChart.Data</kbd> object takes in the third argument in its constructor, which determines the radius of the bubble. The general idea is that the greater the bubble radius, the greater is the impact/contribution of that data point. So, in our example, we have used the sales value and the maximum sales value to determine the radius by using the formula, <kbd>(sales/(maxSale  * 1d)) * 2</kbd>, which means we are sizing the sales to the scale of 2.</p>
<p>The rest of the details are exactly similar to the other two-axis charts we have seen, namely bar charts, line charts, and area charts. Therefore, we are not going into its details and we would highly recommend you visit those recipes. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes of this chapter:</p>
<ul>
<li>Creating a bar chart</li>
<li>Creating an area chart</li>
<li>Creating a line chart</li>
<li>Creating a scatter chart</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a scatter chart</h1>
                </header>
            
            <article>
                
<p>A scatter chart is another type of two-axis charts, where the data is presented as a set of points. Each series in the chart is presented by a different shape. These points are not joined, unlike line charts. Such charts help us in identifying where the bulk of the data lies by looking at the density of the data points. In this recipe, we will look at creating a simple scatter chart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>I have collected the statistics from the one-day international cricket match between India and New Zealand held on October 26, 2016 (<a href="http://www.espncricinfo.com/series/1030193/scorecard/1030221">http://www.espncricinfo.com/series/1030193/scorecard/1030221</a>). The data collected is the score and overs in progress during the fall of wickets during both New Zealand and India's innings. This data can be found in the file, <kbd>chp9/9_scatter_charts/src/gui/com/packt/wickets</kbd>. The data looks like the following:</p>
<pre>NZ,0.2,0
NZ,20.3,120
NZ,30.6,158
NZ,40.5,204</pre>
<p>In the preceding sample, each line of data has three parts:</p>
<ul>
<li>The team</li>
<li>The over in progress during the fall of the wicket</li>
<li>Team score during the fall of the wicket</li>
</ul>
<p>We will plot this data on a scatter chart and get an idea as to how the wickets fell during each team's innings.</p>
<p>For those who are wondering what this game called cricket is all about, we would suggest you spend a few minutes reading about it here: <a href="https://en.wikipedia.org/wiki/Cricket">https://en.wikipedia.org/wiki/Cricket</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's first create a method to read the fall of wickets data from the file:</li>
</ol>
<pre>        private Map&lt;String, List&lt;FallOfWicket&gt;&gt; getFallOfWickets() 
                throws IOException{
          Scanner reader = new Scanner(getClass()
                           .getModule()
                           .getResourceAsStream("com/packt/wickets")
          );
          Map&lt;String, List&lt;FallOfWicket&gt;&gt; data = new HashMap&lt;&gt;();
          while(reader.hasNext()){
            String line = reader.nextLine();
            String[] elements = line.split(",");
            String country = elements[0];
            if ( !data.containsKey(country)){
              data.put(country, new ArrayList&lt;FallOfWicket&gt;());
            }
            data.get(country).add(new FallOfWicket(elements));
          }
          return data;
        }</pre>
<ol start="2">
<li>A scatter chart is also an X-Y chart; we will use <kbd>XYChart.Series</kbd> to create data for the chart. Let's write a method to create an instance of <kbd>XYChart.Series&lt;Number,Number&gt;</kbd> using the data parsed from the file:</li>
</ol>
<pre>        private XYChart.Series&lt;Number, Number&gt; getSeries(
          List&lt;FallOfWicket&gt; data, String seriesName
        ){
          XYChart.Series&lt;Number,Number&gt; series = new XYChart.Series&lt;&gt;();
          series.setName(seriesName);
          data.forEach(s -&gt; {
            series.getData().add(
              new XYChart.Data&lt;Number, Number&gt;(s.over, s.score)
            );
          });
          return series;
        }</pre>
<ol start="3">
<li>Let's now build the UI (all this code goes within the <kbd>start(Stage stage)</kbd> method), starting with creating an instance of <kbd>GridPane</kbd> and configuring it:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="4">
<li>Load the data from the file using the method created in the first step:</li>
</ol>
<pre>        Map&lt;String, List&lt;FallOfWicket&gt;&gt; fow = getFallOfWickets();</pre>
<ol start="5">
<li>Create the required <em>x</em> and <em>y</em> axes and add them to <kbd>ScatterChart</kbd>:</li>
</ol>
<pre>        final NumberAxis xAxis = new NumberAxis();
        final NumberAxis yAxis = new NumberAxis();
        xAxis.setLabel("Age");
        yAxis.setLabel("Marks");
        final ScatterChart&lt;Number,Number&gt; scatterChart = 
                           new ScatterChart&lt;&gt;(xAxis,yAxis);</pre>
<ol start="6">
<li>Create <kbd>XYChart.Series</kbd> for each team's innings and add it to <kbd>ScatterChart</kbd>:</li>
</ol>
<pre>        scatterChart.getData().add(getSeries(fow.get("NZ"), "NZ"));
        scatterChart.getData().add(getSeries(fow.get("IND"), "IND"));</pre>
<ol start="7">
<li>Add <kbd>ScatterChart</kbd> to <kbd>gridPane</kbd> and create a new <kbd>Scene</kbd> graph with <kbd>gridPane</kbd> as the root:</li>
</ol>
<pre>        gridPane.add(scatterChart, 1, 1);
        Scene scene = new Scene(gridPane, 600, 400);</pre>
<ol start="8">
<li>Set the scene graph to the <kbd>Stage</kbd> instance to be rendered on the display:</li>
</ol>
<pre>        stage.setTitle("Bubble Charts");
        stage.setScene(scene);
        stage.show();</pre>
<ol start="9">
<li>Launch the UI from the <kbd>main</kbd> method, as shown here:</li>
</ol>
<pre>        public static void main(String[] args) {
          Application.launch(args);
        }</pre>
<p>You can find the complete code at the location, <kbd>chp9/9_scatter_charts</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <span><kbd>chp9/9_scatter_charts</kbd>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd> and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="292" width="413" class="image-border" src="assets/3d55039a-dfd9-4e8b-998b-4d8e33e1f0c9.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A scatter chart works in a similar way to how a bar chart or a line chart works. It's another two-axis graph, where the data points are plotted on the two axes. The axes are created using <kbd>javafx.scene.chart.CategoryAxis</kbd> or <kbd>javafx.scene.chart.NumberAxis</kbd>, depending on whether the data is string or numeric. </p>
<p>The data to be plotted is provided in the form of <kbd>XYChart.Series&lt;X,Y&gt;</kbd>, where <kbd>X</kbd> and <kbd>Y</kbd> can be <kbd>String</kbd> or any type extending <kbd>Number</kbd>, and it contains the data in the form of a list of <kbd>XYChart.Data</kbd> objects, something like the following:</p>
<pre>XYChart.Series&lt;Number,Number&gt; series  = new XYChart.Series&lt;&gt;();
series.getData().add(new XYChart.Data&lt;Number, Number&gt;(xValue, yValue));</pre>
<p>In a scatter chart, the data is plotted in the form of points, with each series having a specific color and shape, and these points are not joined, unlike line or area charts. This can be seen in the example used in the recipe. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes of this chapter:</p>
<ul>
<li>Creating a bar chart</li>
<li>Creating an area chart</li>
<li>Creating a line chart</li>
<li>Creating a pie chart</li>
<li>Creating a bubble chart</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embedding HTML in an application</h1>
                </header>
            
            <article>
                
<p>JavaFX provides support for managing web pages via the classes defined in the <kbd>javafx.scene.web</kbd> package. It supports loading the web page, either by accepting the web page URL or by accepting the web page content. It also manages the document model of the web page, applies the relevant CSS, and runs the relevant JavaScript code. It also extends support for a two-way communication between JavaScript and the Java code. </p>
<p>In this recipe, we will build a very primitive and simple web browser, which supports the following:</p>
<ul>
<li>Navigating through the history of the pages visited</li>
<li>Reloading the current page</li>
<li>An address bar for accepting the URL </li>
<li>A button for loading the entered URL</li>
<li>Showing the web page</li>
<li>Showing the status of loading of the web page</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require an internet connection to test the loading of pages. So, make sure you are connected to the internet. Apart from this, there is nothing specific required to work with this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's first create a class with empty methods, which would represent the main application for launching the application as well as the JavaFX UI:</li>
</ol>
<pre>        public class BrowserDemo extends Application{
          public static void main(String[] args) {
            Application.launch(args);
          }
          @Override
          public void start(Stage stage) {
            //this will have all the JavaFX related code
          }
        }</pre>
<p style="padding-left: 60px">In the subsequent steps, we will write all our code within the <kbd>start(Stage stage)</kbd> method.</p>
<ol start="2">
<li>Let's create a <kbd><span>javafx.scene.web.</span>WebView</kbd> component, which will render our web page. This has the required <kbd><span>javafx.scene.web.</span>WebEngine</kbd> instance, which manages loading of the web page:</li>
</ol>
<pre>        WebView webView = new WebView();</pre>
<ol start="3">
<li>Get the instance of <kbd>javafx.scene.web.WebEngine</kbd> used by <kbd>webView</kbd>. We will use this instance of <kbd><span>javafx.scene.web.</span>WebEngine</kbd> to navigate through the history and load other web pages. Then we will, by default, load the URL, <a href="http://www.google.com">http://www.google.com</a>:</li>
</ol>
<pre>        WebEngine webEngine = webView.getEngine();
        webEngine.load("http://www.google.com/");</pre>
<ol start="4">
<li>Now, let's create a <kbd>javafx.scene.control.TextField</kbd> component, which will act as our browser's address bar:</li>
</ol>
<pre>        TextField webAddress = new TextField("http://www.google.com/");</pre>
<ol start="5">
<li>We want to change the title of the browser and the web page in the address bar, based on the title and URL of the completely loaded web page. This can be done by listening to the change in the <kbd>stateProperty</kbd> of <kbd>javafx.concurrent.Worker</kbd> obtained from the <kbd><span>javafx.scene.web.</span>WebEngine</kbd> instance:</li>
</ol>
<pre>        webEngine.getLoadWorker().stateProperty().addListener(
          new ChangeListener&lt;State&gt;() {
            public void changed(ObservableValue ov, 
                                State oldState, State newState) {
              if (newState == State.SUCCEEDED) {
                stage.setTitle(webEngine.getTitle());
                webAddress.setText(webEngine.getLocation());
              }
            }
          }
        );</pre>
<ol start="6">
<li>Let's create a <kbd>javafx.scene.control.Button</kbd> instance, which, on click, will load the web page identified by the URL entered in the address bar:</li>
</ol>
<pre>        Button goButton = new Button("Go");
        goButton.setOnAction((event) -&gt; {
          String url = webAddress.getText();
          if ( url != null &amp;&amp; url.length() &gt; 0){
            webEngine.load(url);
          }
        });</pre>
<ol start="7">
<li>Let's create a <span><kbd>javafx.scene.control.Button</kbd> instance, which, on click, will go to the previous web page in the history. To achieve this, we will execute the JavaScript code, <kbd>history.back()</kbd>, from within the action handler:</span></li>
</ol>
<pre>        Button prevButton = new Button("Prev");
        prevButton.setOnAction(e -&gt; {
          webEngine.executeScript("history.back()");
        });</pre>
<ol start="8">
<li>Let's create a <kbd>javafx.scene.control.Button</kbd> instance, which, on click, will go to the next entry in the history maintained by <kbd>javafx.scene.web.WebEngine</kbd> instance. For this, we will make use of the <kbd>javafx.scene.web.WebHistory</kbd> API:</li>
</ol>
<pre>        Button nextButton = new Button("Next");
        nextButton.setOnAction(e -&gt; {
          WebHistory wh = webEngine.getHistory();
          Integer historySize = wh.getEntries().size();
          Integer currentIndex = wh.getCurrentIndex();
          if ( currentIndex &lt; (historySize - 1)){
            wh.go(1);
          }
        });</pre>
<ol start="9">
<li>Next is the button for reloading the current page. Again, we will make use of <kbd>javafx.scene.web.WebEngine</kbd> to reload the current page:</li>
</ol>
<pre>        Button reloadButton = new Button("Refresh");
        reloadButton.setOnAction(e -&gt; {
          webEngine.reload();
        });</pre>
<ol start="10">
<li>Now, we need to group all the components created so far, namely, <kbd>prevButton</kbd>, <kbd>nextButton</kbd>, <kbd>reloadButton</kbd>, <kbd>webAddress</kbd>, and <kbd>goButton</kbd> so that they align horizontally with each other. To achieve this, we will make use of <kbd>javafx.scene.layout.HBox</kbd> with relevant spacing and padding to make the components look well spaced:</li>
</ol>
<pre>        HBox addressBar = new HBox(10);
        addressBar.setPadding(new Insets(10, 5, 10, 5));
        addressBar.setHgrow(webAddress, Priority.ALWAYS);
        addressBar.getChildren().addAll(
          prevButton, nextButton, reloadButton, webAddress, goButton
        );</pre>
<ol start="11">
<li>We would want to know whether the web page is loading and whether it has finished. Let's create a <kbd>javafx.scene.layout.Label</kbd> field to update the status if the web page is loaded. Then, we listen to the updates to <kbd>workDoneProperty</kbd> of the <kbd>javafx.concurrent.Worker</kbd> instance, which we can get from the <kbd>javafx.scene.web.WebEngine</kbd> instance:</li>
</ol>
<pre>        Label websiteLoadingStatus = new Label();
        webEngine.getLoadWorker().workDoneProperty().addListener(
                            new ChangeListener&lt;Number&gt;(){
          public void changed(ObservableValue ov, Number oldState,<br/>                              Number newState) {
            if (newState.doubleValue() != 100.0){
              websiteLoadingStatus.setText("Loading " + 
              <strong>                             </strong>webAddress.getText());
            }else{
              websiteLoadingStatus.setText("Done");
            }
          }
        });</pre>
<ol start="12">
<li>Let's align the entire address bar (with its navigation buttons), <kbd>webView</kbd>, and <span><kbd>websiteLoadingStatus</kbd> vertically:</span></li>
</ol>
<pre>        VBox root = new VBox();
        root.getChildren().addAll(
          addressBar, webView, websiteLoadingStatus
        );</pre>
<ol start="13">
<li>Create a new <kbd>Scene</kbd> object with the <kbd>VBox</kbd> instance created in the preceding step as the root:</li>
</ol>
<pre>        Scene scene = new Scene(root);</pre>
<ol start="14">
<li>We want the <kbd>javafx.stage.Stage</kbd> instance to occupy the complete screen size; for this, we will make use of <kbd>Screen.getPrimary().getVisualBounds()</kbd>. Then, as usual, we will render the scene graph on the stage:</li>
</ol>
<pre>        Rectangle2D primaryScreenBounds = 
                    Screen.getPrimary().getVisualBounds();
        stage.setTitle("Web Browser");
        stage.setScene(scene);
        stage.setX(primaryScreenBounds.getMinX());
        stage.setY(primaryScreenBounds.getMinY());
        stage.setWidth(primaryScreenBounds.getWidth());
        stage.setHeight(primaryScreenBounds.getHeight());
        stage.show();</pre>
<p>The complete code can be found at the location, <kbd>chp9/10_embed_html</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <kbd>chp9/10_embed_html</kbd><span>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>, and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="406" width="528" class="image-border" src="assets/1191889d-a320-41ae-8954-3975de214628.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The web-related APIs are available in the module, <kbd>javafx.web</kbd>, so we will have to require it in <kbd>module-info</kbd>:</p>
<pre>module gui{
  requires javafx.controls;
  requires javafx.web;
  opens com.packt;
}</pre>
<p>The following are the important classes in <kbd>javafx.scene.</kbd> web package when dealing with web pages in JavaFX:</p>
<ul>
<li><kbd>WebView</kbd>: This UI component uses <kbd>WebEngine</kbd> to manage the loading, rendering, and interaction with the web page</li>
<li><kbd>WebEngine</kbd>: This is the main component that deals with loading and managing the web page</li>
<li><kbd>WebHistory</kbd>: This records the web pages visited in the current <kbd>WebEngine</kbd> instance</li>
<li><kbd>WebEvent</kbd>: These are the instances passed to the event handlers of <kbd>WebEngine</kbd> invoked by the JavaScript event</li>
</ul>
<p>In our recipe, we make use of the first three classes.</p>
<p>We don't directly create an instance of <kbd>WebEngine</kbd>; instead, we make use of <kbd>WebView</kbd> to get a reference to the <kbd>WebEngine</kbd> instance managed by it. The <kbd>WebEngine</kbd> instance loads the web page asynchronously by submitting the task of loading the page to <kbd>javafx.concurrent.Worker</kbd> instances. Then, we register change listeners on these worker instance properties to track the progress of loading the web page. We have made use of two such properties in this recipe, namely, <kbd>stateProperty</kbd> and <kbd>workDoneProperty</kbd>. The former tracks the change of the state of the worker, and the latter tracks the percentage of work done. </p>
<p>A worker can go through the following states (as listed in the <kbd>javafx.concurrent.Worker.State</kbd> enum):</p>
<ul>
<li><kbd>CANCELLED</kbd></li>
<li><kbd>FAILED</kbd></li>
<li><kbd>READY</kbd></li>
<li><kbd>RUNNING</kbd></li>
<li><kbd>SCHEDULED</kbd></li>
<li><kbd>SUCCEEDED</kbd></li>
</ul>
<p>In our recipe, we are only checking for <kbd>SUCCEEDED</kbd>, but you can enhance it to check for <kbd>FAILED</kbd> as well. This will help us report invalid URLs or even get the message from the event object and show it to the user.</p>
<p>The way we add the listeners to track the change in the properties is by using the <kbd>addListener()</kbd> method on <kbd>*Property()</kbd>, where <kbd>*</kbd> can be <kbd>state</kbd>, <kbd>workDone</kbd>, or any other attribute of the worker that has been exposed as a property:</p>
<pre>webEngine.getLoadWorker().stateProperty().addListener( 
  new ChangeListener&lt;State&gt;() {
    public void changed(ObservableValue ov, 
      State oldState, State newState) {
        //event handler code here
    }
  }
);<br/><br/>webEngine.getLoadWorker().workDoneProperty().addListener(
  new ChangeListener&lt;Number&gt;(){
    public void changed(ObservableValue ov, 
      Number oldState, Number newState) {
        //event handler code here
    }
  }
);</pre>
<p>Then <kbd>javafx.scene.web.WebEngine</kbd> component also supports:</p>
<ul>
<li>Reloading the current page</li>
<li>Getting the history of the pages loaded by it</li>
<li>Executing the JavaScript code</li>
<li>Listening to JavaScript properties, such as showing an alert box or confirmation box</li>
<li>Interacting with the document model of the web page using the <kbd>getDocument()</kbd> method</li>
</ul>
<p>In this recipe, we also looked at using <kbd>WebHistory</kbd> obtained from <kbd>WebEngine</kbd>. <kbd>WebHistory</kbd> stores the web pages loaded by the given <kbd>WebEngine</kbd> instance, which means one <kbd>WebEngine</kbd> instance will have one <kbd>WebHistory</kbd> instance. <kbd>WebHistory</kbd> supports the following:</p>
<ul>
<li>Getting the list of entries by using the <kbd>getEntries()</kbd> method. This will also get us the number of entries in the history. This is required while navigating forward and backward in history; otherwise, we will end up with an index out of bounds exception.</li>
<li>Getting <kbd>currentIndex</kbd>, that is, its index within the <kbd>getEntries()</kbd> list.</li>
<li>Navigating to the specific entry in the entries list of <kbd>WebHistory</kbd>. This can be achieved by using the <kbd>go()</kbd> method, which accepts an offset. This offset indicates which web page to load, relative to the current position. For example, <em>+1</em> indicates the next entry and <em>-1</em> indicates the previous entry. It's important to check for the boundary conditions; otherwise, you will end up with going before <em>0</em>, that is, <em>-1</em>, or going past the entry list size.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we showed you a basic approach to creating a web browser using the support provided by JavaFX. You can enhance this to support the following:</p>
<ul>
<li>Better error handling and user messages, that is, to show whether the web address is valid or not by tracking the state change of the worker</li>
<li>Multiple tabs</li>
<li>Bookmarking</li>
<li>Storing the state of the browser locally so that the next time it is run, it loads all the bookmarks and history</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Embedding media in an application</h1>
                </header>
            
            <article>
                
<p>JavaFX provides a component, <kbd>javafx.scene.media.MediaView</kbd>, for viewing videos and listening to audios. This component is backed by a media engine, <kbd>javafx.scene.media.MediaPlayer</kbd>, which loads and manages the playback of the media. </p>
<p>In this recipe, we will look at playing a sample video and controlling its playback by using the methods on the media engine. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will make use of the sample video available at <kbd>chp9/11_embed_audio_video/sample_video1.mp4</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's first create a class with empty methods, which would represent the main application for launching the application as well as the JavaFX UI:</li>
</ol>
<pre>        public class EmbedAudioVideoDemo extends Application{
          public static void main(String[] args) {
            Application.launch(args);
          }
          @Override
          public void start(Stage stage) {
            //this will have all the JavaFX related code
          }
        }</pre>
<ol start="2">
<li>Create a <kbd>javafx.scene.media.Media</kbd> object for the video located at <kbd>chp9/11_embed_audio_video/sample_video1.mp4</kbd>:</li>
</ol>
<pre>        File file = new File("sample_video1.mp4");
        Media media = new Media(file.toURI().toString());</pre>
<ol start="3">
<li>Create a new media engine,  <kbd>javafx.scene.media.MediaPlayer</kbd>, using the <kbd>javafx.scene.media.Media</kbd> object created in the previous step:</li>
</ol>
<pre>        MediaPlayer mediaPlayer = new MediaPlayer(media);</pre>
<ol start="4">
<li>Let's track the status of the media player by registering a change listener on <kbd>statusProperty</kbd> of the <kbd>javafx.scene.media.MediaPlayer</kbd> object:</li>
</ol>
<pre>        mediaPlayer.statusProperty().addListener(
                    new ChangeListener&lt;Status&gt;() {
          public void changed(ObservableValue ov, 
                              Status oldStatus, Status newStatus) {
            System.out.println(oldStatus +"-&gt;" + newStatus);
          }
        });</pre>
<ol start="5">
<li>Let's now create a media viewer using the media engine created in the previous step:</li>
</ol>
<pre>        MediaView mediaView = new MediaView(mediaPlayer);</pre>
<ol start="6">
<li>We will restrict the width and height of the media viewer:</li>
</ol>
<pre>        mediaView.setFitWidth(350);
        mediaView.setFitHeight(350); </pre>
<ol start="7">
<li>Next, we create three buttons to pause the video playback, resume the playback, and stop the playback. We will make use of the relevant methods in the <kbd>javafx.scene.media.MediaPlayer</kbd> class:</li>
</ol>
<pre>        Button pauseB = new Button("Pause");
        pauseB.setOnAction(e -&gt; {
          mediaPlayer.pause();
        });

        Button playB = new Button("Play");
        playB.setOnAction(e -&gt; {
          mediaPlayer.play();
        });

        Button stopB = new Button("Stop");
        stopB.setOnAction(e -&gt; {
          mediaPlayer.stop();
        });</pre>
<ol start="8">
<li>Align all these buttons horizontally using <kbd>javafx.scene.layout.HBox</kbd>:</li>
</ol>
<pre>        HBox controlsBox = new HBox(10);
        controlsBox.getChildren().addAll(pauseB, playB, stopB);</pre>
<ol start="9">
<li>Align the media viewer and the buttons bar vertically using <kbd>javafx.scene.layout.VBox</kbd>:</li>
</ol>
<pre>        VBox vbox = new VBox();
        vbox.getChildren().addAll(mediaView, controlsBox);</pre>
<ol start="10">
<li>Create a new scene graph using the <kbd>VBox</kbd> object as the root and set it to the stage object:</li>
</ol>
<pre>        Scene scene = new Scene(vbox);
        stage.setScene(scene);
        // Name and display the Stage.
        stage.setTitle("Media Demo");</pre>
<ol start="11">
<li>Render the stage on the display:</li>
</ol>
<pre>        stage.setWidth(400);
        stage.setHeight(400);
        stage.show();</pre>
<p>The complete code can be found at <kbd>chp9/11_embed_audio_video</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <kbd>chp9/11_embed_audio_video</kbd><span>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>, and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="216" width="311" class="image-border" src="assets/7db0582c-1ac0-4783-b57c-c1e36cea43b1.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The important classes, in the <kbd>javafx.scene.media</kbd> package for media playback are as follows:</p>
<ul>
<li><kbd>Media</kbd>: This represents the source of the media, that is, either the video or audio. This accepts the source in the form of HTTP/HTTPS/FILE and JAR URLs.</li>
<li><kbd>MediaPlayer</kbd>: This manages the playback of the media.</li>
<li><kbd>MediaView</kbd>: This is the UI component that allows viewing the media. </li>
</ul>
<p>There are a few other classes, but we haven't covered them in this recipe. The media-related classes are in the <kbd>javafx.media</kbd> module. So, do not forget to require a dependency on it, as shown here:</p>
<pre>module gui{
  requires javafx.controls;
  requires javafx.media;
  opens com.packt;
}</pre>
<p>In this recipe, we have a sample video at <kbd>chp9/11_embed_audio_video/sample_video1.mp4</kbd>, and we make use of the <kbd>java.io.File</kbd> API to build <kbd>File</kbd> URL to locate the video:</p>
<pre>File file = new File("sample_video1.mp4");
Media media = new Media(file.toURI().toString());</pre>
<p>The media playback is managed by using the API exposed by the <kbd>javafx.scene.media.MediaPlayer</kbd> class. In this recipe, we made use of a few of its methods, namely <kbd>play()</kbd>, <kbd>pause()</kbd>, and <kbd>stop()</kbd>. The <kbd>javafx.scene.media.MediaPlayer</kbd> class is initialized by using the <kbd>javafx.scene.media.Media</kbd> object:</p>
<pre>MediaPlayer mediaPlayer = new MediaPlayer(media);</pre>
<p>Rendering the media on the UI is managed by the  <kbd>javafx.scene.media.MediaView</kbd> class, and it is backed by a <kbd>javafx.scene.media.MediaPlayer</kbd> object:</p>
<pre>MediaView mediaView = new MediaView(mediaPlayer);</pre>
<p>We can set the height and width of the viewer by using the <kbd>setFitWidth()</kbd> and <kbd>setFitHeight()</kbd> methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We gave a basic demo of media support in JavaFX. There's a lot more to explore. You can add volume control options, options to seek forward or backward, playing of audios, and audio equalizer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding effects to controls</h1>
                </header>
            
            <article>
                
<p>Adding effects in a controlled way gives a good appearance to the user interface. There are multiple effects like blurring, shadows, reflection, blooming, and so on. JavaFX provides a set of classes under the <kbd>javafx.scene.effects</kbd> package, which can be used to add effects to enhance the look of the application. This package is available in the <kbd>javafx.graphics</kbd> module.</p>
<p>In this recipe, we will look at a few effects: blur, shadow, and reflection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's first create a class with empty methods, which would represent the main application for launching the application as well as the JavaFX UI:</li>
</ol>
<pre>        public class EffectsDemo extends Application{
          public static void main(String[] args) {
            Application.launch(args);
          }
          @Override
          public void start(Stage stage) {
            //code added here in next steps
          }
        }</pre>
<ol start="2">
<li>The subsequent code will be written within the <kbd>start(Stage stage)</kbd> method. Create and configure <kbd>javafx.scene.layout.GridPane</kbd>:</li>
</ol>
<pre>        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(10);
        gridPane.setVgap(10);
        gridPane.setPadding(new Insets(25, 25, 25, 25));</pre>
<ol start="3">
<li>Create rectangles required for applying the blur effects:</li>
</ol>
<pre>        Rectangle r1 = new Rectangle(100,25, Color.BLUE);
        Rectangle r2 = new Rectangle(100,25, Color.RED);
        Rectangle r3 = new Rectangle(100,25, Color.ORANGE);</pre>
<ol start="4">
<li>Add <kbd>javafx.scene.effect.BoxBlur</kbd> to <kbd>Rectangle r1</kbd>, <kbd>javafx.scene.effect.MotionBlur</kbd> to <kbd>Rectangle r2</kbd>, and <kbd>javafx.scene.effect.GaussianBlur</kbd> to <kbd>Rectangle r3</kbd>:</li>
</ol>
<pre>        r1.setEffect(new BoxBlur(10,10,3));
        r2.setEffect(new MotionBlur(90, 15.0));
        r3.setEffect(new GaussianBlur(15.0));</pre>
<ol start="5">
<li>Add the rectangles to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        gridPane.add(r1,1,1);
        gridPane.add(r2,2,1);
        gridPane.add(r3,3,1);</pre>
<ol start="6">
<li>Create three circles, required for applying shadows:</li>
</ol>
<pre>        Circle c1 = new Circle(20, Color.BLUE);
        Circle c2 = new Circle(20, Color.RED);
        Circle c3 = new Circle(20, Color.GREEN);</pre>
<ol start="7">
<li>Add <kbd>javafx.scene.effect.DropShadow</kbd> to <kbd>c1</kbd> and <kbd><span>javafx.scene.effect.</span>InnerShadow</kbd> to <kbd>c2</kbd>:</li>
</ol>
<pre>        c1.setEffect(new DropShadow(0, 4.0, 0, Color.YELLOW));
        c2.setEffect(new InnerShadow(0, 4.0, 4.0, Color.ORANGE));</pre>
<ol start="8">
<li>Add these circles to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        gridPane.add(c1,1,2);
        gridPane.add(c2,2,2);
        gridPane.add(c3,3,2);</pre>
<ol start="9">
<li>Create a simple text, <kbd>Reflection Sample</kbd>, on which we will apply the reflection effect:</li>
</ol>
<pre>        Text t = new Text("Reflection Sample");
        t.setFont(Font.font("Arial", FontWeight.BOLD, 20));
        t.setFill(Color.BLUE);</pre>
<ol start="10">
<li>Create a <kbd>javafx.scene.effect.Reflection</kbd> effect and add it to the text:</li>
</ol>
<pre>        Reflection reflection = new Reflection();
        reflection.setFraction(0.8);
        t.setEffect(reflection);</pre>
<ol start="11">
<li>Add the text component to <kbd>gridPane</kbd>:</li>
</ol>
<pre>        gridPane.add(t, 1, 3, 3, 1);</pre>
<ol start="12">
<li>Create a scene graph using <kbd>gridPane</kbd> as the root node:</li>
</ol>
<pre>        Scene scene = new Scene(gridPane, 500, 300);</pre>
<ol start="13">
<li>Set the scene graph to the stage and render it on the display:</li>
</ol>
<pre>        stage.setScene(scene);
        stage.setTitle("Effects Demo");
        stage.show();</pre>
<p>The complete code can be found at <kbd>chp9/12_effects_demo</kbd>.</p>
<p>We have provided two run scripts, <kbd>run.bat</kbd> and <kbd>run.sh</kbd>, under <kbd>chp9/12_effects_demo</kbd><span>. The <kbd>run.bat</kbd> script will be for running the application on Windows and <kbd>run.sh</kbd> will be for running the application on Linux.</span></p>
<p><span>Run the application using <kbd>run.bat</kbd> or <kbd>run.sh</kbd> and you will see the following GUI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="200" width="303" class="image-border" src="assets/d460b18c-fdd4-462a-ab25-842b8a9c556a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we have made use of the following effects:</p>
<ul>
<li><kbd>javafx.scene.effect.BoxBlur</kbd></li>
<li><kbd><span>javafx.scene.effect.</span>MotionBlur</kbd></li>
<li><kbd><span>javafx.scene.effect.</span>GaussianBlur</kbd></li>
<li><kbd><span>javafx.scene.effect.</span>DropShadow</kbd></li>
<li><kbd><span>javafx.scene.effect.</span>InnerShadow</kbd></li>
<li><kbd><span>javafx.scene.effect.</span>Reflection</kbd></li>
</ul>
<p>The <kbd>BoxBlur</kbd> effect is created by specifying the width and height of the blur effect, and also the number of times the effect needs to be applied:</p>
<pre>BoxBlur boxBlur = new BoxBlur(10,10,3);</pre>
<p>The <span><kbd>MotionBlur</kbd> effect is created by providing the angle of the blur and its radius. This gives an effect of something captured while in motion:</span></p>
<pre>MotionBlur motionBlur = new MotionBlur(90, 15.0);</pre>
<p>The <span><kbd>GaussianBlur</kbd> effect is created by providing the radius of the effect, and the effect uses the Gaussian formula to apply the effect:</span></p>
<pre><span>GaussianBlur gb = new GaussianBlur(15.0);</span></pre>
<p>The <kbd>DropShadow</kbd> adds the shadow behind the object whereas <kbd>InnerShadow</kbd> adds the shadow within the object. Each of these takes the radius of the shadow, the <em>x</em> and <em>y</em> location of the start of shadow, and the color of the shadow:</p>
<pre>DropShadow dropShadow = new DropShadow(0, 4.0, 0, Color.YELLOW);
InnerShadow innerShadow = new InnerShadow(0, 4.0, 4.0, Color.ORANGE);</pre>
<p><kbd>Reflection</kbd> is a pretty simple effect, which adds the reflection of the object. We can set the fraction of how much of the original object is reflected:</p>
<pre>Reflection reflection = new Reflection();
reflection.setFraction(0.8);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are quite a few more effects:</p>
<ul>
<li>The blend effect, which blends two different inputs with a predefined blending approach</li>
<li>The bloom effect, which makes the brighter portions appear brighter</li>
<li>The glow effect, which makes the object glow</li>
<li>Lighting effect, which simulates a light source on the object thereby giving it a 3D appearance.</li>
</ul>
<p>We would recommend you to try out these effects in the same way as we have tried them out. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the new TIFF I/O API to read TIFF images</h1>
                </header>
            
            <article>
                
<p><strong>Tagged Image File Format</strong> (<strong>TIFF</strong>) is a common image format for exchanging images between applications. Previously, JDK didn't have any support for reading TIFF images, and developers had to use the Java Image API, which was external to JDK.</p>
<p>In this recipe, we will show you how to read a TIFF image file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We have a sample TIFF image file at the location, <kbd>chp9/13_tiff_reader/sample.tif</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Get the image readers by format name, which is <kbd>tiff</kbd> for TIFF images</li>
</ol>
<pre>         Iterator iterator = ImageIO.getImageReadersByFormatName("tiff");</pre>
<ol start="2">
<li>Get the first <kbd>ImageReader</kbd> object from the image readers obtained in the previous step:</li>
</ol>
<pre>         ImageReader reader = (ImageReader) iterator.next();</pre>
<ol start="3">
<li>Create a <kbd>FileImageInputStream</kbd> object for the <kbd>sample.tif</kbd> image:</li>
</ol>
<pre>        try(ImageInputStream is = 
                 new FileImageInputStream(new File("sample.tif"))) {
          //image reading code here.
        } catch (Exception ex){
          //exception handling
        }</pre>
<ol start="4">
<li>Use the reader obtained to read the image file:</li>
</ol>
<pre>         reader.setInput(is, false, true);</pre>
<ol start="5">
<li>Let's get some attributes, such as the number of images, width, and height, just to confirm that we have really read the image:</li>
</ol>
<pre>         System.out.println("Number of Images: " + <br/>                            reader.getNumImages(true));
         System.out.println("Height: " + reader.getHeight(0));
         System.out.println("Width: " + reader.getWidth(0));
         System.out.println(reader.getFormatName());</pre>
<p>The complete code for this can be found at <kbd>chp9/13_tiff_reader</kbd>. You can run the sample either by using <kbd>run.bat</kbd> or <kbd>run.sh</kbd>.</p>


            </article>

            
        </section>
    </body></html>