- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zooming in on the Metaspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18762_04.xhtml#_idTextAnchor057), we examined garbage collection
    in detail. We discovered that objects without a reference are eligible for garbage
    collection. In effect, the garbage collector marks the objects that have a connection
    back to the stack, annotating them as live objects. The sweep phase of the garbage
    collector then reclaims the memory of the objects that are not marked (the dead
    objects).
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the various garbage collection implementations. Based on your
    specific criteria, an evaluation of each implementation is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focuses on an area known as the **Metaspace**. We will examine
    the Metaspace under the following headings:'
  prefs: []
  type: TYPE_NORMAL
- en: JVM usage of the Metaspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing Metaspace memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start with the JVM usage of the Metaspace.
  prefs: []
  type: TYPE_NORMAL
- en: JVM usage of the Metaspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Metaspace is a special area of native memory outside of the heap. Native
    memory is memory provided by the operating system to an application for its own
    use. The JVM uses the Metaspace to store class-related information, that is, the
    class’s runtime representation. This is the class’s metadata; hence the *meta*data
    is stored in the *Meta*space.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs: []
  type: TYPE_NORMAL
- en: Metadata is information about data. For example, columns in a database are metadata
    about the data in the columns. Thus, if a column name is **Name** and a specific
    row value is **John**, then **Name** is metadata about **John**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This metadata consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Class files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure and methods of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, in metadata, the JVM has everything it requires to work with the class.
  prefs: []
  type: TYPE_NORMAL
- en: PermGen
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Java 8, the metadata was stored in an area (contiguous with the heap)
    known as **PermGen**, or **permanent generation**. PermGen stored the class metadata,
    interned strings, and the class’s static variables. As of Java 8, the class metadata
    is now stored in the Metaspace, and interned strings and class/static variables
    are stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now examine class loading.
  prefs: []
  type: TYPE_NORMAL
- en: Class loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a class is accessed for the first time (for example, when an object of
    the class is created), the class loader locates the class file and allocates its
    metadata in the Metaspace. The class loader owns this allocated Metaspace and
    the class loader instance itself is loaded onto the heap. Once loaded, subsequent
    references reuse the metadata of that same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two class loaders worth mentioning at this point: the bootstrap class
    loader (which is responsible for loading the class loaders themselves) and the
    application class loader. Both of these class loaders’ metadata reside permanently
    in Metaspace and consequently, are never garbage collected. Dynamic class loaders
    (and the classes they load) are, on the other hand, eligible for garbage collection.'
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the release of memory from the Metaspace.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing Metaspace memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major changes from PermGen (pre-Java 8) to Metaspace (Java 8 onwards)
    is that the Metaspace can now grow in size. By default, the amount of memory allocated
    for the Metaspace is unbounded, as it is part of native memory. The size of the
    Metaspace can be customized using the JVM `–``XX:MetaspaceSize` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Metaspace can trigger garbage collection in only two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Metaspace runs out of memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaspace size exceeds a JVM-set threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us examine these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Metaspace runs out of memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated, by default, the native memory available to the Metaspace is unlimited.
    If you run out of memory, you get an `OutOfMemoryError` message, and this will
    trigger a run of the garbage collector. You can limit the Metaspace size with
    the JVM `–XX:MaxMetaspaceSize` flag. If you reach this limit, that will also trigger
    a run of the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Metaspace size exceeds a JVM-set threshold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can configure the JVM to trigger a garbage collection when the Metaspace
    reaches a certain threshold, known as the `-XX:MetaspaceSize` flag. We use the
    `–XX:MinMetaspaceFreeRatio` and `–XX:MaxMetaspaceFreeRatio` flags to raise or
    lower the high-water mark, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know when garbage collection runs in the Metaspace, let us examine
    how garbage collection works regarding the Metaspace.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection of the Metaspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the class loader owns the metadata for a class, the garbage collector can
    only reclaim this metadata when the class loader itself is dead. The class loader
    is only dead when there are no instances of any classes loaded by that loader.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at an example to help explain this further. The example assumes
    a dynamic class loader and uses simplified diagrams for ease of explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.1* details the situation in memory after we have created two objects
    of the **O** type and one object of the **P** type.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Metaspace allocation](img/Figure_5.1_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Metaspace allocation
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, initially, the JVM creates the class loader object
    (dark blue), two objects of the **O** type (light blue), and one object of the
    **P** type (yellow) on the heap. The **O** and **P** references are on the stack.
    Upon creating the first **O** and **P** instances, the class loader loads the
    metadata for both **O** and **P** in the Metaspace. However, when creating the
    second instance of **O**, nothing happens in the Metaspace because the metadata
    for **O** is already loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.2* will show the situation in memory when both of the **O** references
    go out of scope but garbage collection has not yet run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Metaspace (both O references out of scope)](img/Figure_5.2_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Metaspace (both O references out of scope)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the JVM has popped both of the **O** references from the stack.
    Garbage collection has not yet run so the instances remain on the heap. *Figure
    5**.3* shows the situation after the first run of garbage collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Metaspace after garbage collection (run #1)](img/Figure_5.3_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3 – Metaspace after garbage collection (run #1)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that the garbage collector reclaimed the
    two (dead) **O** objects from the heap. In addition, the garbage collector moved
    both the class loader and **P** objects to the survivor space.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the metadata for **O** remains in the Metaspace even though no objects
    of the **O** type are on the heap. This is because the garbage collector could
    not reclaim the class loader for **O** due to the existence of the object of the
    **P** type on the heap (the same class loader loaded both **O** and **P**).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.4* shows the situation in memory when the **P** reference goes
    out of scope and garbage collection runs again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Metaspace after garbage collection (run #2)](img/Figure_5.4_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4 – Metaspace after garbage collection (run #2)'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the JVM has popped the reference of **P** from the stack. As
    a result, the garbage collector reclaimed the object of the **P** type.
  prefs: []
  type: TYPE_NORMAL
- en: As the garbage collector has now reclaimed all instances of **O** and **P**
    types, it can reclaim the class loader that loaded **O** and **P**. Now, finally,
    the garbage collector can reclaim the metadata for **O** and **P** classes in
    the Metaspace.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up this chapter. Let us recap the major points.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we zoomed in on the Metaspace (formerly known as PermGen).
    The Metaspace is a special area of non-heap memory reserved for a class’s metadata.
    The metadata consists of information enabling the JVM to work with the class:
    for example, method bytecode, constants, and annotations. When a class is first
    used, its metadata is loaded into the Metaspace. An example is the creation of
    an object for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the native memory available to the Metaspace is unlimited. A maximum
    Metaspace size is configurable using the JVM `–XX:MaxMetaspaceSize` flag. A threshold
    value or high-water mark can be set initially using the `–XX:MetaspaceSize` flag.
    If a threshold value is set and reached, this induces a run of the garbage collector.
    Using both JVM flags, `–XX:MinMetaspaceFreeRatio` and `–XX:MaxMetaspaceFreeRatio`,
    in conjunction with garbage collection results, we can dynamically influence the
    high-water mark and, therefore, the interval to the next run of the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: We saw, using an example, how the metadata for a class remains in Metaspace
    until the garbage collector deallocates the class loader that loaded that class.
    This cannot occur until all classes loaded by that class loader have no instances.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have zoomed in on the Metaspace, we will turn our attention to the
    next chapter, which focuses on configuring and monitoring the memory management
    of the JVM.
  prefs: []
  type: TYPE_NORMAL
