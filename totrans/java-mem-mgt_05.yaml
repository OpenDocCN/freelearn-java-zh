- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Zooming in on the Metaspace
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专注于元空间
- en: In [*Chapter 4*](B18762_04.xhtml#_idTextAnchor057), we examined garbage collection
    in detail. We discovered that objects without a reference are eligible for garbage
    collection. In effect, the garbage collector marks the objects that have a connection
    back to the stack, annotating them as live objects. The sweep phase of the garbage
    collector then reclaims the memory of the objects that are not marked (the dead
    objects).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18762_04.xhtml#_idTextAnchor057)中，我们详细研究了垃圾回收。我们发现没有引用的对象有资格进行垃圾回收。实际上，垃圾收集器标记了那些有回溯到栈的对象，将它们标记为活动对象。垃圾收集器的清除阶段随后回收了未标记的对象（即已死亡的对象）的内存。
- en: We also examined the various garbage collection implementations. Based on your
    specific criteria, an evaluation of each implementation is required.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了各种垃圾收集实现。根据您的具体标准，需要对每个实现进行评估。
- en: 'This chapter focuses on an area known as the **Metaspace**. We will examine
    the Metaspace under the following headings:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍一个称为**元空间**的区域。我们将以下标题下检查元空间：
- en: JVM usage of the Metaspace
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM对元空间的利用
- en: Class loading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载
- en: Releasing Metaspace memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放元空间内存
- en: Let us start with the JVM usage of the Metaspace.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从JVM对元空间的利用开始。
- en: JVM usage of the Metaspace
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM对元空间的利用
- en: The Metaspace is a special area of native memory outside of the heap. Native
    memory is memory provided by the operating system to an application for its own
    use. The JVM uses the Metaspace to store class-related information, that is, the
    class’s runtime representation. This is the class’s metadata; hence the *meta*data
    is stored in the *Meta*space.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 元空间是堆之外的本机内存的一个特殊区域。本机内存是操作系统提供给应用程序用于其自身使用的内存。JVM使用元空间来存储与类相关的信息，即类的运行时表示。这是类的元数据；因此，*元数据*存储在*元空间*中。
- en: Metadata
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据
- en: Metadata is information about data. For example, columns in a database are metadata
    about the data in the columns. Thus, if a column name is **Name** and a specific
    row value is **John**, then **Name** is metadata about **John**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是关于数据的信息。例如，数据库中的列是关于列中数据的元数据。因此，如果列名为**Name**，而特定行的值是**John**，那么**Name**是关于**John**的元数据。
- en: 'This metadata consists of the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这项元数据包括以下内容：
- en: Class files
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类文件
- en: Structure and methods of the class
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的结构和方法
- en: Constants
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: Annotations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解
- en: Optimizations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: Thus, in metadata, the JVM has everything it requires to work with the class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在元数据中，JVM拥有与类一起工作所需的一切。
- en: PermGen
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PermGen
- en: Prior to Java 8, the metadata was stored in an area (contiguous with the heap)
    known as **PermGen**, or **permanent generation**. PermGen stored the class metadata,
    interned strings, and the class’s static variables. As of Java 8, the class metadata
    is now stored in the Metaspace, and interned strings and class/static variables
    are stored on the heap.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，元数据存储在一个称为**PermGen**或**永久代**的区域（与堆连续）。PermGen存储类元数据、内部字符串和类的静态变量。从Java
    8开始，类元数据现在存储在元空间中，内部字符串和类/静态变量存储在堆上。
- en: Let us now examine class loading.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查类加载。
- en: Class loading
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类加载
- en: When a class is accessed for the first time (for example, when an object of
    the class is created), the class loader locates the class file and allocates its
    metadata in the Metaspace. The class loader owns this allocated Metaspace and
    the class loader instance itself is loaded onto the heap. Once loaded, subsequent
    references reuse the metadata of that same class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次访问类时（例如，当创建类的对象时），类加载器定位类文件并在元空间中为其分配元数据。类加载器拥有分配的元空间，并且类加载器实例本身被加载到堆上。一旦加载，后续的引用将重用该类相同的元数据。
- en: 'There are two class loaders worth mentioning at this point: the bootstrap class
    loader (which is responsible for loading the class loaders themselves) and the
    application class loader. Both of these class loaders’ metadata reside permanently
    in Metaspace and consequently, are never garbage collected. Dynamic class loaders
    (and the classes they load) are, on the other hand, eligible for garbage collection.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，有两个类加载器值得提及：引导类加载器（负责加载类加载器本身）和应用类加载器。这两个类加载器的元数据永久存储在元空间中，因此永远不会被垃圾回收。动态类加载器（以及它们加载的类）另一方面，有资格进行垃圾回收。
- en: This leads us to the release of memory from the Metaspace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们从元空间中释放内存。
- en: Releasing Metaspace memory
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放元空间内存
- en: One of the major changes from PermGen (pre-Java 8) to Metaspace (Java 8 onwards)
    is that the Metaspace can now grow in size. By default, the amount of memory allocated
    for the Metaspace is unbounded, as it is part of native memory. The size of the
    Metaspace can be customized using the JVM `–``XX:MetaspaceSize` flag.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PermGen（Java 8 之前）到 Metaspace（Java 8 及以后）的一个主要变化是，Metaspace 现在可以按需增长大小。默认情况下，分配给
    Metaspace 的内存量是无界的，因为它属于本地内存的一部分。Metaspace 的大小可以使用 JVM 的 `–XX:MetaspaceSize` 标志进行自定义。
- en: 'The Metaspace can trigger garbage collection in only two scenarios:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Metaspace 只能在两种情况下触发垃圾回收：
- en: Metaspace runs out of memory
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metaspace 内存耗尽
- en: Metaspace size exceeds a JVM-set threshold
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metaspace 的大小超过了 JVM 设置的阈值
- en: Let us examine these in turn.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查这些内容。
- en: Metaspace runs out of memory
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metaspace 内存耗尽
- en: As stated, by default, the native memory available to the Metaspace is unlimited.
    If you run out of memory, you get an `OutOfMemoryError` message, and this will
    trigger a run of the garbage collector. You can limit the Metaspace size with
    the JVM `–XX:MaxMetaspaceSize` flag. If you reach this limit, that will also trigger
    a run of the garbage collector.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，默认情况下，Metaspace 可用的本地内存是无限的。如果你耗尽内存，你会收到一个 `OutOfMemoryError` 信息，这将触发垃圾回收器的运行。你可以使用
    JVM 的 `–XX:MaxMetaspaceSize` 标志来限制 Metaspace 的大小。如果你达到这个限制，也会触发垃圾回收器的运行。
- en: Metaspace size exceeds a JVM-set threshold
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metaspace 的大小超过了 JVM 设置的阈值
- en: We can configure the JVM to trigger a garbage collection when the Metaspace
    reaches a certain threshold, known as the `-XX:MetaspaceSize` flag. We use the
    `–XX:MinMetaspaceFreeRatio` and `–XX:MaxMetaspaceFreeRatio` flags to raise or
    lower the high-water mark, respectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置 JVM，当 Metaspace 达到某个特定阈值时触发垃圾回收，这个阈值被称为 `-XX:MetaspaceSize` 标志。我们使用 `–XX:MinMetaspaceFreeRatio`
    和 `–XX:MaxMetaspaceFreeRatio` 标志来分别提高或降低高水位线。
- en: Now that we know when garbage collection runs in the Metaspace, let us examine
    how garbage collection works regarding the Metaspace.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了垃圾回收在 Metaspace 中运行的时间，让我们来检查垃圾回收在 Metaspace 中的工作方式。
- en: Garbage collection of the Metaspace
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metaspace 的垃圾回收
- en: As the class loader owns the metadata for a class, the garbage collector can
    only reclaim this metadata when the class loader itself is dead. The class loader
    is only dead when there are no instances of any classes loaded by that loader.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类加载器拥有类的元数据，垃圾回收器只能在类加载器本身死亡时回收这些元数据。类加载器只有在没有由该加载器加载的任何类的实例时才会死亡。
- en: Let us look at an example to help explain this further. The example assumes
    a dynamic class loader and uses simplified diagrams for ease of explanation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来进一步解释这一点。该例子假设了一个动态类加载器，并使用简化的图表来便于解释。
- en: '*Figure 5**.1* details the situation in memory after we have created two objects
    of the **O** type and one object of the **P** type.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.1* 详细说明了我们在创建了两个 **O** 类型的对象和一个 **P** 类型的对象后内存中的情况。'
- en: '![Figure 5.1 – Metaspace allocation](img/Figure_5.1_B18762.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Metaspace 分配](img/Figure_5.1_B18762.jpg)'
- en: Figure 5.1 – Metaspace allocation
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Metaspace 分配
- en: In the preceding figure, initially, the JVM creates the class loader object
    (dark blue), two objects of the **O** type (light blue), and one object of the
    **P** type (yellow) on the heap. The **O** and **P** references are on the stack.
    Upon creating the first **O** and **P** instances, the class loader loads the
    metadata for both **O** and **P** in the Metaspace. However, when creating the
    second instance of **O**, nothing happens in the Metaspace because the metadata
    for **O** is already loaded.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，最初，JVM 在堆上创建了类加载器对象（深蓝色），两个 **O** 类型的对象（浅蓝色）和一个 **P** 类型的对象（黄色）。**O**
    和 **P** 引用在栈上。在创建第一个 **O** 和 **P** 实例时，类加载器在 Metaspace 中加载了 **O** 和 **P** 的元数据。然而，在创建第二个
    **O** 实例时，Metaspace 中没有发生任何事情，因为 **O** 的元数据已经加载。
- en: '*Figure 5**.2* will show the situation in memory when both of the **O** references
    go out of scope but garbage collection has not yet run:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2* 将展示当两个 **O** 引用都超出作用域但垃圾回收尚未运行时内存中的情况：'
- en: '![Figure 5.2 – Metaspace (both O references out of scope)](img/Figure_5.2_B18762.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – Metaspace（两个 O 引用超出作用域）](img/Figure_5.2_B18762.jpg)'
- en: Figure 5.2 – Metaspace (both O references out of scope)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Metaspace（两个 O 引用超出作用域）
- en: 'As you can see, the JVM has popped both of the **O** references from the stack.
    Garbage collection has not yet run so the instances remain on the heap. *Figure
    5**.3* shows the situation after the first run of garbage collection:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JVM 已经从栈中弹出了两个 **O** 引用。由于垃圾回收尚未运行，实例仍然在堆上。*图 5.3* 展示了第一次运行垃圾回收后的情况：
- en: '![Figure 5.3 – Metaspace after garbage collection (run #1)](img/Figure_5.3_B18762.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 垃圾回收后的元空间（运行#1）](img/Figure_5.3_B18762.jpg)'
- en: 'Figure 5.3 – Metaspace after garbage collection (run #1)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 垃圾回收后的元空间（运行#1）
- en: In the preceding figure, we can see that the garbage collector reclaimed the
    two (dead) **O** objects from the heap. In addition, the garbage collector moved
    both the class loader and **P** objects to the survivor space.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到垃圾收集器从堆中回收了两个（已死亡）**O**对象。此外，垃圾收集器将类加载器和**P**对象都移动到了幸存空间。
- en: Note that the metadata for **O** remains in the Metaspace even though no objects
    of the **O** type are on the heap. This is because the garbage collector could
    not reclaim the class loader for **O** due to the existence of the object of the
    **P** type on the heap (the same class loader loaded both **O** and **P**).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使没有**O**类型的对象在堆上，**O**的元数据仍然保留在元空间中。这是因为垃圾收集器由于堆上存在**P**类型的对象（同一个类加载器同时加载了**O**和**P**）而无法回收**O**的类加载器。
- en: '*Figure 5**.4* shows the situation in memory when the **P** reference goes
    out of scope and garbage collection runs again:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.4*展示了当**P**引用超出作用域且再次运行垃圾收集时的内存情况：'
- en: '![Figure 5.4 – Metaspace after garbage collection (run #2)](img/Figure_5.4_B18762.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 垃圾回收后的元空间（运行#2）](img/Figure_5.4_B18762.jpg)'
- en: 'Figure 5.4 – Metaspace after garbage collection (run #2)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 垃圾回收后的元空间（运行#2）
- en: We can see that the JVM has popped the reference of **P** from the stack. As
    a result, the garbage collector reclaimed the object of the **P** type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到JVM已经从栈中弹出**P**的引用。因此，垃圾收集器回收了**P**类型的对象。
- en: As the garbage collector has now reclaimed all instances of **O** and **P**
    types, it can reclaim the class loader that loaded **O** and **P**. Now, finally,
    the garbage collector can reclaim the metadata for **O** and **P** classes in
    the Metaspace.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于垃圾收集器现在已经回收了**O**和**P**类型的所有实例，它可以回收加载**O**和**P**的类加载器。现在，最终，垃圾收集器可以回收元空间中**O**和**P**类的元数据。
- en: That wraps up this chapter. Let us recap the major points.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束。让我们回顾一下主要观点。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we zoomed in on the Metaspace (formerly known as PermGen).
    The Metaspace is a special area of non-heap memory reserved for a class’s metadata.
    The metadata consists of information enabling the JVM to work with the class:
    for example, method bytecode, constants, and annotations. When a class is first
    used, its metadata is loaded into the Metaspace. An example is the creation of
    an object for the first time.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们聚焦于元空间（以前称为PermGen）。元空间是非堆内存的一个特殊区域，用于存储类的元数据。元数据包括使JVM能够与类一起工作的信息：例如，方法字节码、常量和注解。当一个类首次使用时，其元数据被加载到元空间中。例如，首次创建一个对象。
- en: By default, the native memory available to the Metaspace is unlimited. A maximum
    Metaspace size is configurable using the JVM `–XX:MaxMetaspaceSize` flag. A threshold
    value or high-water mark can be set initially using the `–XX:MetaspaceSize` flag.
    If a threshold value is set and reached, this induces a run of the garbage collector.
    Using both JVM flags, `–XX:MinMetaspaceFreeRatio` and `–XX:MaxMetaspaceFreeRatio`,
    in conjunction with garbage collection results, we can dynamically influence the
    high-water mark and, therefore, the interval to the next run of the garbage collector.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，元空间可用的本地内存是无限的。可以使用JVM `–XX:MaxMetaspaceSize`标志配置最大元空间大小。可以使用`–XX:MetaspaceSize`标志最初设置一个阈值值或高水位标记。如果设置了阈值值并达到，这将引发垃圾收集器的运行。通过结合使用JVM标志`–XX:MinMetaspaceFreeRatio`和`–XX:MaxMetaspaceFreeRatio`以及垃圾收集结果，我们可以动态地影响高水位标记，因此影响垃圾收集器下一次运行的间隔。
- en: We saw, using an example, how the metadata for a class remains in Metaspace
    until the garbage collector deallocates the class loader that loaded that class.
    This cannot occur until all classes loaded by that class loader have no instances.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个例子看到了一个类的元数据如何保留在元空间中，直到垃圾收集器释放加载该类的类加载器。这只有在所有由该类加载器加载的类都没有实例时才能发生。
- en: Now that we have zoomed in on the Metaspace, we will turn our attention to the
    next chapter, which focuses on configuring and monitoring the memory management
    of the JVM.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经聚焦于元空间，我们将把注意力转向下一章，本章将重点介绍配置和监控JVM的内存管理。
