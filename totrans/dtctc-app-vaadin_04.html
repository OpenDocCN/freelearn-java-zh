<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Authentication and Authorization</h1>
                </header>
            
            <article>
                
<p class="mce-root">Authentication is the process that ensures the identity of a user, usually done by providing a set of identifying credentials (username and password). Authorization is the security process that determines the access levels a user has in the application. In this chapter, we will continue with the development of the login form implemented in <a href="f992404d-986b-42b9-893e-3667c122030f.xhtml" target="_blank">Chapter 3</a>, <em>Implementing Server-Side Components with Internationalization</em>, by adding authentication and authorization features. We'll also learn how to implement the <em>remember me</em> option in the login form.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>The HTTP session</li>
<li>Cookies management</li>
<li>Authorization and authentication mechanisms</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be<span> </span>required<span> </span>to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-04</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/RM8KNY">https://goo.gl/RM8KNY</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing public and private views</h1>
                </header>
            
            <article>
                
<p>Frequently, web applications have two main screens. One for visitors who are not authenticated, and one for users who are authenticated. It makes sense to implement the UI in a way that reflects this exactly. The idea is to create two custom components (using the <kbd>Composite</kbd> class); one for public access, and one for authenticated users. So, for now, let's suppose we have a custom <kbd>PublicComponent</kbd> class that shows the login form and a <kbd>PrivateComponent</kbd> that shows something like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2cee696c-3b6c-46f3-8d88-383c48c6e40f.png" style=""/></div>
<p>When the user is successfully authenticated, the <kbd>PrivateComponent</kbd> is shown. When the <span class="packt_screen">Logout</span> button is clicked, the user should be redirected to the <kbd>PublicComponent</kbd>. The Vaadin <kbd>UI</kbd> implementation (<kbd>VaadinUI</kbd> in this chapter's example) should reflect the fact that there are two main screens that can be shown depending on whether the user is authenticated or not.</p>
<p class="mce-root">The <kbd>init</kbd> method of the <kbd>UI</kbd> implementation should verify whether a user is authenticated already, and if so, show the <kbd>PrivateComponent</kbd>. Otherwise, it should show the <kbd>PublicComponent</kbd>. This is necessary to cover the case when the user reloads the page in the browser: we don't want the user to have to re-authenticate after a page reload. In plain Java, this functionality looks like the following:</p>
<pre>public class VaadinUI extends UI {

    static { Messages.addBundle("messages"); }

    @Override
    protected void init(VaadinRequest vaadinRequest) {
        if (<strong>AuthService.isAuthenticated()</strong>) {
            <strong>setContent(new PrivateComponent())</strong>;
        } else {
            <strong>setContent(new PublicComponent())</strong>;
        }
    }
}</pre>
<p>We'll develop the <kbd>AuthService</kbd> class in a bit, but the point in this section is to show you how simple the <kbd>UI</kbd> implementation can be. Always try to keep your <kbd>UI</kbd> implementation simple! Delegate to other classes the actual functionality of your application. Reflect only the essence of the top-level workflow of the application in your <kbd>UI</kbd> implementation. In our case, a simple class that shows one of two main screens, plus a sensible default depending on the authentication state, is enough.</p>
<p><span>One of the security features of Vaadin Framework is the fact that, by default, there's no way to access the execution of code by requesting different URLs. In the previous example, requesting <kbd>http://localhost:8080</kbd> will always invoke the <kbd>init</kbd> method, which gives us the chance to check whether the user is authenticated or not by asking a service class. </span>You might be wondering how the authentication state is kept on the server. The answer is the HTTP session.</p>
<div class="packt_infobox">You can learn more about security in Vaadin Framework applications at <a href="https://vaadin.com/security">https://vaadin.com/security</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the HTTP session and cookies to identify users</h1>
                </header>
            
            <article>
                
<p>One way of keeping track of the state of a web application is by making use of the HTTP session. The currently authenticated user is part of the state of the application and can be stored in the HTTP session. In Vaadin applications, you can store values in the HTTP session by using the <kbd>VaadinSession.setAttribute(String, Object)</kbd> method. The first parameter is a custom identifier for the value which is specified using the second parameter. For example, we can store the number <kbd>777</kbd> in an attribute with the name <kbd>number</kbd> in the HTTP session as follows:</p>
<pre>VaadinSession.getCurrent().<strong>setAttribute</strong>("<strong>number</strong>", <strong>777</strong>);</pre>
<p>You can remove the value from the session by passing <kbd>null</kbd>:</p>
<pre>VaadinSession.getCurrent().setAttribute("number", <strong>null</strong>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keeping track of authenticated users</h1>
                </header>
            
            <article>
                
<p>Following this approach, we can store the <kbd>username</kbd> in the HTTP session when a user is successfully authenticated. We can also check whether the user has been authenticated by checking whether a value exists in the HTTP session. This can be implemented as follows:</p>
<pre>public class <strong>AuthService</strong> {

    private static final String USERNAME_ATTRIBUTE = "username";

    public static boolean authenticate(
            String username, String password) {

        boolean authentic = <strong>"admin".equals(username)</strong> &amp;&amp;
                <strong>"admin".equals(password)</strong>;
 
        <strong>if (authentic)</strong> {
            <strong>VaadinSession.getCurrent().setAttribute(
                    USERNAME_ATTRIBUTE, username)</strong>;
        }

        return authentic;
    }

    public static boolean isAuthenticated() {
        return <strong>VaadinSession.getCurrent().getAttribute(
                USERNAME_ATTRIBUTE) != null</strong>;
    }
}</pre>
<p>There are a few things to notice here. First, for simplicity in this example, the code checks whether <kbd>username</kbd> and <kbd>password</kbd> are both equal to the string <kbd>"admin"</kbd>. In a real application, this should query a database or delegate to any other authentication process. For example, if you have a class that provides functionality to query user data, the Boolean check could look something like the following:</p>
<pre>User existingUser = userRepository.findByUsernameAndPassword(
        username, password);
boolean authentic = existingUser != null;</pre>
<div class="packt_tip"><span>Never store passwords in a way that they can be retrieved. In other words, always store <em>salted hashes</em> of passwords instead of the password itself. This can protect not only your users but also yourself! If you store a password as a hash of it, you can be sure that nobody, including you, can get to know the real password. If the database is compromised, </span>at<span> least the passwords are going to be garbage. Suppose you have a </span><kbd>hash</kbd><span> method that uses SHA or any other secure algorithm. When setting a password, you can save an entity with something like the following:</span><br/>
<kbd>user.setPassword(hash(theActualPassword));</kbd><br/>
<span>In order to check whether a password is correct (for example, during authentication), you can compare the hash of the given password with the value stored in the database. Something like the following:</span>
<ul>
<li class="mce-root"><kbd>String stored = user.getPassword();</kbd></li>
<li class="mce-root"><kbd>String hash = hash(attemptedPassword);</kbd></li>
<li class="mce-root"><kbd>if (stored.equals(hash) {...}</kbd></li>
</ul>
</div>
<p>Second, the<span> </span><kbd>AuthService</kbd><span> </span>class has Vaadin stuff in it. Service classes should be decoupled<span> </span>from<span> </span>the<span> </span>presentation<span> </span>technology, but in our case, that's okay, since there's not much chance of us changing the web framework! And that's usually the case in real-life applications anyway.<span> </span>Additionally, reusing this class out of the context of a Vaadin application doesn't seem very likely, but if it becomes<span> </span>necessary, you can decouple it from Vaadin by directly using the HTTP session.</p>
<div class="packt_tip">If your application allows third-party developers to add new functionality to your application and it exposes the HTTP session, developers might be able to impersonate a user if they know their username. Since the only condition for declaring a user as authenticated is to have an entry in the HTTP session with the<span> </span>corresponding<span> </span>username as its key, a malicious developer could add such a username and invoke other functionality on their behalf. In such cases, consider symmetrically<span> </span>encrypting<span> </span>the key (username) or even using an alternative storage<span> </span>mechanism<span> </span>for the HTTP session.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the login/logout process</h1>
                </header>
            
            <article>
                
<p>Let's recap what we have implemented at this point. We have a multi-language<span> </span><kbd>LoginFormComponent</kbd><span> </span>ready for use (developed in <a href="f992404d-986b-42b9-893e-3667c122030f.xhtml" target="_blank">Chapter 3</a><em>, Implementing Server-Side Components with Internationalization</em>), a<span> </span><kbd>UI</kbd><span> </span>implementation that shows a<span> </span><kbd>PublicComponent</kbd><span> </span>or a<span> </span><kbd>PrivateComponent</kbd><span>, </span>depending on whether a user is authenticated, and an<span> </span><kbd>AuthService</kbd><span> </span>class that allows us to authenticate a user (if their login credentials are correct) and<span> </span>check<span> </span>whether there is an authenticated user in the session or not.</p>
<p>It's time to complete the login/logout process by implementing the<span> </span><kbd>PublicComponent</kbd><span> </span>and<span> </span><kbd>PrivateComponent</kbd><span> </span>classes. Let's start with the<span> </span><kbd>PublicComponent</kbd><span> </span>class:</p>
<pre>public class <strong>PublicComponent</strong> extends Composite {

    public PublicComponent() {
        LoginFormComponent <strong>loginForm = new LoginFormComponent()</strong>;
        loginForm.setCaptions(
                Messages.get("auth.username"),
                Messages.get("auth.password"),
                Messages.get("auth.login"),
                Messages.get("auth.rememberMe"));

        loginForm.setLoginListener(form -&gt; <strong>loginClicked(form)</strong>);
        setCompositionRoot(<strong>loginForm</strong>);
    }

    private void <strong>loginClicked</strong>(LoginFormComponent form) {
        if (!AuthService.authenticate(
                form.getUsername(), form.getPassword())) {
            Notification.show(
                    Messages.get("auth.bad.credentials"),
                            Notification.Type.ERROR_MESSAGE);
        }
    }
}</pre>
<p>This component extends<span> </span><kbd>Composite</kbd><span> </span>and uses the<span> </span><kbd>LoginFormComponent</kbd><span> </span>as its composition root. The<span> </span><kbd>loginClicked</kbd><span> </span>method is called when the user clicks the respective button, and it's inside this method where we try to authenticate the user. If the credentials are correct, we show an error notification, but if they are correct, we are not doing anything at all! And actually, we don't really need to do anything else in this class. Do you<span> </span>remember<span> </span>how we implemented the<span> </span><kbd>VaadinUI</kbd><span> </span>class so that it would show one screen or the other according to the authentication state? Well, all we need to do in order to make this work is add a simple page reload to the<span> </span><kbd>AuthService.authenticate</kbd><span> </span>method for when the authentication<span> </span>succeeds:</p>
<pre>public class AuthService {

    private static final String USERNAME_ATTRIBUTE = "username";

    public static boolean authenticate(
            String username, String password) {

        boolean authentic = "admin".equals(username) &amp;&amp;
                "admin".equals(password);

        if (authentic) {
            VaadinSession.getCurrent().setAttribute(
                    USERNAME_ATTRIBUTE, username);
            <strong>Page.getCurrent().reload();</strong>
        }

        return authentic;
    }
    ...
}</pre>
<p>That's right!<span> </span>Since<span> </span>the<span> </span><kbd>VaadinUI.init</kbd><span> </span>method is called when the user refreshes the browser and our implementation checks whether there's an authenticated user in the HTTP session (via the<span> </span><kbd>AuthService</kbd><span> </span>class), we don't need to do anything else.</p>
<p>How about the other way around? When the user logs out, we should perform two actions:</p>
<ol>
<li>Remove all the data in the HTTP session (invalidate the session).</li>
<li>Refresh the browser (in order to invoke the<span> </span><kbd>VaadinUI.init</kbd><span> </span>method and automatically show the<span> </span><kbd>PublicComponent</kbd>).</li>
</ol>
<p>It's just reasonable to implement this functionality in the<span> </span><kbd>AuthService</kbd><span> </span>class:</p>
<pre>public class AuthService {
    ...

    public static void logout() {
        VaadinService.getCurrentRequest().getWrappedSession()
                .<strong>invalidate()</strong>;
        Page.getCurrent().<strong>setLocation("")</strong>;
    }
}</pre>
<p>The<span> </span><kbd>invalidate</kbd><span> </span>method removes any values from the HTTP session and invalidates it. The server will create a new session if the application is requested again.</p>
<div class="packt_tip">Servers maintain sessions in several ways, such as through cookies or URL rewriting. Depending on your specific server, you might have to call <kbd>VaadinService.reinitializeSession(VaadinService.getCurrentRequest())</kbd> to ensure a new session key is generated after you invalidate a session.</div>
<p>Notice how we reloaded the browser this time. Instead of calling the<span> </span><kbd>Page.reload()</kbd><span> </span>method, we are making sure that the URL in the browser requests the starting URL for the<span> </span>web application. This will also remove, for example, any fragments or parameters from the URL that may contain <em>sensitive information</em>.</p>
<div class="packt_infobox"><em>Sensitive information</em> refers to any kind of data, information, or knowledge that must be protected against unauthorized access.</div>
<p>Finally, the<span> </span><kbd>PrivateComponent</kbd><span> </span>class should be pretty straightforward to implement. For the sake of completeness, here's the code:</p>
<pre>public class PrivateComponent extends Composite {

    public PrivateComponent() {
        Label label = new Label(
                "User: " + <strong>AuthService.getAuthenticatedUser()</strong>);
        Button logOutButton = new Button(
                Messages.get("auth.logout"),e -&gt; <strong>logoutClicked</strong>());
        setCompositionRoot(new VerticalLayout(label,
                logOutButton));
    }

    private void logoutClicked() {
        <strong>AuthService.logout()</strong>;
    }
}</pre>
<p>Notice the<span> </span><kbd>AuthService.getAuthenticatedUser()</kbd><span> </span>method. You can implement that method with one line of code:</p>
<pre>public class AuthService { 
    ... 
 
    public static String getAuthenticatedUser() { 
        <strong>return (String) VaadinSession.getCurrent().getAttribute( 
                USERNAME_ATTRIBUTE)</strong>; 
    } 
} </pre>
<div class="packt_tip">Remember to use HTTPS (HTTP Secure) any time you have a web application with a login form that sends user credentials through the network. By enabling HTTPS, the data is encrypted, preventing man-in-the-middle attacks. You can learn more about how to enable HTTPS at <a href="https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate">https://vaadin.com/blog/enabling-https-in-your-java-server-using-a-free-certificate</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the remember me feature</h1>
                </header>
            
            <article>
                
<p>The <em>remember me</em> feature allows users to automatically authenticate themselves with the web application even after they have closed the browser, or the HTTP session has been destroyed, without having to enter their usernames and passwords. If a user has previously authenticated<span> </span>themselves<span> </span>and<span> </span>chose<span> </span>to be remembered, the web application will, remember the user using HTTP cookies.</p>
<p>Essentially, with the <em>remember me</em> feature, your application can consume two kinds of<span> </span><em>login credentials</em>:</p>
<ul>
<li>A username and password combination</li>
<li>A valid HTTP cookie previously created by the web application</li>
</ul>
<p>Let's think of the login/logout process, putting the <em>remember me</em> functionality into play this time. When a user requests the web application for the first time, the<span> </span><kbd>VaadinUI.init</kbd><span> </span>method is invoked. This method will check whether the user is authenticated or not in order to show the corresponding <kbd>UI</kbd> component. This is delegated to the<span> </span><kbd>AuthService</kbd><span> </span>class in our example. The<span> </span><kbd>AuthService.isAuthenticated</kbd><span> </span>method checks whether or not there's an authenticated user in the HTTP session.<span> </span>At first<span>, </span>there is none, so it should check whether the user was<span> </span><em>remembered</em><span> </span>before. Ignoring the details, we know the user was not remembered before. So the<span> </span><kbd>PublicComponent</kbd><span> </span>is shown and the user can log in with, username and password. But this time, the user checks the<span> </span><span class="packt_screen">Remember me</span><span> </span>checkbox.</p>
<p>We need to tell this<span> </span>choice<span> </span>to the<span> </span><kbd>AuthService.authenticate</kbd><span> </span>method (by passing a Boolean value from the checkbox), which in turn will check if the username and password are correct and, if so, perform the logic to<span> </span><em>remember</em><span> </span>the user. This is the interesting part.</p>
<p>A user is remembered by creating an HTTP cookie with the name, say<span> </span><kbd>remember-me</kbd>, and storing a value that<span> </span>allows<span> </span>us to identify the user later. We could be<span> </span>tempted<span> </span>to simply store the plain username in this cookie, but that would lead to a serious security issue; if a malicious user has access to the browser and gets the value of a<span> </span><kbd>remember-me</kbd><span> </span>cookie, they will be able to sign in as that user by simply creating a cookie with the stolen value.</p>
<p>Instead of storing <em>sensitive information</em> in the cookie, we can store a randomly generated string and store the username in the server using a Java<span> </span><kbd>Map</kbd>, where the key is the random string and the value is the username.</p>
<div class="packt_tip">Using a Java<span> </span><kbd>Map</kbd><span> </span>is good enough for the example in this chapter. However, keep in mind that if you restart the server, remembered users are no longer remembered (pun<span> </span>intended). A real-life application<span> </span>should use a persistent <kbd>Map</kbd>, such as an SQL table, but the principle is exactly the same. Additionally, you might want to store a hash of the random key, in the same way as you should do with user passwords. This will protect users if data in this table is compromised.</div>
<p>So, let's recap. The user logged in by providing their username and password and checking the<span> </span><span class="packt_screen">Remember me</span><span> </span>option, and the web application created a cookie containing a random key and stored the username in a<span> </span><kbd>Map</kbd><span> </span>using that key. Now, let's see what happens when the user closes the browser (or waits until the HTTP session is closed) and requests the web application again.</p>
<p>As usual, the<span> </span><kbd>VaadinUI.init</kbd><span> </span>method is invoked and the<span> </span><kbd>AuthService.isAuthenticated</kbd><span> </span>method checks whether there's an authenticated user in the HTTP session.<span> </span>Of course<span>, </span>there isn't, and it proceeds with the cookie check. This time, there is a<span> </span><kbd>remember-me</kbd><span> </span>cookie, so the method just<span> </span>searches<span> </span>for the username in the<span> </span><kbd>Map</kbd><span> </span>of remembered users and gets the value of the username. Now, it should just store the username in the HTTP session and return<span> </span><kbd>true</kbd>. The user was automatically authenticated!</p>
<p>The last part we need to consider is the<span> </span>logout<span> </span>action. When the<span> </span>user<span> </span>logs out, the<span> </span><kbd>remember-me</kbd><span> </span>cookie should be destroyed, along with the corresponding entry in the Java<span> </span><kbd>Map</kbd><span> </span>of remembered users.</p>
<p>I would urge you to try and implement all this by yourself. I have created a branch with the name<span> </span><kbd>remember-me-exercise</kbd><span> </span>in the source code that<span> </span>accompanies<span> </span>this book. You can use this branch as<span> </span>a<span> </span>starting point if you want to do the exercise. You can check it out by running:</p>
<pre>    cd Data-centric-Applications-with-Vaadin-8
    git checkout remember-me-exercise</pre>
<p>If you prefer to see the solution, just check the code in the<span> </span><kbd>master</kbd><span> </span>branch.</p>
<p>Let's see some snippets of code you could use for the exercise. Let's begin with HTTP cookies management. You can send a new cookie to the browser by using the<span> </span><kbd>VaadinRequest.addCookie</kbd><span> </span>method. The following snippet of code creates a new cookie with the name<span> </span><kbd>remember-me</kbd><span> </span>and the value<span> </span><kbd>admin</kbd><span> </span>and sends it to the browser:</p>
<pre>Cookie cookie = new Cookie("remember-me", "admin"); 
cookie.setPath("/"); 
cookie.setMaxAge(60 * 60 * 24 * 15); 
VaadinService.getCurrentResponse().addCookie(cookie); </pre>
<p>The <kbd>setPath</kbd> defines the path for the cookie. The browser sends the cookies associated with that path in subsequent requests to the server.</p>
<div class="packt_tip">Note that the path should include the servlet's context path. You can get it by calling <kbd>VaadinServlet.getCurrent().getServletContext().getContextPath()</kbd>.</div>
<p>The<span> </span><kbd>setMaxAge</kbd><span> </span>method allows you to set the time for which the cookie will be valid. The time is given in seconds, which means that the previous snippet creates a cookie valid for 15 days.</p>
<p>To delete a cookie, set its age to zero. For example, the following code removes the<span> </span><kbd>remember-me</kbd><span> </span>cookie:</p>
<pre>Cookie cookie = new Cookie("remember-me", ""); 
cookie.setPath("/"); 
cookie.<strong>setMaxAge(0)</strong>; 
VaadinService.getCurrentResponse().addCookie(cookie); </pre>
<p>You can get all the cookies reported by the<span> </span>browser<span> </span>by using the<span> </span><kbd>VaadinRequest.getCookies</kbd> method. You can get an instance of<span> </span><kbd>VaadinRequest</kbd><span> </span>via<span> </span><kbd>VaadinService.getCurrent()</kbd>. The following snippet of code retrieves an<span> </span><kbd>Optional</kbd><span> </span>of a cookie with the name<span> </span><kbd>remember-me</kbd>:</p>
<pre>Cookie[] cookies = VaadinService.getCurrentRequest().getCookies(); 
 
Optional&lt;Cookie&gt; cookie = Arrays.stream(cookies) 
        .filter(c -&gt; "remember-me".equals(c.getName())) 
        .findFirst(); </pre>
<p>Finally, here there's a tip to generate a random string suitable for the<span> </span><kbd>Map</kbd><span> </span>of remembered users:</p>
<pre>SecureRandom random = new SecureRandom(); 
String randomKey = new BigInteger(130, random).toString(32); </pre>
<p>In short, this converts a randomly generated<span> </span><kbd>BigInteger</kbd><span> </span>consisting of <kbd>130</kbd> bits and converts them into a sequence of base-32 characters. Although 128 bits is secure enough, a base-32 character can take five bits. <em>128/5 = 25.6</em>, so we need a couple of extra bits to get the next multiple of 5, which leads to <em>130/5=26</em>. In conclusion, we get 26 random characters. Keep in mind that UUIDs are not designed to be unpredictable and should not be used to identify sessions.</p>
<div class="packt_tip">A good implementation should also periodically clean the <kbd>Map</kbd> of remembered users. This can be achieved by adding a custom data type that stores not only the username<span> </span>but the expiry date. A background process can run every day, checking for expired entries and removing them from the <kbd>Map</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling features according to a user's roles</h1>
                </header>
            
            <article>
                
<p>This<span> </span>section<span> </span>discusses authorization<span> implementation </span>strategies. Authorization is the process of granting access to resources according to a defined policy. Keep in mind that <em>authentication</em><span> </span>is the process of verifying if a user or another system is who they<span> </span>claim<span> </span>they are, <em>authorization</em><span> </span>deals with what a certain user can do.</p>
<p>Authorization mechanisms can be implemented in many ways depending on the specific requirements of an application. Some applications use a basic public/private approach (like the one we have used so far in this chapter) where the policy is as simple as checking if a user is authenticated in order to grant access to a certain UI component. Other applications may require multiple roles, each one with a different set of permissions. Moreover, a user may have multiple roles at the same time and those roles could change at runtime. And to make it a bit more complicated, a role could define a set of permissions that could also change at runtime.</p>
<p>Depending on the complexity of the authentication rules that your application must support, you would use one or another approach to authorization. Let's discuss some of them, which, hopefully, will inspire you and give you ideas about how to implement an authorization<span> </span>mechanism<span> </span>suitable for your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding authorization logic in UI components</h1>
                </header>
            
            <article>
                
<p>The first approach we will discuss is including the authorization logic in the UI components themselves. This is what we have done in the example application, where we show a<span> </span><kbd>PrivateComponent</kbd><span> </span>if the user is authenticated or a<span> </span><kbd>PublicComponent</kbd><span> </span>if they are not. You can extrapolate this and use it with, for example, roles. Suppose there were two roles:<span> </span><em>employee</em><span> </span>and<span> </span><em>admin</em>. You have to show a<span> </span>hypothetical<span> </span><kbd>AdminComponent</kbd><span> </span>to users with the role admin and an<span> </span><kbd>EmployeeComponent</kbd><span> </span>to users with the<span> </span><em>employee</em> role. You can easily code a method that returns the right component according to the role as follows:</p>
<pre>private Optional&lt;Component&gt; getComponent(User user) {

    if (user.getRole().<strong>equals(Role.Admin)</strong>) {
        <strong>return new AdminComponent()</strong>;

    } else if (user.getRole().<strong>equals(Role.Employee)</strong>) {
        <strong>return new EmployeeComponent()</strong>;
    }

    return Optional.empty();
}</pre>
<p>If a new<span> </span><kbd>Role</kbd><span> </span>appears in future, you can simply add another<span> </span><kbd>if</kbd><span> </span>clause to cover the case.</p>
<p>What if there's no need for a completely new UI component for a role? For example, let's say the<span> </span><kbd>EmployeeComponent</kbd><span> </span>must show a<span> </span><em>delete</em><span> </span>button only for users with the <em>employee</em> role, and so<em> </em>not for users with the <em>trainee</em> role. The easier solution is to code this logic inside the<span> </span><kbd>EmployeeComponent</kbd><span> </span>class itself, using something like the following:</p>
<pre>public class <strong>EmployeeComponent</strong> extends Composite {
    public EmployeeComponent() {
        ...

        User user = AuthService.getCurrentUser();

        if (user.getRole().<strong>equals(Role.Employee)</strong>) {
            Button delete = new Button();
            someLayout.<strong>addComponent(delete)</strong>;
        }
        ...
    }
}</pre>
<p>A good thing about this approach is that you can follow the code to understand what's visible and what's not. However, you might end up with authorization code all over the source code. Well, at least over the UI-related classes. This is, however,<span> </span>a valid approach and you should at least consider it.</p>
<p>A disadvantage of this way of implementing authorization is that<span> </span>it couples<span> </span>UI code with<span> </span>authorization code. This makes it a bit more difficult for software reuse. The preceding class, for example, cannot be used in a different application without carrying the<span> </span><kbd>AuthService</kbd><span> </span>class.<span> </span>Fortunately,<span> </span>we can easily decouple this class from the authentication stuff. The key is the<span> </span><em>principle of least privilege</em>.</p>
<p>The principle of least privilege states<span> </span>that<span> </span>a software entity should have access to the least or minimum amount of data it requires to perform its function. Can you see how the<span> </span><kbd>EmployeeComponent</kbd><span> </span>class violates this principle? All the class needs to know is whether to show the<span> </span><kbd>delete</kbd><span> </span>button or not. It doesn't really care about roles and authentication<span> </span>logic. We are passing way too much information to it. What's the minimal amount of information this class needs to<span> </span>fulfill<span> </span>its requirements? A simple Boolean telling it whether to show the<span> </span><kbd>delete</kbd><span> </span>button or not. That's it. A possible implementation can include a parameter in the constructor for this purpose. Here's an example:</p>
<pre>public class EmployeeComponent extends Composite { 
    public EmployeeComponent(<strong>boolean showDeleteButton</strong>) { 
        ... 
 
        if (<strong>showDeleteButton</strong>) { 
            Button delete = new Button(); 
            someLayout.addComponent(delete); 
            ... 
        } 
        ... 
    } 
} </pre>
<p>We just removed the coupling between this class and the authentication logic. However, we moved the authentication logic somewhere else. Now the client of the<span> </span><kbd>EmployeeComponent</kbd><span> </span>class must configure it depending on the authorization rules. It's not such a bad<span> </span>thing<span> </span>considering that such a client is already coupled to the<span> </span><kbd>AuthService</kbd><span> </span>class, right? Take a look at the new implementation:</p>
<pre>private Optional&lt;Component&gt; getComponent(User user) { 
 
    if (user.getRole().equals(Role.Admin)) { 
        return new AdminComponent(); 
 
    } else if (user.getRole().<strong>equals(Role.Employee)</strong>) { 
        return new EmployeeComponent(<strong>true</strong>); 
 
    } else if (user.getRole().<strong>equals(Role.Trainee)</strong>) { 
        return new EmployeeComponent(<strong>false</strong>); 
    } 
 
    return Optional.empty(); 
} </pre>
<div class="packt_infobox">The<span> </span><kbd>Optional</kbd><span> </span>class serves as a container for a value that may or may not be<span> </span><kbd>null</kbd><span> </span>(we are not talking about a Vaadin<span> </span><kbd>Container</kbd><span> </span>here; the<span> </span><kbd>Container</kbd><span> </span>interface was removed in Vaadin Framework 8.0).<span> </span><kbd>Optional</kbd><span> </span>helps<span> </span>to decrease<span> </span>the<span> </span>number<span> </span>of null checks in your code. Instead of returning a null value from a method, you can return an<span> </span><kbd>Optional</kbd><span>, </span>which is empty when the enclosing value is null. This way, the client of the method knows that the returned value might be null. Bear in mind that the original purpose of the<span> </span><kbd>Optional</kbd><span> </span>class is to serve as an<span> </span><em>optional return value</em>. Avoid using<span> </span><kbd>Optional</kbd><span> </span>in method<span> </span>parameters.</div>
<p>The main takeaway of this discussion is to keep in mind that you can provide configuration options for your UI components. Don't just unnecessarily couple them with authentication classes. Provide parameters in the constructors, setters, or even configuration classes if the complexity requires it in order to tell the UI component how it should look and behave.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding authorization using request data</h1>
                </header>
            
            <article>
                
<p>Let's study a strategy to implement authorization outside UI components. Web frameworks can be classified as:</p>
<ul>
<li>Component-based<span> </span>frameworks</li>
<li>Request/response-based frameworks</li>
</ul>
<p>Vaadin Framework is a<span> </span>component-based<span> </span>framework. It abstracts away the concept of request and response. You don't have to<span> </span>think<span> </span>much about it when developing a Vaadin application, and that's one of the key features of the framework. Thanks to its ability to allow developers to implement a web application by directly using the Java programming language, developers can use any object-oriented technique to implement features such as authorization. In fact,<span> </span>in the previous section<span>, </span>we explored how to do so using simple Java<span> </span><kbd>if</kbd><span> </span>statements.</p>
<p>Request/response based frameworks, on the other hand, usually make it a bit harder to use the approach we discussed in the previous section (coding the authorization logic directly in the UI component), in part because the UI layer runs in the client side. Coding authentication rules in the client side is a no-go. How do request/response based frameworks implement authorization?<span> </span>Typically, these frameworks include a<span> </span><em>front controller</em>, a software entity that processes all the requests and decides which portion of your code should be invoked. It's then easy to add a<span> </span><em>filter</em><span> </span>to secure the requested resources according to a set of rules. In short, authorization is implemented with a combination of server-side code (which decides what to show in the browser) and a filter securing URLs according to authorization rules.</p>
<p>Can we use something similar with Vaadin? Let's explore the capabilities of Vaadin regarding<span> </span><em>request information</em><span> </span>to see how we can take<span> </span>advantage<span> </span>of it in order to design an authentication<span> </span>mechanism<span> </span>that is completely decoupled from the actual UI components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting request information</h1>
                </header>
            
            <article>
                
<p>When we talk about a <em>request</em><span> made </span>to<span> </span>a web application, we are talking about an HTTP request that a client, typically, a browser, makes to the web server. The server takes the<span> </span><em>context path</em><span> </span>and routes the request to the appropriate web application (for example, a Vaadin application). An important part of the HTTP request is the URL used to access the application and its resources. The following screenshot shows the most important parts of a URL:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0a9e9017-03a0-410a-ba27-eba4252c93a2.png" style=""/></div>
<p>With Vaadin Framework you can get access to all these parts.<span> </span>For example<span>, </span>in order to get the<span> </span><em>path info</em><span> </span>part of the URL, you can call:</p>
<pre>String pathInfo = VaadinRequest.getCurrent().getPathInfo(); 
assert(pathInfo.equals("users")); </pre>
<p>To get a<span> </span><em>parameter</em><span> </span>value, you can call:</p>
<pre>String name = VaadinRequest.getCurrent().getParameter("name"); 
assert(name.equals("Alejandro")); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing requests to a UI component</h1>
                </header>
            
            <article>
                
<p>Using the<span> </span><em>path info</em><span> </span>part and<span> </span><em>parameters</em>, you can already implement a<span> </span>mechanism<span> </span>that<span> </span><em>routes</em><span> </span>a request to a specific component, similarly to what a front controller does in a request/response-based framework. For example:</p>
<pre>public class FrontController { <br/>    public static void <strong>route</strong>(VaadinRequest request, 
        SingleComponentContainer container) { 
 
        String path = request.getPathInfo(); 
 
        if (<strong>"users".equals(path)</strong>) { 
            container.<strong>setContent(new UsersComponent())</strong>; 
 
        } else if (<strong>"orders".equals(path)</strong>) { 
            container.<strong>setContent(new OrdersComponent())</strong>; 
 
        } else { ... }         
    } 
} </pre>
<p>And the corresponding<span> </span><kbd>UI</kbd><span> </span>implementation could look like this:</p>
<pre>public class VaadinUI extends UI { 
    @Override 
    protected void init(VaadinRequest request) { 
        FrontController.<strong>route</strong>(request, this); 
    } 
} </pre>
<p>The<span> </span><kbd>FrontController</kbd><span> </span>class can invoke any authorization logic in order to decide whether the current user can see a<span> </span><kbd>UI</kbd><span> </span>component or not before routing the request to a<span> </span><kbd>UI</kbd><span> </span>component. For example:</p>
<pre>public class FrontController { <br/>    public static void route(VaadinRequest request, 
        SingleComponentContainer container) { 
         
        String path = request.getPathInfo(); 
 
        if (<strong>!AuthService.userCanAccess(path)</strong>) { 
            container.setContent(new ErrorComponent( 
                <strong>"Access denied."</strong>)); 
            return; 
       } 
 
       ... 
    } 
} </pre>
<p>The<span> </span><kbd>AuthService.userCanAccess</kbd><span> </span>method can be implemented in various ways:</p>
<ol>
<li>A set of<span> </span><kbd>if</kbd>/<kbd>else</kbd><span> </span>statements checking each path/role combination</li>
<li>A check on a Java<span> </span><kbd>Map</kbd><span> </span>where each key is a path and each value is a<span> </span><kbd>Set</kbd><span> </span>of the allowed roles for that path</li>
<li>A check<span> with</span><span> </span>an external resource (such as an SQL database, web service, or <kbd>properties</kbd> file)</li>
<li>An algorithm combining the previous alternatives</li>
</ol>
<p>Implementing each of these solutions would take too much space in the book, and it's also more related to Java than Vaadin itself, so I'll let you decide how to implement this method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding authorization with the help of a Navigator</h1>
                </header>
            
            <article>
                
<p>You might have heard about the<span> </span><kbd>Navigator</kbd><span> </span>class in Vaadin Framework. In short, the <kbd>Navigator</kbd> class allows you to pair URI fragments with UI components. When the fragment part changes in the browser, the associated UI component is rendered. It also allows you to<span> </span>programmatically<span> </span><em>navigate</em><span> </span>to a specific UI component by specifying its associated fragment. For example:</p>
<pre>public class VaadinUI extends UI { 
    @Override 
    protected void init(VaadinRequest vaadinRequest) { 
        Navigator navigator = new Navigator(<strong>this</strong>, <strong>this</strong>); 
         
        navigator.addView("view1", <strong>new View1()</strong>); 
        navigator.addView("view2", new View2()); 
    } 
} </pre>
<p>When you create a<span> </span><kbd>Navigator</kbd>, you specify the<span> </span><kbd>UI</kbd><span> </span>to which the<span> </span><kbd>Navigator</kbd><span> </span>is attached and a<span> </span><kbd>ComponentContainer</kbd><span> </span>(such as<span> </span><kbd>VerticalLayout</kbd>, for example), whose content will be replaced when the view is made visible (when changing the fragment in the browser, for<span> </span>example). You associate <em>view names</em> to UI components by using the <kbd>addView</kbd> method. In the previous example, we passed instances of the UI components (using the <kbd>new</kbd> keyword). The <kbd>Navigator</kbd> class will use these instances throughout the session, so the state of each view is maintained even after navigating away from a view. You can let the <kbd>Navigator</kbd> class create a new instance of the UI component each time the view is requested by using the overloaded <kbd>addView(String, Class&lt;? extends View&gt;)</kbd> method. Here's an example:</p>
<pre>navigator.addView("view1", <strong>View1.class</strong>);</pre>
<p>The UI components you can add to a<span> </span><kbd>Navigator</kbd><span> </span>must implement the<span> </span><kbd>View</kbd><span> </span>interface, as shown in the following class:</p>
<pre>public class View1 extends Composite <strong>implements View</strong> { 
    public View1() { 
        setContent(new Label("View 1")); 
    } 
}</pre>
<div class="packt_infobox">Since Vaadin Framework 8.0, the<span> </span><kbd>View</kbd><span> </span>interface includes a Java 8<span> </span><em>default </em><kbd>enter</kbd><span> </span>method so you don't have to implement it. Vaadin Framework 8.1 includes some additional default methods you can implement if needed. Take a look at the reference API of the<span> </span><kbd>View</kbd><span> </span>interface for more information:<span> </span><kbd><span class="URLPACKT">https://vaadin.com/api/8.3.2/com/vaadin/navigator/View.html</span></kbd>.</div>
<p>But let's get back to the discussion of authorization strategies. The<span> </span><kbd>Navigator</kbd><span> </span>class allows you to add a<span> </span><kbd>ViewChangeListener</kbd>. We can use this listener to introduce authorization rules and<span> </span><em>secure</em><span> </span>UI components. For example:</p>
<pre>public class AuthViewListener <strong>implements ViewChangeListener</strong> { 
 
    @Override 
    public boolean <strong>beforeViewChange</strong>(ViewChangeEvent event) { 
        if (AuthService.userCanAccess(event.getViewName())) { 
            return true; 
        } 
 
        return false; 
    } 
} </pre>
<p>The<span> </span><kbd>beforeViewChange</kbd><span> </span>method must return<span> </span><kbd>true</kbd><span> </span>to allow the view change and<span> </span><kbd>false</kbd><span> </span>to block it.</p>
<div class="packt_infobox">Vaadin Framework 8.0 added support for the<span> </span><em>HTML 5 History API</em>. With it, you can avoid having<span> </span><em>hashbangs</em><span> </span>in the URL (that little<span> </span><kbd>!#</kbd><span> </span>sequence). Vaadin Framework 8.2 added support for the HTML 5 History API with the<span> </span><kbd>Navigator</kbd><span> </span>class. You can activate this support by annotating the<span> </span><kbd>UI</kbd><span> </span>implementation with<span> </span><kbd>@PushStateNavigation</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter<span>, </span><span>we</span> <span>learned how to keep track of authenticated users by using the HTTP session. We also learned how to implement the <em>remember me</em> feature by using cookies in a secure way. Finally, we discussed</span><span> </span><span>authorization strategies, including coding authorization logic</span><span> </span>directly<span> </span><span>in UI components and coding it by using request data.</span></p>
<div>
<p>In the next chapter<span>, </span>you will learn about how to connect to SQL databases using multiple Java persistence frameworks with Vaadin.</p>
</div>


            </article>

            
        </section>
    </body></html>