<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Aspect-Oriented Programming and Components</h1>
                </header>
            
            <article>
                
<p class="mce-root">Often in programming, we see pieces of source code that are repeated in different methods. In some cases, we could refactor our code and move them to separate modules. Sometimes, however, this is not possible. Some notable examples include logging and verification. Aspect-oriented programming is helpful in such cases, and we will get an understanding of it by the end of this chapter.</p>
<p>Components are reusable pieces of code that provide a number of services and have some requirements. They are extremely useful for avoiding code duplication, and of course, for promoting code reuse. Here, we will see how to build components and how Scala makes the writing and use of components easier than other languages.</p>
<p>While getting familiar with aspect-oriented programming and components, we will go through the following top-level topics:</p>
<ul>
<li>Aspect-oriented programming</li>
<li>Components in Scala</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Aspect-oriented programming</h1>
                </header>
            
            <article>
                
<p><strong>Aspect-oriented programming</strong> (<strong>AOP</strong>) addresses a common functionality, that spans across an application, but cannot be otherwise abstracted in a single module using traditional object-oriented techniques. This repeated functionality is often referred to as <em>cross-cutting concerns</em>. A common example is logging—normally, loggers are created within classes and then their methods are called inside the methods of the classes. This helps with the debugging and tracing of events in an application, but it is not really related to the actual functionality in any way.</p>
<p>AOP recommends that cross-cutting concerns are abstracted and encapsulated in their own modules. In the next few subsections, we will look into how AOP improves code and also makes cross-cutting concerns easily extendible.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding application efficiency</h1>
                </header>
            
            <article>
                
<p>An important part of every program is efficiency. In many cases, we can time our methods and find bottlenecks in our applications. Let's look at an example program that we will try and time afterwards.</p>
<p>We will have a look at parsing. In many real-life applications, we have to read data in specific formats and parse it to the objects in our code. For this example, we will have a small database of people represented in a JSON format:</p>
<pre>[<br/>  {<br/>    "firstName": "Ivan",<br/>    "lastName": "Nikolov",<br/>    "age": 26<br/>  },<br/>  {<br/>    "firstName": "John",<br/>    "lastName": "Smith",<br/>    "age": 55<br/>  },<br/>  {<br/>    "firstName": "Maria",<br/>    "lastName": "Cooper",<br/>    "age": 19<br/>  }<br/>]</pre>
<p>To represent this JSON in Scala, we have to define our model. It will be simple and contain only one class—<kbd>Person</kbd>. Here is the code for it:</p>
<pre>case class Person(firstName: String, lastName: String, age: Int)</pre>
<p class="mce-root">Since we will be reading JSON inputs, we will have to parse them. There are many parsers out there, and everyone might have their own preferences. In the current example, we have used json4s (<a href="https://github.com/json4s/json4s">https://github.com/json4s/json4s</a>). We have the following extra dependency in our <kbd>build.sbt/pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.json4s&lt;/groupId&gt;<br/>    &lt;artifactId&gt;json4s-jackson_2.12&lt;/artifactId&gt;<br/>    &lt;version&gt;3.6.0-M2&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>The following shows the <kbd>build.sbt</kbd> equivalent of the <kbd>pom.xml</kbd> version:</p>
<pre>"org.json4s" %% "json4s-jackson" % "3.6.0-M2"</pre>
<p>We have written a class with two methods that parses an input file of the given preceding format and returns a list of <kbd>Person</kbd> objects. These two methods do exactly the same thing, but one of them is more efficient than the other one:</p>
<pre>import org.json4s._<br/>import org.json4s.jackson.JsonMethods._<br/><br/>trait DataReader {<br/>  def readData(): List[Person]<br/>  def readDataInefficiently(): List[Person]<br/>}<br/><br/>class DataReaderImpl extends DataReader {<br/>  implicit val formats = DefaultFormats<br/>  <br/>  private def readUntimed(): List[Person] =<br/>    parse(StreamInput(getClass.getResourceAsStream("/users.json"))).extract[List[Person]]<br/><br/>  override def readData(): List[Person] = readUntimed()<br/><br/>  override def readDataInefficiently(): List[Person] = {<br/>    (1 to 10000).foreach {<br/>      case num =&gt;<br/>        readUntimed()<br/>    }<br/>    readUntimed()<br/>  }<br/>}</pre>
<p>The <kbd>DataReader</kbd> trait acts as an interface, and using the implementation is quite straightforward:</p>
<pre>object DataReaderExample {<br/>  def main(args: Array[String]): Unit = {<br/>    val dataReader = new DataReaderImpl<br/>    System.out.println(s"I just read the following data efficiently:<br/>     ${dataReader.readData()}")<br/>    System.out.println(s"I just read the following data inefficiently:<br/>     ${dataReader.readDataInefficiently()}")<br/>  }<br/>}</pre>
<p>It will produce output as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0c0e55e4-a5e0-406b-bfb0-cf40354c48cf.png" width="719" height="109"/></div>
<p>The preceding example is clear. However, what if we want to optimize our code and see what causes it to be slow? The previous code does not give us this possibility, so we will have to take some extra steps in order to time and see how our application performs. In the following subsections, we will show how this is done without and with AOP.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Timing our application without AOP</h1>
                </header>
            
            <article>
                
<p>There is a basic way to do our timing. We could either surround the <kbd>println</kbd> statements in our application, or add the timing as a part of the methods in the <kbd>DataReaderImpl</kbd> class. Generally, adding the timing as part of the methods seems like a better choice as in some cases, these methods could be called at different places and their performance would depend on the passed parameters and other factors. Considering what we said, this is how our <kbd>DataReaderImpl</kbd> class could be refactored in order to support timing:</p>
<pre>import org.json4s._<br/>import org.json4s.jackson.JsonMethods._<br/><br/>class DataReaderImpl extends DataReader {<br/> implicit val formats = DefaultFormats<br/> <br/> private def readUntimed(): List[Person] =<br/>  parse(StreamInput(getClass.getResourceAsStream("/users.json")))<br/>  .extract[List[Person]]<br/><br/> override def readData(): List[Person] = {<br/>   val startMillis = System.currentTimeMillis()<br/>   val result = readUntimed()<br/>   val time = System.currentTimeMillis() - startMillis<br/>   System.err.println(s"readData took ${time} milliseconds.")<br/>    result<br/> }<br/><br/> override def readDataInefficiently(): List[Person] = {<br/>   val startMillis = System.currentTimeMillis()<br/>   (1 to 10000).foreach {<br/>     case num =&gt;<br/>      readUntimed()<br/>   }<br/>   val result = readUntimed()<br/>   val time = System.currentTimeMillis() - startMillis<br/>   System.err.println(s"readDataInefficiently took ${time} milliseconds.")<br/>   result<br/> }<br/>}</pre>
<p>As you can see, the code becomes quite unreadable and the timing interferes with the actual functionality. In any case, if we run our program, the output will show us where the problem is:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/de830a48-ec2f-4a67-9142-88b67d451c83.png" width="721" height="146"/></div>
<p>We will see how to improve our code using aspect-oriented programming in the next subsection.</p>
<div class="packt_infobox">In the previous example, we used <kbd>System.err.println</kbd> to log the timing. This is just for example purposes. In practice, using loggers, for example <strong>slf4j</strong> (<a href="https://www.slf4j.org/">https://www.slf4j.org/</a>), is the recommended option, as you can have different logging levels and switch logs using configuration files. Using loggers here would have added extra dependencies and it would have pulled your attention away from the important material.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Timing our application with AOP</h1>
                </header>
            
            <article>
                
<p>As we saw, adding our timing code to our methods introduces code duplication and makes our code hard to follow, even for a small example. Now, imagine that we also have to do logging and other activities. Aspect-oriented programming helps in separating these concerns.</p>
<p>We can revert the <kbd>DataReaderImpl</kbd> class to its original state, where it does not do any logging. Then, we create another trait called <kbd>LoggingDataReader</kbd>, which extends from <kbd>DataReader</kbd> and has the following contents:</p>
<pre>trait LoggingDataReader extends DataReader {<br/><br/>  abstract override def readData(): List[Person] = {<br/>    val startMillis = System.currentTimeMillis()<br/>    val result = super.readData()<br/>    val time = System.currentTimeMillis() - startMillis<br/>    System.err.println(s"readData took ${time} milliseconds.")<br/>    result<br/>  }<br/><br/>  abstract override def readDataInefficiently(): List[Person] = {<br/>    val startMillis = System.currentTimeMillis()<br/>    val result = super.readDataInefficiently()<br/>    val time = System.currentTimeMillis() - startMillis<br/>    System.err.println(s"readDataInefficiently took ${time} milliseconds.")<br/>    result<br/>  }<br/>}</pre>
<p>Something interesting here is the <kbd>abstract override</kbd> modifier. It notifies the compiler that we will be doing stackable modifications. If we do not use this modifier, our compilation will fail with the following errors:</p>
<pre>Error:(9, 24) method readData in trait DataReader is accessed from super. It may not be abstract unless it is overridden by a member declared `abstract' and `override'<br/>    val result = super.readData()<br/>                       ^<br/>Error:(17, 24) method readDataInefficiently in trait DataReader is accessed from super. It may not be abstract unless it is overridden by a member declared `abstract' and `override'<br/>    val result = super.readDataInefficiently()<br/>                       ^</pre>
<p>Now, let's use our new trait using a mixin composition, which we already covered earlier in this book, in the following program:</p>
<pre>object DataReaderAOPExample {<br/>  def main(args: Array[String]): Unit = {<br/>    val dataReader = new DataReaderImpl with LoggingDataReader<br/>    System.out.println(s"I just read the following data efficiently:<br/>     ${dataReader.readData()}")<br/>    System.out.println(s"I just read the following data inefficiently:<br/>     ${dataReader.readDataInefficiently()}")<br/>  }<br/>}</pre>
<p>If we run this program, we will see that, as before, our output will contain the timings.</p>
<p>The advantage of using aspect-oriented programming is clear—the implementation is not contaminated by other code, which is irrelevant to it. Moreover, we can add extra modifications using the same approach—more logging, retry logic, rollbacks, and so on. Everything happens by just creating new traits that extend <kbd>DataReader</kbd> and mixing them in, as shown previously. Of course, we can have multiple modifications applied at the same time that will execute in order, and the order of their execution will follow the rules of linearization, which we are already familiar with.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Components in Scala</h1>
                </header>
            
            <article>
                
<p>Components are parts of an application that are meant to be combined with other parts of the application. They should be reusable in order to achieve less code duplication. Components typically have interfaces, which describe the services they provide and a number of services or other components they depend on.</p>
<p>In large applications, we usually see multiple components that are integrated to work together. Describing the services that a component provides is usually straightforward, and it is done with the help of interfaces. Integrating other components, however, could sometimes require a developer to do extra work. This is usually done by passing the interface of the requirement as a parameter. However, imagine a large application in which we might have a lot of requirements; wiring things up could take time and effort. Moreover, every time a new requirement comes up, we would have to do quite a lot of refactoring. An alternative to parameters is multiple inheritance; however, the language needs to support it in some way.</p>
<p>A popular way to wire components up in languages such as Java is through dependency injection. There are libraries that exist in Java that can be used in order to inject components into each other during runtime.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Scala's expressive power to build components</h1>
                </header>
            
            <article>
                
<p>We have already said a few times in this book that Scala is a much more expressive language than the simply object-oriented ones. We already looked into concepts such as abstract types, self types, unification, and mixin compositions. They allow us to create generic code, require specific classes, and are able to treat objects, classes, variables, and functions in the same way and achieve multiple inheritance. Using different combinations of these would allow us to write the modular code we are looking for.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing components</h1>
                </header>
            
            <article>
                
<p>Dependency injection is quite popular to wire components up. However, in languages such as Java, this would mean that we require someone to use the same library as we do. Having a high number of parameters in the classes throughout our applications is also not acceptable. This makes it easier to make mistakes and turns refactoring and code extension into a nightmare.</p>
<p>In the next subsection, we will look into how Scala self types can be used in order to create and compose components.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Self types for components</h1>
                </header>
            
            <article>
                
<p>As an example, let's imagine that we are trying to build a robot that cooks food. Our robot will be able to look up recipes and cook the dishes we ask for, as well as tell us the time. We will be able to add extra functionality to our robot by simply creating new components.</p>
<p>We want our code to be modular, so it makes sense to split the functionality. The following diagram shows what our robot will look like and the relationships between the different components:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8b129cc6-5d6e-462a-8e1f-8f5cb39d4507.png" style="width:33.00em;height:17.42em;" width="673" height="354"/></div>
<p>First of all, let's define the interfaces for the different components:</p>
<pre>trait Time {<br/>  def getTime(): String<br/>}<br/><br/>trait RecipeFinder {<br/>  def findRecipe(dish: String): String<br/>}<br/><br/>trait Cooker {<br/>  def cook(what: String): Food<br/>}</pre>
<p>We need our <kbd>Food</kbd> class to be defined, and for this example, it will be as simple as this:</p>
<pre>case class Food(name: String)</pre>
<p>Once this is done, we can start creating our components. First is the <kbd>TimeComponent</kbd> and the implementation of <kbd>Time</kbd> in a nested class:</p>
<pre>trait TimeComponent {<br/>  val time: Time<br/><br/>  class TimeImpl extends Time {<br/>    val formatter = DateTimeFormatter.ofPattern("HH:mm:ss")<br/>    override def getTime(): String = s"The time is:<br/>     ${LocalDateTime.now().format(formatter)}"<br/>  }<br/>}</pre>
<p>Now, we can implement the <kbd>RecipeComponent</kbd> in a similar way. The following is the component code and the implementation code:</p>
<pre>trait RecipeComponent {<br/>  val recipe: RecipeFinder<br/><br/>  class RecipeFinderImpl extends RecipeFinder {<br/>    override def findRecipe(dish: String): String = dish match {<br/>      case "chips" =&gt; "Fry the potatoes for 10 minutes."<br/>      case "fish" =&gt; "Clean the fish and put in the oven for 30 minutes."<br/>      case "sandwich" =&gt; "Put butter, ham and cheese on the bread,<br/>       toast and add tomatoes."<br/>      case _ =&gt; throw new RuntimeException(s"${dish} is unknown recipe.")<br/>    }<br/>  }<br/>}</pre>
<p>Finally, we need to implement the <kbd>CookingComponent</kbd>. It actually requires a <kbd>RecipeComponent</kbd>. Here is how this is done:</p>
<pre>trait CookingComponent {<br/>  this: RecipeComponent =&gt;<br/><br/>  val cooker: Cooker<br/><br/>  class CookerImpl extends Cooker {<br/>    override def cook(what: String): Food = {<br/>      val recipeText = recipe.findRecipe(what)<br/>      Food(s"We just cooked $what using the following recipe:<br/>       '$recipeText'.")<br/>    }<br/>  }<br/>}</pre>
<p>Now, we have all the components separately implemented, and we can combine them in order to create our robot. We will create a component registry that the robot will use, as follows:</p>
<pre>class RobotRegistry extends TimeComponent with RecipeComponent with CookingComponent {<br/>  override val time: Time = new TimeImpl<br/>  override val recipe: RecipeFinder = new RecipeFinderImpl<br/>  override val cooker: Cooker = new CookerImpl<br/>}</pre>
<p>Let's now create a <kbd>Robot</kbd>:</p>
<pre>class Robot extends RobotRegistry {<br/>  def cook(what: String) = cooker.cook(what)<br/>  def getTime() = time.getTime()<br/>}</pre>
<p>An example program that uses our robot will look like the following:</p>
<pre>object RobotExample {<br/>  def main(args: Array[String]): Unit = {<br/>    val robot = new Robot<br/>    System.out.println(robot.getTime())<br/>    System.out.println(robot.cook("chips"))<br/>    System.out.println(robot.cook("sandwich"))<br/>  }<br/>}</pre>
<p>An example output of this program is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/401b7fb3-45a7-49ed-be72-a9ab8da0889e.png" width="722" height="127"/></div>
<p>In the preceding example, we saw the way Scala implements dependency injection that is easy to wire up without using extra libraries. This is really useful as it doesn't make our constructors large and we don't have to extend many classes as well. Moreover, the components we have are nicely separated, testable, and clearly define their requirements. We also saw how we can add requirements recursively using components that require other ones.</p>
<div class="packt_infobox">The preceding example is actually a representation of the <strong>cake design pattern</strong>. One of the nice features here is that the presence of dependencies is evaluated at compile time rather than at runtime, as popular Java libraries do.<br/>
<br/>
The cake design pattern has its drawbacks as well, but we will be focusing on all the features—good and bad ones—later in this book. This is where we will show how the components can be tested as well.</div>
<p>The cake design pattern example in this chapter is really simple. In real-life applications, we might have components that depend on other components, which have their own dependencies and so on. In such cases, things can get complicated. We will aim to showcase this better and in much more detail later in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked into aspect-oriented programming in Scala. We now know how to separate code that normally wouldn't be possible to move into modules. This will lead to avoiding code duplication and make our programs nice with different, specialized modules.</p>
<p>We also showed how to create reusable components using techniques we covered in the previous chapters of this book. Components provide interfaces and have specific requirements, which could be easily satisfied using the richness of Scala. They are really relevant to design patterns because they have the same purpose—to make the code better, avoid repetition, and be able to easily test it.</p>
<p>In the following chapters of this book, we will start looking at some concrete design patterns with their useful features and use cases. We will start with <em>creational design patterns</em> as they are defined by the <em>GoF</em>, but of course, from the Scala point of view.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  </body></html>