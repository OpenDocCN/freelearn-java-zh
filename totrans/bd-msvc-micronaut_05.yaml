- en: '*Chapter 3*: Working on RESTful Web Services'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any microservice development, one of the core aspects is how the microservice
    interfaces with the external world. `pet-clinic` application. For outgoing and
    incoming payloads to these endpoints, we will use **data transfer objects** (**DTOs**)
    in tandem with MapStruct to map DTOs to/from entities. For hands-on work, we will
    work to add restful endpoints to the following microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pet-owner`: Working hands-on to add HTTP GET, POST, PUT, and DELETE endpoints
    for `pet-owner` schema objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic`: Working hands-on to add HTTP GET, POST, PUT, and DELETE endpoints
    for `pet-clinic` schema objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-review`: Working hands-on to add HTTP GET, POST, PUT, and DELETE
    endpoints for the `pet-clinic-reviews` collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While working on the aforementioned microservices, we will dive into the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working on restful microservices in the Micronaut framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using DTOs for the endpoint payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating restful endpoints for a microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Micronaut's HTTP server APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Micronaut's HTTP client APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the practical know-how to work on
    restful web services in the Micronaut framework. This knowledge is important to
    work on the web layer of a microservice. Furthermore, we will also explore leveraging
    HTTP server objects and client objects in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and macOS. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK**: Version 8 or above (we used Java 14).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development IDE**: Based on your preferences, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL**: Instructions to download and install PostgreSQL can be found
    at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred, then instructions
    on how to download and install can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rest client**: Any HTTP REST client can be used. We used the Advanced REST
    Client Chrome plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on restful microservices in the Micronaut framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to learn about restful microservices in the Micronaut framework, we
    will continue working on the `pet-clinic` application. The following table summarizes
    the changes we will be making on each of the microservices in the `pet-clinic`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.1 – Microservices in the pet-clinic application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_3.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.1 – Microservices in the pet-clinic application
  prefs: []
  type: TYPE_NORMAL
- en: In each microservice, we will get hands-on with adding HTTP endpoints for performing
    CRUD operations on the data objects owned by them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our hands-on discussions, we will focus on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DTOs**: How DTOs can be used to encapsulate outgoing and incoming payloads
    for restful endpoints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: How services liaison with database repositories for any controller
    requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**: How controllers provide a standard restful interface for the
    external world in the Micronaut framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding to *Figure 2.2* of [*Chapter 2*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033),
    *Working on the Data Access*, the following are the components in this chapter
    within each microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Microservice components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Microservice components
  prefs: []
  type: TYPE_NORMAL
- en: We will continue with the separation of concerns by following the controller-service-repository
    pattern. For communications between the service and controller, we will explore
    DTOs. We will work in a bottom-up fashion while covering DTOs, services, and finally
    controllers. DTOs, mappers, services, and controllers follow the same approach,
    and therefore, to keep our discussion focused, we will target the `pet-owner`
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, our focal point will be DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: Using DTOs for the endpoint payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DTO pattern originates from the enterprise application architecture and
    fundamentally, data objects aggregate and encapsulate the data to transfer. Since
    in the microservices architecture an end client may need varied data from different
    persistence resources (such as invoice data along with user data), the DTO pattern
    is very effective in limiting calls to microservices for getting the desired projection
    of data. DTOs are also known as assembler objects since they assemble data from
    multiple entity classes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore how to implement and map (to an entity) DTOs.
    In the later sections, we will further dive into using DTOs as an effective mechanism
    to transfer data from and into a microservice. We will also look at how DTOs can
    help reduce the number of calls to microservices by assembling data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DTOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement a DTO, we will begin defining a DTO class for the pet owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `pet-owner` microservice project (created in *Chapter 2*, *Working
    on the Data Access*) in your preferred IDE. Add the `com.packtpub.micronaut.service.dto`
    package to contain all DTOs. We can define `OwnerDTO` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`OwnerDTO` is implementing the `Serializable` marker interface to mark that
    the DTO is serializable. Furthermore, in continuation of our earlier discussion
    on the assembler pattern, `OwnerDTO` will also contain a set of `PetDTO` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the similar POJO model, we can define DTOs for other entities in the
    `pet-owner` microservice, such as `PetDTO`, `VisitDTO`, and `PetTypeDTO` in the
    `com.packtpub.micronaut.service.dto` package.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will work on mapping these DTOs to database entities.
  prefs: []
  type: TYPE_NORMAL
- en: Using MapStruct to define mappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MapStruct** is a code generator that uses annotation processing to implement
    mappings between source and target Java classes. The implemented MapStruct code
    consists of plain method calls, therefore it''s type-safe and easy to read code.
    Since we don''t need to write code for these mappings, MapStruct is very effective
    in reducing the source code footprint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To map DTOs to entities and vice versa, we will use MapStruct in our `pet-owner`
    microservice. Since we are using Maven, we will have to add the following to the
    `pom.xml` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By importing MapStruct into the project, POM will allow us to leverage the
    MapStruct toolkit. Furthermore, for the Maven compiler, we will need to add MapStruct
    to `annotationProcessorPaths`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The annotation processing settings in POM will direct the Java annotation processor
    to generate source code for any mappings that are marked using MapStruct annotations.
    In addition, `jsr330` is specified as a default component model in the context
    of the Micronaut framework (in Spring, a Spring model is often used).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new package named `com.packtpub.micronaut.service.mapper`
    to contain all the mapper interfaces. To abstract out a generic entity mapper,
    we can declare the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EntityMapper` interface abstracts out object-to-object and list-to-list
    conversion methods. By extending this interface, we can easily define an interface
    to map `OwnerDTO` to the `Owner` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `OwnerMapper` interface extends `EntityMapper` and uses `PetMapper`. `PetMapper`
    is used to map a set of `PetDTO` instances to `Pet` entities. `PetMapper` can
    be defined using a very similar approach.
  prefs: []
  type: TYPE_NORMAL
- en: Adhering to the same approach, we can thus define `PetMapper`, `VisitMapper`,
    and `PetTypeMapper` for the `Pet`, `Visit`, and `PetType` entities, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have dived into DTOs and their mappings to corresponding entity classes.
    In the next section, we will zero down on the service changes concerning DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the services to use DTOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Working on
    the Data Access*, to simplify the discussion, we defined service methods that
    used entity classes directly. This approach is not recommended for a variety of
    reasons, including the fact that we end up colluding/coupling business logic with
    database entities or it can become hairy if a service method needs to use multiple
    entities. Put simply, we must separate the concerns by decoupling database entities
    from business-required data objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use DTOs in business services, we will need to modify abstracting interfaces.
    The `OwnerService` interface can be modified to use DTOs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `save()` method is modified to save `OwnerDTO` instead of the `Owner` entity.
    Also, `findAll()` and `findOne()` will return `OwnerDTO` instead of `Owner`.
  prefs: []
  type: TYPE_NORMAL
- en: Complying with the same approach, we can modify these service interfaces for
    other entities in the `pet-owner` microservice, that is, `PetService`, `PetTypeService`,
    and `VisitService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we modified abstracting service interfaces, we will have to modify implementing
    classes too. `OwnerServiceImpl` can be modified to use DTOs like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `save()` method will use `OwnerMapper` to convert `OwnerDTO` to the entity
    before the repository method is called. Similarly, fetch methods will convert
    `Owner` entities back to `OwnerDTO`s before returning the responses.
  prefs: []
  type: TYPE_NORMAL
- en: Following the same approach, we can modify `PetServiceImpl`, `PetTypeServiceImpl`,
    and `VisitServiceImpl`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have focused on DTOs and how we can easily use DTOs by mapping them
    on entity objects using the MapStruct framework. In the next section, we will
    center our attention on how to create restful endpoints for the `pet-owner` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the restful endpoints for a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Micronaut framework, we can create all commonly used HTTP methods,
    namely GET, PUT, POST, and DELETE. At the core, all HTTP concerns are encapsulated
    in the `io.micronaut.http` package. This package contains `HttpRequest` and `HttpResponse`
    interfaces. These interfaces are the bedrock of defining any HTTP endpoint. Using
    these standard implementations, we will cover all HTTP methods in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an endpoint for retrieving a list of resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an endpoint for fetching a list of resources, we can begin by adding
    the `com.packtpub.micronaut.web.rest` package to contain all controller resources.
    We will add a fetch all owners endpoint to the `OwnerResource` controller in the
    `pet-owner` microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things we need to ponder here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Controller`: This is a stereotype that marks `OwnerResource` as a restful
    controller and is exposed on the `/api` base URL.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Get`: This annotation is used to expose the `getAllOwners()` method on HTTP
    get over the relative URL of `/owners`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@ExecuteOn`: This annotation specifies to execute this GET request on the
    I/O thread pool. The value of the `@ExecuteOn` annotation can be any executor
    defined in `micronaut.executors`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HttpRequest`: `getAllOwners()` takes on `HttpRequest` as an input parameter.
    Often, `HttpRequest` is passed to trace and log details of the origin, for example,
    which IP address is submitting the request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pageable`: This is a standard interface in the `io.micronaut.data.model` package
    and is often used to pass pagination information in the request, for example,
    `…/api/owners?page=1&size=50&sort=(firstName)`. This pagination information is
    often optional and passed as query parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HttpResponse`: `getAllOwners()` returns `HttpResponse`, which is a generic
    interface and embodies a specific type of response within the example. In this
    example, it is returning `List<OwnerDTO>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PaginationUtil`: This is a custom class in the `com.packtpub.micronaut.util`
    package and it generates paged responses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can run the `pet-owner` service locally and by default, it will run on port
    `8080`. We can use any REST client and hit `http://localhost:8080/api/owners`
    and we will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Retrieving all owners'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Retrieving all owners
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, when we call the fetch all owners endpoint,
    we are not passing any pagination information to get all owners. Therefore, it
    will retrieve all the owners and their pet information from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an endpoint for retrieving a specific resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an endpoint for fetching a specific resource, we will add a method
    in `OwnerResource` to fetch a specific owner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things we need to ponder here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@PathVariable`: This is used to specify and match a path variable in the HTTP
    call. In the proceeding example, we are passing the owner ID as a path variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Optional`: In this example, we are returning an optional object. If the service
    can find an owner for the specified ID, then an `HTTP 200` response will be sent;
    otherwise, `HTTP 404` will be reverted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can run the `pet-owner` service locally and by default, it will run on port
    `8080`. We can use any rest client and by hitting `http://localhost:8080/api/owners/1`,
    we will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Retrieving a specific owner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Retrieving a specific owner
  prefs: []
  type: TYPE_NORMAL
- en: '`OwnerDTO` encapsulated the pet data as well so the response payload will fetch
    complete details about the owner with ID `1`. Furthermore, if any non-existing
    ID is passed to the proceeding HTTP request, then it will result in `HTTP 404`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Retrieving a non-existing owner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Retrieving a non-existing owner
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding API call, we tried to fetch an owner with the `123789` ID,
    but since we don't have an owner with this ID, it results in an `HTTP 404` `not
    found` response.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an endpoint for inserting a resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an endpoint to insert a resource, we will add an HTTP POST method
    to `OwnerResource` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to pay attention to here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Post`: `createOwner()` is exposed using the `@Post` annotation as an HTTP
    POST API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@ExecuteOn`: This annotation specifies to execute this POST request on the
    I/O thread pool.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Body`: The `@Body` annotation specifies that the `ownerDTO` method argument
    in `createOwner()` is bound to the body of the incoming HTTP POST request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Not null id check`: Using an `if` construct, we are quickly checking that
    the HTTP body doesn''t contain a payload with the ID already defined. This is
    a case of asserting a business validation and if it fails, then the API is throwing
    a bad request exception.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HttpResponse.created`: In the happy path scenario, the API will return `HTTP
    201` created. This response indicates that the request was executed successfully
    and a resource was created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can boot up the `pet-owner` microservice locally and hit an HTTP POST request
    in a rest client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Inserting an owner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Inserting an owner
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding HTTP POST call, we passed an owner object to be inserted in
    the HTTP body. As anticipated, the API call was successful and returned an `HTTP
    201` `created` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if we try to hit this HTTP POST method to create an owner that
    has an ID value already, then it will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Inserting an existing owner again'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Inserting an existing owner again
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try to insert an owner with an ID value in the body payload, then an
    `HTTP 500` internal server error is thrown with a message – `Internal Server Error:
    A new owner cannot already have an ID`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an endpoint for updating a resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an endpoint to update a resource, we will add an HTTP PUT method
    to `OwnerResource` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to ponder here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Put`: The `@Put` annotation exposes the `updateOwner()` method as an HTTP
    PUT API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@ExecuteOn`: This annotation specifies to execute this PUT request on the
    I/O thread pool. The I/O thread pool is a mechanism to achieve I/O concurrency
    by maintaining a quorum of threads waiting to be assigned the I/O requests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Body`: The `@Body` annotation specifies that the `ownerDTO` method argument
    in `createOwner()` is bound to the body of the incoming HTTP PUT request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Null id check`: Using an `if` construct, we are quickly checking that the
    HTTP body doesn''t contain a payload with a null ID. If the ID is null, then the
    API is throwing a bad request exception.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HttpResponse.ok`: In the happy path scenario, the API will return `HTTP 200`.
    This response indicates that the request was executed successfully and a resource
    was updated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can boot up the `pet-owner` microservice locally and hit an HTTP PUT request
    in a rest client like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Updating an owner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Updating an owner
  prefs: []
  type: TYPE_NORMAL
- en: In the HTTP PUT request, we requested to update a resource we just inserted
    previously. We are updating the address and city for this resource. As anticipated,
    the request was executed successfully and an `HTTP 200` response was returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to update a resource with a null ID, then it will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Updating a non-existing owner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Updating a non-existing owner
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding HTTP PUT call, we tried to update an owner with a null ID.
    An `HTTP 500` internal server error is thrown with a message – `Internal Server
    Error: Invalid id`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an endpoint for deleting a resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To exhibit deleting a resource, we can add an HTTP DELETE method to `OwnerResource`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to ponder here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Delete`: The `@Delete` annotation exposes the `deleteOwner()` method as an
    HTTP DELETE API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@ExecuteOn`: This annotation specifies to execute this PUT request on the
    I/O thread pool.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@PathVariable`: `@PathVariable` binds the ID parameter in the `deleteOwner()`
    method to the variable specified in the HTTP request URL.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HttpResponse.noContent`: In the happy path scenario, the API will return `HTTP
    204`. This response indicates that the request was executed successfully and there
    is no additional content in the response payload.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can boot up the `pet-owner` microservice locally and hit an HTTP DELETE
    request in a rest client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Deleting an owner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Deleting an owner
  prefs: []
  type: TYPE_NORMAL
- en: We requested to delete the owner that we inserted/updated in previous examples.
    As anticipated, the request was successful and an `HTTP 204` response was returned.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored how to create all different types of restful endpoints.
    This discussion paves our way into using Micronaut's HTTP server APIs. In the
    next section, we will cover some practical aspects of leveraging these server
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Micronaut's HTTP server APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Micronaut framework offers a non-blocking HTTP server based on Netty. These
    server APIs can be leveraged to address some useful microservice requirement scenarios.
    To do any hands-on work, we will continue with the `pet-owner` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the outset, we must have the following Maven dependency in the project POM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This dependency should already be in the `pet-owner` project. In the next sections,
    we will explore some useful configurations in the HTTP server world.
  prefs: []
  type: TYPE_NORMAL
- en: Binding HTTP requests in the Micronaut framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways we can bind arguments to an HTTP request in the Micronaut
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Body`: As discussed before, `@Body` binds the argument from the body of the
    HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CookieValue`: This binds an argument from the cookie value in the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Header`: This binds an argument from a header in the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@QueryValue`: This binds an argument from a query parameter in the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathVariable`: This binds an argument from the path in the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Part`: In a multi-part HTTP request, this binds the argument to a part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestBean`: This binds any object (in the HTTP request) to a Java bean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with the preceding HTTP request bindings, the Micronaut framework supports
    multiple URI templates. These templates come in handy in creating various kinds
    of restful microservices. Considering the owner resource, we can support the following
    URI template matching in Micronaut:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.2 – URI templates in the Micronaut framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_3.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.2 – URI templates in the Micronaut framework
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding table, we can see various approaches in matching/restricting
    an incoming HTTP request and what each approach can achieve for a specific resource.
    In the next section, we will discuss how we can validate the data in an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Micronaut framework supports both JSR 380 bean validations as well as hibernate
    bean validations. By default, a Micronaut project usually contains a `micronaut-validation`
    dependency, which is implemented based on the JSR 380 standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using validation annotations such as `@NotNull` and `@NotEmpty`, we can verify
    whether an argument/parameter is meeting all the validation criteria or not before
    processing a request. Some useful annotations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@NotNull`: This asserts if the argument/parameter value is not null, for example,
    `@NotNull @PathVariable String ownerId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NotEmpty`: This asserts if the argument is not null and not empty. It can
    be applied to any argument of the `String`, `Collection`, or `Map` type, and so
    on, for example, `@NotEmpty @PathVariable String ownerId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Min`: This validates that the annotated property has a value greater than
    or equal to the `value` attribute, for example, `@Min(value = 0) Integer offset`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Max`: This validates that the annotated property has a value equal to or
    smaller than the `value` attribute, for example, `@Max(value =100) Integer offset`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Valid`: `@Valid` validates all arguments/parameters within the object graph.
    It recursively scans all inner `@Valid` usages within the object graph and determines
    the final validation after checking everything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these validations are not met, then `javax.validation.ConstraintViolationException`
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: To handle constraint violation exceptions as well as other checked/unchecked
    exceptions, we will explore some options in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Micronaut framework provides good coverage on raising different kinds of
    exceptions throughout the life cycle of an HTTP request along with handling these
    exceptions. The standard exception handlers can be found in the `io.micronaut.http.server.exceptions`
    package. By default, the following handlers are provided within this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ContentLengthExceededHandler`: This handles `ContentLengthExceededException`
    by returning an `HttpStatus.REQUEST_ENTITY_TOO_LARGE` response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConversionErrorHandler`: This handles `ConversionErrorException` by returning
    an `HttpStatus.BAD_REQUEST` response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpStatusHandler`: This handles `HttpStatusException` by returning `HttpStatus`
    as specified in the `HttpStatusException` response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JsonExceptionHandler`: This handles `JsonProcessingException` by returning
    an `HttpStatus.BAD_REQUEST` response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnsatisfiedArgumentHandler`: This handles `UnsatisfiedArgumentException` by
    returning an `HttpStatus.BAD_REQUEST` response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URISyntaxHandler`: This handles `URISyntaxException` by returning an `HttpStatus.BAD_REQUEST`
    response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the preceding standard exceptions and exception handlers, we
    can create our custom exceptions and exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assume a hypothetical `FooException` that can be raised by a microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`FooException` extends `RuntimeException`, which makes it an unchecked exception,
    and we can create `FooExceptionHandler` to handle this exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `FooExceptionHandler` bean injection mandates the required injection of
    `FooException` and `ExceptionHandler`. At any place within the code base, if `FooException`
    is raised, it will be caught by `FooExceptionHandler` and a `HttpStatus.INTERNAL_SERVER_ERROR`
    response will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning the APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Micronaut supports API versioning by using the `@Version` annotation. This annotation
    can be used at the controller or method level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Versioning is not supported by default and to enable versioning, we must make
    the following changes in `application.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the configuration, we have enabled versioning and by default, if no version
    is specified, then the incoming request will be served by the version `1` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exhibit versioning, we will add `@Version` to the `getOwner()` method of
    `OwnerResource` in the `pet-owner` microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`@Version` allows multiple projections of the `getOwner()` method. This annotation
    comes in handy in supporting event-driven microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test these changes, we can run `pet-owner` locally and use the advanced
    rest client to make a call to `getOwner()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Calling a versioned API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Calling a versioned API
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding HTTP call, we specified the version using the `X-API-VERSION`
    header. As per the value specified in this header, this call will be served by
    the version `2` API.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored how to leverage HTTP server APIs in the Micronaut framework.
    In the next section, we will focus our attention on HTTP client aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Using Micronaut's HTTP client APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Micronaut's HTTP client is a non-blocking client based on Netty with baked-in
    cloud features such as service discovery and load balancing. This custom implementation
    enhances the standard HTTP client with microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exhibit basic HTTP calls, we will create an HTTP client for `OwnerResource`
    in the `pet-owner` microservice. At the outset, we must have the `micronaut-http-client`
    dependency in the `pom.xml` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`micronaut-http-client` encapsulated all HTTP client-related APIs, such as
    creating `RxHttpClient`, performing all HTTP operations, and handling and processing
    response payloads.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how to leverage `micronaut-http-client` to perform various
    HTTP operations on the endpoint we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Performing an HTTP PUT operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To perform an HTTP PUT operation, we can create `OwnerResourceClient`. This
    client can be packaged inside `com.packtpub.micronaut.web.rest.client`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the following method to perform an HTTP call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP GET request.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing an HTTP POST operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform an HTTP POST operation, we can add the following method to `OwnerResourceClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP POST request. An owner object will be passed as the request payload.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing an HTTP PUT operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform an HTTP PUT operation, we can add the following method to `OwnerResourceClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP PUT request. An `owner` object will be passed as the request payload.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing an HTTP DELETE operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform an HTTP DELETE operation, we can add the following method to `OwnerResourceClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP DELETE request. A no content message will be returned if the request executes
    successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various aspects of working on web endpoints in a
    Micronaut application. We kick-started with the concept of assemblers or DTOs
    and then dived into how to create restful endpoints for supporting essential CRUD
    operations. Also, we experimented with some of the HTTP server APIs in the Micronaut
    framework. Lastly, we focused on the HTTP client aspects and created a client
    utility using `micronaut-http-client`.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has given us the skills related to various practical aspects of
    working on restful microservices in the Micronaut framework. Furthermore, by exploring
    the HTTP client, we covered these aspects end to end. This hands-on knowledge
    to work on the web layer is pivotal in developing any microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on securing the web layer of the `pet-clinic`
    microservice by experimenting with different approaches and methods in safeguarding
    the restful endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a DTO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use MapStruct in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a restful HTTP GET endpoint in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a restful HTTP POST endpoint in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a restful HTTP PUT endpoint in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a restful HTTP DELETE endpoint in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Micronaut support HTTP request binding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we validate data in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we version the APIs in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Micronaut support HTTP client aspects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we create an HTTP client in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
