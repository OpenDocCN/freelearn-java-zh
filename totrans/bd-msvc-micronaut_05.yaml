- en: '*Chapter 3*: Working on RESTful Web Services'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*: 在 RESTful Web 服务上工作'
- en: 'In any microservice development, one of the core aspects is how the microservice
    interfaces with the external world. `pet-clinic` application. For outgoing and
    incoming payloads to these endpoints, we will use **data transfer objects** (**DTOs**)
    in tandem with MapStruct to map DTOs to/from entities. For hands-on work, we will
    work to add restful endpoints to the following microservices:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何微服务开发中，核心方面之一是微服务如何与外部世界接口。`宠物诊所`应用程序。对于这些端点的出站和入站有效载荷，我们将使用 **数据传输对象**（**DTOs**）与
    MapStruct 一起映射 DTO 到/从实体。对于实际操作，我们将努力为以下微服务添加 RESTful 端点：
- en: '`pet-owner`: Working hands-on to add HTTP GET, POST, PUT, and DELETE endpoints
    for `pet-owner` schema objects'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`宠物主人`: 通过实际操作为`宠物主人`模式对象添加 HTTP GET、POST、PUT 和 DELETE 端点'
- en: '`pet-clinic`: Working hands-on to add HTTP GET, POST, PUT, and DELETE endpoints
    for `pet-clinic` schema objects'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`宠物诊所`: 通过实际操作为`宠物诊所`模式对象添加 HTTP GET、POST、PUT 和 DELETE 端点'
- en: '`pet-clinic-review`: Working hands-on to add HTTP GET, POST, PUT, and DELETE
    endpoints for the `pet-clinic-reviews` collection'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`宠物诊所评论`: 通过实际操作为`宠物诊所评论`集合添加 HTTP GET、POST、PUT 和 DELETE 端点'
- en: 'While working on the aforementioned microservices, we will dive into the following
    topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究以下主题，以处理上述微服务：
- en: Working on restful microservices in the Micronaut framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Micronaut 框架中处理 RESTful 微服务
- en: Using DTOs for the endpoint payloads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DTOs 作为端点有效载荷
- en: Creating restful endpoints for a microservice
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务创建 RESTful 端点
- en: Using Micronaut's HTTP server APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Micronaut 的 HTTP 服务器 API
- en: Using Micronaut's HTTP client APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Micronaut 的 HTTP 客户端 API
- en: By the end of this chapter, you will have the practical know-how to work on
    restful web services in the Micronaut framework. This knowledge is important to
    work on the web layer of a microservice. Furthermore, we will also explore leveraging
    HTTP server objects and client objects in the Micronaut framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备在 Micronaut 框架中处理 RESTful Web 服务的实际知识。这些知识对于在微服务的网络层工作非常重要。此外，我们还将探讨在
    Micronaut 框架中利用 HTTP 服务器对象和客户端对象。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and macOS. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有命令和技术说明均在 Windows 10 和 macOS 上运行。本章涵盖的代码示例可在本书的 GitHub 仓库 [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03)
    中找到。
- en: 'The following tools need to be installed and set up in the development environment:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中需要安装和设置以下工具：
- en: '**Java SDK**: Version 8 or above (we used Java 14).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**: 版本 8 或更高（我们使用了 Java 14）。'
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**: 这不是必需的，只有当你想使用 Maven 作为构建系统时才需要。然而，我们建议在任何开发机器上设置 Maven。下载和安装 Maven
    的说明可以在 [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)
    找到。'
- en: '**Development IDE**: Based on your preferences, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发 IDE**: 根据您的偏好，可以使用任何基于 Java 的 IDE，但为了编写本章，使用了 IntelliJ。'
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**: 下载和安装 Git 的说明可以在 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    找到。'
- en: '**PostgreSQL**: Instructions to download and install PostgreSQL can be found
    at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**: 下载和安装 PostgreSQL 的说明可以在 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    找到。'
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred, then instructions
    on how to download and install can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：MongoDB Atlas 提供了一个免费的在线数据库即服务，存储空间高达 512 MB。然而，如果您更喜欢本地数据库，则可以在[https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)找到下载和安装的说明。我们为编写本章使用了本地安装。'
- en: '**Rest client**: Any HTTP REST client can be used. We used the Advanced REST
    Client Chrome plugin.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST 客户端**：可以使用任何 HTTP REST 客户端。我们使用了 Advanced REST Client Chrome 插件。'
- en: Working on restful microservices in the Micronaut framework
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Micronaut 框架中开发 RESTful 微服务
- en: 'In order to learn about restful microservices in the Micronaut framework, we
    will continue working on the `pet-clinic` application. The following table summarizes
    the changes we will be making on each of the microservices in the `pet-clinic`
    application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 Micronaut 框架中的 RESTful 微服务，我们将继续在 `pet-clinic` 应用程序上工作。以下表格总结了我们将对 `pet-clinic`
    应用程序中的每个微服务进行的更改：
- en: '![Table 3.1 – Microservices in the pet-clinic application'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 3.1 – pet-clinic 应用程序中的微服务'
- en: '](img/Table_3.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_3.1.jpg)'
- en: Table 3.1 – Microservices in the pet-clinic application
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – pet-clinic 应用程序中的微服务
- en: In each microservice, we will get hands-on with adding HTTP endpoints for performing
    CRUD operations on the data objects owned by them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个微服务中，我们将亲自动手添加 HTTP 端点以对它们拥有的数据对象执行 CRUD 操作。
- en: 'In our hands-on discussions, we will focus on the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的动手实践中，我们将关注以下内容：
- en: '**DTOs**: How DTOs can be used to encapsulate outgoing and incoming payloads
    for restful endpoints'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DTO**：如何使用 DTO 封装 RESTful 端点的出入有效载荷'
- en: '**Services**: How services liaison with database repositories for any controller
    requests'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：服务如何与数据库存储库协调以处理任何控制器请求'
- en: '**Controllers**: How controllers provide a standard restful interface for the
    external world in the Micronaut framework'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：如何在 Micronaut 框架中为外部世界提供标准的 RESTful 接口'
- en: 'Adding to *Figure 2.2* of [*Chapter 2*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033),
    *Working on the Data Access*, the following are the components in this chapter
    within each microservice:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033)的*数据访问工作*中添加到 *图 2.2*，本章中每个微服务内的组件如下：
- en: '![Figure 3.1 – Microservice components'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 微服务组件'
- en: '](img/Figure_3.1_B16585.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16585.jpg)'
- en: Figure 3.1 – Microservice components
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 微服务组件
- en: We will continue with the separation of concerns by following the controller-service-repository
    pattern. For communications between the service and controller, we will explore
    DTOs. We will work in a bottom-up fashion while covering DTOs, services, and finally
    controllers. DTOs, mappers, services, and controllers follow the same approach,
    and therefore, to keep our discussion focused, we will target the `pet-owner`
    microservice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过遵循控制器-服务-存储库模式来分离关注点。对于服务和控制器之间的通信，我们将探讨 DTO。在涵盖 DTO、服务和最终控制器时，我们将采用自下而上的方式。DTO、映射器、服务和控制器遵循相同的方法，因此，为了使我们的讨论保持专注，我们将以
    `pet-owner` 微服务为目标。
- en: In the next section, our focal point will be DTOs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们的焦点将是 DTO。
- en: Using DTOs for the endpoint payloads
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DTO 进行端点有效载荷
- en: The DTO pattern originates from the enterprise application architecture and
    fundamentally, data objects aggregate and encapsulate the data to transfer. Since
    in the microservices architecture an end client may need varied data from different
    persistence resources (such as invoice data along with user data), the DTO pattern
    is very effective in limiting calls to microservices for getting the desired projection
    of data. DTOs are also known as assembler objects since they assemble data from
    multiple entity classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: DTO 模式起源于企业应用架构，本质上，数据对象聚合和封装要传输的数据。由于在微服务架构中，终端客户端可能需要从不同的持久化资源（如发票数据和用户数据）中获取不同的数据，因此
    DTO 模式在限制对微服务的调用以获取所需的数据投影方面非常有效。DTO 也被称为组装对象，因为它们从多个实体类中组装数据。
- en: In this section, we will explore how to implement and map (to an entity) DTOs.
    In the later sections, we will further dive into using DTOs as an effective mechanism
    to transfer data from and into a microservice. We will also look at how DTOs can
    help reduce the number of calls to microservices by assembling data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何实现和映射（到实体）DTO。在后面的章节中，我们将进一步深入探讨使用 DTO 作为在微服务之间有效传输数据的一种机制。我们还将研究
    DTO 如何通过组装数据来帮助减少对微服务的调用次数。
- en: Implementing DTOs
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 DTO
- en: To implement a DTO, we will begin defining a DTO class for the pet owner.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个 DTO，我们将开始定义一个宠物主人的 DTO 类。
- en: 'Open the `pet-owner` microservice project (created in *Chapter 2*, *Working
    on the Data Access*) in your preferred IDE. Add the `com.packtpub.micronaut.service.dto`
    package to contain all DTOs. We can define `OwnerDTO` as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您首选 IDE 中的 `pet-owner` 微服务项目（在 *第 2 章*，*处理数据访问* 中创建），将 `com.packtpub.micronaut.service.dto`
    包添加到包含所有 DTO 的包中。我们可以定义 `OwnerDTO` 如下：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`OwnerDTO` is implementing the `Serializable` marker interface to mark that
    the DTO is serializable. Furthermore, in continuation of our earlier discussion
    on the assembler pattern, `OwnerDTO` will also contain a set of `PetDTO` instances.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnerDTO` 实现了 `Serializable` 标记接口，以标记 DTO 是可序列化的。此外，在继续我们之前关于组装模式的讨论中，`OwnerDTO`
    还将包含一组 `PetDTO` 实例。'
- en: Following the similar POJO model, we can define DTOs for other entities in the
    `pet-owner` microservice, such as `PetDTO`, `VisitDTO`, and `PetTypeDTO` in the
    `com.packtpub.micronaut.service.dto` package.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照类似的 POJO 模型，我们可以在 `pet-owner` 微服务中为其他实体定义 DTO，例如在 `com.packtpub.micronaut.service.dto`
    包中的 `PetDTO`、`VisitDTO` 和 `PetTypeDTO`。
- en: In the next section, we will work on mapping these DTOs to database entities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将致力于将这些 DTO 映射到数据库实体。
- en: Using MapStruct to define mappers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MapStruct 定义映射器
- en: '**MapStruct** is a code generator that uses annotation processing to implement
    mappings between source and target Java classes. The implemented MapStruct code
    consists of plain method calls, therefore it''s type-safe and easy to read code.
    Since we don''t need to write code for these mappings, MapStruct is very effective
    in reducing the source code footprint.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapStruct** 是一个代码生成器，它使用注解处理来实现源和目标 Java 类之间的映射。实现的 MapStruct 代码由简单的函数调用组成，因此它是类型安全的且易于阅读的代码。由于我们不需要为这些映射编写代码，MapStruct
    在减少源代码体积方面非常有效。'
- en: 'To map DTOs to entities and vice versa, we will use MapStruct in our `pet-owner`
    microservice. Since we are using Maven, we will have to add the following to the
    `pom.xml` project:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 DTO 映射到实体以及反之亦然，我们将在 `pet-owner` 微服务中使用 MapStruct。由于我们使用 Maven，我们不得不在 `pom.xml`
    项目中添加以下内容：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By importing MapStruct into the project, POM will allow us to leverage the
    MapStruct toolkit. Furthermore, for the Maven compiler, we will need to add MapStruct
    to `annotationProcessorPaths`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 MapStruct 导入项目，POM 将允许我们利用 MapStruct 工具包。此外，对于 Maven 编译器，我们需要将 MapStruct
    添加到 `annotationProcessorPaths`：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The annotation processing settings in POM will direct the Java annotation processor
    to generate source code for any mappings that are marked using MapStruct annotations.
    In addition, `jsr330` is specified as a default component model in the context
    of the Micronaut framework (in Spring, a Spring model is often used).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: POM 中的注解处理设置将指导 Java 注解处理器为使用 MapStruct 注解标记的任何映射生成源代码。此外，`jsr330` 被指定为 Micronaut
    框架（在 Spring 中，通常使用 Spring 模型）中的默认组件模型。
- en: 'We will create a new package named `com.packtpub.micronaut.service.mapper`
    to contain all the mapper interfaces. To abstract out a generic entity mapper,
    we can declare the following interface:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的包名为 `com.packtpub.micronaut.service.mapper`，以包含所有映射器接口。为了抽象出一个通用的实体映射器，我们可以声明以下接口：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `EntityMapper` interface abstracts out object-to-object and list-to-list
    conversion methods. By extending this interface, we can easily define an interface
    to map `OwnerDTO` to the `Owner` entity:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityMapper` 接口抽象出了对象到对象和列表到列表的转换方法。通过扩展此接口，我们可以轻松定义一个接口来将 `OwnerDTO` 映射到
    `Owner` 实体：'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `OwnerMapper` interface extends `EntityMapper` and uses `PetMapper`. `PetMapper`
    is used to map a set of `PetDTO` instances to `Pet` entities. `PetMapper` can
    be defined using a very similar approach.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnerMapper` 接口扩展了 `EntityMapper` 并使用 `PetMapper`。`PetMapper` 用于将一组 `PetDTO`
    实例映射到 `Pet` 实体。`PetMapper` 可以使用非常类似的方法定义。'
- en: Adhering to the same approach, we can thus define `PetMapper`, `VisitMapper`,
    and `PetTypeMapper` for the `Pet`, `Visit`, and `PetType` entities, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循相同的方法，因此我们可以为`Pet`、`Visit`和`PetType`实体分别定义`PetMapper`、`VisitMapper`和`PetTypeMapper`。
- en: So far, we have dived into DTOs and their mappings to corresponding entity classes.
    In the next section, we will zero down on the service changes concerning DTOs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经深入探讨了DTO及其与相应实体类的映射。在下一节中，我们将专注于与DTO相关的服务更改。
- en: Modifying the services to use DTOs
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改服务以使用DTO
- en: In [*Chapter 2*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Working on
    the Data Access*, to simplify the discussion, we defined service methods that
    used entity classes directly. This approach is not recommended for a variety of
    reasons, including the fact that we end up colluding/coupling business logic with
    database entities or it can become hairy if a service method needs to use multiple
    entities. Put simply, we must separate the concerns by decoupling database entities
    from business-required data objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033)《数据访问工作》中，为了简化讨论，我们定义了直接使用实体类的方法。由于多种原因，包括我们最终将业务逻辑与数据库实体耦合，或者如果服务方法需要使用多个实体，这可能会变得复杂，因此这种方法不建议使用。简单来说，我们必须通过解耦数据库实体与业务所需的数据对象来分离关注点。
- en: 'To use DTOs in business services, we will need to modify abstracting interfaces.
    The `OwnerService` interface can be modified to use DTOs as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在业务服务中使用DTO，我们需要修改抽象接口。`OwnerService`接口可以修改为使用DTO如下：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `save()` method is modified to save `OwnerDTO` instead of the `Owner` entity.
    Also, `findAll()` and `findOne()` will return `OwnerDTO` instead of `Owner`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`方法被修改为保存`OwnerDTO`而不是`Owner`实体。同样，`findAll()`和`findOne()`将返回`OwnerDTO`而不是`Owner`。'
- en: Complying with the same approach, we can modify these service interfaces for
    other entities in the `pet-owner` microservice, that is, `PetService`, `PetTypeService`,
    and `VisitService`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 采用相同的方法，我们可以修改`pet-owner`微服务中其他实体的服务接口，即`PetService`、`PetTypeService`和`VisitService`。
- en: 'Since we modified abstracting service interfaces, we will have to modify implementing
    classes too. `OwnerServiceImpl` can be modified to use DTOs like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们修改了抽象服务接口，因此我们还需要修改实现类。`OwnerServiceImpl`可以修改为使用DTO如下：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `save()` method will use `OwnerMapper` to convert `OwnerDTO` to the entity
    before the repository method is called. Similarly, fetch methods will convert
    `Owner` entities back to `OwnerDTO`s before returning the responses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`方法将使用`OwnerMapper`在调用存储库方法之前将`OwnerDTO`转换为实体。同样，获取方法将在返回响应之前将`Owner`实体转换回`OwnerDTO`。'
- en: Following the same approach, we can modify `PetServiceImpl`, `PetTypeServiceImpl`,
    and `VisitServiceImpl`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 采用相同的方法，我们还可以修改`PetServiceImpl`、`PetTypeServiceImpl`和`VisitServiceImpl`。
- en: So far, we have focused on DTOs and how we can easily use DTOs by mapping them
    on entity objects using the MapStruct framework. In the next section, we will
    center our attention on how to create restful endpoints for the `pet-owner` microservice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注DTO以及如何通过使用MapStruct框架将它们映射到实体对象上来轻松使用DTO。在下一节中，我们将关注与DTO相关的服务更改。
- en: Creating the restful endpoints for a microservice
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务创建RESTful端点
- en: Using the Micronaut framework, we can create all commonly used HTTP methods,
    namely GET, PUT, POST, and DELETE. At the core, all HTTP concerns are encapsulated
    in the `io.micronaut.http` package. This package contains `HttpRequest` and `HttpResponse`
    interfaces. These interfaces are the bedrock of defining any HTTP endpoint. Using
    these standard implementations, we will cover all HTTP methods in the following
    sections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Micronaut框架，我们可以创建所有常用的HTTP方法，即GET、PUT、POST和DELETE。在核心上，所有HTTP关注点都被封装在`io.micronaut.http`包中。此包包含`HttpRequest`和`HttpResponse`接口。这些接口是定义任何HTTP端点的基石。使用这些标准实现，我们将在以下章节中涵盖所有HTTP方法。
- en: Creating an endpoint for retrieving a list of resources
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于检索资源列表的端点
- en: 'To create an endpoint for fetching a list of resources, we can begin by adding
    the `com.packtpub.micronaut.web.rest` package to contain all controller resources.
    We will add a fetch all owners endpoint to the `OwnerResource` controller in the
    `pet-owner` microservice:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用于获取资源列表的端点，我们可以首先添加`com.packtpub.micronaut.web.rest`包以包含所有控制器资源。我们将在`pet-owner`微服务的`OwnerResource`控制器中添加一个获取所有所有者的端点：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are a few things we need to ponder here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要思考以下几点：
- en: '`@Controller`: This is a stereotype that marks `OwnerResource` as a restful
    controller and is exposed on the `/api` base URL.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Controller`：这是一个标记`OwnerResource`为RESTful控制器的.stereotype，并在`/api`基本URL上公开。'
- en: '`@Get`: This annotation is used to expose the `getAllOwners()` method on HTTP
    get over the relative URL of `/owners`.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Get`：这个注解用于在HTTP get上公开`getAllOwners()`方法，相对于URL`/owners`。'
- en: '`@ExecuteOn`: This annotation specifies to execute this GET request on the
    I/O thread pool. The value of the `@ExecuteOn` annotation can be any executor
    defined in `micronaut.executors`.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@ExecuteOn`：这个注解指定在I/O线程池上执行此GET请求。`@ExecuteOn`注解的值可以是`micronaut.executors`中定义的任何执行器。'
- en: '`HttpRequest`: `getAllOwners()` takes on `HttpRequest` as an input parameter.
    Often, `HttpRequest` is passed to trace and log details of the origin, for example,
    which IP address is submitting the request.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HttpRequest`：`getAllOwners()`接受`HttpRequest`作为输入参数。通常，`HttpRequest`被传递以跟踪和记录详细信息，例如，哪个IP地址提交了请求。'
- en: '`pageable`: This is a standard interface in the `io.micronaut.data.model` package
    and is often used to pass pagination information in the request, for example,
    `…/api/owners?page=1&size=50&sort=(firstName)`. This pagination information is
    often optional and passed as query parameters.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pageable`：这是`io.micronaut.data.model`包中的一个标准接口，通常用于在请求中传递分页信息，例如，`…/api/owners?page=1&size=50&sort=(firstName)`。这种分页信息通常是可选的，并作为查询参数传递。'
- en: '`HttpResponse`: `getAllOwners()` returns `HttpResponse`, which is a generic
    interface and embodies a specific type of response within the example. In this
    example, it is returning `List<OwnerDTO>`.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HttpResponse`：`getAllOwners()`返回`HttpResponse`，这是一个通用接口，在示例中体现为特定类型的响应。在这个例子中，它返回`List<OwnerDTO>`。'
- en: '`PaginationUtil`: This is a custom class in the `com.packtpub.micronaut.util`
    package and it generates paged responses.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PaginationUtil`：这是`com.packtpub.micronaut.util`包中的一个自定义类，它生成分页响应。'
- en: 'We can run the `pet-owner` service locally and by default, it will run on port
    `8080`. We can use any REST client and hit `http://localhost:8080/api/owners`
    and we will get the following response:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地运行`pet-owner`服务，默认情况下，它将在端口`8080`上运行。我们可以使用任何REST客户端，并访问`http://localhost:8080/api/owners`，我们将得到以下响应：
- en: '![Figure 3.2 – Retrieving all owners'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 检索所有所有者](img/Figure_3.2_B16585.jpg)'
- en: '](img/Figure_3.2_B16585.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 检索所有所有者](img/Figure_3.2_B16585.jpg)'
- en: Figure 3.2 – Retrieving all owners
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 检索所有所有者
- en: As shown in the preceding screenshot, when we call the fetch all owners endpoint,
    we are not passing any pagination information to get all owners. Therefore, it
    will retrieve all the owners and their pet information from the database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，当我们调用检索所有所有者的端点时，我们没有传递任何分页信息以获取所有所有者。因此，它将从数据库中检索所有所有者和他们的宠物信息。
- en: Creating an endpoint for retrieving a specific resource
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于检索特定资源的端点
- en: 'To create an endpoint for fetching a specific resource, we will add a method
    in `OwnerResource` to fetch a specific owner, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用于检索特定资源的端点，我们将在`OwnerResource`中添加一个方法来检索特定所有者，如下所示：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are a few things we need to ponder here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个问题需要我们思考：
- en: '`@PathVariable`: This is used to specify and match a path variable in the HTTP
    call. In the proceeding example, we are passing the owner ID as a path variable.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@PathVariable`：这个注解用于指定和匹配HTTP调用中的路径变量。在上面的例子中，我们传递所有者ID作为路径变量。'
- en: '`Optional`: In this example, we are returning an optional object. If the service
    can find an owner for the specified ID, then an `HTTP 200` response will be sent;
    otherwise, `HTTP 404` will be reverted.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Optional`：在这个例子中，我们返回一个可选对象。如果服务可以找到指定ID的所有者，则发送`HTTP 200`响应；否则，将回滚为`HTTP
    404`。'
- en: 'We can run the `pet-owner` service locally and by default, it will run on port
    `8080`. We can use any rest client and by hitting `http://localhost:8080/api/owners/1`,
    we will get the following response:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地运行`pet-owner`服务，默认情况下，它将在端口`8080`上运行。我们可以使用任何REST客户端，通过访问`http://localhost:8080/api/owners/1`，我们将得到以下响应：
- en: '![Figure 3.3 – Retrieving a specific owner'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 检索特定所有者](img/Figure_3.3_B16585.jpg)'
- en: '](img/Figure_3.3_B16585.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 检索特定所有者](img/Figure_3.3_B16585.jpg)'
- en: Figure 3.3 – Retrieving a specific owner
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 检索特定所有者
- en: '`OwnerDTO` encapsulated the pet data as well so the response payload will fetch
    complete details about the owner with ID `1`. Furthermore, if any non-existing
    ID is passed to the proceeding HTTP request, then it will result in `HTTP 404`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnerDTO` 也封装了宠物数据，因此响应负载将检索ID为`1`的所有者的完整详细信息。此外，如果向后续的HTTP请求传递任何不存在的ID，则会导致`HTTP
    404`：'
- en: '![Figure 3.4 – Retrieving a non-existing owner'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 检索不存在的所有者](img/Figure_3.4_B16585.jpg)'
- en: '](img/Figure_3.4_B16585.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Retrieving a non-existing owner
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding API call, we tried to fetch an owner with the `123789` ID,
    but since we don't have an owner with this ID, it results in an `HTTP 404` `not
    found` response.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Creating an endpoint for inserting a resource
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an endpoint to insert a resource, we will add an HTTP POST method
    to `OwnerResource` as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are a few things to pay attention to here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`@Post`: `createOwner()` is exposed using the `@Post` annotation as an HTTP
    POST API.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@ExecuteOn`: This annotation specifies to execute this POST request on the
    I/O thread pool.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Body`: The `@Body` annotation specifies that the `ownerDTO` method argument
    in `createOwner()` is bound to the body of the incoming HTTP POST request.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Not null id check`: Using an `if` construct, we are quickly checking that
    the HTTP body doesn''t contain a payload with the ID already defined. This is
    a case of asserting a business validation and if it fails, then the API is throwing
    a bad request exception.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HttpResponse.created`: In the happy path scenario, the API will return `HTTP
    201` created. This response indicates that the request was executed successfully
    and a resource was created.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can boot up the `pet-owner` microservice locally and hit an HTTP POST request
    in a rest client as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Inserting an owner'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16585.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Inserting an owner
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding HTTP POST call, we passed an owner object to be inserted in
    the HTTP body. As anticipated, the API call was successful and returned an `HTTP
    201` `created` response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if we try to hit this HTTP POST method to create an owner that
    has an ID value already, then it will fail:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Inserting an existing owner again'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B16585.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Inserting an existing owner again
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try to insert an owner with an ID value in the body payload, then an
    `HTTP 500` internal server error is thrown with a message – `Internal Server Error:
    A new owner cannot already have an ID`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Creating an endpoint for updating a resource
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an endpoint to update a resource, we will add an HTTP PUT method
    to `OwnerResource` as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A few things to ponder here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`@Put`: The `@Put` annotation exposes the `updateOwner()` method as an HTTP
    PUT API.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@ExecuteOn`: This annotation specifies to execute this PUT request on the
    I/O thread pool. The I/O thread pool is a mechanism to achieve I/O concurrency
    by maintaining a quorum of threads waiting to be assigned the I/O requests.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Body`: The `@Body` annotation specifies that the `ownerDTO` method argument
    in `createOwner()` is bound to the body of the incoming HTTP PUT request.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Null id check`: Using an `if` construct, we are quickly checking that the
    HTTP body doesn''t contain a payload with a null ID. If the ID is null, then the
    API is throwing a bad request exception.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HttpResponse.ok`: In the happy path scenario, the API will return `HTTP 200`.
    This response indicates that the request was executed successfully and a resource
    was updated.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HttpResponse.ok`: 在愉快的路径场景中，API 将返回 `HTTP 200`。这个响应表示请求已成功执行，并且资源已被更新。'
- en: 'We can boot up the `pet-owner` microservice locally and hit an HTTP PUT request
    in a rest client like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地启动 `pet-owner` 微服务，并在 REST 客户端中发送一个 HTTP PUT 请求，如下所示：
- en: '![Figure 3.7 – Updating an owner'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 更新所有者'
- en: '](img/Figure_3.7_B16585.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B16585.jpg)'
- en: Figure 3.7 – Updating an owner
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 更新所有者
- en: In the HTTP PUT request, we requested to update a resource we just inserted
    previously. We are updating the address and city for this resource. As anticipated,
    the request was executed successfully and an `HTTP 200` response was returned.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP PUT 请求中，我们请求更新我们刚刚插入的资源。我们正在更新这个资源的地址和城市。正如预期的那样，请求成功执行，并返回了一个 `HTTP
    200` 响应。
- en: 'If we try to update a resource with a null ID, then it will fail:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用 null ID 更新资源，那么它将失败：
- en: '![Figure 3.8 – Updating a non-existing owner'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 更新不存在的所有者'
- en: '](img/Figure_3.8_B16585.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.8_B16585.jpg)'
- en: Figure 3.8 – Updating a non-existing owner
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 更新不存在的所有者
- en: 'In the preceding HTTP PUT call, we tried to update an owner with a null ID.
    An `HTTP 500` internal server error is thrown with a message – `Internal Server
    Error: Invalid id`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 HTTP PUT 请求中，我们尝试使用 null ID 更新一个所有者。抛出了一个带有消息的 `HTTP 500` 内部服务器错误 – `内部服务器错误：无效的
    ID`。
- en: Creating an endpoint for deleting a resource
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为删除资源创建一个端点
- en: 'To exhibit deleting a resource, we can add an HTTP DELETE method to `OwnerResource`
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示删除资源，我们可以在 `OwnerResource` 中添加一个 HTTP DELETE 方法，如下所示：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A few things to ponder here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些值得思考的问题：
- en: '`@Delete`: The `@Delete` annotation exposes the `deleteOwner()` method as an
    HTTP DELETE API.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Delete`: `@Delete` 注解将 `deleteOwner()` 方法公开为 HTTP DELETE API。'
- en: '`@ExecuteOn`: This annotation specifies to execute this PUT request on the
    I/O thread pool.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@ExecuteOn`: 这个注解指定在这个 I/O 线程池上执行这个 PUT 请求。'
- en: '`@PathVariable`: `@PathVariable` binds the ID parameter in the `deleteOwner()`
    method to the variable specified in the HTTP request URL.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@PathVariable`: `@PathVariable` 将 `deleteOwner()` 方法中的 ID 参数绑定到 HTTP 请求 URL
    中指定的变量。'
- en: '`HttpResponse.noContent`: In the happy path scenario, the API will return `HTTP
    204`. This response indicates that the request was executed successfully and there
    is no additional content in the response payload.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HttpResponse.noContent`: 在愉快的路径场景中，API 将返回 `HTTP 204`。这个响应表示请求已成功执行，并且响应体中没有额外的内容。'
- en: 'We can boot up the `pet-owner` microservice locally and hit an HTTP DELETE
    request in a rest client:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地启动 `pet-owner` 微服务，并在 REST 客户端中发送一个 HTTP DELETE 请求，如下所示：
- en: '![Figure 3.9 – Deleting an owner'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 删除所有者'
- en: '](img/Figure_3.9_B16585.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B16585.jpg)'
- en: Figure 3.9 – Deleting an owner
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 删除所有者
- en: We requested to delete the owner that we inserted/updated in previous examples.
    As anticipated, the request was successful and an `HTTP 204` response was returned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求删除我们在之前的示例中插入/更新的所有者。正如预期的那样，请求成功，并返回了一个 `HTTP 204` 响应。
- en: So far, we have explored how to create all different types of restful endpoints.
    This discussion paves our way into using Micronaut's HTTP server APIs. In the
    next section, we will cover some practical aspects of leveraging these server
    APIs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何创建所有不同类型的 RESTful 端点。这次讨论为我们使用 Micronaut 的 HTTP 服务器 API 打开了道路。在下一节中，我们将介绍一些利用这些服务器
    API 的实际方面。
- en: Using Micronaut's HTTP server APIs
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Micronaut 的 HTTP 服务器 API
- en: The Micronaut framework offers a non-blocking HTTP server based on Netty. These
    server APIs can be leveraged to address some useful microservice requirement scenarios.
    To do any hands-on work, we will continue with the `pet-owner` microservice.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 框架提供了一个基于 Netty 的非阻塞 HTTP 服务器。这些服务器 API 可以用来解决一些有用的微服务需求场景。为了进行实际操作，我们将继续使用
    `pet-owner` 微服务。
- en: 'At the outset, we must have the following Maven dependency in the project POM:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在项目的 POM 文件中添加以下 Maven 依赖项：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This dependency should already be in the `pet-owner` project. In the next sections,
    we will explore some useful configurations in the HTTP server world.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项应该已经在 `pet-owner` 项目中。在接下来的几节中，我们将探索 HTTP 服务器世界中的几个有用配置。
- en: Binding HTTP requests in the Micronaut framework
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Micronaut 框架中绑定 HTTP 请求
- en: 'There are several ways we can bind arguments to an HTTP request in the Micronaut
    framework:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Micronaut 框架中，我们可以通过几种方式将参数绑定到 HTTP 请求上：
- en: '`@Body`: As discussed before, `@Body` binds the argument from the body of the
    HTTP request.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Body`：如前所述，`@Body`将HTTP请求体中的参数绑定到一个参数上。'
- en: '`@CookieValue`: This binds an argument from the cookie value in the HTTP request.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CookieValue`：这会将HTTP请求中的cookie值绑定到一个参数上。'
- en: '`@Header`: This binds an argument from a header in the HTTP request.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Header`：这会将HTTP请求中的一个头部的参数绑定到一个参数上。'
- en: '`@QueryValue`: This binds an argument from a query parameter in the HTTP request.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@QueryValue`：这会将HTTP请求中的查询参数绑定到一个参数上。'
- en: '`@PathVariable`: This binds an argument from the path in the HTTP request.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PathVariable`：这会将HTTP请求中的路径绑定到一个参数上。'
- en: '`@Part`: In a multi-part HTTP request, this binds the argument to a part.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Part`：在多部分HTTP请求中，这会将参数绑定到一个部分上。'
- en: '`@RequestBean`: This binds any object (in the HTTP request) to a Java bean.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestBean`：这会将任何对象（在HTTP请求中）绑定到一个Java Bean上。'
- en: 'Along with the preceding HTTP request bindings, the Micronaut framework supports
    multiple URI templates. These templates come in handy in creating various kinds
    of restful microservices. Considering the owner resource, we can support the following
    URI template matching in Micronaut:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的HTTP请求绑定之外，Micronaut框架支持多种URI模板。这些模板在创建各种类型的RESTful微服务时非常有用。考虑到所有者资源，我们可以在Micronaut中支持以下URI模板匹配：
- en: '![Table 3.2 – URI templates in the Micronaut framework'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 3.2 – URI templates in the Micronaut framework]'
- en: '](img/Table_3.2.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 3.2.jpg]'
- en: Table 3.2 – URI templates in the Micronaut framework
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 – Micronaut框架中的URI模板
- en: In the preceding table, we can see various approaches in matching/restricting
    an incoming HTTP request and what each approach can achieve for a specific resource.
    In the next section, we will discuss how we can validate the data in an HTTP request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，我们可以看到各种匹配/限制传入HTTP请求的方法以及每种方法可以为特定资源实现什么。在下一节中，我们将讨论如何验证HTTP请求中的数据。
- en: Validating data
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证数据
- en: The Micronaut framework supports both JSR 380 bean validations as well as hibernate
    bean validations. By default, a Micronaut project usually contains a `micronaut-validation`
    dependency, which is implemented based on the JSR 380 standard.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut框架支持JSR 380 Bean验证以及Hibernate Bean验证。默认情况下，Micronaut项目通常包含一个`micronaut-validation`依赖项，该依赖项基于JSR
    380标准实现。
- en: 'Using validation annotations such as `@NotNull` and `@NotEmpty`, we can verify
    whether an argument/parameter is meeting all the validation criteria or not before
    processing a request. Some useful annotations are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如`@NotNull`和`@NotEmpty`这样的验证注解，我们可以在处理请求之前验证一个参数/参数是否满足所有验证标准。以下是一些有用的注解：
- en: '`@NotNull`: This asserts if the argument/parameter value is not null, for example,
    `@NotNull @PathVariable String ownerId`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：这断言参数/参数值不是null，例如，`@NotNull @PathVariable String ownerId`。'
- en: '`@NotEmpty`: This asserts if the argument is not null and not empty. It can
    be applied to any argument of the `String`, `Collection`, or `Map` type, and so
    on, for example, `@NotEmpty @PathVariable String ownerId`.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotEmpty`：这断言参数不是null且不为空。它可以应用于任何`String`、`Collection`或`Map`类型的参数等，例如，`@NotEmpty
    @PathVariable String ownerId`。'
- en: '`@Min`: This validates that the annotated property has a value greater than
    or equal to the `value` attribute, for example, `@Min(value = 0) Integer offset`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Min`：这验证注解的属性值大于或等于`value`属性，例如，`@Min(value = 0) Integer offset`。'
- en: '`@Max`: This validates that the annotated property has a value equal to or
    smaller than the `value` attribute, for example, `@Max(value =100) Integer offset`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Max`：这验证注解的属性值等于或小于`value`属性，例如，`@Max(value =100) Integer offset`。'
- en: '`@Valid`: `@Valid` validates all arguments/parameters within the object graph.
    It recursively scans all inner `@Valid` usages within the object graph and determines
    the final validation after checking everything.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Valid`：`@Valid`验证对象图中所有的参数/参数。它递归地扫描对象图中的所有内部`@Valid`使用，并在检查完所有内容后确定最终的验证。'
- en: If any of these validations are not met, then `javax.validation.ConstraintViolationException`
    is thrown.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何这些验证未满足，则抛出`javax.validation.ConstraintViolationException`异常。
- en: To handle constraint violation exceptions as well as other checked/unchecked
    exceptions, we will explore some options in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理约束违反异常以及其他已检查/未检查的异常，我们将在下一节中探讨一些选项。
- en: Handling errors
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'The Micronaut framework provides good coverage on raising different kinds of
    exceptions throughout the life cycle of an HTTP request along with handling these
    exceptions. The standard exception handlers can be found in the `io.micronaut.http.server.exceptions`
    package. By default, the following handlers are provided within this package:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut框架在整个HTTP请求的生命周期中提供了对抛出不同类型异常的良好覆盖，以及处理这些异常。标准异常处理程序可以在`io.micronaut.http.server.exceptions`包中找到。默认情况下，此包内提供了以下处理程序：
- en: '`ContentLengthExceededHandler`: This handles `ContentLengthExceededException`
    by returning an `HttpStatus.REQUEST_ENTITY_TOO_LARGE` response.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentLengthExceededHandler`: 这个处理程序通过返回一个`HttpStatus.REQUEST_ENTITY_TOO_LARGE`响应来处理`ContentLengthExceededException`。'
- en: '`ConversionErrorHandler`: This handles `ConversionErrorException` by returning
    an `HttpStatus.BAD_REQUEST` response.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConversionErrorHandler`: 这个处理程序通过返回一个`HttpStatus.BAD_REQUEST`响应来处理`ConversionErrorException`。'
- en: '`HttpStatusHandler`: This handles `HttpStatusException` by returning `HttpStatus`
    as specified in the `HttpStatusException` response.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpStatusHandler`: 这个处理程序通过返回`HttpStatusException`中指定的`HttpStatus`来处理`HttpStatusException`。'
- en: '`JsonExceptionHandler`: This handles `JsonProcessingException` by returning
    an `HttpStatus.BAD_REQUEST` response.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonExceptionHandler`: 这个处理程序通过返回一个`HttpStatus.BAD_REQUEST`响应来处理`JsonProcessingException`。'
- en: '`UnsatisfiedArgumentHandler`: This handles `UnsatisfiedArgumentException` by
    returning an `HttpStatus.BAD_REQUEST` response.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnsatisfiedArgumentHandler`: 这个处理程序通过返回一个`HttpStatus.BAD_REQUEST`响应来处理`UnsatisfiedArgumentException`。'
- en: '`URISyntaxHandler`: This handles `URISyntaxException` by returning an `HttpStatus.BAD_REQUEST`
    response.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URISyntaxHandler`: 这个处理程序通过返回一个`HttpStatus.BAD_REQUEST`响应来处理`URISyntaxException`。'
- en: In addition to the preceding standard exceptions and exception handlers, we
    can create our custom exceptions and exception handlers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的标准异常和异常处理程序之外，我们还可以创建我们自己的自定义异常和异常处理程序。
- en: 'We can assume a hypothetical `FooException` that can be raised by a microservice:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设一个假设的`FooException`，它可以由微服务抛出：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`FooException` extends `RuntimeException`, which makes it an unchecked exception,
    and we can create `FooExceptionHandler` to handle this exception:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`FooException`扩展了`RuntimeException`，这使得它成为一个未检查的异常，我们可以创建`FooExceptionHandler`来处理这个异常：'
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `FooExceptionHandler` bean injection mandates the required injection of
    `FooException` and `ExceptionHandler`. At any place within the code base, if `FooException`
    is raised, it will be caught by `FooExceptionHandler` and a `HttpStatus.INTERNAL_SERVER_ERROR`
    response will be returned.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`FooExceptionHandler` bean注入强制要求注入`FooException`和`ExceptionHandler`。在代码库的任何地方，如果抛出`FooException`，它将被`FooExceptionHandler`捕获，并返回一个`HttpStatus.INTERNAL_SERVER_ERROR`响应。'
- en: Versioning the APIs
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API版本控制
- en: Micronaut supports API versioning by using the `@Version` annotation. This annotation
    can be used at the controller or method level.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut通过使用`@Version`注解支持API版本控制。这个注解可以在控制器或方法级别使用。
- en: 'Versioning is not supported by default and to enable versioning, we must make
    the following changes in `application.yml`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下不支持版本控制，要启用版本控制，我们必须在`application.yml`中进行以下更改：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the configuration, we have enabled versioning and by default, if no version
    is specified, then the incoming request will be served by the version `1` API.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，我们已经启用了版本控制，并且默认情况下，如果没有指定版本，则入站请求将由版本`1`的API提供服务。
- en: 'To exhibit versioning, we will add `@Version` to the `getOwner()` method of
    `OwnerResource` in the `pet-owner` microservice:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示版本控制，我们将在`pet-owner`微服务的`OwnerResource`的`getOwner()`方法上添加`@Version`：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`@Version` allows multiple projections of the `getOwner()` method. This annotation
    comes in handy in supporting event-driven microservices.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Version`允许对`getOwner()`方法的多个投影。这个注解在支持事件驱动微服务时非常有用。'
- en: 'To test these changes, we can run `pet-owner` locally and use the advanced
    rest client to make a call to `getOwner()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这些更改，我们可以在本地运行`pet-owner`并使用高级REST客户端调用`getOwner()`：
- en: '![Figure 3.10 – Calling a versioned API'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.10 – 调用一个版本化的API'
- en: '](img/Figure_3.10_B16585.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.10_B16585.jpg]'
- en: Figure 3.10 – Calling a versioned API
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 调用一个版本化的API
- en: In the preceding HTTP call, we specified the version using the `X-API-VERSION`
    header. As per the value specified in this header, this call will be served by
    the version `2` API.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的HTTP调用中，我们使用`X-API-VERSION`头指定了版本。根据这个头中指定的值，这个调用将由版本`2`的API提供服务。
- en: So far, we have explored how to leverage HTTP server APIs in the Micronaut framework.
    In the next section, we will focus our attention on HTTP client aspects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何在Micronaut框架中利用HTTP服务器API。在下一节中，我们将关注HTTP客户端方面。
- en: Using Micronaut's HTTP client APIs
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Micronaut 的 HTTP 客户端 API
- en: Micronaut's HTTP client is a non-blocking client based on Netty with baked-in
    cloud features such as service discovery and load balancing. This custom implementation
    enhances the standard HTTP client with microservices architecture.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 的 HTTP 客户端是一个基于 Netty 的非阻塞客户端，内置了服务发现和负载均衡等云功能。这种自定义实现增强了标准 HTTP 客户端，以适应微服务架构。
- en: 'To exhibit basic HTTP calls, we will create an HTTP client for `OwnerResource`
    in the `pet-owner` microservice. At the outset, we must have the `micronaut-http-client`
    dependency in the `pom.xml` project:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示基本的 HTTP 调用，我们将在 `pet-owner` 微服务中为 `OwnerResource` 创建一个 HTTP 客户端。一开始，我们必须在
    `pom.xml` 项目中添加 `micronaut-http-client` 依赖项：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`micronaut-http-client` encapsulated all HTTP client-related APIs, such as
    creating `RxHttpClient`, performing all HTTP operations, and handling and processing
    response payloads.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`micronaut-http-client` 封装了所有与 HTTP 客户端相关的 API，例如创建 `RxHttpClient`，执行所有 HTTP
    操作，以及处理和响应负载。'
- en: Next, we will explore how to leverage `micronaut-http-client` to perform various
    HTTP operations on the endpoint we created earlier.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何利用 `micronaut-http-client` 在我们之前创建的端点上执行各种 HTTP 操作。
- en: Performing an HTTP PUT operation
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 HTTP PUT 操作
- en: To perform an HTTP PUT operation, we can create `OwnerResourceClient`. This
    client can be packaged inside `com.packtpub.micronaut.web.rest.client`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 HTTP PUT 操作，我们可以创建 `OwnerResourceClient`。这个客户端可以打包在 `com.packtpub.micronaut.web.rest.client`
    中。
- en: 'We can add the following method to perform an HTTP call:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加以下方法来执行 HTTP 调用：
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP GET request.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient.create()` 将创建一个 HTTP 客户端，然后我们使用它来发送 HTTP GET 请求。'
- en: Performing an HTTP POST operation
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 HTTP POST 操作
- en: 'To perform an HTTP POST operation, we can add the following method to `OwnerResourceClient`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 HTTP POST 操作，我们可以向 `OwnerResourceClient` 添加以下方法：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP POST request. An owner object will be passed as the request payload.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient.create()` 将创建一个 HTTP 客户端，然后我们使用它来发送 HTTP POST 请求。一个所有者对象将被作为请求负载传递。'
- en: Performing an HTTP PUT operation
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 HTTP PUT 操作
- en: 'To perform an HTTP PUT operation, we can add the following method to `OwnerResourceClient`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 HTTP PUT 操作，我们可以向 `OwnerResourceClient` 添加以下方法：
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP PUT request. An `owner` object will be passed as the request payload.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient.create()` 将创建一个 HTTP 客户端，然后我们使用它来发送 HTTP PUT 请求。一个 `owner` 对象将被作为请求负载传递。'
- en: Performing an HTTP DELETE operation
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 HTTP DELETE 操作
- en: 'To perform an HTTP DELETE operation, we can add the following method to `OwnerResourceClient`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 HTTP DELETE 操作，我们可以向 `OwnerResourceClient` 添加以下方法：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`HttpClient.create()` will create an HTTP client that we then use to make an
    HTTP DELETE request. A no content message will be returned if the request executes
    successfully.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient.create()` 将创建一个 HTTP 客户端，然后我们使用它来发送 HTTP DELETE 请求。如果请求执行成功，将返回一个无内容消息。'
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered various aspects of working on web endpoints in a
    Micronaut application. We kick-started with the concept of assemblers or DTOs
    and then dived into how to create restful endpoints for supporting essential CRUD
    operations. Also, we experimented with some of the HTTP server APIs in the Micronaut
    framework. Lastly, we focused on the HTTP client aspects and created a client
    utility using `micronaut-http-client`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了在 Micronaut 应用程序中处理 Web 端点的各个方面。我们从组装器或 DTO 的概念开始，然后深入探讨了如何创建支持基本
    CRUD 操作的 restful 端点。我们还实验了 Micronaut 框架中的一些 HTTP 服务器 API。最后，我们专注于 HTTP 客户端方面，并使用
    `micronaut-http-client` 创建了一个客户端实用工具。
- en: This chapter has given us the skills related to various practical aspects of
    working on restful microservices in the Micronaut framework. Furthermore, by exploring
    the HTTP client, we covered these aspects end to end. This hands-on knowledge
    to work on the web layer is pivotal in developing any microservice.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了与 Micronaut 框架中 restful 微服务各种实际方面相关的技能。此外，通过探索 HTTP 客户端，我们从头到尾覆盖了这些方面。在开发任何微服务时，这种在
    Web 层面上工作的实践经验至关重要。
- en: In the next chapter, we will work on securing the web layer of the `pet-clinic`
    microservice by experimenting with different approaches and methods in safeguarding
    the restful endpoints.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过尝试不同的方法和方法来保护 restful 端点，来确保 `pet-clinic` 微服务的 Web 层安全。
- en: Questions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a DTO?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 DTO？
- en: How do you use MapStruct in the Micronaut framework?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中使用 MapStruct？
- en: How do you create a restful HTTP GET endpoint in the Micronaut framework?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中创建一个 RESTful HTTP GET 端点？
- en: How do you create a restful HTTP POST endpoint in the Micronaut framework?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中创建一个 RESTful HTTP POST 端点？
- en: How do you create a restful HTTP PUT endpoint in the Micronaut framework?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中创建一个 RESTful HTTP PUT 端点？
- en: How do you create a restful HTTP DELETE endpoint in the Micronaut framework?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中创建一个 RESTful HTTP DELETE 端点？
- en: How does Micronaut support HTTP request binding?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 框架是如何支持 HTTP 请求绑定的？
- en: How can we validate data in the Micronaut framework?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Micronaut 框架中验证数据？
- en: How can we version the APIs in the Micronaut framework?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Micronaut 框架中对 API 进行版本控制？
- en: How does Micronaut support HTTP client aspects?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 框架是如何支持 HTTP 客户端方面的？
- en: How can we create an HTTP client in the Micronaut framework?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Micronaut 框架中创建一个 HTTP 客户端？
