<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer587" class="Basic-Text-Frame">
    <h1 class="chapterNumber">23</h1>
    <h1 id="_idParaDest-550" class="chapterTitle">Native-Complied Java Microservices</h1>
    <p class="normal">In this chapter, we will learn how to compile the Java source code in our microservices into binary executable<a id="_idIndexMarker1619"/> files, known as <strong class="keyWord">Native Images</strong>. A Native Image starts up significantly faster compared to using a Java VM and is also expected to consume less memory. We will be introduced to the <strong class="keyWord">Spring AOT </strong>engine<strong class="keyWord"> </strong>introduced in Spring Framework 6 and the <strong class="keyWord">GraalVM</strong> project and its <strong class="keyWord">Native Image compiler</strong>, learning how to use them.</p>
    <p class="normal">We will cover the following topics:</p>
    <ul>
      <li class="bulletList">When to natively compile Java source code</li>
      <li class="bulletList">Introducing the GraalVM project and Spring’s AOT engine</li>
      <li class="bulletList">Handling problems with native compilation</li>
      <li class="bulletList">Testing and compiling Native Images </li>
      <li class="bulletList">Testing with Docker Compose</li>
      <li class="bulletList">Testing with Kubernetes</li>
    </ul>
    <div class="note">
      <p class="normal">Even though Spring Framework 6 and Spring Boot 3 come with <strong class="keyWord">General Availability</strong> (<strong class="keyWord">GA</strong>) support for building native executables of Spring Boot applications, it must be considered as being in an early stage. At the time of writing this chapter, a lot of pitfalls were discovered while natively compiling the microservices in this book. Since natively compiling the microservices is not required for the rest of the material in this book, this chapter is placed at the end of the book as an extra chapter, describing an exciting but not yet fully mature technology.</p>
    </div>
    <h1 id="_idParaDest-551" class="heading-1">Technical requirements</h1>
    <p class="normal">For instructions on how to install the tools used in this book and how to access the source code for this book, see:</p>
    <ul>
      <li class="bulletList"><em class="chapterRef">Chapter 21</em>, <em class="italic">Installation Instructions for macOS</em></li>
      <li class="bulletList"><em class="chapterRef">Chapter 22</em>, <em class="italic">Installation Instructions for Microsoft Windows with WSL 2 and Ubuntu</em></li>
    </ul>
    <p class="normal">The code examples in this chapter all come from the source code in <code class="inlineCode">$BOOK_HOME/Chapter23</code>.</p>
    <p class="normal">If you want to view the changes applied to the source code in this chapter so you can natively compile the microservices, you can compare it with the source code for <em class="chapterRef">Chapter 20</em>, <em class="italic">Monitoring Microservices</em>. You can use your favorite <code class="inlineCode">diff</code> tool and compare the two folders <code class="inlineCode">$BOOK_HOME/Chapter20</code> and <code class="inlineCode">$BOOK_HOME/Chapter23</code>.</p>
    <h1 id="_idParaDest-552" class="heading-1">When to native-compile Java source code</h1>
    <p class="normal">Java has always been known for its <strong class="keyWord">build-once-run-anywhere</strong> capability, providing excellent cross-platform support. The Java source code is compiled once into bytecode. At<a id="_idIndexMarker1620"/> runtime, a Java VM transforms the bytecode into executable code for the target platform using a <strong class="keyWord">Just in Time</strong> compiler, also known as <strong class="keyWord">JIT</strong> compilation. This takes some time, slowing down the<a id="_idIndexMarker1621"/> startup of Java programs. Before the era of microservices, Java components typically ran on an application server, like a Java EE server. After being deployed, the Java component ran for a long time, making the longer startup time less of a problem.</p>
    <p class="normal">With the introduction of microservices, this perspective changed. With microservices, there comes the expectation of being able to upgrade them more frequently and quickly scale instances for a microservice up and down based on its usage. Another expectation is to be able to <strong class="keyWord">scale to zero</strong>, meaning that when a microservice is not used, it should not run any instances at all. An unused microservice should not allocate any hardware resources and, even more importantly, should not create any runtime cost, for example, in a cloud deployment. To be able to meet these expectations, it is important that a microservice instance can be started swiftly. </p>
    <p class="normal">Also, with the use of containers, the importance of cross-platform support built into the application itself has faded. Instead, Docker can be used to build Docker images that contain support for multiple platforms, for example, Linux on both <code class="inlineCode">arm64</code> and <code class="inlineCode">amd64</code> (also known as <code class="inlineCode">x86_64</code>), or Docker images that can be run on Windows and Linux. For more information, see <a href="https://docs.docker.com/build/building/multi-platform/"><span class="url">https://docs.docker.com/build/building/multi-platform/</span></a>. For an example of a Docker image that contains multi-platform support, see the OpenJDK Docker image used in this book, <a href="https://hub.docker.com/_/eclipse-temurin/tags"><span class="url">https://hub.docker.com/_/eclipse-temurin/tags</span></a>.</p>
    <div class="packt_tip">
      <p class="normal">Given that the startup time for Java programs can be significantly reduced, other use cases also come to mind; for example, developing Java-based <strong class="keyWord">Function-as-a-Service</strong> (<strong class="keyWord">FaaS</strong>) solutions using<a id="_idIndexMarker1622"/> AWS Lambda, Azure Functions, or Google Cloud Functions, to mention some of the major platforms. Also, developing CLI tools in Java becomes a feasible option.</p>
    </div>
    <p class="normal">Together, these lead to<a id="_idIndexMarker1623"/> a situation where faster startup becomes a more critical requirement than cross-platform support. This requirement can be achieved by compiling the Java source code into the target platform’s binary format at build time, in the same way as C or Go programs are compiled. This is known as <strong class="keyWord">Ahead of Time</strong> compilation or <strong class="keyWord">AOT</strong> compilation. The GraalVM Native<a id="_idIndexMarker1624"/> Image compiler will be used to perform the AOT compilation.</p>
    <div class="note">
      <p class="normal">As we will see in the next section, the GraalVM Native Image compiler comes with a few restrictions, for example, relating to the use of reflection and dynamic proxies. It also takes quite some time to compile Java code into a binary Native Image. This technology has its strengths and weaknesses.</p>
    </div>
    <p class="normal">With a better understanding of when it might be of interest to natively compile Java source code, let’s learn about the tooling: first, the GraalVM project, and then, the Spring AOT engine.</p>
    <h1 id="_idParaDest-553" class="heading-1">Introducing the GraalVM project</h1>
    <p class="normal">Oracle has worked for several years on a high-performance Java VM and associated tools, known together as<a id="_idIndexMarker1625"/> the <strong class="keyWord">GraalVM</strong> project (<a href="https://www.graalvm.org"><span class="url">https://www.graalvm.org</span></a>). It was launched back in April 2018 (<a href="https://medium.com/graalvm/graalvm-in-2018-b5fa7ff3b917"><span class="url">https://medium.com/graalvm/graalvm-in-2018-b5fa7ff3b917</span></a>), but work can be traced back to, for example, a research paper from Oracle Labs in 2013 on the subject: <em class="italic">Maxine: An approachable virtual machine for, and in, java</em>; see <a href="https://dl.acm.org/doi/10.1145/2400682.2400689"><span class="url">https://dl.acm.org/doi/10.1145/2400682.2400689</span></a>.</p>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">Fun Fact</strong>: The Maxine VM is known as a <strong class="keyWord">metacircular</strong> Java VM implementation, meaning that it is, itself, written <a id="_idIndexMarker1626"/>in Java.</p>
    </div>
    <p class="normal">GraalVM’s VM is polyglot, supporting not only traditional Java VM languages such as Java, Kotlin, and Scala but also languages such as JavaScript, C, C++, Ruby, Python, and even programs compiled into a WebAssembly. The part of GraalVM that we will focus on is its <strong class="keyWord">Native Image</strong> compiler, which can be used to compile Java bytecode into a Native Image containing binary executable code for a specific <strong class="keyWord">operating system</strong> (<strong class="keyWord">OS</strong>) and HW platform, for example, macOS on Apple silicon (<code class="inlineCode">arm64</code>) or Linux on Intel (<code class="inlineCode">amd64</code>).</p>
    <p class="normal">The Native Image can run without a Java VM, including binary compiled application classes and other classes required from the application’s dependencies. It also includes a runtime <a id="_idIndexMarker1627"/>system called <strong class="keyWord">Substrate VM</strong>, which handles garbage collection, thread scheduling, and more.</p>
    <p class="normal">To be able to build a Native Image, the native compiler runs static code analysis based on a closed-world assumption, meaning that all bytecode that can be called at runtime must be reachable during build time. Therefore, it is not possible to load or create classes on the fly in runtime that was not available during the AOT compilation.</p>
    <p class="normal">To overcome these restrictions, the GraalVM project provides configuration options for the native compiler where <a id="_idIndexMarker1628"/>we can provide <strong class="keyWord">reachability metadata</strong>. With this configuration, we can describe the use of dynamic features like reflection and the generation of proxy classes at runtime. For more information, see <a href="https://www.graalvm.org/22.3/reference-manual/native-image/metadata/"><span class="url">https://www.graalvm.org/22.3/reference-manual/Native Image/metadata/</span></a>. We will learn later in this chapter various ways to create the required reachability metadata. </p>
    <p class="normal">The GraalVM Native Image compiler can be launched using a CLI command, <code class="inlineCode">Native Image</code>, or as part of a Maven or Gradle build. GraalVM provides a plugin for both Maven and <a id="_idIndexMarker1629"/>Gradle. In this chapter, the Gradle plugin will be used. </p>
    <p class="normal">With GraalVM introduced, it is time to learn about Spring’s AOT engine.</p>
    <h1 id="_idParaDest-554" class="heading-1">Introducing the Spring’s AOT engine</h1>
    <p class="normal">The Spring team has also worked on supporting the native compilation of Spring applications for some time. In <a id="_idIndexMarker1630"/>March 2021, after 18 months of work, the experimental <strong class="keyWord">Spring Native</strong> project launched a beta release; see <a href="https://spring.io/blog/2021/03/11/announcing-spring-native-beta"><span class="url">https://spring.io/blog/2021/03/11/announcing-spring-native-beta</span></a>. Based on the experiences from the Spring Native Project, official support for building Native Images was added in Spring Framework 6 and Spring Boot 3; see <a href="https://spring.io/blog/2023/02/23/from-spring-native-to-spring-boot-3"><span class="url">https://spring.io/blog/2023/02/23/from-spring-native-to-spring-boot-3</span></a>. To perform the actual native compilation, Spring uses GraalVM’s Native Image compiler under the hood. </p>
    <p class="normal">The most important feature is Spring’s new <strong class="keyWord">AOT engine</strong>, which <a id="_idIndexMarker1631"/>analyzes the Spring Boot application at build time and generates initialization source code and reachability metadata required by the GraalVM Native Image compiler. The generated initialization source<a id="_idIndexMarker1632"/> code, also known as <strong class="keyWord">AOT-generated code</strong>, replaces the reflection-based initialization performed when using a Java VM, eliminating most of the requirements of dynamic features like reflection and the generation of proxy classes at runtime.</p>
    <p class="normal">When this AOT processing is performed, a closed-world assumption is made in the same way as for the GraalVM Native Image compiler. This means that only Spring beans and classes reachable at build time will be represented in the AOT-generated code and reachability metadata. Special attention must be given to Spring beans that only are created if some profiles are set or if some conditions are met, using <code class="inlineCode">@Profile</code> or <code class="inlineCode">@ConditionalOnProperty</code> annotations. These profiles and conditions must be set at build time; otherwise, these Spring beans will not be represented in the Native Image. </p>
    <p class="normal">To perform the analysis, the AOT engine creates bean definitions for all Spring beans it can find by scanning the source code of the application. But instead of instantiating the Spring beans, meaning starting the application, it generates the corresponding initialization code that will instantiate the Spring beans when executed. For all uses<a id="_idIndexMarker1633"/> of the dynamic features, it will also generate the required reachability metadata.</p>
    <p class="normal">The process of creating a Native Image from the source code of a Spring Boot application is summarized by the following data flow diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19825_23_01.png" alt="A picture containing text, screenshot, diagram, line  Description automatically generated" width="878" height="461"/></figure>
    <p class="packt_figref">Figure 23.1: Data flow diagram explaining the creation of a Native Image</p>
    <p class="normal">The creation of a Native Image goes through the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The application’s source code is compiled into bytecode by the Java compiler.</li>
      <li class="numberedList">Spring’s AOT engine analyzes the code under a closed-world assumption and generates AOT source code and reachability metadata.</li>
      <li class="numberedList">The AOT-generated code is compiled into bytecode using the Java compiler. </li>
      <li class="numberedList">The application’s bytecode, together with the reachability metadata and bytecode created by the AOT engine, is sent to GraalVM’s Native Image compiler, which creates the Native Image.</li>
    </ol>
    <p class="normal">For more information on how the creation of GraalVM Native Images is supported in Spring Boot 3, see <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html"><span class="url">https://docs.spring.io/spring-boot/docs/current/reference/html/Native Image.html</span></a>.</p>
    <p class="normal">Building a Native Image can be done in two ways:</p>
    <ul>
      <li class="bulletList">Creating a<a id="_idIndexMarker1634"/> Native Image for the current OS:
    <p class="normal">The first option uses Gradle’s <code class="inlineCode">nativeImage</code> task. It will use the installed GraalVM’s Native Image compiler to create an executable file for the current OS and hardware architecture. The nativeImage task is available given that GraalVM’s Gradle-plugin is declared in the build file.</p></li>
    </ul>
    <ul>
      <li class="bulletList">Creating a Native Image as a Docker image
    <p class="normal">The second option is to use the existing Gradle task, <code class="inlineCode">bootBuildImage</code>, to create a Docker image. Given that GraalVM’s Gradle plugin is declared in the build file, the bootBuildImage task will create a Docker image that contains the Native Image instead of a Java VM with the application’s JAR file that is used otherwise. The Native Image will be built in a Docker container so that it will be built for Linux. This also means that the GraalVM’s Native Image compiler does not need to be installed when the bootBuildImage task is used. Under the hood, this task uses <strong class="keyWord">buildpacks</strong>, instead of a Dockerfile, to create the Docker image.</p></li>
    </ul>
    <div class="note">
      <p class="normal">The concept of buildpacks was introduced by Heroku back in 2011. In 2018, the <strong class="keyWord">Cloud Native Buildpacks</strong> project (<a href="https://buildpacks.io"><span class="url">https://buildpacks.io</span></a>) was created by Pivotal and Heroku, and later <a id="_idIndexMarker1635"/>that year, it joined CNCF.</p>
      <p class="normal">To be a bit more formal, a buildpack creates an <strong class="keyWord">OCI image</strong>, according to the OCI Image Format Specification: <a href="https://github.com/opencontainers/image-spec/blob/master/spec.md"><span class="url">https://github.com/opencontainers/image-spec/blob/master/spec.md</span></a>. Since the OCI specification is based on Docker’s image format, the formats are very similar and are both supported by container engines.</p>
    </div>
    <p class="normal">To create the OCI images, Spring Boot uses buildpacks from the <strong class="keyWord">Paketo</strong> project; for more<a id="_idIndexMarker1636"/> information, see <a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/container-images.html#container-images.buildpacks"><span class="url">https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/container-images.html#container-images.buildpacks</span></a> and <a href="https://paketo.io/docs/builders"><span class="url">https://paketo.io/docs/builders</span></a>. Unfortunately, Paketo’s buildpacks did not support <code class="inlineCode">arm64</code>, including Apple silicon, at the time of writing this chapter. The <code class="inlineCode">amd64</code> (Intel)-based buildpacks technically works on a MacBook with Apple silicon but runs painfully slowly. As suggested here, <a href="https://www.cloudfoundry.org/blog/arm64-paketo-buildpacks/"><span class="url">https://www.cloudfoundry.org/blog/arm64-paketo-buildpacks/</span></a>, unofficial Docker images for <code class="inlineCode">arm64</code> can be used as a temporary workaround. They are available here: <a href="https://hub.docker.com/r/dashaun/builder-arm"><span class="url">https://hub.docker.com/r/dashaun/builder-arm</span></a>. </p>
    <p class="normal">Creating Native Images <a id="_idIndexMarker1637"/>with the <code class="inlineCode">nativeImage</code> task for the local OS is faster than creating Docker images. Therefore, the <code class="inlineCode">nativeImage</code> task can be used for a quick feedback loop when initially trying to build a Native Image successfully. But once that has been worked out, creating Docker images containing the Native Image is the most useful alternative for testing natively compiled microservices, together with either Docker Compose or Kubernetes. In this chapter, we will use the unofficial Docker images mentioned above, named <code class="inlineCode">dashaun/builder:tiny</code>. Docker images for both <code class="inlineCode">arm64</code> and <code class="inlineCode">amd64</code> are provided.</p>
    <p class="normal">Several tools and projects are available to help eliminate challenges with native compilation. The next section will give an overview of them, and in the <em class="italic">Testing and compiling Native Images</em> section, we will learn how to use them.</p>
    <h1 id="_idParaDest-555" class="heading-1">Handling problems with native compilation</h1>
    <p class="normal">Natively compiling Spring Boot applications is, as already mentioned, not yet mainstream. Therefore, you will <a id="_idIndexMarker1638"/>probably run into problems when trying it out on your own applications. This section will go through a few projects and tools that can be used to handle these problems. Examples of how to use these tools will be provided in the sections below.</p>
    <p class="normal">The following project and tools can be used to handle problems with native compilation of Spring Boot applications:</p>
    <ul>
      <li class="bulletList">Spring AOT smoke tests: <p class="normal">This project contains a suite of tests verifying that the various Spring projects work when natively compiled. Whenever you encounter issues with natively compiling a Spring feature, you should start looking into this project for a working solution. Also, if you want to report a problem with natively compiling a Spring project, you can use tests from this project as a boilerplate to demonstrate the problem in a reproducible <a id="_idIndexMarker1639"/>way. The project is available at <a href="https://github.com/spring-projects/spring-aot-smoke-tests"><span class="url">https://github.com/spring-projects/spring-aot-smoke-tests</span></a>. Test results can be found in Spring’s CI environment. For example, the tests of the various Spring Cloud projects can be found here: <a href="https://ci.spring.io/teams/spring-aot-smoke-tests/pipelines/spring-aot-smoke-tests-3.0.x?group=cloud-app-tests"><span class="url">https://ci.spring.io/teams/spring-aot-smoke-tests/pipelines/spring-aot-smoke-tests-3.0.x?group=cloud-app-tests</span></a>.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList">GraalVM reachability metadata repository: <p class="normal">This project contains reachability metadata for various open-source projects that do not yet support native compilation themselves. The GraalVM community can submit reachability metadata, which is approved after a review by the project’s team. GraalVM’s Gradle plugin automatically looks up reachability metadata from this project and adds it when natively compiling. For more information, see <a href="https://graalvm.github.io/native-build-tools/0.9.18/gradle-plugin.html#metadata-support"><span class="url">https://graalvm.github.io/native-build-tools/0.9.18/gradle-plugin.html#metadata-support</span></a>.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList">Testing AOT-generated code with the Java VM: <p class="normal">Since natively compiling a Spring Boot application takes a few minutes, an interesting alternative can be to try out the initialization code generated by the Spring AOT engine on the Java VM. Normally the AOT-generated code is ignored when using a Java VM, but this can be changed by setting the system property <code class="inlineCode">spring.aot.enabled</code> to <code class="inlineCode">true</code>. This means that the normal reflection-based initialization of the application is replaced by executing the generated initialization code. This can be used as a quick verification that the generated initialization code works as expected. Another positive effect is that the application starts slightly faster.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList">Providing custom hints: <p class="normal">If an application requires custom reachability metadata for the GraalVM Native Image compiler to create a Native Image, they can be provided as JSON files<a id="_idIndexMarker1640"/> as described in the <em class="italic">Introducing the GraalVM project</em> section. Spring provides an alternative to the JSON files by either using an annotation named <code class="inlineCode">@RegisterReflectionForBinding</code> or implementing the <code class="inlineCode">RuntimeHintsRegistrar</code> interface in a class, which can be activated by using the <code class="inlineCode">@ImportRuntimeHints</code> annotation. The <code class="inlineCode">RegisterReflectionForBinding</code> annotation is easier to use, but implementing the <code class="inlineCode">RuntimeHintsRegistrar</code> interface gives full control of the hints specified. </p>
        <p class="normal">One important benefit of using Spring’s custom hints over using GraalVM JSON files is that the custom hints are type-safe and checked by the compiler. If an entity referred to in a GraalVM JSON file is renamed, but the JSON file is not updated, that metadata is lost. This will result in the GraalVM Native Image compiler failing to create a Native Image. </p>
        <p class="normal">When using custom hints, the source code will not even compile; typically, the IDE will complain as soon as the entity is renamed that the custom hint is no longer valid.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList">Running native tests: <p class="normal">Even though testing AOT-generated code with the Java VM can give a quick indication of whether the native compilation will work, we still need to create the Native Image of the application to test it fully. A feedback loop based on creating a Native Image, starting the application, and finally running some tests by hand is very slow and error-prone. A compelling alternative to this process is to run <strong class="keyWord">native tests</strong>, where Spring’s Gradle plugin automatically will create a Native Image and then run JUnit tests defined<a id="_idIndexMarker1641"/> in the application’s project using the Native Image. This still will take time due to the native compilation, but the process is fully automated and repeatable. After ensuring the native tests run as expected, they can be placed in a CI build pipeline for automated execution. Native tests can be started using Gradle with this command: </p>
     
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">gradle nativeTest</span>
</code></pre> </li>
    </ul>
    <ul>
      <li class="bulletList">Using GraalVM’s tracing agent: <p class="normal">If it turns out to be hard to determine what reachability metadata and/or custom hints are required to create a working Native Image for an application, GraalVM’s tracing agent can help out. If the tracing agent is enabled when running the application in the Java VM, it can gather the required reachability metadata based on how the application uses reflection, resources, and proxies. This is specifically useful if run<a id="_idIndexMarker1642"/> together with JUnit tests since gathering the required reachability metadata will be automated and repeatable.</p>
        <p class="normal">With the tooling introduced and explained for how to handle the main expected challenges, let’s see what changes are required in the source code to be able to natively compile the microservices.</p>
      </li>
    </ul>
    <h1 id="_idParaDest-556" class="heading-1">Changes in the source code</h1>
    <p class="normal">Before compiling the Java source code in the microservices into native executable images, the source code needs to be updated a bit. To be able to natively compile the <a id="_idIndexMarker1643"/>microservices, the following changes have been applied to the source code:</p>
    <ul>
      <li class="bulletList">The Gradle build files, <code class="inlineCode">build.gradle</code>, have been updated by adding the GraalVM plugin, adjusting some dependencies, and configuring the <code class="inlineCode">bootBuildImage</code> command.</li>
      <li class="bulletList">Required reachability metadata and custom hints have been added.</li>
      <li class="bulletList">Build time property files have been added to ensure that required Spring beans are reachable during the AOT processing at build time.</li>
      <li class="bulletList">Some properties used at runtime have been added to the <code class="inlineCode">config-repo</code> to make the natively compiled microservices operate successfully.</li>
      <li class="bulletList">The configuration to be able to run the GraalVM Native Image tracing agent has been added.</li>
      <li class="bulletList">The verification script, <code class="inlineCode">test-em-all.bash</code>, has been updated since the Docker images no longer include the <code class="inlineCode">curl</code> command.</li>
      <li class="bulletList">Native tests have been disabled using the annotation <code class="inlineCode">@DisabledInNativeImage</code> at the class level as described in the <em class="italic">Running native tests</em> section.</li>
      <li class="bulletList">Two new Docker Compose files for using the Docker images containing the Native Images have been added.</li>
      <li class="bulletList">A system property has been added to the microservices’ <code class="inlineCode">Dockerfile</code> to simplify toggling AOT mode. The <code class="inlineCode">ENVIRONMENT</code> command has been updated to disable<a id="_idIndexMarker1644"/> AOT mode when run with the Java VM. It looks like this:
        <pre class="programlisting code"><code class="hljs-code">ENTRYPOINT <span class="hljs-selector-attr">[</span><span class="hljs-string">"java"</span><span class="hljs-selector-attr">, </span><span class="hljs-string">"-Dspring.aot.enabled=false"</span><span class="hljs-selector-attr">, </span><span class="hljs-string">"org.springframework.boot.loader.JarLauncher"</span><span class="hljs-selector-attr">]</span>
</code></pre>
      </li>
    </ul>
    <div class="packt_tip">
      <p class="normal">Note that it doesn’t work to specify <code class="inlineCode">spring.aot.enabled</code> as an environment variable or in a property file; it has to be set as a system property on the <code class="inlineCode">java</code> command.</p>
    </div>
    <p class="normal">Let’s go through the changes one by one and start with changes applied to the build files.</p>
    <h2 id="_idParaDest-557" class="heading-2">Updates to the Gradle build files</h2>
    <p class="normal">The changes described in this <a id="_idIndexMarker1645"/>section have been applied to the <code class="inlineCode">build.gradle</code> files in each microservice project unless stated otherwise.</p>
    <p class="normal">The following updates have been applied:</p>
    <ul>
      <li class="bulletList">To enable Spring AOT tasks, the GraalVM plugin has been added:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">plugins</span> {
    <span class="hljs-string">...</span>
    <span class="hljs-string">id</span> <span class="hljs-string">'org.graalvm.buildtools.native'</span> <span class="hljs-string">version</span> <span class="hljs-string">'</span><span class="hljs-string">0.9.18'</span>
}
</code></pre>
      </li>
      <li class="bulletList">The <code class="inlineCode">bootBuildImage</code> task is configured to specify the name of the Docker image that is created. The same naming conventions are used as in earlier chapters, but the name of the image is prefixed with <code class="inlineCode">native-</code> to separate it from the existing Docker images. Also, a Docker image for the builder that supports <code class="inlineCode">arm64</code>, <code class="inlineCode">dashaun/builder:tiny</code>, is specified. For the <code class="inlineCode">product</code> microservice, the configuration looks like this:
        <pre class="programlisting code"><code class="hljs-code">tasks.named(<span class="hljs-string">'bootBuildImage'</span>) {
    imageName = <span class="hljs-string">"hands-on/native-product-service"</span>
    builder = <span class="hljs-string">"dashaun/builder:tiny"</span>
}
</code></pre>
      </li>
      <li class="bulletList">To get around some problems with native compilation, Spring Boot has been upgraded from v3.0.4, as used in the other chapters, to v3.0.5. For the same reason, <code style="font-weight: bold;" class="codeHighlighted">springdoc-openapi</code> has been upgraded from v2.0.2 to v2.1.0.</li>
      <li class="bulletList">Due to the issue described at <a href="https://github.com/spring-projects/spring-boot/issues/33238"><span class="url">https://github.com/spring-projects/spring-boot/issues/33238</span></a>, the <code class="inlineCode">jar</code> task is no longer disabled. </li>
    </ul>
    <div class="packt_tip">
      <p class="normal">To recap why the <code class="inlineCode">jar</code> task was disabled, see the <em class="italic">Implementing our API</em> section in <em class="chapterRef">Chapter 3</em>.</p>
    </div>
    <p class="normal">These are all the changes required for the build files. In the next section, we will learn about how we need to help the native compiler to <a id="_idIndexMarker1646"/>compile our source code in some cases.</p>
    <h2 id="_idParaDest-558" class="heading-2">Providing reachability metadata and custom hints</h2>
    <p class="normal">There are a few cases in the source code where the GraalVM native compiler needs help to be able to compile the<a id="_idIndexMarker1647"/> source code correctly. The first case is the JSON-based APIs and messages that the microservices use. The JSON parser, Jackson, must be able to create Java objects based on the JSON documents that the microservices receive. Jackson uses reflection to perform this work, and we need to tell the native compiler about the classes to which Jackson will apply reflection.</p>
    <p class="normal">For example, a native hint for the <code class="inlineCode">Product</code> class looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">@RegisterReflectionForBinding</span>({ <span class="hljs-title">Event</span>.<span class="hljs-keyword">class</span>, <span class="hljs-title">ZonedDateTimeSerializer</span>.<span class="hljs-keyword">class</span>, <span class="hljs-title">Product</span>.<span class="hljs-keyword">class</span>})<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceApplication</span> {
</code></pre>
    <p class="normal">All necessary custom hint annotations have been added to each microservice’s main class.</p>
    <p class="normal">When this chapter was written, the Resilience4J annotations did not work properly when natively compiled. In issue <code class="inlineCode">#1882</code>, a solution for this problem is proposed by providing an implementation of the <code class="inlineCode">RuntimeHintsRegistrar</code> interface. For details, see <a href="https://github.com/resilience4j/resilience4j/issues/1882"><span class="url">https://github.com/resilience4j/resilience4j/issues/1882</span></a>. This solution has been applied to the <code class="inlineCode">NativeHintsConfiguration</code> class in the <code class="inlineCode">product-service</code> project. The most central parts of the class look like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ImportRuntimeHints(NativeHintsConfiguration.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NativeHintsConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RuntimeHintsRegistrar</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHints</span><span class="hljs-params">(RuntimeHints hints, ClassLoader classLoader)</span> {
    hints.reflection().registerType(CircuitBreakerAspect.class,
      builder -&gt; builder.withMembers(INVOKE_DECLARED_METHODS));
    hints.reflection().registerType(RetryAspect.class,
      builder -&gt; builder.withMembers(INVOKE_DECLARED_METHODS));
    hints.reflection().registerType(TimeLimiterAspect.class,
      builder -&gt; builder.withMembers(INVOKE_DECLARED_METHODS));
  }
}
</code></pre>
    <p class="normal">From the source code above, we can see that hints are registered for the three annotations used in the <code style="font-weight: bold;" class="codeHighlighted">product-composite</code> microservice, the circuit breaker, retry, and time limiter. The class also provides the necessary configuration by importing itself using the <code class="inlineCode">ImportRuntimeHints</code> annotation.</p>
    <p class="normal">A final corner case is <a id="_idIndexMarker1648"/>that we must provide reachability metadata for Resilience4J’s use of reflection in the declaration of the <code class="inlineCode">retry</code> mechanism. The configuration looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">resilience4j.retry</span><span class="hljs-punctuation">:</span>
  <span class="hljs-attribute">instances</span><span class="hljs-punctuation">:</span>
    <span class="hljs-attribute">product</span><span class="hljs-punctuation">:</span>
      <span class="hljs-attribute">maxAttempts</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3</span>
      <span class="hljs-attribute">waitDuration</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1000</span>
      <span class="hljs-attribute">retryExceptions</span><span class="hljs-punctuation">:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">org.springframework.web.reactive.function.client.WebClientResponseException$InternalServerError</span>
</code></pre>
    <p class="normal">This configuration will enable the<code class="inlineCode"> retry</code> mechanism to retry errors of type <code class="inlineCode">InternalServerError</code>. To let the GraalVM Native Image compiler know that reflection must be enabled for this<a id="_idIndexMarker1649"/> class, the third way of supplying reachability metadata has been used: by providing a GraalVM config file. See <code class="inlineCode">src/main/resources/META-INF/Native Image/reflect-config.json</code> in the <code style="font-weight: bold;" class="codeHighlighted">product-composite</code> project.</p>
    <p class="normal">We now know how to provide metadata and custom hints for our own source code. Next, we will learn how we can ensure that Spring beans required at runtime also exist at build time so that the AOT processing can introspect them and generate proper AOT code.</p>
    <h2 id="_idParaDest-559" class="heading-2">Enabling Spring beans at build time in application.yml files</h2>
    <p class="normal">As mentioned above, due to the closed-world assumption that the static analysis uses at build time, all Spring beans required at runtime must be reachable at build time. Otherwise, they cannot be <a id="_idIndexMarker1650"/>activated at runtime. Given that they are reachable at build time, they can be configured at runtime. To<a id="_idIndexMarker1651"/> summarize, this means that if you are using Spring beans that are only created if some profiles are set or if some conditions are met (using the <code class="inlineCode">@Profile</code> or <code class="inlineCode">@ConditionalOnProperty</code> annotations), you must ensure that these profiles and conditions are met at build time.</p>
    <p class="normal">For example, the possibility to specify a separate management port at runtime when using a natively compiled microservice is only possible if the management port was set to a random port (different from the standard port) at build time. Therefore, each microservice has an <code class="inlineCode">application.yml</code> file in its <code class="inlineCode">src/main/resources</code> folder that specifies:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Required to make the Spring AOT engine generate the appropriate infrastructure for a separate management port at build time</span>
<span class="hljs-attr">management.server.port:</span> <span class="hljs-number">9009</span>
</code></pre>
    <p class="normal">With this specified at build time, when the Native Image is created, the management port can be set to<a id="_idIndexMarker1652"/> any value at runtime using property files in the <code class="inlineCode">config-repo</code> folder.</p>
    <p class="normal">Below is a list of all properties set at build time in the <code class="inlineCode">application.yml</code> files to avoid these types of<a id="_idIndexMarker1653"/> problems for various Spring beans used by the four microservices:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Required to make Springdoc handling forward headers correctly when natively compiled</span>
<span class="hljs-attr">server.forward-headers-strategy:</span> <span class="hljs-string">framework</span>
<span class="hljs-comment"># Required to make the Spring AOT engine generate the appropriate infrastructure for a separate management port, Prometheus, and K8S probes at build time</span>
<span class="hljs-attr">management.server.port:</span> <span class="hljs-number">9009</span>
<span class="hljs-attr">management.endpoint.health.probes.enabled:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">management.endpoints.web.exposure.include:</span> <span class="hljs-string">health,info,circuitbreakerevents,prometheus</span>
<span class="hljs-comment"># Required to make the Spring AOT engine generate a ReactiveJwtDecoder for the OIDC issuer</span>
<span class="hljs-attr">spring.security.oauth2.resourceserver.jwt.issuer-uri:</span> <span class="hljs-string">http://someissuer</span>
<span class="hljs-comment"># See https://github.com/springdoc/springdoc-openapi/issues/1284#issuecomment-1279854219</span>
<span class="hljs-attr">springdoc.enable-native-support:</span> <span class="hljs-literal">true</span>
<span class="hljs-comment"># Native Compile: Point out that RabbitMQ is to be used when performing the native compilation</span>
<span class="hljs-attr">spring.cloud.stream.defaultBinder:</span> <span class="hljs-string">rabbit</span>
<span class="hljs-comment"># Native Compile: Required to disable the health check of RabbitMQ when using Kafka</span>
<span class="hljs-comment"># management.health.rabbit.enabled: false</span>
<span class="hljs-comment"># Native Compile: Required to disable the health check of Kafka when using RabbitMQ</span>
<span class="hljs-attr">management.health.kafka.enabled:</span> <span class="hljs-literal">false</span>
<span class="hljs-comment"># Native Compile: Required to get the circuit breaker's health check to work properly</span>
<span class="hljs-attr">management.health.circuitbreakers.enabled:</span> <span class="hljs-literal">true</span>
</code></pre>
    <div class="note">
      <p class="normal">As reported in issue <code class="inlineCode">#2255</code>, the Swagger UI does not display the <strong class="keyWord">Authorize</strong> button when natively compiled. See <a href="https://github.com/springdoc/springdoc-openapi/issues/2255"><span class="url">https://github.com/springdoc/springdoc-openapi/issues/2255</span></a>.</p>
    </div>
    <p class="normal">There can also exist cases where natively compiled microservices also require slightly different <a id="_idIndexMarker1654"/>configurations at runtime; this will be covered in the next section.</p>
    <h2 id="_idParaDest-560" class="heading-2">Updated runtime properties</h2>
    <p class="normal">In one case, a runtime property also needs to be updated when using natively compiled images. That is the <a id="_idIndexMarker1655"/>connection string for the MySQL database used by the <code class="inlineCode">review</code> microservice. Since not all character sets are represented in the Native Image by default, we must specify one as available in the Native Image. We will use the UTF-8 character set. This is done for all MySQL connection properties in the review config file <code class="inlineCode">config-repo/review.yml</code>. It looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.datasource.url:</span> <span class="hljs-string">jdbc:mysql://localhost/review-db?useUnicode=true&amp;connectionCollation=utf8_general_ci&amp;characterSetResults=utf8&amp;characterEncoding=utf-8</span>
</code></pre>
    <p class="normal">With the required changes of properties both at build time and runtime covered, let’s learn how to configure the GraalVM Native Image tracing agent.</p>
    <h2 id="_idParaDest-561" class="heading-2">Configuration of the GraalVM Native Image tracing agent</h2>
    <p class="normal">In cases where it is hard to determine what reachability metadata and/or custom hints are required, we can use the<a id="_idIndexMarker1656"/> GraalVM Native Image tracing agent. As previously mentioned, it can, at runtime, detect the usage of reflection, resources, and proxies and create the required <a id="_idIndexMarker1657"/>reachability metadata based on that. </p>
    <p class="normal">To enable the tracing agent to observe the execution of JUnit tests, the following <code class="inlineCode">jvmArgs</code> can be added to the <code class="inlineCode">build.gradle</code> file in the <code class="inlineCode">test</code> section:</p>
    <pre class="programlisting code"><code class="hljs-code">tasks.named(<span class="hljs-string">'test'</span>) {
    useJUnitPlatform()
    jvmArgs <span class="hljs-string">"-agentlib:Native Image-agent=access-filter-file=src/test/resources/access-filter.json,config-output-dir=src/main/resources/META-INF/Native Image"</span>
}
</code></pre>
    <p class="normal">Since the tracing agent is not required to make native compilation work for the microservices in this book, this configuration is commented out in the build files.</p>
    <p class="normal">The parameter <code class="inlineCode">Native Image-agent=access-filter-file</code> specifies a file listing Java packages and classes that the <a id="_idIndexMarker1658"/>tracing agent should exclude, typically test-related classes that we have no use for at runtime. </p>
    <p class="normal">For example, for the <code class="inlineCode">product</code> microservice, the<a id="_idIndexMarker1659"/> file <code class="inlineCode">src/test/resources/access-filter.json</code> looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span> <span class="hljs-attr">"rules"</span><span class="hljs-punctuation">:</span>
  <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"org.apache.maven.surefire.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"net.bytebuddy.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"org.apiguardian.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"org.junit.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"org.gradle.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"org.mockito.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"org.springframework.test.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"org.springframework.boot.test.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">org.testcontainers.**"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"se.magnus.microservices.core.product.MapperTests"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"se.magnus.microservices.core.product.MongoDbTestBase"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"se.magnus.microservices.core.product.PersistenceTests"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span><span class="hljs-attr">"excludeClasses"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"se.magnus.microservices.core.product.ProductServiceApplicationTests"</span><span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The folder specified by the <code class="inlineCode">config-output-dir</code> parameter will contain the generated configuration files. The specified folder, <code class="inlineCode">src/main/resources/META-INF/Native Image</code>, is where the GraalVM native compiler looks for reachability metadata.</p>
    <p class="normal">Finally, let’s learn how the verification script has been adopted to be able to test the Native Images.</p>
    <h2 id="_idParaDest-562" class="heading-2">Updates to the test-em-all.bash verification script</h2>
    <p class="normal">In the previous chapters, <code class="inlineCode">eclipse-temurin</code> was used as the base image for the Docker images. The verification script, <code class="inlineCode">test-em-all.bash</code>, uses the <code class="inlineCode">curl</code> command that comes with that base image for<a id="_idIndexMarker1660"/> running circuit breaker tests inside the <code class="inlineCode">product-composite</code> container. </p>
    <div class="packt_tip">
      <p class="normal">The verification script runs the <code class="inlineCode">curl</code> command inside the <code class="inlineCode">product-composite</code> container since the endpoints used to verify the functionality of the circuit breaker are not exposed outside of the internal network in Docker.</p>
    </div>
    <p class="normal">With natively compiled microservices, the Docker image will no longer contain utility tools like the <code class="inlineCode">curl</code> command. To overcome this problem, the <code class="inlineCode">curl</code> commands are executed from the <code style="font-weight: bold;" class="codeHighlighted">auth-server</code>'s container, whose Docker image still is based on <code class="inlineCode">eclipse-temurin</code> and therefore contains the required <code class="inlineCode">curl</code> command.</p>
    <p class="normal">Since the tests of the circuit breaker are executed from the <code style="font-weight: bold;" class="codeHighlighted">auth-server</code>, the hostname, <code class="inlineCode">localhost</code>, is replaced with <code class="inlineCode">product-composite</code>.</p>
    <p class="normal">For details, see the verification script <code class="inlineCode">test-em-all.bash</code>.</p>
    <p class="normal">With the required changes in the source code explained, let’s learn how to use the various tools mentioned in the previous sections to test and create Native Images for the microservices.</p>
    <h1 id="_idParaDest-563" class="heading-1">Testing and compiling Native Images</h1>
    <p class="normal">Now, it is time to try out the tools for<a id="_idIndexMarker1661"/> testing and building Native Images! </p>
    <p class="normal">The following tools will be covered in this section:</p>
    <ul>
      <li class="bulletList">Running the <a id="_idIndexMarker1662"/>tracing agent</li>
      <li class="bulletList">Executing native tests</li>
      <li class="bulletList">Creating a Native Image for the current OS</li>
      <li class="bulletList">Creating a Native Image as a Docker image</li>
    </ul>
    <p class="normal">Since the first three tools require that the GraalVM and its <code class="inlineCode">Native Image</code> compiler are installed locally, we must install them first. Next, we will go through the tools one by one.</p>
    <h2 id="_idParaDest-564" class="heading-2">Installing GraalVM and its Native Image compiler </h2>
    <p class="normal">If you want to try out native tests, the tracing agent, or the native compiler without using Docker, you must <a id="_idIndexMarker1663"/>first install the GraalVM JDK together with the Native Image compiler. </p>
    <p class="normal">It can be done by the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">To install GraalVM, <strong class="keyWord">SDKman</strong> (<a href="https://sdkman.io"><span class="url">https://sdkman.io</span></a>) will be used. If not already installed, it can be<a id="_idIndexMarker1664"/> installed with the following commands:
        <pre class="programlisting con"><code class="hljs-con">curl -s "https://get.sdkman.io" | bash
source "$HOME/.sdkman/bin/sdkman-init.sh"
</code></pre>
      </li>
      <li class="numberedList">Verify that SDKman was installed correctly with the following command:
        <pre class="programlisting con"><code class="hljs-con">sdk version
</code></pre>
    <p class="normal">Expect it to return something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">SDKMAN 5.18.1
</code></pre>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">On Linux, GraalVM’s Native Image compiler requires GCC to be installed. If you are running an Ubuntu instance under WSL 2 on Windows, you can install GCC with the required dependencies with the following command:
        <pre class="programlisting con"><code class="hljs-con">sudo apt install -y build-essential libz-dev zlib1g-dev
</code></pre>
      </li>
      <li class="numberedList">Now GraalVM can be installed. Version 22.3.1 for Java 17 is used in this book. It can be installed and set to the default Java version with the following commands:
        <pre class="programlisting con"><code class="hljs-con">sdk install java 22.3.1.r17-grl 
sdk default java 22.3.1.r17-grl
</code></pre>
      </li>
      <li class="numberedList">Finally, the Native Image compiler can be installed with the following command:
        <pre class="programlisting con"><code class="hljs-con">gu install Native Image
</code></pre>
      </li>
      <li class="numberedList">To verify the installation, run the following commands:
        <pre class="programlisting con"><code class="hljs-con">java -version
gu list
</code></pre>
    <p class="normal">Expect a response from the <code class="inlineCode">java -version</code> command like:</p>
    <pre class="programlisting con"><code class="hljs-con">openjdk version "17.0.6" 2023-01-17
OpenJDK Runtime Environment GraalVM CE 22.3.1 (build 17.0.6+10-jvmci-22.3-b13)
OpenJDK 64-Bit Server VM GraalVM CE 22.3.1 (build 17.0.6+10-jvmci-22.3-b13, mixed mode, sharing)
</code></pre>
    <p class="normal">For the <code class="inlineCode">gu list</code> command, expect:</p>
    <pre class="programlisting con"><code class="hljs-con">ComponentId              Version             Component name
-----------------------------------------------------------
graalvm                  22.3.1              GraalVM Core  
Native Image             22.3.1              Native Image  
</code></pre>
      </li>
    </ol>
    <p class="normal">Now we are ready to try out <a id="_idIndexMarker1665"/>the tools; let’s start with the tracing agent!</p>
    <h2 id="_idParaDest-565" class="heading-2">Running the tracing agent</h2>
    <p class="normal">For the microservices in this book, the tracing agent is not required. But it can be of interest to see how to <a id="_idIndexMarker1666"/>use it for other cases: if, for example, one of your own microservices will require help from the tracing agent to generate the required reachability metadata.</p>
    <p class="normal">If you want to try out the tracing agent, you can do so with the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Activate the <code class="inlineCode">jvmArgs</code> parameter in the section of the <code class="inlineCode">build.gradle</code> file for the selected microservice by removing the preceding comment characters <code class="inlineCode">//</code>.</li>
      <li class="numberedList">Run a <code class="inlineCode">gradle test</code> command, in this case for the <code class="inlineCode">product</code> service:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter23
./gradlew :microservices:product-service:test --no-daemon
</code></pre>
        <ul>
          <li class="bulletList">This is a normal <code class="inlineCode">gradle test</code> command, but to avoid running out of memory, we disable the use of the Gradle daemon. By default, the daemon is limited to using 512 MB for its heap, which is insufficient for the tracing agent in most cases.</li>
        </ul>
      </li>
      <li class="numberedList">After the tests are complete, you should find the following files in the <code class="inlineCode">microservices/product-service/src/main/resources/META-INF/Native Image</code> folder:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">jni-config.json</span>
predefined-classes-<span class="hljs-built_in">config</span>.<span class="hljs-keyword">json</span>
proxy-<span class="hljs-built_in">config</span>.<span class="hljs-keyword">json</span>
reflect-<span class="hljs-built_in">config</span>.<span class="hljs-keyword">json</span>
resource-<span class="hljs-built_in">config</span>.<span class="hljs-keyword">json</span>
serialization-<span class="hljs-built_in">config</span>.<span class="hljs-keyword">json</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">After browsing through the generated files, wrap up by adding back the comment before the <code class="inlineCode">jvmArgs</code> parameter in the build file to disable the tracing agent and remove<a id="_idIndexMarker1667"/> the created files. </p>
    <p class="normal">Next, we move on to how to use native tests!</p>
    <h2 id="_idParaDest-566" class="heading-2">Running native tests</h2>
    <p class="normal">Running native tests can, as<a id="_idIndexMarker1668"/> described earlier, be very useful for automating the process of finding issues with creating Native Images. Unfortunately, a couple of problems currently prevent us from using native tests with the microservices in this book:</p>
    <ul>
      <li class="bulletList">Tests that use Testcontainers can’t be used with native tests.
    <p class="normal">For details, see <a href="https://github.com/spring-projects/spring-boot/issues/35663"><span class="url">https://github.com/spring-projects/spring-boot/issues/35663</span></a>.</p></li>
    </ul>
    <ul>
      <li class="bulletList">Tests that use Mockito cannot be used with native tests either.
    <p class="normal">For details, see <a href="https://github.com/spring-projects/spring-boot/issues/32195"><span class="url">https://github.com/spring-projects/spring-boot/issues/32195</span></a> and <a href="https://github.com/mockito/mockito/issues/2435"><span class="url">https://github.com/mockito/mockito/issues/2435</span></a>.</p></li>
    </ul>
    <p class="normal">Therefore, all tests have been disabled using native tests using the annotation <code class="inlineCode">@DisabledInNativeImage</code> at the class level. This means that we still can run the native test command; all Native Images will be created but no tests will currently be executed in the Native Images. As these problems are resolved, the <code class="inlineCode">@DisabledInNativeImage</code> annotation can be removed step by step and more and more tests will be run by the native test command.</p>
    <p class="normal">To run the native tests on all four microservices, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">./gradlew nativeTest
</code></pre>
    <p class="normal">To test a specific microservice, run a command like:</p>
    <pre class="programlisting con"><code class="hljs-con">./gradlew :microservices:product-service:nativeTest
</code></pre>
    <p class="normal">After each test of a microservice, the<a id="_idIndexMarker1669"/> native testing tool creates a test report that looks like:</p>
    <pre class="programlisting code"><code class="hljs-code">JUnit Platform on Native Image - report
...
[        13 tests found           ]
[        13 tests skipped         ]
[         0 tests started         ]
[         0 tests aborted         ]
[         0 tests successful      ]
[         0 tests failed          ]
</code></pre>
    <p class="normal">As can be seen in the report above, currently all tests are skipped.</p>
    <p class="normal">After covering the test agent and native tests, let’s see how we can create Native Images.</p>
    <h2 id="_idParaDest-567" class="heading-2">Creating a Native Image for the current OS</h2>
    <p class="normal">The first option for creating a<a id="_idIndexMarker1670"/> Native Image is to use Gradle’s <code class="inlineCode">nativeImage</code> command. It will use the installed GraalVM <code class="inlineCode">Native Image</code> compiler to create an executable file for the current OS and hardware architecture.</p>
    <p class="normal">Since we will only test our microservices using Docker and Kubernetes, we will not use Native Images created by this command. But to try it out on the <code style="font-weight: bold;" class="codeHighlighted">product-composite</code> microservice, run the following commands:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create the Native Image with the following command:
        <pre class="programlisting con"><code class="hljs-con">./gradlew microservices:product-composite-service:nativeCompile
</code></pre>
    <p class="normal">The executable file will be created in the <code class="inlineCode">build/native/nativeCompile</code> folder with the name <code class="inlineCode">product-composite-service</code>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">The executable file can be inspected using the <code style="font-weight: bold;" class="codeHighlighted">file</code> command:
        <pre class="programlisting con"><code class="hljs-con">file microservices/product-composite-service/build/native/nativeCompile/product-composite-service
</code></pre>
    <p class="normal">It will respond with something like:</p>

    <pre class="programlisting con"><code class="hljs-con">…product-composite-service: Mach-O 64-bit executable arm64
</code></pre>      
    <p class="normal">Here, <code class="inlineCode">Mach-O</code> indicates that the file is compiled for macOS, and <code class="inlineCode">arm64</code> indicates it is compiled for Apple silicon.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">To try it out, we need to start up the resources it needs manually. In this case, it is only RabbitMQ that is required to make it start up successfully. Start it up with the following command:
        <pre class="programlisting con"><code class="hljs-con">docker-compose up -d rabbitmq
</code></pre>
      </li>
      <li class="numberedList">The Native Image <a id="_idIndexMarker1671"/>can now be started in the terminal by specifying the same environment variables that are supplied in the <code style="font-weight: bold;" class="codeHighlighted">docker-compose</code> files:
        <pre class="programlisting con"><code class="hljs-con">SPRING_RABBITMQ_USERNAME=rabbit-user-prod \
SPRING_RABBITMQ_PASSWORD=rabbit-pwd-prod \
SPRING_CONFIG_LOCATION=file:config-repo/application.yml,file:config-repo/product-composite.yml \
microservices/product-composite-service/build/native/nativeCompile/product-composite-service
</code></pre>
      
    <p class="normal">It should start up quickly and print something like the following in the log output:</p>
    <pre class="programlisting con"><code class="hljs-con">Started ProductCompositeServiceApplication in 0.543 seconds
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Try it out by calling its liveness probe:
        <pre class="programlisting con"><code class="hljs-con">curl localhost:4004/actuator/health/liveness
</code></pre>
    <p class="normal">Expect it to answer with:</p>
    <pre class="programlisting con"><code class="hljs-con">{"status":"UP"}
</code></pre>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Stop the execution by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> and stop the RabbitMQ container with the following command:
        <pre class="programlisting con"><code class="hljs-con">docker-compose down
</code></pre>
      </li>
    </ol>
    <p class="normal">Even though this is the fastest way to create a Native Image, it is not very useful for the scope of this book. Instead, it needs<a id="_idIndexMarker1672"/> to be built for Linux and placed in a Docker container. Let’s jump into the next section and learn how to do that.</p>
    <h2 id="_idParaDest-568" class="heading-2">Creating a Native Image as a Docker image</h2>
    <p class="normal">Now, it is time to build Docker images <a id="_idIndexMarker1673"/>containing Native Images of our microservices. Go through the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">This is a very resource-demanding process. Therefore, first, ensure that Docker Desktop is allowed to consume at least 10 GB of memory to avoid out-of-memory faults.</li>
    </ol>
    <div class="packt_tip">
      <p class="normal">If a build fails with an error message that looks like <code class="inlineCode">&lt;container-name&gt; exited with code 137</code>, you have run out of memory in Docker.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">If your computer has less than 32 GB of memory, it could be a good idea to stop the <code class="inlineCode">minikube </code>instance at this time to avoid running out of memory in the computer. Use the following command:
        <pre class="programlisting con"><code class="hljs-con">minikube stop
</code></pre>
      </li>
      <li class="numberedList">Ensure that the Docker client talks to Docker Desktop and not to the <code class="inlineCode">minikube</code> instance:
        <pre class="programlisting con"><code class="hljs-con">eval $(minikube docker-env -u)
</code></pre>
      </li>
      <li class="numberedList">Run the following command to compile the <code class="inlineCode">product</code> service:
        <pre class="programlisting con"><code class="hljs-con">./gradlew :microservices:product-service:bootBuildImage --no-daemon
</code></pre>
      
    <div class="note">
      <p class="normal">Expect it to take some time. The command will start a Docker container to perform the native compilation. The first time it runs, it will also download the GraalVM native compiler to be used in Docker, making the compilation time even longer. On my MacBook, the first compilation takes a few minutes, mainly depending on my network’s capacity; after that, it takes just around a minute or two.</p>
    </div>
    <p class="normal">Expect a lot of output during the compilation, including all sorts of warning and error <a id="_idIndexMarker1674"/>messages. A successful compilation ends with a log output like this:</p>
    <pre class="programlisting con"><code class="hljs-con">Successfully built image 'docker.io/hands-on/native-product-service:latest'
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Natively compile the three remaining microservices with the following commands:
        <pre class="programlisting con"><code class="hljs-con">./gradlew :microservices:product-composite-service:bootBuildImage --no-daemon
./gradlew :microservices:recommendation-service:bootBuildImage --no-daemon
./gradlew :microservices:review-service:bootBuildImage --no-daemon
</code></pre>
      </li>
      <li class="numberedList">To verify that the Docker images were successfully built, run the following command:
        <pre class="programlisting con"><code class="hljs-con">docker images | grep "hands-on/native"
</code></pre>
      
    <p class="normal">Expect output like this:</p></li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_23_02.png" alt="Graphical user interface, text  Description automatically generated" width="776" height="188"/></figure>
    <p class="packt_figref">Figure 23.2: Docker images containing the natively compiled executables</p>
    <p class="normal">Now that we’ve created the Docker images containing the natively compiled executables, we are ready to try them out! We will start with Docker Compose and, after that, try them out with Kubernetes.</p>
    <h1 id="_idParaDest-569" class="heading-1">Testing with Docker Compose</h1>
    <p class="normal">We are ready to try out the natively compiled <a id="_idIndexMarker1675"/>microservices. To use the Docker images that contain the natively compiled microservices, two new Docker Compose files have been created, <code class="inlineCode">docker-compose-native.yml</code> and <code class="inlineCode">docker-compose-partitions-native.yml</code>. They are copies of <code class="inlineCode">docker-compose.yml</code>, and <code class="inlineCode">docker-compose-partitions.yml</code>, where the <code class="inlineCode">build</code> option has been removed from the definitions of the microservices. Also, the names of the Docker images to use have been changed, so the ones we created in the previous section are used, with names that start with <code class="inlineCode">native-</code>.</p>
    <div class="packt_tip">
      <p class="normal">In this chapter, we will only use <code class="inlineCode">docker-compose-native.yml</code>.; feel free to try out <code class="inlineCode">docker-compose-partitions-native.yml</code> on your own.</p>
    </div>
    <p class="normal">We’ll first get a benchmark using the Java VM-based microservices to compare the startup times and initial memory consumption. We will run the following tests:</p>
    <ul>
      <li class="bulletList">Use the Java VM-based microservices with AOT mode disabled.</li>
      <li class="bulletList">Use the Java VM-based microservices with AOT mode enabled. </li>
      <li class="bulletList">Use the Docker images that contain the natively compiled microservices. </li>
    </ul>
    <p class="normal">To avoid port collisions, we first must stop the <code class="inlineCode">minikube</code> instance with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">minikube stop
</code></pre>
    <h2 id="_idParaDest-570" class="heading-2">Testing Java VM-based microservices with AOT mode disabled</h2>
    <p class="normal">We will start the tests by ignoring the AOT-generated code, starting the Java VM-based microservices as we did in the<a id="_idIndexMarker1676"/> previous chapters. Run through the following commands to test the Java VM-based microservices:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start by compiling the source code and building the Java VM-based Docker images in Docker Desktop:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter23
eval $(minikube docker-env -u)
./gradlew build
docker-compose build
</code></pre>
      </li>
      <li class="numberedList">Use the default Docker Compose file for the Java VM-based microservices:
        <pre class="programlisting con"><code class="hljs-con">unset COMPOSE_FILE
</code></pre>
      </li>
      <li class="numberedList">Start all containers, except the microservices’ containers:
        <pre class="programlisting con"><code class="hljs-con">docker-compose up -d mysql mongodb rabbitmq auth-server gateway
</code></pre>
      
    <p class="normal">Wait for the containers to start up until the CPU load goes down.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Start up the microservices using the Java VM:
        <pre class="programlisting con"><code class="hljs-con">docker-compose up -d 
</code></pre>
      
    <p class="normal">Wait for the microservices to start up, again monitoring the CPU load.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">To find out how <a id="_idIndexMarker1677"/>long time it took to start the microservices, we can look for a log output containing <code class="inlineCode">: Started</code>. Run the following command:
        <pre class="programlisting con"><code class="hljs-con">docker-compose logs product-composite product review recommendation | grep ": Started"
</code></pre>
      
    <p class="normal">Expect an output like this:</p>
    <figure class="mediaobject"><img src="../Images/B19825_23_03.png" alt="A screen shot of a computer  Description automatically generated with medium confidence" width="812" height="130"/></figure>
    <p class="packt_figref">Figure 23.3: Startup times for Java VM-based microservices</p>
    <p class="normal">In the output, we can see startup times varying from 5.5 to 7 seconds. Remember that all four microservice instances were started simultaneously, resulting in longer startup times compared to if they were started up one by one.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Run through the tests to verify that the system landscape works as expected:
        <pre class="programlisting con"><code class="hljs-con">USE_K8S=false HOST=localhost PORT=8443 HEALTH_URL=https://localhost:8443 ./test-em-all.bash
</code></pre>
      </li>
      <li class="numberedList">Expect the output we have seen in previous chapters from the tests:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_23_04.png" alt="A screenshot of a computer  Description automatically generated with medium confidence" width="812" height="285"/></figure>
    <p class="packt_figref">Figure 23.4: Output from the test script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Finally, to find <a id="_idIndexMarker1678"/>out how much memory is used after starting up and running the tests, run the following command:
        <pre class="programlisting con"><code class="hljs-con">docker stats --no-stream
</code></pre>
    <p class="normal">Expect a response like this:</p>

    <figure class="mediaobject"><img src="../Images/B19825_23_05.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence" width="812" height="282"/></figure>
    <p class="packt_figref">Figure 23.5: Memory usage for Java VM-based microservices</p>
    <p class="normal">From the preceding output, we can see that the microservices consume around 240-310 MB.</p>      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Bring down the system landscape:
        <pre class="programlisting con"><code class="hljs-con">docker compose down
</code></pre>
      </li>
    </ol>
    <p class="normal">Now we know how long the <a id="_idIndexMarker1679"/>microservices take to start up without using the AOT-generated code; let’s test them in AOT mode. </p>
    <h2 id="_idParaDest-571" class="heading-2">Testing Java VM-based microservices with AOT mode enabled</h2>
    <p class="normal">Now we will enable AOT mode, using<a id="_idIndexMarker1680"/> the AOT-generated code to start the Java VM-based microservices. We expect them to start a bit faster in AOT mode. Run through the following commands:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start all containers, except the microservices’ containers:
        <pre class="programlisting con"><code class="hljs-con">docker-compose up -d mysql mongodb rabbitmq auth-server gateway
</code></pre>
      </li>
      <li class="numberedList">Enable AOT mode by editing each microservice’s Dockerfile and set “<code class="inlineCode">-Dspring.aot.enabled=true</code>" in the <code class="inlineCode">ENVIRONMENT</code> command so it looks like this:
        <pre class="programlisting con"><code class="hljs-con">ENTRYPOINT ["java", "-Dspring.aot.enabled=true", "org.springframework.boot.loader.JarLauncher"]
</code></pre>
      </li>
      <li class="numberedList">Rebuild the microservices:
        <pre class="programlisting con"><code class="hljs-con">docker-compose build
</code></pre>
      </li>
      <li class="numberedList">Start the microservices:
        <pre class="programlisting con"><code class="hljs-con">docker-compose up -d
</code></pre>
      </li>
      <li class="numberedList">Check AOT mode:
        <pre class="programlisting con"><code class="hljs-con">docker-compose logs product-composite product review recommendation | grep "Starting AOT-processed"
</code></pre>

    <p class="normal">Expect four lines containing “<code class="inlineCode">Starting AOT-processed</code>".</p>      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Check the startup<a id="_idIndexMarker1681"/> times:
        <pre class="programlisting con"><code class="hljs-con">docker-compose logs product-composite product review recommendation | grep ": Started"
</code></pre>
     
    <p class="normal">Expect the same type of output as when running without AOT mode in the section above but with slightly shorter startup times. In my case, the startup times vary from 4.5 to 5.5 seconds. Compared to the normal Java VM startup times, this is 1 to 1.5 seconds faster.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Run <code class="inlineCode">test-em-all.bash</code>:
        <pre class="programlisting con"><code class="hljs-con">USE_K8S=false HOST=localhost PORT=8443 HEALTH_URL=https://localhost:8443 ./test-em-all.bash
</code></pre>
      
    <p class="normal">Expect an output like when running without AOT mode in the section above.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Revert the changes in the Dockerfiles and perform a rebuild of the Docker images to disable AOT mode.</li>
      <li class="numberedList">Bring down the system landscape:
        <pre class="programlisting con"><code class="hljs-con">docker compose down
</code></pre>
      </li>
    </ol>
    <p class="normal">In this test, we verified that Java VM-based microservices start up a bit faster using the AOT-generated <a id="_idIndexMarker1682"/>code. Now it’s time to try out the natively compiled microservices.</p>
    <h2 id="_idParaDest-572" class="heading-2">Testing natively compiled microservices</h2>
    <p class="normal">Now, we are ready to repeat the same procedure, but this time using the Docker images with the natively<a id="_idIndexMarker1683"/> compiled microservices:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Change to the new Docker Compose file:
        <pre class="programlisting con"><code class="hljs-con">export COMPOSE_FILE=docker-compose-native.yml
</code></pre>
      </li>
      <li class="numberedList">Start all containers, except for the microservices’ containers:
        <pre class="programlisting con"><code class="hljs-con">docker-compose up -d mysql mongodb rabbitmq auth-server gateway
</code></pre>
    <p class="normal">Wait for the containers to start up until the CPU load goes down.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Start up the microservices using the Java VM:
        <pre class="programlisting con"><code class="hljs-con">docker-compose up -d 
</code></pre>
    <p class="normal">Wait for the microservices to start up, again monitoring the CPU load.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">To find out how long time it took to start the natively compiled microservices, run the same command we ran previously:
        <pre class="programlisting con"><code class="hljs-con">docker-compose logs product-composite product review recommendation | grep ": Started"
</code></pre>
    <p class="normal">Expect output like this:</p>
      
    <figure class="mediaobject"><img src="../Images/B19825_23_06.png" alt="A screen shot of a computer  Description automatically generated with medium confidence" width="812" height="128"/></figure>
    <p class="packt_figref">Figure 23.6: Startup times for natively compiled microservices</p>
    <p class="normal">In the above output, we can see startup times varying from 0.2-0.5 seconds. Considering that all microservices instances were started up at the same time, these are rather impressive figures compared to the 5.5 to 7 seconds it took for the Java VM-based tests!</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Run through the tests<a id="_idIndexMarker1684"/> to verify that the system landscape works as expected:
        <pre class="programlisting con"><code class="hljs-con">USE_K8S=false HOST=localhost PORT=8443 HEALTH_URL=https://localhost:8443 ./test-em-all.bash
</code></pre>
    <p class="normal">Expect the same output as from the test above using the Java VM-based Docker images.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Finally, to find out how much memory is used after starting up and running the tests, run the following command:
        <pre class="programlisting con"><code class="hljs-con">docker stats --no-stream
</code></pre>
    <p class="normal">Expect a response like this:</p>
     
    <figure class="mediaobject"><img src="../Images/B19825_23_07.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence" width="812" height="284"/></figure>
    <p class="packt_figref">Figure 23.7: Memory usage for natively compiled microservices</p>
    <p class="normal">From the preceding output, we can see that the microservices consume around 80-130 MB. Again, this is a noticeable reduction compared to the 240-310 MB that the Java VM containers used!</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Bring down the system landscape:
        <pre class="programlisting con"><code class="hljs-con">docker compose down
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">To get a better understanding of both the memory and CPU consumption of the natively compiled microservices, a more realistic load test needs to be performed, but that is beyond the scope of this book.</p>
    </div>
    <p class="normal">After seeing how much<a id="_idIndexMarker1685"/> faster and less memory-consuming the natively compiled microservices are when starting up compared to Java VM-based alternatives, let’s see how we can run them using Kubernetes.</p>
    <h1 id="_idParaDest-573" class="heading-1">Testing with Kubernetes</h1>
    <p class="normal">To be able to deploy the natively compiled microservices in Kubernetes, a new environment Helm chart has<a id="_idIndexMarker1686"/> been added, which has been configured to use the Docker images that contain the natively compiled microservices. The Helm charts can be found in the following folders:</p>
    <pre class="programlisting code"><code class="hljs-code">kubernetes/helm/
└── environments
    └── dev-env-native
</code></pre>
    <p class="normal">Another thing we need to consider before deploying the natively compiled microservices to Kubernetes is how to provision the Docker images. We don’t want to run the lengthy native compilation commands again to get new Docker images created in the <code class="inlineCode">minikube</code> instance. If we used a Docker registry in this book, we could have pushed the images to the registry, but we haven’t. Instead, we will extract the Docker images from Docker Desktop and import them into the <code class="inlineCode">minikube</code> instance, as a workaround for not using a Docker registry.</p>
    <p class="normal">Move the Docker<a id="_idIndexMarker1687"/> images from Docker Desktop to the <code class="inlineCode">minikube</code> instance with the following commands:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Export the Docker images from Docker Desktop:
        <pre class="programlisting con"><code class="hljs-con">eval $(minikube docker-env -u)
docker save hands-on/native-product-composite-service:latest -o native-product-composite.tar
docker save hands-on/native-product-service:latest -o native-product.tar
docker save hands-on/native-recommendation-service:latest -o native-recommendation.tar
docker save hands-on/native-review-service:latest -o native-review.tar
</code></pre>
      </li>
      <li class="numberedList">Start up the <code class="inlineCode">minikube</code> instance again:
        <pre class="programlisting con"><code class="hljs-con">minikube start
</code></pre>
      </li>
      <li class="numberedList">In a separate terminal, start the <code style="font-weight: bold;" class="codeHighlighted">minikube tunnel</code> command:
        <pre class="programlisting con"><code class="hljs-con">minikube tunnel
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">Note that this command requires that your user has <code class="inlineCode">sudo</code> privileges and that you enter your password during startup. It can take a couple of seconds before the command asks for the password, so it is easy to miss!</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Import the Docker images into the <code class="inlineCode">minikube</code> instance:
        <pre class="programlisting con"><code class="hljs-con">eval $(minikube docker-env)
docker load -i native-product-composite.tar
docker load -i native-product.tar
docker load -i native-recommendation.tar
docker load -i native-review.tar
</code></pre>
      </li>
      <li class="numberedList">Finally, delete the exported <code class="inlineCode">.tar</code> files:
        <pre class="programlisting con"><code class="hljs-con">rm native-product-composite.tar native-product.tar native-recommendation.tar native-review.tar
</code></pre>
      </li>
    </ol>
    <p class="normal">Building, deploying, and verifying the deployment on Kubernetes is done in the same way as in the previous chapters. Run the following commands:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Build the Docker image for the <code style="font-weight: bold;" class="codeHighlighted">auth-server</code> with the following command:
        <pre class="programlisting con"><code class="hljs-con">docker-compose build auth-server
</code></pre>
      </li>
      <li class="numberedList">Recreate the <a id="_idIndexMarker1688"/>namespace, <code class="inlineCode">hands-on</code>, and set it as the default Namespace:
        <pre class="programlisting con"><code class="hljs-con">kubectl delete namespace hands-on
kubectl apply -f kubernetes/hands-on-namespace.yml
kubectl config set-context $(kubectl config current-context) --namespace=hands-on
</code></pre>
      </li>
      <li class="numberedList">Resolve the Helm chart dependencies with the following commands.
    <p class="normal">First, we update the dependencies in the <code class="inlineCode">components</code> folder:</p>
    <pre class="programlisting con"><code class="hljs-con">for f in kubernetes/helm/components/*; do helm dep up $f; done
</code></pre>
    <p class="normal">Next, we update the dependencies in the <code class="inlineCode">environments</code> folder:</p>
    <pre class="programlisting con"><code class="hljs-con">for f in kubernetes/helm/environments/*; do helm dep up $f; done
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">We are now ready to deploy the system landscape using Helm. Run the following command and wait for all the deployments to complete:
        <pre class="programlisting con"><code class="hljs-con">helm upgrade -install hands-on-dev-env-native \
  kubernetes/helm/environments/dev-env-native \
  -n hands-on --wait
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">In the previous chapters, we used the <code class="inlineCode">helm install</code> command. The <code class="inlineCode">helm upgrade -install</code> command used here is a better alternative for scripting since it performs an <code class="inlineCode">insert</code> if the chart is not installed, but an <code class="inlineCode">upgrade</code> if the chart is already installed. It’s a bit like an <code class="inlineCode">upsert</code> command in the relational database world.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Run the normal tests to verify the deployment with the following command:
        <pre class="programlisting con"><code class="hljs-con">./test-em-all.bash
</code></pre>
    <p class="normal">Expect the output to be like what we’ve already seen in the previous tests.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Check the startup<a id="_idIndexMarker1689"/> time for one of the Pods. To measure the actual startup time for a specific microservice, let’s delete it and then measure the time it takes to start up once Kubernetes recreates it:
        <pre class="programlisting con"><code class="hljs-con">Kubectl delete pod -l app=product-composite
kubectl logs -l app=product-composite --tail=-1 | grep ": Started"
</code></pre>
    <p class="normal">Expect a response like this:</p>
     
    <figure class="mediaobject"><img src="../Images/B19825_23_08.png" alt="" role="presentation" width="812" height="64"/></figure>
    <p class="packt_figref">Figure 23.8: Startup time when running as a Pod in Kubernetes</p>
    <p class="normal">Expect a startup time around what we noticed when using Docker Compose, 0.4 seconds in the example above. Since we also start an Istio proxy as a sidecar, there might be some extra delay.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Check the Docker images used with the following command:
        <pre class="programlisting con"><code class="hljs-con">kubectl get pods -o jsonpath="{.items[*].spec.containers[*].image}" | xargs -n1 | grep hands-on
</code></pre>
    <p class="normal">Expect the following response:</p>
    <figure class="mediaobject"><img src="../Images/B19825_23_09.png" alt="A screenshot of a computer program  Description automatically generated with low confidence" width="598" height="193"/></figure>
    <p class="packt_figref">Figure 23.9: Docker images with natively compiled code</p>
    <p class="normal">From the<a id="_idIndexMarker1690"/> output, we can see that all containers, except the <code class="inlineCode">auth-server</code>, use Docker images with the same prefix <code class="inlineCode">native</code>, meaning we are running natively compiled executables inside the Docker containers.</p>
    <p class="normal">This completes this chapter on using Spring’s AOT engine and the GraalVM project to create natively compiled executables for our microservices.</p>
      </li>
    </ol>
    <h1 id="_idParaDest-574" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we were introduced to the new <em class="italic">Spring AOT engine</em> and underlying <em class="italic">GraalVM</em> project, along with its Native Image compiler. After declaring GraalVM’s plugin in the build file and providing the Native Image compiler with some reachability metadata and custom hints, it can be used to create Native Images. Spring Boot’s Gradle task <code class="inlineCode">buildBootImage</code> packages these standalone executable files into ready-to-use Docker images.</p>
    <p class="normal">The main benefit of compiling Java-based source code into Native Images is significantly faster startup time and less memory usage. In a test where we started up the microservice instances at the same time, we observed 0.2-0.5 seconds startup times for the natively compiled microservices, compared with the 5.5 to 7 seconds required for the Java VM-based microservices for the same test. Also, the natively compiled microservices required less than half of the memory compared to the Java VM-based microservices after running through the verifications in the script, <code class="inlineCode">test-em-all.bash</code>.</p>
    <p class="normal">Most libraries and frameworks in this book already support GraalVM’s <code class="inlineCode">Native Image</code> compiler. For those that don’t, <em class="italic">GraalVM Reachability Metadata Repository</em> can help out by providing reachability metadata from the community. GraalVM’s build plugin can automatically detect and download reachability metadata from this repository. As a last resort, the GraalVM Native Image <em class="italic">tracing agent</em> can be used to create reachability metadata to help the native compiler. The tracing agent is configured to run together with the existing JUnit tests, creating reachability metadata based on the execution of the tests.</p>
    <p class="normal">If we find it problematic to get the Native Image creation to work properly for a specific Spring feature, we can reach out to the <em class="italic">Spring AOT Smoke Tests</em> project for working examples per Spring feature. To verify that the microservices will work once natively compiled, we can run the unit tests in a Native Image using Spring Boot’s Gradle task <code class="inlineCode">nativeTest</code>.</p>
    <div class="packt_tip">
      <p class="normal">For the time being, the <code class="inlineCode">nativeTest</code> task is not very useful with the source code in this book due to the described problems that existed when this chapter was written. </p>
    </div>
    <p class="normal">We have also seen how easy it is to replace the Docker images running a Java VM with Docker images containing the natively compiled images. By running the Java VM Docker images in <em class="italic">AOT mode</em>, the startup times can be reduced a bit and, at the same time, we ensure that the generated AOT code works as expected. Finally, we tested the natively compiled images, both using Docker Compose and Kubernetes. </p>
    <p class="normal">With this, we have reached the end of the book. I hope it has helped you learn how to develop microservices using all the amazing features of Spring Boot, Spring Cloud, Kubernetes, and Istio and that you feel encouraged to try them out!</p>
    <h1 id="_idParaDest-575" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">How are the Spring’s AOT engine and the GraalVM projects related to each other?</li>
      <li class="numberedList">How is the tracing agent used?</li>
      <li class="numberedList">What is the difference between JIT and AOT compilation?</li>
      <li class="numberedList">What is AOT mode, and how can it be beneficial to use?</li>
      <li class="numberedList">What is a native custom hint?</li>
      <li class="numberedList">What is a native test, and why is it useful?</li>
      <li class="numberedList">How are initial memory usage and startup times affected by natively compiling Java code?</li>
    </ol>
    <h1 id="_idParaDest-576" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussion with the author and other readers:</p>
    <p class="normal"><a href="https://packt.link/SpringBoot3e"><span class="url">https://packt.link/SpringBoot3e</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1849216352344398875.png" alt="" role="presentation" width="177" height="177"/></p>
  </div>
</div>
</div>
</body></html>