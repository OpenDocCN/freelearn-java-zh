- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Building RESTful APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建RESTful API
- en: RESTful APIs are crucial in modern cloud apps for seamless data exchange, enabling
    interoperability, scalability, and efficient communication between services. Spring
    Boot simplifies RESTful authoring by providing a framework for quick, efficient
    development, auto-configuration, and integrated tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代云应用程序中，RESTful API对于无缝数据交换至关重要，它使得服务之间能够实现互操作性、可扩展性和高效通信。Spring Boot通过提供快速、高效开发、自动配置和集成工具的框架，简化了RESTful
    API的编写。
- en: In this chapter, you will acquire the skills to create RESTful services and
    consume them seamlessly from other applications. You will also learn how to create
    automated tests for your RESTful APIs using the features provided by Spring Boot
    and other popular tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将获得创建RESTful服务和无缝地从其他应用程序中消费它们的技能。您还将学习如何使用Spring Boot和其他流行工具提供的功能为您的RESTful
    API创建自动化测试。
- en: 'In this chapter, we’re going to cover the following main recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要食谱：
- en: Creating a RESTful API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建RESTful API
- en: Defining responses and the data model exposed by the API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义API暴露的响应和数据模型
- en: Managing errors in a RESTful API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RESTful API中管理错误
- en: Testing a RESTful API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试RESTful API
- en: Using OpenAPI to document our RESTful API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenAPI来记录我们的RESTful API
- en: Consuming a RESTful API from another Spring Boot application using FeignClient
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FeignClient从另一个Spring Boot应用程序中消费RESTful API
- en: Consuming a RESTful API from another Spring Boot application using RestClient
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RestClient从另一个Spring Boot应用程序中消费RESTful API
- en: Mocking a RESTful API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟RESTful API
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter’s recipes, you will need a computer with any OS (I
    use Ubuntu on Windows Subsystem for Linux – WSL), an editor such as Visual Studio
    Code ([https://code.visualstudio.com/](https://code.visualstudio.com/)) or IntelliJ
    Idea ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)), and
    Java OpenJDK 17 or higher.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的食谱，您需要一个运行任何操作系统（我使用的是Windows Subsystem for Linux – WSL上的Ubuntu）的计算机，一个编辑器，如Visual
    Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    或IntelliJ Idea ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/))），以及Java
    OpenJDK 17或更高版本。
- en: There are multiple distributions of Java from different vendors – if you already
    have one installed, you can continue using it; if you need to install one, you
    can use Eclipse Adoptium distribution ([https://adoptium.net/](https://adoptium.net/)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 来自不同供应商的Java有多种发行版——如果您已经安装了一个，您可以继续使用它；如果您需要安装一个，可以使用Eclipse Adoptium发行版（[https://adoptium.net/](https://adoptium.net/))。
- en: If you use Visual Studio Code, I recommend installing Extension Pack for Java
    ([https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack))
    and Spring Boot Extension Pack ([https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack](https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Visual Studio Code，我建议安装Java扩展包（[https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack)）和Spring
    Boot扩展包（[https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack](https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack)）。
- en: If you don’t have a tool to perform HTTP requests, you could use curl ([https://curl.se/](https://curl.se/))
    or Postman ([https://www.postman.com/](https://www.postman.com/)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有用于执行HTTP请求的工具，可以使用curl ([https://curl.se/](https://curl.se/)) 或Postman
    ([https://www.postman.com/](https://www.postman.com/))。
- en: 'Finally, you can download the complete project on GitHub at: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在GitHub上下载完整的项目：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
- en: You will need a git client to download the code from the book’s GitHub repository
    ([https://git-scm.com/downloads](https://git-scm.com/downloads)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个git客户端来从本书的GitHub仓库下载代码（[https://git-scm.com/downloads](https://git-scm.com/downloads)）。
- en: Creating a RESTful API
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful API
- en: A **RESTful API** is a standardized way for software components to communicate
    over the internet using HTTP methods and URLs. You should learn it because it’s
    fundamental for modern web and cloud application development. It promotes scalable,
    flexible, and stateless communication, enabling developers to design efficient
    and widely compatible systems. Understanding RESTful APIs is crucial for building
    and integrating services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: When I was a child I played with football-player cards, exchanging cards that
    I had multiples of with my friends. My children, some decades later, still play
    this game. Throughout this chapter, you will create a system to manage a football
    card-trading game, with teams, players, albums, and cards. In this recipe, you
    will create a RESTful API exposing **Create, Read, Update, and Delete** (**CRUD**)
    **operations** on football players.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a RESTful API, Spring Boot provides a great tool named Spring Initializr.
    You can open this tool in your browser using [https://start.spring.io/](https://start.spring.io/).
    We’ll use this tool to create a Spring Boot project with all dependencies. This
    tool is also well integrated into code editors such as VSCode and IntelliJ (Premium
    edition).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a RESTful project using Spring Initializr and create our first
    endpoint with typical HTTP operations:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io) in your browser and
    you’ll see the following screen:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1: Spring Initializr](img/B21646_01_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Spring Initializr'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Initilizr allows you to configure the project and generates the structure
    with the necessary files and dependencies, which you can use as a starting point
    for your application. On this start page, set up the following configuration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** section, select **Maven**
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Language** section, select **Java**
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Spring Boot** section, select the latest stable version – at the time
    of writing this book, this is **3.1.4**
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Dependencies** section, select **Spring Web**
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the following in the `com.packt`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `football`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Demo project for Spring Boot` `3 Coobook`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Packaging**, select **Jar**
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Java**, select **21**
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have configured the preceding options, you can choose the options
    for **Generate**, **Explore**, or **Share…**:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click **Explore**, you can explore the project before downloading it.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you click **Share**, a URL is generated that you can share with other people.
    For instance, our configuration will produce this URL: [https://start.spring.io/#!type=maven-project
    &language=java&platformVersion=3.1.3&packaging=jar&jvmVersion=1 7&groupId=compackt&artifactId=football&name=football&description=Demo%20project%20for%20Spring%20Boot%203%20
    Cookbook&packageName=com.packt.football&dependencies=web](https://start.spring.io/).
    If you open it, it will configure all of the options as shown in *Figure 1.1*.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you click **Generate**, it will download a ZIP file of the project structure.
    Click this option now.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您点击 **生成**，它将下载项目结构的 ZIP 文件。现在点击此选项。
- en: Unzip the file. You now have the basic project structure, but you don’t have
    any API. If you try to run the application, you will receive an HTTP 404 Not Found
    response.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压文件。现在您有了基本的项目结构，但您还没有任何 API。如果您尝试运行应用程序，您将收到 HTTP 404 Not Found 响应。
- en: 'In the `src/main/java/com/packt/football` folder, create a file named `PlayerController.java`
    with the following content to create a RESTful endpoint:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main/java/com/packt/football` 文件夹中，创建一个名为 `PlayerController.java` 的文件，并包含以下内容以创建
    RESTful 端点：
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run it, open a terminal in the project root folder and execute the following
    command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行它，请在项目根目录中打开一个终端并执行以下命令：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will build your project and start the application. By default,
    the web container listens on port `8080`.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将构建您的项目并启动应用程序。默认情况下，Web 容器监听端口 `8080`。
- en: 'Execute an HTTP request to see the results. You can open `http://localhost:8080/players`
    in a browser or use a tool such as curl to perform the request:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个 HTTP 请求以查看结果。您可以在浏览器中打开 `http://localhost:8080/players`，或者使用 curl 等工具执行请求：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will have a list of players returned by the controller.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将收到控制器返回的玩家列表。
- en: 'Enhance your RESTful endpoint by adding more verbs. In the `PlayerController.java`
    file, do the following:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加更多动词来增强您的 RESTful 端点。在 `PlayerController.java` 文件中，执行以下操作：
- en: 'Implement a POST request to create a player:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个用于创建玩家的 POST 请求：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add another GET request to return one player:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加另一个 GET 请求以返回一个玩家：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a DELETE request to delete one player:'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 DELETE 请求以删除一个玩家：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement a PUT request to update a player:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个用于更新玩家的 PUT 请求：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Execute your application again as explained in *step 5* and test your endpoint.
    Perform a GET request by entering the following command into your terminal:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 5 步中的说明再次执行应用程序并测试您的端点。在终端中输入以下命令执行 GET 请求：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Perform a POST request using curl:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 curl 执行 POST 请求：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'curl --header "Content-Type: application/text" --request DELETE http://localhost:8080/players/Aitana%20BONMATI'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'curl --header "Content-Type: application/text" --request DELETE http://localhost:8080/players/Aitana%20BONMATI'
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Player Aitana BONMATI deleted
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 玩家 Aitana BONMATI 已被删除
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By adding the Spring Web dependency to our project, Spring Boot automatically
    embeds a Tomcat server in the application. `start.spring.io` and it listens on
    port `8080`, which is the default port for Tomcat. However, as there is no mapping
    configured in the application, it always responds with a 404 Not Found error.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Spring Web 依赖项添加到我们的项目中，Spring Boot 自动将 Tomcat 服务器嵌入到应用程序中。`start.spring.io`
    并监听端口 `8080`，这是 Tomcat 的默认端口。然而，由于应用程序中没有配置映射，它总是响应 404 Not Found 错误。
- en: By adding the `PlayerController` class, we are informing Spring Boot that it
    should register the `PlayerController` class in dependency containers as an implementation
    class. By adding `PlayerController` class. As we applied these at a class level,
    we configured all requests in this class with the `players` prefix.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `PlayerController` 类，我们通知 Spring Boot 应将其 `PlayerController` 类注册到依赖容器中作为实现类。通过添加
    `PlayerController` 类。由于我们在类级别上应用了这些，我们已使用 `players` 前缀配置了此类中的所有请求。
- en: 'The last step is mapping requests to their handling methods. This is performed
    by using mapping annotations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将请求映射到处理方法。这是通过使用映射注解来完成的：
- en: '`@GetMapping`: Maps a GET request to a method'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping`：将 GET 请求映射到方法'
- en: '`@PostMapping`: Maps a POST request to a method'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PostMapping`：将 POST 请求映射到方法'
- en: '`@PutMapping`: Maps a PUT request to a method'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PutMapping`：将 PUT 请求映射到方法'
- en: '`@DeleteMethod`: Maps a DELETE request to a method'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DeleteMethod`：将 DELETE 请求映射到方法'
- en: These mapping annotations are a specialization of `@RequestMapping`, as they
    inform the web container how to map a request to its handler, in this case, using
    the annotated method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些映射注解是 `@RequestMapping` 的一个特殊化，因为它们通知 Web 容器如何将请求映射到其处理器，在这种情况下，使用注解的方法。
- en: Keep in mind that you can only have one of these mapping types per controller
    (i.e., one `GetMapping` or `PostMapping`) unless you provide more configuration
    to refine the mapping. In this example, you can see there are two instances of
    `@GetMapping`, but `readPlayer` is annotated with an additional element and thus
    is mapped with its class prefix, `players`, plus a name. That means all GET requests
    with `/players/anything` will be mapped to this method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个控制器（即，一个 `GetMapping` 或 `PostMapping`）只能有一个这种映射类型，除非您提供更多配置来细化映射。在这个例子中，您可以看到有两个
    `@GetMapping` 实例，但 `readPlayer` 被注解了额外的元素，因此它被映射到其类前缀 `players` 加上名称。这意味着所有以 `/players/anything`
    开头的 GET 请求都将映射到这个方法。
- en: 'As of now, that additional information is not yet configured in the method.
    To use all this additional HTTP request information in your method, you can use
    the following annotations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些额外信息尚未在方法中配置。要使用所有这些额外的 HTTP 请求信息在您的方 法中，您可以使用以下注解：
- en: '`@GetMapping("/{name}") public String readPlayer(@PathVariable String name)`
    maps the last part of the path to the `name` method argument.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping("/{name}") public String readPlayer(@PathVariable String name)`
    将路径的最后一部分映射到 `name` 方法参数。'
- en: '**@RequestBody**: This will map the request body to the method argument.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@RequestBody**：这将把请求体映射到方法参数。'
- en: '**@RequestHeader**: This will map request headers to the method argument.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@RequestHeader**：这将把请求头映射到方法参数。'
- en: '**@RequestParam**: You can use this to map requests params, such as query string
    parameters, form data, or parts in multipart requests.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@RequestParam**：您可以使用这个注解来映射请求参数，例如查询字符串参数、表单数据或multipart请求中的部分。'
- en: Just by decorating our classes with previous annotations, Spring Boot is able
    to set up the web application container to manage the requests. There are some
    annotations not yet covered, but we covered the basics to create our RESTful APIs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只需用之前的注解装饰我们的类，Spring Boot 就能设置好 Web 应用程序容器来管理请求。还有一些注解尚未介绍，但我们已经介绍了创建 RESTful
    API 的基础知识。
- en: There’s more...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Even if the RESTful endpoint we just created is very simple, I intentionally
    added these methods – `GET` by default, `GET` with an identifier, `POST`, `PUT`,
    and `DELETE`. This choice is rooted in the fact that it aligns with the most prevalent
    semantics for performing CRUD and List operations on a resource.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们所创建的 RESTful 端点非常简单，我也故意添加了这些方法 - 默认的 `GET`、带有标识符的 `GET`、`POST`、`PUT` 和
    `DELETE`。这个选择是基于它与执行 CRUD 和列表操作的最普遍语义相一致。
- en: 'In the context of our resource being football *players*, we have the following
    operations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的资源是足球**球员**的上下文中，我们有以下操作：
- en: '`GET` by default usually returns a list of resources, in our case, all players'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`GET` 通常返回资源列表，在我们的例子中，是所有球员
- en: '`GET` with an identifier returns a specific player'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有标识符的 `GET` 返回一个特定的球员
- en: '`POST` creates a new resource'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 创建一个新的资源'
- en: '`PUT` updates a resource'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 更新一个资源'
- en: '`DELETE` deletes a resource'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 删除一个资源'
- en: Also, the HTTP status code responses are very important in the semantics of
    RESTful operations. In this recipe, the responses are not managed in the standard
    way. In the following recipes, we will expand on this and learn how Spring Boot
    can facilitate the proper handling of responses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HTTP 状态码响应在 RESTful 操作的语义中非常重要。在这个菜谱中，响应不是按照标准方式管理的。在接下来的菜谱中，我们将扩展这一点，学习
    Spring Boot 如何促进正确处理响应。
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you want to learn more about API design, you can visit the following pages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 API 设计的信息，您可以访问以下页面：
- en: '[https://swagger.io/resources/articles/best-practices-in-api-design/](https://swagger.io/resources/articles/best-practices-in-api-design/)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://swagger.io/resources/articles/best-practices-in-api-design/](https://swagger.io/resources/articles/best-practices-in-api-design/)'
- en: '[https://learn.microsoft.com/azure/architecture/best-practices/api-design](https://learn.microsoft.com/azure/architecture/best-practices/api-design)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/azure/architecture/best-practices/api-design](https://learn.microsoft.com/azure/architecture/best-practices/api-design)'
- en: Defining responses and the data model exposed by the API
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义响应和 API 暴露的数据模型
- en: In the previous recipe, we created a very simple RESTful API. To develop a RESTful
    API that provides a positive user experience for its consumers, it is essential
    to incorporate both standard response codes and a consistent data model. In this
    recipe, we will enhance the previous RESTful API by returning standard response
    codes and creating a data model for our players endpoint.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个菜谱中，我们创建了一个非常简单的RESTful API。为了开发一个为消费者提供良好用户体验的RESTful API，必须结合使用标准响应代码和一致的数据模型。在这个菜谱中，我们将通过返回标准响应代码并为我们的玩家端点创建数据模型来增强先前的RESTful
    API。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You can use the project generated in the previous recipe or download the sample
    from the GitHub repository: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用之前菜谱中生成的项目或从GitHub仓库下载样本：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。
- en: You can find the code to start this exercise in the `chapter1/recipe1-2/start`
    folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter1/recipe1-2/start`文件夹中找到启动此练习的代码。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will create a folder structure to contain different types
    of classes for our project. We will define a data model to expose in our RESTful
    API, along with a service to provide the operations needed by the API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个文件夹结构来包含我们项目中的不同类型的类。我们将定义一个数据模型来在我们的RESTful API中公开，以及一个提供API所需操作的服务。
- en: 'Note that all of the content created in the following steps will be under the
    `src/main/java/com/packt/football` folder or one of the subfolders you will create
    when required. Let’s get started:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下步骤中创建的所有内容都将位于`src/main/java/com/packt/football`文件夹或您在需要时创建的子文件夹中。让我们开始吧：
- en: 'Create a folder named `model`. Then in this folder, create a file named `Player.java`
    with the following content:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`model`的文件夹。然后在这个文件夹中创建一个名为`Player.java`的文件，内容如下：
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a folder named `exceptions`. In this folder, create two files:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exceptions`的文件夹。在这个文件夹中创建两个文件：
- en: 'The first, `AlreadyExistsException.java`, should have the following content:'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个，`AlreadyExistsException.java`，应包含以下内容：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the second, `NotFoundException.java`, should contain this content:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个，`NotFoundException.java`，应包含以下内容：
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create another folder named `services`, and in this folder, create a class
    named `FootballService`. This class manages all operations needed by our RESTful
    API. Do the following in this file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`services`的文件夹，并在该文件夹中创建一个名为`FootballService`的类。这个类管理我们RESTful API所需的所有操作。在这个文件中执行以下操作：
- en: 'Create the class first:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先创建这个类：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class will manage the data in a `Map`, keeping all players in memory.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类将使用`Map`管理数据，将所有玩家保存在内存中。
- en: 'Now let’s define a `Map<String, Player>` field and initialize it. (I just created
    two entries for brevity, but in the GitHub repo, you will find many more):'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`Map<String, Player>`字段并初始化它。（为了简洁起见，我只创建了两个条目，但在GitHub仓库中，您将找到更多）：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the operations required by our RESTful API:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们RESTful API所需的操作：
- en: 'Start by listing the players:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先列出玩家：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then return a player (do note that if the player doesn’t exist, it will throw
    an exception):'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后返回一个玩家（请注意，如果玩家不存在，它将抛出一个异常）：
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a new player (do note that if the player already exists, it will throw
    an exception):'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新玩家（请注意，如果玩家已经存在，它将抛出一个异常）：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Update a player (note that if the player doesn’t already exist, it will throw
    an exception):'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新一个玩家（请注意，如果玩家尚未存在，它将抛出一个异常）：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Delete a player (note that if the player doesn’t exist, it will continue without
    errors):'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个玩家（请注意，如果玩家不存在，它将无错误地继续）：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, in the `PlayerController` class, modify the controller to use our new
    service and expose the newly created data model:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`PlayerController`类中，修改控制器以使用我们新的服务并公开新创建的数据模型：
- en: 'Add a `FootballService` field and create a constructor in the `PlayerController`
    class with an argument of type `FootballService` to initialize it:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`PlayerController`类中添加一个`FootballService`字段，并创建一个带有类型为`FootballService`的参数的构造函数来初始化它：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the operations to manage the players. We will use our recently created
    service to manage that functionality. As explained in the previous recipe, we
    will decorate our class methods to manage the RESTful endpoint methods and will
    invoke the services of our `Football` service class:'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建管理玩家的操作。我们将使用我们最近创建的服务来管理该功能。如前一个菜谱中所述，我们将装饰我们的类方法来管理RESTful端点方法，并将调用我们的`Football`服务类的服务：
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `application` root folder, open a terminal and execute the following
    command to run the application:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `application` 根目录下，打开终端并执行以下命令以运行应用程序：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Test the application by executing the following `curl` command to get all of
    the players:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下 `curl` 命令来测试应用程序，以获取所有球员：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we defined a new record type named `Player`. Spring Boot automatically
    serializes that object into a response body that can be sent to the client in
    a format such as JSON or XML.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们定义了一个名为 `Player` 的新记录类型。Spring Boot自动将此对象序列化为响应体，该响应体可以以JSON或XML等格式发送给客户端。
- en: Spring Boot uses a message converter to perform this serialization. The choice
    of message converter and the serialization format depends on the Accept header
    in the client’s request. By default, Spring Boot serializes the response as JSON.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot使用消息转换器来完成此序列化。消息转换器的选择和序列化格式取决于客户端请求中的Accept头。默认情况下，Spring Boot将响应序列化为JSON。
- en: About records
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关于记录
- en: The `equals()`, `hashCode()`, and `toString()` constructors based on the record
    components. This feature aims to simplify the creation of classes that primarily
    encapsulate data. Spring Boot 3 uses Java 17 or higher.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `equals()`、`hashCode()` 和 `toString()` 构造函数的记录组件。此功能旨在简化主要封装数据的类的创建。Spring
    Boot 3 使用 Java 17 或更高版本。
- en: 'If you have special serialization requirements you can configure your own message
    converter by implementing your `WebMvcConfigurer` and overriding the method `configureMessageConverters`.
    You can find more information in the Spring Framework documentation: [https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List)).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有特殊的序列化要求，你可以通过实现自己的 `WebMvcConfigurer` 并覆盖 `configureMessageConverters`
    方法来配置自己的消息转换器。你可以在Spring框架文档中找到更多信息：[https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List))。
- en: 'Spring Boot’s default handling of HTTP status codes can be summarized as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot对HTTP状态码的默认处理可以总结如下：
- en: When the execution occurs without generating exceptions, it responds with an
    HTTP 200 status.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当执行过程没有生成异常时，它将以 HTTP 200 状态响应。
- en: If a method is not implemented by the endpoint, it will return a **405 Method
    not** **allowed** error.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果端点未实现方法，它将返回一个 **405 方法不允许** 错误。
- en: If trying to get a resource that doesn’t exist, for instance, a path that is
    not managed by the application, it will return **404** **Not found**.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尝试获取一个不存在的资源，例如，一个应用程序未管理的路径，它将返回 **404** **未找到**。
- en: If the request is not valid, it will return **400** **Bad Request**.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求无效，它将返回 **400** **错误请求**。
- en: In the event of an exception, it yields an **HTTP 500 Internal** **Server error**.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发生异常的情况下，它产生一个 **HTTP 500 内部服务器** **错误**。
- en: There are other operations related to security, which we will discuss in later
    chapters, that may return **401 Unauthorized** or **403 Forbidden**.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他与安全相关的操作，我们将在后面的章节中讨论，这些操作可能会返回 **401 未授权** 或 **403 禁止**。
- en: This behavior can be enough in some scenarios, but if you want to provide proper
    semantics to your RESTful API, you should return a 404 status code when a resource
    is not found. Check the next recipe to learn how to handle these scenarios.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，这种行为可能已经足够，但如果你想要为你的RESTful API提供适当的语义，你应该在找不到资源时返回404状态码。检查下一个菜谱以了解如何处理这些场景。
- en: Note that the `FootballService` class is annotated with `@Service`, `@Controller`,
    `@Bean`, and others. As there is a dependency in the `PlayerController` class
    for `FootballService`, when Spring Boot instantiates the `PlayerController`, it
    passes an instance of `FootballService` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`FootballService` 类被注解为 `@Service`、`@Controller`、`@Bean` 等。由于 `PlayerController`
    类对 `FootballService` 有依赖，当Spring Boot实例化 `PlayerController` 时，它传递 `FootballService`
    类的一个实例。
- en: Managing errors in a RESTful API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理RESTful API中的错误
- en: In the previous recipe, we enhanced our RESTful API by using complex data structures.
    However, the application was not able to manage some common errors or return standard
    response codes. In this recipe, l we will enhance the previous RESTful API by
    managing common errors and returning consistent response codes following the standards.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一食谱中，我们通过使用复杂的数据结构增强了我们的RESTful API。然而，应用程序无法管理一些常见的错误或返回标准的响应代码。在本食谱中，我们将通过管理常见错误并返回符合标准的一致响应代码来增强之前的RESTful
    API。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can use the project generated in the previous recipe or download the sample
    from the GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用上一食谱生成的项目，或者从GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)下载样本。
- en: You can find the code to start this exercise in the `chapter1/recipe1-3/start`
    folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`chapter1/recipe1-3/start`文件夹中找到开始此练习的代码。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we will modify the RESTful API created in the previous recipe
    to handle the exceptions that can be raised by our application and we’ll return
    the most appropriate HTTP response code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将修改上一食谱中创建的RESTful API，以处理应用程序可能引发的异常，并将返回最合适的HTTP响应代码。
- en: 'All content created in the following steps will be under the `src/main/java/com/packt/football`
    folder or one of the subfolders you will create. Let’s get started:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中创建的所有内容都将位于`src/main/java/com/packt/football`文件夹或你将创建的子文件夹中。让我们开始吧：
- en: 'If you try to retrieve a non-existing player or create the same player twice,
    it will throw an exception. The result will be an HTTP 500 server error:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试检索一个不存在的玩家或创建相同的玩家两次，它将抛出异常。结果将是一个HTTP 500服务器错误：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To manage this error more consistently, we will add a new `notFoundHandler`
    method in the `PlayerController` class to manage `NotFoundException` errors:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更一致地管理此错误，我们将在`PlayerController`类中添加一个新的`notFoundHandler`方法来管理`NotFoundException`错误：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we’ll add another method named `alreadyExistsHandler` to manage `AlreadyExistsException`
    errors:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加另一个名为`alreadyExistsHandler`的方法来管理`AlreadyExistsException`错误：
- en: '[PRE27]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `application` root folder, open a terminal and execute the following
    command to run the application:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application`根目录下，打开一个终端并执行以下命令以运行应用程序：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Test the application by executing the following curl commands:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下curl命令来测试应用程序：
- en: 'Execute this command to get a player that does not exist:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行以下命令以获取一个不存在的玩家：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that by returning an `HTTP 404 Not Found` response, our application adheres
    to standard RESTful API semantics. HTTP 404 means that you tried to get a resource
    that does not exist, in our case, player 9999.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，通过返回`HTTP 404 Not Found`响应，我们的应用程序遵循标准的RESTful API语义。HTTP 404表示你尝试获取一个不存在的资源，在我们的例子中是玩家9999。
- en: 'Let’s verify that our application manages the `AlreadyExistsException` as expected.
    Execute the following request to create a player twice:'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们验证我们的应用程序是否按预期管理了`AlreadyExistsException`。执行以下请求以创建玩家两次：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first time it will work with no errors and will return the `HTTP 200` code.
    The second time it will return an `HTTP` `400` code.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一次运行时将没有任何错误，并返回`HTTP 200`代码。第二次运行将返回`HTTP` `400`代码。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we learned in the previous recipe, Spring Boot manages the HTTP status code
    for the most common cases. In this recipe, we demonstrated how to manage other
    scenarios that are specific to our application logic and require consistent HTTP
    status codes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一食谱中学到的，Spring Boot管理最常见的HTTP状态代码。在本食谱中，我们展示了如何管理其他特定于我们应用程序逻辑的场景，并需要一致的HTTP状态代码。
- en: To provide proper semantics to the RESTful API, you should return a `404` status
    code when a resource is not found. In some scenarios, it could make sense to change
    the signature of `FootballService` to return a null value in case it doesn’t find
    a player. However, if the controller returns a null the response will be `HTTP
    200` anyway. To avoid this behavior, we added the **@ExceptionHandler** annotation
    to add a handler method to manage a specific type of exception, and the **@ResponseStatus**
    annotation to manage the HTTP status code to return in that specific method handler.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给RESTful API提供适当的语义，当资源未找到时，你应该返回`404`状态码。在某些场景中，将`FootballService`的签名更改为在找不到玩家时返回null值是有意义的。然而，如果控制器返回null，响应将仍然是`HTTP
    200`。为了避免这种行为，我们添加了**@ExceptionHandler**注解来添加一个处理方法来管理特定类型的异常，以及**@ResponseStatus**注解来管理在该特定方法处理程序中返回的HTTP状态码。
- en: There’s more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is possible to control the response codes more explicitly in your code.
    Instead of using your data model directly in the controller, you can return `ResponseEntity`,
    which allows you to specify the status code explicitly. The following is an example
    of how you can implement `getPlayer` in this way:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，你可以更明确地控制响应码。而不是直接在控制器中使用你的数据模型，你可以返回`ResponseEntity`，这允许你明确指定状态码。以下是如何以这种方式实现`getPlayer`的示例：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another alternative is having a global handler for all controllers by using
    a class annotated with `@ControllerAdvice`, like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案是使用带有`@ControllerAdvice`注解的类来为所有控制器提供一个全局处理器：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this way, you can have consistent error-handling for all your RESTful endpoints
    in your application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以为应用程序中所有RESTful端点提供一致的错误处理。
- en: Testing a RESTful API
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试RESTful API
- en: Testing the application manually can be tiring, especially when dealing with
    challenging scenarios that are hard to validate. Additionally, it lacks scalability
    in terms of development productivity. Hence, I highly recommend applying automated
    testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试应用程序可能会很累，尤其是在处理难以验证的挑战性场景时。此外，它在开发生产率方面缺乏可扩展性。因此，我强烈建议应用自动化测试。
- en: By default, Spring Boot includes the *Testing starter* that provides the basic
    components for unit and integration testing. In this recipe, we’ll learn how to
    implement a unit test for our RESTful API.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot包括提供单元和集成测试基本组件的*Testing starter*。在这个菜谱中，我们将学习如何为我们的RESTful
    API实现单元测试。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create unit tests for the RESTful API created in the previous
    recipe. I prepared a working version in case you haven’t completed it yet. You
    can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    You can find the code to start this recipe in the `chapter1/recipe1-4/start` folder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为之前菜谱中创建的RESTful API创建单元测试。如果你还没有完成，我准备了一个工作版本。你可以在书的GitHub仓库中找到它，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。你可以在这个菜谱的`chapter1/recipe1-4/start`文件夹中找到启动此菜谱的代码。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let’s add some tests to our RESTful API that will validate our application
    whenever we change it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的RESTful API中添加一些测试，以便在更改应用程序时验证它：
- en: 'We’ll start by creating a new test class for our RESTful controller in the
    `src/test` folder. Let’s name the new class `PlayerControllerTest` and annotate
    it with `@WebMvcTest` as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`src/test`文件夹中为我们的RESTful控制器创建一个新的测试类。让我们将新类命名为`PlayerControllerTest`，并使用`@WebMvcTest`注解，如下所示：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, define a field of type `MockMvc` and annotate it as `@Autowired`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个类型为`MockMvc`的字段，并使用`@Autowired`注解。
- en: '[PRE34]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, create another field of type `FootballService` and annotate it with `@MockBean`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建另一个类型为`FootballService`的字段，并使用`@MockBean`注解。
- en: 'We are ready now to write our first test:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写我们的第一个测试：
- en: 'Let’s create a method to validate when our RESTful API returns the players.
    Name the new method `testListPlayers`:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个方法来验证我们的RESTful API何时返回玩家。将新方法命名为`testListPlayers`：
- en: '[PRE35]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Importantly, note that it should be annotated with `@Test`.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要注意，它应该使用`@Test`注解。
- en: 'The first thing to do in the test is configure `FootballService`. The following
    lines configure `FootballService` to return a list of two players when invoking
    the `listPlayers` method:'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的第一件事是配置`FootballService`。以下行配置`FootballService`在调用`listPlayers`方法时返回两位玩家的列表：
- en: '[PRE36]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code performs a GET request that accepts application/JSON content.
    The expected result is OK, meaning any HTTP status code between 200 and 299\.
    The expected result is a JSON array with two elements. Finally, we save the result
    in the `result` variable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行了一个接受application/JSON内容的GET请求。预期结果是OK，这意味着任何200到299之间的HTTP状态码。预期结果是一个包含两个元素的JSON数组。最后，我们将结果保存在`result`变量中。
- en: 'As we saved the result in the `result` variable, we can perform additional
    validations. For instance, we can validate that the returned array of players
    is exactly as expected:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将结果保存在了`result`变量中，我们可以执行额外的验证。例如，我们可以验证返回的球员数组是否完全符合预期：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '@Test'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: public void testReadPlayer_doesnt_exist() throws Exception {
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: public void testReadPlayer_doesnt_exist() throws Exception {
- en: '}'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: String id = "1884823";
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: String id = "1884823";
- en: given(footballService.getPlayer(id))
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: given(footballService.getPlayer(id))
- en: '.mvc field defined in *step 2* to simulate the request and then validate it
    behaves as expected:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*步骤 2*中定义的`.mvc`字段来模拟请求，然后验证其行为是否符合预期：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To execute the tests, use the following command:'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要执行测试，请使用以下命令：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `test` goal is also executed anytime you execute the `package` or `install`
    goals unless you explicitly disable the test execution.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行`package`或`install`目标时，也会执行`test`目标，除非你明确禁用测试执行。
- en: Usually, you can also execute the tests from your favorite IDE.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你也可以从你喜欢的IDE中执行测试。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By default, Spring Initializr includes a dependency for `spring-boot-starter-test`.
    This dependency provides all the necessary components to create tests. Let’s describe
    the elements used in this recipe:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Initializr包括对`spring-boot-starter-test`的依赖。这个依赖提供了创建测试所需的所有必要组件。让我们描述在这个菜谱中使用的元素：
- en: '`@WebMvcTest`: When you apply this annotation to a testing class, it disables
    Spring Boot default autoconfiguration and applies only the relevant configuration
    for MVC tests. That means that it doesn’t register classes annotated with `@Service`
    as `FootballService`, but it registers classes annotated with `@RestController`
    as `PlayerController`.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebMvcTest`: 当你将此注解应用于测试类时，它禁用了Spring Boot默认的自动配置，并仅应用与MVC测试相关的配置。这意味着它不会注册带有`@Service`注解的`FootballService`类，但它会注册带有`@RestController`注解的`PlayerController`类。'
- en: '`@MockBean`: As our `FootballService` class is not autoconfigured because we
    use `@WebMvcTest`), we can register our own implementation of `FootballService`.
    The `@MockBean` annotation allows us to mock the implementation of `FootballService`,
    replacing any previous bean registration.'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MockBean`: 由于我们的`FootballService`类没有自动配置（因为我们使用了`@WebMvcTest`），我们可以注册自己的`FootballService`实现。`@MockBean`注解允许我们模拟`FootballService`的实现，替换任何之前的bean注册。'
- en: '`given`: This method stubs a method and allows us to specify the behavior.
    For instance, using `thenReturn` sets the return value when the method specified
    by `given` is called.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`given`: 这种方法模拟了一个方法，并允许我们指定其行为。例如，使用`thenReturn`在调用`given`指定的方法时设置返回值。'
- en: '`MockMvc`: This simulates the behavior of the web server and allows you to
    test your controllers without having to deploy the application. When performing
    simulated requests, it returns `ResultActions` that provides methods to validate
    that the controller behaves as expected, for instance, the `andExpect` method.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvc`: 这模拟了Web服务器的行为，并允许你测试你的控制器，而无需部署应用程序。在执行模拟请求时，它返回`ResultActions`，提供了验证控制器行为是否符合预期的方法，例如`andExpect`方法。'
- en: In this recipe, we used other JUnit utilities, such as `assertArrayEquals` to
    compare the elements of two arrays. The utilities offered by JUnit and other testing
    libraries are very extensive and we won’t cover them all in detail in this book.
    However, I’ll explain the testing utilities the first time I introduce them as
    we go through.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了其他JUnit实用工具，例如`assertArrayEquals`来比较两个数组的元素。JUnit和其他测试库提供的实用工具非常广泛，我们不会在这本书中详细涵盖所有内容。然而，当我介绍它们时，我会解释测试实用工具。
- en: There’s more...
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can write tests for the rest of the methods exposed by our RESTful API as
    an exercise. I also prepared some tests for this RESTful API myself. You can find
    them in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)
    – the final version is in the `chapter1/recipe1-4/end` folder.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以作为一个练习为我们的RESTful API公开的其他方法编写测试。我还为这个RESTful API准备了一些测试。你可以在书的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)中找到它们——最终版本在`chapter1/recipe1-4/end`文件夹中。
- en: See also
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this book, I apply the **Arrange-Act-Assert** (**AAA**) principles when
    writing tests:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这本书中，我在编写测试时应用了**安排-执行-断言**（**AAA**）原则：
- en: '**Arrange**: In this step, you prepare the class you want to test by setting
    up the conditions needed for the “act” step to run'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：在这个步骤中，你通过设置“执行”步骤运行所需的条件来准备你想要测试的类。'
- en: '**Act**: In this step, you perform the action you are testing'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：在这个步骤中，你执行你正在测试的操作'
- en: '**Assert**: In this step, you verify that the expected results were achieved'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：在这个步骤中，你验证是否达到了预期的结果'
- en: There is also the **Arrange-Act-Assert-Clean** (**AAAC**) variant that adds
    a last step to clean up any change done by the test. Ideally, that last step should
    not be necessary as we can mock any component or service that handles a state
    that requires being cleaned up.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，还有**安排-执行-断言-清理**（**AAAC**）的变体，它增加了一个最后一步来清理测试所做的任何更改。理想情况下，最后一步不应该必要，因为我们可以模拟任何需要清理状态的处理组件或服务。
- en: Using OpenAPI to document our RESTful API
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用OpenAPI来文档我们的RESTful API
- en: Now that we have a RESTful API, we can create a consumer application. We could
    create an application and just perform HTTP requests. That would require that
    we provide the consumers with the source code of our application and that they
    understand it. But what if they are developing their application in a different
    language and they don’t know Java and Spring Boot? For this reason, OpenAPI was
    created. OpenAPI is a standard to document RESTful APIs and can be used to generate
    client applications. It’s widely adopted and is supported by different languages
    and frameworks. Spring Boot’s support for OpenAPI is excellent.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有了RESTful API，我们可以创建一个消费者应用程序。我们可以创建一个应用程序并仅执行HTTP请求。这将要求我们向消费者提供我们应用程序的源代码，并且他们需要理解它。但如果他们正在用不同的语言开发他们的应用程序，并且他们不知道Java和Spring
    Boot呢？出于这个原因，OpenAPI被创建出来。OpenAPI是一个用于文档RESTful API的标准，可以用来生成客户端应用程序。它被广泛采用，并支持不同的语言和框架。Spring
    Boot对OpenAPI的支持非常出色。
- en: In this recipe, we’ll learn how to add OpenAPI support to our RESTful API and
    consume it using the tools provided by OpenAPI.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何为我们的RESTful API添加OpenAPI支持，并使用OpenAPI提供的工具来消费它。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will enhance the RESTful API created in the previous recipe.
    If you haven’t completed the previous recipe, you can find a working version in
    the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将增强之前菜谱中创建的RESTful API。如果你还没有完成之前的菜谱，你可以在书的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)中找到一个工作版本。
- en: You can find the code to start this exercise in the `chapter1/recipe1-5/start`
    folder.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在`chapter1/recipe1-5/start`文件夹中找到开始这个练习的代码。
- en: Note
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: OpenAPI 3.0 is the new name of Swagger after it was donated by SmartBear to
    the OpenAPI Initiative. You will likely find a lot of documentation still using
    the name *Swagger* when referring to OpenAPI.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenAPI 3.0是Swagger在SmartBear捐赠给OpenAPI倡议后的新名称。你可能会发现很多文档仍然使用*Swagger*这个名字来指代OpenAPI。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let’s document our RESTful API with OpenAPI and start testing from the nice
    OpenAPI user interface:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用OpenAPI来文档我们的RESTful API，并从漂亮的OpenAPI用户界面开始测试：
- en: 'Open the `pom.xml` file of RESTful API project and add the SpringDoc OpenAPI
    Starter WebMVC UI dependency, `org.springdoc:springdoc-openapi-starter-webmvc-ui`.
    To add the dependency, insert the following XML into the `<``dependencies>` element:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开RESTful API项目的`pom.xml`文件，并添加SpringDoc OpenAPI Starter WebMVC UI依赖项，`org.springdoc:springdoc-openapi-starter-webmvc-ui`。要添加依赖项，将以下XML插入到`<dependencies>`元素中：
- en: '[PRE42]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Important
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要
- en: For brevity, I removed the other dependencies from the code snippet, but you
    should keep all of them in your code.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简洁，我从代码片段中删除了其他依赖项，但你应该在你自己的代码中保留所有这些依赖项。
- en: 'Now you can execute this application and open the following URL in your browser:
    `http://localhost:8080/v3/api-docs`. It returns the description of your RESTful
    API in OpenAPI format. You can also open `http://localhost:8080/swagger-ui/index.html`
    for a nice user interface to interact with your API.'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以执行此应用程序并在浏览器中打开以下 URL：`http://localhost:8080/v3/api-docs`。它以 OpenAPI 格式返回您的
    RESTful API 的描述。您还可以打开 `http://localhost:8080/swagger-ui/index.html` 以获得一个用于与您的
    API 交互的友好用户界面。
- en: '![Figure 1.2: Open API (Swagger) UI for our RESTful API](img/B21646_01_2.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 1.2：我们的 RESTful API 的 Open API (Swagger) UI](img/B21646_01_2.jpg)'
- en: 'Figure 1.2: Open API (Swagger) UI for our RESTful API'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.2：我们的 RESTful API 的 Open API (Swagger) UI
- en: As you can see, it exposes all the RESTful operations defined in the application
    and the data model used, in this case, `Player`. Now you can use the browser to
    execute any of the operations available.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，它公开了应用程序中定义的所有 RESTful 操作以及使用的数据模型，在这种情况下是 `Player`。现在您可以使用浏览器执行任何可用的操作。
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `org.springdoc:springdoc-openapi-starter-webmvc-ui` dependency examines
    the application at runtime to generate the description of the endpoints available.
    The core of OpenAPI is the service definition that can be found at http://localhost:8080/v3/api-docs.
    That is a JSON document that follows the OpenAPI schema and describes the RESTful
    endpoints hosted in the application. An endpoint is a combination of a path, HTTP
    method, parameters, responses, and data schemas.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`org.springdoc:springdoc-openapi-starter-webmvc-ui` 依赖项在运行时检查应用程序以生成端点的描述。OpenAPI
    的核心是可在 http://localhost:8080/v3/api-docs 找到的服务定义。这是一个遵循 OpenAPI 架构的 JSON 文档，描述了应用程序中托管的
    RESTful 端点。端点是路径、HTTP 方法、参数、响应和数据模式的组合。'
- en: The other interesting feature provided by the OpenAPI dependency is a nice UI
    that uses the OpenAPI schema to provide a basic interaction with the service.
    It can replace `curl` to test the RESTful service as it’s not necessary to remember
    all possible arguments.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenAPI 依赖项提供的另一个有趣的功能是使用 OpenAPI 架构提供基本交互的友好 UI。它可以替代 `curl` 来测试 RESTful 服务，因为它不需要记住所有可能的参数。
- en: Consuming a RESTful API from another Spring Boot application using FeignClient
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 FeignClient 从另一个 Spring Boot 应用程序消费 RESTful API
- en: Now that we have a RESTful API and it’s properly documented, we can create a
    consumer application. There are many tools to generate the client code from the
    OpenAPI specification, but in this project, we will create the client code manually
    for learning purposes.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个 RESTful API，并且它已经得到了适当的文档，我们可以创建一个消费者应用程序。有许多工具可以从 OpenAPI 规范生成客户端代码，但在这个项目中，我们将为了学习目的手动创建客户端代码。
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will enhance the RESTful API created in the previous recipe. If you haven’t
    completed that yet, you can find a working version in the book’s GitHub repo at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](http://ebay.co.uk).
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将增强前面菜谱中创建的 RESTful API。如果您还没有完成，您可以在本书的 GitHub 仓库 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](http://ebay.co.uk)
    中找到一个工作版本。
- en: You can find the code to start this exercise in the `chapter1/recipe1-6/start`
    folder.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在 `chapter1/recipe1-6/start` 文件夹中找到开始此练习的代码。
- en: We will create a new Spring Boot application using the Spring Initializr tool
    again ([https://start.spring.io](https://start.spring.io)).
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将再次使用 Spring Initializr 工具创建一个新的 Spring Boot 应用程序 ([https://start.spring.io](https://start.spring.io))。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll create a Spring Boot application consuming the Football RESTful API created
    in the previous recipe:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建一个 Spring Boot 应用程序，它将消费在前面菜谱中创建的 Football RESTful API：
- en: 'First, we’ll create a new Spring Boot application. Open [https://start.spring.io](https://start.spring.io)
    and use the same parameters as in the *Creating a RESTful API* recipe, except
    for changing the following options:'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的 Spring Boot 应用程序。打开 [https://start.spring.io](https://start.spring.io)
    并使用与 *创建 RESTful API* 菜单中相同的参数，除了以下选项需要更改：
- en: For `albums`
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `albums`
- en: For **Dependencies**, select **Spring Web** and **OpenFeign**
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **依赖项**，选择 **Spring Web** 和 **OpenFeign**
- en: '![Figure 1.3: Spring Initializr for consumer application](img/B21646_01_3.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 1.3：消费者应用的 Spring Initializr](img/B21646_01_3.jpg)'
- en: 'Figure 1.3: Spring Initializr for consumer application'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.3：消费者应用的 Spring Initializr
- en: Generate the project to download the ZIP file. Extract the project and open
    `pom.xml`.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成项目以下载 ZIP 文件。解压缩项目并打开 `pom.xml`。
- en: 'Create a record named `Player` and add the following code:'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Player` 的记录并添加以下代码：
- en: '[PRE43]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create an interface named `FootballClient` and add the following code:'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FootballClient` 的接口并添加以下代码：
- en: '[PRE44]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a controller named `AlbumsController.java` with the following code:'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AlbumsController.java` 的控制器，代码如下：
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Modify the `AlbumsApplication` application class by adding the `@EnableFeignClients`
    annotation:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过添加 `@EnableFeignClients` 注解修改 `AlbumsApplication` 应用程序类：
- en: '[PRE46]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now execute the application by executing the following command in your terminal:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过在您的终端中执行以下命令来运行应用程序：
- en: '[PRE47]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The additional parameter is to run this application listening on port `8081`,
    instead of the default `8080`. The other application is listening on port `8080`,
    hence we need to avoid port conflicts.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 额外的参数是运行此应用程序监听端口 `8081`，而不是默认的 `8080`。另一个应用程序正在监听端口 `8080`，因此我们需要避免端口冲突。
- en: 'Then test the application:'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后测试应用程序：
- en: '[PRE48]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You will receive a response similar to this:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将收到类似以下响应：
- en: '[PRE49]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Feign is a `@RequestMapping`, such as `@GetMapping`, `@PostMapping`, and `@PutMapping`,
    to specify the HTTP method and the URL path. Indeed, the annotations are the same
    as those used in the server-side application.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Feign 是一个 `@RequestMapping`，例如 `@GetMapping`、`@PostMapping` 和 `@PutMapping`，用于指定
    HTTP 方法以及 URL 路径。实际上，这些注解与服务器端应用程序中使用的注解相同。
- en: You can inject the Feign client interface into your Spring components and use
    it to make HTTP requests. Spring Cloud Feign will automatically generate and execute
    the HTTP requests based on the interface definition. By decorating the application
    class with `@EnableFeignClients`, it scans the application for interfaces with
    the `@FeignClient` annotation and generates the client.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将 Feign 客户端接口注入到您的 Spring 组件中，并使用它来发送 HTTP 请求。Spring Cloud Feign 将根据接口定义自动生成并执行
    HTTP 请求。通过在应用程序类上装饰 `@EnableFeignClients`，它会扫描应用程序中带有 `@FeignClient` 注解的接口并生成客户端。
- en: In the controller, we can then use the Feign client simply via Spring Boot dependency
    injection.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在控制器中，我们可以通过 Spring Boot 依赖注入简单地使用 Feign 客户端。
- en: Do note that we passed an additional parameter, `-Dspring-boot.run.arguments=--`
    `server.port=8081`, to execute the client application. The reason is that the
    RESTful API is already using port `8080` so we need to execute the client application
    in a different port.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们传递了一个额外的参数 `-Dspring-boot.run.arguments=-- server.port=8081` 来执行客户端应用程序。原因是
    RESTful API 已经在使用端口 `8080`，因此我们需要在不同的端口上执行客户端应用程序。
- en: There’s more...
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多...
- en: There are other options than Feign to perform the requests. I decided to use
    Feign due to its great integration with Spring Cloud components, such as Eureka
    Server. We will see in the following recipes how to integrate with Spring Cloud
    and how it can do load balancing on the client side.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了 Feign 之外，还有其他选项可以执行请求。我决定使用 Feign，因为它与 Spring Cloud 组件（如 Eureka 服务器）的集成非常出色。在接下来的菜谱中，我们将看到如何与
    Spring Cloud 集成以及它如何在客户端进行负载均衡。
- en: 'Most of the code on the client side in this recipe can be automatically generated
    using IDE integrations or standalone tools. These tools are especially useful
    to maintain the client-side code in sync with the server descriptions. These tools
    use OpenAPI descriptions exposed by the RESTful API to generate the client code:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本菜谱中，客户端的大部分代码可以使用 IDE 集成或独立工具自动生成。这些工具特别有用，可以保持客户端代码与服务器描述同步。这些工具使用 RESTful
    API 暴露的 OpenAPI 描述来生成客户端代码：
- en: 'OpenAPITools: [https://github.com/OpenAPITools/openapi-generator](https://github.com/OpenAPITools/openapi-generator)'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenAPITools: [https://github.com/OpenAPITools/openapi-generator](https://github.com/OpenAPITools/openapi-generator)'
- en: 'swagger-codegen: [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'swagger-codegen: [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)'
- en: Both projects provide a command-line tool and a Maven plugin to generate client-side
    code.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个项目都提供了一个命令行工具和一个 Maven 插件来生成客户端代码。
- en: Consuming a RESTful API from another Spring Boot application using RestClient
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从另一个 Spring Boot 应用程序使用 RestClient 消费 RESTful API
- en: In this recipe, we’ll use a new component introduced in Spring Framework 6.1
    and available in Spring Boot since version 3.2\. In the previous recipe, we created
    a FeignClient by creating an interface in the client application and defining
    the same methods available in the target service. By using the RestClient component,
    we will have a fluent API that offers an abstraction over HTTP libraries. It allows
    converting from Java objects to HTTP requests, and the other way round, the creation
    of objects from the HTTP responses.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Spring 框架 6.1 中引入的新组件，并在 Spring Boot 3.2 版本中可用。在先前的菜谱中，我们通过在客户端应用程序中创建一个接口并定义目标服务中可用的相同方法来创建一个
    FeignClient。通过使用 RestClient 组件，我们将获得一个提供 HTTP 库抽象的流畅 API。它允许将 Java 对象转换为 HTTP
    请求，反之亦然，从 HTTP 响应创建对象。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will enhance the RESTful API created in the *Using OpenAPI to document our
    RESTful API* recipe. If you haven’t completed it yet, you can find a working version
    in the book’s GitHub repo at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将增强在*使用 OpenAPI 记录我们的 RESTful API*菜谱中创建的 RESTful API。如果您还没有完成，您可以在书的 GitHub
    仓库中找到一个工作版本，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: You can find the code to start this exercise in the `chapter1/recipe1-7/start`
    folder.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在 `chapter1/recipe1-7/start` 文件夹中找到启动此练习的代码。
- en: We will create a new Spring Boot application using the Spring Initializr tool
    again ([https://start.spring.io](https://start.spring.io)).
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将再次使用 Spring Initializr 工具创建一个新的 Spring Boot 应用程序 ([https://start.spring.io](https://start.spring.io))。
- en: How to do it...
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We’ll create a new Spring Boot application using the Spring Initializr tool
    that will consume the RESTful API created in the *Using OpenAPI to document our
    RESTful* *API* recipe:'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将再次使用 Spring Initializr 工具创建一个新的 Spring Boot 应用程序，该应用程序将消耗在*使用 OpenAPI 记录我们的
    RESTful API*菜谱中创建的 RESTful API：
- en: 'Let’s start by creating a new Spring Boot application using the Spring Initializr
    tool. To do this, open [https://start.spring.io](https://start.spring.io) in your
    browser and use the same parameters as in the *Creating a RESTful API* recipe,
    except for changing the following options:'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从使用 Spring Initializr 工具创建一个新的 Spring Boot 应用程序开始。为此，在您的浏览器中打开 [https://start.spring.io](https://start.spring.io)，并使用与*创建
    RESTful API*菜谱中相同的参数，除了更改以下选项：
- en: For `albums`
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `albums`
- en: For **Dependencies**, select **Spring Web**
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**依赖项**，选择**Spring Web**
- en: 'Now, create a configuration class named `AlbumsConfiguration` in which we define
    a `RestClient` bean:'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `AlbumsConfiguration` 的配置类，在其中我们定义一个 `RestClient` 实例：
- en: '[PRE50]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that we defined a field with the `@Value` annotation to configure the URL
    of the remote server.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们使用 `@Value` 注解定义了一个字段来配置远程服务器的 URL。
- en: 'Next, create a service class named `FootballClientService`. This class will
    use the Spring Boot container to inject the `RestClient` bean in the constructor:'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `FootballClientService` 的服务类。这个类将使用 Spring Boot 容器在构造函数中注入 `RestClient`
    实例：
- en: '[PRE51]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, you can use the `RestClient` to retrieve the data from the remote RESTful
    API. You can create a method named `getPlayers` as follows:'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `RestClient` 从远程 RESTful API 获取数据。您可以创建一个名为 `getPlayers` 的方法，如下所示：
- en: '[PRE52]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, you can create another method to get just a single player from the remote
    RESTful API:'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以创建另一个方法来从远程 RESTful API 获取单个玩家：
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, you can create an Album RESTful API using the `FootballClientService`
    service. I created a sample version that you can find in the book’s GitHub repository.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以使用 `FootballClientService` 服务创建一个 Album RESTful API。我创建了一个示例版本，您可以在书的
    GitHub 仓库中找到。
- en: How it works...
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we didn’t create any additional type to replicate the remote
    RESTful API. Instead, we used the `RestClient` to perform requests using the Fluent
    API style, that is, using the result of a method to chain a call to another method.
    This Fluent API design is easier to read, that’s why it’s named “Fluent”.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们没有创建任何额外的类型来复制远程 RESTful API。相反，我们使用了 `RestClient` 来使用 Fluent API 风格执行请求，即使用方法的结果来链式调用另一个方法。这种
    Fluent API 设计易于阅读，因此被称为“Fluent”。
- en: 'Let’s analyze what we did in the `getPlayer` method:'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们分析在 `getPlayer` 方法中我们做了什么：
- en: We started by calling the `get` method, which returns an object that can be
    used to set the request’s properties, such as the URI, the headers, and other
    request parameters. We just set the remote address by using the `uri` method.
    Note that this address is appended to the base address defined in the `AlbumsConfiguration`
    class.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先调用了`get`方法，该方法返回一个可以用来设置请求属性的对象，例如URI、头部和其他请求参数。我们只是通过使用`uri`方法设置了远程地址。请注意，此地址附加到`AlbumsConfiguration`类中定义的基本地址。
- en: When we called the `exchange` method, the RestClient performed the call to the
    remote RESTful API. Then, the method exchange provides a handler to manage the
    response.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用`exchange`方法时，RestClient执行了对远程RESTful API的调用。然后，`exchange`方法提供了一个处理器来管理响应。
- en: In the response handler, we control what happens if the player is not found,
    in which case we return an empty object. Otherwise, we use the `bodyTo` method,
    which allows passing a type to be used to deserialize the response. In this example,
    we used the `Player` class.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在响应处理器中，我们控制当找不到播放器时会发生什么，在这种情况下，我们返回一个空对象。否则，我们使用`bodyTo`方法，该方法允许传递一个用于反序列化响应的类型。在这个例子中，我们使用了`Player`类。
- en: The code for `getPlayers` is very similar to `getPlayer`; the main difference
    is that the result is a `List` of players. To specify this, it was necessary to
    use the `ParameterizedTypeReference` class to pass a generic type. To capture
    the generic type, it’s necessary to define a subclass of `ParameterizedTypeReference`,
    which we did by defining an anonymous inline class. That’s why we added the new
    `ParameterizedTypeReference<List<Player>>(){ }`, including the curly braces `{
    }` at the end.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getPlayers`的代码与`getPlayer`非常相似；主要区别在于结果是播放器的`List`。为了指定这一点，有必要使用`ParameterizedTypeReference`类传递一个泛型类型。为了捕获泛型类型，需要定义`ParameterizedTypeReference`的子类，我们通过定义一个匿名内联类来实现。这就是为什么我们添加了新的`ParameterizedTypeReference<List<Player>>(){
    }`，包括最后的括号`{ }`。'
- en: In this recipe, we used the `@Value` annotation in the `AlbumsConfiguration`
    class. This annotation allows us to inject values from external sources, for instance
    from configuration files or environment variables. The value `"${football.api.url:http://localhost:8080}"`
    means that it will try to get the `footbal.api.url` configuration property first.
    If it’s not defined, it will take the default value, `http://localhost:8080`.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们在`AlbumsConfiguration`类中使用了`@Value`注解。这个注解允许我们从外部源注入值，例如从配置文件或环境变量中。值`"${football.api.url:http://localhost:8080}"`意味着它将首先尝试获取`footbal.api.url`配置属性。如果没有定义，它将采用默认值，`http://localhost:8080`。
- en: You will see that the format of the properties will change depending on whether
    they are defined in the `application.properties` file or the `application.yml`
    file. In the `application.properties` file, you will see the full property in
    a single line. That is `football.api.url=http://localhost:8080`.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到属性的格式会根据它们是在`application.properties`文件中定义还是在`application.yml`文件中定义而改变。在`application.properties`文件中，你会看到完整的属性在单行中。那就是`football.api.url=http://localhost:8080`。
- en: 'On the other hand, the `application.yml` file can nest the properties, so you
    will see the following:'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，`application.yml`文件可以嵌套属性，所以你会看到以下内容：
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this book, I’ll use the `application.yml` file in most of the cases, but
    you will encounter the `application.properties` format as well, such as when using
    the environment variables.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这本书中，我将在大多数情况下使用`application.yml`文件，但你也会遇到`application.properties`格式，例如在使用环境变量时。
- en: Mocking a RESTful API
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模拟RESTful API
- en: The main drawback of using a remote service as we did in the previous recipes
    is that you need the remote service running when you test your client application.
    To tackle this scenario, you can **mock** a remote server. By *mock*, I mean simulating
    the behavior of a component or service, in this case, the remote service.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用远程服务作为我们之前食谱中所做的主要缺点是，当你测试客户端应用程序时，你需要远程服务正在运行。为了应对这种场景，你可以**模拟**一个远程服务器。通过**模拟**，我的意思是模拟组件或服务的行为了，在这种情况下，是远程服务。
- en: Mocking a remote dependency in a test can be useful for several reasons. One
    of the main reasons is that it allows you to test your code in isolation, without
    having to worry about the behavior of the remote dependency. This can be especially
    useful if the remote dependency is unreliable or slow, or if you want to test
    your code in different scenarios that are difficult to reproduce with the remote
    dependency.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试中模拟远程依赖项可以有几个原因。其中一个主要原因是它允许你在隔离的环境中测试你的代码，无需担心远程依赖项的行为。如果远程依赖项不可靠或速度慢，或者你想要测试难以用远程依赖项复制的不同场景，这特别有用。
- en: In this recipe, we’ll learn how to use Wiremock to mock the remote `Football`
    service in our Albums application during the testing execution.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何在测试执行期间使用 Wiremock 模拟我们的 Albums 应用程序中的远程 `Football` 服务。
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create the tests for the application we built in the *Consuming
    a RESTful API from another Spring Boot application using RestClient* recipe. If
    you haven’t completed that recipe yet, I have prepared a working version of the
    recipe that can be found in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in `chapter1/recipe1-8/start`.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将为我们在 *从另一个 Spring Boot 应用程序使用 RestClient 消费 RESTful API* 食谱中构建的应用程序创建测试。如果你还没有完成那个食谱，我准备了一个可以在本书的
    GitHub 仓库中找到的工作版本，该仓库位于 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)，在
    `chapter1/recipe1-8/start`。
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll add the Wiremock dependency to our project and then we’ll be able to
    create isolated tests for our Albums application:'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将向我们的项目添加 Wiremock 依赖项，然后我们将能够为我们的 Albums 应用程序创建隔离的测试：
- en: 'The first thing to do is to add the Wiremock dependency to the Albums project.
    To do so, open the `pom.xml` file and add the following dependency:'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首件事是向 Albums 项目添加 Wiremock 依赖项。要做到这一点，打开 `pom.xml` 文件并添加以下依赖项：
- en: '[PRE55]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we can create a test class for our `FootballClientService`. Let’s name
    the test class `FootballClientServiceTest`. We’ll use the `@SpringBootTest` annotation
    to pass a property with the remote server address:'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的 `FootballClientService` 创建一个测试类。让我们将测试类命名为 `FootballClientServiceTest`。我们将使用
    `@SpringBootTest` 注解传递一个带有远程服务器地址的属性：
- en: '[PRE56]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we need to set up a Wiremock server in the test. Add the following content
    to the `FootballClientServiceTest` class:'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在测试中设置一个 Wiremock 服务器。将以下内容添加到 `FootballClientServiceTest` 类中：
- en: '[PRE57]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can declare a `FootballClientService` field that will be injected by
    Spring Boot. Annotate it with `@Autowired`:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以声明一个 `FootballClientService` 字段，该字段将由 Spring Boot 注入。用 `@Autowired` 注解它：
- en: '[PRE58]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, write a test to validate the `getPlayer` method.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编写一个测试来验证 `getPlayer` 方法。
- en: 'Name the test `getPlayerTest`:'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试命名为 `getPlayerTest`：
- en: '[PRE59]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let’s start first by arranging the result of the remote service. Add the following
    code to the test:'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先安排远程服务的结果。将以下代码添加到测试中：
- en: '[PRE60]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, call the `getPlayer` method. This method depends on the remote service:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用 `getPlayer` 方法。此方法依赖于远程服务：
- en: '[PRE61]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And then validate the results:'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后验证结果：
- en: '[PRE62]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As an exercise, you can create tests for the rest of methods of the `FootballClientService`
    class and also other scenarios, such as simulating different responses from the
    remote server. You can find a few more tests prepared in the book’s GitHub repository.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为练习，你可以为 `FootballClientService` 类的其余方法创建测试，也可以创建其他场景的测试，例如模拟远程服务器不同的响应。你可以在本书的
    GitHub 仓库中找到一些准备好的测试。
- en: How it works...
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Wiremock is a library for API mock testing. It can run as an independent tool
    or as a library, as we did in this recipe. Wiremock is necessary for tests only,
    and for that reason, we configured the `scope` dependency as `test`. There is
    a known incompatibility with Spring Boot version 3.2.x. Spring Boot uses Jetty
    12, while Wiremock depends on Jetty 11\. To avoid that incompatibility we used
    the `wiremock-standalone` artifact instead of the `wiremock` artifact, as it includes
    all required dependencies.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Wiremock 是一个用于 API 模拟测试的库。它可以作为一个独立工具运行，也可以作为一个库运行，就像我们在本食谱中所做的那样。Wiremock 只在测试中是必要的，因此我们将
    `scope` 依赖配置为 `test`。与 Spring Boot 版本 3.2.x 存在已知的不兼容性。Spring Boot 使用 Jetty 12，而
    Wiremock 依赖于 Jetty 11。为了避免这种不兼容性，我们使用了 `wiremock-standalone` 依赖项，而不是 `wiremock`
    依赖项，因为它包含了所有必需的依赖项。
- en: The Wiremock project is not part of the Spring Boot framework, however, it is
    a popular option for mocking services in Spring projects.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Wiremock 项目不是 Spring Boot 框架的一部分，然而，它是 Spring 项目中模拟服务的一个流行选择。
- en: In this recipe, we used the `@SpringBootTest` annotation as it uses the SpringBoot
    context and allows passing custom environment variables with the `properties`
    field. We used the properties to pass the address of the remote server where we
    configured Wiremock. We used a different server address to avoid conflicts with
    the real remote server in case it was running on the machine for whatever reason.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了`@SpringBootTest`注解，因为它使用了SpringBoot上下文，并允许通过`properties`字段传递自定义环境变量。我们使用这些属性来传递我们配置Wiremock的远程服务器地址。我们使用不同的服务器地址以避免与实际远程服务器发生冲突，无论出于何种原因它可能正在该机器上运行。
- en: We also used `@BeforeAll` to run the Wiremock server initialization before each
    test was executed. In that initialization, we configured the Wiremock server to
    listen on port `7979`, matching the configuration passed in the `properties` field.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还使用了`@BeforeAll`来在每次测试执行之前运行Wiremock服务器初始化。在这个初始化中，我们配置Wiremock服务器监听端口`7979`，与`properties`字段中传递的配置相匹配。
- en: 'With `StubFor` we configured the desired behavior for the remote server: when
    receiving a `GET` request for `/players/325636`, it should return a JSON with
    the mocked player. The rest is just normal test validation to make sure the result
    is as expected.'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`StubFor`，我们为远程服务器配置了所需的行为：当接收到对`/players/325636`的`GET`请求时，它应该返回一个包含模拟玩家的JSON。其余的只是正常的测试验证，以确保结果符合预期。
- en: See also
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参见
- en: You can find more information about Wiremock on the project web page at [https://www.wiremock.io/](https://www.wiremock.io/).
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在项目的网页上找到更多关于Wiremock的信息：[https://www.wiremock.io/](https://www.wiremock.io/)。
- en: '[PRE63]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
