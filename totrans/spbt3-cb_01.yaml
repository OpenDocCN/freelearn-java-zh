- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful APIs are crucial in modern cloud apps for seamless data exchange, enabling
    interoperability, scalability, and efficient communication between services. Spring
    Boot simplifies RESTful authoring by providing a framework for quick, efficient
    development, auto-configuration, and integrated tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will acquire the skills to create RESTful services and
    consume them seamlessly from other applications. You will also learn how to create
    automated tests for your RESTful APIs using the features provided by Spring Boot
    and other popular tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining responses and the data model exposed by the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing errors in a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OpenAPI to document our RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming a RESTful API from another Spring Boot application using FeignClient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming a RESTful API from another Spring Boot application using RestClient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter’s recipes, you will need a computer with any OS (I
    use Ubuntu on Windows Subsystem for Linux – WSL), an editor such as Visual Studio
    Code ([https://code.visualstudio.com/](https://code.visualstudio.com/)) or IntelliJ
    Idea ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)), and
    Java OpenJDK 17 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple distributions of Java from different vendors – if you already
    have one installed, you can continue using it; if you need to install one, you
    can use Eclipse Adoptium distribution ([https://adoptium.net/](https://adoptium.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: If you use Visual Studio Code, I recommend installing Extension Pack for Java
    ([https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack))
    and Spring Boot Extension Pack ([https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack](https://marketplace.visualstudio.com/items?itemName=vmware.vscode-boot-dev-pack)).
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have a tool to perform HTTP requests, you could use curl ([https://curl.se/](https://curl.se/))
    or Postman ([https://www.postman.com/](https://www.postman.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can download the complete project on GitHub at: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).'
  prefs: []
  type: TYPE_NORMAL
- en: You will need a git client to download the code from the book’s GitHub repository
    ([https://git-scm.com/downloads](https://git-scm.com/downloads)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **RESTful API** is a standardized way for software components to communicate
    over the internet using HTTP methods and URLs. You should learn it because it’s
    fundamental for modern web and cloud application development. It promotes scalable,
    flexible, and stateless communication, enabling developers to design efficient
    and widely compatible systems. Understanding RESTful APIs is crucial for building
    and integrating services.
  prefs: []
  type: TYPE_NORMAL
- en: When I was a child I played with football-player cards, exchanging cards that
    I had multiples of with my friends. My children, some decades later, still play
    this game. Throughout this chapter, you will create a system to manage a football
    card-trading game, with teams, players, albums, and cards. In this recipe, you
    will create a RESTful API exposing **Create, Read, Update, and Delete** (**CRUD**)
    **operations** on football players.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a RESTful API, Spring Boot provides a great tool named Spring Initializr.
    You can open this tool in your browser using [https://start.spring.io/](https://start.spring.io/).
    We’ll use this tool to create a Spring Boot project with all dependencies. This
    tool is also well integrated into code editors such as VSCode and IntelliJ (Premium
    edition).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a RESTful project using Spring Initializr and create our first
    endpoint with typical HTTP operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io) in your browser and
    you’ll see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1: Spring Initializr](img/B21646_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Spring Initializr'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Initilizr allows you to configure the project and generates the structure
    with the necessary files and dependencies, which you can use as a starting point
    for your application. On this start page, set up the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** section, select **Maven**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Language** section, select **Java**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Spring Boot** section, select the latest stable version – at the time
    of writing this book, this is **3.1.4**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Dependencies** section, select **Spring Web**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the following in the `com.packt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `football`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Demo project for Spring Boot` `3 Coobook`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Packaging**, select **Jar**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Java**, select **21**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have configured the preceding options, you can choose the options
    for **Generate**, **Explore**, or **Share…**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click **Explore**, you can explore the project before downloading it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you click **Share**, a URL is generated that you can share with other people.
    For instance, our configuration will produce this URL: [https://start.spring.io/#!type=maven-project
    &language=java&platformVersion=3.1.3&packaging=jar&jvmVersion=1 7&groupId=compackt&artifactId=football&name=football&description=Demo%20project%20for%20Spring%20Boot%203%20
    Cookbook&packageName=com.packt.football&dependencies=web](https://start.spring.io/).
    If you open it, it will configure all of the options as shown in *Figure 1.1*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you click **Generate**, it will download a ZIP file of the project structure.
    Click this option now.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip the file. You now have the basic project structure, but you don’t have
    any API. If you try to run the application, you will receive an HTTP 404 Not Found
    response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `src/main/java/com/packt/football` folder, create a file named `PlayerController.java`
    with the following content to create a RESTful endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run it, open a terminal in the project root folder and execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will build your project and start the application. By default,
    the web container listens on port `8080`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute an HTTP request to see the results. You can open `http://localhost:8080/players`
    in a browser or use a tool such as curl to perform the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will have a list of players returned by the controller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enhance your RESTful endpoint by adding more verbs. In the `PlayerController.java`
    file, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a POST request to create a player:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another GET request to return one player:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a DELETE request to delete one player:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a PUT request to update a player:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute your application again as explained in *step 5* and test your endpoint.
    Perform a GET request by entering the following command into your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform a POST request using curl:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'curl --header "Content-Type: application/text" --request DELETE http://localhost:8080/players/Aitana%20BONMATI'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Player Aitana BONMATI deleted
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By adding the Spring Web dependency to our project, Spring Boot automatically
    embeds a Tomcat server in the application. `start.spring.io` and it listens on
    port `8080`, which is the default port for Tomcat. However, as there is no mapping
    configured in the application, it always responds with a 404 Not Found error.
  prefs: []
  type: TYPE_NORMAL
- en: By adding the `PlayerController` class, we are informing Spring Boot that it
    should register the `PlayerController` class in dependency containers as an implementation
    class. By adding `PlayerController` class. As we applied these at a class level,
    we configured all requests in this class with the `players` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is mapping requests to their handling methods. This is performed
    by using mapping annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@GetMapping`: Maps a GET request to a method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`: Maps a POST request to a method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PutMapping`: Maps a PUT request to a method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMethod`: Maps a DELETE request to a method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These mapping annotations are a specialization of `@RequestMapping`, as they
    inform the web container how to map a request to its handler, in this case, using
    the annotated method.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you can only have one of these mapping types per controller
    (i.e., one `GetMapping` or `PostMapping`) unless you provide more configuration
    to refine the mapping. In this example, you can see there are two instances of
    `@GetMapping`, but `readPlayer` is annotated with an additional element and thus
    is mapped with its class prefix, `players`, plus a name. That means all GET requests
    with `/players/anything` will be mapped to this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of now, that additional information is not yet configured in the method.
    To use all this additional HTTP request information in your method, you can use
    the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@GetMapping("/{name}") public String readPlayer(@PathVariable String name)`
    maps the last part of the path to the `name` method argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@RequestBody**: This will map the request body to the method argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@RequestHeader**: This will map request headers to the method argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@RequestParam**: You can use this to map requests params, such as query string
    parameters, form data, or parts in multipart requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just by decorating our classes with previous annotations, Spring Boot is able
    to set up the web application container to manage the requests. There are some
    annotations not yet covered, but we covered the basics to create our RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if the RESTful endpoint we just created is very simple, I intentionally
    added these methods – `GET` by default, `GET` with an identifier, `POST`, `PUT`,
    and `DELETE`. This choice is rooted in the fact that it aligns with the most prevalent
    semantics for performing CRUD and List operations on a resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of our resource being football *players*, we have the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` by default usually returns a list of resources, in our case, all players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` with an identifier returns a specific player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` creates a new resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` updates a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` deletes a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the HTTP status code responses are very important in the semantics of
    RESTful operations. In this recipe, the responses are not managed in the standard
    way. In the following recipes, we will expand on this and learn how Spring Boot
    can facilitate the proper handling of responses.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to learn more about API design, you can visit the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://swagger.io/resources/articles/best-practices-in-api-design/](https://swagger.io/resources/articles/best-practices-in-api-design/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/azure/architecture/best-practices/api-design](https://learn.microsoft.com/azure/architecture/best-practices/api-design)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining responses and the data model exposed by the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created a very simple RESTful API. To develop a RESTful
    API that provides a positive user experience for its consumers, it is essential
    to incorporate both standard response codes and a consistent data model. In this
    recipe, we will enhance the previous RESTful API by returning standard response
    codes and creating a data model for our players endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the project generated in the previous recipe or download the sample
    from the GitHub repository: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code to start this exercise in the `chapter1/recipe1-2/start`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a folder structure to contain different types
    of classes for our project. We will define a data model to expose in our RESTful
    API, along with a service to provide the operations needed by the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all of the content created in the following steps will be under the
    `src/main/java/com/packt/football` folder or one of the subfolders you will create
    when required. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder named `model`. Then in this folder, create a file named `Player.java`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder named `exceptions`. In this folder, create two files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first, `AlreadyExistsException.java`, should have the following content:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'And the second, `NotFoundException.java`, should contain this content:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another folder named `services`, and in this folder, create a class
    named `FootballService`. This class manages all operations needed by our RESTful
    API. Do the following in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the class first:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This class will manage the data in a `Map`, keeping all players in memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let’s define a `Map<String, Player>` field and initialize it. (I just created
    two entries for brevity, but in the GitHub repo, you will find many more):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the operations required by our RESTful API:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by listing the players:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then return a player (do note that if the player doesn’t exist, it will throw
    an exception):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new player (do note that if the player already exists, it will throw
    an exception):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Update a player (note that if the player doesn’t already exist, it will throw
    an exception):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete a player (note that if the player doesn’t exist, it will continue without
    errors):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the `PlayerController` class, modify the controller to use our new
    service and expose the newly created data model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `FootballService` field and create a constructor in the `PlayerController`
    class with an argument of type `FootballService` to initialize it:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the operations to manage the players. We will use our recently created
    service to manage that functionality. As explained in the previous recipe, we
    will decorate our class methods to manage the RESTful endpoint methods and will
    invoke the services of our `Football` service class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `application` root folder, open a terminal and execute the following
    command to run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the application by executing the following `curl` command to get all of
    the players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we defined a new record type named `Player`. Spring Boot automatically
    serializes that object into a response body that can be sent to the client in
    a format such as JSON or XML.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot uses a message converter to perform this serialization. The choice
    of message converter and the serialization format depends on the Accept header
    in the client’s request. By default, Spring Boot serializes the response as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: About records
  prefs: []
  type: TYPE_NORMAL
- en: The `equals()`, `hashCode()`, and `toString()` constructors based on the record
    components. This feature aims to simplify the creation of classes that primarily
    encapsulate data. Spring Boot 3 uses Java 17 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have special serialization requirements you can configure your own message
    converter by implementing your `WebMvcConfigurer` and overriding the method `configureMessageConverters`.
    You can find more information in the Spring Framework documentation: [https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMe%20ssageConverters(java.util.List)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot’s default handling of HTTP status codes can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the execution occurs without generating exceptions, it responds with an
    HTTP 200 status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a method is not implemented by the endpoint, it will return a **405 Method
    not** **allowed** error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If trying to get a resource that doesn’t exist, for instance, a path that is
    not managed by the application, it will return **404** **Not found**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the request is not valid, it will return **400** **Bad Request**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the event of an exception, it yields an **HTTP 500 Internal** **Server error**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other operations related to security, which we will discuss in later
    chapters, that may return **401 Unauthorized** or **403 Forbidden**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This behavior can be enough in some scenarios, but if you want to provide proper
    semantics to your RESTful API, you should return a 404 status code when a resource
    is not found. Check the next recipe to learn how to handle these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `FootballService` class is annotated with `@Service`, `@Controller`,
    `@Bean`, and others. As there is a dependency in the `PlayerController` class
    for `FootballService`, when Spring Boot instantiates the `PlayerController`, it
    passes an instance of `FootballService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Managing errors in a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we enhanced our RESTful API by using complex data structures.
    However, the application was not able to manage some common errors or return standard
    response codes. In this recipe, l we will enhance the previous RESTful API by
    managing common errors and returning consistent response codes following the standards.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the project generated in the previous recipe or download the sample
    from the GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code to start this exercise in the `chapter1/recipe1-3/start`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will modify the RESTful API created in the previous recipe
    to handle the exceptions that can be raised by our application and we’ll return
    the most appropriate HTTP response code.
  prefs: []
  type: TYPE_NORMAL
- en: 'All content created in the following steps will be under the `src/main/java/com/packt/football`
    folder or one of the subfolders you will create. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to retrieve a non-existing player or create the same player twice,
    it will throw an exception. The result will be an HTTP 500 server error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To manage this error more consistently, we will add a new `notFoundHandler`
    method in the `PlayerController` class to manage `NotFoundException` errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll add another method named `alreadyExistsHandler` to manage `AlreadyExistsException`
    errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `application` root folder, open a terminal and execute the following
    command to run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the application by executing the following curl commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute this command to get a player that does not exist:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that by returning an `HTTP 404 Not Found` response, our application adheres
    to standard RESTful API semantics. HTTP 404 means that you tried to get a resource
    that does not exist, in our case, player 9999.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s verify that our application manages the `AlreadyExistsException` as expected.
    Execute the following request to create a player twice:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The first time it will work with no errors and will return the `HTTP 200` code.
    The second time it will return an `HTTP` `400` code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in the previous recipe, Spring Boot manages the HTTP status code
    for the most common cases. In this recipe, we demonstrated how to manage other
    scenarios that are specific to our application logic and require consistent HTTP
    status codes.
  prefs: []
  type: TYPE_NORMAL
- en: To provide proper semantics to the RESTful API, you should return a `404` status
    code when a resource is not found. In some scenarios, it could make sense to change
    the signature of `FootballService` to return a null value in case it doesn’t find
    a player. However, if the controller returns a null the response will be `HTTP
    200` anyway. To avoid this behavior, we added the **@ExceptionHandler** annotation
    to add a handler method to manage a specific type of exception, and the **@ResponseStatus**
    annotation to manage the HTTP status code to return in that specific method handler.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to control the response codes more explicitly in your code.
    Instead of using your data model directly in the controller, you can return `ResponseEntity`,
    which allows you to specify the status code explicitly. The following is an example
    of how you can implement `getPlayer` in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative is having a global handler for all controllers by using
    a class annotated with `@ControllerAdvice`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can have consistent error-handling for all your RESTful endpoints
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the application manually can be tiring, especially when dealing with
    challenging scenarios that are hard to validate. Additionally, it lacks scalability
    in terms of development productivity. Hence, I highly recommend applying automated
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring Boot includes the *Testing starter* that provides the basic
    components for unit and integration testing. In this recipe, we’ll learn how to
    implement a unit test for our RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create unit tests for the RESTful API created in the previous
    recipe. I prepared a working version in case you haven’t completed it yet. You
    can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    You can find the code to start this recipe in the `chapter1/recipe1-4/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add some tests to our RESTful API that will validate our application
    whenever we change it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by creating a new test class for our RESTful controller in the
    `src/test` folder. Let’s name the new class `PlayerControllerTest` and annotate
    it with `@WebMvcTest` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define a field of type `MockMvc` and annotate it as `@Autowired`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, create another field of type `FootballService` and annotate it with `@MockBean`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are ready now to write our first test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create a method to validate when our RESTful API returns the players.
    Name the new method `testListPlayers`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Importantly, note that it should be annotated with `@Test`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first thing to do in the test is configure `FootballService`. The following
    lines configure `FootballService` to return a list of two players when invoking
    the `listPlayers` method:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code performs a GET request that accepts application/JSON content.
    The expected result is OK, meaning any HTTP status code between 200 and 299\.
    The expected result is a JSON array with two elements. Finally, we save the result
    in the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saved the result in the `result` variable, we can perform additional
    validations. For instance, we can validate that the returned array of players
    is exactly as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: public void testReadPlayer_doesnt_exist() throws Exception {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: String id = "1884823";
  prefs: []
  type: TYPE_NORMAL
- en: given(footballService.getPlayer(id))
  prefs: []
  type: TYPE_NORMAL
- en: '.mvc field defined in *step 2* to simulate the request and then validate it
    behaves as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the tests, use the following command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `test` goal is also executed anytime you execute the `package` or `install`
    goals unless you explicitly disable the test execution.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you can also execute the tests from your favorite IDE.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By default, Spring Initializr includes a dependency for `spring-boot-starter-test`.
    This dependency provides all the necessary components to create tests. Let’s describe
    the elements used in this recipe:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@WebMvcTest`: When you apply this annotation to a testing class, it disables
    Spring Boot default autoconfiguration and applies only the relevant configuration
    for MVC tests. That means that it doesn’t register classes annotated with `@Service`
    as `FootballService`, but it registers classes annotated with `@RestController`
    as `PlayerController`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@MockBean`: As our `FootballService` class is not autoconfigured because we
    use `@WebMvcTest`), we can register our own implementation of `FootballService`.
    The `@MockBean` annotation allows us to mock the implementation of `FootballService`,
    replacing any previous bean registration.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`given`: This method stubs a method and allows us to specify the behavior.
    For instance, using `thenReturn` sets the return value when the method specified
    by `given` is called.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockMvc`: This simulates the behavior of the web server and allows you to
    test your controllers without having to deploy the application. When performing
    simulated requests, it returns `ResultActions` that provides methods to validate
    that the controller behaves as expected, for instance, the `andExpect` method.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we used other JUnit utilities, such as `assertArrayEquals` to
    compare the elements of two arrays. The utilities offered by JUnit and other testing
    libraries are very extensive and we won’t cover them all in detail in this book.
    However, I’ll explain the testing utilities the first time I introduce them as
    we go through.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can write tests for the rest of the methods exposed by our RESTful API as
    an exercise. I also prepared some tests for this RESTful API myself. You can find
    them in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)
    – the final version is in the `chapter1/recipe1-4/end` folder.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this book, I apply the **Arrange-Act-Assert** (**AAA**) principles when
    writing tests:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Arrange**: In this step, you prepare the class you want to test by setting
    up the conditions needed for the “act” step to run'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: In this step, you perform the action you are testing'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: In this step, you verify that the expected results were achieved'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the **Arrange-Act-Assert-Clean** (**AAAC**) variant that adds
    a last step to clean up any change done by the test. Ideally, that last step should
    not be necessary as we can mock any component or service that handles a state
    that requires being cleaned up.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using OpenAPI to document our RESTful API
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a RESTful API, we can create a consumer application. We could
    create an application and just perform HTTP requests. That would require that
    we provide the consumers with the source code of our application and that they
    understand it. But what if they are developing their application in a different
    language and they don’t know Java and Spring Boot? For this reason, OpenAPI was
    created. OpenAPI is a standard to document RESTful APIs and can be used to generate
    client applications. It’s widely adopted and is supported by different languages
    and frameworks. Spring Boot’s support for OpenAPI is excellent.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to add OpenAPI support to our RESTful API and
    consume it using the tools provided by OpenAPI.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we will enhance the RESTful API created in the previous recipe.
    If you haven’t completed the previous recipe, you can find a working version in
    the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the code to start this exercise in the `chapter1/recipe1-5/start`
    folder.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: OpenAPI 3.0 is the new name of Swagger after it was donated by SmartBear to
    the OpenAPI Initiative. You will likely find a lot of documentation still using
    the name *Swagger* when referring to OpenAPI.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s document our RESTful API with OpenAPI and start testing from the nice
    OpenAPI user interface:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `pom.xml` file of RESTful API project and add the SpringDoc OpenAPI
    Starter WebMVC UI dependency, `org.springdoc:springdoc-openapi-starter-webmvc-ui`.
    To add the dependency, insert the following XML into the `<``dependencies>` element:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For brevity, I removed the other dependencies from the code snippet, but you
    should keep all of them in your code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you can execute this application and open the following URL in your browser:
    `http://localhost:8080/v3/api-docs`. It returns the description of your RESTful
    API in OpenAPI format. You can also open `http://localhost:8080/swagger-ui/index.html`
    for a nice user interface to interact with your API.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.2: Open API (Swagger) UI for our RESTful API](img/B21646_01_2.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.2: Open API (Swagger) UI for our RESTful API'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, it exposes all the RESTful operations defined in the application
    and the data model used, in this case, `Player`. Now you can use the browser to
    execute any of the operations available.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `org.springdoc:springdoc-openapi-starter-webmvc-ui` dependency examines
    the application at runtime to generate the description of the endpoints available.
    The core of OpenAPI is the service definition that can be found at http://localhost:8080/v3/api-docs.
    That is a JSON document that follows the OpenAPI schema and describes the RESTful
    endpoints hosted in the application. An endpoint is a combination of a path, HTTP
    method, parameters, responses, and data schemas.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The other interesting feature provided by the OpenAPI dependency is a nice UI
    that uses the OpenAPI schema to provide a basic interaction with the service.
    It can replace `curl` to test the RESTful service as it’s not necessary to remember
    all possible arguments.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Consuming a RESTful API from another Spring Boot application using FeignClient
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a RESTful API and it’s properly documented, we can create a
    consumer application. There are many tools to generate the client code from the
    OpenAPI specification, but in this project, we will create the client code manually
    for learning purposes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will enhance the RESTful API created in the previous recipe. If you haven’t
    completed that yet, you can find a working version in the book’s GitHub repo at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](http://ebay.co.uk).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the code to start this exercise in the `chapter1/recipe1-6/start`
    folder.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will create a new Spring Boot application using the Spring Initializr tool
    again ([https://start.spring.io](https://start.spring.io)).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll create a Spring Boot application consuming the Football RESTful API created
    in the previous recipe:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we’ll create a new Spring Boot application. Open [https://start.spring.io](https://start.spring.io)
    and use the same parameters as in the *Creating a RESTful API* recipe, except
    for changing the following options:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For `albums`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web** and **OpenFeign**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.3: Spring Initializr for consumer application](img/B21646_01_3.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.3: Spring Initializr for consumer application'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Generate the project to download the ZIP file. Extract the project and open
    `pom.xml`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a record named `Player` and add the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an interface named `FootballClient` and add the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a controller named `AlbumsController.java` with the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `AlbumsApplication` application class by adding the `@EnableFeignClients`
    annotation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now execute the application by executing the following command in your terminal:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The additional parameter is to run this application listening on port `8081`,
    instead of the default `8080`. The other application is listening on port `8080`,
    hence we need to avoid port conflicts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then test the application:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will receive a response similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Feign is a `@RequestMapping`, such as `@GetMapping`, `@PostMapping`, and `@PutMapping`,
    to specify the HTTP method and the URL path. Indeed, the annotations are the same
    as those used in the server-side application.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can inject the Feign client interface into your Spring components and use
    it to make HTTP requests. Spring Cloud Feign will automatically generate and execute
    the HTTP requests based on the interface definition. By decorating the application
    class with `@EnableFeignClients`, it scans the application for interfaces with
    the `@FeignClient` annotation and generates the client.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the controller, we can then use the Feign client simply via Spring Boot dependency
    injection.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Do note that we passed an additional parameter, `-Dspring-boot.run.arguments=--`
    `server.port=8081`, to execute the client application. The reason is that the
    RESTful API is already using port `8080` so we need to execute the client application
    in a different port.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are other options than Feign to perform the requests. I decided to use
    Feign due to its great integration with Spring Cloud components, such as Eureka
    Server. We will see in the following recipes how to integrate with Spring Cloud
    and how it can do load balancing on the client side.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Most of the code on the client side in this recipe can be automatically generated
    using IDE integrations or standalone tools. These tools are especially useful
    to maintain the client-side code in sync with the server descriptions. These tools
    use OpenAPI descriptions exposed by the RESTful API to generate the client code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'OpenAPITools: [https://github.com/OpenAPITools/openapi-generator](https://github.com/OpenAPITools/openapi-generator)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'swagger-codegen: [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both projects provide a command-line tool and a Maven plugin to generate client-side
    code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Consuming a RESTful API from another Spring Boot application using RestClient
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we’ll use a new component introduced in Spring Framework 6.1
    and available in Spring Boot since version 3.2\. In the previous recipe, we created
    a FeignClient by creating an interface in the client application and defining
    the same methods available in the target service. By using the RestClient component,
    we will have a fluent API that offers an abstraction over HTTP libraries. It allows
    converting from Java objects to HTTP requests, and the other way round, the creation
    of objects from the HTTP responses.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will enhance the RESTful API created in the *Using OpenAPI to document our
    RESTful API* recipe. If you haven’t completed it yet, you can find a working version
    in the book’s GitHub repo at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the code to start this exercise in the `chapter1/recipe1-7/start`
    folder.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will create a new Spring Boot application using the Spring Initializr tool
    again ([https://start.spring.io](https://start.spring.io)).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll create a new Spring Boot application using the Spring Initializr tool
    that will consume the RESTful API created in the *Using OpenAPI to document our
    RESTful* *API* recipe:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new Spring Boot application using the Spring Initializr
    tool. To do this, open [https://start.spring.io](https://start.spring.io) in your
    browser and use the same parameters as in the *Creating a RESTful API* recipe,
    except for changing the following options:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For `albums`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, create a configuration class named `AlbumsConfiguration` in which we define
    a `RestClient` bean:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we defined a field with the `@Value` annotation to configure the URL
    of the remote server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a service class named `FootballClientService`. This class will
    use the Spring Boot container to inject the `RestClient` bean in the constructor:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can use the `RestClient` to retrieve the data from the remote RESTful
    API. You can create a method named `getPlayers` as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can create another method to get just a single player from the remote
    RESTful API:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, you can create an Album RESTful API using the `FootballClientService`
    service. I created a sample version that you can find in the book’s GitHub repository.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we didn’t create any additional type to replicate the remote
    RESTful API. Instead, we used the `RestClient` to perform requests using the Fluent
    API style, that is, using the result of a method to chain a call to another method.
    This Fluent API design is easier to read, that’s why it’s named “Fluent”.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s analyze what we did in the `getPlayer` method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We started by calling the `get` method, which returns an object that can be
    used to set the request’s properties, such as the URI, the headers, and other
    request parameters. We just set the remote address by using the `uri` method.
    Note that this address is appended to the base address defined in the `AlbumsConfiguration`
    class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When we called the `exchange` method, the RestClient performed the call to the
    remote RESTful API. Then, the method exchange provides a handler to manage the
    response.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the response handler, we control what happens if the player is not found,
    in which case we return an empty object. Otherwise, we use the `bodyTo` method,
    which allows passing a type to be used to deserialize the response. In this example,
    we used the `Player` class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for `getPlayers` is very similar to `getPlayer`; the main difference
    is that the result is a `List` of players. To specify this, it was necessary to
    use the `ParameterizedTypeReference` class to pass a generic type. To capture
    the generic type, it’s necessary to define a subclass of `ParameterizedTypeReference`,
    which we did by defining an anonymous inline class. That’s why we added the new
    `ParameterizedTypeReference<List<Player>>(){ }`, including the curly braces `{
    }` at the end.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we used the `@Value` annotation in the `AlbumsConfiguration`
    class. This annotation allows us to inject values from external sources, for instance
    from configuration files or environment variables. The value `"${football.api.url:http://localhost:8080}"`
    means that it will try to get the `footbal.api.url` configuration property first.
    If it’s not defined, it will take the default value, `http://localhost:8080`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You will see that the format of the properties will change depending on whether
    they are defined in the `application.properties` file or the `application.yml`
    file. In the `application.properties` file, you will see the full property in
    a single line. That is `football.api.url=http://localhost:8080`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the other hand, the `application.yml` file can nest the properties, so you
    will see the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this book, I’ll use the `application.yml` file in most of the cases, but
    you will encounter the `application.properties` format as well, such as when using
    the environment variables.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Mocking a RESTful API
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The main drawback of using a remote service as we did in the previous recipes
    is that you need the remote service running when you test your client application.
    To tackle this scenario, you can **mock** a remote server. By *mock*, I mean simulating
    the behavior of a component or service, in this case, the remote service.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Mocking a remote dependency in a test can be useful for several reasons. One
    of the main reasons is that it allows you to test your code in isolation, without
    having to worry about the behavior of the remote dependency. This can be especially
    useful if the remote dependency is unreliable or slow, or if you want to test
    your code in different scenarios that are difficult to reproduce with the remote
    dependency.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to use Wiremock to mock the remote `Football`
    service in our Albums application during the testing execution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we’ll create the tests for the application we built in the *Consuming
    a RESTful API from another Spring Boot application using RestClient* recipe. If
    you haven’t completed that recipe yet, I have prepared a working version of the
    recipe that can be found in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in `chapter1/recipe1-8/start`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll add the Wiremock dependency to our project and then we’ll be able to
    create isolated tests for our Albums application:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first thing to do is to add the Wiremock dependency to the Albums project.
    To do so, open the `pom.xml` file and add the following dependency:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a test class for our `FootballClientService`. Let’s name
    the test class `FootballClientServiceTest`. We’ll use the `@SpringBootTest` annotation
    to pass a property with the remote server address:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to set up a Wiremock server in the test. Add the following content
    to the `FootballClientServiceTest` class:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can declare a `FootballClientService` field that will be injected by
    Spring Boot. Annotate it with `@Autowired`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, write a test to validate the `getPlayer` method.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the test `getPlayerTest`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s start first by arranging the result of the remote service. Add the following
    code to the test:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, call the `getPlayer` method. This method depends on the remote service:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then validate the results:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an exercise, you can create tests for the rest of methods of the `FootballClientService`
    class and also other scenarios, such as simulating different responses from the
    remote server. You can find a few more tests prepared in the book’s GitHub repository.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Wiremock is a library for API mock testing. It can run as an independent tool
    or as a library, as we did in this recipe. Wiremock is necessary for tests only,
    and for that reason, we configured the `scope` dependency as `test`. There is
    a known incompatibility with Spring Boot version 3.2.x. Spring Boot uses Jetty
    12, while Wiremock depends on Jetty 11\. To avoid that incompatibility we used
    the `wiremock-standalone` artifact instead of the `wiremock` artifact, as it includes
    all required dependencies.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Wiremock project is not part of the Spring Boot framework, however, it is
    a popular option for mocking services in Spring projects.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we used the `@SpringBootTest` annotation as it uses the SpringBoot
    context and allows passing custom environment variables with the `properties`
    field. We used the properties to pass the address of the remote server where we
    configured Wiremock. We used a different server address to avoid conflicts with
    the real remote server in case it was running on the machine for whatever reason.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We also used `@BeforeAll` to run the Wiremock server initialization before each
    test was executed. In that initialization, we configured the Wiremock server to
    listen on port `7979`, matching the configuration passed in the `properties` field.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With `StubFor` we configured the desired behavior for the remote server: when
    receiving a `GET` request for `/players/325636`, it should return a JSON with
    the mocked player. The rest is just normal test validation to make sure the result
    is as expected.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find more information about Wiremock on the project web page at [https://www.wiremock.io/](https://www.wiremock.io/).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
