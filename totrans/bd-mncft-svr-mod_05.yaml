- en: Chapter 5. Plugin Commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nice thing about the Bukkit API is that it has the basic features already
    built into its framework. As programmers, we need not go out of our way to implement
    these basic features into plugins. In this chapter, we will discuss one of these
    features, namely the in-game commands that can be executed by a player. These
    are similar to the commands that you are already familiar with, such as `/reload`,
    `/gamemode`, or `/give`. We will create a plugin that will *enchant* an item.
    By the end of this chapter, once the plugin is complete, you will be able to type
    `/enchant` to add your favorite enchantments to the item in your hand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are one of the easiest ways for players to communicate with a plugin.
    They also allow players to trigger the execution of a plugin''s code. For these
    reasons, most plugins will have some sort of command. The Bukkit development team
    realized this and provided us with a simple way to register commands. Registering
    commands through Bukkit ensures that a plugin will know when a player types a
    command. It also prevents a plugin from having conflicts with another plugin''s
    commands. The following are the three steps that we will cover to add a command
    to a plugin:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Informing Bukkit that a plugin will be using a command
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming what a plugin will do when someone types a command
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning newly written code to a specific command
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a command to plugin.yml
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Bukkit plugin as you did in [Chapter 3](part0026_split_000.html#OPEK1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 3. Creating Your First Bukkit Plugin"), *Creating Your First Bukkit Plugin*,
    but name it `Enchanter`. Alternatively, you can create a copy of your existing
    project and modify the name, package, and so on in order to create a new plugin.
    This will eliminate the need to add the required libraries and configure the build
    script. A project can be copied by performing the following steps:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project that you wish to copy and select **Copy…** from the
    menu.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the project name. The project location should remain unchanged.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `build.xml`, as discussed in [Chapter 4](part0033_split_000.html#VF2I1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 4. Testing on the Spigot Server"), *Testing on the Spigot Server*, and
    change the project's name to match what was set in step 2.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the package in your new project so that it is unique by right-clicking
    on the package and selecting **Rename…** in the **Refactor** menu item.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the main class, if necessary. You can also remove the methods or classes
    that you know will not be reused.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, modify the `plugin.yml` file with the new plugin information, including
    name, main, version, and description.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will inform Bukkit that we will use a command by modifying the `plugin.yml`
    file of the plugin. As mentioned in [Chapter 2](part0020_split_000.html#J2B81-b66e70deee6e4ed481db4b113e303f23
    "Chapter 2. Learning the Bukkit API"), *Learning the Bukkit API*, Spigot reads
    the YAML file in order to find out necessary information about the plugin. This
    information includes all the commands that your plugin will handle. Each command
    can have a description, a proper usage message, and aliases, which is similar
    to how `rl` is an alias for `reload`. The command that we will use for the plugin
    will be `enchant`. It is typical to use lowercase letters for commands so that
    players do not have to worry about capitalization when typing the in-game command.
    The following code is a sample of how `plugin.yml` will appear after the `enchant`
    command is added:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过修改插件的`plugin.yml`文件来通知Bukkit我们将使用一个命令。如[第2章](part0020_split_000.html#J2B81-b66e70deee6e4ed481db4b113e303f23
    "第2章。学习Bukkit API")中所述的*学习Bukkit API*，Spigot读取YAML文件以找出有关插件所需的所有信息。这些信息包括您的插件将处理的全部命令。每个命令都可以有一个描述、正确的使用消息和别名，这与`rl`是`reload`的别名类似。我们将用于插件的命令将是`enchant`。通常，使用小写字母来表示命令，这样玩家在输入游戏命令时不必担心大小写。以下是在添加`enchant`命令后`plugin.yml`将如何显示的示例代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how the lines are indented. This indentation must be spaces and not tabs.
    NetBeans helps us automatically indent the necessary lines as you type them. In
    addition to this, NetBeans will automatically use spaces even if you use the *Tab*
    key. Indentation is very important in YAML files as this determines the hierarchy
    of keys. The `enchant command` is indented under `commands` to indicate that it
    is a command for the plugin. The `aliases`, `description`, and `usage` commands
    are indented under `enchant` to indicate that they belong to the `enchant` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些行的缩进。这种缩进必须是空格，而不是制表符。NetBeans在您键入时自动缩进必要的行。此外，即使您使用了*Tab*键，NetBeans也会自动使用空格。在YAML文件中，缩进非常重要，因为它决定了键的层次结构。`enchant
    command`在`commands`下缩进，表示它是插件的命令。`aliases`、`description`和`usage`命令在`enchant`下缩进，表示它们属于`enchant`命令。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The order of these three settings does not matter and they are optional.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个设置的顺序无关紧要，它们是可选的。
- en: The usage message will be displayed in case an error occurs or a player uses
    a command incorrectly. The description message can be viewed by issuing the help
    command for the plugin, that is, `/help Enchanter`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误或玩家错误地使用命令，将显示使用消息。可以通过发出插件的帮助命令来查看描述消息，即`/help Enchanter`。
- en: 'For `aliases`, we have `e` as a value. This means that we can type `/e` if
    we feel that `/enchant` is too long to type. You may have more aliases, but they
    must be put in a YAML list format. Lists in a YAML file can be created in two
    different ways. The first format involves separating each item by a comma and
    a space and enclosing the entire list in square brackets, as shown in the following
    piece of code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`aliases`，我们有一个`e`作为值。这意味着如果我们觉得`/enchant`太长难以输入，我们可以输入`/e`。您可能有更多的别名，但它们必须以YAML列表格式放置。YAML文件中的列表可以以两种不同的方式创建。第一种格式涉及通过逗号和空格分隔每个项目，并将整个列表括在方括号中，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second format involves placing each item on a new line, which starts with
    a hyphen and a space, as shown in the following piece of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种格式涉及将每个项目放在新的一行上，该行以连字符和一个空格开始，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preferred method is usually determined by the length of the list. The second
    format is easier to read when lists are long. However, be careful not to have
    extra or missing spaces before the hyphen, as it will cause problems when a program
    tries to read the list. In general, ensure that your lists line up. For more information
    about the YAML language, visit [http://www.yaml.org/spec/1.2/spec.html](http://www.yaml.org/spec/1.2/spec.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，列表的长度决定了首选的方法。第二种格式在列表很长时更容易阅读。然而，请注意，在连字符之前不要有额外的或缺失的空格，因为这会在程序尝试读取列表时引起问题。一般来说，确保您的列表对齐。有关YAML语言的更多信息，请访问[http://www.yaml.org/spec/1.2/spec.html](http://www.yaml.org/spec/1.2/spec.html)。
- en: 'Multiple commands can be easily added to a plugin. The following code is an
    example of `plugin.yml` with several commands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松地将多个命令添加到插件中。以下代码是`plugin.yml`文件中包含多个命令的示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Programming the command actions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程命令动作
- en: 'Once you have added the command to the `plugin.yml` file, you can begin working
    on the code that the command will trigger. Create a new class in the NetBeans
    project. This new class will be called `EnchantCommand`. You can name the class
    something else if you wish, but keep in mind that the name of a class should give
    you an idea of how the class is used without you having to open it. Place this
    class in the same package as that of `Enchanter`, the main plugin class, as shown
    in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将命令添加到`plugin.yml`文件中，您就可以开始编写命令将触发的代码。在NetBeans项目中创建一个新类。这个新类将被称为`EnchantCommand`。如果您愿意，可以给这个类起其他名字，但请记住，类的名字应该在不打开它的情况下就能让你了解这个类是如何使用的。将这个类放在与`Enchanter`（主插件类）相同的包中，如下面的截图所示：
- en: '![Programming the command actions](img/00035.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![编程命令操作](img/00035.jpeg)'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that though the packages are structured similarly, you will use
    your own unique namespace, not `com.codisimus`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管包的结构相似，但您将使用自己的唯一命名空间，而不是`com.codisimus`
- en: 'This new class will execute the `enchant` command. Thus, it must implement
    the `CommandExecutor` interface. We will append code to the class header to do
    this. This is similar to adding `extends JavaPlugin` to the `Enchanter` class.
    `JavaPlugin` is a class. Therefore, we extended it with our class. `CommandExecutor`
    is an interface, which means that we must implement it. Once we add `implements
    CommandExecutor` to the class header of `EnchantCommand`, a light bulb will appear
    to notify us of the need to import the `CommandExecutor` class. Import the class,
    and the light bulb will still be there. It is now informing us that because we
    implemented an interface, we must implement all of its abstract methods. Click
    on the light bulb to do so, and the method that we need appears. This new method
    will be called when a player executes the `enchant` command. The method provides
    us with the following four parameters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类将执行`enchant`命令。因此，它必须实现`CommandExecutor`接口。我们将向类头添加代码来实现这一点。这类似于向`Enchanter`类添加`extends
    JavaPlugin`。`JavaPlugin`是一个类。因此，我们用我们的类扩展了它。`CommandExecutor`是一个接口，这意味着我们必须实现它。一旦我们在`EnchantCommand`类头中添加了`implements
    CommandExecutor`，就会有一个灯泡出现，提示我们需要导入`CommandExecutor`类。导入该类，灯泡仍然存在。现在它正在通知我们，因为我们实现了接口，我们必须实现其所有抽象方法。点击灯泡来实现，所需的方法就会出现。这个新方法将在玩家执行`enchant`命令时被调用。该方法提供了以下四个参数：
- en: '`CommandSender sender`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommandSender sender`'
- en: This command can be named `cs` by default, but we will name it `sender` because
    it is easy to forget what `cs` stands for
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，此命令可以命名为`cs`，但我们将命名为`sender`，因为它容易忘记`cs`代表什么
- en: This is who sent the command
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是发送命令的人
- en: It may be a player, the console, a command block, or even a custom `CommandSender`
    interface that was created by another plugin
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能是一个玩家、控制台、命令方块，甚至是另一个插件创建的定制`CommandSender`接口
- en: '`Command cmnd`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命令 cmnd`'
- en: This is the `Command` object that the sender executes
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是发送者执行的`命令`对象
- en: We will not need this as this class will be used for only a single command
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将不需要这个，因为这个类将仅用于单个命令
- en: '`String alias`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符串别名`'
- en: This is which alias the sender typed
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是发送者输入的别名
- en: For example, it might be `enchant`, `e`, `addenchant`, or `powerup`
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，它可能是`enchant`、`e`、`addenchant`或`powerup`
- en: '`String[] args`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String[] args`'
- en: This is an array of strings
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个字符串数组
- en: Each string is an argument that the sender type
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字符串都是发送者输入的参数
- en: Arguments follow the alias and are separated by a space
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数跟在别名后面，并由空格分隔
- en: The command itself is not considered as an argument
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令本身不被视为参数
- en: For example, if they type `/enchant knockback 5`, then `knockback` will be the
    first argument (`args[0]`) and `5` will be the second and final argument (`args[1]`)
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果他们输入`/enchant knockback 5`，那么`knockback`将是第一个参数（`args[0]`），而`5`将是第二个也是最后一个参数（`args[1]`）
- en: We do not need to worry about the arguments at this point, because the `enchant`
    command will not need any
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一点上，我们不需要担心参数，因为`enchant`命令不需要任何参数
- en: 'As mentioned before, there are different kinds of `CommandSenders`. The following
    image is an inheritance diagram for `CommandSender`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有不同类型的`CommandSenders`。以下是为`CommandSender`的继承图：
- en: '![Programming the command actions](img/00036.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![编程命令操作](img/00036.jpeg)'
- en: 'In this diagram, you can see that `Player`, `ConsoleCommandSender`, and a couple
    of other classes are all subtypes of `CommandSender`. The purpose of the enchant
    command is to allow a player to enchant the item that they are holding. Therefore,
    a `CommandSender` object that isn''t a player will have no use for this command.
    In the `onCommand` method, the first code that we write will be to check whether
    a player has executed the command. If we do not perform this check, then the plugin
    will crash when a nonplayer attempts to issue the `enchant` command. We will check
    this by using an `if` statement and the `instanceof` keyword. The code for this
    is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，你可以看到`Player`、`ConsoleCommandSender`以及几个其他类都是`CommandSender`的子类型。增强命令的目的允许玩家增强他们持有的物品。因此，非玩家`CommandSender`对象将不会使用这个命令。在`onCommand`方法中，我们首先写的代码是检查是否有玩家执行了命令。如果我们不执行这个检查，那么当非玩家尝试发出`enchant`命令时，插件将会崩溃。我们将通过使用`if`语句和`instanceof`关键字来检查这一点。相应的代码如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code can be translated to this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以翻译为以下内容：
- en: '`if the command sender is a Player`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`如果命令发送者是玩家`'
- en: 'This `if` statement will let us know if it was a player who sent the command.
    If the command sender is not a player, then we want to stop executing the code.
    We will do this by using the `return` keyword. However, the `return` type for
    this method is `boolean`. We must return a `boolean` value, which will tell Bukkit
    whether the usage message needs to be shown to the command sender. Typically,
    for the `onCommand` method, you want to return `false` if the command is not executed
    successfully. In this case, it was not. Therefore, we will use the `return false;`
    code. So far, inside the method, we have constructed the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if`语句将告诉我们是否是玩家发送了命令。如果命令发送者不是玩家，那么我们希望停止执行代码。我们将通过使用`return`关键字来完成这个操作。然而，这个方法的`return`类型是`boolean`。我们必须返回一个`boolean`值，这将告诉Bukkit是否需要向命令发送者显示使用信息。通常，对于`onCommand`方法，如果你希望命令没有成功执行，你想要返回`false`。在这种情况下，它并没有。因此，我们将使用`return
    false;`代码。到目前为止，在方法内部，我们已经构建了以下代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, this is not quite right. This asks Bukkit to return `false` if the
    command sender is a player, but we want to return `false` when the opposite is
    the case. We can accomplish this by adding an exclamation point. If you don''t
    already know, in Java, an exclamation point is a `NOT` operator and can be used
    to invert a `boolean` value. We will correct the previous code by inverting the
    resulting value, as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不完全正确。这要求Bukkit在命令发送者是玩家时返回`false`，但当我们想要返回`false`时，情况正好相反。我们可以通过添加一个感叹号来实现这一点。如果你还不了解，在Java中，感叹号是一个`NOT`运算符，可以用来反转`boolean`值。我们将通过反转结果值来纠正之前的代码，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the extra set of parentheses. This is very important. Parentheses allow
    expressions to be grouped together. We want to invert the `boolean` value that
    results from the `sender instanceof Player` code. Without the parentheses, we
    would be attempting to invert the sender object, which does not make sense. As
    a result of this, the code would not be compiled.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意额外的括号。这非常重要。括号允许表达式被分组。我们想要反转由`sender instanceof Player`代码产生的`boolean`值。如果没有括号，我们就会尝试反转发送者对象，这是没有意义的。因此，代码将无法编译。
- en: 'Up to this point, the `EnchantComand` class code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`EnchantComand`类代码如下：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have taken care of the nonplayers, we are certain that the `CommandSender`
    object is a player. We will want to work with the `Player` object rather than
    the `CommandSender` object because the `Player` object will have a specific item
    in its hand. We can get the `Player` object by *casting* the `CommandSender` object
    to `Player`. By casting, we are telling Java that we know that the command sender
    is actually a `Player object` rather than a `ConsoleCommandSender object` or one
    of the other subtypes. Casting is done by using the following syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了非玩家，我们确定`CommandSender`对象是一个玩家。我们希望与`Player`对象而不是`CommandSender`对象一起工作，因为`Player`对象将手中有特定的物品。我们可以通过将`CommandSender`对象*转换为*`Player`来获取`Player`对象。通过转换，我们告诉Java我们知道命令发送者实际上是一个`Player`对象，而不是`ConsoleCommandSender`对象或其他子类型。转换是通过以下语法完成的：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are not already familiar with casting, I again suggest that you learn
    some of these programming concepts at [codisimus.com/learnjava](http://codisimus.com/learnjava).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉转换，我再次建议你学习一些这些编程概念，请访问[codisimus.com/learnjava](http://codisimus.com/learnjava)。
- en: 'Now that we have the `Player object`, we need the item that they are holding.
    Looking at the Bukkit API documentation for the `Player` class, which is available
    at [https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html),
    you can see that there exists a `getItemInHand` method, which is inherited from
    `HumanEntity`. It will return an `ItemStack` class, which is exactly what we want.
    This is demonstrated in the following piece of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Player对象`，我们需要他们所持有的物品。查看[Bukkit API文档](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html)中关于`Player`类的文档，该文档可在[https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html)找到，你可以看到存在一个`getItemInHand`方法，该方法是从`HumanEntity`继承而来的。它将返回`ItemStack`类，这正是我们想要的。这在上面的代码片段中得到了演示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before doing anything with this item, we have to ensure that there actually
    is an item to enchant. If the player runs the command when they have no item in
    their hand, we do not want the plugin to crash. We will check whether the value
    of `ItemStack class` is `null` and the type of the item is `AIR`. In either case,
    we will return `false`, as follows, because the command wasn''t executed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在对这件物品进行任何操作之前，我们必须确保确实有一个物品可以附魔。如果玩家在手中没有物品时运行命令，我们不希望插件崩溃。我们将检查`ItemStack类`的值是否为`null`以及物品类型是否为`AIR`。在任何情况下，我们都会返回`false`，如下所示，因为命令没有执行：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we do not include the `null` check (hand == null) here in the code, we may
    encounter a `NullPointerExceptions error`, as discussed in *Testing on the Spigot
    Server*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在代码中不包含`null`检查（hand == null），我们可能会遇到*Testing on the Spigot Server*中讨论的`NullPointerExceptions错误`。
- en: Now, we have a reference to the player and the item that they are holding. Our
    end goal is to enchant this item. Again, looking at the API documentation, we
    can find several methods to add enchantments to an `ItemStack class` at [https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html).
    Read through the descriptions to find out which one is right for us.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了对玩家和他们所持物品的引用。我们的最终目标是附魔这个物品。再次查看API文档，我们可以在[https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html)找到添加到`ItemStack类`的几个方法。阅读描述以找出哪个适合我们。
- en: Two of the methods are used to add multiple enchantments at once. We may want
    to add more than one enchantment, but to simplify the code, we will only add one
    at a time. The two remaining methods are `addEnchantment(Enchantment ench, int
    level)` and `addUnsafeEnchantment(Enchantment ench, int level)`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 两个方法用于一次性添加多个附魔。我们可能想要添加多个附魔，但为了简化代码，我们将一次只添加一个。剩下的两个方法是`addEnchantment(Enchantment
    ench, int level)`和`addUnsafeEnchantment(Enchantment ench, int level)`。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The description for the unsafe method states that: *This method is unsafe and
    will ignore level restrictions or item type. Use at your own discretion.* This
    warning is provided because these unsafe enchantments have not been tested and
    could produce undesirable results. You shouldn''t let this deter you from using
    the method but you will want to test the enchantment before using it with friends
    to ensure that it doesn''t crash the server.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全方法的描述中指出：*此方法不安全，将忽略等级限制或物品类型。请自行决定使用。* 提供此警告是因为这些不安全的附魔尚未经过测试，可能会产生不理想的结果。你不应该让这个警告阻止你使用该方法，但在与朋友一起使用之前，你将想要测试附魔，以确保它不会使服务器崩溃。
- en: Therefore, if we choose to go with `unsafe`, we can create powerful enchantments,
    such as a sharpness level of 10\. Without a plugin, a sword is limited to a sharpness
    of level 5\. With unsafe enchantments, we can also enchant items that were previously
    unenchantable, such as a fish with `KNOCKBACK` or `FIRE_ASPECT`. Now, you will
    start to discover all the fun and cool things that you can do with plugins and
    which could not be done with a vanilla game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们选择使用`unsafe`，我们可以创建强大的附魔，例如10级的锋利度。没有插件，剑的锋利度限制在5级。使用不安全的附魔，我们还可以附魔之前无法附魔的物品，例如带有`KNOCKBACK`或`FIRE_ASPECT`的鱼。现在，你将开始发现所有你可以用插件做的有趣和酷的事情，这些事情在原版游戏中是无法做到的。
- en: 'From a personal experience, I found out that the `KNOCKBACK` enchantment is
    quite entertaining. In my example, I will apply `KNOCKBACK` to the item, but you
    should of course choose whichever enchantment you prefer. For a full list of enchantments
    and what they do, visit the API docs at [https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html)
    or the Minecraft Wiki at [http://minecraft.gamepedia.com/Enchanting#Enchantments](http://minecraft.gamepedia.com/Enchanting#Enchantments).
    Bukkit does warn us that using an unsafe method can cause problems. To avoid conflicts,
    try to keep the enchantment levels at 10 or below. With most enchantments, you
    will not even notice a difference after level 10\. We have decided that we will
    use `addUnsafeEnchantment(Enchantment ench, int level)`. This method takes an
    `Enchantment` and an `int` value as parameters. This `int` value is of course
    the enchantment''s level, as stated in the API documentation. We have decided
    what we want each of these parameters to be. We can complete the line of code,
    as shown in the following piece of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从个人经验来看，我发现`KNOCKBACK`附魔相当有趣。在我的例子中，我将`KNOCKBACK`应用到物品上，但你当然可以选择你喜欢的任何附魔。关于附魔的完整列表及其功能，请访问API文档[https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html)或Minecraft维基[http://minecraft.gamepedia.com/Enchanting#Enchantments](http://minecraft.gamepedia.com/Enchanting#Enchantments)。Bukkit警告我们，使用不安全的方法可能会引起问题。为了避免冲突，尽量将附魔等级保持在10级或以下。对于大多数附魔，在10级之后你甚至可能不会注意到任何区别。我们决定使用`addUnsafeEnchantment(Enchantment
    ench, int level)`。此方法接受一个`Enchantment`和一个`int`值作为参数。这个`int`值当然是附魔的等级，正如API文档中所述。我们已经决定了每个参数应该是什么。我们可以完成以下代码行，如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For added fun, we will add the `FIRE_ASPECT` enchantment as well, as shown
    in the following piece of code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加乐趣，我们还将添加`FIRE_ASPECT`附魔，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, everything will be executed successfully. Before we return `true`,
    we should send a message to the player to let them know that everything worked
    as planned. We will use the `sendMessage` method to send the message to only this
    player by using the following line of code. No one else on the server, including
    the console, will see the message:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，一切都将成功执行。在我们返回`true`之前，我们应该向玩家发送一条消息，让他们知道一切按计划进行。我们将使用`sendMessage`方法通过以下代码行只向这位玩家发送消息。服务器上的其他人，包括控制台，将看不到这条消息：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The completed class is shown in the following lines of code. Remember to comment
    your code as you type it. Some of the comments in the following code may seem
    unnecessary, as the code is easy enough to read. We will refer to this code by
    the term self-documentation. You only need to leave comments for the code that
    may be difficult to understand in the future or which may need clarification.
    While you are still learning, I encourage you to overuse comments. They won''t
    hurt anything by being present, and they will clearly explain the code for you
    in case you need it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的类在以下代码行中显示。记住在编写代码时注释你的代码。以下代码中的某些注释可能看起来不必要，因为代码本身很容易阅读。我们将用术语自文档化来引用此代码。你只需要为可能在未来难以理解或需要澄清的代码留下注释。在你仍在学习的时候，我鼓励你过度使用注释。它们的存在不会造成任何伤害，并且在你需要时可以清楚地解释代码：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code implements the enchant command. It verifies that the command
    sender is a player and that the player is holding an item. It then adds defined
    enchantments to the item. This concludes the work that needed to be done in the
    `EnchantCommand` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码实现了enchant命令。它验证命令发送者是一个玩家，并且该玩家正在持有物品。然后它将定义的附魔添加到物品上。这完成了在`EnchantCommand`类中需要完成的工作。
- en: Assigning the executor for the enchant command
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配enchant命令的执行者
- en: We are almost ready to start using the command on the server. The only remaining
    step is to assign the class that we just wrote to the `enchant` command. This
    is typically referred to as registering a command. In the `onEnable` method of
    the `Enchanter` class, we will get the `enchant` command using the `getCommand("enchant")`
    code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好开始在服务器上使用这个命令了。唯一剩下的步骤是将我们刚刚编写的类分配给`enchant`命令。这通常被称为注册命令。在`Enchanter`类的`onEnable`方法中，我们将使用`getCommand("enchant")`代码获取`enchant`命令。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The name of the command must be exactly as it is in `plugin.yml`. This also
    means that this code will only retrieve commands that are specific to this plugin.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的名称必须与`plugin.yml`中的完全一致。这也意味着这段代码只会检索特定于该插件的所有命令。
- en: 'Once we have the enchant command, we can set a new instance of `EnchantCommand`
    as the executor for the command. All of this can be done in one line, as shown
    in the following piece of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了附魔命令，我们就可以设置一个新的`EnchantCommand`实例作为该命令的执行者。所有这些都可以在一行中完成，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All that you will have in the `main` class is shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`类中您将拥有的所有内容如下所示：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now have a useful plugin to play with on your own server. You can build
    this plugin, as discussed in the previous chapter, and put it on your server to
    test. Try it with different items and observe how it works. There are many plugins
    that can be created and which solely function by using commands. With this knowledge,
    you have the potential to create numerous plugins. You can try a few plugins,
    like a plugin that teleports you to the spawn location of the world using `/spawn`,
    a plugin that plays the Creeper Hiss sound to a specific player using `/scare
    <player>`, and a plugin that strikes a player with lightning using `/strike <player>`
    by yourself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个可以在自己的服务器上使用的有用插件。您可以像前一章讨论的那样构建这个插件，并将其放在您的服务器上进行测试。尝试使用不同的物品，并观察它是如何工作的。可以创建许多仅通过使用命令来运行的插件。有了这些知识，您有潜力创建大量的插件。您可以尝试一些插件，比如使用`/spawn`命令将您传送到世界的出生点的插件，一个使用`/scare
    <player>`命令向特定玩家播放Creepers嘶嘶声的插件，以及一个使用`/strike <player>`命令用闪电击中玩家的插件，您自己也可以尝试。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is a `strikeLightning` method within the `World` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`World`类中有一个名为`strikeLightning`的方法。'
- en: For the plugin, you will have to use arguments. First, you will need to check
    whether you were given the correct number of arguments. Then, you will have to
    get the first argument, as explained earlier in this chapter. This argument will
    be the name of a player. There is a method in the `Bukkit` class to find a player
    with a given name.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插件，您将需要使用参数。首先，您需要检查是否给出了正确的参数数量。然后，您需要获取第一个参数，正如本章前面所解释的那样。这个参数将是玩家的名称。`Bukkit`类中有一个方法可以用来根据给定的名称查找玩家。
- en: If you are ever searching for a plugin idea, remember that the API documentation
    is a great source of inspiration. Also, people are always looking for plugins
    to be made on the Bukkit, Spigot, and Minecraft forums. In the next chapter, we
    will expand on the `Enchanter` plugin by adding permissions to it. This will ensure
    that only privileged players will be able to enchant items using the `enchant`
    command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找插件灵感，请记住API文档是一个很好的灵感来源。此外，人们总是在Bukkit、Spigot和Minecraft论坛上寻找要制作的插件。在下一章中，我们将通过添加权限来扩展`Enchanter`插件。这将确保只有特权玩家才能使用`enchant`命令对物品进行附魔。
