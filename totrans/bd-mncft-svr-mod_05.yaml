- en: Chapter 5. Plugin Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nice thing about the Bukkit API is that it has the basic features already
    built into its framework. As programmers, we need not go out of our way to implement
    these basic features into plugins. In this chapter, we will discuss one of these
    features, namely the in-game commands that can be executed by a player. These
    are similar to the commands that you are already familiar with, such as `/reload`,
    `/gamemode`, or `/give`. We will create a plugin that will *enchant* an item.
    By the end of this chapter, once the plugin is complete, you will be able to type
    `/enchant` to add your favorite enchantments to the item in your hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are one of the easiest ways for players to communicate with a plugin.
    They also allow players to trigger the execution of a plugin''s code. For these
    reasons, most plugins will have some sort of command. The Bukkit development team
    realized this and provided us with a simple way to register commands. Registering
    commands through Bukkit ensures that a plugin will know when a player types a
    command. It also prevents a plugin from having conflicts with another plugin''s
    commands. The following are the three steps that we will cover to add a command
    to a plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: Informing Bukkit that a plugin will be using a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming what a plugin will do when someone types a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning newly written code to a specific command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a command to plugin.yml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Bukkit plugin as you did in [Chapter 3](part0026_split_000.html#OPEK1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 3. Creating Your First Bukkit Plugin"), *Creating Your First Bukkit Plugin*,
    but name it `Enchanter`. Alternatively, you can create a copy of your existing
    project and modify the name, package, and so on in order to create a new plugin.
    This will eliminate the need to add the required libraries and configure the build
    script. A project can be copied by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project that you wish to copy and select **Copy…** from the
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the project name. The project location should remain unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `build.xml`, as discussed in [Chapter 4](part0033_split_000.html#VF2I1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 4. Testing on the Spigot Server"), *Testing on the Spigot Server*, and
    change the project's name to match what was set in step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the package in your new project so that it is unique by right-clicking
    on the package and selecting **Rename…** in the **Refactor** menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the main class, if necessary. You can also remove the methods or classes
    that you know will not be reused.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, modify the `plugin.yml` file with the new plugin information, including
    name, main, version, and description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will inform Bukkit that we will use a command by modifying the `plugin.yml`
    file of the plugin. As mentioned in [Chapter 2](part0020_split_000.html#J2B81-b66e70deee6e4ed481db4b113e303f23
    "Chapter 2. Learning the Bukkit API"), *Learning the Bukkit API*, Spigot reads
    the YAML file in order to find out necessary information about the plugin. This
    information includes all the commands that your plugin will handle. Each command
    can have a description, a proper usage message, and aliases, which is similar
    to how `rl` is an alias for `reload`. The command that we will use for the plugin
    will be `enchant`. It is typical to use lowercase letters for commands so that
    players do not have to worry about capitalization when typing the in-game command.
    The following code is a sample of how `plugin.yml` will appear after the `enchant`
    command is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note how the lines are indented. This indentation must be spaces and not tabs.
    NetBeans helps us automatically indent the necessary lines as you type them. In
    addition to this, NetBeans will automatically use spaces even if you use the *Tab*
    key. Indentation is very important in YAML files as this determines the hierarchy
    of keys. The `enchant command` is indented under `commands` to indicate that it
    is a command for the plugin. The `aliases`, `description`, and `usage` commands
    are indented under `enchant` to indicate that they belong to the `enchant` command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order of these three settings does not matter and they are optional.
  prefs: []
  type: TYPE_NORMAL
- en: The usage message will be displayed in case an error occurs or a player uses
    a command incorrectly. The description message can be viewed by issuing the help
    command for the plugin, that is, `/help Enchanter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `aliases`, we have `e` as a value. This means that we can type `/e` if
    we feel that `/enchant` is too long to type. You may have more aliases, but they
    must be put in a YAML list format. Lists in a YAML file can be created in two
    different ways. The first format involves separating each item by a comma and
    a space and enclosing the entire list in square brackets, as shown in the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second format involves placing each item on a new line, which starts with
    a hyphen and a space, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preferred method is usually determined by the length of the list. The second
    format is easier to read when lists are long. However, be careful not to have
    extra or missing spaces before the hyphen, as it will cause problems when a program
    tries to read the list. In general, ensure that your lists line up. For more information
    about the YAML language, visit [http://www.yaml.org/spec/1.2/spec.html](http://www.yaml.org/spec/1.2/spec.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple commands can be easily added to a plugin. The following code is an
    example of `plugin.yml` with several commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Programming the command actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have added the command to the `plugin.yml` file, you can begin working
    on the code that the command will trigger. Create a new class in the NetBeans
    project. This new class will be called `EnchantCommand`. You can name the class
    something else if you wish, but keep in mind that the name of a class should give
    you an idea of how the class is used without you having to open it. Place this
    class in the same package as that of `Enchanter`, the main plugin class, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Programming the command actions](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that though the packages are structured similarly, you will use
    your own unique namespace, not `com.codisimus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new class will execute the `enchant` command. Thus, it must implement
    the `CommandExecutor` interface. We will append code to the class header to do
    this. This is similar to adding `extends JavaPlugin` to the `Enchanter` class.
    `JavaPlugin` is a class. Therefore, we extended it with our class. `CommandExecutor`
    is an interface, which means that we must implement it. Once we add `implements
    CommandExecutor` to the class header of `EnchantCommand`, a light bulb will appear
    to notify us of the need to import the `CommandExecutor` class. Import the class,
    and the light bulb will still be there. It is now informing us that because we
    implemented an interface, we must implement all of its abstract methods. Click
    on the light bulb to do so, and the method that we need appears. This new method
    will be called when a player executes the `enchant` command. The method provides
    us with the following four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CommandSender sender`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command can be named `cs` by default, but we will name it `sender` because
    it is easy to forget what `cs` stands for
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is who sent the command
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be a player, the console, a command block, or even a custom `CommandSender`
    interface that was created by another plugin
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command cmnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the `Command` object that the sender executes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not need this as this class will be used for only a single command
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String alias`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is which alias the sender typed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, it might be `enchant`, `e`, `addenchant`, or `powerup`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String[] args`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an array of strings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each string is an argument that the sender type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments follow the alias and are separated by a space
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The command itself is not considered as an argument
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if they type `/enchant knockback 5`, then `knockback` will be the
    first argument (`args[0]`) and `5` will be the second and final argument (`args[1]`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not need to worry about the arguments at this point, because the `enchant`
    command will not need any
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned before, there are different kinds of `CommandSenders`. The following
    image is an inheritance diagram for `CommandSender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Programming the command actions](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this diagram, you can see that `Player`, `ConsoleCommandSender`, and a couple
    of other classes are all subtypes of `CommandSender`. The purpose of the enchant
    command is to allow a player to enchant the item that they are holding. Therefore,
    a `CommandSender` object that isn''t a player will have no use for this command.
    In the `onCommand` method, the first code that we write will be to check whether
    a player has executed the command. If we do not perform this check, then the plugin
    will crash when a nonplayer attempts to issue the `enchant` command. We will check
    this by using an `if` statement and the `instanceof` keyword. The code for this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be translated to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if the command sender is a Player`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `if` statement will let us know if it was a player who sent the command.
    If the command sender is not a player, then we want to stop executing the code.
    We will do this by using the `return` keyword. However, the `return` type for
    this method is `boolean`. We must return a `boolean` value, which will tell Bukkit
    whether the usage message needs to be shown to the command sender. Typically,
    for the `onCommand` method, you want to return `false` if the command is not executed
    successfully. In this case, it was not. Therefore, we will use the `return false;`
    code. So far, inside the method, we have constructed the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not quite right. This asks Bukkit to return `false` if the
    command sender is a player, but we want to return `false` when the opposite is
    the case. We can accomplish this by adding an exclamation point. If you don''t
    already know, in Java, an exclamation point is a `NOT` operator and can be used
    to invert a `boolean` value. We will correct the previous code by inverting the
    resulting value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note the extra set of parentheses. This is very important. Parentheses allow
    expressions to be grouped together. We want to invert the `boolean` value that
    results from the `sender instanceof Player` code. Without the parentheses, we
    would be attempting to invert the sender object, which does not make sense. As
    a result of this, the code would not be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to this point, the `EnchantComand` class code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have taken care of the nonplayers, we are certain that the `CommandSender`
    object is a player. We will want to work with the `Player` object rather than
    the `CommandSender` object because the `Player` object will have a specific item
    in its hand. We can get the `Player` object by *casting* the `CommandSender` object
    to `Player`. By casting, we are telling Java that we know that the command sender
    is actually a `Player object` rather than a `ConsoleCommandSender object` or one
    of the other subtypes. Casting is done by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not already familiar with casting, I again suggest that you learn
    some of these programming concepts at [codisimus.com/learnjava](http://codisimus.com/learnjava).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the `Player object`, we need the item that they are holding.
    Looking at the Bukkit API documentation for the `Player` class, which is available
    at [https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html),
    you can see that there exists a `getItemInHand` method, which is inherited from
    `HumanEntity`. It will return an `ItemStack` class, which is exactly what we want.
    This is demonstrated in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before doing anything with this item, we have to ensure that there actually
    is an item to enchant. If the player runs the command when they have no item in
    their hand, we do not want the plugin to crash. We will check whether the value
    of `ItemStack class` is `null` and the type of the item is `AIR`. In either case,
    we will return `false`, as follows, because the command wasn''t executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we do not include the `null` check (hand == null) here in the code, we may
    encounter a `NullPointerExceptions error`, as discussed in *Testing on the Spigot
    Server*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a reference to the player and the item that they are holding. Our
    end goal is to enchant this item. Again, looking at the API documentation, we
    can find several methods to add enchantments to an `ItemStack class` at [https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html).
    Read through the descriptions to find out which one is right for us.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the methods are used to add multiple enchantments at once. We may want
    to add more than one enchantment, but to simplify the code, we will only add one
    at a time. The two remaining methods are `addEnchantment(Enchantment ench, int
    level)` and `addUnsafeEnchantment(Enchantment ench, int level)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The description for the unsafe method states that: *This method is unsafe and
    will ignore level restrictions or item type. Use at your own discretion.* This
    warning is provided because these unsafe enchantments have not been tested and
    could produce undesirable results. You shouldn''t let this deter you from using
    the method but you will want to test the enchantment before using it with friends
    to ensure that it doesn''t crash the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if we choose to go with `unsafe`, we can create powerful enchantments,
    such as a sharpness level of 10\. Without a plugin, a sword is limited to a sharpness
    of level 5\. With unsafe enchantments, we can also enchant items that were previously
    unenchantable, such as a fish with `KNOCKBACK` or `FIRE_ASPECT`. Now, you will
    start to discover all the fun and cool things that you can do with plugins and
    which could not be done with a vanilla game.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a personal experience, I found out that the `KNOCKBACK` enchantment is
    quite entertaining. In my example, I will apply `KNOCKBACK` to the item, but you
    should of course choose whichever enchantment you prefer. For a full list of enchantments
    and what they do, visit the API docs at [https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html](https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html)
    or the Minecraft Wiki at [http://minecraft.gamepedia.com/Enchanting#Enchantments](http://minecraft.gamepedia.com/Enchanting#Enchantments).
    Bukkit does warn us that using an unsafe method can cause problems. To avoid conflicts,
    try to keep the enchantment levels at 10 or below. With most enchantments, you
    will not even notice a difference after level 10\. We have decided that we will
    use `addUnsafeEnchantment(Enchantment ench, int level)`. This method takes an
    `Enchantment` and an `int` value as parameters. This `int` value is of course
    the enchantment''s level, as stated in the API documentation. We have decided
    what we want each of these parameters to be. We can complete the line of code,
    as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For added fun, we will add the `FIRE_ASPECT` enchantment as well, as shown
    in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, everything will be executed successfully. Before we return `true`,
    we should send a message to the player to let them know that everything worked
    as planned. We will use the `sendMessage` method to send the message to only this
    player by using the following line of code. No one else on the server, including
    the console, will see the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed class is shown in the following lines of code. Remember to comment
    your code as you type it. Some of the comments in the following code may seem
    unnecessary, as the code is easy enough to read. We will refer to this code by
    the term self-documentation. You only need to leave comments for the code that
    may be difficult to understand in the future or which may need clarification.
    While you are still learning, I encourage you to overuse comments. They won''t
    hurt anything by being present, and they will clearly explain the code for you
    in case you need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements the enchant command. It verifies that the command
    sender is a player and that the player is holding an item. It then adds defined
    enchantments to the item. This concludes the work that needed to be done in the
    `EnchantCommand` class.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the executor for the enchant command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost ready to start using the command on the server. The only remaining
    step is to assign the class that we just wrote to the `enchant` command. This
    is typically referred to as registering a command. In the `onEnable` method of
    the `Enchanter` class, we will get the `enchant` command using the `getCommand("enchant")`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of the command must be exactly as it is in `plugin.yml`. This also
    means that this code will only retrieve commands that are specific to this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the enchant command, we can set a new instance of `EnchantCommand`
    as the executor for the command. All of this can be done in one line, as shown
    in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All that you will have in the `main` class is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have a useful plugin to play with on your own server. You can build
    this plugin, as discussed in the previous chapter, and put it on your server to
    test. Try it with different items and observe how it works. There are many plugins
    that can be created and which solely function by using commands. With this knowledge,
    you have the potential to create numerous plugins. You can try a few plugins,
    like a plugin that teleports you to the spawn location of the world using `/spawn`,
    a plugin that plays the Creeper Hiss sound to a specific player using `/scare
    <player>`, and a plugin that strikes a player with lightning using `/strike <player>`
    by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a `strikeLightning` method within the `World` class.
  prefs: []
  type: TYPE_NORMAL
- en: For the plugin, you will have to use arguments. First, you will need to check
    whether you were given the correct number of arguments. Then, you will have to
    get the first argument, as explained earlier in this chapter. This argument will
    be the name of a player. There is a method in the `Bukkit` class to find a player
    with a given name.
  prefs: []
  type: TYPE_NORMAL
- en: If you are ever searching for a plugin idea, remember that the API documentation
    is a great source of inspiration. Also, people are always looking for plugins
    to be made on the Bukkit, Spigot, and Minecraft forums. In the next chapter, we
    will expand on the `Enchanter` plugin by adding permissions to it. This will ensure
    that only privileged players will be able to enchant items using the `enchant`
    command.
  prefs: []
  type: TYPE_NORMAL
