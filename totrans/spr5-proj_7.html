<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Task Management System Using Spring and Kotlin</h1>
                </header>
            
            <article>
                
<p><span>In the chapters so far, we have explored various topics and concepts in depth. Starting with the pure Spring Framework and moving onto Spring Boot, we learned how quickly and easily we can create an enterprise-grade application with Spring Boot. </span></p>
<p>We also learned about the integration of the Spring Framework with other tools and technologies, such as Elasticsearch, LDAP, and OAuth, within the purview of the Spring Boot context. We then learned a new way of creating an application with Spring as a backend and Angular as a frontend with a tool called <strong>JHipster</strong>.</p>
<p>Then, we discovered how to create an application with modern architecture in the dimension of the distributed environment called <strong>microservice</strong>. In this chapter, we go further and explore a completely different dimension of the Spring Framework, looking at how it is supported by a new programming language called <strong>Kotlin</strong>.</p>
<p>As a programming language, Kotlin has quickly become popular among developers and companies. <span>The first stable version of Kotlin was released officially in 2016. The very next year Google officially declared Kotlin as a supported language for mobile development on an Android platform. This greatly increased the popularity and adoption rate of Kotlin.</span></p>
<p>Starting with version 5, Spring announced support for Kotlin to develop enterprise applications on a Spring Framework. In this chapter, we will explore how to develop a Spring-based application with Kotlin. We will build an application called Task Management with Spring Boot and Kotlin, and will cover the following:</p>
<ul>
<li>Introduction to Kotlin </li>
<li>Basic features of Kotlin as a programming language</li>
<li>Kotlin versus Java</li>
<li>Spring support for Kotlin</li>
<li>Developing a Task Management application in Spring with Kotlin</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07</a>. The code can be executed on any operating system, although it has only been tested on Windows.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Kotlin </h1>
                </header>
            
            <article>
                
<p>Kotlin is a language for <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) and hence can be used in place of Java. Be it server side, mobile, or web, you can use Kotlin everywhere Java is used at present. It is sponsored by a company called <strong>JetBrains</strong>; it is open source, and you can download the source code from GitHub (<a href="https://github.com/jetbrains/kotlin">https://github.com/jetbrains/kotlin</a>). They plan to roll out Kotlin for embedded and iOS platforms in the near future.</p>
<p>Kotlin provides good support as a functional programming language. The term functional programming is used to describe a declarative paradigm where the program is created by an expression or declaration rather than by the execution of commands. The functional programming model inherently brings certain qualities to the application, such as more compressed and predicted code, easy testing ability, reusability, and so on. Kotlin brings a functional paradigm in the form of inbuilt features. </p>
<p>There are many similarities between Java and Kotlin, and so the question arises, why do we need another programming language when Java has been widely used and very popular for more than two decades. The answer lies in some of the cool features Kotlin has, which make it the better choice for developing JVM-based applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interoperability </h1>
                </header>
            
            <article>
                
<p>One of the most promising features of Kotlin is its interoperable capabilities. Kotlin is 100% interoperable with Java. The <span>application can combine both the languages. The call to Java libraries can be made from Kotlin without any conversion or fuss. Similarly, code written in Kotlin can also be called from Java with ease. </span>This greatly helps Java developers to migrate from Java to Kotlin without any difficulty. </p>
<p>Migrating a code from one programming language to another is a quite tedious and time-consuming task, especially when those programming languages are incompatible, in terms of rules, syntax, features, and so on. Although there are a bunch of features available in Kotlin that are not present directly or indirectly in Java, it is the interoperability of Kotlin that allows running the code with both programming languages simultaneously. You do not have to migrate all Java code to Kotlin. Kotlin's <strong>Interoperability</strong> is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e3cc5dc9-95a7-4c99-a716-6a793669cb62.png" style="width:27.83em;height:20.67em;"/></p>
<p>On top of this, the Kotlin standard library is dependent on the Java Class Library, which enables reusing the dependencies, and no code refactoring is required in any of the places. For example: Kotlin's collection framework is built on top of Java's collection API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concise yet powerful </h1>
                </header>
            
            <article>
                
<p>While working with Kotlin, you will find another good quality is how concise it is. The Kotlin syntax is easy to read and interpret even without prior knowledge of any programming language. Kotlin has certain features that make it a truly concise language, such as type interface, data classes, properties, smart casts, and a lot more. <span>We will see more detail about each of them later in this chapter. </span></p>
<p>With these features, the code written with Kotlin is compact without losing its capabilities. Kotlin is more concise than Java in many aspects, and because of this we can implement the same functionality with fewer lines of code. This greatly improves legibility and ease of use. Developers can easily read, code, and update the program, even when it has been written by others. </p>
<p>Furthermore, Kotlin enables the speeding up of day-to-day development tasks with various features such as default parameters, <span>extension functions, and </span>object declarations. Your code is more compact and yet robust, without raising any maintainability concerns. This will reduce the possibility of bugs in the system.</p>
<p>Kotlin evolved as an enhancement to Java rather than as a completely new language. So the skills and knowledge you have with Java can be applied to Kotlin, making it an easy language to learn.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Safety feature</h1>
                </header>
            
            <article>
                
<div class="titlepage">
<p>Another reason you will love Kotlin is its safety feature. The code written in Kotlin is far safer than that written in Java. Kotlin is designed in a way to shield it from the common programming flaws, which results in a more stable system with fewer crashes and failures.</p>
<p>For any programming language that allows the null reference will create a runtime exception, such as <kbd>NullPointerException</kbd> , during the execution of the application. Improper handling of such a scenario may result in an abrupt system collision. If you have prior experience of Java, you might have experienced such scenarios. </p>
<p>Kotlin was designed with this in mind and defines the reference types in two categories: those that are nullable and those that are not. By default, Kotlin does not allow the reference with the null value and forces the developer to handle them in a specific manner. This greatly reduces the possibility of problems caused by <kbd>NullPointerException</kbd>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IDE Support</h1>
                </header>
            
            <article>
                
<div class="titlepage">
<p><strong>JetBrains</strong>, the company behind Kotlin, is well known for its <strong>i</strong><span><strong>ntegrated development environment (IDE)</strong></span> called <strong>IntelliJ IDEA</strong>, and<strong> </strong>obviously has first-class support for Kotlin. As far as the IDE is concerned, Eclipse is also one of the most favored among Java developers, and so JetBrains also offers a Kotlin <span>plugin for Eclipse. </span></p>
<p>In the very early days when Java had just evolved, there was no IDE in the initial stage and developers had to use text editors to do coding. It was difficult working without the safety and convenience of an IDE. When Eclipse came onto the market, developers quickly adopted it and since then it has become popular and widely accepted among Java developers.</p>
<p>Kotlin, on the other hand, was lucky enough to get IDE support from day one. This quickly boosted the popularity of Kotlin. It was really convenient and easy to learn. Developers were able to produce good quality code quickly, improving the software development life cycle. </p>
</div>
<p>Needless to say, Kotlin allows coding with text editors. Also, you can use Command Prompt to build Kotlin applications. Additionally, if you are an Android developer, it has its own IDE called <strong>Android Studio</strong> developed on top of IntelliJ IDEA IDE.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kotlin features</h1>
                </header>
            
            <article>
                
<p>Kotlin was designed not to compete with Java, but rather to be a good JVM language with added features not present in Java. Kotlin, as a language, has lots of new and exciting features, compared to Java, that increase code readability and maintainability.</p>
<p>It is vital to understand the basic features of Kotlin. In this section, we will explore a few of them that are essential for building an application in Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The concept of a function</h1>
                </header>
            
            <article>
                
<p>By definition, a function is a set or group of related statements that perform a specific task. It is a basic building block of any program. You can equate the function in Kotlin with the method in Java; however, there are certain differences. The function in Kotlin can be defined at the top level, meaning it is not required to be enclosed in a class. The function can be part of a class as well as defined within another function.</p>
<p>In Kotlin, the functions get first-class support, meaning it supports all the operations and can be stored into a variable and data structure, passed as an argument to other function as well <span>as being returned from other (top-level) functions, it</span> can be defined as an expression, and lots more. All these features bring a great amount of flexibility and make Kotlin really concise. We will see the following uses of functions in Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function as an expression</h1>
                </header>
            
            <article>
                
<p>While writing the function, you need to put the code in a function body. However, in Kotlin, you can define a function as an expression. For example: you want to find the minimum between two numbers and you wrote a function called<span> </span><kbd>min()</kbd><span> </span>as follows: </p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>print</span>(<span>min</span>(<span>4</span><span>,</span><span>7</span>))<br/>}<br/><span>fun </span><span>min</span>(numberA: Int<span>, </span>numberB:Int) : Int {<br/>    <span>if</span>(numberA &lt; numberB){<br/>        <span>return </span>numberA<br/>    }<span>else</span>{<br/>        <span>return </span>numberB<br/>    }<br/>}</pre>
<p>This will return the minimum number out of two given numbers. This function can be written as an expression style as follows:</p>
<pre><span>fun </span><span>min</span>(numberA: Int<span>, </span>numberB:Int) : Int = <span>if</span>(numberA &lt; numberB){ numberA }<span>else</span>{ numberB }</pre>
<p>This is how the code looks expressive and compact. Also, notice that we have removed the <kbd>return</kbd> keyword, as Kotlin is smart enough to return the last value without explicitly specifying the <kbd>return</kbd> keyword. This is what is called a <strong>single line</strong> or <strong>one line</strong> function. However, for a complex function, you can write it in multiple lines as follows:</p>
<pre><span>fun </span><span>min</span>(numberA: Int<span>, </span>numberB:Int) : Int<br/>   =  <span>if</span>(numberA &lt; numberB){<br/>            numberA<br/>        }<span>else</span>{<br/>            numberB<br/>        }</pre>
<p>This looks more compact and expressive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default function arguments</h1>
                </header>
            
            <article>
                
<p>Often, the amount of data that we supply to functions or constructors varies in different use cases. The system should be flexible enough to produce the desired result even if we don't provide the values of all the parameters. </p>
<p>If you want to achieve this in Java, you need to write a couple of overloaded functions or constructors as per your need. You will end up writing the same method multiple times with a different set of input parameters and calling other constructors or methods with default values. This quickly results in verbose code—writing code again and again for the same thing. </p>
<p>Kotlin provides an intuitive solution to this scenario with the feature called the default function argument. This is as simple as it sounds. You need to define a default value to those function arguments that you feel may not be provided with the value at the time of executing the function.</p>
<p>For example: let's say we wrote the function to find the volume of the cube as follows:</p>
<pre><span>fun </span><span>getVolume</span>(length:Int<span>, </span>width:Int<span>,</span>height:Int):Int{<br/>    <span>return </span>length * width * height<span>;<br/></span>}</pre>
<p>While calling this function, you need to pass all three parameters or else the compiler will signal the error. Now, assume that we want the system to take the default height as<span> </span><kbd>10</kbd><span> </span>if it is not provided explicitly. It can be written as follows: </p>
<pre><span>fun </span><span>getVolume</span>(length:Int<span>, </span>width:Int<span>,</span>height:Int =<span>10</span>):Int{<br/>    <span>return </span>length * width * height<span>;<br/></span>}</pre>
<p>This function can be called as<span> </span><kbd>getVolume(2,4)</kbd><span> </span>and<span> </span><kbd>10</kbd><span> </span>will be substituted as a default value to <kbd>height</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extension functions</h1>
                </header>
            
            <article>
                
<p>If you need to extend a class with a set of new functionalities, you need to update the Java source code. However, if you are using third-party libraries, you may not have the source. A class needs to be extended to accommodate other functions. You also can use various design patterns such as decorator and strategy for this purpose.</p>
<p>However, Kotlin allows the straightforward adding of extra functions to an existing class with the feature called an<span> <strong>e</strong></span><strong>xtension function</strong>. As its name implies, an<span> e</span>xtension function extends the functionality of the class without touching its source code. In other words, you are no longer required to inherit the class to be extended. This sounds really interesting. It behaves just like other member functions but is declared outside of the class.</p>
<p>Assume that you need to convert the given string into camel case. The Kotlin<span> </span><kbd>String</kbd><span> </span>class does not provide the functionality to convert a given string into camel case out of the box. We will the use<span> e</span>xtension function<span> </span>to define a separate function that, will actually do this job as follows:</p>
<pre><span>fun </span>String.<span>camelCase</span>():String{<br/>    <span>var </span>camelCaseStr = StringBuffer()<br/>    <span>var </span>wordLst : List&lt;String&gt; = <span>this</span>.<span>trim</span>().<span>split</span>(<span>" "</span>)<br/>    <span>for</span>(word <span>in </span>wordLst){<br/>        camelCaseStr.append(word.<span>replaceFirst</span>(word[<span>0</span>]<span>, </span>word[<span>0</span>].<span>toUpperCase</span>())).append(<span>" "</span>)<br/>    }<br/>    <span>return </span>camelCaseStr.<span>trim</span>().toString()<br/>}</pre>
<p>The<span> </span><kbd>camelCase()</kbd><span> function </span>is the<span> e</span>xtension function<span> </span>on the <kbd>String</kbd> class, which returns the<span> s</span>tring. The custom logic resides in the body of this function. You can call the<span> </span><kbd>camelCase()</kbd><span> </span>function on any string literal as follows:</p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>print</span>(<span>"this is just for sample"</span>.<span>camelCase</span>())<br/> // This will print as—This Is Just For Sample<br/>}</pre>
<p>The <kbd>camelCase()</kbd><span> function </span>is our custom function so you can use any other name you feel appropriate. Let's see one more example of<span> an </span>extension function. Suppose you want to find the square of a given integer. Again, Kotlin does not provide a direct function for that but we can write<span> the e</span>xtension function<span> </span>as follows: </p>
<pre><span>fun </span>Int.<span>square</span>():Int{<br/>    <span>return this </span>* <span>this<br/></span>}</pre>
<p>The<span> </span><kbd>square()</kbd><span> extension function </span>can be called in an integer literal as follows: </p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/><span>    </span><span>print</span>(<span>3</span>.<span>square</span>())<br/>}</pre>
<p>This is an extraordinary feature that we can use to extend functionalities without updating the code or inheriting the base class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda expression or function literal</h1>
                </header>
            
            <article>
                
<p>Every programming language has a provision for defining the literals, such as string, integer, double, and so on. They can be defined in a specific manner such as string literal as <kbd>Hello</kbd>, double literal as <kbd>34.23</kbd>, and so on. Kotlin allows us to define a function as a literal by enclosing the code in braces as follows:</p>
<pre><span>//This is functional literal<br/></span><span>{ </span><span>println</span>(<span>" This is function literal "</span>)<span>}</span></pre>
<p>This function can be declared in a normal way as follows: </p>
<pre><span>fun </span><span>printMsg</span>(message:String){<br/>    <span>println</span>(message)<br/>}</pre>
<p><span>It is essentially the same thing as a function literal. But the functional literal looks pretty compact yet expressive. A f</span>unction literal can be assigned to a variable and called at a later point of the code as follows: </p>
<pre><span>//Functional literal assigned to variable<br/></span><span>var </span>greetingMsg = <span>{ </span><span>println</span>(<span>"Hello World ...!!!"</span>)<span>}<br/></span><span><br/></span><span>//Calling the function through literal<br/></span>greetingMsg()</pre>
<p>The function literal can be assigned to a variable as in the first line. Just like other functions, the function literal can be invoked with a variable (with parenthesis) as shown in the second line. There are certain characteristics of the function literal as follows:</p>
<ul>
<li>It represents the block or body of the function that does not have any name.</li>
<li><span>It</span> is not associated with or bound to any entity such as class, interface, or object, and hence an access modifier is not allowed.</li>
<li>Since it does not have a name, it is called <strong>anonymous.</strong></li>
<li><span>It</span> can be passed to other functions (mainly high-order functions) as an argument.</li>
<li><span>It</span> is generally surrounded by curly braces and without the <kbd>fun</kbd> keyword.</li>
<li>It is also known as a lambda expression.</li>
</ul>
<p>Kotlin also allows passing parameters to a function literal or lambda expression as follows:</p>
<pre><span>//Lambda with parameter<br/></span><span>var </span>showWarning = <span>{</span>message : String <span>-&gt; </span><span>println</span>(message)<span>}<br/></span><span><br/></span><span>//Calling Lambda expression with parameter<br/></span>showWarning(<span>" Warning 1 occurred ..!!!"</span>)<br/>showWarning(<span>" Warning 2 occurred ..!!!"</span>)</pre>
<p>The lambda expression is divided into two parts by an arrow (<kbd>-&gt;</kbd>). The left part is the parameter section, while the right part is the lambda or function body. Multiple parameters are allowed with comma-separated lists and without enclosing them in parentheses as follows:</p>
<pre><span>//Multiple parameters<br/></span><span>var </span>addition = <span>{ </span>num1: Int<span>, </span>num2: Int <span>-&gt;<br/></span><span>        </span><span>println</span>(<span>"sum of </span><span>$</span>num1<span> and </span><span>$</span>num2<span> is ..</span><span>${</span>num1+num2<span>}</span><span>"</span>)<br/>     <span>}<br/></span>addition(<span>3</span><span>, </span><span>5</span>)</pre>
<p>We can write this code in a slightly different way as follows:</p>
<pre><span>var </span>addition2 : (Int<span>,</span>Int)-&gt; Unit = <span>{ </span>num1<span>, </span>num2 <span>-&gt;<br/></span><span>    </span><span>println</span>(<span>"sum of </span><span>$</span>num1<span> and </span><span>$</span>num2<span> is ..</span><span>${</span>num1+num2<span>}</span><span>"</span>)<br/><span>}<br/></span>addition2(<span>3</span><span>, </span><span>5</span>) </pre>
<p>In this code, the declaration of a parameter is moved out from <span>the lambda expression. The <kbd>Unit</kbd> function in Kotlin is equivalent to <kbd>void</kbd> in Java. </span><span>This feature makes Kotlin a truly functional language. The function literal can also be the parameter of another function.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing lambda to another function</h1>
                </header>
            
            <article>
                
<p>Kotlin allows us to pass a function to other (higher-order) functions as a parameter, using the lambda expression. Such a function can accept as a parameter a lambda expression or an anonymous function. Before discussing this topic further, let us first understand what a function type is.</p>
<p><span>Kotlin is a statically typed language and the functions also need to have a type. It is called a <strong>function type</strong>. We will see a few examples of how to define them as follows:</span></p>
<ul>
<li><kbd>()-&gt;Int</kbd>: The function type that returns an integer <span>type</span> and takes no argument.</li>
<li><kbd>(Int)-&gt;Unit</kbd>: The function type that takes an integer parameter and returns nothing.</li>
<li><kbd>()-&gt;(Int)-&gt;String</kbd>: The function type that returns another function, which eventually returns a string. The latter function takes an integer as a parameter.</li>
</ul>
<p>Now, let's see how we can define a function type as an input parameter to the outer function. Consider a scenario where you are designing an application for a bank loan. You need to check the eligibility criteria and decide whether a loan is applicable. The function that does this job should look as follows:</p>
<pre><span>data class </span>Applicant(<br/>                    <span>var </span><span>applicantId</span>: Int<span>,<br/></span><span>                    var </span><span>name</span>: String<span>,<br/></span><span>                    var </span><span>age</span>: Int<span>,<br/></span><span>                    var </span><span>gender</span>: String)<br/><br/><span>fun </span><span>isEligibleForLoan </span>(mobileNo:String<span>, </span>eligibilityScore:(applicantId:Int)-&gt;Double) : Boolean{<br/>    <span>//Business logic to fetch applicant details from given mobileNo<br/></span><span>    </span><span>var </span>applicant = Applicant(<span>12</span><span>,</span><span>"Nilang"</span><span>,</span><span>38</span><span>,</span><span>"M"</span>)<span>;<br/></span><span>    var </span>score = eligibilityScore(applicant.<span>applicantId</span>)<span>;<br/></span><span>    return </span>score &gt;<span>80<br/></span>}</pre>
<p>The <kbd>isEligibleForLoan()</kbd> <span>function </span>is a higher-order function that takes two parameters. The first parameter is the applicant's mobile number from which it will fetch the applicant's details. The second parameter is a function type, which we can consider as a sort of interface type. It simply calculates the eligibility score based on a given applicant ID. The actual implementation of the function type will be provided when the <span><kbd>isEligibleForLoan()</kbd> function is called as follows:</span></p>
<pre><span>var </span>isEligible = <span>isEligibleForLoan</span>(<span>"9998789671"</span><span>,</span><span>{<br/></span><span>     </span>applicantId <span>-&gt; </span><span>//Write logic to calculate the <br/>                   //eligibility of candidate and return the score<br/></span><span>     </span><span>85.23 // This is sample value<br/></span><span> </span><span>}</span>)<br/> <span>println</span>(<span>" isEligibile: </span><span>$</span>isEligible <span>"</span>)</pre>
<p>We need to pass a lambda expression in the second parameter. It is nothing but an anonymous function that takes the application ID as an input parameter and calculates an eligibility score. The score will be returned back to the <span><kbd>isEligibleForLoan()</kbd> function from where, </span><span>based on the score, we return whether a loan is applicable or not.</span></p>
<p>If the function type is the last parameter, then Kotlin allows to call it in a slightly different way. The preceding function can be called alternatively as follows:</p>
<pre><span>var </span>isEligible2 = <span>isEligibleForLoan</span>(<span>"9998789671"</span>)<span>{<br/></span><span>        </span>applicantId <span>-&gt; </span><span>//Write logic to calculate the eligibility <br/>                       //of candidate and return the score<br/></span><span>    </span><span>75.23 // This is sample value<br/></span><span>}</span></pre>
<p>In this way, the lambda expression is placed outside of the parenthesis, which is more expressive. But this is only possible when a function type is declared at the last parameter. Passing a lambda expression as a function type is useful, especially for an Ajax call where we want to update the page element once we get the data from the response without freezing the UI. The function that is injected through the lambda expression will work as a callback function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Returning a function from another function</h1>
                </header>
            
            <article>
                
<p>We have seen how function type can be defined as a parameter while calling another function. With the help of a lambda expression, it becomes even more straightforward. One step further, Kotlin allows the returning of a function from another function. Let's understand how that works.</p>
<p>Suppose we have one interface called <kbd>WildAnimal</kbd> that is implemented by three classes as follows:</p>
<pre><span>interface </span>WildAnimal{<br/>    <span>fun </span><span>setName</span>(name:String)<br/>    <span>fun </span><span>bark</span>():String<br/>}<br/><br/><span>class </span>Dog : WildAnimal{<br/>    <span>private var </span><span>dogName</span>: String = <span>""<br/></span><span>    </span><span>override fun </span><span>bark</span>(): String {<br/>        <span>print</span>(<span>" Bhao bhao ..."</span>)<br/>        <span>return </span><span>"</span><span>${</span><span>dogName</span><span>}</span><span> Dog is barking ..."<br/></span><span>    </span>}<br/>    <span>override fun </span><span>setName</span>(name: String) {<br/>        <span>this</span>.<span>dogName </span>= name<br/>    }<br/>}<br/><span>class </span>Fox : WildAnimal{<br/>    <span>private var </span><span>foxName</span>: String = <span>""<br/></span><span>    </span><span>override fun </span><span>bark</span>(): String {<br/>        <span>print</span>(<span>" Haaaaoooooo..."</span>)<br/>        <span>return </span><span>"</span><span>${</span><span>foxName</span><span>}</span><span> Fox is barking ..."<br/></span><span>    </span>}<br/>    <span>override fun </span><span>setName</span>(name: String) {<br/>        <span>this</span>.<span>foxName </span>= name<br/>    }<br/>}<br/><span>class </span>Lion : WildAnimal{<br/>    <span>private var </span><span>lionName</span>: String = <span>""<br/></span><span>    </span><span>override fun </span><span>bark</span>(): String {<br/>        <span>print</span>(<span>" HHHHHAAAAAAAAAAA..."</span>)<br/>        <span>return </span><span>"</span><span>${</span><span>lionName</span><span>}</span><span> Lion is Barking ..."<br/></span><span>    </span>}<br/>    <span>override fun </span><span>setName</span>(name: String) {<br/>        <span>this</span>.<span>lionName </span>= name<br/>    }<br/>}</pre>
<p>Each class implements two methods—<kbd>setName()</kbd> and <kbd>bark()</kbd> that will set the animal and show a barking voice respectively. We will create an instance of each of the class, set its name, and call the <kbd>bark()</kbd> function to print the barking voice and also print the name of the animal. To achieve this, we will write a function as follows:</p>
<pre><span>fun </span><span>getAnimalVoiceFun</span>(animal: WildAnimal):(String) -&gt; String{<br/>    <span>return </span><span>{<br/></span><span>        </span>animal.setName(<span>it</span>)<br/>        animal.bark()<br/>    <span>}<br/></span>}</pre>
<p>The <kbd>getAnimalVoiceFun</kbd> function takes the implementation of <kbd>WildAnimal</kbd> as a parameter and returns the function that takes <kbd>String</kbd> as a parameter and returns <kbd>String</kbd> as an output. The code written inside the <kbd>{ }</kbd> braces in the body of the <kbd>getAnimalVoiceFun</kbd> function denotes the function that is returning from it. The <kbd>it</kbd> parameter points to the <kbd>String</kbd> parameter of the enclosing function.</p>
<p>The <kbd>animal.bark()</kbd> function, which actually returns the string, will be ultimately returned from an enclosed function. This function can be written in a slightly different way as follows:</p>
<pre><span>fun getAnimalVoiceFun(animal: WildAnimal):(name:String) -&gt; String{<br/></span><span>    return {<br/></span><span>             animal.setName(</span>name=it<span>)<br/></span><span>             animal.bark()<br/></span><span>        }<br/></span><span>}</span></pre>
<p>The difference is we are declaring the name of the parameter—<kbd>name</kbd> of the type string and using it as a <kbd>name=it</kbd> expression in the enclosing function. In both of the previous ways, the parenthesis represents the function, so the <kbd>fun</kbd> keyword is silent. However, you can declare it as follows:</p>
<pre><span>fun getAnimalVoiceFun(animal: WildAnimal):(String) -&gt; String{<br/></span><span>  return <strong>fun</strong>(name:String):String {<br/></span><span>     animal.setName(name)<br/></span><span><strong>     return</strong> animal.bark()<br/></span><span>}</span></pre>
<p>In this way, we are explicitly using the <kbd>fun</kbd> keyword for enclosing function. Also, you have to explicitly mention the <kbd>return</kbd> keyword in the enclosing function. You can use either of these ways to declare the <kbd>getAnimalVoiceFun</kbd> function. You can call this function as follows:</p>
<pre><span>println</span>(<span>getAnimalVoiceFun</span>(Lion())(<span>"Jake"</span>))<br/><span>println</span>(<span>getAnimalVoiceFun</span>(Dog())(<span>"Boomer"</span>))<br/><span>println</span>(<span>getAnimalVoiceFun</span>(Fox())(<span>"Lilli"</span>))</pre>
<p>We are calling the <kbd>getAnimalVoiceFun</kbd> function with an instance of the respective class. You can see how the second string parameter included in separate parenthesis will be provided to a function defined within the function—<kbd>getAnimalVoiceFun</kbd>. You will get an output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e42631de-5550-4cfc-9cc8-32fdebc12724.png" style="width:28.42em;height:4.58em;"/></p>
<p>In Kotlin, the function can be defined as a type. We can use the function type to declare the preceding function as follows:</p>
<pre><span>val </span>getAnimalVoice: (WildAnimal) -&gt;(String)-&gt; String = <span>{<br/></span><span>        </span>animal:WildAnimal <span>-&gt; {<br/></span><span>               </span>animal.setName(<span>it</span>)<br/>               animal.bark()<br/>         <span>}<br/></span><span>}</span></pre>
<p>The <kbd>getAnimalVoice</kbd> variable is defined as a function type, which takes the <kbd>WildAnimal</kbd> <span>object </span>and returns another function, which takes <kbd>String</kbd> as an input parameter <span>(with the <kbd>it</kbd> keyword) </span>and returns a <kbd>String</kbd> output <span>(by calling <kbd>animal.bark()</kbd>)</span>. The lambda expression is used to define this function. This can be called as follows:</p>
<pre><span>println</span>(getAnimalVoice(Lion())(<span>"Lio"</span>))<br/><span>println</span>(getAnimalVoice(Dog())(<span>"Tommy"</span>))<br/><span>println</span>(getAnimalVoice(Fox())(<span>"Chiku"</span>))</pre>
<p>And the output would be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cca14107-1d57-453e-af30-9f17e0808088.png" style="width:30.42em;height:4.42em;"/></p>
<p>There may be other straightforward ways to set the animal name and print the barking voice. However, we have just seen how it can be possible by returning the function from another function. You can write some common logic that is applicable to multiple functions, and returning common code as a separate function would be an ideal scenario to use the function as a return type of another function. This is how flexible and concise Kotlin is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Null safety</h1>
                </header>
            
            <article>
                
<p>While working with Java, when the program executes and tries to access the variables set to null and then not initialized with a proper value, it will crash the system and produce the classic exception called <kbd>NullPointerException</kbd>.</p>
<p>As we know, Kotlin is a statically typed language so everything is defined as a type, including null values. The nullability is a type in Kotlin. By default, a Kotlin compiler does not allow a null value to any type. Generally, when we define variables, we set their values at the time of declaration. </p>
<p>But, in some exceptional cases, you don't want to initialize the variable at the time of declaration. In this case, while using those variables, the Kotlin compiler will raise the concern. For example: the following code will give an error signal in Kotlin:</p>
<pre><span>var </span>msg:String = <span>"Sample Message !!"<br/></span>msg = <span>null<br/></span><span>var </span>anotherMsg :String = <span>null</span></pre>
<p>The variable initialized with some value is not allowed to be reassigned with the null value. Also, any variable defined with type (<kbd>String</kbd> , in our case) is not allowed to initialize with null. The Kotlin compiler has this restriction to avoid <kbd>NullPointerException</kbd>, so it will catch this at compile time rather than causing a runtime error which results in an abrupt system collision. </p>
<p><span>Kotlin wants us to initialize the typed variable at the time of declaration. </span>As we said, there are situations where we have to initialize variables with null and Kotlin allows it in a different way, as follows: </p>
<pre><span>var </span>nullableMsg : String? = <span>" I have some value ..!! "<br/></span><span>println</span>(nullableMsg)<br/>nullableMsg=<span>null</span></pre>
<p>The nullable variable can be defined with a question mark with a type of variable <span>called a </span><strong>safe call operator</strong>. You can now assign null value. However, when we define a nullable variable and try to call its method, the compiler will show an error as follows: </p>
<pre><span>var </span>nullableMsg2 : String? = <span>" I have some value ..!! "<br/></span><span>println</span>(nullableMsg2.length) // Compiler will show an error here.</pre>
<p>The reason for this is Kotlin will not allow calling methods on a nullable type without either explicitly checking for null or calling the method in a safe way. The previous code can be rewritten to avoid a compilation error in the following ways: </p>
<pre><span>//Correct ways to call nullable variable<br/></span><span>if</span>(nullableMsg2 !=<span>null</span>){<br/>    <span>println</span>(<span>nullableMsg2</span>.<span>length</span>) <span>// Option 1<br/></span>}<br/><span>println</span>(nullableMsg2?.<span>length</span>) <span>// Option 2</span></pre>
<p>The <kbd>nullableMsg2?</kbd> method is the safe way to call a nullable variable. If the variable is null, Kotlin will silently bypass that call and return a null value. <span>This is a more concise way for a safe null check in Kotlin. </span>But if you want to make sure the value is returned, even if it is null, then you can use another approach as follows: </p>
<pre><span>println</span>(nullableMsg2?.<span>length </span>?: -<span>1</span>)</pre>
<p>The additional question mark and colon (<kbd>?:</kbd> ) is called the <strong>Elvis operator</strong>. It is basically similar to the if-else block and returns the length if not null. If it is null, then it will return <kbd>-1</kbd>. This is basically the short form of a ternary operator, such as <kbd>if(a) ? b : c</kbd> , but cleaner and more compact. This will prevent any accidental <kbd>NullPointerException</kbd> at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data classes</h1>
                </header>
            
            <article>
                
<p>You might have created a class that is a simple data container without specific business logic or functionality. Such a scenario happens while following the value object or the data transfer object pattern. Typically, such classes look as follows:</p>
<pre><span>// Java code<br/>public class </span>StudentVOJava {<br/>    <span>private </span>String <span>name</span><span>;<br/></span><span>    private int </span><span>age</span><span>;<br/></span><span>    private int </span><span>standard</span><span>;<br/></span><span>    private </span>String <span>gender</span><span>;<br/></span><span>    public </span><span>StudentVO</span>(String name<span>, int </span>age<span>, int </span>standard<span>, </span>String gender) {<br/>        <span>this</span>.<span>name </span>= name<span>;<br/></span><span>        this</span>.<span>age </span>= age<span>;<br/></span><span>        this</span>.<span>standard </span>= standard<span>;<br/></span><span>        this</span>.<span>gender </span>= gender<span>;<br/></span><span>    </span>}<br/>    <span>public </span>String <span>getName</span>() {<br/>        <span>return </span><span>name</span><span>;<br/></span><span>    </span>}<br/>    <span>public void </span><span>setName</span>(String name) {<br/>        <span>this</span>.<span>name </span>= name<span>;<br/></span><span>    </span>}<br/>    <span>public int </span><span>getAge</span>() {<br/>        <span>return </span><span>age</span><span>;<br/></span><span>    </span>}<br/>    <span>public void </span><span>setAge</span>(<span>int </span>age) {<br/>        <span>this</span>.<span>age </span>= age<span>;<br/></span><span>    </span>}<br/>    <span>public int </span><span>getStandard</span>() {<br/>        <span>return </span><span>standard</span><span>;<br/></span><span>    </span>}<br/>    <span>public void </span><span>setStandard</span>(<span>int </span>standard) {<br/>        <span>this</span>.<span>standard </span>= standard<span>;<br/></span><span>    </span>}<br/>    <span>public </span>String <span>getGender</span>() {<br/>        <span>return </span><span>gender</span><span>;<br/></span><span>    </span>}<br/>    <span>public void </span><span>setGender</span>(String gender) {<br/>        <span>this</span>.<span>gender </span>= gender<span>;<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public boolean </span><span>equals</span>(Object o) {<br/>        <span>if </span>(<span>this </span>== o) <span>return true;<br/></span><span>        if </span>(o == <span>null </span>|| getClass() != o.getClass()) <span>return false;<br/></span><span>        </span>StudentVO studentVO = (StudentVO) o<span>;<br/></span><span>        return </span><span>age </span>== studentVO.<span>age </span>&amp;&amp;<br/>                <span>standard </span>== studentVO.<span>standard </span>&amp;&amp;<br/>                Objects.<span>equals</span>(<span>name</span><span>, </span>studentVO.<span>name</span>) &amp;&amp;<br/>                Objects.<span>equals</span>(<span>gender</span><span>, </span>studentVO.<span>gender</span>)<span>;<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public int </span><span>hashCode</span>() {<br/>        <span>return </span>Objects.<span>hash</span>(<span>name</span><span>, </span><span>age</span><span>, </span><span>standard</span><span>, </span><span>gender</span>)<span>;<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public </span>String <span>toString</span>() {<br/>        <span>return </span><span>"StudentVO{" </span>+<br/>                <span>"name='" </span>+ <span>name </span>+ <span>'</span><span>\'</span><span>' </span>+ <span>", age=" </span>+ <span>age </span>+<br/>                <span>", standard=" </span>+ <span>standard </span>+<br/>                <span>", gender='" </span>+ <span>gender </span>+ <span>'</span><span>\'</span><span>' </span>+<br/>                <span>'}'</span><span>;<br/></span><span>    </span>}<br/>}</pre>
<p>There is nothing special in this class, just a few properties, getters, setters, constructor, and the implementation of <kbd>hashCode()</kbd>, <kbd>equals()</kbd>, and <kbd>toString()</kbd>. Lots of boilerplate code would really distract any business functionality. Due to this, the code becomes less readable, searchable, and verbose. </p>
<p>With the help of modern IDEs, it is just a matter of a few clicks to generate this code, but still it has a readability issue. The same code written in Kotlin is not only much cleaner on the first view but also helps with focusing on the important part out of the boring boilerplate stuff, as follows:</p>
<pre><span>data class </span>StudentVOKotlin(<span>var </span><span>name</span>: String<span>, </span><span>var </span><span>age</span>: Int<span>,<br/></span><span>                           var </span><span>standard</span>: Int<span>, </span><span>var </span><span>gender</span>: String)</pre>
<p>Everything is covered in just a single line of code, and it is also more readable. A declaration such as this will create setters, getters, constructor, and the implementation of the <kbd>toString()</kbd>, <kbd>hashCode()</kbd>, and <kbd>equals()</kbd> methods along with other useful functionalities behind the curtain by Kotlin. If you want to make your class immutable, just declare the properties with <kbd>val</kbd> instead of <kbd>var</kbd> as follows: </p>
<pre><span>data class </span>StudentVOKotlin(<span>val </span><span>name</span>: String<span>, </span><span>val </span><span>age</span>: Int<span>,<br/></span><span>                           val </span><span>standard</span>: Int<span>, </span><span>val </span><span>gender</span>: String)</pre>
<p>Immutable variables can be defined with <kbd>val</kbd> in Kotlin. You can now call only getters on the object of the <kbd>StudentVOKotlin</kbd> class. We can use this class as follows:</p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>var </span>student = StudentVOKotlin(<span>"Nilang"</span><span>,</span><span>10</span><span>,</span><span>5</span><span>,</span><span>"M"</span>)<br/>    <span>println</span>(<span>"Student is  </span><span>$</span>student<span>"</span>) // This will call toString()<br/>    //This will call getter of respective properties<br/>    <span>println</span>(<span>"age of </span><span>${</span>student.<span>name</span><span>}</span><span> is </span><span>${</span>student.<span>age</span><span>}</span><span>"</span>) <br/>}</pre>
<p>This really makes the code compact and readable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interoperability</h1>
                </header>
            
            <article>
                
<p>As we have seen, Kotlin is fully interoperable with Java so that you can write Java and Kotlin functions altogether in the same project and call them from each other. Let's understand how that magic happens. Before that, let's look at how things happen behind the scenes.</p>
<p>For example, you wrote a Kotlin function in the <kbd>CheckOperability.kt</kbd> file as follows: </p>
<pre><span>fun </span><span>greeting</span>(name: String){<br/>    <span>print</span>(<span>" Hello </span><span>$</span>name<span> !!!"</span>)<br/>}</pre>
<p>This code will be compiled by the Kotlin compiler and converted into byte code. The generated Java class file will be as follows:</p>
<pre>public final class CheckInterOperabilityKt<br/>{<br/>  public static final void greeting(@NotNull String name)<br/>  {<br/>    //Some code for null type check added by Kotlin at this place.<br/>    String str = " Hello " + name + " !!!";System.out.print(str);<br/>  }<br/>}</pre>
<p>As you can see, Kotlin converts the <kbd>.kt</kbd> file (<kbd>CheckInterOperabilityKt.class</kbd>) into a corresponding Java class. The <kbd>greeting()</kbd> function defined in Kotlin is also converted to a Java function. By default, all functions in Kotlin are static. Also, Kotlin is not forcing you to define a <kbd>void</kbd> in case there is no-return value. (Kotlin has <kbd>Unit</kbd> in place of <kbd>void</kbd> actually.) While converting, it will add <kbd>void</kbd> along with a <kbd>static</kbd> keyword to the function. </p>
<p>We will now see how we can call the Java code from Kotlin, and vice versa.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling the Kotlin code from Java</h1>
                </header>
            
            <article>
                
<p>Let's create a Kotlin function that simply does multiplication of two given numbers in the <kbd>KotlinFile.kt</kbd> file as follows:</p>
<pre><span>fun </span><span>multiply</span>(a:Int<span>, </span>b:Int):Int{<br/>    <span>print</span>(<span>"Calling multiply function From Kotlin...."</span>)<br/>    <span>return </span>a * b<br/>}</pre>
<p>We want to call a Kotlin <kbd>multiply()</kbd> <span>function </span>into a Java class. As we know, the Kotlin compiler processes this file into a Java class, where it defines the <kbd>multiply()</kbd> method as a static method of the <kbd>KotlinFileKt.class</kbd> generated class <span>file,</span> so that it can be accessible with the <kbd>KotlinFileKt.multiply()</kbd> expression.</p>
<div class="packt_infobox">In case you wish to change the Java class file name from the Kotlin source, you need to define it as <kbd>@file:JvmName("CustomKotlinFile")</kbd> in the Kotlin file. In this case, the Kotlin compiler will generate the <kbd>CustomKotlinFile.class</kbd> file and the function can be accessed with the <kbd>CustomKotlinFile.multiply()</kbd> call. </div>
<p>Let's first add the Java class and call the Kotlin function as follows: </p>
<pre><span>public class </span>JavaFile {<br/>    <span>public  static void  </span><span>main</span>(String args[]){<br/>        System.<span>out</span>.print(KotlinFileKt.<span>multiply</span>(<span>3</span><span>,</span><span>4</span>))<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>This is how the Kotlin function can be called from the Java class. Now let's see how to call a Java function from Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling Java code from Kotlin </h1>
                </header>
            
            <article>
                
<p>Let's define a function that simply does the addition of two numbers in a Java file as follows:</p>
<pre><span>public static int </span><span>add</span>(<span>int </span>num1<span>, int </span>num2){<br/>    <span>return </span>num1+num2<span>;<br/></span>}</pre>
<p>This can be called in the Kotlin file in a similar way to how we called the Kotlin code into Java. Since this is a static function, we can call it with the Java class in Kotlin as follows: </p>
<pre><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>var </span>total = JavaFile.add(<span>5</span><span>,</span><span>6</span>)<br/>    <span>print</span>(<span>"Value from Java is </span><span>$</span>total<span>"</span>)<br/>}</pre>
<p>The <kbd>main</kbd> function in Kotlin represents the execution point similar to <kbd>public static void main()</kbd> in Java.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Smart casts</h1>
                </header>
            
            <article>
                
<p>While working with Java, you may face the scenario where you need to cast the object before further processing. However, even if there is certainty about the type of object that you are passing, you still need to cast the object explicitly in Java as follows:</p>
<pre><span>//Java code<br/>public static void  </span><span>main</span>(String[] args){<br/>    Object name = <span>"Nilang"</span><span>;<br/></span><span>    if</span>(name <span>instanceof </span>String){<br/>        <span>greetingMsg</span>((String) name)<span>;<br/></span><span>    </span>}<br/>}<br/><span>private static void </span><span>greetingMsg</span>(String name){<br/>    System.<span>out</span>.print(<span>" Welcome "</span>+name+<span>" ..!!"</span>)<span>;<br/></span>}</pre>
<p>If we try to call <kbd>greetingMsg()</kbd> without an explicit cast, the Java compiler will show an error because the <kbd>name</kbd> variable is of the <kbd>Object</kbd> type. In this case, although the compiler knows that <kbd>name</kbd> can be only of the <kbd>String</kbd> type (through the condition <kbd>if(name instanceOf String)</kbd>), the Java compiler needs explicit casting. In other words, we need to perform casting, even though it is actually redundant. </p>
<p>However, in the case of Kotlin, you are not required to cast explicitly if a parameter is proven to be of a required type. This code can be written in Kotlin as follows:</p>
<pre><span>//Kotlin code<br/>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>val </span>name: Any = <span>"Nilang"<br/></span><span>    </span><span>if</span>(name <span>is </span>String) {<br/>        <span>greetingMsg</span>(<span>name</span>)<br/>    }<br/>}<br/><span>private fun </span><span>greetingMsg</span>(name: String) {<br/>    <span>print</span>(<span>" Welcome </span><span>$</span>name<span> ..!!"</span>)<br/>}</pre>
<p>The <kbd>Any</kbd> type in Kotlin is equivalent to <kbd>Object</kbd> in Java. In this code, the compiler knows that the input given to the <kbd>greetingMsg</kbd> function can only be of the <kbd>String</kbd> type (with the <kbd>if</kbd> condition) so an explicit cast is not required. This is called <strong>smart</strong> <strong>cast</strong> in Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operator overloading</h1>
                </header>
            
            <article>
                
<p>Operator overloading is another convenient feature of Kotlin, which makes it more expressive and readable. It allows you to use standard symbols such as <kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>, <kbd>/</kbd>, <kbd>%</kbd>, <kbd>&lt;</kbd>, <kbd>&gt;</kbd>, and so on, to perform various operations on any object. Under the hood, operator overloading initiates a function call to perform various mathematical operations, comparisons, indexing operations with arrays, and lots more. </p>
<p>The classes such as int, byte, short, long, double, float, and so on, have defined corresponding functions for each of these operators. For example: if we do <kbd>a+b</kbd> on an integer, Kotlin will call <kbd>a.plus(b)</kbd> internally as follows:</p>
<pre><span>var </span>num1 = <span>10<br/></span><span>var </span>num2 = <span>5<br/></span><span>println</span>(num1+num2)<br/><span>println</span>(num1.plus(num2))</pre>
<p>Both print statements show the same result. We can define how operators work for custom classes by overloading corresponding functions. For example, we have a class called <kbd>CoordinatePoint</kbd>, which represents the x and y coordinates for a given point in the graph. If we want to override the operators on this class, then it should be coded as follows:</p>
<pre><span>data class </span>CoordinatePoint(<span>var </span><span>xPoint</span>: Int<span>, var </span><span>yPoint</span>: Int){<br/>    <span>// overloading + operator with plus function<br/></span><span>    </span><span>operator fun </span><span>plus</span>(anotherPoint: CoordinatePoint) : CoordinatePoint {<br/>        <span>return </span>CoordinatePoint(<span>xPoint </span>+ anotherPoint.<span>xPoint</span><span>, </span><span>yPoint </span>+ anotherPoint.<span>yPoint</span>)<br/>    }<br/>    <span>// overloading - operator with minus function<br/></span><span>    </span><span>operator fun </span><span>minus</span>(anotherPoint: CoordinatePoint) : CoordinatePoint {<br/>        <span>return </span>CoordinatePoint(<span>xPoint </span>- anotherPoint.<span>xPoint</span><span>, </span><span>yPoint </span>- anotherPoint.<span>yPoint</span>)<br/>    }<br/>}<br/><span>fun </span><span>main</span>(args: Array&lt;String&gt;) {<br/>    <span>var </span>point1 = CoordinatePoint(<span>2</span><span>,</span><span>5</span>)<br/>    <span>var </span>point2 = CoordinatePoint(<span>4</span><span>,</span><span>3</span>)<br/><br/>    //This will call overloaded function plus()<br/>    <span>var </span>point3 = point1 + point2 <br/>    <br/>   //This will call overloaded function minus()<br/>    <span>var </span>point4 = point1 - point2<br/><br/>    <span>println</span>(point3)<br/>    <span>println</span>(point4)<br/>}</pre>
<p>The <kbd>CoordinatePoint</kbd> class is our custom class, and the <kbd>plus()</kbd> and <kbd>minus()</kbd> functions are actually called when the objects of this class are used along with the corresponding operators. The <kbd>operator</kbd> keyword is used to associate the corresponding function with the operators.</p>
<p>Apart from arithmetic, Kotlin supports other operators, such as <strong>index access</strong> operators, <strong>in</strong> operators, <strong>invoke</strong> operators, <strong>argument</strong> <strong>assignment</strong> operators, <strong>equal</strong> operators, <strong>function</strong> operators, and so on. With operator overloading, this code is more compact and concise and of course is clearer as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kotlin versus Java</h1>
                </header>
            
            <article>
                
<p>After going through the feature richness of Kotlin, it would be really helpful to compare it to Java. This is not to prove a particular language is more appropriate than the other, but rather to just list the differences to make the choice easier for different scenarios:</p>
<ul>
<li><strong>Null safety</strong>: Kotlin provides a nice way to define and handle nullable types, whereas Java does not have a similar feature out of the box.</li>
<li><strong>Extension function</strong>: Java needs an inheritance to extend the class, whereas Kotlin allows you to define the extension function without inheriting any class. You can define an extension function for custom classes as well.</li>
<li><strong>Type reference</strong>: In Java, we need to specify the type of variable explicitly, but Kotlin will handle it based on the assignment so you do not have to define the type in all the scenarios.</li>
<li><strong>Functional programming</strong>: Kotlin is a functional language and provides many useful features for functions. Java, on the other hand, has started supporting lambda expressions.</li>
<li><strong>Coroutine support</strong>: Coroutines are lightweight threads used to handle asynchronous, non-blocking code. Kotlin support coroutines out of the box. The Co-routines are managed by users. Java, on other hand, supports similar functionality with multithreads managed by the underlying OS.</li>
</ul>
<ul>
<li><strong>Data class</strong>: In Java, we need to declare constructors, getters, setters, <kbd>toString()</kbd>, <kbd>hashCode()</kbd>, and <kbd>equals()</kbd> manually, while Kotlin does all that behind the scene.</li>
<li><strong>Smart cast</strong>: Java needs to check for cast explicitly, while Kotlin does this job smartly. </li>
<li><strong>Checked exception</strong>: Java does support checked exceptions, whereas Kotlin does not support them.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring supports for Kotlin</h1>
                </header>
            
            <article>
                
<p>Due to its stunning features, Kotlin has rapidly grown in popularity, and many frameworks have started supporting it. The Spring Framework has allowed the development of Spring applications with Kotlin since version 5. Though Kotlin is fully interoperable with Java, you can write an application with pure and fully idiomatic Kotlin code. <span>The diverse range of Kotlin features enhances productivity and combines well with Spring for application development.</span></p>
<p>As we have seen, the extension function in Kotlin is a non-intrusive way of providing a better alternative to the utility class or creating a class hierarchy for adding new features. Spring has used this feature to apply new Kotlin specific capabilities to existing Spring APIs. It is mainly used for dependency management. <span>In the same way, Spring has also made framework APIs null safe to take full advantage of Kotlin.</span></p>
<p>Even Spring Boot has first-class Kotlin support, starting from version 2.x. This means you can write Spring-based applications in Kotlin as if Spring was a native framework of Kotlin. The current version of Kotlin released in October 2018 is 1.3, and Spring supports Kotlin 1.1 and higher. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing an application – Task Management System</h1>
                </header>
            
            <article>
                
<p>This chapter aims to create an application called <strong>Task Management System</strong> (<strong>TMS</strong>) with Spring Boot and Kotlin. In previous chapters, we created various applications in Java. In this section, we will learn how to develop Spring-based applications in Kotlin with Spring Boot.</p>
<p>With TMS, we will implement the following functionalities; instead of making full-fledged and feature-rich applications, our focus will be on how to leverage Kotlin capability while developing Spring-based applications: </p>
<ul>
<li>Task creation and assigning to the user.</li>
<li>View, update, and delete the task by an admin user.</li>
<li>Add comments to a given task by the admin and normal user to whom the task is assigned.</li>
<li>Implement authentication and authorization with Spring Security.</li>
<li>For simplicity, we will expose the REST service to add users. There will be one admin user and one or more normal users.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Spring Boot project with Kotlin</h1>
                </header>
            
            <article>
                
<p class="mce-root">The first thing is to create a project structure through the Spring Boot initializer. In all previous chapters, we created a project structure in <span><strong>Spring Tool Suit</strong> </span>(<span><strong>STS</strong></span>—an Eclipse-based IDE). There is another way to create it from the web. Go to the  <a href="https://start.spring.io/">https://start.spring.io/</a> URL, and fill in the data as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b2d965e3-a06a-4333-b41c-5bbe1b59bdce.png"/></p>
<p>Make sure you select <span class="packt_screen">Kotlin</span> as a programming language option along with latest stable Spring Boot version (<span class="packt_screen">2.1.2</span> as of now). Also select the dependencies as follows:</p>
<ul>
<li><span class="packt_screen">JPA</span>: Used to interact with the database through <strong>Java Persistence API</strong> (<strong>JPA</strong>)</li>
<li><span class="packt_screen">Web</span>: Add Spring <span><strong>Model-View-Controller</strong> (</span><strong>MVC</strong>) specific features</li>
<li><span class="packt_screen">Security</span>: Required to add Spring Security capabilities</li>
</ul>
<ul>
<li><span class="packt_screen">DevTools</span>: To make live reload on code changes</li>
<li><span class="packt_screen">Thymeleaf</span>: Designing the views with Thymeleaf templates</li>
<li><span class="packt_screen">MySQL</span>: Java connector to interact with the MySQL database</li>
</ul>
<p>Click on the <span class="packt_screen">Generate Project</span> button, and you will see an application structure is downloaded as a ZIP bundle. Just unzip it in your local machine. So far, we have used STS—<span>an Eclipse IDE—</span>as an IDE to develop various applications in previous chapters. However, <span>for a more comprehensive experience, </span>we will use IntelliJ IDEA (a well-known IDE  native with support for Kotlin) in this chapter. </p>
<p>IntelliJ IDEA ships in two versions: Community and Ultimate. The former is available free of cost for JVM and Android-based development, while the later is for web and enterprise development, with more feature support. It is available for popular operating systems—Windows, macOS, and Linux. We will use the Community version. Download it from the <a href="https://www.jetbrains.com/idea/download">https://www.jetbrains.com/idea/download</a> URL, and install it on your local machine.</p>
<p>To import the project, open the IntelliJ IDEA IDE, select the <span class="packt_screen">File</span> <span class="packt_screen">|</span> <span class="packt_screen">Open</span> menu, and select the extracted project structure folder that we have downloaded from the Spring initializer. The very first difference you will see in the Kotlin-based Spring application is the folder structure. The Kotlin source code will reside in <kbd>src/main/kotlin</kbd> compared to <kbd>src/main/java</kbd><em> </em>for standard Java-based applications.</p>
<p>To support Kotlin, Spring requires certain dependencies, which are added automatically to <kbd>pom.xml</kbd> while generating it from the Spring initializer. You will see the Kotlin specific dependencies as follows: </p>
<pre><span>&lt;dependency&gt;<br/></span><span>   &lt;groupId&gt;</span>org.jetbrains.kotlin<span>&lt;/groupId&gt;<br/></span><span>   &lt;artifactId&gt;</span>kotlin-reflect<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span>&lt;dependency&gt;<br/></span><span>   &lt;groupId&gt;</span>org.jetbrains.kotlin<span>&lt;/groupId&gt;<br/></span><span>   &lt;artifactId&gt;</span>kotlin-stdlib-jdk8<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span>&lt;dependency&gt;<br/></span><span>   &lt;groupId&gt;</span>com.fasterxml.jackson.module<span>&lt;/groupId&gt;<br/></span><span>   &lt;artifactId&gt;</span>jackson-module-kotlin<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span><span> </span></pre>
<p class="mce-root">The <kbd>kotlin-stdlib-jdk8</kbd> dependency is required for Kotlin 1.2 and higher versions. For Kotlin 1.1, you need to use <kbd>kotlin-stdlib-jre8</kbd>. The Kotlin-reflect is a reflection feature used in Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DB design </h1>
                </header>
            
            <article>
                
<p>To store task-related data, we will use the MySQL database. We will also store user and role information in database tables. The tables and their relationship details look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7735aa6d-919b-4860-9a9d-53929f0626f6.png" style="width:31.33em;height:29.83em;"/></p>
<p>The table details are as follows:</p>
<ul>
<li><strong>task:</strong> This table stores the details about tasks added into the system. It has a one-to-many relationship with the <strong>comments</strong> table. </li>
<li><strong>comments:</strong> When a user enters a <strong>task</strong> comment, it will be added to this table.</li>
<li><strong>users:</strong> This is a master table to store user details. It has a many-to-many relationship with the table <strong>role</strong>. It also has a one-to-many relationship with the <strong>task</strong> and <strong>comments</strong> tables.</li>
<li><strong>role:</strong> This is a master table for roles. Mainly, there are two roles—<kbd>ROLE_USER</kbd> and <kbd>ROLE_ADMIN</kbd>. <span>It has a many-to-many relationship with the table <strong>users</strong>.</span></li>
<li><strong>user_role:</strong> This is a link table and will store the associated data of <strong>role</strong> and <strong>users</strong>.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity classes</h1>
                </header>
            
            <article>
                
<p>We will use Spring Data JPA to interact with the database, so first we need to write entity classes. An entity class will be mapped to a database table, and its attributes are mapped to the table columns. The JPA entity class is a user-defined POJO class, which is nothing but an ordinary Java class with certain JPA specific annotation and is capable of presenting the objects in the database. </p>
<p>We will create a separate entity class for each of the tables except the link table <strong>user_role</strong>, which is handled with the <kbd>@ManyToMany</kbd> annotation. The details are as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Users</h1>
                </header>
            
            <article>
                
<p>Entity class for the <kbd>users</kbd> table should look as follows:</p>
<pre><span>@Entity<br/></span><span>@Table</span>(<span>name=</span><span>"users"</span><span>,</span><span>catalog=</span><span>"task_mgmt_system"</span>)<br/><span>class </span>User {<br/>    <span>@Id<br/></span><span>    @GeneratedValue</span>(<span>strategy= </span>GenerationType.<span>IDENTITY</span>)<br/>    <span>@Column</span>(<span>name = </span><span>"id"</span>)<br/>    <span>private var </span><span>id</span>:Int? = <span>null<br/></span><span><br/></span><span>    @Column</span>(<span>name=</span><span>"username"</span>)<br/>    <span>private var </span><span>username </span>: String? = <span>null<br/></span><span><br/></span><span>    @Column</span>(<span>name=</span><span>"password"</span>)<br/>    <span>private var </span><span>password </span>: String? = <span>null<br/></span><span><br/></span><span>    @Column</span>(<span>name=</span><span>"firstname"</span>)<br/>    <span>private var </span><span>firstname </span>: String? = <span>null<br/></span><span><br/></span><span>    @Column</span>(<span>name=</span><span>"lastname"</span>)<br/>    <span>private var </span><span>lastname </span>: String? = <span>null<br/></span><span><br/></span><span>    @Column</span>(<span>name=</span><span>"enabled"</span>)<br/>    <span>private var </span><span>enabled </span>: Boolean = <span>false<br/></span><span><br/></span><span>    @ManyToMany</span>(<span>cascade = </span>[CascadeType.<span>PERSIST</span>]<span>,</span><span>fetch = </span>FetchType.<span>EAGER</span>)<br/>    <span>@JoinTable</span>(<br/>            <span>name = </span><span>"user_role"</span><span>,<br/></span><span>            </span><span>joinColumns = </span>[JoinColumn(<span>name = </span><span>"user_id"</span><span>,</span><span>referencedColumnName = </span><span>"id"</span>) ]<span>,<br/></span><span>            </span><span>inverseJoinColumns = </span>[JoinColumn(<span>name = </span><span>"role_id"</span><span>,</span><span>referencedColumnName = </span><span>"id"</span>)]<br/>    )<br/>    <span>private var </span><span>roles</span>: Set&lt;Role&gt;? = <span>null<br/></span><span><br/></span><span>    @OneToMany<br/></span><span>    @JoinColumn</span>(<span>name =</span><span>"user_id"</span>)<br/>    <span>private var </span><span>comments </span>: MutableSet&lt;Comments&gt;? = <span>null</span><br/><br/>  //.... Getters and Setters<br/>}</pre>
<p>The <kbd>@Entity</kbd> annotation is used to declare that the class is a JPA entity. The <kbd>@Table</kbd> annotation is used to map the class with a specific database table. The attributes of this class are mapped to the respective columns with the <kbd>@Column</kbd> annotation. The attributes are defined as nullable, as they will be populated at runtime. </p>
<p>The <kbd>@JoinTable</kbd> annotation is used to declare the link table, and <kbd>JoinColumn</kbd> is used to define the column reference between tables associated with a many-to-many relationship along with the link table. The many-to-many relationship declaration in Kotlin is a little bit different than in Java. The same configuration is declared in Java as follows:</p>
<pre>@ManyToMany(cascade = CascadeType.PERSIST,fetch = FetchType.EAGER )<br/>@JoinTable(<br/>   name = "user_role",<br/>   joinColumns = @JoinColumn(name = "user_id",referencedColumnName = "id"),<br/>   inverseJoinColumns = @JoinColumn(name = "role_id",referencedColumnName = "id")<br/>)</pre>
<p>The visible difference here is the declaration of the <kbd>joinColumns</kbd> attribute of the <kbd>@JoinTable</kbd> annotation. In Java, it is declared with an annotation, while in Kotlin it is defined as an array. Another difference is defining the <kbd>cascade</kbd> attribute in the <kbd>@ManyToMany</kbd> annotation. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Role</h1>
                </header>
            
            <article>
                
<p>The entity class corresponding to the <kbd>role</kbd> table looks as follows:</p>
<pre><span>@Entity<br/></span><span>@Table</span>(<span>name=</span><span>"role"</span><span>,</span><span>catalog=</span><span>"task_mgmt_system"</span>)<br/><span>class </span>Role {<br/>    <span>@Id<br/></span><span>    @GeneratedValue</span>(<span>strategy= </span>GenerationType.<span>IDENTITY</span>)<br/>    <span>@Column</span>(<span>name = </span><span>"id"</span>)<br/>    <span>private var </span><span>id</span>:Int? = <span>null<br/></span><span><br/></span><span>    @Column</span>(<span>name=</span><span>"role"</span>)<br/>    <span>private var </span><span>role </span>: String? = <span>null<br/></span><span><br/></span><span>    @ManyToMany</span>(<span>mappedBy = </span><span>"roles"</span><span>,</span><span>cascade = </span>[CascadeType.<span>PERSIST</span>])<br/>    <span>private var </span><span>users</span>:Set&lt;User&gt;? = <span>null</span><br/> // ... Getters and Setters<br/>}</pre>
<p>In the many-to-many relationship between <kbd>User</kbd> and <kbd>Role</kbd> entities, the ownership is with the<kbd>User</kbd> entity so the <kbd>@ManyToMany</kbd> annotation in the <kbd>Role</kbd> entity is defined with the <kbd>mappedBy</kbd> attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Task</h1>
                </header>
            
            <article>
                
<p>The entity class associated to <kbd>task</kbd> table should look as follows:</p>
<pre><span>@Entity<br/></span><span>@Table</span>(<span>name=</span><span>"task"</span><span>,</span><span>catalog=</span><span>"task_mgmt_system"</span>)<br/><span>class </span>Task {<br/>   <span>@Id<br/></span><span>   @GeneratedValue</span>(<span>strategy=</span>GenerationType.<span>IDENTITY</span>)<br/>   <span>@Column</span>(<span>name = </span><span>"id"</span>)<br/>   <span>private var </span><span>id </span>:Int?=<span>null<br/></span><span><br/></span><span>   @Column</span>(<span>name=</span><span>"title"</span>)<br/>   <span>private var </span><span>title </span>: String? = <span>null<br/></span><span>   <br/></span><span>   @Column</span>(<span>name=</span><span>"detail"</span>)<br/>   <span>private var </span><span>detail </span>: String? = <span>null<br/></span><span><br/></span><span>   @Column</span>(<span>name=</span><span>"assigned_to"</span>)<br/>   <span>private var </span><span>assignedTo </span>: Int? = <span>null<br/></span><span><br/></span><span>   @Column</span>(<span>name=</span><span>"status"</span>)<br/>   <span>private var </span><span>status </span>: String? = <span>null<br/></span><span><br/></span><span>   @OneToMany<br/></span><span>   @JoinColumn</span>(<span>name =</span><span>"task_id"</span>)<br/>   <span>private var </span><span>comments </span>: MutableSet&lt;Comments&gt;? = <span>null</span><br/><br/>  // .. Getters and Setters<br/>}</pre>
<p>The <kbd>@OneToMany</kbd> annotation is used to declare a one-to-many relationship with the <kbd>comments</kbd> table. The <kbd>@JoinColumn</kbd> annotation is used to declare the column reference in the <kbd>comments</kbd> table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comments</h1>
                </header>
            
            <article>
                
<p>The entity class for <kbd>comments</kbd> table should look as follows:</p>
<pre><span>@Entity<br/></span><span>@Table</span>(<span>name=</span><span>"comments"</span><span>,</span><span>catalog=</span><span>"task_mgmt_system"</span>)<br/><span>class </span>Comments {<br/>   <span>@Id<br/></span><span>   @GeneratedValue</span>(<span>strategy=</span>GenerationType.<span>IDENTITY</span>)<br/>   <span>private var </span><span>id </span>:Int?=<span>null<br/></span><span><br/></span><span>   @ManyToOne<br/></span><span>   @JoinColumn</span>(<span>name = </span><span>"user_id"</span><span>,</span><span>nullable = </span><span>false</span>)<br/>   <span>private var </span><span>user </span>: User? = <span>null<br/></span><span><br/></span><span>   @ManyToOne<br/></span><span>   @JoinColumn</span>(<span>name = </span><span>"task_id"</span><span>, </span><span>nullable = </span><span>false</span>)<br/>   <span>private var </span><span>task </span>: Task? = <span>null;<br/></span><span><br/></span><span>   private var </span><span>comment</span>:String? = <span>null</span><br/> <br/>  // .. Getters and Setters<br/>}</pre>
<p>The <kbd>@ManyToOne</kbd> annotation is used to declare a many-to-one relationship with a <strong>task</strong> table. The <kbd>@JoinColumn</kbd> annotation is used to define the reference column (primary key).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security</h1>
                </header>
            
            <article>
                
<p>Spring Security is the de facto standard for implementing security constraints in Spring-based applications. In previous chapters, we used Spring Security with an in-memory model while implementing user authentication and authorization. The in-memory model should only be used for testing purposes only. In a real scenario, authentication and authorization details are fetched from other systems to make it loosely coupled with the application code, such as LDAP, OAuth, and so on.</p>
<p>In <a href="e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml">Chapter 3</a>, <em>Blogpress – A Simple Blog Management System</em>, we learned how to configure Spring Security with LDAP and OAuth in detail. In this chapter, we will use database tables to store authentication and authorization details. First, let's create a class and define the security configuration as follows:</p>
<pre><span>@Configuration<br/></span><span>@EnableWebSecurity<br/></span><span>@ComponentScan</span>(<span>"com.nilangpatel.tms.security"</span>)<br/><span>class </span>WebSecurityConfig : WebSecurityConfigurerAdapter() {<br/><span><br/>    @Throws</span>(Exception::<span>class</span>)<br/><span>    override fun </span><span>configure</span>(web: WebSecurity){<br/>        web.ignoring().antMatchers(<span>"/js/**"</span>)<span><br/></span><span>        </span>web.ignoring().antMatchers(<span>"/css/**"</span>)<span><br/></span>    }<br/>    <br/>   <span>@Throws</span>(Exception::<span>class</span>)<br/><span>   override fun </span><span>configure</span>(http: HttpSecurity) {<br/>    // .... HttpSecurity specific configuration<br/>   }<br/>}</pre>
<p>This is a typical security configuration. The way we declared annotation for Kotlin is similar to what we have done with Java. However, there are differences as follows:</p>
<ul>
<li>In Kotlin, we can use a colon (<kbd>:</kbd>) to declare inheritance. The <kbd>WebSecurityConfigurerAdapter</kbd> class is a parent class, but with the surprise that it is a Java class. You can extend your Kotlin class from another Java class, and it is absolutely fine. This is how Kotlin is deeply interoperable with Java. Another difference is the parent class is used with the constructor notation (with brackets).</li>
<li>To override a method from the parent class, Kotlin uses the <kbd>override</kbd> keyword.</li>
<li>Since Kotlin does not support checked exceptions directly, the <kbd>@Throws</kbd> annotation is used to define the exception details.</li>
</ul>
<p>Next, the access mechanism needs to be configured to various pages in the system. This can be done by overriding the configure method, which basically provides an HTTP specific security configuration. It looks as follows:</p>
<pre><span>@Throws</span>(Exception::<span>class</span>)<br/><span>override fun </span><span>configure</span>(http: HttpSecurity) {<br/>    http.authorizeRequests()<br/>        .antMatchers(<span>"/"</span><span>,</span><span>"/login"</span><span>,</span><span>"/api/register"</span>).permitAll()<br/>        .antMatchers(<span>"/controlPage/**"</span><span>,</span><span>"/getAllUsers/**"</span><span>,<br/></span><span>            </span><span>"/allTaskList/**"</span><span>,</span><span>"/addTaskComment/**"</span><span>,</span><span>"/viewTask/**"</span>)<br/>            .hasAnyAuthority(TaskMgmntConstant.<span>ROLE_USER</span><span>,</span>TaskMgmntConstant.<span>ROLE_ADMIN</span>)<br/>        .antMatchers(<span>"/showAddTask/**"</span><span>,</span><span>"/showEditTask/**"</span><span>,<br/></span><span>                    </span><span>"/addTask/**"</span><span>,</span><span>"/updateTask/**"</span><span>,</span><span>"/deleteTask/**"</span>)<br/>            .hasAnyAuthority(TaskMgmntConstant.<span>ROLE_ADMIN</span>)<br/>        .and()<br/>     .formLogin().loginPage(<span>"/login"</span>).permitAll()<br/>        .defaultSuccessUrl(<span>"/controlPage"</span><span>,true</span>)<br/>        .failureUrl(<span>"/login?error=true"</span>)<br/>     .and().csrf().disable()<br/>        .logout()<br/>        .permitAll().logoutSuccessUrl(<span>"/login?logout=true"</span>)<br/>}</pre>
<p>The noticeable things here are we have configured various URLs accessible for all users, even without login, and only the admin needs to log in. We also have configured the login, success, and failure URLs along with the logout URL. We will talk more about them in the <em>Defining the Spring MVC controller</em> section.</p>
<p>Now, we will configure an authentication mechanism. Spring supports various options such as in-memory, LDAP, OAuth, and so on. For this application, we will fetch user details from the database. To implement Spring Security with the database, there are two approaches.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Query approach</h1>
                </header>
            
            <article>
                
<p>Spring Security needs users and their role details to perform the security check. In this approach, we will fetch the user and role details with a SQL query. We will define a query in the <kbd>application.properties</kbd> file as follows:</p>
<pre><span>spring.queries.users-query</span><span>= </span><span>select username, password, enabled from users where username=?<br/></span><span>spring.queries.roles-query</span><span>= </span><span>select u.username, r.role from users u inner join user_role ur on(u.id=ur.user_id) inner join role r on(ur.role_id=r.id) where u.username=?</span></pre>
<p>The first query fetches user details while second queries retrieve the list of roles for a given username. These properties can be read in the <kbd>WebSecurityConfig</kbd> class as follows:  </p>
<pre><span>@Value</span>(<span>"</span><span>\$</span><span>{spring.queries.users-query}"</span>)<br/><span>private val </span><span>usersQuery</span>: String? = <span>null<br/></span><span><br/></span><span>@Value</span>(<span>"</span><span>\$</span><span>{spring.queries.roles-query}"</span>)<br/><span>private val </span><span>rolesQuery</span>: String? = <span>null</span></pre>
<p>In Kotlin, the symbol <kbd>$</kbd> is used to print the variable within <kbd>String</kbd> without explicitly using the <kbd>+</kbd> operator. Since we want to read the property from the <kbd>application.properties</kbd> file, we have to use the escape character (<kbd>\</kbd>) along with the <kbd>$</kbd> operator. Apart from this, the variables are declared as nullable (with <kbd>String?</kbd>) as they will be populated by Spring at runtime.</p>
<p>Next, we will override the <kbd>configure()</kbd> method to define the authentication configuration as follows:</p>
<pre><span>@Throws</span>(Exception::<span>class</span>)<br/><span>override fun </span><span>configure</span>(auth: AuthenticationManagerBuilder?) {<br/>    auth!!.jdbcAuthentication()<br/>            .usersByUsernameQuery(<span>usersQuery</span>)<br/>            .authoritiesByUsernameQuery(<span>rolesQuery</span>)<br/>            .dataSource(<span>dataSource</span>)<br/>            .passwordEncoder(passwordEncoder())<br/>}</pre>
<p>The nice thing about IntelliJ IDEA is, whenever you pass any Java code, it will prompt to convert to Java. On choosing <span class="packt_screen">yes</span>, it will automatically convert Java code into Kotlin code. The <kbd>!!</kbd> symbol is a not-null assertion operator, which basically converts any value to a non-null type and throws a <kbd>NullPointerException</kbd> if the variable is null. It is part of the null safety feature of Kotlin. The <kbd>dataSource</kbd> and <kbd>passwordEncoder</kbd> methods can be defined as follows:</p>
<pre><span>@Autowired<br/></span><span>private var </span><span>dataSource</span>: DataSource? = <span>null</span><br/><br/><span>@Bean<br/></span><span>fun </span><span>passwordEncoder</span>(): BCryptPasswordEncoder {<br/>    <span>return </span>BCryptPasswordEncoder()<br/>}</pre>
<p>The <kbd>dataSource</kbd> will be injected by Spring at runtime, so it must be declared as nullable (with <kbd>?</kbd>). We will use <kbd>BCryptPasswordEncoder</kbd> to encode the password with the <kbd>bcrpt</kbd> algorithm, which is considered to be a very strong encoding algorithm.</p>
<div class="packt_infobox">The <kbd>userQuery</kbd> and <kbd>roleQuery</kbd> objects are not necessarily required.  If you do not provide them, you need to design the tables with predefined names and columns. The user table must be created with a name—<kbd>users</kbd> with columns <kbd>username</kbd>, <kbd>password</kbd>, and <kbd>enabled</kbd> , while the <strong>role</strong> table must be created with a name—<kbd>authorities</kbd>.</div>
<p>This approach has certain restrictions. For example: <kbd>userQuery</kbd> must return the <kbd>username</kbd>, <kbd>password</kbd>, and <kbd>enabled</kbd> column value in the same sequence and  <kbd>roleQuery</kbd> must return  <kbd>username</kbd> and <kbd>role name</kbd> in the same sequence. If any change happens in this sequence, it may not work properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UserDetailsService approach</h1>
                </header>
            
            <article>
                
<p>Another approach to fetch use and role information is using the <kbd>UserDetailsService</kbd> interface. It is an abstract way to fetch authentication and authorization details. It has one method—<kbd>loadUserByUsername()</kbd> that will return user details based on <kbd>username</kbd>. You can override it and write your own logic to retrieve the user details.</p>
<p>Spring provides a class called <kbd>DaoAuthenticationProvider</kbd> that basically uses the <kbd>UserDetailsService</kbd> implementation to fetch user details during the authentication process. The flexibility in this approach means we can define a custom method to fetch user details. We will define a method in the JPA repository for the <kbd>User</kbd> entity. The JPA is a standard way of interacting with a relational database with Java objects. The repository looks as follows:</p>
<pre>@Repository<br/>interface UserRepository : JpaRepository&lt;User, Int&gt; {<br/>   fun findByUsername(username: String): User?<br/>}</pre>
<p><kbd>UserRepository</kbd> is a Kotlin interface that extends the Java <kbd>JpaRepository</kbd> interface. The <kbd>@Repository</kbd> annotation is used to declare this interface as a JPA repository. The <kbd>findByUsername</kbd> method is a query method, which will fetch the user. Spring Data JPA has an inbuilt query building mechanism, based on the repository method name. </p>
<p>For the <kbd>findByUsername</kbd> method, it will first remove the <kbd>findBy</kbd> prefix and compose the query from the rest of the method name. In this case, it will internally create a query, such as <kbd>select * from users where username=?</kbd>. This method returns an object of the <kbd>User</kbd> entity class. Next, we need to provide a custom user service, and for that we will implement <kbd>UserDetailsService</kbd> as follows: </p>
<pre><span>@Service<br/></span><span>class </span>CustomUserDetailsService : UserDetailsService {<br/><br/>    <span>@Autowired<br/></span><span>    private val </span><span>userRepository</span>: UserRepository? = <span>null<br/><br/></span><span>    @Throws</span>(UsernameNotFoundException::<span>class</span>)<span><br/></span><span>    override fun </span><span>loadUserByUsername</span>(username: String): UserDetails {<br/>      <span>val </span>user = <span>userRepository</span>?.findByUsername(username) ?: <br/>                     <span>throw </span>UsernameNotFoundException(username)<br/>      <span>return </span>CustomUserPrinciple(user)<br/>    }<br/>}</pre>
<p>The <kbd>CustomUserDetailsService</kbd> class is declared with a <kbd>@Service</kbd> annotation to declare it as a service component. It overrides a <kbd>loadUserByUsername()</kbd> method, where we can write custom logic to fetch user details. A repository <kbd>findByUsername()</kbd> method that we have created is used here to fetch user details.</p>
<p>The return type is <kbd>UserDetails</kbd> that is an interface that actually stores user information, which is then encapsulated to authenticate objects later. We have created a <kbd>CustomUserPrinciple</kbd> <span>class </span>to provide an implementation of <kbd>UserDetails</kbd> as follows:</p>
<pre><span>class </span>CustomUserPrinciple : UserDetails {<br/>    <span>constructor</span>(user: User?) {<br/>        <span>this</span>.<span>user </span>= user<br/>    }<br/>    <span>private var </span><span>user</span>:User? = <span>null<br/><br/></span>    <span>override fun </span><span>isEnabled</span>(): Boolean {<br/>        <span>return true<br/></span><span>    </span>}<br/>    <span>override fun </span><span>getUsername</span>(): String {<br/>        <span>return this</span>.<span>user</span>?.getUsername() ?: <span>""<br/></span><span>    </span>}<br/>    <span>override fun </span><span>isCredentialsNonExpired</span>(): Boolean {<br/>        <span>return true<br/></span><span>    </span>}<br/>    <span>override fun </span><span>getPassword</span>(): String {<br/>       <span>return this</span>.<span>user</span>?.getPassword() ?: <span>""<br/></span><span>    </span>}<br/>    <span>override fun </span><span>isAccountNonExpired</span>(): Boolean {<br/>        <span>return true<br/></span><span>    </span>}<br/>    <span>override fun </span><span>isAccountNonLocked</span>(): Boolean {<br/>        <span>return true<br/></span><span>    </span>}<br/>    <span>override fun </span><span>getAuthorities</span>(): MutableCollection&lt;<span>out </span>GrantedAuthority&gt; {<br/>         <span>var </span>userRoles:Set&lt;Role&gt;? = <span>user</span>?.getRoles() ?: <span>null<br/></span><span>         var </span>authorities:MutableSet&lt;GrantedAuthority&gt; = HashSet<span>&lt;GrantedAuthority&gt;</span>()<br/>         <span>for</span>(role <span>in </span>userRoles.<span>orEmpty</span>()){<br/>             authorities.add(CustomGrantedAuthority(role))<br/>         }<br/>         <span>return </span>authorities<br/>    }<br/><br/>}</pre>
<p>The <kbd>UserDetails</kbd> interface requires the implementation of certain methods as follows:</p>
<ul>
<li><kbd>isEnable()</kbd>: This method basically returns if the user is activated or not. In a practical scenario, there must be a separate database column to check if the user is enabled or not. For simplicity, we simply return <kbd>true</kbd>  assuming that all users are enabled. If the user returns <kbd>false</kbd>, Spring Security will not allow login.</li>
<li><kbd>getUsername()</kbd>: This simply returns the <span>username</span>.</li>
<li><kbd>isCredentialsNonExpired()</kbd>: This is a very useful method when you want to impose a constraint on the user to update the password after a certain time limit. In this method, you need to check whether the password has expired, based on your requirement, and return the value accordingly. For simplicity, if we return <kbd>true</kbd> , it means password has not expired.</li>
<li><kbd>getPassword()</kbd>: It should return the password.</li>
<li><kbd>isAccountNonExpired()</kbd>: This indicates whether a user account has expired or not. To make it simple, we just return <kbd>true</kbd>.</li>
<li><kbd>isAccountNonLocked()</kbd>: This is used to check whether a user account is locked. Again, for simplicity, we a just return <kbd>true</kbd>.</li>
<li class="mce-root"><kbd>getAuthorities()</kbd><span>: This method returns authorities granted to the user. We retrieve roles from a user object and wrap them in a</span> <kbd>GrantedAuthority</kbd> <span>type. The</span> <kbd>GrantedAuthority</kbd> <span>is an interface. We have provided an implementation through</span> the <kbd>CustomGrantedAuthority</kbd> <span>class as follows:</span></li>
</ul>
<pre style="color: black;padding-left: 60px">class CustomGrantedAuthority : GrantedAuthority{<br/>    private var role:Role?=null<br/>    constructor( role:Role ){<br/>        this.role = role<br/>    }<br/>    override fun getAuthority(): String {<br/>        return role?.getRole() ?: ""<br/>    }<br/>}</pre>
<ul>
<li>We are injecting a user object through the constructor, which can be used to retrieve further details in each of these methods.</li>
</ul>
<p>The last part is to define the Spring Security configuration. Add methods to the <kbd>WebSecurityConfig</kbd> class as follows:</p>
<pre><span>@Throws</span>(Exception::<span>class</span>)<br/><span>override fun </span><span>configure</span>(auth: AuthenticationManagerBuilder?) {<br/>    auth!!.authenticationProvider(authenticationProvider())<br/>}<br/><br/><span>@Bean<br/></span><span>fun </span><span>authenticationProvider</span>(): DaoAuthenticationProvider {<br/>    <span>val </span>authProvider = DaoAuthenticationProvider()<br/>    authProvider.setUserDetailsService(<span>userDetailService</span>)<br/>    authProvider.setPasswordEncoder(passwordEncoder())<br/>    <span>return </span>authProvider<br/>}</pre>
<p>The <kbd>authenticationProvider()</kbd> method simply creates an object of the <kbd>DaoAuthenticationProvider</kbd> type, configure it with user detail service object and password encoder and return. It is then used in the <kbd>configure()</kbd> method to set as the authentication provider. The object of <kbd>UserDetailService</kbd> can be injected in the same class as follows:</p>
<pre><span>@Autowired<br/></span><span>private var </span><span>userDetailService</span>: CustomUserDetailsService? = <span>null</span></pre>
<p>This approach is more flexible in terms of allowing a customized way to fetch user details, which are then used by Spring to perform various security constraints. It simply decouples the logic of authentication and authorization from the mechanism to fetch user details. This makes the system more flexible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the Spring MVC controller</h1>
                </header>
            
            <article>
                
<p>Our backend layer is ready, and now we will design the controller and view layer. We have decided to user Spring MVC for the frontend, which is the best fit for web-based Spring applications. The declaration of Spring MVC controller in Kotlin is similar to what we have done in Java, as follows:</p>
<pre><span>@Controller<br/></span><span>class </span>TaskMgmtSystemController {<br/><br/>// Controller methods...<br/>}</pre>
<p>The Kotlin <kbd>TaskMgmtSystemController</kbd> class is declared with the <kbd>@Controller</kbd> annotation, which is used to define the class as a Spring MVC controller. The way of defining controller methods in Kotlin is also similar to Java. For example: a home page can be shown by the following controller method:</p>
<pre><span>@GetMapping</span>(<span>"/"</span>)<br/><span>fun </span><span>showHomePage</span>(model: Model): String  {<br/>   <span>logger</span>.info(<span>"This will show home page "</span>)<br/>   setProcessingData(model<span>, </span>TaskMgmntConstant.<span>TITLE_HOME_PAGE</span>)<br/>   <span>return </span><span>"home"<br/></span>}</pre>
<p>This method is mapped with the <kbd>/</kbd> URL (accessible at <a href="http://localhost:8080">http://localhost:8080</a>) and returns a home page. As mentioned, we are going to use Thymeleaf templates to construct a view layer.</p>
<div class="packt_infobox">If you are not very familiar with Thymeleaf, it is a natural template engine used to produce views, which are processed at the server side. A detail explanation was given in <a href="e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml">Chapter 3</a><em>, Blogpress – A Simple Blog Management System,</em> of this book. You can refer to it to get more idea about how Thymeleaf works with Spring.</div>
<p>We also have defined constants to access predefined values. <span>Unlike Java, we can not define constants in the Kotlin interface. </span>To define constants, we will use a singleton class. In Kotlin, we can create a singleton class by an object declaration feature. This can be achieved with the <kbd>object</kbd> keyword. The <kbd>TaskMgmntConstant</kbd> <span>singleton class </span>looks as follows:</p>
<pre><span>object </span>TaskMgmntConstant {<br/>   <span>const val </span><span>ROLE_USER </span>:String = <span>"ROLE_USER"<br/></span><span>   </span><span>const val </span><span>ROLE_ADMIN </span>:String = <span>"ROLE_ADMIN"<br/></span><span>   </span><span>const val </span><span>TITLE_HOME_PAGE</span>: String = <span>"Home"<br/></span><span>   </span><span>const val </span><span>TITLE_LOGIN_PAGE</span>: String = <span>"Login"<br/></span><span>   </span><span>const val </span><span>TITLE_LANDING_CONTROL_PAGE</span>:String = <span>"Control Page"<br/></span><span>   </span><span>const val </span><span>TITLE_ADD_TASK_PAGE</span>:String = <span>"Add Task"<br/></span><span>   </span><span>const val </span><span>TITLE_UPDATE_TASK_PAGE</span>:String = <span>"Update Task"<br/></span><span>   </span><span>const val </span><span>PAGE_TITLE</span>: String = <span>"pageTitle"<br/></span>}</pre>
<p>Though there is no <kbd>class</kbd> keyword used here, this code combines both <kbd>class</kbd> and the singleton declaration altogether. Internally, Kotlin will create a single static instance of the <kbd>TaskMgmntConstant</kbd> class. The <kbd>object</kbd> declaration can contain functions as well, which can be accessed with the <kbd>object</kbd> declaration name directly. It is similar to accessing the static variables and methods of the class type in Java. </p>
<p>The <kbd>const</kbd> keyword is used to define constants. The variables declared with the <kbd>const</kbd> keyword are compile-time constants, meaning they must be populated at the time of compilation. Because of this reason, they can not be assigned to function or class constructors but only to a string or primitives.</p>
<p>Next, we will see how to define controller methods for other operations as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing the control page</h1>
                </header>
            
            <article>
                
<p>When a user does log in, the system will land on a page called the control page. From this page, users can view the task and perform various operations based on the role they have. For example: a normal user can see the task list assigned to it and also able to add a comment for a specific task. The admin user can add a new task, edit, and delete an existing one. This controller method simply redirects the user to the landing (or control) page. The code looks as follows:</p>
<pre><span>@GetMapping</span>(<span>"/controlPage"</span>)<br/><span>fun </span><span>showControlPage</span>(model:Model):String {<br/>   <span>logger</span>.info(<span>"Showing control page "</span>)<br/>    setProcessingData(model<span>, </span>TaskMgmntConstant.<span>TITLE_LANDING_CONTROL_PAGE</span>)<br/>    <span>return </span><span>"control-page"<br/></span>}</pre>
<p>In the <em>Spring Security</em> section, we configured <kbd>/controlPage</kbd> accessible to normal and admin users. It cannot be accessed without login. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing the login page</h1>
                </header>
            
            <article>
                
<p class="mce-root">This controller method will redirect the user to the login page. It looks as follows:</p>
<pre><span>@GetMapping</span>(<span>"/login"</span>)<br/><span>fun </span><span>showLoginPage</span>(<span>@RequestParam</span>(<span>name = </span><span>"error"</span><span>,</span><span>required = </span><span>false</span>) error:String? <span>,<br/></span><span>      @RequestParam</span>(<span>name = </span><span>"logout"</span><span>, </span><span>required = </span><span>false</span>) logout:String?<span>, </span>model:Model):String  {<br/>   <span>logger</span>.info(<span>"This is login page URL   "</span>)<br/>   <span>if </span>(error != <span>null</span>) {<br/>      model.addAttribute(<span>"error"</span><span>, </span><span>"Invalid Credentials provided."</span>)<br/>   }<br/>   <span>if </span>(logout != <span>null</span>) {<br/>      model.addAttribute(<span>"message"</span><span>, </span><span>"Logged out"</span>)<br/>   }<br/>   setProcessingData(model<span>, </span>TaskMgmntConstant.<span>TITLE_LOGIN_PAGE</span>)<span>;<br/></span><span>   return </span><span>"login"<br/></span>}</pre>
<p>It is accessible from the navigation menu. This method also handles an error in the case of invalid credentials and shows an appropriate message to the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing the add new task page</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">add new task</span> feature is configured to allow only admin users. It will redirect the user to the add new task page. The code looks as follows:</p>
<pre><span>@GetMapping</span>(<span>"/showAddTask"</span>)<br/><span>fun </span><span>showAddTask</span>(model:Model):String {<br/>   <span>logger</span>.info(<span>"Going to show Add task page"</span>)<br/>   setProcessingData(model<span>, </span>TaskMgmntConstant.<span>TITLE_ADD_TASK_PAGE</span>)<br/>   <span>return </span><span>"task-add"<br/></span>}</pre>
<p>The  <kbd>/showAddTask</kbd> URL is configured as a navigation menu in the control page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing the edit task page</h1>
                </header>
            
            <article>
                
<p>Only admin users can edit existing tasks. Admin users can see an <span class="packt_screen">Edit</span> button for each task record on task—list screen. Upon clicking it, this method will be triggered. It looks as follows.</p>
<pre><span>@GetMapping</span>(<span>"/showEditTask"</span>)<br/><span>fun </span><span>showEditTask</span>(<span>@RequestParam</span>(<span>name = </span><span>"taskId"</span><span>,</span><span>required = </span><span>true</span>) taskId: Int<span>,<br/></span><span>      </span>model:Model):String {<br/>   <span>val </span>task:Task? = <span>taskRepository</span>?.findById(taskId)?.get()<br/>   <span>if</span>(task !=<span>null</span>){<br/>      <span>val </span>userId: Int = <span>task</span>.getAssignedTo() ?: <span>0<br/></span><span>      </span><span>val </span>user:User? = <span>userRepository</span>?.findById(userId)?.get()<br/>      <span>val </span>taskDto = TaskDTO(<span>task</span>.getId()<span>,</span><span>task</span>.getTitle()<span>,<br/></span><span>            </span><span>task</span>.getDetail()<span>,</span>userId<span>,</span>(user?.getFirstname() + <span>" "</span>+user?.getLastname())<span>,</span><span>task</span>.getStatus()<span>,null</span>)<br/>      model.addAttribute(<span>"task"</span><span>,</span>taskDto)<br/>   }<br/>   <span>logger</span>.info(<span>"Going to show Edit task page"</span>)<br/>   setProcessingData(model<span>, </span>TaskMgmntConstant.<span>TITLE_UPDATE_TASK_PAGE</span>)<br/>   model.addAttribute(<span>"screenTitle"</span><span>,</span><span>"Edit Task"</span>)<br/>   <span>return </span><span>"task-edit"<br/></span>}</pre>
<p>The <kbd>taskId</kbd> parameter will be sent as a request parameter from the task list screen. First, we fetch the task object from a given <kbd>taskId</kbd> with <kbd>taskRepository</kbd> and then copy it to the <kbd>TaskDTO</kbd> object. You can see we have declared variables with the <kbd>val</kbd> keyword, which is used to declare constants. Kotlin recommends using <kbd>val</kbd> in case the variable is not changed after assigning the value. The <kbd>TaskDTO</kbd> class is a data class defined in Kotlin as follows:</p>
<pre><span>class </span>TaskDTO( <span>var </span><span>id </span>:Int?<span>, var </span><span>title </span>: String?<span>,<br/></span><span>               var </span><span>detail </span>: String?<span>, var </span><span>assignedTo </span>: Int?<span>, var </span><span>assignedPerson</span>:String?<span>,<br/></span><span>               var </span><span>status </span>: String?<span>, var </span><span>comments </span>: Set&lt;Comments&gt;?)</pre>
<p class="mce-root">The <span class="packt_screen">Edit Task</span> screen looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/95e80311-3475-48d1-93f3-96d63fb1f4bd.png" style="width:41.67em;height:29.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a new task</h1>
                </header>
            
            <article>
                
<p>Only admin users can add a new task. This controller method will insert the task record in the database. It looks as follows:</p>
<pre><span>@PostMapping</span>(<span>"/addTask"</span>)<br/><span>fun </span><span>addTask</span>(<span>@RequestParam</span>(<span>name = </span><span>"title"</span><span>,</span><span>required = </span><span>true</span>) title:String<span>,<br/></span><span>         @RequestParam</span>(<span>name = </span><span>"detail"</span><span>,</span><span>required = </span><span>true</span>) detail:String<span>,<br/></span><span>         @RequestParam</span>(<span>name = </span><span>"selectedUserId"</span><span>, </span><span>required = </span><span>true</span>) selectedUserId:Int<span>,<br/></span><span>      </span>model:Model):String {<br/>   <span>val </span>task = Task()<br/>   task.setTitle(title)<br/>   task.setDetail(detail)<br/>   task.setAssignedTo(selectedUserId)<br/>   task.setStatus(TaskStatus.<span>PENDING</span>.getStatus())<br/>   <span>taskRepository</span>?.save(task)<br/><br/>   <span>logger</span>.info(<span>"Goint to show Add task page"</span>)<br/>   setProcessingData(model<span>, </span>TaskMgmntConstant.<span>TITLE_ADD_TASK_PAGE</span>)<br/>   model.addAttribute(<span>"screenTitle"</span><span>,</span><span>"Add new Task"</span>)<br/>   <span>return </span><span>"redirect:allTaskList"<br/></span>}</pre>
<p>The <kbd>title</kbd>, <kbd>detail</kbd>, and <kbd>userId</kbd> parameters (to whom the task is assigned) are provided from the <span class="packt_screen">add task</span> screen. This method simply creates an instance of the <kbd>Task</kbd> class, populates its value, and saves it in <kbd>taskRepsitory</kbd>. Unlike Java, the instance can be created without the <kbd>new</kbd> keyword in Kotlin. Also, Kotlin defers the type of variable wherever it is possible. For example, we have not defined the type of the <kbd>task</kbd> variable because it is assigned the object of the <kbd>Task</kbd> type class so Kotlin understands that it is the <kbd>Task</kbd> type only.</p>
<p>Instead of redirecting to a specific page, we are redirecting to another controller method with the <kbd>/allTaskList</kbd> URL pattern, which basically shows a task list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating a task</h1>
                </header>
            
            <article>
                
<p>Updating a task is similar to adding a new task method. Only admin users can update the existing task. This method looks as follows:</p>
<pre><span>@PostMapping</span>(<span>"/updateTask"</span>)<br/><span>fun </span><span>updateTask</span>(<span>@RequestParam</span>(<span>name = </span><span>"taskId"</span><span>,</span><span>required = </span><span>true</span>) taskId:Int<span>,<br/></span><span>         @RequestParam</span>(<span>name = </span><span>"title"</span><span>,</span><span>required = </span><span>true</span>) title:String<span>,<br/></span><span>         @RequestParam</span>(<span>name = </span><span>"detail"</span><span>,</span><span>required = </span><span>true</span>) detail:String<span>,<br/></span><span>         @RequestParam</span>(<span>name = </span><span>"selectedUserId"</span><span>, </span><span>required = </span><span>true</span>) selectedUserId:Int<span>,<br/></span><span>         </span>model:Model):String {<br/>   <span>val </span>task:Task? = <span>taskRepository</span>?.findById(taskId)?.get()<br/>   <span>if</span>(task !=<span>null</span>) {<br/>      <span>task</span>.setTitle(title)<br/>      <span>task</span>.setDetail(detail)<br/>      <span>task</span>.setAssignedTo(selectedUserId)<br/>      <span>taskRepository</span>?.save(<span>task</span>)<br/>   }<br/><br/>   <span>logger</span>.info(<span>"Going to show Add task page"</span>)<br/>   model.addAttribute(<span>"screenTitle"</span><span>,</span><span>"Edit Task"</span>)<br/>   setProcessingData(model<span>, </span>TaskMgmntConstant.<span>TITLE_ADD_TASK_PAGE</span>)<br/>   <span>return </span><span>"redirect:allTaskList"<br/></span>}</pre>
<p>The code looks similar to the <kbd>addTask()</kbd> method. The only difference is we get the <kbd>taskId</kbd> of the existing task as an additional parameter. First, we retrieve it, update its value, and finally save it with <kbd>taskRepository</kbd>. This method also redirects to another controller method to show a task list with an <kbd>/allTaskList</kbd> URL pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a task comment</h1>
                </header>
            
            <article>
                
<p>Normal and admin users can add comments to an existing task. On opening the task in view mode, the screen provides a facility to add a comment. The code of the controller method for adding task comments looks as follows:</p>
<pre><span>@PostMapping</span>(<span>"/addTaskComment"</span>)<br/><span>fun </span><span>addTask</span>(<span>@RequestParam</span>(<span>name = </span><span>"taskId"</span><span>,</span><span>required = </span><span>true</span>) taskId:Int<span>,<br/></span><span>         @RequestParam</span>(<span>name = </span><span>"taskComment"</span><span>,</span><span>required = </span><span>true</span>) taskComment:String<span>,<br/></span><span>         </span>model:Model):String {<br/>   <span>val </span>currentTask:Task? = <span>taskRepository</span>?.findById(taskId)?.get()<br/>   <span>if</span>(currentTask !=<span>null</span>) {<br/>      <span>val </span>principal = SecurityContextHolder.getContext().<span>authentication</span>.<span>principal<br/></span><span>      </span><span>if </span>(principal <span>is </span>CustomUserPrinciple) {<br/>         <span>val </span>user = <span>principal</span>.getUser()<br/>         <span>var </span>existingComments: MutableSet&lt;Comments&gt;? = <span>currentTask</span>.getComments()<br/>         <span>var </span>comment:Comments?<br/>         <span>if</span>(existingComments == <span>null </span>|| <span>existingComments</span>.isEmpty()) {<br/>            existingComments = <span>mutableSetOf</span>() <span>// Inmitialize empty hash set<br/></span><span>         </span>}<br/>            comment = Comments()<br/>            <span>comment</span>.setTask(<span>currentTask</span>)<br/>            <span>if</span>(user !=<span>null</span>) <span>comment</span>.setUser(<span>user</span>)<br/>            <span>comment</span>.setComment(taskComment)<br/>            comment = <span>commentRepository</span>?.save(<span>comment</span>)<br/>            <span>if</span>(comment !=<span>null</span>) {<br/>               <span>existingComments</span>.add(<span>comment</span>)<br/>            }<br/>            <span>currentTask</span>.setComments(<span>existingComments</span>)<br/>            <span>taskRepository</span>?.save(<span>currentTask</span>)<br/>      }<br/>   }<br/>   <span>return </span><span>"redirect:viewTask?taskId=</span><span>$</span>taskId<span>"<br/></span>}</pre>
<p>In this method, the <kbd>taskId</kbd> and <kbd>taskComment</kbd> parameters are supplied by the view task screen from where the user can add the comment. We fetch the <kbd>Task</kbd> object from <kbd>taskId</kbd> and fetch its comments as a mutable set.</p>
<p>Kotlin provides an <span>API</span> collection (list, set, map, and so on) with a clear distinction between mutable and immutable types. This is very handy to ensure you avoid bugs and design clear APIs. When you declare any collection, say, <kbd>List&lt;out T&gt;</kbd>, it is immutable by default and Kotlin allows read-only operations, such as <kbd>size()</kbd>, <kbd>get()</kbd>, and so on. You cannot add any element to it.</p>
<p>If you wish to modify the collection, you need to use mutable types explicitly, such as <kbd>MutableList&lt;String&gt;</kbd>, <kbd>MutableMap&lt;String, String&gt;</kbd>, and so on. In our case, we need to add a comment in the existing set so we used the <kbd>MutableSet</kbd> type. The comment set is empty while adding the first comment so we create an empty set with the <kbd>mutableSetOf()</kbd> method. This method is used to create a collection of the <kbd>Set</kbd> type on the fly.</p>
<p>We also need to add <kbd>userId</kbd> of the currently logged-in user to a comment. To do so, we make a call to <kbd>SecurityContextHolder.getContext().authentication.principal</kbd>. The <kbd>SecurityContextHolder</kbd> class is provided by Spring Security, and it is used to get various security-related information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting all users</h1>
                </header>
            
            <article>
                
<p>This method will return all users available in the system. It is used to create a task screen to fetch a user list to choose for a task assignment. The method is as follows:</p>
<pre><span>@GetMapping</span>(<span>"/getAllUsers"</span>)<br/><span>fun </span><span>getUsers</span>(model:Model):String{<br/>   <span>var </span>users: List&lt;User&gt;? = <span>userRepository</span>?.findAll() ?: <span>null;<br/></span><span>   </span>model.addAttribute(<span>"users"</span><span>,</span>users)<br/>   <span>return </span><span>"users"<br/></span>}</pre>
<p>We call it from the model popup in the add task screen. The UI will be rendered by the Thymeleaf template—<kbd>users.html</kbd><em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing a task list</h1>
                </header>
            
            <article>
                
<p>This method shows the list of tasks to both normal and admin users. The difference is a normal user can only view and add comments, while the admin user can view, edit, and delete operations on a task record. Another difference is a normal user can see a list of tasks assigned to it, while an admin user can see all tasks available in the system. The method should look as follows:</p>
<pre><span>@GetMapping</span>(<span>"/allTaskList"</span>)<br/><span>fun </span><span>showAllTaskList</span>(<span>@RequestParam</span>(<span>name = </span><span>"myTask"</span><span>,</span><span>required = </span><span>false</span>) myTask:String?<span>,<br/></span><span>               </span>model:Model):String{<br/>   <span>var </span>taskLst:  List&lt;Array&lt;Any&gt;&gt;? = <span>null<br/></span><span>   if</span>(<span>"true" </span>== myTask){<br/>      <span>//get current user ID from Spring context<br/></span><span>      </span><span>val </span>principal = SecurityContextHolder.getContext().<span>authentication</span>.<span>principal<br/></span><span>      </span><span>if </span>(principal <span>is </span>CustomUserPrinciple) {<br/>         <span>val </span>user = <span>principal</span>.getUser()<br/>         <span>if</span>(user !=<span>null</span>){<br/>            taskLst = <span>taskRepository</span>?.findMyTasks(<span>user</span>.getId() ?: <span>0</span>)<br/>         }<br/>         model.addAttribute(<span>"screenTitle"</span><span>,</span><span>"My Tasks"</span>)<br/>      }<br/>   }<span>else </span>{<br/>      taskLst = <span>taskRepository</span>?.findAllTasks()<br/>      model.addAttribute(<span>"screenTitle"</span><span>,</span><span>"All Tasks"</span>)<br/>   }<br/>   <span>val </span>taskDtoLst:MutableList&lt;TaskDTO&gt; = ArrayList()<br/>   <span>var </span>taskDto:TaskDTO?<br/>   <span>for</span>(row <span>in </span>taskLst.<span>orEmpty</span>()){<br/>      taskDto = TaskDTO(row[<span>0</span>] <span>as </span>Int<span>,</span>row[<span>1</span>] <span>as </span>String<span>,</span>row[<span>2</span>] <span>as </span>String<span>,<br/>       null, </span>row[<span>3</span>] <span>as </span>String<span>,</span>row[<span>4</span>] <span>as </span>String<span>,null</span>)<br/>      taskDtoLst.add(<span>taskDto</span>)<br/>   }<br/>   model.addAttribute(<span>"tasks"</span><span>,</span>taskDtoLst)<br/>   <span>return </span><span>"task-list"<br/></span>}</pre>
<p>This method serves two operations, based on the <kbd>myTask</kbd> request parameter. If it is available then pull the tasks assigned to current users only or else fetch all tasks. Fetching all tasks is available to the user with the admin role. After fetching the tasks from the database, we map them on to an object of the <kbd>TaskDTO</kbd> class. The <strong>data transfer object</strong> (<strong>DTO</strong>) is the Kotlin data class and looks as follows:</p>
<pre><span>class </span>TaskDTO( <span>var </span><span>id </span>:Int?<span>, var </span><span>title </span>: String?<span>,<br/></span><span>               var </span><span>detail </span>: String?<span>, var </span><span>assignedTo </span>: Int?<span>, <br/>               var </span><span>assignedPerson</span>:String?<span>, </span><span>var </span><span>status </span>: String?<span>, <br/>               var </span><span>comments </span>: Set&lt;Comments&gt;?)</pre>
<p>In the task list, we show the name of the user to whom the task is assigned. In the <kbd>task</kbd> table, we store <kbd>userId</kbd> , so we need to fetch the username by combining the task and user tables. Spring Data JAP provides a convenient way of fetching results of complex queries with the <kbd>@Query</kbd> annotation.</p>
<p>This annotation is used to define a query using JAP query language (and even native SQL query) and bind it to the method of the JPA repository. When we call that repository method, JPA will execute the query attached to that method with the <kbd>@Query</kbd> annotation. Let's define two methods with <span>join query</span><span> on a repository interface as follows:</span></p>
<pre><span>@Repository<br/></span><span>interface </span>TaskRepository : JpaRepository&lt;Task<span>,</span>Int&gt;{<br/><br/>    @Query("SELECT t.id, t.title, t.detail, concat(u.firstname,<br/>            ' ',u.lastname) as assignedTo ,t.status FROM task t <br/>            inner join users u on t.assigned_to = u.id",<br/>            nativeQuery = true)<br/>    fun findAllTasks(): List&lt;Array&lt;Any&gt;&gt;<br/><br/><span>    @Query</span>(<span>"SELECT t.id, t.title, t.detail, concat(u.firstname,<br/>            ' ',u.lastname) as assignedTo ,t.status FROM task t <br/>            inner join users u on t.assigned_to = u.id and <br/>            u.id =:userId"</span><span>,</span><span>nativeQuery = </span><span>true</span>)<br/><span>    fun </span><span>findMyTasks</span>(userId : Int): List&lt;Array&lt;Any&gt;&gt;<br/>}</pre>
<p>The first method will fetch all tasks available in the system, while the second method will fetch tasks that are assigned to a specific user only. The <kbd>nativeQery</kbd> attribute indicates that it is a SQL query. Since this query returns columns from multiple tables (<strong>task</strong> and <strong>users</strong> in our case), it returns a list of an array of the <kbd>Any</kbd> type, instead of a specific entity class object. The <kbd>List</kbd> object represents the records row, the elements of <kbd>Array</kbd> are columns, and <kbd>Any</kbd> means any available type in Kotlin. <kbd>Any</kbd> is equivalent to <kbd>Object</kbd> in Java.</p>
<p>It can be then used to populate the <kbd>TaskDTO</kbd> object in the controller method—<kbd>showAllTaskList</kbd>. The keyword <kbd>as</kbd> is used to do casting from <kbd>Any</kbd> to a respective type. Kotlin compiler uses smart cast so you don't need to explicitly check if the <kbd>Any</kbd> type given is compatible. For admin users, the task list screen looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/03c35fa4-fe75-44f5-8a64-7994e74c3498.png" style="width:57.08em;height:16.33em;"/></p>
<p>For the normal user, it looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7dae280f-8eba-41cd-9ecc-6d9e87392924.png" style="width:57.08em;height:9.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Viewing a task</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">view task</span> screen will open the task in view mode, meaning it will show the details of the task. It also allows you to add a comment and shows the list of comments added to the selected task. The controller method for viewing the task will populate the task and comment data, and redirects the user to view the task screen. The method looks as follows:</p>
<pre><span>@GetMapping</span>(<span>"/viewTask"</span>)<br/><span>fun </span><span>viewTask</span>(<span>@RequestParam</span>(<span>name = </span><span>"taskId"</span><span>,</span><span>required = </span><span>true</span>) <br/>                                        taskId:Int<span>,</span>model:Model):String{<br/>   <span>val </span>selectedTask:Task? = <span>taskRepository</span>?.findById(taskId)?.get()<br/>   <span>val </span>user:User? = <span>userRepository</span>?.<br/>                    findById(selectedTask?.getAssignedTo() ?: <span>0</span>)?.get()<br/><br/>   <span>val </span>taskDto= TaskDTO(selectedTask?.getId()<span>,</span>selectedTask?.getTitle()<span>,<br/></span><span>         </span>selectedTask?.getDetail()<span>,</span>selectedTask?.getAssignedTo()<span>,<br/></span><span>         </span>(user?.getFirstname() + <span>" "</span>+ user?.getLastname())<span>,<br/></span>         selectedTask?.getStatus()<span>,</span>selectedTask?.getComments())<br/>   <span>val </span>commentLst:  List&lt;Array&lt;Any&gt;&gt;? = <span>commentRepository</span>?.findByTaskId(taskId)<br/>   <span>val </span>commentDtoLst:MutableList&lt;CommentDTO&gt; = ArrayList()<br/>   <span>var </span>commentDto:CommentDTO?<br/>   <span>for</span>(row <span>in </span>commentLst.<span>orEmpty</span>()){<br/>      commentDto = CommentDTO(row[<span>0</span>] <span>as </span>Int<span>,</span>row[<span>1</span>] <span>as </span>String<span>,</span>row[<span>2</span>] <span>as </span>String)<br/>      commentDtoLst.add(<span>commentDto</span>)<br/>   }<br/>   model.addAttribute(<span>"task"</span><span>,</span>taskDto)<br/>   model.addAttribute(<span>"taskComments"</span><span>,</span>commentDtoLst)<br/>   model.addAttribute(<span>"screenTitle"</span><span>,</span><span>"Add Task Comment"</span>)<br/>   <span>return </span><span>"task-view"<br/></span>}</pre>
<p>The <kbd>taskId</kbd> parameter will be sent from a task list screen. First, we fetch the task detail from a given <kbd>taskId</kbd>. We also fetch the user data from the user ID associated with the <kbd>Task</kbd> object. For comments, we do the same thing: fetch comments with a given <kbd>taskId</kbd> from <kbd>commentRepository</kbd>. </p>
<p>We fetch comments from <kbd>commentRepository</kbd> , but we could have fetched it from the <kbd>Task</kbd> object, since they have one-to-many relationships. The reason we do not fetch them that way is, we want to show the username to whom the task is assigned. If we fetch comments from <kbd>Task</kbd>, it will return the collection of the object of the <kbd>Comments</kbd> type, which has a user ID but not first and last name. So we might have to make an additional round of database calls to fetch the user first and last name for each comments record. This may result in a poor performance. </p>
<p>As an alternative, we use a JPA query language mechanism, by associating the <kbd>join</kbd> SQL query with the repository method as follows:</p>
<pre><span>interface </span>CommentRepository: JpaRepository&lt;Comments<span>, </span>Int&gt; {<br/><br/>    <span>@Query</span>(<span>"SELECT c.id, c.comment, concat(u.firstname,' ',u.lastname) <br/>           FROM comments c inner join users u on c.user_id=u.id inner join task t <br/>           on t. id = c.task_id and t.id =:taskId"</span><span>,</span><span>nativeQuery = </span><span>true</span>)<br/>    <span>fun </span><span>findByTaskId</span>(taskId: Int):List&lt;Array&lt;Any&gt;&gt;<br/>}</pre>
<p>It is returned as a <kbd>List&lt;Array&lt;Any&gt;&gt;</kbd> type because the data is fetched from multiple tables (<strong>task</strong> and <strong>comments</strong>). We are iterating it and populating the list of <kbd>CommentDTO</kbd> , which is defined as a data class as follows:</p>
<pre><span>data class </span>CommentDTO(<span>var </span><span>id</span>:Int<span>,var </span><span>comment</span>:String<span>,var </span><span>userName</span>:String)</pre>
<p>The  <kbd>TaskDTO</kbd> object is used to show task details while the list of <kbd>CommentDTO</kbd> is used to show comments in tabular format in the <span class="packt_screen">view task</span> screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a task</h1>
                </header>
            
            <article>
                
<p>Only admin users can delete an existing task. The delete option is visible in the task list screen. The controller method of deleting a task looks as follows:</p>
<pre><span>@PostMapping</span>(<span>"/deleteTask"</span>)<br/><span>fun </span><span>deleteTask</span>(<span>@RequestParam</span>(<span>name = </span><span>"taskId"</span><span>,</span><span>required = </span><span>true</span>) taskId:Int<span>,</span>model:Model):String{<br/>   <span>var </span>selectedTask:Task? = <span>taskRepository</span>?.findById(taskId)?.get()<br/>   <span>if</span>(selectedTask !=<span>null</span>) {<br/>      <span>taskRepository</span>?.delete(<span>selectedTask</span>)<br/>   }<br/>   <span>return </span><span>"redirect:allTaskList"<br/></span>}</pre>
<p>The <kbd>taskId</kbd> parameter is provided in the task list screen. First, we fetch the object of <kbd>Task</kbd> with <kbd>taskId</kbd> from <kbd>taskRepository</kbd> and delete if it is not null. Finally, we redirect to another controller method with the <kbd>/allTaskList</kbd> URL to show the task list screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST call in Kotlin</h1>
                </header>
            
            <article>
                
<p>Let's understand how to make a REST call with Kotlin. We expose the REST API to add users to the system. Basic user details along with role information need to be given. Defining REST controller in Kotlin is similar to Java as follows:</p>
<pre><span>@RestController<br/></span><span>@RequestMapping</span>(<span>"/api"</span>)<br/><span>class </span>TaskMgmntRESTController {<br/>...<br/>}</pre>
<p>The <kbd>TaskMgmntRESTController</kbd> Kotlin class is defined as a REST controller with <kbd>@RestController</kbd> and configures the <kbd>/api</kbd> URL pattern with the <kbd>@RequestMapping</kbd> annotation. We will write a function that handles the registration of users as follows:</p>
<pre><span>@PostMapping</span>(<span>value = </span><span>"/register"</span><span>, </span><span>consumes = </span>[MediaType.<span>APPLICATION_JSON_VALUE</span>])<br/><span>fun </span><span>registerNewUser</span>(<span>@Valid @RequestBody </span>userRegistrationDto: UserRegistrationDTO<span>, <br/></span><span>                                    </span>errors: Errors): ResponseEntity&lt;List&lt;String&gt;&gt; {<br/>          // registration code...<br/>}</pre>
<p>This function is defined with the <kbd>@PostMapping</kbd> <span>annotation </span>so data must be sent with the HTTP POST method. Also, the URL mapping is <kbd>/register</kbd> so the effective path would be <kbd>/api/register</kbd> to access this function (method). It consumes the data in JSON format. Spring will populate an object of <kbd>UserRegistrationDTO</kbd> from the JSON input. The Kotlin data class is as follows:</p>
<pre><span>data class </span>UserRegistrationDTO(<span>var </span><span>username</span>:String<span>, var </span><span>password</span>:String<span>,<br/></span><span>                               var </span><span>firstname</span>:String<span>, var </span><span>lastname</span>:String<span>,<br/></span><span>                               var </span><span>roleList</span>:List&lt;String&gt;)</pre>
<p>The <kbd>username</kbd>, <kbd>password</kbd>, <kbd>firstname</kbd>, and <kbd>lastname</kbd> attributes are used to insert a record in the user table, while the <kbd>roleList</kbd> attribute is used to associate the roles this user has. The input data must be given in JSON format with the HTTP <span>POST </span>method from the REST client as follows:</p>
<pre>{<br/>  "username":"dav",<br/>  "password":"test",<br/>  "firstname":"Dav",<br/>  "lastname":"Patel",<br/>  "roleList":["ROLE_USER","ROLE_ADMIN"]<br/>}</pre>
<p>The code written in the <kbd>registerNewUser</kbd> method will be divided into the following two parts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validation</h1>
                </header>
            
            <article>
                
<p>A user sends the data in JSON format and it must be validated before entering into the system to avoid any backend errors. Instead of imposing a full list of validations, we will implement a few basic validations. For example, validating an existing username,the role list has invalid values other than <kbd>ROLR_USER</kbd> and <kbd>ROLE_ADMIN</kbd>. The code looks as follows:</p>
<pre><span>if </span>(userRegistrationDto.<span>username </span>!= <span>null</span>) {<br/>    <span>var </span>existingUser : User? = <span>userRepository</span>?.findByUsername(<br/>                                            userRegistrationDto.<span>username</span>) <span><br/></span><span>    </span><span>if </span>(existingUser != <span>null</span>) {<br/>        errors.reject(<span>"Existing username"</span><span>,</span><span>"User is already exist with username <br/>                                        '</span><span>${</span>userRegistrationDto.<span>username</span><span>}</span><span>'. "</span>)<br/>    }<br/>}<br/><span>if</span>( userRegistrationDto.<span>roleList</span>.isEmpty()){<br/>    errors.reject(<span>"No Roles provided"</span><span>,</span><span>"Please provide roles"</span>)<br/>}<span>else</span>{<br/>    <span>var </span>validRole = <span>true<br/></span><span>    var </span>invalidRole:String?=<span>null<br/></span><span>    for</span>(roleName <span>in </span>userRegistrationDto.<span>roleList</span>){<br/>        <span>if</span>(!TaskMgmntConstant.getRolesLst().contains(roleName)){<br/>            validRole=<span>false<br/></span><span>            </span>invalidRole = roleName<br/>            <span>break<br/></span><span>        </span>}<br/>    }<br/>    <span>if</span>(!validRole){<br/>        errors.reject(<span>"Invalid Roles"</span><span>,</span><span>" </span><span>$</span>invalidRole<span> is not a valid role"</span>)<br/>    }<br/>}<br/><span>if </span>(errors.hasErrors()) {<br/>    <span>val </span>errorMsg = ArrayList&lt;String&gt;()<br/>    errors.<span>allErrors</span>.<span>forEach </span><span>{ </span>a <span>-&gt; </span>errorMsg.add(a.<span>defaultMessage </span>?: <span>""</span>)<br/>    <span>}<br/></span><span>    </span><span>return </span>ResponseEntity(errorMsg<span>, </span>HttpStatus.<span>BAD_REQUEST</span>)<br/>} <span>else </span>{<br/> // .. User Registration code goes here<br/>}</pre>
<p>First, we check whether the username sent in JSON data already exists in the system. If it does, then return an appropriate message. The second check is about the role list. We have created a predefined role list in the <kbd>TaskMgmntConstant</kbd> class with the function declaration as follows:</p>
<pre><span>object </span>TaskMgmntConstant {<br/>   <span>const val </span><span>ROLE_USER </span>:String = <span>"ROLE_USER"<br/></span><span>   </span><span>const val </span><span>ROLE_ADMIN </span>:String = <span>"ROLE_ADMIN"<br/><br/></span><span>   //... Other constant declaration<br/><br/></span><span>   </span><span>fun </span><span>getRolesLst</span>():List&lt;String&gt;{<br/>      <span>return </span><span>listOf</span>(<span>ROLE_ADMIN</span><span>, </span><span>ROLE_USER</span>)<br/>   }<br/>}</pre>
<p>Let's recall that <kbd>TaskMgmntConstant</kbd> is singleton class and we can define functions apart from constants. If the <kbd>roleList</kbd> data sent as a JSON string is different than these two roles, then we show an appropriate message. You can see how a for-loop is used by the <kbd>forEach</kbd> method with a lambda expression. If any error occurs, we send a validation message with HTTP status 401 (<kbd>HttpStatus.BAD_REQUEST</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User registration</h1>
                </header>
            
            <article>
                
<p>If all validations are satisfied, then we will do user registration along with role mapping with the following code:</p>
<pre><span>val </span>userEntity = User()<br/>userEntity.setUsername(userRegistrationDto.<span>username</span>)<br/>userEntity.setEnabled(<span>true</span>)<br/><span>val </span>encodedPassword = <span>passwordEncoder</span>?.encode(userRegistrationDto.<span>password</span>)<br/>userEntity.setPassword(encodedPassword ?: <span>""</span>)<br/>userEntity.setFirstname(userRegistrationDto.<span>firstname</span>)<br/>userEntity.setLastname(userRegistrationDto.<span>lastname</span>)<br/><br/><span>var </span>role:Role?=<span>null<br/></span><span>var </span>roles: MutableSet&lt;Role&gt; = <span>mutableSetOf</span>()<br/><span>for</span>(roleName <span>in </span>userRegistrationDto.<span>roleList</span>){<br/>    role = <span>roleRepository</span>?.findByRole(roleName)<br/>    <span>if</span>(role !=<span>null</span>) {<br/>        roles.add(<span>role</span>)<br/>    }<br/>}<br/>userEntity.setRoles(roles)<br/><span>userRepository</span>?.save(userEntity)<br/><br/><span>val </span>msgLst = Arrays.asList(<span>"User registered successfully"</span>)<br/><span>return </span>ResponseEntity(msgLst<span>, </span>HttpStatus.<span>OK</span>)</pre>
<p>In this code, we create the <kbd>User</kbd> object and populate its value from the <kbd>UserRegistrationDTO</kbd> object. We also create the mutable role list and populate it by fetching roles with <kbd>roleRepository</kbd> , based on the role name populated in <kbd>UserRegistrationDTO</kbd> from the JSON data. Finally, we associate the mutable set with the <kbd>User</kbd> object and save it in <kbd>userRepository</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned the basics of Kotlin and its various features, and then created an application with Spring Boot and Kotlin. Within a short time span, Kotlin has gained huge momentum and popularity due to its capabilities, such as its interoperability, conciseness, safety features, and support for well-known IDEs. </p>
<p>Spring Framework has lots of features and is widely used in developing modern enterprise applications. With its first class support of various programming languages such as Java, Scala, Groovy, and Kotlin, Spring Framework has become a dominant player among enterprise-application development frameworks.</p>
<p>Spring Framework has a modular design and provides seamless integration in all aspects of the system, such as the frontend, controller layer, security, persistence, cloud support, messaging support, web flow, and lots more. With the invention of Spring Boot, developing Spring-based applications has become easier than ever before. </p>
<p>Throughout this book, we have explored the Spring Framework, showcasing its capabilities by developing a sample application in each chapter. This should definitely build your confidence and encourage you to explore the framework further. However, we recommend you create more sample apps so that you gain more hands-on experience and you really get the most out of the framework.</p>
<p>Here is a perfect way to finish our journey. For further reading, you can refer to the official Spring documentation and forums. Spring has a huge active community, and you can find many personal blogs that will help you to learn and explore the concepts. </p>


            </article>

            
        </section>
    </body></html>