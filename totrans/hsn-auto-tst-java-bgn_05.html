<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Everything You Need to Know About Interfaces and Inheritance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we will go through some important concepts, such as interfaces, how they work, and their usage in Java. We will discuss inheritance using a practical example. This chapter will also look at the concepts of function overloading and function overriding and the differences between them.</p>
<p class="mce-root">We will cover the following topics in this chapter:</p>
<ul class="calibre13">
<li class="calibre14">Interfaces</li>
<li class="calibre14">Introduction to inheritance</li>
<li class="calibre14">Function overloading</li>
<li class="calibre14">Function overriding</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Interfaces</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The interface is one of the core concepts used in Java OOPS, so it's necessary for us to familiarize ourselves with interfaces and their use.</p>
<p class="mce-root">Interfaces are similar to classes. The only difference between an interface and a class is that an interface will have methods but not a body. Confused? In a class, we generally define a method and then start writing code into it. For example, in a class, if we want to write any code, we just start off by declaring the class using <kbd class="calibre16">public void</kbd> and proceed with the rest of the code in that class, as follows:</p>
<pre class="calibre21">public void getData()<br class="calibre2"/>{<br class="calibre2"/>}</pre>
<p class="mce-root">In interfaces, we can only define the signature of the method; we cannot write any code inside the method. But why? What is the use of writing a method signature inside an interface? What is the use of this object-oriented concept in Java? You might have these questions in your mind, so let's try to understand the concept of the interface with a real-life scenario.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using interfaces with a traffic light system</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Consider the typical traffic light system, which is used everywhere around the world to maintain traffic regulations. Every country has its own traffic rules, such as driving on the left or right side of the road. Even though traffic rules differ from country to country, there are certain rules that apply globally and need to be followed by every country. One such rule is the use of traffic lights to govern the traffic flow, where a red light is an indication to stop, an amber/yellow light to ready your engine, and a green light to move your vehicle. Let's say that these global rules are imposed by a central traffic authority, and we want to implement, for example, the Australian traffic system. This system will have its own rules, but we need to make sure that it follows the global rules imposed by the central traffic authority.</p>
<p class="mce-root">Using this example, we'll try to understand the concept of interfaces. Here, the central traffic authority acts as an interface and the Australian traffic rules act as a class that implements the interface; that is, the Australian traffic system will have to follow the rules/methods mentioned in the central traffic authority interface. The methods defined in any interface are just signatures, so the classes will define and implement the methods present in an interface. Let's look at this example in our Java code.</p>
<p class="mce-root">We define an interface in the same way that we define a class. In this traffic light example, let's name the class as <kbd class="calibre16">CentralTraffic</kbd>. We now have a ready interface, as follows:</p>
<pre class="calibre21">package demopack;<br class="calibre2"/><br class="calibre2"/>public interface CentralTraffic {<br class="calibre2"/><br class="calibre2"/>    public void greenGo();<br class="calibre2"/>    public void redStop();<br class="calibre2"/>    public void FlashYellow();<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">We can see in the syntax that instead of <kbd class="calibre16">class</kbd> we have <span class="calibre9">written </span><kbd class="calibre16">interface</kbd><span class="calibre9">. We define a method in the interface using the same method that we use to define a method in a class, but remember that we cannot have a method body defining the method as this is an interface, and doing so will throw an error. Create another class to implement this interface and name it</span> <kbd class="calibre16">AustralianTraffic</kbd><span class="calibre9">. Once we have a Java class, we need to implement the</span> <kbd class="calibre16">CentralTraffic</kbd> <span class="calibre9">interface to it, and we do that using the</span> <kbd class="calibre16">implements</kbd> <span class="calibre9">keyword, as follows:</span></p>
<pre class="calibre21">public class AustralianTraffic implements CentralTraffic {</pre>
<p class="mce-root">After using the preceding sentence, our IDE will show an error, and when you hover over the error, you'll see some suggestions related to the error. One suggestion would be to import <kbd class="calibre16">CentralTraffic</kbd>, and another would be to add unimplemented methods. Click on these suggestions to resolve the error and you should end up with the following code:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/>import demopack.CentralTraffic;<br class="calibre2"/>public class AustralianTraffic implements CentralTraffic {<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>    <br class="calibre2"/>    }<br class="calibre2"/>    @Override<br class="calibre2"/>    public void greenGo() {<br class="calibre2"/>        // TODO Auto-generated method stub<br class="calibre2"/>        System.out.println(" greengo implementation")<br class="calibre2"/>    }<br class="calibre2"/>    @Override<br class="calibre2"/>    public void redStop() {<br class="calibre2"/>        // TODO Auto-generated method stub<br class="calibre2"/>        System.out.println(" redstop implementation")<br class="calibre2"/>    }    <br class="calibre2"/>    @Override<br class="calibre2"/>    public void FlashingYellow() {<br class="calibre2"/>        // TODO Auto-generated method stub<br class="calibre2"/>        System.out.println(" flash yellow implementation")<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">All the methods defined in the <kbd class="calibre16">CentralTraffic</kbd> interface can be seen in the <kbd class="calibre16">AustralianTraffic</kbd> class, and here we can also implement these methods as we wish. Now, if we remove the <kbd class="calibre16">greenGo</kbd> method from our Java class, it'll give us an error. As it is a method defined in an interface, it is mandatory for us to implement all the methods defined in the interface.</p>
<p class="mce-root">The interface methods are defined outside <kbd class="calibre16">public static void main</kbd>, and to execute these methods, we should create a class object for them in the <kbd class="calibre16">main</kbd> method, as follows:</p>
<pre class="calibre21">        CentralTraffic a= new AustralianTraffic();</pre>
<p class="mce-root">This line of code says that we have created an object for the <kbd class="calibre16">AustralianTraffic</kbd> class to implement the methods present in the <kbd class="calibre16">CentralTraffic</kbd> interface. The main class should look as follows:</p>
<pre class="calibre21">public class AustralianTraffic implements CentralTraffic {<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>    CentralTraffic a= new AustralianTraffic();<br class="calibre2"/>    a.redStop();<br class="calibre2"/>    a.FlashYellow();<br class="calibre2"/>    a.greenGo();    <br class="calibre2"/>    }</pre>
<p class="mce-root">Now, after implementing the methods from the interface, we can define our own country-specific methods (rules) in our Java class, as follows:</p>
<pre class="calibre21">public void walkonsymbol()<br class="calibre2"/>{<br class="calibre2"/>    System.out.println("walking");<br class="calibre2"/>} </pre>
<p class="mce-root">In our <kbd class="calibre16">main</kbd> method, if we try calling our country-specific method using <kbd class="calibre16">a.</kbd>, like we did for the other methods in the <kbd class="calibre16">main</kbd> class, then we will find that we won't be able to do so because the <kbd class="calibre16">walkonsymbol</kbd> method is specific to a particular country (that is, the <kbd class="calibre16">AustralianTraffic</kbd> class) and it's not implemented in <kbd class="calibre16">CentralTraffic</kbd>. For the <kbd class="calibre16">walkonsymbol</kbd> method, we need to create another object in the <kbd class="calibre16">main</kbd> class specific to the <kbd class="calibre16">AustralianTraffic</kbd> class, as follows:</p>
<pre class="calibre21">        AustralianTraffic at=new AustralianTraffic();<br class="calibre2"/>        at.walkonsymbol();</pre>
<p class="mce-root">Another piece of information related to the interface is that a class can implement more than one interface. Let's say that we create another interface, such as <kbd class="calibre16">ContinentalTraffic</kbd>, and define another rule related to traffic lights, such as a train symbol to indicate that a train is passing by. We can implement this interface in our <kbd class="calibre16">AustralianTraffic</kbd> class simply by adding a comma, as follows:</p>
<pre class="calibre21">public class AustralianTraffic implements CentralTraffic, ContinentalTraffic {</pre>
<p class="mce-root">For this interface, we need to follow the same steps as we did for the <kbd class="calibre16">CentralTraffic</kbd> interface, such as importing <kbd class="calibre16">ContinentalTraffic</kbd> to <kbd class="calibre16">AustralianTraffic</kbd>, adding unimplemented methods, creating an object specific to <kbd class="calibre16">ContinentalTraffic</kbd> in the main class, and so on.</p>
<p class="mce-root">Now you have a fair idea of the differences between an interface and a class. We learned how to define the interfaces, how to implement them within another class, and how to call them using objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Inheritance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Inheritance is another important OOP concept in Java. Let's take an example of a vehicle to understand the concept of inheritance, just like we did in using the example of a traffic light system to understand interfaces. The basic properties of a vehicle are its color, gears, mirrors, brakes, and so on. Let's say that we are making a new vehicle with certain advancements to some of these properties, such as an engine with a higher CC, and maybe a different design than the old one. Now, to create a new vehicle with these new features, we still need the basic features of the old vehicle, such as mirrors and brakes, which are present in vehicles by default. </p>
<p class="mce-root">Let's take the preceding example and use Java to reflect these relationships in order to understand the concept of inheritance. In our example, if we have a class for a vehicle and enter the basic features of the vehicle as methods that are present in that class, then when we create a class for a new vehicle, it can inherit the features of the class that is created for the vehicle, and we don't have to write the code for these features as they are available to us via inheritance.</p>
<p class="mce-root">Let's get started with the code. Create a <kbd class="calibre16">parentClassdemo</kbd> class, which will be our parent class. In this class, we will define our methods, as follows:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/>public class parentClassdemo {<br class="calibre2"/>    <br class="calibre2"/>    String color = "red";<br class="calibre2"/>    <br class="calibre2"/>    public void Gear()<br class="calibre2"/>    {<br class="calibre2"/>        System.out.println("gear code is implemented");<br class="calibre2"/>    }<br class="calibre2"/>    public void Brakes()<br class="calibre2"/>    {<br class="calibre2"/>        System.out.println("brakes code is implemented");<br class="calibre2"/>    }<br class="calibre2"/>    public void audiosystem()<br class="calibre2"/>    {<br class="calibre2"/>        System.out.println("audiosystem code is implemented");<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">We will now inherit these methods in our child class. Create a <kbd class="calibre16">childClassDemo</kbd> in Java. We inherit the parent class using the <kbd class="calibre16">extends</kbd> keyword, as follows:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/>public class childClassDemo extends parentClassdemo {<br class="calibre2"/><br class="calibre2"/>    public void engine()<br class="calibre2"/>    {<br class="calibre2"/>        System.out.println("new engine");<br class="calibre2"/>    }<br class="calibre2"/>    public void color<br class="calibre2"/>    {<br class="calibre2"/>        System.out.println(color);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>        childClassDemo cd=new childClassDemo();<br class="calibre2"/>        cd.color();<br class="calibre2"/>    }</pre>
<p class="mce-root">Here, we inherited the <kbd class="calibre16">parentClassdemo</kbd> class in the <kbd class="calibre16">childClassDemo</kbd> class using the <kbd class="calibre16">extends</kbd> keyword. In this <kbd class="calibre16">childClassDemo</kbd> class, we defined our own <kbd class="calibre16">engine</kbd> method and used the <kbd class="calibre16">color</kbd> method, which we inherited from the <kbd class="calibre16">parentClassdemo</kbd> class. We then created a <kbd class="calibre16">cd</kbd> object and used it to call the methods from the inherited class. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">More on inheritance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's discuss some notorious tricky questions and misconceptions regarding inheritance in Java. </p>
<p class="mce-root">Let's get started with some of the more well-known questions asked concerning inheritance. Take a look at the following block of code:</p>
<pre class="calibre21">class X<br class="calibre2"/>{<br class="calibre2"/>    //Class X members<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>class Y<br class="calibre2"/>{<br class="calibre2"/>    //Class Y members<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>class Z extends X, Y<br class="calibre2"/>{<br class="calibre2"/>    //Class Z members<br class="calibre2"/>}</pre>
<p class="mce-root">In the preceding code snippet, we have the <kbd class="calibre16">X</kbd> and <kbd class="calibre16">Y</kbd> class and some data fields or methods inside it. The <kbd class="calibre16">Z</kbd> class inherits the <kbd class="calibre16">X</kbd> and <kbd class="calibre16">Y</kbd> classes. Is this allowed? The answer is no. Java does not allows multiple inheritances, whereas it is allowed in C++. So here, we can conclude that the preceding code snippet is not right and will throw an error.</p>
<p class="mce-root">This is also one of the differences between inheritance and interfaces, as an interface allows us to use multiple interfaces at a time.</p>
<p class="mce-root">Take a look at the following example:</p>
<pre class="calibre21">class A<br class="calibre2"/>{<br class="calibre2"/>    int i = 10;<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>class B extends A<br class="calibre2"/>{<br class="calibre2"/>    int i = 20;<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>public class MainClass<br class="calibre2"/>{<br class="calibre2"/>    public static void main(String[] args)<br class="calibre2"/>    {<br class="calibre2"/>        A a = new B();<br class="calibre2"/>        System.out.println(a.i);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre9">Here, we have an <kbd class="calibre16">A</kbd> </span><span class="calibre9">class</span> <span class="calibre9">and it has an</span> <kbd class="calibre16">i</kbd> <span class="calibre9">variable</span><span class="calibre9">. There is also a</span> <kbd class="calibre16">B</kbd> <span class="calibre9">class</span> <span class="calibre9">that extends the</span> <kbd class="calibre16">A</kbd> <span class="calibre9">class</span><span class="calibre9">, and we also have its local</span> <kbd class="calibre16">i</kbd> <span class="calibre9">variable set</span> <span class="calibre9">as</span> <kbd class="calibre16">20</kbd><span class="calibre9">. Now, in</span> <kbd class="calibre16">MainClass</kbd><span class="calibre9">, we create an object for the</span> <kbd class="calibre16">B</kbd> <span class="calibre9">class</span><span class="calibre9">. What does this step actually mean? Here, we are creating an object and saying that this object of this</span> <kbd class="calibre16">B</kbd> <span class="calibre9">class</span> <span class="calibre9">should refer to the properties of the</span> <kbd class="calibre16">A</kbd> <span class="calibre9">class</span><span class="calibre9">. Though we have permission to access this</span> <kbd class="calibre16">B</kbd> <span class="calibre9">class</span> <span class="calibre9">through this</span> <kbd class="calibre16">a</kbd> <span class="calibre9">object</span><span class="calibre9">, we can only access the properties or methods of the</span> <kbd class="calibre16">A</kbd> <span class="calibre9">class</span><span class="calibre9">, because the</span> <kbd class="calibre16">B</kbd> <span class="calibre9">class</span> <span class="calibre9">has permission to access the</span> <kbd class="calibre16">A</kbd> <span class="calibre9">class here, as we are extending it.</span></p>
<p class="mce-root"><span class="calibre9">The question here is what will <kbd class="calibre16">a.i</kbd> print—<kbd class="calibre16">20</kbd> or <kbd class="calibre16">10</kbd>? The answer is, it will print the </span><span class="calibre9">variable value of</span> <kbd class="calibre16">10</kbd><span class="calibre9">, as </span><kbd class="calibre16">A a = new B();</kbd><span class="calibre9"> explicitly tells <kbd class="calibre16">a</kbd> that it is an object of the</span> <kbd class="calibre16">B</kbd> <span class="calibre9">class,</span><span class="calibre9"> but we need to access the methods present in the</span> <kbd class="calibre16">A</kbd> <span class="calibre9">class</span><span class="calibre9">. If we want this output as</span> <kbd class="calibre16">20</kbd><span class="calibre9">, we change the syntax to </span><kbd class="calibre16">B a = new B();</kbd><span class="calibre9">. </span></p>
<p class="mce-root"><span class="calibre9">You may get such questions if you attend Java quizzes or a complex inter</span>view. These are the important pieces of information that you ha<span class="calibre9">ve to know regarding inheritance, and you can plan accordingly.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Function overloading</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Function overloading happens when a class has multiple methods with the same name. If we define a <kbd class="calibre16">getData</kbd> method twice in our class, we can say that the <kbd class="calibre16">getData</kbd> function is overloaded, as shown in the following code:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/>//function overloading<br class="calibre2"/>public class childlevel extends childClassDemo {<br class="calibre2"/><br class="calibre2"/>    public void getData(int a)<br class="calibre2"/>    {<br class="calibre2"/>     <br class="calibre2"/>    }<br class="calibre2"/>    public void getData(String a)<br class="calibre2"/>    {<br class="calibre2"/>     <br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>        childlevel cl=new childlevel();<br class="calibre2"/>        cl.getData(2);<br class="calibre2"/>        cl.getData("hello")<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">There are a few rules that we need to remember while using multiple instances of a function with the same name. The first rule is that the number of arguments present in the function-overloaded method should be different, and the second is that the argument data type should be different. If we keep both the <kbd class="calibre16">getData</kbd> methods with the <kbd class="calibre16">int a</kbd> <span class="calibre9">argument, it will throw an error, so we need to have a different number of arguments for each method. Now, when you print these, you'll get the outputs of <kbd class="calibre16">2</kbd> and <kbd class="calibre16">hello</kbd>. We can see that two different arguments are printed, but with the same method name. Let's add one more <kbd class="calibre16">getData</kbd> instance with two arguments, as follows:</span></p>
<pre class="calibre21">    public void getData(int a, int b)<br class="calibre2"/>    {<br class="calibre2"/>     <br class="calibre2"/>    }</pre>
<p class="mce-root">We now have two instances of <kbd class="calibre16">getData</kbd> with the same data type, but the number of arguments varies. </p>
<p class="mce-root">You might come across function overloading in the real world as well, such as when you are asked for the payment method in an e-commerce website in patches. T<span class="calibre9">he website might use different</span> <kbd class="calibre16">getPayment</kbd><span class="calibre9"> </span><span class="calibre9">methods to</span><span class="calibre9"> confirm the payment—</span><span class="calibre9">one</span> <kbd class="calibre16">getPayment</kbd> <span class="calibre9">method takes a debit card as an argument, another</span> <kbd class="calibre16">getPayment</kbd> <span class="calibre9">method takes a credit card as an argument, and another</span> <kbd class="calibre16">getPayment</kbd> <span class="calibre9">might take a gift card as an argument. So </span><span class="calibre9">we pass different kinds of arguments </span><span class="calibre9">to the same</span> <kbd class="calibre16">getPayment</kbd> <span class="calibre9">method. In this case, we stick to</span> <kbd class="calibre16">getPayment</kbd> <span class="calibre9">as a method name and pass it different arguments, bringing the </span><span class="calibre9">concept of</span><span class="calibre9"> </span><span class="calibre9">function overloading to this particular scenario.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Function overriding</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this section, let's discuss one more important feature in Java—is function overriding. Let's continue with the same example that we looked at when learning about inheritance.</p>
<p class="mce-root">In that example, we had a parent class called <kbd class="calibre16">parentClassdemo</kbd> and a child class called <kbd class="calibre16">childClassDemo</kbd>, and the child class inherited the parent class, as follows:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/>public class childClassDemo extends parentClassdemo {<br class="calibre2"/><br class="calibre2"/>    public void engine()<br class="calibre2"/>    {<br class="calibre2"/>        System.out.println("new engine");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>        childClassDemo cd=new childClassDemo();<br class="calibre2"/>        cd.color();<br class="calibre2"/>    }</pre>
<p class="mce-root">Here, we have the <kbd class="calibre16">engine</kbd> method defined in the child class, which prints a new engine, and we have another method, <kbd class="calibre16">color</kbd>, which is defined in the parent class, and we call it using an object. If we print this, we will get the output of the <kbd class="calibre16">color</kbd> method, as it is defined in the parent class. Now, we create a new method in the child class and name it <kbd class="calibre16">color</kbd> as well, defining it as follows:</p>
<pre class="calibre21">    public void color()<br class="calibre2"/>    {<br class="calibre2"/>        System.out.println("update color");<br class="calibre2"/>    }</pre>
<p class="mce-root">We have two instances of the <kbd class="calibre16">color</kbd> method—one defined in the parent class and a new one defined in the child class. Here is where the concept of function overriding comes into action. If you run the child class, you will get the output of <kbd class="calibre16">update color</kbd>. This is because the new <kbd class="calibre16">color</kbd> method defined in the child class overrides the <kbd class="calibre16">color</kbd> method from the parent class.</p>
<p class="mce-root">This sums up the whole concept of function overriding, where both the methods have the same name, signature, and parameters. In function overloading, we have methods that have the same name, but different arguments. This, one of the major differences between function overloading and function overriding.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we were introduced to some important Java OOP concepts, such as interfaces, inheritance, function overloading, and function overriding. We looked at each concept using an example, which helped us better understand the concepts in detail.</p>
<p class="mce-root">In the next chapter <span class="calibre9">we will take a look at one of the most important concept in Java code: arrays. We'll see how different arrays look, and how to initialize and display them.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>