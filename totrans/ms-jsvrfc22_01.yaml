- en: Chapter 1. Dynamic Access to JSF Application Data through Expression Language
    (EL 3.0)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java **Expression Language** (**EL**) is a compact and powerful mechanism that
    enables dynamic communication in JSP and JSF-based applications (including development
    frameworks based on JSF such as PrimeFaces, ICEfaces, and RichFaces); we embed
    expressions in the presentation layer to communicate with the application logic
    layer. EL provides bidirectional communication, which means that we can expose
    application logic data to the user, but we also can submit user data to be processes.
    Generically speaking, EL can be used to populate HTTP requests with user data,
    to extract and expose data from HTTP responses, to update HTML DOM, to conditionally
    process data, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commonly, EL expressions will be present in JSP and JSF pages, but they can
    also appear outside, in `faces-config.xml`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will see how to use EL in web pages to communicate with
    managed beans, which is the most common case in JSF applications. We will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: EL syntax, operators, and reserved words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EL immediate and deferred evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EL value and method expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional text in JSF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a custom EL resolver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EL syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you can see an overview of the main aspects of EL 2.2 and 3.0
    syntax. EL supports a handful of operators and reserved words. Each of these are
    quickly described in the following section (more details are in the EL specification
    document ([http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html](http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html))).
  prefs: []
  type: TYPE_NORMAL
- en: EL operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EL supports the following categories of operators—arithmetic, relational, logical,
    conditional, empty and added starting with EL 3.0, string concatenation, assignment
    and semicolon operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Textuals | Description | Symbols |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A `+` B | Addition | `+` |'
  prefs: []
  type: TYPE_TB
- en: '| A `-` B | Subtraction | `-` |'
  prefs: []
  type: TYPE_TB
- en: '| A `*` B | Multiplication | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`div`, `/`} B | Arithmetic operator division | /, `div` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`mod`, `%`} B | Arithmetic operator modulo | `%`, `mod` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`and`, `&&`} B | Logical AND | `&&`, `and` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`or`, `&#124;&#124;`} B | Logical OR | `&#124;&#124;`, `or` |'
  prefs: []
  type: TYPE_TB
- en: '| {`not`, `!`} A | Logical opposite | `!`, `not` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`lt`, `<`} B | Relational less than | `<`, `lt` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`gt`, `>`} `B` | Relational greater than | `>`, `gt` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`le`, `<=`} B | Relational less than or equal to | `<=`, `le` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`ge`, `>=`} B | Relational greater than or equal to | `>=`, `ge` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`eq`, `==`} B | Equal to | `==`, `eq` |'
  prefs: []
  type: TYPE_TB
- en: '| A {`ne`, `!=`} B | Not equal to | `!=`, `ne` |'
  prefs: []
  type: TYPE_TB
- en: '| A `=` B | Assignment (EL 3.0) | `=` |'
  prefs: []
  type: TYPE_TB
- en: '| A `;` B | Semicolon (EL 3.0) | `;` |'
  prefs: []
  type: TYPE_TB
- en: '| A `+=` B | String concatenation (EL 3.0) | `+=` |'
  prefs: []
  type: TYPE_TB
- en: '| A `->` B | Lambda expression (EL 3.0) | `->` |'
  prefs: []
  type: TYPE_TB
- en: '| `empty` A | Determine whether a value is null or empty |   |'
  prefs: []
  type: TYPE_TB
- en: '| A `?` B `:` C | Evaluates B or C, depending on the result of the evaluation
    of A. Known as the **ternary operator**. | ?: |'
  prefs: []
  type: TYPE_TB
- en: '|   | Used when writing EL expressions | `.` |'
  prefs: []
  type: TYPE_TB
- en: '|   | Used when writing EL expressions | `[]` |'
  prefs: []
  type: TYPE_TB
- en: EL precedence of operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conforming to EL specification, the precedence of operators from the highest
    to lowest, left to right is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[].`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()` (used to change the precedence of operators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` (unary) `not ! empty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* / div % mod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+` `-` (binary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`< > <= >= lt gt le ge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`== != eq ne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&& and`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|| or`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?` `:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`->` (lambda expression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EL reserved words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EL defines the following reserved words:'
  prefs: []
  type: TYPE_NORMAL
- en: '`and`, `or`, `not`, `eq`, `ne`, `lt`, `gt`, `le`, `ge`, `true` (Boolean literal),
    `false` (Boolean literal), `null`, `instanceof` (a Java keyword to do a class
    comparison between objects), `empty`, `div`, and `mod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EL immediate and deferred evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EL evaluates expressions as **immediate** or **deferred**.
  prefs: []
  type: TYPE_NORMAL
- en: Immediate evaluation returns the result as soon as the page is first rendered.
    These kinds of expressions are read-only value expressions and they can be present
    only in tags that accept runtime expressions. They are easy to recognize after
    the `${}` notation. Usually, they are used for arithmetic and logical operations
    in JSP pages.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred evaluation can return the result at different phases of a page's life
    cycle depending on the technology that is using the expression. JSF can evaluate
    the expression at different phases of the life cycle (for example, during the
    rendering and postback phase), depending on how the expression is being used in
    the page. These kind of expressions can be value and method expressions, and they
    are marked by the `#{}` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Facelets, `${}` and `#{}` act the same.
  prefs: []
  type: TYPE_NORMAL
- en: EL value expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Value expressions** are probably used the most, and they refer to objects
    and their properties and attributes. Such expressions are dynamically used to
    evaluate results or set bean properties at runtime. Through value expressions,
    you can easily access JavaBeans components, collections, and Java SE enumerated
    types. Moreover, EL provides a set of implicit objects that can be used to get
    attributes from different scopes and parameter values. Furthermore, you will see
    how EL deals with each of these objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Value expressions that can read data, but cannot write it are known as **rvalue**
    (`${}` expressions are always rvalue), while those that can read and write data
    are known as **lvalue** (`#{}` expressions can be rvalue and/or lvalue).
  prefs: []
  type: TYPE_NORMAL
- en: Referencing a managed bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Referencing a managed bean is not exactly a useful example, but it is a good
    point to start. Most commonly, your managed bean will look like the following
    code (in this case, the bean''s class name is `PlayersBean`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in the CDI version, your managed bean will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, with an explicit name, your managed bean will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the first two examples, EL refers to the `PlayersBean` managed bean,
    like this—the name is obtained from taking the unqualified class name portion
    of the fully qualified class name and converting the first character to lowercase
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, for the next two examples, EL uses the explicit name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should use CDI beans whenever possible since they are more flexible than
    JSF managed beans, and because annotations from `javax.faces.bean` will be deprecated
    in a future JSF version. Therefore, the CDI ones are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: When the referenced managed bean cannot be found in any scope, a `null` value
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing a managed bean's properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As is commonly known, managed beans usually contain private fields, which are
    accessible through getter and setter methods as bean properties, and some public
    methods that exploits these properties to serve different logic tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'EL expressions that can access these properties contain the dot or square brackets
    notation, `[]`. For example, let''s suppose that the `PlayersBean` managed bean
    contains two fields defined like the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'EL can access these fields through their getter methods; therefore, you need
    to define them as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, an expression that accesses the `playerName` property can use the dot
    notation (`.`) to refer it, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this expression can use the square brackets notation, `[]`,
    as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSF evaluates this expression from left to right. First, it searches for `playersBean`
    in all available scopes (such as request, session, and application). Then, the
    bean is instantiated and the `getPlayerName`/`getPlayerSurname` getter methods
    are called (in the case of Boolean properties, the getter method will be named
    as `is`*XXX*).When you are using the `[]` notation, you can use simple or double
    quotes. Just remember to alternate them correctly in cases like the following
    quotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'An incorrect quotation (you cannot use double quotes inside double quotes)
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'An incorrect quotation (you cannot use simple quotes inside simple quotes)
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A correct quotation (you can use simple quotes in double quotes) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A correct quotation (you can use double quotes in simple quotes) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Referencing a managed bean's nested properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, managed beans use nested properties. Such properties can be accessed
    by EL using the `.` and `[]` notations multiple times in the same expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `PlayersBean` managed bean may represent general data about
    tennis players, such as name, surname, titles, and finals. More detailed information,
    such as birthday, birthplace, height, and weight can be represented through a
    different class named `PlayersDetails`. Now, the `PlayersBean` managed bean contains
    a field of type `PlayersDetails`, which means that birthday, birthplace, and so
    on become nested properties of `PlayersBean`. Speaking in code lines, the relevant
    part of the `PlayersDetails` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The managed bean of the `PlayersBean` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You already know how to call the `playerName` and `playerSurname` properties
    using the `.` and `[]` notations. Next, you can use the same notations to access
    the `birthday` and `birthplace` nested properties, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can use both notations in the same expressions, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `PlayerDetails` class can contain its own nested properties and
    so. In this case, just use the `.` and `[]` notations to get deeper in the hierarchy
    of objects until you reach the desired property.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding expressions, JSF search for `playersBean` in all the available
    scopes (request, session, application, and so on) and obtain an instance of it.
    Afterwards, it calls the `getPlayerDetails` method and the `getBirthday` method
    on result of the `getPlayerDetails` method (and the same for the `birthplace`
    property).
  prefs: []
  type: TYPE_NORMAL
- en: Referencing Java SE enumerated types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EL can access Java SE enumerated types using a `String` literal. For example,
    let''s have an enumerated type defined in `PlayersBean`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily output the `play` value as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To refer to the `Plays` constant, `Plays.Left`, with an expression, use the
    `String` literal `Left` (or `Right` for `Plays.Right`), for example, you can test
    whether `play` is `Left` or `Right`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Referencing collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Collection** items (arrays, lists, maps, sets, and so on) can be accessed
    from EL expressions by specifying a literal value that can be converted to an
    integer or the `[]` notation with an integer and without quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that the `PlayersBean` managed bean contains an
    array named `titles_2013` that keeps the titles won by a player in 2013\. The
    array is defined as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can access the first title from the array by specifying its position
    in array, which is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent in Java to getting or setting the value for `titles_2013[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes you need to iterate over the array instead of accessing
    a specific item. This can be easily accomplished with the `c:forEach` JSTL tag
    ([http://www.oracle.com/technetwork/java/index-jsp-135995.html](http://www.oracle.com/technetwork/java/index-jsp-135995.html)).
    The following code snippet iterates over the `titles_2013` array and outputs each
    item (this is a pretty uncommon usage, so do not try it in production):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simplify it as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `<ui:repeat>` tag as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This tag is detailed in [Chapter 12](ch12.html "Chapter 12. Facelets Templating"),
    *Facelets Templating*, in the *Iterating with <ui:repeat>* section.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same approach for every `List`. For example, in the case of
    `List`, the expression `#{playersBean.titles_2013[0]}` is equivalent in Java to
    `titles_2013.get(0)` and `titles_2013.set(0,` *some_value*`)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of collections of type key-value (for example, `Map`), the EL expressions
    obtain items by key. For example, let''s add a `Map` in `PlayersBean` that stores
    some match facts of a player. It can be defined as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, an EL expression that accesses the item with the key `Aces` can be written
    like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that this approach is not supported on arrays or lists. For example,
    `#{playersBean.titles_2013.0}` is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the key is not an acceptable variable name (for example, `Double Faults`),
    you need to use brackets and quotes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: EL implicit objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSF provides several objects related to the current request and environment.
    EL exposes these objects (known as **implicit objects**) that can be accessed
    at runtime in a Facelet, servlets, or backing bean—these objects are accessible
    through value expressions and are managed by the container. For each expression,
    EL first checks if the value of the base is one of these implicit objects, and,
    if it is not, then it will check beans in progressively wider scopes (from request
    to view, and finally to application scope).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In EL, the part of the expression before the dot or the square bracket is named
    **base** and it usually indicates where the bean instances should be located.
    The part after the first dot, or the square bracket, is called a **property**
    and is recursively cracked in smaller parts, which represents the bean's properties
    to get from the base.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a short overview of these objects in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Implicit object EL | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `#{application}` | `ServletContext` or `PortletContext` | This is an instance
    of `ServletContext` or `PortletContext`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{facesContext}` | `FacesContext` | This is an instance of `FacesContext`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `#{initParam}` | `Map` | This is the context initialization parameter map
    returned by `getInitParameterMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{session}` | `HttpSession` or `PortletSession` | This is an instance of
    `HttpSession` or `PortletSession`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{view}` | `UIViewRoot` | This is the current `UIViewRoot` (the root of
    the `UIComponent` tree). |'
  prefs: []
  type: TYPE_TB
- en: '| `#{component}` | `UIComponent` | This is the current `UIComponent`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{cc}` | `UIComponent` | This is the composite component currently being
    processed. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{request}` | `ServletRequest` or `PortletRequest` | This is an instance
    of `ServletRequest` or `PortletRequest`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{applicationScope}` | `Map` | This is a map to store application-scoped
    data returned by `getApplicationMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{sessionScope}` | `Map` | This is a map to store session-scoped data returned
    by `getSessionMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{viewScope}` | `Map` | This is a map to store current view scoped data
    returned by `getViewMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{requestScope}` | `Map` | This is a map to store request-scoped data returned
    by `getRequestMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{flowScope}` | `Map` | This is a map to store flow-scoped data returned
    by `facesContext.getApplication().getFlowHandler().getCurrentFlowScope()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{flash}` | `Map` | This is a map that contains values present only on the
    "next" request. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{param}` | `Map` | This is a map view of all the query parameters for this
    request. It is returned by `getRequestParameterMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{paramValues}` | `Map` | This is the request parameter value map returned
    by `getRequestParameterValuesMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{header}` | `Map` | This is a map view of all the HTTP headers for this
    request returned by `getRequestHeaderMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{headerValue}` | `Map` | This is the request header values map returned
    by `getRequestHeaderValuesMap`. Each value in the map is an array of strings that
    contains all the values for that key. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{cookie}` | `Map` | This is a map view of values in the HTTP Set-Cookie
    header returned by `getRequestCookieMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#{resource}` | `Resource` | This is a JSF resource identifier to a concrete
    resource URL. |'
  prefs: []
  type: TYPE_TB
- en: EL method expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With EL expressions, we can call arbitrary static and public methods that live
    on the server side in managed beans. Such expressions are usually present in tag's
    attributes (that is, inside an `action` or `actionListener` attribute) and must
    use the deferred evaluation syntax since a method can be called during different
    phases of the life cycle. Commonly, methods are called to respond with actions
    to different kinds of events and for autopages navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some examples of calling bean methods using EL (all methods were
    defined in the `PlayersBean` managed bean):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the `vamosRafa_1` void bean method with no arguments, as shown in the
    following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling the `vamosRafa_2` bean method with no arguments. It returns a string,
    as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The returned string, `Vamos Rafa!`, can be displayed on the web page or used
    for other purposes. In other words, the expression will be evaluated to this string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calling the `vamosRafa_3` bean method with one argument. It returns void, as
    shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `String` arguments are passed by using quotes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `String` constants are passed between simple or double quotes!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calling the `vamosRafa_4` bean method with two arguments. It returns a string,
    as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The expression will be evaluated to the string, `Vamos Rafael Nadal!`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calling the `vamosRafa_5` bean method for autonavigation. First, define the
    method in the managed bean to return a view (outcome) name (`vamos` is the view
    name for the `vamos.xhtml` file), as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Furthermore, extract the view name in the `action` attribute of any JSF UI
    component as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the button labeled **Vamos...** is clicked, JSF will resolve the view
    name, `vamos`, to the `vamos.xhtml` file. Moreover, JSF will look for the `vamos.xhtml`
    file in the current directory and will navigate to it. Commonly, these navigation
    methods are used for conditional navigation between JSF pages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have used parentheses to call a method, even when the method doesn't contain
    arguments. A special case is represented by the methods that contain an `ActionEvent`
    argument. These methods should be called without parentheses, except in the case
    when you override the `ActionEvent` argument altogether by passing and specifying
    custom argument(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'EL expressions can also be used inside JavaScript function calls. For example,
    when you want to pass bean properties to a JavaScript function, you need to place
    them between quotes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript function for this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The conditional text in JSF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need to output the conditional text (without the HTML content), you
    can use the EL ternary operator, which has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you can use this operator to select between two CSS classes, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you want to conditionally output a red or a blue text, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So, if the value of `play` is `Left`, the text will be displayed using the `red`
    CSS class, and if it is not `Left`, then the `blue` class will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the HTML content is not recommended (for security reasons
    do not use `escape="false"`), and the `else` part of the condition cannot be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For better understanding, let''s look at another example. Remember that you
    have iterated over the `titles_2013` array and output each item as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the output of this code will be something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The conditional text in JSF](img/6466EN_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything looks fine except the last comma, which should not appear since
    the **US Open** term is the last item to display. You can easily fix this issue
    with the EL ternary operator, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you just need to show or hide text based on a condition. For this,
    you can place a Boolean expression as the value of the `rendered` attribute (all
    JSF UI components have this attribute). For example, the following line of code
    will output a player''s Facebook address only if such an address exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common situation is to display or hide non-HTML text using two buttons
    of type "Show something..." and "Hide something...". For example, you can have
    a button labeled **Show Career Prize Money** and one labeled **Hide Career Prize
    Money**. Obviously, you want to display the career prize money when the first
    button is clicked and to hide the career prize money when the second button is
    clicked. For this, you can use the `rendered` attribute, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the buttons use AJAX mechanism and an EL method expression to call the
    `showPrizeMoney` and `hidePrizeMoney` methods. These methods just modify the value
    of a `boolean` property, named `show_prize`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When the request is complete, JSF will re-render the panel grid component with
    the ID `rnprizeid`; this was indicated in the `render` attribute of the `f:ajax`
    tag. As you can see, the re-rendered component is a panel that contains a simple
    `h:outputText` tag that outputs the `prize` property depending on the Boolean
    value of the EL expression present in the `rendered` attribute, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Showing and hiding text can be useful, but not enough. Usually, we need to
    show or hide the HTML content. For example, you may need to show or hide a picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This task can be easily accomplished by nesting the HTML code inside the Facelets
    `ui:fragment` tag, which supports the `rendered` attribute, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the EL expression of the `rendered` attribute indicates a `boolean`
    property of the `PlayersBean` managed bean, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can let the user decide when to show or hide the image. You can easily
    adapt the preceding example, with two buttons labeled **Show Image** and **Hide
    Image**, or more elegant, you can use a checkbox, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showHideRacquetPicture` method sets the value of the `show_racquet` property
    to `true` or `false`, depending on the checkbox status. After this method is executed,
    JSF will re-render the content of the `ui:fragment` tag—this is accomplished via
    the HTML content rendered by the `<h:panelGroup>` tag, because the `<ui:fragment>`
    tag doesn''t render the HTML content; therefore, it cannot be referenced by the
    ID. The following is the code for the `showHideRacquetPicture` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, we can conclude that the `rendered` attribute can be used to conditionally
    output the HTML/non-HTML content. The user interaction and internal conditions
    can be used to play with this attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch1_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom EL resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EL flexibility can be tested by extending it with custom implicit variables,
    properties, and method calls. This is possible if we extend the `VariableResolver`
    or `PropertyResolver` class, or even better, the `ELResolver` class that give
    us flexibility to reuse the same implementation for different tasks. The following
    are three simple steps to add custom implicit variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Create your own class that extends the `ELResolver` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the inherited abstract methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `ELResolver` class in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will see how to add a custom implicit variable by extending EL based
    on these steps. In this example, you want to retrieve a collection that contains
    the ATP singles rankings using EL directly in your JSF page. The variable name
    used to access the collection will be `atp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create a class that extends the `javax.el.ELResolver` class.
    This is very simple. The code for the `ATPVarResolver` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you need to implement six abstract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getValue`: This method is defined in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the most important method of an `ELResolver` class. In the implementation
    of the `getValue` method, you will return the ATP items if the property requested
    is named `atp`. Therefore, the implementation will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`getType`: This method is defined in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method identifies the most general acceptable type for our property. The
    scope of this method is to determine if a call of the `setValue` method is safe
    without causing a `ClassCastException` to be thrown. Since we return a collection,
    we can say that the general acceptable type is `List`. The implementation of the
    `getType` method is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setValue`: This method is defined in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method tries to set the value for a given property and base. For read-only
    variables, such as `atp`, you need to throw an exception of type `PropertyNotWritableException`.
    The implementation of the `setValue` method is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isReadOnly`: This method is defined in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method returns `true` if the variable is read-only and `false` otherwise.
    Since the `atp` variable is read-only, the implementation is obvious. This method
    is directly related to the `setValue` method, meaning that it signals whether
    it is safe or not to call the `setValue` method without getting `PropertyNotWritableException`
    as a response. The implementation of the `isReadOnly` method is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`getFeatureDescriptors`: This method is defined in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method returns a set of information about the variables or properties
    that can be resolved (commonly it is used by a design time tool (for example,
    JDeveloper has such a tool) to allow code completion of expressions). In this
    case, you can return `null`. The implementation of the `getFeatureDescriptors`
    method is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`getCommonPropertyType`: This method is defined in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method returns the most general type that this resolver accepts. The implementation
    of the `getCommonPropertyType` method is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you know if the `ELResolver` class acts as a `VariableResolver` class
    (these two classes are deprecated in JSF 2.2) or as a `PropertyResolver` class?
    The answer lies in the first part of the expression (known as the base argument),
    which in our case is `null` (the base is before the first dot or the square bracket,
    while property is after this dot or the square bracket). When the base is `null`,
    the `ELresolver` class acts as a `VariableResolver` class; otherwise, it acts
    as a `PropertyResolver` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getSinglesRankings` method (that populates the collection) is called from
    the `getValue` method, and is defined in the following `ATPSinglesRankings` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, you register the custom `ELResolver` class in `faces-config.xml` using
    the `<el-resolver>` tag and specifying the fully qualified name of the corresponding
    class. In other words, you add the `ELResolver` class in the chain of responsibility,
    which represents the pattern used by JSF to deal with `ELResolvers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time an expression needs to be resolved, JSF will call the default expression
    language resolver implementation. Each value expression is evaluated behind the
    scenes by the `getValue` method. When the `<el-resolver>` tag is present, the
    custom resolver is added in the chain of responsibility. The EL implementation
    manages a chain of resolver instances for different types of expression elements.
    For each part of an expression, EL will traverse the chain until it finds a resolver
    capable to resolve that part. The resolver capable of dealing with that part will
    pass `true` to the `setPropertyResolved` method; this method acts as a flag at
    the `ELContext` level.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, EL implementation checks, after each resolver call, the value of
    this flag via the `getPropertyResolved` method. When the flag is `true`, EL implementation
    will repeat the process for the next part of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Done! Next, you can simply output the collection items in a data table, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Well, so far so good! Now, our custom EL resolver returns the plain list of
    ATP rankings. But, what can we do if we need the list items in the reverse order,
    or to have the items in uppercase, or to obtain a random list? The answer could
    consist in adapting the preceding EL resolver to this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to modify the `getValue` method. At this moment, it returns
    `List`, but you need to obtain an instance of the `ATPSinglesRankings` class.
    Therefore, modify it as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, you need to redefine the `CONTENT` constant accordingly as shown
    in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `ATPSinglesRankings` class can contain a method for each case, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the EL resolver returns an instance of the `ATPSinglesRankings` class
    in the `getValue` method, you can easily call the `getSinglesRankings`, `getSinglesRankingsReversed`,
    and `getSinglesRankingsUpperCase` methods directly from your EL expressions, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The complete applications to demonstrate custom `ELResolvers` are available
    in the code bundle of this chapter and are named `ch1_2` and `ch1_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to develop the last example of writing a custom resolver, let''s imagine
    the following scenario: we want to access the `ELContext` object as an implicit
    object, by writing `#{elContext}` instead of `#{facesContext.ELContext}`. For
    this, we can use the knowledge accumulated from the previous two examples to write
    the following custom resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named, `ch1_6`. The goal of these three examples
    was to get you familiar with the main steps of writing a custom resolver. In [Chapter
    3](ch03.html "Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication"),
    *JSF Scopes – Lifespan and Use in Managed Beans Communication*, you will see how
    to write a custom resolver for a custom scope.
  prefs: []
  type: TYPE_NORMAL
- en: EL 3.0 overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EL 3.0 (JSR 341, part of Java EE 7) represents a major boost of EL 2.2\. The
    main features of EL 3.0 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: New operators `+`, `=`, and `;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection objects support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API for standalone environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming sections, you will see how to use EL 3.0 features in JSF pages.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an expression of type, `x = y`, the assignment operator (`=`), assign the
    value of `y` to `x`. In order to avoid an error of the kind `PropertyNotWritableException`,
    the `x` value must be an lvalue. The following examples show you how to use this
    operator in two simple expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#{x = 3}` evaluates to 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#{y = x + 5}` evaluates to 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assignment operator is right-associative (`z = y = x` is equivalent with
    `z = (y = x)`). For example, `#{z = y = x + 4}` evaluates to 7.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the string concatenation operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an expression of type, `x += y`, the string concatenation operator (`+=`)
    returns the concatenated string of `x` and `y`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#{x += y}` evaluates to 37'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#{0 += 0 +=0 += 1 += 1 += 0 += 0 += 0}` evaluates to 00011000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In EL 2.2, you can do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Working with the semicolon operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an expression of type, `x; y`, `x` is first evaluated, and its value is discarded.
    Next, `y` is evaluated and its value is returned. For example, `#‌{x = 5; y =
    3; z = x + y}` evaluates to 8.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lambda expression can be disassembled in three main parts: parameters, the
    lambda operator (`->`), and the function body.'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, in Java language, a lambda expression represents a method in an anonymous
    implementation of a functional interface. In EL, a lambda expression is reduced
    to an anonymous function that can be passed as an argument to a method.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to not confuse Java 8 lambda expressions with EL lambda expressions,
    but in order to understand the next examples, it is important to know the fundamentals
    of Java 8 lambda expressions ([http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)).
    They don't have the same syntax, but they are similar enough to not cause notable
    discomfort when we need to switch between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'An EL lambda expression is a parameterized `ValueExpression` object. The body
    of an EL lambda expression is an EL expression. EL supports several kinds of lambda
    expressions. The simplest type of EL lambda expressions are immediately invoked,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#{(x->x+1)(3)}` evaluates to 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#{((x,y,z)->x-y*z)(1,7,3)}` evaluates to -20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, we have assigned lambda expressions. These are invoked indirectly.
    For example, `#‌{q = x->x+1; q(3)}` evaluates to 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indirectly, invocation can be used to write functions. For example, we can
    write a function to calculate `n mod m` (without using the `%` operator). The
    following example is evaluated to 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this function from other expressions. For example, if we want to
    calculate the greatest common divisor of two numbers, we can exploit the preceding
    function; the following example is evaluated to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions can be passed as arguments to methods. For example, in the
    following example, you call a method named `firstLambdaAction`—the lambda expression
    is invoked from this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `firstLambdaAction` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Another powerful feature of lambda expressions consists of nested lambda expressions.
    For example (first, is evaluated the inner expression to 7, afterwards the outer
    expression to as, 10 - 7): `#‌{(x->x-((x,y)->(x+y))(4,3))(10)}` evaluates to 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you think EL lambda expressions rocks? Well, get ready for more. The real
    power is unleashed only when we bring collection objects into equations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with collection objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: EL 3.0 provides powerful support to manipulate collection objects by applying
    operations in a pipeline. The methods supporting the collection operations are
    implemented as `ELResolvers`, and lambda expressions are indicated as arguments
    for these methods.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind manipulating collection objects is based on **streams**.
    More precisely, the specific operations are accomplished as method calls to the
    stream of elements obtained from the collection. Many operations return streams,
    which can be used in other operations that return streams, and so on. In such
    a case, we can say that we have a chain of streams or a pipeline. The entry in
    the pipeline is known as the **source**, and the exit from the pipeline is known
    as the **terminal operation** (this operation doesn't return a stream). Between
    the source and terminal operation, we may have zero or more **intermediate operations**
    (all of them return streams).
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline execution begins when the terminal operation starts. Because intermediate
    operations are lazy evaluated, they don't preserve intermediate results of the
    operations (an exception is the sorted operation, which needs all the elements
    to sort tasks).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see some examples. We begin by declaring a set, a list, and a map—EL
    contains syntaxes to construct sets, lists, and maps dynamically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go a step further and sort the list in ascending/descending order.
    For this, we use the `stream`, `sorted` (this is like the `ORDER BY` statement
    of SQL), and `toList` methods (the latter returns a `List` that contains the elements
    of the source stream), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, let''s say that we have the following list in a managed bean named
    `LambdaBean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can apply 24 percent of VAT and compute the total for costs higher
    than 1,000 using the `filter` (this is like SQL''s `WHERE` and `GROUP BY` statements),
    `map` (this is like SQL''s `SELECT` statement), and `reduce` (this is like the
    aggregate functions) methods. These methods are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: These were just a few examples of using collection objects in EL 3.0\. A complete
    application named `ch1_4` is available for download in the code bundle of this
    chapter. Since, in this application you can see more than 70 examples, I recommend
    you to take a look at it. Moreover, a nice example can be found on Michael Müller's
    blog at [http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/](http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/).
  prefs: []
  type: TYPE_NORMAL
- en: 'But, what if we want to take advantage of lambda expressions, but we don''t
    like to write such expressions? Well, a solution can be to write parameterized
    functions based on lambda expressions, and call them in the JSTL style. For example,
    the following function is capable of extracting a sublist of a `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call it as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In the complete application, named `ch1_5`, you can see a bunch of 21 parameterized
    functions that can be used with `List`s.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that EL 2.2 expressions can be used to dynamically access
    data (read and write) stored in JavaBeans components, to call arbitrary static
    and public methods, and to perform arithmetic and logic operations. Finally, we
    saw that EL allows us to extend its capabilities with custom resolvers. Starting
    with EL 3.0, we can take advantage of new operators, lambda expressions, and support
    when working with collection objects.
  prefs: []
  type: TYPE_NORMAL
- en: While reading this book, you will see many examples of EL expressions in real
    cases. For example, in the next chapter, you will use EL expressions to explore
    JSF communication capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will discuss JSF communications.
  prefs: []
  type: TYPE_NORMAL
