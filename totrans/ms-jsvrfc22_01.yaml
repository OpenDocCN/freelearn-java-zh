- en: Chapter 1. Dynamic Access to JSF Application Data through Expression Language
    (EL 3.0)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 动态访问JSF应用程序数据通过表达式语言（EL 3.0）
- en: Java **Expression Language** (**EL**) is a compact and powerful mechanism that
    enables dynamic communication in JSP and JSF-based applications (including development
    frameworks based on JSF such as PrimeFaces, ICEfaces, and RichFaces); we embed
    expressions in the presentation layer to communicate with the application logic
    layer. EL provides bidirectional communication, which means that we can expose
    application logic data to the user, but we also can submit user data to be processes.
    Generically speaking, EL can be used to populate HTTP requests with user data,
    to extract and expose data from HTTP responses, to update HTML DOM, to conditionally
    process data, and much more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java **表达式语言**（**EL**）是一种紧凑且强大的机制，它使得在JSP和JSF应用程序（包括基于JSF的开发框架，如PrimeFaces、ICEfaces和RichFaces）中实现动态通信成为可能；我们在表示层嵌入表达式以与应用程序逻辑层进行通信。EL提供双向通信，这意味着我们可以将应用程序逻辑数据暴露给用户，同时也可以提交用户数据以进行处理。一般来说，EL可以用来用用户数据填充HTTP请求，从HTTP响应中提取和暴露数据，更新HTML
    DOM，条件处理数据等等。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Commonly, EL expressions will be present in JSP and JSF pages, but they can
    also appear outside, in `faces-config.xml`, for example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，EL表达式会出现在JSP和JSF页面中，但它们也可以出现在外部，例如在`faces-config.xml`中。
- en: 'In this chapter, you will see how to use EL in web pages to communicate with
    managed beans, which is the most common case in JSF applications. We will cover
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解如何在网页中使用EL与托管Bean进行通信，这是JSF应用程序中最常见的情况。我们将涵盖以下主题：
- en: EL syntax, operators, and reserved words
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EL语法、运算符和保留字
- en: EL immediate and deferred evaluation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EL即时和延迟求值
- en: EL value and method expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EL值和方法表达式
- en: The conditional text in JSF
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF中的条件文本
- en: Write a custom EL resolver
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义EL解析器
- en: EL syntax
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EL语法
- en: In this section, you can see an overview of the main aspects of EL 2.2 and 3.0
    syntax. EL supports a handful of operators and reserved words. Each of these are
    quickly described in the following section (more details are in the EL specification
    document ([http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html](http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html))).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您可以了解EL 2.2和3.0语法的概述。EL支持一些运算符和保留字。以下将简要描述这些内容（更多详情请参考EL规范文档([http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html](http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html))).
- en: EL operators
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EL运算符
- en: 'EL supports the following categories of operators—arithmetic, relational, logical,
    conditional, empty and added starting with EL 3.0, string concatenation, assignment
    and semicolon operators:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: EL支持以下几类运算符—算术、关系、逻辑、条件、空值，从EL 3.0开始增加了字符串连接、赋值和分号运算符：
- en: '| Textuals | Description | Symbols |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 文本 | 描述 | 符号 |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A `+` B | Addition | `+` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| A `+` B | 加法 | `+` |'
- en: '| A `-` B | Subtraction | `-` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| A `-` B | 减法 | `-` |'
- en: '| A `*` B | Multiplication | `*` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| A `*` B | 乘法 | `*` |'
- en: '| A {`div`, `/`} B | Arithmetic operator division | /, `div` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| A {`div`, `/`} B | 算术运算符除法 | /, `div` |'
- en: '| A {`mod`, `%`} B | Arithmetic operator modulo | `%`, `mod` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| A {`mod`, `%`} B | 算术运算符取模 | `%`, `mod` |'
- en: '| A {`and`, `&&`} B | Logical AND | `&&`, `and` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| A {`and`, `&&`} B | 逻辑与 | `&&`, `and` |'
- en: '| A {`or`, `&#124;&#124;`} B | Logical OR | `&#124;&#124;`, `or` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| A {`or`, `&#124;&#124;`} B | 逻辑或 | `&#124;&#124;`, `or` |'
- en: '| {`not`, `!`} A | Logical opposite | `!`, `not` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| {`not`, `!`} A | 逻辑非 | `!`, `not` |'
- en: '| A {`lt`, `<`} B | Relational less than | `<`, `lt` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| A {`lt`, `<`} B | 关系小于 | `<`, `lt` |'
- en: '| A {`gt`, `>`} `B` | Relational greater than | `>`, `gt` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| A {`gt`, `>`} `B` | 关系大于 | `>`, `gt` |'
- en: '| A {`le`, `<=`} B | Relational less than or equal to | `<=`, `le` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| A {`le`, `<=`} B | 关系小于等于 | `<=`, `le` |'
- en: '| A {`ge`, `>=`} B | Relational greater than or equal to | `>=`, `ge` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| A {`ge`, `>=`} B | 关系大于等于 | `>=`, `ge` |'
- en: '| A {`eq`, `==`} B | Equal to | `==`, `eq` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| A {`eq`, `==`} B | 等于 | `==`, `eq` |'
- en: '| A {`ne`, `!=`} B | Not equal to | `!=`, `ne` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| A {`ne`, `!=`} B | 不等于 | `!=`, `ne` |'
- en: '| A `=` B | Assignment (EL 3.0) | `=` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| A `=` B | 赋值（EL 3.0） | `=` |'
- en: '| A `;` B | Semicolon (EL 3.0) | `;` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| A `;` B | 分号（EL 3.0） | `;` |'
- en: '| A `+=` B | String concatenation (EL 3.0) | `+=` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| A `+=` B | 字符串连接（EL 3.0） | `+=` |'
- en: '| A `->` B | Lambda expression (EL 3.0) | `->` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| A `->` B | Lambda表达式（EL 3.0） | `->` |'
- en: '| `empty` A | Determine whether a value is null or empty |   |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `empty` A | 判断一个值是否为空或空值 |   |'
- en: '| A `?` B `:` C | Evaluates B or C, depending on the result of the evaluation
    of A. Known as the **ternary operator**. | ?: |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| A `?` B `:` C | 根据 A 的评估结果评估 B 或 C。称为**三元运算符**。 | ?: |'
- en: '|   | Used when writing EL expressions | `.` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|   | 用于编写 EL 表达式时使用 | `.` |'
- en: '|   | Used when writing EL expressions | `[]` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|   | 用于编写 EL 表达式时使用 | `[]` |'
- en: EL precedence of operators
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EL 运算符优先级
- en: 'Conforming to EL specification, the precedence of operators from the highest
    to lowest, left to right is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 符合 EL 规范，运算符的优先级从高到低，从左到右如下：
- en: '`[].`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[].`'
- en: '`()` (used to change the precedence of operators)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()`（用于改变运算符的优先级）'
- en: '`-` (unary) `not ! empty`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`（一元）`not ! empty`'
- en: '`* / div % mod`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* / div % mod`'
- en: '`+` `-` (binary)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` `-`（二元）'
- en: '`+=`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=`'
- en: '`< > <= >= lt gt le ge`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< > <= >= lt gt le ge`'
- en: '`== != eq ne`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`== != eq ne`'
- en: '`&& and`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&& 和`'
- en: '`|| or`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|| 或`'
- en: '`?` `:`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` `:`'
- en: '`->` (lambda expression)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->`（lambda 表达式）'
- en: '`=`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`'
- en: '`;`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;`'
- en: EL reserved words
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EL 保留字
- en: 'EL defines the following reserved words:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: EL 定义以下保留字：
- en: '`and`, `or`, `not`, `eq`, `ne`, `lt`, `gt`, `le`, `ge`, `true` (Boolean literal),
    `false` (Boolean literal), `null`, `instanceof` (a Java keyword to do a class
    comparison between objects), `empty`, `div`, and `mod`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`、`or`、`not`、`eq`、`ne`、`lt`、`gt`、`le`、`ge`、`true`（布尔字面量）、`false`（布尔字面量）、`null`、`instanceof`（用于在对象之间进行类比较的
    Java 关键字）、`empty`、`div` 和 `mod`'
- en: EL immediate and deferred evaluation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EL 立即和延迟评估
- en: EL evaluates expressions as **immediate** or **deferred**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: EL 将表达式评估为**立即**或**延迟**。
- en: Immediate evaluation returns the result as soon as the page is first rendered.
    These kinds of expressions are read-only value expressions and they can be present
    only in tags that accept runtime expressions. They are easy to recognize after
    the `${}` notation. Usually, they are used for arithmetic and logical operations
    in JSP pages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 立即评估在页面首次渲染时立即返回结果。这类表达式是只读值表达式，并且它们只能存在于接受运行时表达式的标签中。它们在 `${}` 符号之后很容易识别。通常，它们用于
    JSP 页面中的算术和逻辑运算。
- en: Deferred evaluation can return the result at different phases of a page's life
    cycle depending on the technology that is using the expression. JSF can evaluate
    the expression at different phases of the life cycle (for example, during the
    rendering and postback phase), depending on how the expression is being used in
    the page. These kind of expressions can be value and method expressions, and they
    are marked by the `#{}` notation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟评估可以在页面生命周期不同阶段返回结果，具体取决于使用表达式的技术。JSF 可以在生命周期的不同阶段评估表达式（例如，在渲染和回传阶段），具体取决于在页面中使用表达式的方式。这类表达式可以是值表达式和方法表达式，并且它们由
    `#{}` 符号标记。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Facelets, `${}` and `#{}` act the same.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Facelets 中，`${}` 和 `#{}` 的行为相同。
- en: EL value expressions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EL 值表达式
- en: '**Value expressions** are probably used the most, and they refer to objects
    and their properties and attributes. Such expressions are dynamically used to
    evaluate results or set bean properties at runtime. Through value expressions,
    you can easily access JavaBeans components, collections, and Java SE enumerated
    types. Moreover, EL provides a set of implicit objects that can be used to get
    attributes from different scopes and parameter values. Furthermore, you will see
    how EL deals with each of these objects.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**值表达式**可能是使用最频繁的，它们引用对象及其属性和属性。这类表达式在运行时动态用于评估结果或设置 Bean 属性。通过值表达式，您可以轻松访问
    JavaBeans 组件、集合和 Java SE 枚举类型。此外，EL 提供了一组隐式对象，可用于从不同作用域获取属性和参数值。此外，您将看到 EL 如何处理这些对象中的每一个。'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Value expressions that can read data, but cannot write it are known as **rvalue**
    (`${}` expressions are always rvalue), while those that can read and write data
    are known as **lvalue** (`#{}` expressions can be rvalue and/or lvalue).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以读取数据但不能写入的值表达式称为**右值**（`${}` 表达式始终是右值），而可以读取和写入数据的值表达式称为**左值**（`#{}` 表达式可以是右值和/或左值）。
- en: Referencing a managed bean
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用管理 Bean
- en: 'Referencing a managed bean is not exactly a useful example, but it is a good
    point to start. Most commonly, your managed bean will look like the following
    code (in this case, the bean''s class name is `PlayersBean`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '引用管理 Bean 并非一个非常有用的例子，但它是一个很好的起点。最常见的情况是，您的管理 Bean 将类似于以下代码（在这种情况下，Bean 的类名为
    `PlayersBean`）:'
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, in the CDI version, your managed bean will be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 CDI 版本中，你的管理 Bean 将如下所示：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, with an explicit name, your managed bean will be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用显式名称，你的管理 Bean 将如下所示：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, for the first two examples, EL refers to the `PlayersBean` managed bean,
    like this—the name is obtained from taking the unqualified class name portion
    of the fully qualified class name and converting the first character to lowercase
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于前两个例子，EL引用`PlayersBean`管理Bean，如下所示——名称是从完全限定类名中提取非限定类名部分，并将第一个字符转换为小写得到的：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition, for the next two examples, EL uses the explicit name as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于接下来的两个例子，EL使用以下显式名称：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should use CDI beans whenever possible since they are more flexible than
    JSF managed beans, and because annotations from `javax.faces.bean` will be deprecated
    in a future JSF version. Therefore, the CDI ones are recommended.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尽可能使用CDI Bean，因为它们比JSF管理Bean更灵活，并且因为`javax.faces.bean`的注解将在未来的JSF版本中弃用。因此，推荐使用CDI
    Bean。
- en: When the referenced managed bean cannot be found in any scope, a `null` value
    will be returned.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用的管理Bean在任何范围内找不到时，将返回一个`null`值。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接将文件通过电子邮件发送给你。
- en: Referencing a managed bean's properties
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用管理Bean的属性
- en: As is commonly known, managed beans usually contain private fields, which are
    accessible through getter and setter methods as bean properties, and some public
    methods that exploits these properties to serve different logic tasks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如人所知，管理Bean通常包含私有字段，这些字段可以通过getter和setter方法作为Bean属性访问，以及一些公共方法，这些方法利用这些属性来执行不同的逻辑任务。
- en: 'EL expressions that can access these properties contain the dot or square brackets
    notation, `[]`. For example, let''s suppose that the `PlayersBean` managed bean
    contains two fields defined like the following lines:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以访问这些属性的EL表达式包含点或方括号符号`[]`。例如，假设`PlayersBean`管理Bean包含以下定义的两个字段：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'EL can access these fields through their getter methods; therefore, you need
    to define them as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: EL可以通过它们的getter方法访问这些字段；因此，你需要按照以下代码定义它们：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, an expression that accesses the `playerName` property can use the dot
    notation (`.`) to refer it, as shown in the following line of code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个访问`playerName`属性的表示式可以使用点符号（`.`）来引用它，如下面的代码行所示：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, this expression can use the square brackets notation, `[]`,
    as shown in the following line of code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这个表示式可以使用方括号符号`[]`，如下面的代码行所示：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JSF evaluates this expression from left to right. First, it searches for `playersBean`
    in all available scopes (such as request, session, and application). Then, the
    bean is instantiated and the `getPlayerName`/`getPlayerSurname` getter methods
    are called (in the case of Boolean properties, the getter method will be named
    as `is`*XXX*).When you are using the `[]` notation, you can use simple or double
    quotes. Just remember to alternate them correctly in cases like the following
    quotations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JSF从左到右评估这个表达式。首先，它在所有可用的范围内（如请求、会话和应用）搜索`playersBean`。然后，实例化Bean并调用`getPlayerName`/`getPlayerSurname`
    getter方法（对于布尔属性，getter方法将命名为`is`*XXX*）。当你使用`[]`符号时，你可以使用单引号或双引号。只需记住在如下引号的情况下正确交替使用即可。
- en: 'An incorrect quotation (you cannot use double quotes inside double quotes)
    is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误的引号（你无法在双引号内使用双引号）是：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An incorrect quotation (you cannot use simple quotes inside simple quotes)
    is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误的引号（你无法在单引号内使用单引号）是：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A correct quotation (you can use simple quotes in double quotes) is:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的引号（你可以在双引号内使用单引号）是：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A correct quotation (you can use double quotes in simple quotes) is:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的引号（你可以在单引号内使用双引号）是：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Referencing a managed bean's nested properties
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用管理Bean的嵌套属性
- en: Usually, managed beans use nested properties. Such properties can be accessed
    by EL using the `.` and `[]` notations multiple times in the same expression.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，管理Bean使用嵌套属性。这些属性可以通过EL在同一个表达式中多次使用`.`和`[]`符号来访问。
- en: 'For example, the `PlayersBean` managed bean may represent general data about
    tennis players, such as name, surname, titles, and finals. More detailed information,
    such as birthday, birthplace, height, and weight can be represented through a
    different class named `PlayersDetails`. Now, the `PlayersBean` managed bean contains
    a field of type `PlayersDetails`, which means that birthday, birthplace, and so
    on become nested properties of `PlayersBean`. Speaking in code lines, the relevant
    part of the `PlayersDetails` class is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`PlayersBean`托管Bean可能代表网球运动员的一般数据，如姓名、姓氏、冠军和决赛。更详细的信息，如生日、出生地、身高和体重，可以通过名为`PlayersDetails`的不同类来表示。现在，`PlayersBean`托管Bean包含一个类型为`PlayersDetails`的字段，这意味着生日、出生地等成为`PlayersBean`的嵌套属性。用代码行来说，`PlayersDetails`类的相关部分如下：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The managed bean of the `PlayersBean` class is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayersBean`类的托管Bean如下：'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You already know how to call the `playerName` and `playerSurname` properties
    using the `.` and `[]` notations. Next, you can use the same notations to access
    the `birthday` and `birthplace` nested properties, as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何使用`.`和`[]`符号表示法调用`playerName`和`playerSurname`属性。接下来，你可以使用相同的符号表示法来访问嵌套属性`birthday`和`birthplace`，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or, you can use both notations in the same expressions, as shown in the following
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在同一个表达式中使用这两种符号表示法，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, the `PlayerDetails` class can contain its own nested properties and
    so. In this case, just use the `.` and `[]` notations to get deeper in the hierarchy
    of objects until you reach the desired property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`PlayerDetails`类可以包含其自己的嵌套属性等。在这种情况下，只需使用`.`和`[]`符号表示法来深入到对象的层次结构中，直到达到所需的属性。
- en: In the preceding expressions, JSF search for `playersBean` in all the available
    scopes (request, session, application, and so on) and obtain an instance of it.
    Afterwards, it calls the `getPlayerDetails` method and the `getBirthday` method
    on result of the `getPlayerDetails` method (and the same for the `birthplace`
    property).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，JSF在所有可用的作用域（请求、会话、应用程序等）中搜索`playersBean`，并获取其实例。之后，它调用`getPlayerDetails`方法，并在`getPlayerDetails`方法的返回结果上调用`getBirthday`方法（对于`birthplace`属性也是如此）。
- en: Referencing Java SE enumerated types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用Java SE枚举类型
- en: 'EL can access Java SE enumerated types using a `String` literal. For example,
    let''s have an enumerated type defined in `PlayersBean`, as shown in the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: EL可以使用字符串字面量访问Java SE枚举类型。例如，让我们假设在`PlayersBean`中定义了一个枚举类型，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can easily output the `play` value as shown in the following line of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地输出`play`值，如下面的代码行所示：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To refer to the `Plays` constant, `Plays.Left`, with an expression, use the
    `String` literal `Left` (or `Right` for `Plays.Right`), for example, you can test
    whether `play` is `Left` or `Right`, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用`Plays`常量`Plays.Left`，使用表达式中的字符串字面量`Left`（或`Right`用于`Plays.Right`），例如，你可以测试`play`是否为`Left`或`Right`，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Referencing collections
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用集合
- en: '**Collection** items (arrays, lists, maps, sets, and so on) can be accessed
    from EL expressions by specifying a literal value that can be converted to an
    integer or the `[]` notation with an integer and without quotes.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**项（数组、列表、映射、集合等）可以通过指定一个可以转换为整数或使用整数和空格的`[]`符号表示法（无需引号）的文本值从EL表达式中访问。'
- en: 'For example, let''s suppose that the `PlayersBean` managed bean contains an
    array named `titles_2013` that keeps the titles won by a player in 2013\. The
    array is defined as shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`PlayersBean`托管Bean包含一个名为`titles_2013`的数组，该数组保存了2013年一名球员赢得的冠军。数组定义如下面的代码所示：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you can access the first title from the array by specifying its position
    in array, which is `0`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过指定数组中的位置来访问数组的第一个标题，该位置是`0`：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is equivalent in Java to getting or setting the value for `titles_2013[0]`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Java中相当于获取或设置`titles_2013[0]`的值。
- en: 'However, sometimes you need to iterate over the array instead of accessing
    a specific item. This can be easily accomplished with the `c:forEach` JSTL tag
    ([http://www.oracle.com/technetwork/java/index-jsp-135995.html](http://www.oracle.com/technetwork/java/index-jsp-135995.html)).
    The following code snippet iterates over the `titles_2013` array and outputs each
    item (this is a pretty uncommon usage, so do not try it in production):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你需要遍历数组而不是访问特定的项。这可以通过 `c:forEach` JSTL 标签（[http://www.oracle.com/technetwork/java/index-jsp-135995.html](http://www.oracle.com/technetwork/java/index-jsp-135995.html)）轻松实现。以下代码片段遍历
    `titles_2013` 数组并输出每个项（这是一个相当不常见的用法，所以不要在生产环境中尝试）：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can simplify it as shown in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其简化如下代码所示：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also use the `<ui:repeat>` tag as shown in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用如下代码中所示的 `<ui:repeat>` 标签：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This tag is detailed in [Chapter 12](ch12.html "Chapter 12. Facelets Templating"),
    *Facelets Templating*, in the *Iterating with <ui:repeat>* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签在 *Facelets 模板化* 的 *使用 <ui:repeat> 遍历* 部分的第 12 章（[ch12.html "Chapter 12. Facelets
    Templating"](ch12.html "Chapter 12. Facelets Templating")）中有详细说明。
- en: You can use the same approach for every `List`. For example, in the case of
    `List`, the expression `#{playersBean.titles_2013[0]}` is equivalent in Java to
    `titles_2013.get(0)` and `titles_2013.set(0,` *some_value*`)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个 `List` 使用相同的方法。例如，在 `List` 的情况下，表达式 `#{playersBean.titles_2013[0]}` 在
    Java 中等同于 `titles_2013.get(0)` 和 `titles_2013.set(0,` *some_value*`)`。
- en: 'In the case of collections of type key-value (for example, `Map`), the EL expressions
    obtain items by key. For example, let''s add a `Map` in `PlayersBean` that stores
    some match facts of a player. It can be defined as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型为键值对的集合（例如，`Map`）的情况下，EL 表达式通过键来获取项。例如，让我们在 `PlayersBean` 中添加一个 `Map`，它存储了一些玩家的比赛事实。它可以定义如下代码所示：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, an EL expression that accesses the item with the key `Aces` can be written
    like the following line of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个访问键为 `Aces` 的项的 EL 表达式可以写成以下代码行：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that this approach is not supported on arrays or lists. For example,
    `#{playersBean.titles_2013.0}` is not correct.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法不支持数组或列表。例如，`#{playersBean.titles_2013.0}` 是不正确的。
- en: 'When the key is not an acceptable variable name (for example, `Double Faults`),
    you need to use brackets and quotes, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当键不是一个可接受的变量名时（例如，`Double Faults`），你需要使用括号和引号，如下代码所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: EL implicit objects
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EL 隐式对象
- en: JSF provides several objects related to the current request and environment.
    EL exposes these objects (known as **implicit objects**) that can be accessed
    at runtime in a Facelet, servlets, or backing bean—these objects are accessible
    through value expressions and are managed by the container. For each expression,
    EL first checks if the value of the base is one of these implicit objects, and,
    if it is not, then it will check beans in progressively wider scopes (from request
    to view, and finally to application scope).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 提供了与当前请求和环境相关的几个对象。EL 提供了这些对象（称为 **隐式对象**），可以在 Facelet、servlet 或后端 bean
    中在运行时访问——这些对象通过值表达式访问，并由容器管理。对于每个表达式，EL 首先检查基础值是否是这些隐式对象之一，如果不是，它将逐级检查更广泛的范围中的
    beans（从请求到视图，最后到应用程序范围）。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In EL, the part of the expression before the dot or the square bracket is named
    **base** and it usually indicates where the bean instances should be located.
    The part after the first dot, or the square bracket, is called a **property**
    and is recursively cracked in smaller parts, which represents the bean's properties
    to get from the base.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EL 中，点或方括号之前的部分被称为 **基础**，它通常表示应该位于哪个 bean 实例。第一个点或方括号之后的部分称为 **属性**，并且递归地分解成更小的部分，代表从基础获取的
    bean 属性。
- en: 'You can see a short overview of these objects in the following table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下表格中看到这些对象的简要概述：
- en: '| Implicit object EL | Type | Description |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 隐式对象 EL | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `#{application}` | `ServletContext` or `PortletContext` | This is an instance
    of `ServletContext` or `PortletContext`. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `#{application}` | `ServletContext` 或 `PortletContext` | 这是 `ServletContext`
    或 `PortletContext` 的实例。|'
- en: '| `#{facesContext}` | `FacesContext` | This is an instance of `FacesContext`.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `#{facesContext}` | `FacesContext` | 这是一个 `FacesContext` 的实例。|'
- en: '| `#{initParam}` | `Map` | This is the context initialization parameter map
    returned by `getInitParameterMap`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `#{initParam}` | `Map` | 这是 `getInitParameterMap` 返回的上下文初始化参数映射。|'
- en: '| `#{session}` | `HttpSession` or `PortletSession` | This is an instance of
    `HttpSession` or `PortletSession`. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `#{session}` | `HttpSession`或`PortletSession` | 这是一个`HttpSession`或`PortletSession`的实例。|'
- en: '| `#{view}` | `UIViewRoot` | This is the current `UIViewRoot` (the root of
    the `UIComponent` tree). |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `#{view}` | `UIViewRoot` | 这是指定的当前`UIViewRoot`（`UIComponent`树的根）。|'
- en: '| `#{component}` | `UIComponent` | This is the current `UIComponent`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `#{component}` | `UIComponent` | 这是指定的当前`UIComponent`。|'
- en: '| `#{cc}` | `UIComponent` | This is the composite component currently being
    processed. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `#{cc}` | `UIComponent` | 这是指定正在处理的复合组件。|'
- en: '| `#{request}` | `ServletRequest` or `PortletRequest` | This is an instance
    of `ServletRequest` or `PortletRequest`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `#{request}` | `ServletRequest`或`PortletRequest` | 这是一个`ServletRequest`或`PortletRequest`的实例。|'
- en: '| `#{applicationScope}` | `Map` | This is a map to store application-scoped
    data returned by `getApplicationMap`. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `#{applicationScope}` | `Map` | 这是一个映射，用于存储由`getApplicationMap`返回的应用程序范围数据。|'
- en: '| `#{sessionScope}` | `Map` | This is a map to store session-scoped data returned
    by `getSessionMap`. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `#{sessionScope}` | `Map` | 这是一个映射，用于存储由`getSessionMap`返回的会话范围数据。|'
- en: '| `#{viewScope}` | `Map` | This is a map to store current view scoped data
    returned by `getViewMap`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `#{viewScope}` | `Map` | 这是一个映射，用于存储由`getViewMap`返回的当前视图范围数据。|'
- en: '| `#{requestScope}` | `Map` | This is a map to store request-scoped data returned
    by `getRequestMap`. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `#{requestScope}` | `Map` | 这是一个映射，用于存储由`getRequestMap`返回的请求范围数据。|'
- en: '| `#{flowScope}` | `Map` | This is a map to store flow-scoped data returned
    by `facesContext.getApplication().getFlowHandler().getCurrentFlowScope()`. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `#{flowScope}` | `Map` | 这是一个映射，用于存储由`facesContext.getApplication().getFlowHandler().getCurrentFlowScope()`返回的流程范围数据。|'
- en: '| `#{flash}` | `Map` | This is a map that contains values present only on the
    "next" request. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `#{flash}` | `Map` | 这是一个只包含“下一个”请求中存在的值的映射。|'
- en: '| `#{param}` | `Map` | This is a map view of all the query parameters for this
    request. It is returned by `getRequestParameterMap`. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `#{param}` | `Map` | 这是此请求的所有查询参数的映射视图。它由`getRequestParameterMap`返回。|'
- en: '| `#{paramValues}` | `Map` | This is the request parameter value map returned
    by `getRequestParameterValuesMap`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `#{paramValues}` | `Map` | 这是`getRequestParameterValuesMap`返回的请求参数值映射。|'
- en: '| `#{header}` | `Map` | This is a map view of all the HTTP headers for this
    request returned by `getRequestHeaderMap`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `#{header}` | `Map` | 这是此请求所有HTTP头部的映射视图，由`getRequestHeaderMap`返回。|'
- en: '| `#{headerValue}` | `Map` | This is the request header values map returned
    by `getRequestHeaderValuesMap`. Each value in the map is an array of strings that
    contains all the values for that key. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `#{headerValue}` | `Map` | 这是`getRequestHeaderValuesMap`返回的请求头部值映射。映射中的每个值都是一个包含该键所有值的字符串数组。|'
- en: '| `#{cookie}` | `Map` | This is a map view of values in the HTTP Set-Cookie
    header returned by `getRequestCookieMap`. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `#{cookie}` | `Map` | 这是一个映射视图，显示了由`getRequestCookieMap`返回的HTTP Set-Cookie头中的值。|'
- en: '| `#{resource}` | `Resource` | This is a JSF resource identifier to a concrete
    resource URL. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `#{resource}` | `Resource` | 这是一个指向具体资源URL的JSF资源标识符。|'
- en: EL method expressions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EL方法表达式
- en: With EL expressions, we can call arbitrary static and public methods that live
    on the server side in managed beans. Such expressions are usually present in tag's
    attributes (that is, inside an `action` or `actionListener` attribute) and must
    use the deferred evaluation syntax since a method can be called during different
    phases of the life cycle. Commonly, methods are called to respond with actions
    to different kinds of events and for autopages navigation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EL表达式，我们可以调用托管bean上服务器端的任意静态和公共方法。此类表达式通常存在于标签的属性中（即，在`action`或`actionListener`属性内部）并且必须使用延迟评估语法，因为方法可以在生命周期的不同阶段被调用。通常，方法被调用以响应不同类型的事件和自动页面导航。
- en: 'Let''s see some examples of calling bean methods using EL (all methods were
    defined in the `PlayersBean` managed bean):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用EL调用bean方法的几个示例（所有方法都在`PlayersBean`托管bean中定义）：
- en: 'Calling the `vamosRafa_1` void bean method with no arguments, as shown in the
    following code:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用无参数的`vamosRafa_1` void bean方法，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Calling the `vamosRafa_2` bean method with no arguments. It returns a string,
    as shown in the following code:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用无参数的`vamosRafa_2` bean方法。它返回一个字符串，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The returned string, `Vamos Rafa!`, can be displayed on the web page or used
    for other purposes. In other words, the expression will be evaluated to this string.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回的字符串“Vamos Rafa!”可以在网页上显示或用于其他目的。换句话说，表达式将被评估为这个字符串。
- en: 'Calling the `vamosRafa_3` bean method with one argument. It returns void, as
    shown in the following code:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个参数调用 `vamosRafa_3` Bean 方法。它返回 void，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the `String` arguments are passed by using quotes.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`String` 参数是通过使用引号传递的。
- en: Note
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `String` constants are passed between simple or double quotes!
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`String` 常量用单引号或双引号传递！'
- en: 'Calling the `vamosRafa_4` bean method with two arguments. It returns a string,
    as shown in the following code:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个参数调用 `vamosRafa_4` Bean 方法。它返回一个字符串，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The expression will be evaluated to the string, `Vamos Rafael Nadal!`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该表达式将被评估为字符串，`Vamos Rafael Nadal!`。
- en: 'Calling the `vamosRafa_5` bean method for autonavigation. First, define the
    method in the managed bean to return a view (outcome) name (`vamos` is the view
    name for the `vamos.xhtml` file), as shown in the following code:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `vamosRafa_5` Bean 方法进行自动导航。首先，在管理 Bean 中定义该方法以返回一个视图（结果）名称（`vamos` 是 `vamos.xhtml`
    文件的视图名称），如下面的代码所示：
- en: '[PRE32]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Furthermore, extract the view name in the `action` attribute of any JSF UI
    component as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从任何 JSF UI 组件的 `action` 属性中提取视图名称，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, when the button labeled **Vamos...** is clicked, JSF will resolve the view
    name, `vamos`, to the `vamos.xhtml` file. Moreover, JSF will look for the `vamos.xhtml`
    file in the current directory and will navigate to it. Commonly, these navigation
    methods are used for conditional navigation between JSF pages.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当点击标记为 **Vamos...** 的按钮时，JSF 将解析视图名称 `vamos` 到 `vamos.xhtml` 文件。此外，JSF 将在当前目录中查找
    `vamos.xhtml` 文件，并将其导航到该文件。通常，这些导航方法用于在 JSF 页面之间进行条件导航。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have used parentheses to call a method, even when the method doesn't contain
    arguments. A special case is represented by the methods that contain an `ActionEvent`
    argument. These methods should be called without parentheses, except in the case
    when you override the `ActionEvent` argument altogether by passing and specifying
    custom argument(s).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至在没有参数的情况下也使用了括号来调用方法。一个特殊情况是包含 `ActionEvent` 参数的方法。这些方法应该不带括号调用，除非你完全通过传递和指定自定义参数来覆盖
    `ActionEvent` 参数。
- en: 'EL expressions can also be used inside JavaScript function calls. For example,
    when you want to pass bean properties to a JavaScript function, you need to place
    them between quotes, as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: EL 表达式也可以用在 JavaScript 函数调用中。例如，当你想将 Bean 属性传递给 JavaScript 函数时，需要将它们放在引号之间，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The JavaScript function for this is shown in the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JavaScript 函数的代码如下所示：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The conditional text in JSF
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 中的条件文本
- en: 'When you need to output the conditional text (without the HTML content), you
    can use the EL ternary operator, which has the following syntax:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要输出条件性文本（不包含 HTML 内容）时，可以使用 EL 三元运算符，其语法如下：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For example, you can use this operator to select between two CSS classes, as
    shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用这个运算符在两个 CSS 类之间进行选择，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you want to conditionally output a red or a blue text, as shown in the
    following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你想要条件性地输出红色或蓝色文本，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, if the value of `play` is `Left`, the text will be displayed using the `red`
    CSS class, and if it is not `Left`, then the `blue` class will be used.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `play` 的值为 `Left`，则将使用 `red` CSS 类显示文本，如果不是 `Left`，则使用 `blue` 类。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that the HTML content is not recommended (for security reasons
    do not use `escape="false"`), and the `else` part of the condition cannot be omitted.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，不建议使用 HTML 内容（出于安全原因，不要使用 `escape="false"`），并且不能省略条件的 `else` 部分。
- en: 'For better understanding, let''s look at another example. Remember that you
    have iterated over the `titles_2013` array and output each item as shown in the
    following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们看另一个例子。记住你已经遍历了 `titles_2013` 数组，并按如下代码所示输出每个项目：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Well, the output of this code will be something like the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这段代码的输出将类似于以下截图：
- en: '![The conditional text in JSF](img/6466EN_01_01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![JSF 中的条件文本](img/6466EN_01_01.jpg)'
- en: 'Everything looks fine except the last comma, which should not appear since
    the **US Open** term is the last item to display. You can easily fix this issue
    with the EL ternary operator, as shown in the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一个逗号外，一切看起来都正常，因为这个逗号不应该出现，因为 **US Open** 是要显示的最后一个项目。你可以通过 EL 三元运算符轻松解决这个问题，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Sometimes you just need to show or hide text based on a condition. For this,
    you can place a Boolean expression as the value of the `rendered` attribute (all
    JSF UI components have this attribute). For example, the following line of code
    will output a player''s Facebook address only if such an address exists:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你只需要根据条件显示或隐藏文本。为此，你可以将布尔表达式作为`rendered`属性的值（所有JSF UI组件都有这个属性）。例如，以下代码行将仅在存在Facebook地址时输出玩家的Facebook地址：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Another common situation is to display or hide non-HTML text using two buttons
    of type "Show something..." and "Hide something...". For example, you can have
    a button labeled **Show Career Prize Money** and one labeled **Hide Career Prize
    Money**. Obviously, you want to display the career prize money when the first
    button is clicked and to hide the career prize money when the second button is
    clicked. For this, you can use the `rendered` attribute, as shown in the following
    code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的情况是使用两个类型为"显示某物..."和"隐藏某物..."的按钮来显示或隐藏非HTML文本。例如，你可以有一个标签为**显示职业生涯奖金**的按钮和一个标签为**隐藏职业生涯奖金**的按钮。显然，当你点击第一个按钮时，你希望显示职业生涯奖金；当你点击第二个按钮时，你希望隐藏职业生涯奖金。为此，你可以使用`rendered`属性，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Both the buttons use AJAX mechanism and an EL method expression to call the
    `showPrizeMoney` and `hidePrizeMoney` methods. These methods just modify the value
    of a `boolean` property, named `show_prize`, as shown in the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 两个按钮都使用AJAX机制和EL方法表达式来调用`showPrizeMoney`和`hidePrizeMoney`方法。这些方法只是修改一个名为`show_prize`的`boolean`属性值，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the request is complete, JSF will re-render the panel grid component with
    the ID `rnprizeid`; this was indicated in the `render` attribute of the `f:ajax`
    tag. As you can see, the re-rendered component is a panel that contains a simple
    `h:outputText` tag that outputs the `prize` property depending on the Boolean
    value of the EL expression present in the `rendered` attribute, as shown in the
    following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请求完成后，JSF将重新渲染ID为`rnprizeid`的面板网格组件；这已在`f:ajax`标签的`render`属性中指示。如你所见，重新渲染的组件是一个包含简单`h:outputText`标签的面板，该标签根据`rendered`属性中EL表达式的布尔值输出`prize`属性，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Showing and hiding text can be useful, but not enough. Usually, we need to
    show or hide the HTML content. For example, you may need to show or hide a picture:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 显示和隐藏文本可能很有用，但不足以满足需求。通常，我们需要显示或隐藏HTML内容。例如，你可能需要显示或隐藏一张图片：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This task can be easily accomplished by nesting the HTML code inside the Facelets
    `ui:fragment` tag, which supports the `rendered` attribute, as shown in the following
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务可以通过将HTML代码嵌套在支持`rendered`属性的Facelets `ui:fragment`标签内轻松完成，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, the EL expression of the `rendered` attribute indicates a `boolean`
    property of the `PlayersBean` managed bean, as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`rendered`属性的EL表达式表示`PlayersBean`管理Bean的`boolean`属性，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, you can let the user decide when to show or hide the image. You can easily
    adapt the preceding example, with two buttons labeled **Show Image** and **Hide
    Image**, or more elegant, you can use a checkbox, as shown in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以让用户决定何时显示或隐藏图片。你可以轻松地修改前面的示例，添加两个标签为**显示图片**和**隐藏图片**的按钮，或者更优雅的做法是使用复选框，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `showHideRacquetPicture` method sets the value of the `show_racquet` property
    to `true` or `false`, depending on the checkbox status. After this method is executed,
    JSF will re-render the content of the `ui:fragment` tag—this is accomplished via
    the HTML content rendered by the `<h:panelGroup>` tag, because the `<ui:fragment>`
    tag doesn''t render the HTML content; therefore, it cannot be referenced by the
    ID. The following is the code for the `showHideRacquetPicture` method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`showHideRacquetPicture`方法根据复选框的状态将`show_racquet`属性设置为`true`或`false`。在此方法执行后，JSF将重新渲染`ui:fragment`标签的内容——这是通过`<h:panelGroup>`标签渲染的HTML内容来实现的，因为`<ui:fragment>`标签不渲染HTML内容；因此，它不能通过ID引用。以下为`showHideRacquetPicture`方法的代码：'
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, we can conclude that the `rendered` attribute can be used to conditionally
    output the HTML/non-HTML content. The user interaction and internal conditions
    can be used to play with this attribute value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，`rendered`属性可以用来有条件地输出HTML/非HTML内容。用户交互和内部条件可以用来操作这个属性值。
- en: The complete application is named `ch1_1`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch1_1`。
- en: Writing a custom EL resolver
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义EL解析器
- en: 'EL flexibility can be tested by extending it with custom implicit variables,
    properties, and method calls. This is possible if we extend the `VariableResolver`
    or `PropertyResolver` class, or even better, the `ELResolver` class that give
    us flexibility to reuse the same implementation for different tasks. The following
    are three simple steps to add custom implicit variables:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展自定义隐式变量、属性和方法调用，可以测试 EL 的灵活性。这可以通过扩展 `VariableResolver` 或 `PropertyResolver`
    类，或者更好的是，扩展 `ELResolver` 类来实现，这给我们提供了在不同任务中重用相同实现的能力。以下是将自定义隐式变量添加的三个简单步骤：
- en: Create your own class that extends the `ELResolver` class.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自 `ELResolver` 类的自己的类。
- en: Implement the inherited abstract methods.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现继承的抽象方法。
- en: Add the `ELResolver` class in `faces-config.xml`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `faces-config.xml` 中添加 `ELResolver` 类。
- en: Next, you will see how to add a custom implicit variable by extending EL based
    on these steps. In this example, you want to retrieve a collection that contains
    the ATP singles rankings using EL directly in your JSF page. The variable name
    used to access the collection will be `atp`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到如何根据这些步骤通过扩展 EL 添加自定义隐式变量。在这个例子中，你想要通过 EL 直接在你的 JSF 页面中检索包含 ATP 单打排名的集合。用于访问集合的变量名将是
    `atp`。
- en: 'First, you need to create a class that extends the `javax.el.ELResolver` class.
    This is very simple. The code for the `ATPVarResolver` class is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个继承自 `javax.el.ELResolver` 类的类。这非常简单。`ATPVarResolver` 类的代码如下：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Second, you need to implement six abstract methods:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要实现六个抽象方法：
- en: '`getValue`: This method is defined in the following manner:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getValue`: 此方法定义如下：'
- en: '[PRE51]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is the most important method of an `ELResolver` class. In the implementation
    of the `getValue` method, you will return the ATP items if the property requested
    is named `atp`. Therefore, the implementation will be as follows:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `ELResolver` 类最重要的方法。在 `getValue` 方法的实现中，如果你请求的属性名为 `atp`，你将返回 ATP 项目。因此，实现将如下：
- en: '[PRE52]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`getType`: This method is defined in the following manner:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getType`: 此方法定义如下：'
- en: '[PRE53]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This method identifies the most general acceptable type for our property. The
    scope of this method is to determine if a call of the `setValue` method is safe
    without causing a `ClassCastException` to be thrown. Since we return a collection,
    we can say that the general acceptable type is `List`. The implementation of the
    `getType` method is as follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法确定我们属性的最一般可接受类型。此方法的作用域是确定调用 `setValue` 方法是否安全，不会抛出 `ClassCastException`。由于我们返回一个集合，我们可以说一般可接受类型是
    `List`。`getType` 方法的实现如下：
- en: '[PRE54]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`setValue`: This method is defined in the following manner:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValue`: 此方法定义如下：'
- en: '[PRE55]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This method tries to set the value for a given property and base. For read-only
    variables, such as `atp`, you need to throw an exception of type `PropertyNotWritableException`.
    The implementation of the `setValue` method is as follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法尝试为给定的属性和基础设置值。对于只读变量，如 `atp`，你需要抛出 `PropertyNotWritableException` 类型的异常。`setValue`
    方法的实现如下：
- en: '[PRE56]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`isReadOnly`: This method is defined in the following manner:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isReadOnly`: 此方法定义如下：'
- en: '[PRE57]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This method returns `true` if the variable is read-only and `false` otherwise.
    Since the `atp` variable is read-only, the implementation is obvious. This method
    is directly related to the `setValue` method, meaning that it signals whether
    it is safe or not to call the `setValue` method without getting `PropertyNotWritableException`
    as a response. The implementation of the `isReadOnly` method is as follows:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法如果变量是只读的则返回 `true`，否则返回 `false`。由于 `atp` 变量是只读的，所以实现很明显。此方法与 `setValue` 方法直接相关，意味着它表示是否安全调用
    `setValue` 方法，而不会得到 `PropertyNotWritableException` 作为响应。`isReadOnly` 方法的实现如下：
- en: '[PRE58]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`getFeatureDescriptors`: This method is defined in the following manner:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFeatureDescriptors`: 此方法定义如下：'
- en: '[PRE59]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This method returns a set of information about the variables or properties
    that can be resolved (commonly it is used by a design time tool (for example,
    JDeveloper has such a tool) to allow code completion of expressions). In this
    case, you can return `null`. The implementation of the `getFeatureDescriptors`
    method is as follows:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法返回一组关于可以解析的变量或属性的信息（通常它被设计时工具（例如，JDeveloper 有这样的工具）用于允许表达式代码补全）。在这种情况下，你可以返回
    `null`。`getFeatureDescriptors` 方法的实现如下：
- en: '[PRE60]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`getCommonPropertyType`: This method is defined in the following manner:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCommonPropertyType`: 此方法定义如下：'
- en: '[PRE61]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This method returns the most general type that this resolver accepts. The implementation
    of the `getCommonPropertyType` method is as follows:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法返回此解析器接受的类型中最一般化的类型。`getCommonPropertyType`方法的实现如下：
- en: '[PRE62]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: How do you know if the `ELResolver` class acts as a `VariableResolver` class
    (these two classes are deprecated in JSF 2.2) or as a `PropertyResolver` class?
    The answer lies in the first part of the expression (known as the base argument),
    which in our case is `null` (the base is before the first dot or the square bracket,
    while property is after this dot or the square bracket). When the base is `null`,
    the `ELresolver` class acts as a `VariableResolver` class; otherwise, it acts
    as a `PropertyResolver` class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道`ELResolver`类是作为`VariableResolver`类（这两个类在JSF 2.2中已弃用）还是作为`PropertyResolver`类来操作？答案在于表达式的第一部分（称为基本参数），在我们的例子中是`null`（基本参数位于第一个点或方括号之前，而属性位于此点或方括号之后）。当基本参数为`null`时，`ELresolver`类作为`VariableResolver`类来操作；否则，它作为`PropertyResolver`类来操作。
- en: 'The `getSinglesRankings` method (that populates the collection) is called from
    the `getValue` method, and is defined in the following `ATPSinglesRankings` class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSinglesRankings`方法（用于填充集合）是从`getValue`方法中调用的，并在以下`ATPSinglesRankings`类中定义：'
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Third, you register the custom `ELResolver` class in `faces-config.xml` using
    the `<el-resolver>` tag and specifying the fully qualified name of the corresponding
    class. In other words, you add the `ELResolver` class in the chain of responsibility,
    which represents the pattern used by JSF to deal with `ELResolvers`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你需要在`faces-config.xml`中使用`<el-resolver>`标签注册自定义的`ELResolver`类，并指定相应类的完全限定名。换句话说，你将`ELResolver`类添加到责任链中，这代表了JSF处理`ELResolvers`所使用的模式：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each time an expression needs to be resolved, JSF will call the default expression
    language resolver implementation. Each value expression is evaluated behind the
    scenes by the `getValue` method. When the `<el-resolver>` tag is present, the
    custom resolver is added in the chain of responsibility. The EL implementation
    manages a chain of resolver instances for different types of expression elements.
    For each part of an expression, EL will traverse the chain until it finds a resolver
    capable to resolve that part. The resolver capable of dealing with that part will
    pass `true` to the `setPropertyResolved` method; this method acts as a flag at
    the `ELContext` level.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要解析一个表达式时，JSF都会调用默认的表达式语言解析器实现。每个值表达式都由`getValue`方法在幕后进行评估。当存在`<el-resolver>`标签时，自定义解析器被添加到责任链中。EL实现管理不同类型表达式元素的责任链中的解析器实例。对于表达式的每一部分，EL都会遍历链，直到找到能够解析该部分的解析器。能够处理该部分的解析器会将`true`传递给`setPropertyResolved`方法；此方法在`ELContext`级别上充当一个标志。
- en: Furthermore, EL implementation checks, after each resolver call, the value of
    this flag via the `getPropertyResolved` method. When the flag is `true`, EL implementation
    will repeat the process for the next part of the expression.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，EL实现通过`getPropertyResolved`方法在每次解析器调用后检查此标志的值。当标志为`true`时，EL实现将重复对表达式下一部分的过程。
- en: 'Done! Next, you can simply output the collection items in a data table, as
    shown in the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！接下来，你只需简单地以数据表的形式输出集合项，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Well, so far so good! Now, our custom EL resolver returns the plain list of
    ATP rankings. But, what can we do if we need the list items in the reverse order,
    or to have the items in uppercase, or to obtain a random list? The answer could
    consist in adapting the preceding EL resolver to this situation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止一切顺利！现在，我们的自定义EL解析器返回了ATP排名的普通列表。但是，如果我们需要以相反的顺序排列列表项，或者需要将项转换为大写，或者需要获取一个随机列表，我们该怎么办？答案可能在于将前面的EL解析器适应这种情况。
- en: 'First, you need to modify the `getValue` method. At this moment, it returns
    `List`, but you need to obtain an instance of the `ATPSinglesRankings` class.
    Therefore, modify it as shown in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要修改`getValue`方法。此时，它返回`List`，但你需要获取`ATPSinglesRankings`类的实例。因此，按照以下代码进行修改：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Moreover, you need to redefine the `CONTENT` constant accordingly as shown
    in the following line of code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要根据以下代码行重新定义`CONTENT`常量：
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, the `ATPSinglesRankings` class can contain a method for each case, as
    shown in the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ATPSinglesRankings`类可以包含每个情况的方法，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Since the EL resolver returns an instance of the `ATPSinglesRankings` class
    in the `getValue` method, you can easily call the `getSinglesRankings`, `getSinglesRankingsReversed`,
    and `getSinglesRankingsUpperCase` methods directly from your EL expressions, as
    shown in the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EL 解析器在 `getValue` 方法中返回 `ATPSinglesRankings` 类的实例，你可以轻松地从你的 EL 表达式中直接调用
    `getSinglesRankings`、`getSinglesRankingsReversed` 和 `getSinglesRankingsUpperCase`
    方法，如下所示：
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The complete applications to demonstrate custom `ELResolvers` are available
    in the code bundle of this chapter and are named `ch1_2` and `ch1_3`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 用于演示自定义 `ELResolvers` 的完整应用程序包含在本章的代码包中，并命名为 `ch1_2` 和 `ch1_3`。
- en: 'In order to develop the last example of writing a custom resolver, let''s imagine
    the following scenario: we want to access the `ELContext` object as an implicit
    object, by writing `#{elContext}` instead of `#{facesContext.ELContext}`. For
    this, we can use the knowledge accumulated from the previous two examples to write
    the following custom resolver:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发编写自定义解析器的最后一个示例，让我们设想以下场景：我们想要将 `ELContext` 对象作为隐式对象访问，通过编写 `#{elContext}`
    而不是 `#{facesContext.ELContext}`。为此，我们可以利用前两个示例积累的知识来编写以下自定义解析器：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The complete application is named, `ch1_6`. The goal of these three examples
    was to get you familiar with the main steps of writing a custom resolver. In [Chapter
    3](ch03.html "Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication"),
    *JSF Scopes – Lifespan and Use in Managed Beans Communication*, you will see how
    to write a custom resolver for a custom scope.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 `ch1_6`。这三个示例的目的是让你熟悉编写自定义解析器的关键步骤。在 [第 3 章](ch03.html "第 3 章。JSF
    作用域 – 在管理 Bean 通信中的生命周期和使用")，*JSF 作用域 – 在管理 Bean 通信中的生命周期和使用*，你将看到如何编写自定义作用域的解析器。
- en: EL 3.0 overview
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EL 3.0 概述
- en: 'EL 3.0 (JSR 341, part of Java EE 7) represents a major boost of EL 2.2\. The
    main features of EL 3.0 are as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: EL 3.0（JSR 341，Java EE 7 的一部分）是 EL 2.2 的一次重大提升。EL 3.0 的主要特性如下：
- en: New operators `+`, `=`, and `;`
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新运算符 `+`、`=` 和 `;`
- en: Lambda expressions
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Collection objects support
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合对象支持
- en: An API for standalone environments
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立环境的 API
- en: In the upcoming sections, you will see how to use EL 3.0 features in JSF pages.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到如何在 JSF 页面中使用 EL 3.0 特性。
- en: Working with the assignment operator
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用赋值运算符
- en: 'In an expression of type, `x = y`, the assignment operator (`=`), assign the
    value of `y` to `x`. In order to avoid an error of the kind `PropertyNotWritableException`,
    the `x` value must be an lvalue. The following examples show you how to use this
    operator in two simple expressions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型为的表达式 `x = y` 中，赋值运算符（`=`）将 `y` 的值赋给 `x`。为了避免 `PropertyNotWritableException`
    类型的错误，`x` 的值必须是一个 lvalue。以下示例展示了如何在两个简单表达式中使用此运算符：
- en: '`#{x = 3}` evaluates to 3'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#{x = 3}` 的结果为 3'
- en: '`#{y = x + 5}` evaluates to 8'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#{y = x + 5}` 的结果为 8'
- en: The assignment operator is right-associative (`z = y = x` is equivalent with
    `z = (y = x)`). For example, `#{z = y = x + 4}` evaluates to 7.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符是右结合的（`z = y = x` 等价于 `z = (y = x)`）。例如，`#{z = y = x + 4}` 的结果为 7。
- en: Working with the string concatenation operator
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串连接运算符
- en: 'In an expression of type, `x += y`, the string concatenation operator (`+=`)
    returns the concatenated string of `x` and `y`. For example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型为的表达式 `x += y` 中，字符串连接操作符（`+=`）返回 `x` 和 `y` 的连接字符串。例如：
- en: '`#{x += y}` evaluates to 37'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#{x += y}` 的结果为 37'
- en: '`#{0 += 0 +=0 += 1 += 1 += 0 += 0 += 0}` evaluates to 00011000'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#{0 += 0 +=0 += 1 += 1 += 0 += 0 += 0}` 的结果为 00011000'
- en: 'In EL 2.2, you can do this using the following code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EL 2.2 中，你可以使用以下代码来完成此操作：
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Working with the semicolon operator
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分号运算符
- en: In an expression of type, `x; y`, `x` is first evaluated, and its value is discarded.
    Next, `y` is evaluated and its value is returned. For example, `#‌{x = 5; y =
    3; z = x + y}` evaluates to 8.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型为的表达式 `x; y` 中，首先评估 `x`，然后丢弃其值。接下来，评估 `y` 并返回其值。例如，`#‌{x = 5; y = 3; z =
    x + y}` 的结果为 8。
- en: Exploring lambda expressions
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Lambda 表达式
- en: 'A lambda expression can be disassembled in three main parts: parameters, the
    lambda operator (`->`), and the function body.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式可以分解为三个主要部分：参数、Lambda 操作符（`->`）和函数体。
- en: Basically, in Java language, a lambda expression represents a method in an anonymous
    implementation of a functional interface. In EL, a lambda expression is reduced
    to an anonymous function that can be passed as an argument to a method.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 语言中，Lambda 表达式代表一个在匿名实现功能接口中的方法。在 EL 中，Lambda 表达式被简化为一个可以作为方法参数传递的匿名函数。
- en: It is important to not confuse Java 8 lambda expressions with EL lambda expressions,
    but in order to understand the next examples, it is important to know the fundamentals
    of Java 8 lambda expressions ([http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)).
    They don't have the same syntax, but they are similar enough to not cause notable
    discomfort when we need to switch between them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要混淆Java 8 lambda表达式和EL lambda表达式，但为了理解下一个示例，了解Java 8 lambda表达式的基础知识[http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)是重要的。它们的语法不同，但足够相似，在我们需要在它们之间切换时不会引起明显的困扰。
- en: 'An EL lambda expression is a parameterized `ValueExpression` object. The body
    of an EL lambda expression is an EL expression. EL supports several kinds of lambda
    expressions. The simplest type of EL lambda expressions are immediately invoked,
    for example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: EL lambda表达式是一个参数化的`ValueExpression`对象。EL lambda表达式的主体是一个EL表达式。EL支持几种类型的lambda表达式。EL
    lambda表达式的最简单类型是立即调用的，例如：
- en: '`#{(x->x+1)(3)}` evaluates to 4'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#{(x->x+1)(3)}`计算结果为4'
- en: '`#{((x,y,z)->x-y*z)(1,7,3)}` evaluates to -20'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#{((x,y,z)->x-y*z)(1,7,3)}`计算结果为-20'
- en: Further, we have assigned lambda expressions. These are invoked indirectly.
    For example, `#‌{q = x->x+1; q(3)}` evaluates to 4.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有已分配的lambda表达式。这些是通过间接调用的。例如，`#‌{q = x->x+1; q(3)}`计算结果为4。
- en: 'Indirectly, invocation can be used to write functions. For example, we can
    write a function to calculate `n mod m` (without using the `%` operator). The
    following example is evaluated to 3:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 间接地，调用可以用来编写函数。例如，我们可以编写一个函数来计算`n mod m`（不使用`%`运算符）。以下示例计算结果为3：
- en: '[PRE72]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can call this function from other expressions. For example, if we want to
    calculate the greatest common divisor of two numbers, we can exploit the preceding
    function; the following example is evaluated to 5:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从其他表达式中调用这个函数。例如，如果我们想计算两个数的最大公约数，我们可以利用前面的函数；以下示例计算结果为5：
- en: '[PRE73]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Lambda expressions can be passed as arguments to methods. For example, in the
    following example, you call a method named `firstLambdaAction`—the lambda expression
    is invoked from this method:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以作为方法的参数传递。例如，在以下示例中，你调用一个名为`firstLambdaAction`的方法——lambda表达式从这个方法中调用：
- en: '[PRE74]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, the `firstLambdaAction` method is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`firstLambdaAction`方法如下：
- en: '[PRE75]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Another powerful feature of lambda expressions consists of nested lambda expressions.
    For example (first, is evaluated the inner expression to 7, afterwards the outer
    expression to as, 10 - 7): `#‌{(x->x-((x,y)->(x+y))(4,3))(10)}` evaluates to 3.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式的一个强大特性是嵌套的lambda表达式。例如（首先，计算内部表达式为7，然后计算外部表达式为as，10 - 7）：`#‌{(x->x-((x,y)->(x+y))(4,3))(10)}`计算结果为3。
- en: Do you think EL lambda expressions rocks? Well, get ready for more. The real
    power is unleashed only when we bring collection objects into equations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为EL lambda表达式很酷吗？好吧，准备好迎接更多。真正的力量只有在我们将集合对象带入方程时才会释放出来。
- en: Working with collection objects
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理集合对象
- en: EL 3.0 provides powerful support to manipulate collection objects by applying
    operations in a pipeline. The methods supporting the collection operations are
    implemented as `ELResolvers`, and lambda expressions are indicated as arguments
    for these methods.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: EL 3.0通过在管道中应用操作为操作集合对象提供了强大的支持。支持集合操作的方法实现为`ELResolvers`，lambda表达式作为这些方法的参数。
- en: The main idea behind manipulating collection objects is based on **streams**.
    More precisely, the specific operations are accomplished as method calls to the
    stream of elements obtained from the collection. Many operations return streams,
    which can be used in other operations that return streams, and so on. In such
    a case, we can say that we have a chain of streams or a pipeline. The entry in
    the pipeline is known as the **source**, and the exit from the pipeline is known
    as the **terminal operation** (this operation doesn't return a stream). Between
    the source and terminal operation, we may have zero or more **intermediate operations**
    (all of them return streams).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 操作集合对象的主要思想是基于**流**。更准确地说，具体操作是通过调用从集合中获取的元素流的方法来完成的。许多操作返回流，这些流可以用在其他返回流的操作中，依此类推。在这种情况下，我们可以说我们有一个流链或管道。管道的入口称为**源**，管道的出口称为**终端操作**（此操作不返回流）。在源和终端操作之间，我们可能有零个或多个**中间操作**（所有这些操作都返回流）。
- en: The pipeline execution begins when the terminal operation starts. Because intermediate
    operations are lazy evaluated, they don't preserve intermediate results of the
    operations (an exception is the sorted operation, which needs all the elements
    to sort tasks).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 管道执行开始于终端操作启动时。由于中间操作是惰性评估的，它们不会保留操作的中间结果（一个例外是排序操作，它需要所有元素来排序任务）。
- en: 'Now, let''s see some examples. We begin by declaring a set, a list, and a map—EL
    contains syntaxes to construct sets, lists, and maps dynamically as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些示例。我们首先声明一个集合、一个列表和一个映射——EL 包含动态构建集合、列表和映射的语法，如下所示：
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, let''s go a step further and sort the list in ascending/descending order.
    For this, we use the `stream`, `sorted` (this is like the `ORDER BY` statement
    of SQL), and `toList` methods (the latter returns a `List` that contains the elements
    of the source stream), as shown in the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步，按升序/降序对列表进行排序。为此，我们使用 `stream`、`sorted`（这类似于 SQL 的 `ORDER BY` 语句）和
    `toList` 方法（后者返回一个包含源流元素的 `List`），如下面的代码所示：
- en: '[PRE77]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Further, let''s say that we have the following list in a managed bean named
    `LambdaBean`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设我们有一个名为 `LambdaBean` 的管理 Bean 中的以下列表：
- en: '[PRE78]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, we can apply 24 percent of VAT and compute the total for costs higher
    than 1,000 using the `filter` (this is like SQL''s `WHERE` and `GROUP BY` statements),
    `map` (this is like SQL''s `SELECT` statement), and `reduce` (this is like the
    aggregate functions) methods. These methods are used as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以应用 24% 的增值税，并使用 `filter`（这类似于 SQL 的 `WHERE` 和 `GROUP BY` 语句）、`map`（这类似于
    SQL 的 `SELECT` 语句）和 `reduce`（这类似于聚合函数）方法来计算超过 1,000 的总成本。这些方法的使用如下：
- en: '[PRE79]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These were just a few examples of using collection objects in EL 3.0\. A complete
    application named `ch1_4` is available for download in the code bundle of this
    chapter. Since, in this application you can see more than 70 examples, I recommend
    you to take a look at it. Moreover, a nice example can be found on Michael Müller's
    blog at [http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/](http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 EL 3.0 中使用集合对象的几个示例。本章代码包中提供了一个名为 `ch1_4` 的完整应用程序，可供下载。由于在这个应用程序中你可以看到超过
    70 个示例，我建议你查看一下。此外，一个很好的示例可以在 Michael Müller 的博客上找到，网址为 [http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/](http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/)。
- en: 'But, what if we want to take advantage of lambda expressions, but we don''t
    like to write such expressions? Well, a solution can be to write parameterized
    functions based on lambda expressions, and call them in the JSTL style. For example,
    the following function is capable of extracting a sublist of a `List`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想利用 lambda 表达式，但又不喜欢编写这样的表达式呢？嗯，一个解决方案可以是基于 lambda 表达式编写参数化函数，并以 JSTL
    风格调用它们。例如，以下函数能够从一个 `List` 中提取子列表：
- en: '[PRE80]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we can call it as shown in the following code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像以下代码所示进行调用：
- en: '[PRE81]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the complete application, named `ch1_5`, you can see a bunch of 21 parameterized
    functions that can be used with `List`s.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `ch1_5` 的完整应用程序中，你可以看到一些可以与 `List`s 一起使用的参数化函数。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that EL 2.2 expressions can be used to dynamically access
    data (read and write) stored in JavaBeans components, to call arbitrary static
    and public methods, and to perform arithmetic and logic operations. Finally, we
    saw that EL allows us to extend its capabilities with custom resolvers. Starting
    with EL 3.0, we can take advantage of new operators, lambda expressions, and support
    when working with collection objects.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到 EL 2.2 表达式可以用来动态访问存储在 JavaBeans 组件中的数据（读取和写入），调用任意的静态和公共方法，以及执行算术和逻辑操作。最后，我们了解到
    EL 允许我们通过自定义解析器扩展其功能。从 EL 3.0 开始，我们可以利用新的运算符、lambda 表达式以及与集合对象一起工作的支持。
- en: While reading this book, you will see many examples of EL expressions in real
    cases. For example, in the next chapter, you will use EL expressions to explore
    JSF communication capabilities.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书的过程中，你将看到许多 EL 表达式在实际案例中的应用。例如，在下一章中，你将使用 EL 表达式来探索 JSF 通信功能。
- en: See you in the next chapter, where we will discuss JSF communications.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在下一章中相见，我们将讨论 JSF 通信。
