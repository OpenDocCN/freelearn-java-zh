<html><head></head><body>
		<div id="_idContainer041">
			<h1 id="_idParaDest-66"><em class="italic"><a id="_idTextAnchor065"/>Chapter 3</em>: Working on RESTful Web Services</h1>
			<p>In any microservice development, one of the core aspects is how the microservice interfaces with the external world. <strong class="bold">RESTful </strong>or <em class="italic">restful</em> has emerged as the golden standard of building these service interfaces. RESTful treats all information exchange as a resource exchange among systems. A resource represents the state of the object at the time of the transfer, hence the term <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>). In this chapter, we will explore the key aspects of working on these restful interfaces in the Micronaut framework. We will continue with the controller-service-repository pattern and add restful endpoints to the microservice projects within the <strong class="source-inline">pet-clinic</strong> application. For outgoing and incoming payloads to these endpoints, we will use <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>) in tandem with MapStruct to map DTOs to/from entities. For hands-on work, we will work to add restful endpoints to the following microservices:</p>
			<ul>
				<li><strong class="source-inline">pet-owner</strong>: Working hands-on to add HTTP GET, POST, PUT, and DELETE endpoints for <strong class="source-inline">pet-owner</strong> schema objects</li>
				<li><strong class="source-inline">pet-clinic</strong>: Working hands-on to add HTTP GET, POST, PUT, and DELETE endpoints for <strong class="source-inline">pet-clinic</strong> schema objects</li>
				<li><strong class="source-inline">pet-clinic-review</strong>: Working hands-on to add HTTP GET, POST, PUT, and DELETE endpoints for the <strong class="source-inline">pet-clinic-reviews</strong> collection</li>
			</ul>
			<p>While working on the aforementioned microservices, we will dive into the following topics in this chapter:</p>
			<ul>
				<li>Working on restful microservices in the Micronaut framework</li>
				<li>Using DTOs for the endpoint payloads</li>
				<li>Creating restful endpoints for a microservice</li>
				<li>Using Micronaut's HTTP server APIs</li>
				<li>Using Micronaut's HTTP client APIs</li>
			</ul>
			<p>By the end of this chapter, you will have the practical know-how to work on restful web services in the Micronaut framework. This knowledge is important to work on the web layer of a microservice. Furthermore, we will also explore leveraging HTTP server objects and client objects in the Micronaut framework.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter are run on Windows 10 and macOS. Code examples covered in this chapter are available in the book's GitHub repository at <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter03</a>.</p>
			<p>The following tools need to be installed and set up in the development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong>: Version 8 or above (we used Java 14).</li>
				<li><strong class="bold">Maven</strong>: This is optional and only required if you would like to use Maven as the build system. However, we recommend having Maven set up on any development machine. Instructions to download and install Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">Development IDE</strong>: Based on your preferences, any Java-based IDE can be used, but for the purpose of writing this chapter, IntelliJ was used. </li>
				<li><strong class="bold">Git</strong>: Instructions to download and install Git can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</li>
				<li><strong class="bold">PostgreSQL</strong>: Instructions to download and install PostgreSQL can be found at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</li>
				<li><strong class="bold">MongoDB</strong>: MongoDB Atlas provides a free online database-as-a-service with up to 512 MB storage. However, if a local database is preferred, then instructions on how to download and install can be found at <a href="https://docs.mongodb.com/manual/administration/install-community/">https://docs.mongodb.com/manual/administration/install-community/</a>. We used a local installation for writing this chapter.</li>
				<li><strong class="bold">Rest client</strong>: Any HTTP REST client can be used. We used the Advanced REST Client Chrome plugin. </li>
			</ul>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Working on restful microservices in the Micronaut framework</h1>
			<p>In <a id="_idIndexMarker242"/>order to learn about restful microservices in the <a id="_idIndexMarker243"/>Micronaut framework, we will continue working on the <strong class="source-inline">pet-clinic</strong> application. The following table summarizes the changes we will be making on each of the microservices in the <strong class="source-inline">pet-clinic</strong> application:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Table_3.1.jpg" alt="Table 3.1 – Microservices in the pet-clinic application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 3.1 – Microservices in the pet-clinic application</p>
			<p>In<a id="_idIndexMarker244"/> each microservice, we will get hands-on with adding HTTP endpoints <a id="_idIndexMarker245"/>for performing CRUD operations on the data objects owned by them. </p>
			<p>In our hands-on discussions, we will focus on the following:</p>
			<ul>
				<li><strong class="bold">DTOs</strong>: How <a id="_idIndexMarker246"/>DTOs can be used to encapsulate outgoing and incoming payloads for restful endpoints</li>
				<li><strong class="bold">Services</strong>: How services<a id="_idIndexMarker247"/> liaison with database repositories for any controller requests</li>
				<li><strong class="bold">Controllers</strong>: How controllers<a id="_idIndexMarker248"/> provide a standard restful interface for the external world in the Micronaut framework</li>
			</ul>
			<p>Adding to <em class="italic">Figure 2.2</em> of <a href="B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Working on the Data Access</em>, the following are the components in this chapter within each microservice:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.1_B16585.jpg" alt="Figure 3.1 – Microservice components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Microservice components</p>
			<p>We will <a id="_idIndexMarker249"/>continue with the separation of<a id="_idIndexMarker250"/> concerns by following the controller-service-repository pattern. For communications between the service and controller, we will explore DTOs. We will work in a bottom-up fashion while covering DTOs, services, and finally controllers. DTOs, mappers, services, and controllers follow the same approach, and therefore, to keep our discussion focused, we will target the <strong class="source-inline">pet-owner</strong> microservice. </p>
			<p>In the next section, our focal point will be DTOs.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Using DTOs for the endpoint payloads</h1>
			<p>The <a id="_idIndexMarker251"/>DTO pattern originates<a id="_idIndexMarker252"/> from the enterprise application architecture and fundamentally, data objects aggregate and encapsulate the data to transfer. Since in the microservices architecture an end client may need varied data from different persistence resources (such as invoice data along with user data), the DTO pattern is very effective in limiting calls to microservices for getting the desired projection of data. DTOs are also known as assembler objects since they assemble data from multiple entity classes.</p>
			<p>In this section, we <a id="_idIndexMarker253"/>will explore how to<a id="_idIndexMarker254"/> implement and map (to an entity) DTOs. In the later sections, we will further dive into using DTOs as an effective mechanism to transfer data from and into a microservice. We will also look at how DTOs can help reduce the number of calls to microservices by assembling data.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Implementing DTOs</h2>
			<p>To<a id="_idIndexMarker255"/> implement a DTO, we will begin defining a DTO class for the pet owner. </p>
			<p>Open the <strong class="source-inline">pet-owner</strong> microservice project (created in <em class="italic">Chapter 2</em>, <em class="italic">Working on the Data Access</em>) in your preferred IDE. Add the <strong class="source-inline">com.packtpub.micronaut.service.dto</strong> package to contain all DTOs. We can define <strong class="source-inline">OwnerDTO</strong> as follows:</p>
			<p class="source-code">@Introspected</p>
			<p class="source-code">public class OwnerDTO implements Serializable {</p>
			<p class="source-code">    private Long id;</p>
			<p class="source-code">    private String firstName;</p>
			<p class="source-code">    private String lastName;</p>
			<p class="source-code">    private String address;</p>
			<p class="source-code">    private String city;</p>
			<p class="source-code">    private String telephone;</p>
			<p class="source-code">    private Set&lt;PetDTO&gt; pets = new HashSet&lt;&gt;();</p>
			<p class="source-code">    … getters and setters</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">OwnerDTO</strong> is implementing the <strong class="source-inline">Serializable</strong> marker interface to mark that the DTO is serializable. Furthermore, in continuation of our earlier discussion on the assembler pattern, <strong class="source-inline">OwnerDTO</strong> will also contain a set of <strong class="source-inline">PetDTO</strong> instances.</p>
			<p>Following the<a id="_idIndexMarker256"/> similar POJO model, we can define DTOs for other entities in the <strong class="source-inline">pet-owner</strong> microservice, such as <strong class="source-inline">PetDTO</strong>, <strong class="source-inline">VisitDTO</strong>, and <strong class="source-inline">PetTypeDTO</strong> in the <strong class="source-inline">com.packtpub.micronaut.service.dto</strong> package.</p>
			<p>In the next section, we will work on mapping these DTOs to database entities.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Using MapStruct to define mappers</h2>
			<p><strong class="bold">MapStruct</strong> is a<a id="_idIndexMarker257"/> code generator that uses annotation processing to implement mappings between source and target Java classes. The implemented MapStruct code consists of plain method calls, therefore it's type-safe and easy to read code. Since we don't need to write code for these mappings, MapStruct is very effective in reducing the source code footprint. </p>
			<p>To map DTOs to entities and vice versa, we will use MapStruct in our <strong class="source-inline">pet-owner</strong> microservice. Since we are using Maven, we will have to add the following to the <strong class="source-inline">pom.xml</strong> project:</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;properties&gt;</p>
			<p class="source-code">    &lt;org.mapstruct.version&gt;1.3.1.Final&lt;/org.mapstruct.version&gt;</p>
			<p class="source-code">&lt;/properties&gt;</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;dependencies&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</p>
			<p class="source-code">        &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</p>
			<p class="source-code">        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p class="source-code">&lt;/dependencies&gt;</p>
			<p>By importing <a id="_idIndexMarker258"/>MapStruct into the project, POM will allow us to leverage the MapStruct toolkit. Furthermore, for the Maven compiler, we will need to add MapStruct to <strong class="source-inline">annotationProcessorPaths</strong>:</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;build&gt;</p>
			<p class="source-code">    &lt;plugins&gt;</p>
			<p class="source-code">        &lt;plugin&gt;</p>
			<p class="source-code">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</p>
			<p class="source-code">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</p>
			<p class="source-code">            &lt;configuration&gt;</p>
			<p class="source-code">                …</p>
			<p class="source-code">                &lt;annotationProcessorPaths&gt;</p>
			<p class="source-code">                    &lt;path&gt;</p>
			<p class="source-code">                        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</p>
			<p class="source-code">                        &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</p>
			<p class="source-code">                        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;</p>
			<p class="source-code">                    &lt;/path&gt;</p>
			<p class="source-code">                    &lt;!-- other annotation processors --&gt;</p>
			<p class="source-code">                &lt;/annotationProcessorPaths&gt;</p>
			<p class="source-code">    &lt;compilerArgs&gt;</p>
			<p class="source-code">                    &lt;arg&gt;-Amapstruct.defaultComponentModel=jsr330&lt;/arg&gt;</p>
			<p class="source-code">                     ….</p>
			<p class="source-code">               &lt;/compilerArgs&gt;</p>
			<p class="source-code">            &lt;/configuration&gt;</p>
			<p class="source-code">        &lt;/plugin&gt;</p>
			<p class="source-code">    &lt;/plugins&gt;</p>
			<p class="source-code">&lt;/build&gt; </p>
			<p>The annotation<a id="_idIndexMarker259"/> processing settings in POM will direct the Java annotation processor to generate source code for any mappings that are marked using MapStruct annotations. In addition, <strong class="source-inline">jsr330</strong> is specified as a default component model in the context of the Micronaut framework (in Spring, a Spring model is often used). </p>
			<p>We will create a new package named <strong class="source-inline">com.packtpub.micronaut.service.mapper</strong> to contain all the mapper interfaces. To abstract out a generic entity mapper, we can declare the following interface:</p>
			<p class="source-code">public interface EntityMapper &lt;D, E&gt; {</p>
			<p class="source-code">    E toEntity(D dto);</p>
			<p class="source-code">    D toDto(E entity);</p>
			<p class="source-code">    List &lt;E&gt; toEntity(List&lt;D&gt; dtoList);</p>
			<p class="source-code">    List &lt;D&gt; toDto(List&lt;E&gt; entityList);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">EntityMapper</strong> interface abstracts out object-to-object and list-to-list conversion methods. By extending this interface, we can easily define an interface to map <strong class="source-inline">OwnerDTO</strong> to the <strong class="source-inline">Owner</strong> entity:</p>
			<p class="source-code">@Mapper(componentModel = "jsr330", uses = {PetMapper.class})</p>
			<p class="source-code">public interface OwnerMapper extends EntityMapper&lt;OwnerDTO, Owner&gt; {</p>
			<p class="source-code">    default Owner fromId(Long id) {</p>
			<p class="source-code">        if (id == null) {</p>
			<p class="source-code">            return null;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        Owner owner = new Owner();</p>
			<p class="source-code">        owner.setId(id);</p>
			<p class="source-code">        return owner;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">OwnerMapper</strong> interface extends <strong class="source-inline">EntityMapper</strong> and uses <strong class="source-inline">PetMapper</strong>. <strong class="source-inline">PetMapper</strong> is used to map a set of <strong class="source-inline">PetDTO</strong> instances to <strong class="source-inline">Pet</strong> entities. <strong class="source-inline">PetMapper</strong> can be defined using a very similar approach.</p>
			<p>Adhering to the<a id="_idIndexMarker260"/> same approach, we can thus define <strong class="source-inline">PetMapper</strong>, <strong class="source-inline">VisitMapper</strong>, and <strong class="source-inline">PetTypeMapper</strong> for the <strong class="source-inline">Pet</strong>, <strong class="source-inline">Visit</strong>, and <strong class="source-inline">PetType</strong> entities, respectively. </p>
			<p>So far, we have dived into DTOs and their mappings to corresponding entity classes. In the next section, we will zero down on the service changes concerning DTOs. </p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Modifying the services to use DTOs</h2>
			<p>In <a href="B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Working on the Data Access</em>, to simplify the discussion, we defined service methods <a id="_idIndexMarker261"/>that used entity classes directly. This approach is <a id="_idIndexMarker262"/>not recommended for a variety of reasons, including the fact that we end up colluding/coupling business logic with database entities or it can become hairy if a service method needs to use multiple entities. Put simply, we must separate the concerns by decoupling database entities from business-required data objects. </p>
			<p>To use DTOs in business services, we will need to modify abstracting interfaces. The <strong class="source-inline">OwnerService</strong> interface can be modified to use DTOs as follows:</p>
			<p class="source-code">public interface OwnerService {</p>
			<p class="source-code">    OwnerDTO save(OwnerDTO ownerDTO);</p>
			<p class="source-code">    Page&lt;OwnerDTO&gt; findAll(Pageable pageable);</p>
			<p class="source-code">    Optional&lt;OwnerDTO&gt; findOne(Long id);</p>
			<p class="source-code">    void delete(Long id);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">save()</strong> method<a id="_idIndexMarker263"/> is modified to save <strong class="source-inline">OwnerDTO</strong> instead of<a id="_idIndexMarker264"/> the <strong class="source-inline">Owner</strong> entity. Also, <strong class="source-inline">findAll()</strong> and <strong class="source-inline">findOne()</strong> will return <strong class="source-inline">OwnerDTO</strong> instead of <strong class="source-inline">Owner</strong>.</p>
			<p>Complying with the same approach, we can modify these service interfaces for other entities in the <strong class="source-inline">pet-owner</strong> microservice, that is, <strong class="source-inline">PetService</strong>, <strong class="source-inline">PetTypeService</strong>, and <strong class="source-inline">VisitService</strong>.</p>
			<p>Since we modified abstracting service interfaces, we will have to modify implementing classes too. <strong class="source-inline">OwnerServiceImpl</strong> can be modified to use DTOs like so:  </p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">@Transactional</p>
			<p class="source-code">public class OwnerServiceImpl implements OwnerService {</p>
			<p class="source-code">    … injections for OwnerRepository and OwnerMapper</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public OwnerDTO save(OwnerDTO ownerDTO) {</p>
			<p class="source-code">        Owner owner = ownerMapper.toEntity(ownerDTO);</p>
			<p class="source-code">        owner = ownerRepository.mergeAndSave(owner);</p>
			<p class="source-code">        return ownerMapper.toDto(owner);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    @ReadOnly</p>
			<p class="source-code">    @Transactional</p>
			<p class="source-code">    public Page&lt;OwnerDTO&gt; findAll(Pageable pageable) {</p>
			<p class="source-code">        return ownerRepository.findAll(pageable)</p>
			<p class="source-code">                .map(ownerMapper::toDto);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    @ReadOnly</p>
			<p class="source-code">    @Transactional</p>
			<p class="source-code">    public Optional&lt;OwnerDTO&gt; findOne(Long id) {</p>
			<p class="source-code">        return ownerRepository.findById(id)</p>
			<p class="source-code">                .map(ownerMapper::toDto);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void delete(Long id) {</p>
			<p class="source-code">        ownerRepository.deleteById(id);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">save()</strong> method will use <strong class="source-inline">OwnerMapper</strong> to convert <strong class="source-inline">OwnerDTO</strong> to the entity before the repository<a id="_idIndexMarker265"/> method is called. Similarly, fetch <a id="_idIndexMarker266"/>methods will convert <strong class="source-inline">Owner</strong> entities back to <strong class="source-inline">OwnerDTO</strong>s before returning the responses.</p>
			<p>Following the same approach, we can modify <strong class="source-inline">PetServiceImpl</strong>, <strong class="source-inline">PetTypeServiceImpl</strong>, and <strong class="source-inline">VisitServiceImpl</strong>.</p>
			<p>So far, we have focused on DTOs and how we can easily use DTOs by mapping them on entity objects using the MapStruct framework. In the next section, we will center our attention on how to create restful endpoints for the <strong class="source-inline">pet-owner</strong> microservice.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Creating the restful endpoints for a microservice</h1>
			<p>Using the <a id="_idIndexMarker267"/>Micronaut framework, we can create all<a id="_idIndexMarker268"/> commonly used HTTP methods, namely GET, PUT, POST, and DELETE. At the core, all HTTP concerns are encapsulated in the <strong class="source-inline">io.micronaut.http</strong> package. This package contains <strong class="source-inline">HttpRequest</strong> and <strong class="source-inline">HttpResponse</strong> interfaces. These interfaces are the bedrock of defining any HTTP endpoint. Using these standard implementations, we will cover all HTTP methods in the following sections. </p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Creating an endpoint for retrieving a list of resources</h2>
			<p>To create an <a id="_idIndexMarker269"/>endpoint for fetching a list of resources, we can begin by adding the <strong class="source-inline">com.packtpub.micronaut.web.rest</strong> package to contain all controller resources. We will add a fetch all owners endpoint to the <strong class="source-inline">OwnerResource</strong> controller in the <strong class="source-inline">pet-owner</strong> microservice:</p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">public class OwnerResource {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    @Get("/owners")</p>
			<p class="source-code">    @ExecuteOn(TaskExecutors.IO)</p>
			<p class="source-code">    public HttpResponse&lt;List&lt;OwnerDTO&gt;&gt; getAllOwners(HttpRequest request, Pageable pageable) {</p>
			<p class="source-code">        log.debug("REST request to get a page of Owners");</p>
			<p class="source-code">        Page&lt;OwnerDTO&gt; page = ownerService.findAll(pageable);</p>
			<p class="source-code">        return HttpResponse.ok(page.getContent()).headers(headers -&gt;</p>
			<p class="source-code">            PaginationUtil.generatePaginationHttpHeaders(headers, UriBuilder.of(request.getPath()), page));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>There are a <a id="_idIndexMarker270"/>few things we need to ponder here:</p>
			<ol>
				<li><strong class="source-inline">@Controller</strong>: This is a stereotype that marks <strong class="source-inline">OwnerResource</strong> as a restful controller and is exposed on the <strong class="source-inline">/api</strong> base URL.</li>
				<li><strong class="source-inline">@Get</strong>: This annotation is used to expose the <strong class="source-inline">getAllOwners()</strong> method on HTTP get over the relative URL of <strong class="source-inline">/owners</strong>. </li>
				<li><strong class="source-inline">@ExecuteOn</strong>: This annotation specifies to execute this GET request on the I/O thread pool. The value of the <strong class="source-inline">@ExecuteOn</strong> annotation can be any executor defined in <strong class="source-inline">micronaut.executors</strong>.</li>
				<li><strong class="source-inline">HttpRequest</strong>: <strong class="source-inline">getAllOwners()</strong> takes on <strong class="source-inline">HttpRequest</strong> as an input parameter. Often, <strong class="source-inline">HttpRequest</strong> is passed to trace and log details of the origin, for example, which IP address is submitting the request. </li>
				<li><strong class="source-inline">pageable</strong>: This is a standard interface in the <strong class="source-inline">io.micronaut.data.model</strong> package and is often used to pass pagination information in the request, for example, <strong class="source-inline">…/api/owners?page=1&amp;size=50&amp;sort=(firstName)</strong>. This pagination information is often optional and passed as query parameters. </li>
				<li><strong class="source-inline">HttpResponse</strong>: <strong class="source-inline">getAllOwners()</strong> returns <strong class="source-inline">HttpResponse</strong>, which is a generic interface and embodies a specific type of response within the example. In this example, it is returning <strong class="source-inline">List&lt;OwnerDTO&gt;</strong>.</li>
				<li><strong class="source-inline">PaginationUtil</strong>: This is a custom class in the <strong class="source-inline">com.packtpub.micronaut.util</strong> package and it generates paged responses.</li>
			</ol>
			<p>We can run<a id="_idIndexMarker271"/> the <strong class="source-inline">pet-owner</strong> service locally and by default, it will run on port <strong class="source-inline">8080</strong>. We can use any REST client and hit <strong class="source-inline">http://localhost:8080/api/owners</strong> and we will get the following response:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.2_B16585.jpg" alt="Figure 3.2 – Retrieving all owners&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Retrieving all owners</p>
			<p>As shown in the preceding screenshot, when we call the fetch all owners endpoint, we are not passing any pagination information to get all owners. Therefore, it will retrieve all the owners and their pet information from the database.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Creating an endpoint for retrieving a specific resource</h2>
			<p>To create an endpoint<a id="_idIndexMarker272"/> for fetching a specific resource, we will add a method in <strong class="source-inline">OwnerResource</strong> to fetch a specific owner, as follows:</p>
			<p class="source-code">@Get("/owners/{id}")</p>
			<p class="source-code">@ExecuteOn(TaskExecutors.IO)</p>
			<p class="source-code">public HttpResponse&lt;Optional&lt;OwnerDTO&gt;&gt; getOwner(@PathVariable Long id) {</p>
			<p class="source-code">    log.debug("REST request to get Owner : {}", id);</p>
			<p class="source-code">    return ownerService.findOne(id);</p>
			<p class="source-code">}</p>
			<p>There are a few things we need to ponder here:</p>
			<ol>
				<li value="1"><strong class="source-inline">@PathVariable</strong>: This is used to specify and match a path variable in the HTTP call. In the proceeding example, we are passing the owner ID as a path variable.</li>
				<li><strong class="source-inline">Optional</strong>: In this example, we are returning an optional object. If the service can find an owner for the specified ID, then an <strong class="source-inline">HTTP 200</strong> response will be sent; otherwise, <strong class="source-inline">HTTP 404</strong> will be reverted. </li>
			</ol>
			<p>We can run the <strong class="source-inline">pet-owner</strong> service locally and by default, it will run on port <strong class="source-inline">8080</strong>. We can use any rest client and by hitting <strong class="source-inline">http://localhost:8080/api/owners/1</strong>, we will get the following response:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_3.3_B16585.jpg" alt="Figure 3.3 – Retrieving a specific owner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Retrieving a specific owner</p>
			<p><strong class="source-inline">OwnerDTO</strong> encapsulated<a id="_idIndexMarker273"/> the pet data as well so the response payload will fetch complete details about the owner with ID <strong class="source-inline">1</strong>. Furthermore, if any non-existing ID is passed to the proceeding HTTP request, then it will result in <strong class="source-inline">HTTP 404</strong>:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_3.4_B16585.jpg" alt="Figure 3.4 – Retrieving a non-existing owner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Retrieving a non-existing owner</p>
			<p>In the preceding API call, we tried to fetch an owner with the <strong class="source-inline">123789</strong> ID, but since we don't have an owner with this ID, it results in an <strong class="source-inline">HTTP 404</strong> <strong class="source-inline">not found</strong> response. </p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Creating an endpoint for inserting a resource</h2>
			<p>To create an <a id="_idIndexMarker274"/>endpoint to insert a resource, we will add an HTTP POST method to <strong class="source-inline">OwnerResource</strong> as follows: </p>
			<p class="source-code">…</p>
			<p class="source-code">@Post("/owners")</p>
			<p class="source-code">@ExecuteOn(TaskExecutors.IO)</p>
			<p class="source-code">public HttpResponse&lt;OwnerDTO&gt; createOwner(@Body OwnerDTO ownerDTO) throws URISyntaxException {</p>
			<p class="source-code">    if (ownerDTO.getId() != null) {</p>
			<p class="source-code">        throw new BadRequestAlertException("A new owner cannot already have an ID", ENTITY_NAME, "idexists");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    OwnerDTO result = ownerService.save(ownerDTO);</p>
			<p class="source-code">    URI location = new URI("/api/owners/" + result.getId());</p>
			<p class="source-code">    return HttpResponse.created(result).headers(headers -&gt; {</p>
			<p class="source-code">        headers.location(location);</p>
			<p class="source-code">        HeaderUtil.createEntityCreationAlert(headers, applicationName, true, ENTITY_NAME, result.getId().toString());</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p class="source-code">…</p>
			<p>There are a few things to pay attention to here:</p>
			<ol>
				<li value="1"><strong class="source-inline">@Post</strong>: <strong class="source-inline">createOwner()</strong> is exposed using the <strong class="source-inline">@Post</strong> annotation as an HTTP POST API.</li>
				<li><strong class="source-inline">@ExecuteOn</strong>: This annotation specifies to execute this POST request on the I/O thread pool.</li>
				<li><strong class="source-inline">@Body</strong>: The <strong class="source-inline">@Body</strong> annotation specifies that the <strong class="source-inline">ownerDTO</strong> method argument in <strong class="source-inline">createOwner()</strong> is bound to the body of the incoming HTTP POST request. </li>
				<li><strong class="source-inline">Not null id check</strong>: Using an <strong class="source-inline">if</strong> construct, we are quickly checking that the HTTP body doesn't contain a payload with the ID already defined. This is a case of asserting<a id="_idIndexMarker275"/> a business validation and if it fails, then the API is throwing a bad request exception. </li>
				<li><strong class="source-inline">HttpResponse.created</strong>: In the happy path scenario, the API will return <strong class="source-inline">HTTP 201</strong> created. This response indicates that the request was executed successfully and a resource was created. </li>
			</ol>
			<p>We can boot up the <strong class="source-inline">pet-owner</strong> microservice locally and hit an HTTP POST request in a rest client as follows: </p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_3.5_B16585.jpg" alt="Figure 3.5 – Inserting an owner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Inserting an owner</p>
			<p>In the<a id="_idIndexMarker276"/> preceding HTTP POST call, we passed an owner object to be inserted in the HTTP body. As anticipated, the API call was successful and returned an <strong class="source-inline">HTTP 201</strong> <strong class="source-inline">created</strong> response. </p>
			<p>Furthermore, if we try to hit this HTTP POST method to create an owner that has an ID value already, then it will fail:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_3.6_B16585.jpg" alt="Figure 3.6 – Inserting an existing owner again&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Inserting an existing owner again</p>
			<p>When we<a id="_idIndexMarker277"/> try to insert an owner with an ID value in the body payload, then an <strong class="source-inline">HTTP 500</strong> internal server error is thrown with a message – <strong class="source-inline">Internal Server Error: A new owner cannot already have an ID</strong>. </p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Creating an endpoint for updating a resource</h2>
			<p>To create an<a id="_idIndexMarker278"/> endpoint to update a resource, we will add an HTTP PUT method to <strong class="source-inline">OwnerResource</strong> as follows:</p>
			<p class="source-code">…</p>
			<p class="source-code">@Put("/owners")</p>
			<p class="source-code">@ExecuteOn(TaskExecutors.IO)</p>
			<p class="source-code">public HttpResponse&lt;OwnerDTO&gt; updateOwner(@Body OwnerDTO ownerDTO) throws URISyntaxException {</p>
			<p class="source-code">    log.debug("REST request to update Owner : {}", ownerDTO);</p>
			<p class="source-code">    if (ownerDTO.getId() == null) {</p>
			<p class="source-code">        throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    OwnerDTO result = ownerService.save(ownerDTO);</p>
			<p class="source-code">    return HttpResponse.ok(result).headers(headers -&gt;</p>
			<p class="source-code">            HeaderUtil.createEntityUpdateAlert(headers, applicationName, true, ENTITY_NAME, ownerDTO.getId().toString()));</p>
			<p class="source-code">}</p>
			<p class="source-code">…</p>
			<p>A few <a id="_idIndexMarker279"/>things to ponder here:</p>
			<ol>
				<li value="1"><strong class="source-inline">@Put</strong>: The <strong class="source-inline">@Put</strong> annotation exposes the <strong class="source-inline">updateOwner()</strong> method as an HTTP PUT API. </li>
				<li><strong class="source-inline">@ExecuteOn</strong>: This annotation specifies to execute this PUT request on the I/O thread pool. The I/O thread pool is a mechanism to achieve I/O concurrency by maintaining a quorum of threads waiting to be assigned the I/O requests. </li>
				<li><strong class="source-inline">@Body</strong>: The <strong class="source-inline">@Body</strong> annotation specifies that the <strong class="source-inline">ownerDTO</strong> method argument in <strong class="source-inline">createOwner()</strong> is bound to the body of the incoming HTTP PUT request. </li>
				<li><strong class="source-inline">Null id check</strong>: Using an <strong class="source-inline">if</strong> construct, we are quickly checking that the HTTP body doesn't contain a payload with a null ID. If the ID is null, then the API is throwing a bad request exception. </li>
				<li><strong class="source-inline">HttpResponse.ok</strong>: In the happy path scenario, the API will return <strong class="source-inline">HTTP 200</strong>. This response indicates that the request was executed successfully and a resource <a id="_idIndexMarker280"/>was updated. </li>
			</ol>
			<p>We can boot up the <strong class="source-inline">pet-owner</strong> microservice locally and hit an HTTP PUT request in a rest client like so:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_3.7_B16585.jpg" alt="Figure 3.7 – Updating an owner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Updating an owner</p>
			<p>In the HTTP PUT request, we <a id="_idIndexMarker281"/>requested to update a resource we just inserted previously. We are updating the address and city for this resource. As anticipated, the request was executed successfully and an <strong class="source-inline">HTTP 200</strong> response was returned. </p>
			<p>If we try to update a resource with a null ID, then it will fail:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_3.8_B16585.jpg" alt="Figure 3.8 – Updating a non-existing owner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Updating a non-existing owner</p>
			<p>In the <a id="_idIndexMarker282"/>preceding HTTP PUT call, we tried to update an owner with a null ID. An <strong class="source-inline">HTTP 500</strong> internal server error is thrown with a message – <strong class="source-inline">Internal Server Error: Invalid id</strong>. </p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Creating an endpoint for deleting a resource</h2>
			<p>To exhibit <a id="_idIndexMarker283"/>deleting a resource, we can add an HTTP DELETE method to <strong class="source-inline">OwnerResource</strong> as follows:</p>
			<p class="source-code">…</p>
			<p class="source-code">@Delete("/owners/{id}")</p>
			<p class="source-code">@ExecuteOn(TaskExecutors.IO)</p>
			<p class="source-code">public HttpResponse deleteOwner(@PathVariable Long id) {</p>
			<p class="source-code">    log.debug("REST request to delete Owner : {}", id);</p>
			<p class="source-code">    ownerService.delete(id);</p>
			<p class="source-code">    return HttpResponse.noContent().headers(headers -&gt; HeaderUtil.createEntityDeletionAlert(headers, applicationName, true, ENTITY_NAME, id.toString()));</p>
			<p class="source-code">}</p>
			<p class="source-code">…</p>
			<p> A few things to ponder here:</p>
			<ol>
				<li value="1"><strong class="source-inline">@Delete</strong>: The <strong class="source-inline">@Delete</strong> annotation exposes the <strong class="source-inline">deleteOwner()</strong> method as an HTTP DELETE API. </li>
				<li><strong class="source-inline">@ExecuteOn</strong>: This annotation specifies to execute this PUT request on the I/O thread pool.</li>
				<li><strong class="source-inline">@PathVariable</strong>: <strong class="source-inline">@PathVariable</strong> binds the ID parameter in the <strong class="source-inline">deleteOwner()</strong> method to the variable specified in the HTTP request URL.</li>
				<li><strong class="source-inline">HttpResponse.noContent</strong>: In the happy path scenario, the API will return <strong class="source-inline">HTTP 204</strong>. This <a id="_idIndexMarker284"/>response indicates that the request was executed successfully and there is no additional content in the response payload. </li>
			</ol>
			<p>We can boot up the <strong class="source-inline">pet-owner</strong> microservice locally and hit an HTTP DELETE request in a rest client:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_3.9_B16585.jpg" alt="Figure 3.9 – Deleting an owner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Deleting an owner</p>
			<p>We requested to delete the owner that we inserted/updated in previous examples. As anticipated, the request was successful and an <strong class="source-inline">HTTP 204</strong> response was returned.</p>
			<p>So far, we have explored how to create all different types of restful endpoints. This discussion paves our way into using Micronaut's HTTP server APIs. In the next section, we will cover some practical aspects of leveraging these server APIs.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Using Micronaut's HTTP server APIs</h1>
			<p>The Micronaut <a id="_idIndexMarker285"/>framework offers a non-blocking HTTP server based on Netty. These server APIs can be leveraged to address some useful microservice requirement scenarios. To do any hands-on work, we will continue with the <strong class="source-inline">pet-owner</strong> microservice. </p>
			<p>At the outset, we must have the following Maven dependency in the project POM:</p>
			<p class="source-code">…</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">&lt;groupId&gt;io.micronaut&lt;/groupId&gt;</p>
			<p class="source-code">&lt;artifactId&gt;micronaut-http-server-netty&lt;/artifactId&gt;</p>
			<p class="source-code">&lt;scope&gt;compile&lt;/scope&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p class="source-code">…</p>
			<p>This dependency should already be in the <strong class="source-inline">pet-owner</strong> project. In the next sections, we will explore some useful configurations in the HTTP server world.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Binding HTTP requests in the Micronaut framework</h2>
			<p>There are <a id="_idIndexMarker286"/>several ways we can bind arguments<a id="_idIndexMarker287"/> to an HTTP request in the Micronaut framework: </p>
			<ul>
				<li><strong class="source-inline">@Body</strong>: As discussed before, <strong class="source-inline">@Body</strong> binds the argument from the body of the HTTP request. </li>
				<li><strong class="source-inline">@CookieValue</strong>: This binds an argument from the cookie value in the HTTP request. </li>
				<li><strong class="source-inline">@Header</strong>: This binds an argument from a header in the HTTP request.</li>
				<li><strong class="source-inline">@QueryValue</strong>: This binds an argument from a query parameter in the HTTP request.</li>
				<li><strong class="source-inline">@PathVariable</strong>: This binds an argument from the path in the HTTP request. </li>
				<li><strong class="source-inline">@Part</strong>: In a multi-part HTTP request, this binds the argument to a part. </li>
				<li><strong class="source-inline">@RequestBean</strong>: This binds any object (in the HTTP request) to a Java bean.</li>
			</ul>
			<p>Along with<a id="_idIndexMarker288"/> the preceding HTTP request bindings, the<a id="_idIndexMarker289"/> Micronaut framework supports multiple URI templates. These templates come in handy in creating various kinds of restful microservices. Considering the owner resource, we can support the following URI template matching in Micronaut:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Table_3.2.jpg" alt="Table 3.2 – URI templates in the Micronaut framework&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 3.2 – URI templates in the Micronaut framework</p>
			<p>In the preceding table, we can see various approaches in matching/restricting an incoming HTTP request and what each approach can achieve for a specific resource. In the next section, we will discuss how we can validate the data in an HTTP request. </p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Validating data</h2>
			<p>The Micronaut framework<a id="_idIndexMarker290"/> supports both JSR 380 bean validations as well as hibernate bean validations. By default, a Micronaut project usually contains a <strong class="source-inline">micronaut-validation</strong> dependency, which is implemented based on the JSR 380 standard. </p>
			<p>Using validation annotations such as <strong class="source-inline">@NotNull</strong> and <strong class="source-inline">@NotEmpty</strong>, we can verify whether an argument/parameter is meeting all the validation criteria or not before processing a request. Some useful annotations are as follows:</p>
			<ul>
				<li><strong class="source-inline">@NotNull</strong>: This asserts if the argument/parameter value is not null, for example, <strong class="source-inline">@NotNull @PathVariable String ownerId</strong>.</li>
				<li><strong class="source-inline">@NotEmpty</strong>: This asserts if the argument is not null and not empty. It can be applied to any argument of the <strong class="source-inline">String</strong>, <strong class="source-inline">Collection</strong>, or <strong class="source-inline">Map</strong> type, and so on, for example, <strong class="source-inline">@NotEmpty @PathVariable String ownerId</strong>.</li>
				<li><strong class="source-inline">@Min</strong>: This validates that the annotated property has a value greater than or equal to the <strong class="source-inline">value</strong> attribute, for example, <strong class="source-inline">@Min(value = 0) Integer offset</strong>.</li>
				<li><strong class="source-inline">@Max</strong>: This validates that the annotated property has a value equal to or smaller than the <strong class="source-inline">value</strong> attribute, for example, <strong class="source-inline">@Max(value =100) Integer offset</strong>.</li>
				<li><strong class="source-inline">@Valid</strong>: <strong class="source-inline">@Valid</strong> validates all arguments/parameters within the object graph. It recursively scans all inner <strong class="source-inline">@Valid</strong> usages within the object graph and determines the final validation after checking everything. </li>
			</ul>
			<p>If any of these validations are not met, then <strong class="source-inline">javax.validation.ConstraintViolationException</strong> is thrown. </p>
			<p>To handle constraint violation exceptions as well as other checked/unchecked exceptions, we will explore some options in the next section. </p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Handling errors</h2>
			<p>The Micronaut framework provides<a id="_idIndexMarker291"/> good coverage on raising different kinds of exceptions throughout the life cycle of an HTTP request along with handling these exceptions. The standard exception handlers can be found in the <strong class="source-inline">io.micronaut.http.server.exceptions</strong> package. By default, the following handlers are provided within this package:</p>
			<ul>
				<li><strong class="source-inline">ContentLengthExceededHandler</strong>: This handles <strong class="source-inline">ContentLengthExceededException</strong> by returning an <strong class="source-inline">HttpStatus.REQUEST_ENTITY_TOO_LARGE</strong> response.</li>
				<li><strong class="source-inline">ConversionErrorHandler</strong>: This handles <strong class="source-inline">ConversionErrorException</strong> by returning an <strong class="source-inline">HttpStatus.BAD_REQUEST</strong> response.</li>
				<li><strong class="source-inline">HttpStatusHandler</strong>: This handles <strong class="source-inline">HttpStatusException</strong> by returning <strong class="source-inline">HttpStatus</strong> as specified in the <strong class="source-inline">HttpStatusException</strong> response.  </li>
				<li><strong class="source-inline">JsonExceptionHandler</strong>: This handles <strong class="source-inline">JsonProcessingException</strong> by returning an <strong class="source-inline">HttpStatus.BAD_REQUEST</strong> response.</li>
				<li><strong class="source-inline">UnsatisfiedArgumentHandler</strong>: This handles <strong class="source-inline">UnsatisfiedArgumentException</strong> by returning an <strong class="source-inline">HttpStatus.BAD_REQUEST</strong> response.</li>
				<li><strong class="source-inline">URISyntaxHandler</strong>: This handles <strong class="source-inline">URISyntaxException</strong> by returning an <strong class="source-inline">HttpStatus.BAD_REQUEST</strong> response.</li>
			</ul>
			<p>In addition to the preceding standard exceptions and exception handlers, we can create our custom exceptions and exception handlers.</p>
			<p>We can assume a hypothetical <strong class="source-inline">FooException</strong> that can be raised by a microservice: </p>
			<p class="source-code">public class FooException extends RuntimeException {</p>
			<p class="source-code">…</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">FooException</strong> extends <strong class="source-inline">RuntimeException</strong>, which makes it an unchecked exception, and we can <a id="_idIndexMarker292"/>create <strong class="source-inline">FooExceptionHandler</strong> to handle this exception:</p>
			<p class="source-code">@Produces</p>
			<p class="source-code">@Singleton </p>
			<p class="source-code">@Requires(classes = {FooException.class, ExceptionHandler.class})  </p>
			<p class="source-code">public class FooExceptionHandler implements ExceptionHandler&lt;FooException, HttpResponse&gt; { </p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public HttpResponse handle(HttpRequest request, FooException exception) {</p>
			<p class="source-code">        JsonError error = new JsonError(exception.getMessage());</p>
			<p class="source-code">        error.path('/' + exception.getArgument().getName());</p>
			<p class="source-code">        error.link(Link.SELF, Link.of(request.getUri()));</p>
			<p class="source-code">        return HttpResponse.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">FooExceptionHandler</strong> bean injection mandates the required injection of <strong class="source-inline">FooException</strong> and <strong class="source-inline">ExceptionHandler</strong>. At any place within the code base, if <strong class="source-inline">FooException</strong> is raised, it will be caught by <strong class="source-inline">FooExceptionHandler</strong> and a <strong class="source-inline">HttpStatus.INTERNAL_SERVER_ERROR</strong> response will be returned.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Versioning the APIs</h2>
			<p>Micronaut supports API versioning<a id="_idIndexMarker293"/> by using the <strong class="source-inline">@Version</strong> annotation. This annotation can be used at the controller or method level. </p>
			<p>Versioning is not supported by default and to enable versioning, we must make the following changes in <strong class="source-inline">application.yml</strong>:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  application:</p>
			<p class="source-code">    name: Pet-Owner</p>
			<p class="source-code">  router:</p>
			<p class="source-code">    versioning:</p>
			<p class="source-code">      enabled: true</p>
			<p class="source-code">      default-version: 1</p>
			<p class="source-code">…..</p>
			<p>In the configuration, we have enabled versioning and by default, if no version is specified, then the incoming request will be served by the version <strong class="source-inline">1</strong> API.</p>
			<p>To exhibit versioning, we will add <strong class="source-inline">@Version</strong> to the <strong class="source-inline">getOwner()</strong> method of <strong class="source-inline">OwnerResource</strong> in the <strong class="source-inline">pet-owner</strong> microservice:</p>
			<p class="source-code">@Version("1")</p>
			<p class="source-code">@Get("/owners/{id}")</p>
			<p class="source-code">@ExecuteOn(TaskExecutors.IO)</p>
			<p class="source-code">public Optional&lt;OwnerDTO&gt; getOwner(@PathVariable Long id) {</p>
			<p class="source-code">    log.debug("REST request to get Owner : {}", id);</p>
			<p class="source-code">    return ownerService.findOne(id);</p>
			<p class="source-code">}</p>
			<p class="source-code">…</p>
			<p class="source-code">@Version("2")</p>
			<p class="source-code">@Get("/owners/{id}")</p>
			<p class="source-code">@ExecuteOn(TaskExecutors.IO)</p>
			<p class="source-code">public Optional&lt;OwnerDTO&gt; getOwnerV2(@PathVariable Long id) {</p>
			<p class="source-code">    log.debug("REST request to get Owner : {}", id);</p>
			<p class="source-code">    return ownerService.findOne(id);</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">@Version</strong> allows <a id="_idIndexMarker294"/>multiple projections of the <strong class="source-inline">getOwner()</strong> method. This annotation comes in handy in supporting event-driven microservices.</p>
			<p>To test these changes, we can run <strong class="source-inline">pet-owner</strong> locally and use the advanced rest client to make a call to <strong class="source-inline">getOwner()</strong>:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_3.10_B16585.jpg" alt="Figure 3.10 – Calling a versioned API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Calling a versioned API</p>
			<p>In the preceding<a id="_idIndexMarker295"/> HTTP call, we specified the version using the <strong class="source-inline">X-API-VERSION</strong> header. As per the value specified in this header, this call will be served by the version <strong class="source-inline">2</strong> API.</p>
			<p>So far, we have explored how to leverage HTTP server APIs in the Micronaut framework. In the next section, we will focus our attention on HTTP client aspects.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Using Micronaut's HTTP client APIs</h1>
			<p>Micronaut's<a id="_idIndexMarker296"/> HTTP client is a non-blocking client based on Netty with baked-in cloud features such as service discovery and load balancing. This custom implementation enhances the standard HTTP client with microservices architecture. </p>
			<p>To exhibit basic HTTP calls, we will create an HTTP client for <strong class="source-inline">OwnerResource</strong> in the <strong class="source-inline">pet-owner</strong> microservice. At the outset, we must have the <strong class="source-inline">micronaut-http-client</strong> dependency in the <strong class="source-inline">pom.xml</strong> project:</p>
			<p class="source-code">…</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">&lt;groupId&gt;io.micronaut&lt;/groupId&gt;</p>
			<p class="source-code">&lt;artifactId&gt;micronaut-http-client&lt;/artifactId&gt;</p>
			<p class="source-code">&lt;scope&gt;compile&lt;/scope&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p class="source-code">…</p>
			<p><strong class="source-inline">micronaut-http-client</strong> encapsulated<a id="_idIndexMarker297"/> all HTTP client-related APIs, such as creating <strong class="source-inline">RxHttpClient</strong>, performing all HTTP operations, and handling and processing response payloads. </p>
			<p>Next, we will explore how to leverage <strong class="source-inline">micronaut-http-client</strong> to perform various HTTP operations on the endpoint we created earlier.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Performing an HTTP PUT operation</h2>
			<p>To perform an<a id="_idIndexMarker298"/> HTTP PUT operation, we can create <strong class="source-inline">OwnerResourceClient</strong>. This client can be packaged inside <strong class="source-inline">com.packtpub.micronaut.web.rest.client</strong>. </p>
			<p>We can add the following method to perform an HTTP call:</p>
			<p class="source-code">public List&lt;OwnerDTO&gt; getAllOwnersClient() throws MalformedURLException {</p>
			<p class="source-code">    HttpClient client = HttpClient.create(new URL("https://" + server.getHost() + ":" + server.getPort()));</p>
			<p class="source-code">    OwnerDTO[] owners = client.toBlocking().retrieve(HttpRequest.GET("/api/owners"), OwnerDTO[].class);</p>
			<p class="source-code">    return List.of(owners);</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">HttpClient.create()</strong> will <a id="_idIndexMarker299"/>create an HTTP client that we then use to make an HTTP GET request.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Performing an HTTP POST operation</h2>
			<p>To <a id="_idIndexMarker300"/>perform an HTTP POST operation, we can add the following method to <strong class="source-inline">OwnerResourceClient</strong>: </p>
			<p class="source-code">public OwnerDTO createOwnerClient() throws MalformedURLException {</p>
			<p class="source-code">    HttpClient client = HttpClient.create(new URL("https://" + server.getHost() + ":" + server.getPort()));</p>
			<p class="source-code">    OwnerDTO newOwner = new OwnerDTO();</p>
			<p class="source-code">    newOwner.setFirstName("Lisa");</p>
			<p class="source-code">    newOwner.setLastName("Ray");</p>
			<p class="source-code">    newOwner.setAddress("100 Queen St.");</p>
			<p class="source-code">    newOwner.setCity("Toronto");</p>
			<p class="source-code">    newOwner.setTelephone("1234567890");</p>
			<p class="source-code">    return client.toBlocking().retrieve(HttpRequest.POST("/api/owners", newOwner), OwnerDTO.class);</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">HttpClient.create()</strong> will create an HTTP client that we then use to make an HTTP POST request. An owner object will be passed as the request payload. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Performing an HTTP PUT operation</h2>
			<p>To perform an <a id="_idIndexMarker301"/>HTTP PUT operation, we can add the following method to <strong class="source-inline">OwnerResourceClient</strong>:</p>
			<p class="source-code">public OwnerDTO updateOwnerClient() throws MalformedURLException {</p>
			<p class="source-code">    HttpClient client = HttpClient.create(new URL("https://" + server.getHost() + ":" + server.getPort()));</p>
			<p class="source-code">    OwnerDTO owner = new OwnerDTO();</p>
			<p class="source-code">    owner.setId(1L);</p>
			<p class="source-code">    owner.setAddress("120 Queen St.");</p>
			<p class="source-code">    return client.toBlocking().retrieve(HttpRequest.PUT("/api/owners", owner), OwnerDTO.class);</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">HttpClient.create()</strong> will create an HTTP client that we then use to make an HTTP PUT request. An <strong class="source-inline">owner</strong> object will be passed as the request payload.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Performing an HTTP DELETE operation</h2>
			<p>To perform an <a id="_idIndexMarker302"/>HTTP DELETE operation, we can add the following method to <strong class="source-inline">OwnerResourceClient</strong>:</p>
			<p class="source-code">public Boolean deleteOwnerClient() throws MalformedURLException {</p>
			<p class="source-code">    HttpClient client = HttpClient.create(new URL("https://" + server.getHost() + ":" + server.getPort()));</p>
			<p class="source-code">    long ownerId = 1L;</p>
			<p class="source-code">    HttpResponse httpResponse = client.toBlocking().retrieve(HttpRequest.DELETE("/api/owners" + ownerId), HttpResponse.class);</p>
			<p class="source-code">    return httpResponse.getStatus().equals(HttpStatus.NO_CONTENT);</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">HttpClient.create()</strong> will create <a id="_idIndexMarker303"/>an HTTP client that we then use to make an HTTP DELETE request. A no content message will be returned if the request executes successfully. </p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Summary</h1>
			<p>In this chapter, we covered various aspects of working on web endpoints in a Micronaut application. We kick-started with the concept of assemblers or DTOs and then dived into how to create restful endpoints for supporting essential CRUD operations. Also, we experimented with some of the HTTP server APIs in the Micronaut framework. Lastly, we focused on the HTTP client aspects and created a client utility using <strong class="source-inline">micronaut-http-client</strong>. </p>
			<p>This chapter has given us the skills related to various practical aspects of working on restful microservices in the Micronaut framework. Furthermore, by exploring the HTTP client, we covered these aspects end to end. This hands-on knowledge to work on the web layer is pivotal in developing any microservice.</p>
			<p>In the next chapter, we will work on securing the web layer of the <strong class="source-inline">pet-clinic </strong>microservice by experimenting with different approaches and methods in safeguarding the restful endpoints. </p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Questions</h1>
			<ol>
				<li value="1">What is a DTO?</li>
				<li>How do you use MapStruct in the Micronaut framework?</li>
				<li>How do you create a restful HTTP GET endpoint in the Micronaut framework?</li>
				<li>How do you create a restful HTTP POST endpoint in the Micronaut framework?</li>
				<li>How do you create a restful HTTP PUT endpoint in the Micronaut framework?</li>
				<li>How do you create a restful HTTP DELETE endpoint in the Micronaut framework?</li>
				<li>How does Micronaut support HTTP request binding? </li>
				<li>How can we validate data in the Micronaut framework?</li>
				<li>How can we version the APIs in the Micronaut framework? </li>
				<li>How does Micronaut support HTTP client aspects? </li>
				<li>How can we create an HTTP client in the Micronaut framework? </li>
			</ol>
		</div>
	</body></html>