<html><head></head><body><div class="book" title="Chapter&#xA0;4.&#xA0;JSF Validation and AJAX" id="aid-190861"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch04" class="calibre1"/>Chapter 4. JSF Validation and AJAX</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote1" summary="Block quote"><tr class="calibre12"><td valign="top" class="calibre13"> </td><td valign="top" class="calibre13"><p class="calibre14"><span><em class="calibre15">"It always seems impossible until it is done."</em></span></p></td><td valign="top" class="calibre13"> </td></tr><tr class="calibre12"><td valign="top" class="calibre13"> </td><td colspan="2" valign="top" class="calibre16">--<span><span><em class="calibre15">Nelson Mandela</em></span></span></td></tr></table></div><p class="calibre7">So far, we have created a digital customer journey that accomplishes the common create, retrieve, update, and delete, that is, the famous CRUD requirement. The results are attractive to the stakeholder and to the product owner, but the user members of our team are not satisfied with the form, because it lacks the ability to verify the data entries made by members of the general public.</p><p class="calibre7">When we think about it, validation is important for the user as he or she is the one entering the data in a web application. It saves time and frustration for the user, because they know that the entry is wrong as they enter the data. It avoids the costs incurred for fixing of the wrongly submitted data by the database administrator. Validation improves the efficiency of a web application that works 24/7 over the Internet. As more of our daily lives get dependent on the digital adaptation of traditional services, e-commerce is now a necessity; it is essential that we give the general public the right information at the right time, that is, at the point-of-sale or point-of-capture.</p><div class="book" title="Validation methods"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch04lvl1sec36" class="calibre1"/>Validation methods</h1></div></div></div><p class="calibre7">In this chapter, taking<a id="id395" class="calibre1"/> the basic JSF form as a base, we will learn how to apply validation on the server side and on the client-server side. There are certain advantages to both the strategies; we will learn about the pros and cons of both the approaches.</p><div class="book" title="Server-side validation"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec35" class="calibre1"/>Server-side validation</h2></div></div></div><p class="calibre7">Form validation <a id="id396" class="calibre1"/>can be achieved on the server-side in <a id="id397" class="calibre1"/>a Java EE application running on the application server or the servlet container. The information is sent from the web browser to the web application as a normal HTTP form submission. In this mode, the form is submitted as a traditional HTML form element. The web framework, in this case Java EE, validates the input and sends back a response to the client. If the form fails the validation, the page that contains the web form is redisplayed and error messages are shown.</p><p class="calibre7">The server-side quick validation is secure in the sense that it will protect the database even if JavaScript is disabled or unavailable in a web browser. On the other hand, this type of validation <a id="id398" class="calibre1"/>requires a round trip from the client to the server side. The users will not get feedback about the form data until they submit<a id="id399" class="calibre1"/> the form.</p><p class="calibre7">There always seems to be an exception to a rule. If the server-side form validation is submitted using AJAX, then we can get around the slow response. AJAX validation is a nice compromise, because the form can be validated as and when the user enters the data on the form. On the other hand, AJAX requires JavaScript to be enabled in the web browser.</p></div><div class="book" title="Client-side validation"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec36" class="calibre1"/>Client-side validation</h2></div></div></div><p class="calibre7">The user-experience person in our team really prefers the client-side validation, but this type of <a id="id400" class="calibre1"/>validation requires the presence of JavaScript in the browser (or an equivalent type of dynamic scripting technology). Client-side validation affords a more responsive and richer user interaction with the form.</p><p class="calibre7">Client-side <a id="id401" class="calibre1"/>validation ensures that the form is always correct before the user is allowed to submit the form. With JavaScript being a progressive language, there are many ways to inform the user how to better interact with the form submission process. Technologies such as jQuery allow the programmers to add hinting and validation error messages in flight as the user types the data.</p><p class="calibre7">There are situations where JavaScript is disabled or unavailable in the web browser. I can readily think of government security or specialist centers where the sandbox is strictly controlled. When JavaScript is turned off by the user or by the administrator of the device, client-side validation will certainly fail, and the user is able to bypass the validation.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip20" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">Combine client-side and server-side validation</strong></span>
</p><p class="calibre7">In professional applications for businesses, I strongly recommend that you combine both the approaches to validation in order to get the best of both worlds. Client-side validation provides a faster and richer experience and server-side validation protects your data and database from bad data and hacking.</p></div><p class="calibre7">Before we go through the technical topic of validation, we must understand how messages are represented in JSF.</p></div></div></div>
<div class="book" title="Faces messages"><div class="book" id="aid-19UOO2"><div class="book"><div class="book"><h1 class="title"><a id="ch04lvl1sec37" class="calibre1"/>Faces messages</h1></div></div></div><p class="calibre7">The JSF provides two custom tags to display error messages. The <code class="email">&lt;h:message&gt;</code> tag displays messages that are bound to specific components. The <code class="email">&lt;h:messages&gt;</code> tag displays messages that are not bound to specific components.</p><p class="calibre7">We saw our first use of <code class="email">&lt;h:message&gt;</code> in <a class="calibre1" title="Chapter 3. Building JSF Forms" href="part0035.xhtml#aid-11C3M2">Chapter 3</a>, <span class="strong"><em class="calibre9">Building JSF Forms</em></span>. The tag is typically associated with a form control. We can add messages to our JSF pages with the following:</p><div class="informalexample"><pre class="programlisting">&lt;h:messages globalOnly="false" styleClass="alert alert-danger" /&gt;</pre></div><p class="calibre7">The tag is<a id="id402" class="calibre1"/> added to the top of the content. The attribute <code class="email">globalStyle</code> is a Boolean value, and it specifies whether the tag should display messages that are not associated with a component. Here, we are using the Bootstrap CSS selectors again.</p><p class="calibre7">The following is a table of the <a id="id403" class="calibre1"/>attributes that are shared between the JSF tags, <code class="email">&lt;h:messages&gt;</code> and <code class="email">&lt;h:message&gt;</code>:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Attribute</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">Id</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies the unique identifier</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">errorClass</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies the CSS class selectors for error messages</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">errorStyle</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies the style for error messages</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">infoClass</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies the CSS class selector for information messages</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">infoStyle</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies the CSS styles for information messages</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">for</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies the component that a message is associated with</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">rendered</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Sets a Boolean value to specify whether the tag is rendered to the page or not</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">style</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Defines the CSS selectors for all the message types</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">styleClass</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Defines the CSS style for all the message types</p>
</td></tr></tbody></table></div><p class="calibre7">Behind the scenes, these tags render the content from the <code class="email">javax.faces.HtmlMessages</code> and <code class="email">javax.faces.HtmlMessages</code> components respectively, which in turn, rely on the list collection of the <code class="email">javax.faces.application.FacesMessage</code> elements. As a JSF digital developer, we do not have to worry too much about the <code class="email">HtmlMessage</code> and <code class="email">HtmlMessages</code> components from day-to-day, as they lie under the car bonnet. If we were in the business of writing a new JSF renderer or an extension, then we would have to look at the Javadoc and JSF specifications.</p><p class="calibre7">In <a class="calibre1" title="Chapter 3. Building JSF Forms" href="part0035.xhtml#aid-11C3M2">Chapter 3</a>, <span class="strong"><em class="calibre9">Building JSF Forms</em></span>, you were introduced to the application, <code class="email">FacesMessage</code>, for creating the JSF CRUD style forms.<a id="id404" class="calibre1"/> In the Controller, we can create a validation error message that is not associated to any <code class="email">UIComponent</code> in the form. Therefore this validation error is accessible only through global error messages. Here is code that generates such a validation error:</p><div class="informalexample"><pre class="programlisting">  public void findContactById() {
    if (id &lt;= 0) {
      String message = "Bad request. Please use a link from within the system.";
      FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, message, null));
      return;
    }
    /* ... */
  }</pre></div><p class="calibre7">The <code class="email">FacesMessage</code> object represents a validation message with a severity level. We add it to the <code class="email">FacesContext</code> object. The <code class="email">FacesMessage</code> constructor is of the form:</p><div class="informalexample"><pre class="programlisting">public FacesMessage(Severity severity, String summary, String detail)</pre></div><p class="calibre7">The severity can be of four static constants defined in the <code class="email">FaceMessages</code> class, which are <code class="email">SEVERITY_INFO</code>, <code class="email">SERVERITY_WARNING</code>, <code class="email">SEVERITY_ERROR</code>, and <code class="email">SEVERITY_FATAL</code>. These values are actually instantiations of a private inner class <code class="email">Severity</code> that, unfortunately, is not accessible outside the enclosing class, so we can invent our own severities.</p><p class="calibre7">A Faces message also requires a summary of the message and, optionally, details about the invalidation message.</p><p class="calibre7">
<code class="email">javax.faces.context.FacesContext</code> is an aggregate holder for the current incoming request and the potential response. The object instance is instantiated on the initial JSF incoming request (Faces Request), and it will stay alive until the subsequent JSF <code class="email">release()</code> method is triggered, which is usually deep inside the framework. <code class="email">FacesContext</code> is the place from where a <code class="email">FacesMessage</code> is added and from where the list collection of messages can be retrieved.</p><p class="calibre7">
<code class="email">FacesContext</code> has several interesting methods including <code class="email">isValidationFailed()</code>, which is useful to detect any validation failure earlier in the JSF lifecycle. We shall see an example of this call later with Bean Validation. There are other methods as well like using <code class="email">getViewRoot()</code> to get the view root, <code class="email">getCurrentPhaseId()</code> to get the current phase in the JSF lifecycle, and <code class="email">getRenderKit()</code> to retrieve the render kit form. With the <code class="email">isPostback()</code> method, we can find out if the request was an HTML form and if the JSF framework is about to send the data back to the same form. There is much more to the context objects.</p><p class="calibre7">The method to add a faces message to the context looks as follows:</p><div class="informalexample"><pre class="programlisting">public abstract void addMessage(String clientId, FacesMessage message);</pre></div><p class="calibre7">If the <code class="email">clientId</code> attribute is null, the message is a globally available message and is not associated with<a id="id405" class="calibre1"/> any view component.</p><p class="calibre7">Now that we've understood how to generate JSF- specific messages, let's delve into the validation of a JSF application.</p></div>
<div class="book" title="Validation"><div class="book" id="aid-1AT9A2"><div class="book"><div class="book"><h1 class="title"><a id="ch04lvl1sec38" class="calibre1"/>Validation</h1></div></div></div><p class="calibre7">There are a two main ways of achieving validation on the server side. One route to follow is through the<a id="id406" class="calibre1"/> use of Bean Validation version 1.1 from the Java EE 7 specification, and the other traditional route takes you through JSF validation.</p><div class="book" title="Constraining form content with Bean Validation"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec37" class="calibre1"/>Constraining form content with Bean Validation</h2></div></div></div><p class="calibre7">Bean Validation is <a id="id407" class="calibre1"/>a specification that allows the developers to<a id="id408" class="calibre1"/> annotate the POJOs and<a id="id409" class="calibre1"/> entity beans and then call a custom validator instance to verify the properties. The validation framework works with Java annotation and thus, the digital engineer can firmly say how a property or even a method is validated.</p><p class="calibre7">I devoted an entire chapter to Bean Validation in the <span class="strong"><em class="calibre9">Java EE 7 Developer Handbook</em></span>; nevertheless, I will run through the basics with you here, in this Digital Web Application book. There are several annotations in the Bean Validation 1.1 standard that you can use straightaway. However, if your platform allows or if you decide to add Hibernate Validator, then many more useful validation annotations are available. The developer can also create custom validations.</p><p class="calibre7">Let's use the <code class="email">ContactDetail</code> entity again, but this time we have added Bean Validation annotations to the properties, as follows:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.persistence.*;
import javax.validation.constraints.*;
import java.util.Date;

@Entity @Table(name="CONTACT")
/* ... */
public class ContactDetail {
  @Id /* ... */ private long id;

  @NotNull(message = "{contactDetail.title.notNull}")
  private String title;

  @Size(min = 1, max = 64,
        message = "{contactDetail.firstName.size}")
  private String firstName;

  private String middleName;

  @Size(min = 1, max = 64,
        message = "{contactDetail.lastName.size}")
  private String lastName;

  @Pattern(regexp =
      "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@"
      + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$",
      message = "{contactDetail.email.pattern}")
  private String email;

  @NotNull( message = "{contactDetail.dob.notNull}")
  @Temporal(TemporalType.DATE)
  @Past( message="{contactDetail.dob.past}" )
  private Date dob;

  /* ... as before ... */
}</pre></div><p class="calibre7">We added the<a id="id410" class="calibre1"/> annotations <code class="email">@Pattern</code>, <code class="email">@Past</code>, <code class="email">@NotNull</code>, and <code class="email">@Size</code> to the properties of the <code class="email">ContactDetail</code> entity. The annotations can be<a id="id411" class="calibre1"/> found in the Java package <code class="email">javax.validation.constraints</code>, reserved for Bean Validation.</p><p class="calibre7">The <a id="id412" class="calibre1"/>following is a table of the important Bean Validation annotations:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Constraint Name</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Allowed Types</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@Null</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies<a id="id413" class="indexterm"/> that the element must be a null reference pointer.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Any</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@NotNull</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies<a id="id414" class="indexterm"/> that the element must not be a null reference pointer.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Any</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@Min</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies<a id="id415" class="indexterm"/> that the element must be a number value that is greater than or equal to the minimum value supplied. Because of floating arithmetic rounding errors, float and double are not supported.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">BigDecimal, BigInteger, byte, short, int, and long</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@Max</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies<a id="id416" class="indexterm"/> that the element must be a number value that is less than or equal to the minimum value supplied. Because of floating arithmetic rounding errors, float and double are not supported.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">BigDecimal, BigInteger, byte, short, int, and long</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@DecimalMin</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Similar to <code class="literal">@Min</code> but adds the ability to set the value as<a id="id417" class="indexterm"/> a String parameter. The number value must be greater than or equal to the supplied value. FP restriction also applies here.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">BigDecimal, BigInteger,</code>
</p>
<p class="calibre14">
<code class="literal">CharSequence, byte, short, int, and long</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@DecimalMax</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Similar to <code class="literal">@Max</code> but adds the ability to set the value as<a id="id418" class="indexterm"/> a String parameter. The number value must be less than or equal to the supplied value. FP restriction also applies here.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">BigDecimal, BigInteger,</code>
</p>
<p class="calibre14">
<code class="literal">CharSequence, byte, short, int, and long</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@Size</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The<a id="id419" class="indexterm"/> element's size must be inside the supplied inclusive boundary limits.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">CharSequence, Collection, Map and primitive array</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@Past</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The<a id="id420" class="indexterm"/> element must be a date in the past according to the current time of the Java Virtual Machine.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">java.util.Date and java.util.Calendar</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@Future</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The<a id="id421" class="indexterm"/> element must be a date in the future according to the current time of the Java Virtual Machine.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">java.util.Date and java.util.Calendar</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@Pattern</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The <a id="id422" class="indexterm"/>element must match against a supplied regular expression pattern that conforms to the Java convention.</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">CharSequence</code>
</p>
</td></tr></tbody></table></div><p class="calibre7">Bean Validation<a id="id423" class="calibre1"/> annotations typically accept a message<a id="id424" class="calibre1"/> attribute, which is the validation <a id="id425" class="calibre1"/>message for the user, or it can be a value in brackets, which is a trigger for the validation framework to search for a message from <code class="email">java.util.ResourceBundle</code>. Certain annotations like <code class="email">@Min</code>, <code class="email">@Max</code>, <code class="email">@DecimalMin</code>, and <code class="email">@DecimalMax</code> have additional attributes like <code class="email">min</code> and <code class="email">max</code> to specify the obvious boundaries.</p><p class="calibre7">We can define an <code class="email">@NotNull</code> constraint on the property with the validation message, as follows:</p><div class="informalexample"><pre class="programlisting">@NotNull( message = "The office reference must not be null")
private String officeReference;</pre></div><p class="calibre7">It is a good approach, possibly for prototyping a website; but as we know from our knowledge of software archaeology. This could be a maintenance nightmare, because we are writing a digital copy directly into Java code. It is far better to write a text copy inside a property file that can be picked up by the standard <code class="email">ResourceBundle</code>, which Bean Validation uses. Jenny, our resident digital strategist and copywriting expert, will thank us for sending her a property file instead of Java source code.</p><p class="calibre7">So let's rewrite this constraint on the property as follows:</p><div class="informalexample"><pre class="programlisting">@NotNull( message = "{mydataform.officeReference.notNull}")
private String officeReference;</pre></div><p class="calibre7">Bean Validation can be integrated with JSF by placing the messages at a specific location. The programmer need only create a <code class="email">ValidationMessages.properties</code> file in the folder <code class="email">WEB-INF/classes</code>.</p><p class="calibre7">The following is<a id="id426" class="calibre1"/> an extract of the message properties file for <a id="id427" class="calibre1"/>the <code class="email">ContactDetail</code> entity:</p><div class="informalexample"><pre class="programlisting">contactDetail.title.notNull = Title cannot be blank or empty
contactDetail.firstName.size = First name must be between {min} and {max} characters
contactDetail.middleName.size = Middle name must be between {min} and {max} characters
contactDetail.lastName.size = Last name must be between {min} and {max} characters
contactDetail.email.pattern = You must supply a valid email address
contactDetail.dob.past=Your Date of Birth must be in the past</pre></div><p class="calibre7">With Bean Validation, we can add placeholders that are denoted with curly brackets to enrich the <a id="id428" class="calibre1"/>messages that the user will see. The placeholders are specific like <code class="email">{min}</code> and <code class="email">{max}</code>. The other advantage of property files is that the <code class="email">ResourceBundle</code> in the JDK already handles the tricky topic of internationalization for different locales.</p><p class="calibre7">There are big disadvantages to just relying on Bean Validation using JSF. It is great for protecting a database from poorly entered data, and with the Java EE 7 application server that the digital developer gets almost for free, validation is added or amended to the database before each record. However, the Bean Validation has no connection to the JSF frontend. The framework does not have any association with the page author's content. Nor would we want this dependency between the presentation and the model layer in modern day software engineering. One of the best practices in object-oriented programming is the SOLID principle. We certainly want the layers to be singularly responsible for a purpose; open to extension, but closed to modification and, most importantly, to prevent the leaky abstractions that cause a technical debt in the software as it ages.</p><p class="calibre7">Another disadvantage about just relying on Bean Validation is that the verification of the data depends solely on the skills of the Java digital engineer. It means that the page author or designer cannot innovate, edit, or remove validation on the road to a better user-centric experience.</p><p class="calibre7">Bean Validation is great for adding validation in the application logic. You can ensure that the contact detail's title is never blank, if this is a business requirement. Complex and group validations for properties can be achieved. Refer to my book, <span class="strong"><em class="calibre9">Java EE 7 Developer Handbook</em></span>, for further details.</p><p class="calibre7">The following <a id="id429" class="calibre1"/>screenshot shows <code class="email">bean-validation</code>/<code class="email">createContactDetail.xhtml</code> in action from the book source code. The screenshot <a id="id430" class="calibre1"/>shows what happens when the<a id="id431" class="calibre1"/> user just submits the form without filling it in:</p><div class="mediaobject"><img src="../Images/image00385.jpeg" alt="Constraining form content with Bean Validation" class="calibre10"/><div class="caption"><p class="calibre24">Screenshot of Bean Validation on the contact details application</p></div></div><p class="calibre11"> </p><p class="calibre7">The <code class="email">&lt;h:messages&gt;</code> tag <a id="id432" class="calibre1"/>with <a id="id433" class="calibre1"/>the <a id="id434" class="calibre1"/>setting <code class="email">globalStyle=true</code> shows the output of the validation messages that the framework discovers in the <code class="email">ContactDetail</code> entity.</p></div><div class="book" title="Validating user input with JSF"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec38" class="calibre1"/>Validating user input with JSF</h2></div></div></div><p class="calibre7">JSF has always<a id="id435" class="calibre1"/> had a validation framework <a id="id436" class="calibre1"/>since its inception in 2004. It was a feature that separated JSF from the de facto Apache Struts web framework, at the time, as the latter had no <a id="id437" class="calibre1"/>built-in support for validation.</p><p class="calibre7">It is helpful to remember that conversion and validation occur at different phases of the JavaServer Faces lifecycle (review the diagram from <a class="calibre1" title="Chapter 2. JavaServer Faces Lifecycle" href="part0025.xhtml#aid-NQU22">Chapter 2</a>, <span class="strong"><em class="calibre9">JavaServer Faces Lifecycle</em></span>, <span class="strong"><em class="calibre9">The execute and render lifecycle</em></span> section). As a reminder, JSF will set the values in a component during the Apply-Request values phase and then use various conversions, if required, to transform the input String values to the target object. Validation occurs during the Process-Validations phase and this lifecycle follows by design. In order to transform the input data from the HTML request, JSF attempts and checks whether the parameters can be set in the backing bean. The Update-Model-Values phase follows the earlier phases. If a validation or a conversion error occurs in the lifecycle, then it is effectively shortened. JSF moves directly to the Render-Response phase and it converts the properties in the backing bean to Strings so that the web client can display them.</p><p class="calibre7">JSF provides a small set of prebuilt validator tags, which you can apply to mark up as a page author, A table of the Core JSF Custom Tags has been given in <a class="calibre1" title="Chapter 3. Building JSF Forms" href="part0035.xhtml#aid-11C3M2">Chapter 3</a>, <span class="strong"><em class="calibre9">Building JSF Forms</em></span>. Some of them are as follows: <code class="email">&lt;f:validateDoubleRange&gt;</code>, <code class="email">&lt;f:validateLength&gt;</code>, <code class="email">&lt;f:validateLongRange&gt;</code>,<code class="email"> &lt;f:validateRegex&gt;</code>, and <code class="email">&lt;f:validateRequired&gt;</code>.</p><p class="calibre7">We can apply these tags to the contact detail CRUD example. So let's start with the <code class="email">createContact.xhtml</code> page. The following is a short extract from the page:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="createContactDetail"
  styleClass="form-horizontal" p:role="form"&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="title" class="col-sm-3 control-label"&gt;
      Title&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:selectOneMenu class="form-control"
         label="Title" id="title"
         value="#{contactDetailControllerBV.contactDetail.title}"&gt;
        &lt;f:selectItem itemLabel="-" itemValue="" /&gt;
        &lt;f:selectItem itemValue="Mr" /&gt;
        &lt;f:selectItem itemValue="Mrs" /&gt;
        &lt;f:selectItem itemValue="Miss" /&gt;
        &lt;f:selectItem itemValue="Ms" /&gt;
        &lt;f:selectItem itemValue="Dr" /&gt;
        &lt;f:validateRequired/&gt;
      &lt;/h:selectOneMenu&gt;
      &lt;h:message for="title" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="firstName" class="col-sm-3 control-label"&gt;
      First name&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText class="form-control" label="First name"
       value="#{contactDetailControllerBV.contactDetail.firstName}"
       id="firstName" placeholder="First name"&gt;
          &lt;f:validateRequired/&gt;
          &lt;f:validateLength maximum="64" /&gt;
      &lt;/h:inputText&gt;
      &lt;h:message for="firstName" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;!-- . . . --&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="email" class="col-sm-3 control-label"&gt;Email address
    &lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText type="email"
       label="Email" class="form-control" id="email"
       value="#{contactDetailControllerBV.contactDetail.email}"
       placeholder="Enter email"&gt;
          &lt;f:validateRequired/&gt;
          &lt;f:validateLength maximum="64" /&gt;
      &lt;/h:inputText&gt;
      &lt;h:message for="email" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;!-- . . . --&gt;

  &lt;label class="control-label"&gt; Your Date of Birth&lt;/label&gt;
  &lt;!-- . . . --&gt;
  &lt;div class="row  my-group-border"&gt;
    &lt;div class="col-sm-12"&gt;
      &lt;h:message for="dobDay" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-12"&gt;
      &lt;h:message for="dobMonth" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-12"&gt;
      &lt;h:message for="dobYear" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/h:form&gt;</pre></div><p class="calibre7">We placed<a id="id438" class="calibre1"/> the <code class="email">&lt;f:validateRequired&gt;</code>, <code class="email">&lt;f:validateLength&gt;</code>, and <code class="email">&lt;f:validateLongRange&gt;</code> tags inside the body <a id="id439" class="calibre1"/>content of the JSF HTML rendering tags like <code class="email">&lt;h:inputText&gt;</code> and <code class="email">&lt;h:selectOneMenu&gt;</code>. The <code class="email">validateLength</code> tag verifies the<a id="id440" class="calibre1"/> length of String property. The tag accepts a maximum parameter, but it can also take a minimum attribute.</p><p class="calibre7">We also added a <code class="email">&lt;h:message&gt;</code> tag close to its respective HTML input field. The <code class="email">styleClass</code> attribute specifies a custom CSS selector that forces the validation message on a separate new line. The CSS for this looks like as follows:</p><div class="informalexample"><pre class="programlisting">.validation-error {
    display: block;
    margin: 5px 15px 5px 15px;
    padding: 8px 15px 8px 15px;
    color: #a94442;
    background-color: #f2dede;
    border-color: #ebccd1;
}</pre></div><p class="calibre7">In order to avoid JSF sugared names like <code class="email">&lt;jsf_form&gt;:&lt;form_property_name&gt;</code> to the validation error message, which would give a result like <code class="email">contactDetail:title -Validation Error: Value is required</code>, we specify the label attribute for each HTML render tag. The title input field has an attribute setting <code class="email">label="Title"</code>.</p><p class="calibre7">The <code class="email">&lt;f:validateLongRange&gt;</code> tag checks if the actual content of the String is a numerical value between the minimum and maximum attributes. We use this tag in the <code class="email">date-of-birth</code> fields.</p><p class="calibre7">The following extract is the authoring for the day field in the DOB group:</p><div class="informalexample"><pre class="programlisting">  &lt;h:selectOneMenu id="dobDay"
    value="#{contactDetailControllerBV.dobDay}"
      label="Registration Day"&gt;
      &lt;f:selectItem itemLabel="----"  itemValue=""/&gt;
      &lt;f:selectItems
        value="#{contactDetailControllerBV.daysOfTheMonth}"
        var="day"
       itemLabel="#{day}" itemValue="#{day}" /&gt;
      &lt;f:validateRequired/&gt;
      &lt;f:validateLongRange minimum="1" maximum="31" /&gt;
  &lt;/h:selectOneMenu&gt;</pre></div><p class="calibre7">The preceding<a id="id441" class="calibre1"/> code demonstrates how the <code class="email">&lt;f:validateLongRange&gt;</code> tag enforces the day-of-the month field in the form. We rinse and repeat <a id="id442" class="calibre1"/>for the other DOB fields.</p><p class="calibre7">The <code class="email">&lt;f:validateRegex&gt;</code> tag matches the input property string against a regular expression. We use<a id="id443" class="calibre1"/> this tag for the <code class="email">email</code> property. The following is the code for this validation check:</p><div class="informalexample"><pre class="programlisting">  &lt;div class="col-sm-9"&gt;
    &lt;h:inputText type="email"
     label="Email" class="form-control" id="email"
     value="#{contactDetailControllerBV.contactDetail.email}"
     placeholder="Enter email"&gt;
      &lt;f:validateRequired/&gt;
      &lt;f:validateLength maximum="64" /&gt;
      &lt;f:validateRegex pattern="^[_A-Za-z0-9-\+]+(\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\.[A-Za-z0-9]+)*(\.[A-Za-z]{2,})$" /&gt;
    &lt;/h:inputText&gt;
    &lt;h:message for="email" styleClass="alert validation-error"/&gt;
  &lt;/div&gt;</pre></div><p class="calibre7">It is interesting to note that the overbearing pattern attribute value, the regular expression, is almost exactly the same as in the Bean Validation <code class="email">@Pattern</code>. We had to convert the double backslash characters to single backslash, because we do not need to escape the literal in a normal regular expression, not set in Java code.</p><p class="calibre7">The following is a screenshot of the page <code class="email">jsf-validation</code>/<code class="email">createContactDetail.xhtml</code>:</p><div class="mediaobject"><img src="../Images/image00386.jpeg" alt="Validating user input with JSF" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot demonstrating JSF built-in validation rules</p></div></div><p class="calibre11"> </p><div class="book" title="Customizing JSF validation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec17" class="calibre1"/>Customizing JSF validation</h3></div></div></div><p class="calibre7">If you have <a id="id444" class="calibre1"/>played around with the source code and ran the example, I bet you would have noticed some glaring issues with the JSF validation. For instance, when the <code class="email">email</code> field has a value that is not a valid e-mail address, you will see a validation message like this:</p><div class="informalexample"><pre class="programlisting">Regex pattern of '^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$' not matched</pre></div><p class="calibre7">Clearly, this very detailed application message fails the user-centric design and clean language for the public. What can we do with JSF to avoid these messages?</p><p class="calibre7">There are three attributes that can be applied to the HTML rendering tags for input fields like <code class="email">&lt;h:inputText&gt;</code> and <code class="email">&lt;h:selectOneMenu&gt;</code>. The following table shows the attributes that can help customize the JSF validation messages:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Attribute</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">requiredMessage</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Defines a<a id="id445" class="indexterm"/> value-based expression that will be used as a message text if the field is required.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">validatorMessage</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Defines a <a id="id446" class="indexterm"/>value-based expression that will be used as a validation text if the field and property fails validation.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">conversionMessage</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Defines a <a id="id447" class="indexterm"/>value-based expression that will be used as a message if the field can be converted to the target type.</p>
</td></tr></tbody></table></div><p class="calibre7">With this information, we can easily solve our issue with the messages by applying the <code class="email">requiredMessage</code> attribute to our field:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText type="email"
   label="Email" class="form-control" id="email"
   value="#{contactDetailControllerBV.contactDetail.email}"
   validatorMessage="Value must be in the format of an email address"
   converterMessage="Value should be in the format in an email address"
   placeholder="Enter email"&gt;
  &lt;f:validateRequired/&gt;
  &lt;f:validateLength maximum="64" /&gt;
  &lt;f:validateRegex pattern=". . ." /&gt;
&lt;/h:inputText&gt;</pre></div><p class="calibre7">The <code class="email">requiredMessage</code>, <code class="email">validatorMessage</code>, and <code class="email">conversionMessage</code> override any message that is set by the JSF validator on the server side. Note that these attributes can accept value expressions. This is great for page authors to dictate the method. On the other side of the fence though, our e-mail address field has two validation constraints, a regular expression check and a length-of-field constraint. The message is not appropriate for <code class="email">validateLength</code>. So we have a problem there if we use more than one type of validator following this approach.</p><p class="calibre7">There is another approach that we could take. How about overriding the validation messages<a id="id448" class="calibre1"/> globally in the JSF framework? We can configure our own version of the JSF validator messages. In order to achieve this goal, first, we configure the framework with the information regarding the location for loading these messages. We set up a message bundle in the <code class="email">WEB-INF/faces-config.xml</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;faces-config 
    
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
    http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"
    version="2.2"&gt;
  &lt;application&gt;
      &lt;message-bundle&gt;
          uk.co.xenonique.digital.JSFVMessages
      &lt;/message-bundle&gt;
  &lt;/application&gt;
&lt;/faces-config&gt;</pre></div><p class="calibre7">This configuration file defines the Faces resources for the application, and here we can configure a message bundle that references a property file. The path to the property file is actually <code class="email">uk/co/xenonique/digital/JSFVMessages.properties</code>, which you find in the project resources <code class="email">ch04/jsf-crud-validation/src/main/resources</code>.</p><p class="calibre7">Secondly, we supply our own message-bundle file. The contents of this property file <code class="email">JSFVMessages.properties</code> are simply the following property definitions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">javax.faces.validator.RegexValidator.NOT_MATCHED = Input value does not conform to according expected format.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.RegexValidator.PATTERN_NOT_SET = A pattern must be set for validate.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.RegexValidator.MATCH_EXCEPTION = The pattern is not a valid regular expression.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LengthValidator.MAXIMUM = {1}: This field can accept up to ''{0}'' characters long.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LengthValidator.MINIMUM = {1}: This field must have at least ''{0}'' characters long.</strong></span>

<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.MAXIMUM = {1}: This value must be less than or equal to ''{0}''</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.MINIMUM = {1}: This value must be greater than or equal to ''{0}''</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.NOT_IN_RANGE = {2}: This value must be between of {0} and {1} inclusive.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.TYPE = {0}: Unable to convert this value to a decimal number.</strong></span>

<span class="strong"><strong class="calibre8">javax.faces.component.UIInput.REQUIRED = {0}: This value is required</strong></span>
</pre></div><p class="calibre7">As you can see, we have overridden the property <code class="email">RegexValidator.NOT_MATCHED</code> to provide a new <a id="id449" class="calibre1"/>message. The original definitions are found in the JAR file in the application server or bundle as a third party JAR in your servlet container. The definitions can be found in the package of the JAR (<code class="email">jsf-api-2.2.jar</code>) <code class="email">javax/faces/Messages.properties</code>.</p><p class="calibre7">The original definitions for the regular expression validator look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">javax.faces.validator.RegexValidator.NOT_MATCHED = {1}: Validation Error: Value not according to pattern ''{0}''</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.RegexValidator.PATTERN_NOT_SET = A pattern must be set for validate.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.RegexValidator.MATCH_EXCEPTION = The pattern is not a valid regular expression.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LengthValidator.MAXIMUM = {1}: Validation Error: Length is greater than allowable maximum of ''{0}''</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LengthValidator.MINIMUM = {1}: Validation Error: Length is less than allowable minimum of ''{0}''</strong></span>

<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.MAXIMUM = {1}: Validation Error: Value is greater than allowable maximum of ''{0}''</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.MINIMUM = {1}: Validation Error: Value is less than allowable minimum of ''{0}''</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.NOT_IN_RANGE = {2}: Validation Error: Specified attribute is not between the expected values of {0} and {1}.</strong></span>
<span class="strong"><strong class="calibre8">javax.faces.validator.LongRangeValidator.TYPE = {0}: Validation Error: Value is not of the correct type.</strong></span>
</pre></div><p class="calibre7">You can examine this file in the source code at <a class="calibre1" href="http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties">http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties</a>. As you can see, they are quite technical and user-unfriendly. Many property definitions in the message bundle do accept placeholders for the parameters. The <code class="email">NOT_MATCHED</code> accepts two parameters: the first parameter <code class="email">{0}</code> is the pattern and the second parameter <code class="email">{1}</code> is the label of the input field.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre7">In Java EE 7, the placeholders for parameterization in JSF validation are different from those in the Bean Validation framework. JSF uses integer indices, whereas Bean Validation can use named placeholders.</p></div><p class="calibre7">At the time of writing, there is a bug in the reference implementation of the JSF validator, which prevents the developers from using some of the placeholders in a message property. We would have enjoyed a property definition like this:</p><div class="informalexample"><pre class="programlisting">javax.faces.validator.RegexValidator.NOT_MATCHED = Input value {1} does not conform to according expected format.</pre></div><p class="calibre7">Sadly, the <a id="id450" class="calibre1"/>current bug in Mojarra prevents us from writing this out as production code.</p><p class="calibre7">There is an alternative strategy to customizing the JSF validation. We can define our own validators in order to extend the functionality of the framework.</p></div><div class="book" title="Custom validation methods"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec18" class="calibre1"/>Custom validation methods</h3></div></div></div><p class="calibre7">JSF allows the digital engineer to configure a method in a managed bean controller that will be called to validate a field. Adding the attribute validator to the HTML render tags accomplishes <a id="id451" class="calibre1"/>this strategy, and it is a value expression.</p><p class="calibre7">The following is a way to add a custom validation method to the <code class="email">emailAddress</code> property of the contact detail form:</p><div class="informalexample"><pre class="programlisting">  &lt;h:inputText type="email"
   label="Email" class="form-control" id="email"
   value="#{contactDetailControllerBV.contactDetail.email}"
   validator="#{contactDetailControllerJV.validateEmailAddress}"
   placeholder="Enter email"&gt;
      &lt;f:validateRequired/&gt;
  &lt;/h:inputText&gt;</pre></div><p class="calibre7">The attribute validator references the method <code class="email">validateEmailAddress()</code> in the modified <code class="email">ContactDetailControllerJV</code> bean. This method looks like the following:</p><div class="informalexample"><pre class="programlisting">public void validateEmailAddress(
    FacesContext context, UIComponent component, Object value) {
    String text = value.toString();
    if ( text.length() &gt; 64 ) {
      throw new ValidatorException(
        new FacesMessage(
          FacesMessage.SEVERITY_ERROR,
          "The value must be less than 64 chars long.", null));
    }
    final String REGEX =
        "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@"
        + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$";
    Pattern pattern = Pattern.compile(REGEX);
    Matcher matcher = pattern.matcher(text);
    if ( !matcher.matches() ) {
      throw new ValidatorException(
        new FacesMessage(
          FacesMessage.SEVERITY_ERROR,
          "The value must be a valid email address.", null));
    }
}</pre></div><p class="calibre7">In the preceding method <code class="email">validateEmailAddress()</code>, the incoming parameters are the <code class="email">FacesContext</code>, the component being validated is of type UIComponent, and the pending value to be checked is of type Object. This method is validating two constraints: it checks that the<a id="id452" class="calibre1"/> length of the field is not too long and that the field is an e-mail address. We use the JDK standard library <code class="email">javax.regex</code> package to fulfill this. To assert the validation errors, if any, we create the <code class="email">FacesMessage</code> objects and add them to the current <code class="email">FacesContext</code> instance.</p></div><div class="book" title="Defining custom validators"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec19" class="calibre1"/>Defining custom validators</h3></div></div></div><p class="calibre7">Writing validators in controllers or a CDI named bean is a helpful strategy. However, the disadvantage is <a id="id453" class="calibre1"/>that you always need an indirect POJO in your application. There is another strategy where JSF allows us to define custom validators, which are integrated within the framework. A developer may choose to write a POJO that is declared with the annotation <code class="email">javax.faces.validator.FacesValidator</code>. The POJO must implement the interface <code class="email">javax.faces.validator.Validator</code>.</p><p class="calibre7">Let's move our e-mail address checking code into a custom validator. The code for <code class="email">FacesEmailAddressValidator</code> is as follows:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.validator.*;
import java.util.regex.*;

@FacesValidator("emailValidator")
public class FacesEmailAddressValidator implements Validator {
  public static final String EMAIL_REGEX =
    "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@"
  + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$";

  @Override
  public void validate(FacesContext context,
    UIComponent component, Object value)
    throws ValidatorException
  {
    String text = value.toString();
    Pattern pattern = Pattern.compile(EMAIL_REGEX);
    Matcher matcher = pattern.matcher(text);
    if ( !matcher.matches() ) {
      throw new ValidatorException(
        new FacesMessage(
          FacesMessage.SEVERITY_ERROR,        
          "The value must be a valid email address.", null));
    }
  }
}</pre></div><p class="calibre7">This class is <a id="id454" class="calibre1"/>annotated with <code class="email">@FacesValidator</code>, and the single argument identifies the name of the validator in the page view. The method <code class="email">validate()</code> implements the design by constraint in the validator interface. JSF passes in the <code class="email">FacesContext</code>, the associated component with the input value, and the value itself. </p><p class="calibre7">We retrieve the input value as a text string. The regular expression code that validates the e-mail address is almost the same as before except for the message key. The error key is <code class="email">{application.emailAddress.pattern}</code>.</p><p class="calibre7">With our POJO custom validator in place, we can rewrite the HTML on the page view to use it. The following is the extract view from <code class="email">login.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="form-group"&gt;
  &lt;h:outputLabel for="email" class="col-sm-3 control-label"&gt;
    Email&lt;/h:outputLabel&gt;
  &lt;div class="col-sm-6"&gt;
    &lt;h:inputText class="form-control" label="Email"
       value="#{loginControllerJV.email}"
       id="email" placeholder="Password"
       validator="emailValidator"&gt;
        &lt;f:validateRequired/&gt;
    &lt;/h:inputText&gt;
    &lt;h:message for="email" styleClass="alert validation-error"/&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre7">The only difference is the validator attribute in the <code class="email">&lt;h:inputText&gt;</code> element. This attribute specifies the custom validator by name as <code class="email">emailValidator</code>. As we can see, we can combine the custom validator with the default standard validators. There is still a <code class="email">&lt;f:validateRequired&gt;</code> element.</p><p class="calibre7">The following screenshot shows the rendered output of <code class="email">LoginControllerJV</code>:</p><div class="mediaobject"><img src="../Images/image00387.jpeg" alt="Defining custom validators" class="calibre10"/><div class="caption"><p class="calibre24">A front-end page view demonstration two-factor security login and validation</p></div></div><p class="calibre11"> </p></div><div class="book" title="Validating groups of properties"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec20" class="calibre1"/>Validating groups of properties</h3></div></div></div><p class="calibre7">Now that we have<a id="id455" class="calibre1"/> knowledge of the JSF custom validators, we can write a custom validator to verify the group Date-of-Birth input fields. We can achieve this goal, because the <code class="email">FacesContext</code> has been passed. It is possible to look up the UI components individually, separate from the context.</p><p class="calibre7">We shall use the JSF technique called binding inside a page view. Binding effectively publishes the instance of <code class="email">javax.faces.component.UIInput</code> in JSF value and makes it available elsewhere in a page. The attribute binding on the HTML rendering JSF tags binds a component's reference in the component tree to a scoped variable. The following is the relevant JSF code. In particular, pay close attention to the JSF hidden input element at the start of the <a id="id456" class="calibre1"/>code extract from <code class="email">jsf-validation/createContact.xhtml</code>.</p><div class="informalexample"><pre class="programlisting">&lt;label class="control-label"&gt; Your Date of Birth&lt;/label&gt;
&lt;h:inputHidden id="aggregateDobHidden"
               label="hiddenField1" value="true"&gt;
  &lt;f:validator validatorId="dateOfBirthValidator" /&gt;
  &lt;f:attribute name="dob_dotm" value="#{dob_dotm}" /&gt;
  &lt;f:attribute name="dob_moty" value="#{dob_moty}" /&gt;
  &lt;f:attribute name="dob_year" value="#{dob_year}" /&gt;
&lt;/h:inputHidden&gt;

&lt;div class="row  my-group-border"&gt;
  &lt;div class="col-sm-3"&gt;
    &lt;label class="control-label"
      for="dobDay"&gt;Day&lt;/label&gt;
    &lt;div class="controls"&gt;
      &lt;h:selectOneMenu id="dobDay"
         value="#{contactDetailControllerJV.dobDay}"
         binding="#{dob_dotm}"
         label="Registration Day"&gt;
        &lt;f:selectItem itemLabel="----"  itemValue=""/&gt;
        &lt;f:selectItems
          value="#{contactDetailControllerJV.daysOfTheMonth}" var="day"
         itemLabel="#{day}" itemValue="#{day}" /&gt;
        &lt;f:validateRequired/&gt;
        &lt;f:validateLongRange
          minimum="1" maximum="31" /&gt;
      &lt;/h:selectOneMenu&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-3"&gt;
    ...
        &lt;h:selectOneMenu id="dobMonth"
          value="#{contactDetailControllerJV.dobMonth}"
           binding="#{dob_moty}"
           label="Registration Month"&gt;
          ...
        &lt;/h:selectOneMenu&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-3"&gt;
    ...
        &lt;h:inputText id="dobYear"
          value="#{contactDetailControllerJV.dobYear}"
             binding="#{dob_year}"
             label="Registration Year"&gt;
          ...
        &lt;/h:inputText&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  ...
  &lt;div class="col-sm-12"&gt;
    &lt;h:message for="aggregateDobHidden"
      styleClass="alert validation-error"/&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre7">We utilize the hidden field, which is identified as <code class="email">aggregateDobHidden</code> with a dummy form parameter name <code class="email">hiddenField1</code>. It always sends a true value. The <code class="email">&lt;f:attribute&gt;</code> element appends <a id="id457" class="calibre1"/>additional binding information to this UI component. We need three attributes with the names <code class="email">dob_dotm</code> (day of the month), <code class="email">dob_moty</code> (month of the year), and <code class="email">dob_year</code>. These attributes are value expressions for the similarly-named page scope variables <code class="email">#{dob_dotm}</code>, <code class="email">#{dob_moty}</code>, and <code class="email">#{dob_year}</code> respectively.</p><p class="calibre7">We add a binding attribute to each of the JSF selection components. Look at the following first field, again:</p><div class="informalexample"><pre class="programlisting">&lt;h:selectOneMenu id="dobDay"
    value="#{contactDetailControllerJV.dobDay}"
   binding="#{dob_dotm}"</pre></div><p class="calibre7">The attribute binding associates the component to the view and makes it available in the page scope variable defined by the literal String definition <code class="email">#{dob_dotm}</code>. This is an instance of the <code class="email">javax.faces.component.UIInput</code> class, which has a <code class="email">getSubmittedValue()</code> method to get the submitted value. We repeat adding the binding for the other two properties. During a form submission, <code class="email">hiddenField1</code> has the record of bound values for each of the individual properties. This property is different from the individual day, month, and year properties.</p><p class="calibre7">This trick with the binding allows us to group properties together for form validation. The following source code shows the validation on the server side:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.faces.component.*;
import javax.faces.context.FacesContext;
import javax.faces.validator.*;
import java.util.*;

@FacesValidator("dateOfBirthValidator")
public class FacesDateOfBirthValidator implements Validator {
  @Override
  public void validate(FacesContext context,
  UIComponent component, Object value)
  throws ValidatorException {
    UIInput dayComp   = (UIInput)
      component.getAttributes().get("dob_dotm");
    UIInput monthComp = (UIInput)
      component.getAttributes().get("dob_moty");
    UIInput yearComp  = (UIInput)
      component.getAttributes().get("dob_year");

    List&lt;FacesMessage&gt; errors = new ArrayList&lt;&gt;();
    int day = parsePositiveInteger(
      dayComp.getSubmittedValue());
    if ( day &lt; 1 || day &gt; 31 ) {
      errors.add(new FacesMessage(
        FacesMessage.SEVERITY_ERROR,
        "DOB day must be in the range of 1 to 31 ", null));
    }
    int month = parsePositiveInteger(
      monthComp.getSubmittedValue());
    if ( month &lt; 1 || month &gt; 12 ) {
      errors.add(new FacesMessage(
        FacesMessage.SEVERITY_ERROR,
        "DOB month must be in the range of 1 to 12 ", null));
    }

    Calendar cal = Calendar.getInstance();

    cal.setTime(new Date());
    cal.add(Calendar.YEAR, -18);
    Date eighteenBirthday = cal.getTime();

    cal.setTime(new Date());
    cal.add(Calendar.YEAR, -100);
    Date hundredthBirthday = cal.getTime();

    int year = parsePositiveInteger(
      yearComp.getSubmittedValue());
    cal.set(year,month,day);
    Date targetDate = cal.getTime();
    if (targetDate.after(eighteenBirthday) ) {
      errors.add(new FacesMessage(
        FacesMessage.SEVERITY_ERROR,
        "DOB year: you must be 18 years old.", null));
    }
    if ( targetDate.before(hundredthBirthday)) {
      errors.add(new FacesMessage(
        FacesMessage.SEVERITY_ERROR,
        "DOB: you must be younger than 100 years old.", null ));
    }
    if ( !errors.isEmpty()) {
      throw new ValidatorException(errors);
    }
  }

  public int parsePositiveInteger( Object value ) { /*...*/ }
}</pre></div><p class="calibre7">The POJO <code class="email">FacesDateOfBirthValidator</code> verifies the three DOB properties. It does this using a technique<a id="id458" class="calibre1"/> in JSF called binding in the page view, which we will see in a minute. Binding allows JSF input properties to be propagated to another named scope variable that can be used elsewhere on the page. As for the validator, we use an HTML hidden element as a vehicle to retrieve these bounded values as attributes. This is the purpose of the code that casts the component to <code class="email">javax.faces.component.UIInput</code> and then extracts a value.</p><div class="informalexample"><pre class="programlisting">UIInput dayComp   = (UIInput)
      component.getAttributes().get("dob_dotm");
int day = parsePositiveInteger(
      dayComp.getSubmittedValue());</pre></div><p class="calibre7">We have a helper method, <code class="email">parsePositiveInteger()</code> for converting the text value to an integer. Before that, we create a list collection to store any error messages. We then validate the boundary for the day-of-the month from 1 to 31. The logic is almost identical for the month property.</p><p class="calibre7">For the year property, we take a different step. Using the JDK Calendar and Date classes, we build two Date instances: one represents the current date exactly 100 years ago and the other represents the current date 18 years ago. We can then compare if the user's entry date falls inside these two birthday limits.</p><p class="calibre7">If there are any errors at the end of the method <code class="email">validate()</code>, then it raises a <code class="email">ValidatorException</code> exception with the error collections. Note that we elect to use the alternative constructor.</p><p class="calibre7">To complete the validator, the helper method <code class="email">parsePositiveInteger()</code> can be written as follows:</p><div class="informalexample"><pre class="programlisting">  public int parsePositiveInteger( Object value ) {
    if ( value == null ) return -1;
    try {
        return Integer.parseInt( value.toString().trim());
    }
    catch (NumberFormatException nfe) {
        return -1;
    }
  }</pre></div><p class="calibre7">The following <a id="id459" class="calibre1"/>is a screenshot of the contact detail that demonstrates the group validator in use:</p><div class="mediaobject"><img src="../Images/image00388.jpeg" alt="Validating groups of properties" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the date of birth validators</p></div></div><p class="calibre11"> </p></div></div><div class="book" title="Converters"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec39" class="calibre1"/>Converters</h2></div></div></div><p class="calibre7">The <a id="id460" class="calibre1"/>standard JSF validators allow the digital developer to achieve a lot <a id="id461" class="calibre1"/>of functionality. There are circumstances when the requirements exceed the default behavior. Converters are JSF classes that convert between strings and objects. Similar to the way in which annotations define the custom validator, JSF permits the registration of custom convertors. A converter is associated with a JSF component.</p><p class="calibre7">The annotation <code class="email">@java.faces.convert.FacesConverter</code> denotes that a POJO is a custom JSF converter. This type must implement the <code class="email">javax.faces.convert.Converter</code> interface, which has the following methods:</p><div class="informalexample"><pre class="programlisting">public Object getAsObject( FacesContext context,
  UIComponent component, String newValue);

public String getAsString( FacesContext context,
  UIComponent component, Object value);</pre></div><p class="calibre7">The method <code class="email">getAsObject()</code> converts a string representation from the client to the target object. The<a id="id462" class="calibre1"/> other method <code class="email">getAsString()</code> converts the object to the string<a id="id463" class="calibre1"/> representation, which is rendered in the client browser.</p><p class="calibre7">We shall <a id="id464" class="calibre1"/>exemplify the custom JSF converter with one that converts a string to the suits of playing cards. We can write this using a simple Java enumeration class:</p><div class="informalexample"><pre class="programlisting">public enum FrenchSuit {
    HEARTS, DIAMONDS, CLUBS, SPADES
}</pre></div><p class="calibre7">The following is the full listing for the custom converter <code class="email">FrenchSuitConverter</code> class:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.faces.application.FacesMessage;
import javax.faces.component.*;
import javax.faces.context.FacesContext;
import javax.faces.convert.*;
import static uk.co.xenonique.digital.FrenchSuit.*;

@FacesConverter("frenchSuitConverter")
public class FrenchSuitConverter implements Converter {
  @Override
  public Object getAsObject(FacesContext context,
    UIComponent component, String value) {
    String text = value.trim();
    if ( text.length() == 0 ) {
      text = ((UIInput)component).getSubmittedValue().toString();
    }
    text = text.toUpperCase();
    switch (text) {
      case "HEARTS": return HEARTS;
      case "DIAMONDS": return DIAMONDS;
      case "CLUBS": return CLUBS;
      case "SPADES": return SPADES;
      default:
        throw new ConverterException(
          new FacesMessage(
            FacesMessage.SEVERITY_ERROR,
            "Unable to convert object to string", null));
    }
  }

  @Override
  public String getAsString(FacesContext context,
    UIComponent component, Object value) {
    if ( value instanceof String ) {
      return value.toString();
    }
    else if ( !(value instanceof FrenchSuit)) {
      throw new ConverterException(
        new FacesMessage(
          FacesMessage.SEVERITY_ERROR,
          "Unable to convert object to string", null));
    }
    switch ((FrenchSuit)value) {
      case HEARTS: return "Hearts";
      case DIAMONDS: return "Diamonds";
      case CLUBS: return "Clubs";
      case SPADES: return "Spades";
    }
    throw new IllegalStateException(
        "PC should never reach here!");
  }
}</pre></div><p class="calibre7">The POJO is the annotated <code class="email">@FacesConverter</code>, and the value becomes the identifier in the page view.</p><p class="calibre7">JSF invokes<a id="id465" class="calibre1"/> the <code class="email">getAsObject()</code> method with the text representation, which is <a id="id466" class="calibre1"/>trimmed and transformed to the uppercase in order to make the comparisons easier. At the beginning of the method, there is a possibility that the new value could be a blank string. If this is true, then we retrieve the text representation from the already submitted value. For this particular converter, the use case of an empty value is a possibility, so we add the guard. If there is an issue with the process, the method raises an exception, <code class="email">javax.faces.convert.ConverterException</code>.</p><p class="calibre7">JSF calls the <code class="email">getAsString()</code> method in order to convert the object representation to a String. Depending on the object type, the method defends against the different types of input. The input value may be just a string, or it may be an instance of the <code class="email">FrenchSuit</code> enumeration. If the input value is not one of these, the method raises <code class="email">ConverterException</code>.</p><p class="calibre7">In the real world, we know that there will always be four suits in a set of playing cards, and therefore, we can be fairly confident about the maintainability of our enumeration. As a digital <a id="id467" class="calibre1"/>developer, you may not have such luxuries, and hence, applying the principle of defensive programming in a converter and a validator can go a long <a id="id468" class="calibre1"/>way to tracking down bugs.</p><p class="calibre7">The following is an extract from the page <code class="email">/jsf-validation/french-suit.xhtml</code> that exercises the custom converter:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="cardForm"
        styleClass="form-horizontal"
        p:role="form"&gt;
  ...
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="suit" class="col-sm-3 control-label"&gt;
        Card Suit&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:selectOneMenu class="form-control"
           label="Suit" id="suit"
           value="#{frenchSuitController.suit}" &gt;
        &lt;f:converter converterId="frenchSuitConverter" /&gt;
        &lt;f:selectItem itemLabel="-" itemValue="" /&gt;
        &lt;f:selectItem itemValue="#{frenchSuitController.suitEnumValue('HEARTS')}" /&gt;
        &lt;f:selectItem itemValue="#{frenchSuitController.suitEnumValue('CLUBS')}" /&gt;
        &lt;f:selectItem itemValue="#{frenchSuitController.suitEnumValue('DIAMONDS')}" /&gt;
        &lt;f:selectItem itemValue="#{frenchSuitController.suitEnumValue('SPADES')}" /&gt;
        &lt;f:validateRequired/&gt;
      &lt;/h:selectOneMenu&gt;
      &lt;h:message for="suit" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;h:commandButton styleClass="btn btn-primary"
     action="#{frenchSuitController.doAction()}"
     value="Submit" /&gt;
  ...
&lt;/h:form&gt;</pre></div><p class="calibre7">In the preceding view, we are using a dropdown menu <code class="email">&lt;h:selectOneMenu&gt;</code> that allows the user to select a card suit. The code should be very familiar to you by now. The difference lies in the value expressions for each card suit, which are all method invocations with a String-literal parameter. The Expression Language allows you to call methods with parameters. Therefore, the expression: <code class="email">#{frenchSuitController.suitEnumValue('HEARTS')}</code> translates to a method call on the controller.</p><p class="calibre7">Inside the <a id="id469" class="calibre1"/>body content of <code class="email">&lt;h:selectOneMenu&gt;</code>, we explicitly reference<a id="id470" class="calibre1"/> the custom converter by an identifier, and associate it with the UI component through the following:</p><div class="informalexample"><pre class="programlisting">&lt;f:converter converterId="frenchSuitConverter" /&gt;</pre></div><p class="calibre7">JSF then invokes the custom converter in order to translate the individual <code class="email">FrenchSuit</code> enumeration to a String from the page view. It sounds like a roundabout way to show a list of values, but this example demonstrates that the method <code class="email">getAsString()</code> in <code class="email">FrenchSuitConverter</code> is being called. Additionally, it illustrates how to reference Java enumeration in a page view and in a controller in a robust manner.</p><p class="calibre7">Let's examine the controller now:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.faces.context.Flash;
import javax.faces.context.FacesContext;
import javax.faces.view.ViewScoped;
import javax.inject.Named;

@Named("frenchSuitController")
@ViewScoped
public class FrenchSuitController {
    private String firstName;
    private String lastName;
    private FrenchSuit suit;

    public String doAction() {
        Flash flash = FacesContext.getCurrentInstance().
                getExternalContext().getFlash();
        flash.put("firstName",firstName);
        flash.put("lastName",lastName);
        flash.put("suit", suit);
        return "/jsf-validation/french-suit-complete?redirect=true";
    }

    public String cancel() {
        return "/index.xhtml?redirect=true";
    }

    public FrenchSuit  suitEnumValue( String name ) {
        return FrenchSuit.valueOf(name);
    }

    // Getters and setters omitted
}</pre></div><p class="calibre7">We are<a id="id471" class="calibre1"/> jumping ahead slightly with this code for <code class="email">FrenchSuitController</code>. First, let me draw your attention to the method <code class="email">suitEnumValue()</code>, which converts a String literal to the enumeration type <code class="email">FrenchSuit</code>. This is a nice handy trick<a id="id472" class="calibre1"/> for obtaining enumerations in the page view, because Expression Language does not allow direct access to the Java enumerations. It will especially work with enumerations that change over time through different project releases.</p><p class="calibre7">The <code class="email">doAction()</code> and <code class="email">cancel()</code> methods return the URI with a special query parameter <code class="email">redirect=true</code>. This is an instruction for JSF to return a bookmarkable URL; we shall cover this topic much later in this chapter.</p><p class="calibre7">Within <code class="email">doAction()</code> we are making use of the Flash scope in JSF for the first time. The Flash scope is a temporary context that allows the controllers to pass on data to the next navigation view. Remember that the View scope is only valid for the current controller that navigates to the same page view. The <code class="email">@ViewScoped</code> managed beans go out of scope when the <code class="email">FacesContext</code> moves to the next page view. The methods set a key value association in the <code class="email">javax.faces.context.Flash</code> instance.</p><p class="calibre7">The final piece of the puzzle demonstrates how we use the Flash scope in a page view. This code can be found in the file <code class="email">/jsf-validation/french-suit-complete.xhtml</code>. The following code is an extract from the same:</p><div class="informalexample"><pre class="programlisting">&lt;ui:define name="mainContent"&gt;
  &lt;h1&gt; House of Card with JSF Validation&lt;/h1&gt;
  ...
  &lt;div class="jumbotron"&gt;
    &lt;h1&gt; Complete &lt;/h1&gt;
    &lt;p&gt;
      Terrific! You completed the French suit action.
      Your first name is &lt;b&gt;#{flash['firstName']}&lt;/b&gt; and
      your last name is &lt;b&gt;#{flash['lastName']}&lt;/b&gt; and
      you chose &lt;b&gt;#{flash['suit']}&lt;/b&gt; as the playcard suit.
    &lt;/p&gt;
  &lt;/div&gt;
  ...
&lt;/ui:define&gt;</pre></div><p class="calibre7">In this page view, we use the map expression to retrieve values from the Flash scope. The expression <code class="email">#{flash['suit']}</code> is the suit that the user selected. The reader is also directed to look at the documentation for the default JSF converter <code class="email">javax.faces.convert.EnumConverter</code>. In the same package, there are other standard converters such as <code class="email">BigDecimalConverter</code>, <code class="email">BigIntegerConverter</code>, <code class="email">DateTimeConverter</code>, <code class="email">ByteConverter</code>, <code class="email">LongConverter</code>, and <code class="email">DoubleConverter</code>.</p><p class="calibre7">I will leave<a id="id473" class="calibre1"/> you<a id="id474" class="calibre1"/> with the screenshot for the form view <code class="email">french-suit.xhtml</code>:</p><div class="mediaobject"><img src="../Images/image00389.jpeg" alt="Converters" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the suites of cards with the JSF convertor</p></div></div><p class="calibre11"> </p><p class="calibre7">The following is a screenshot showing the end state of <code class="email">french-suit-complete.xhtml</code>. The mark up shows nice visuals in the CSS jumbotron style from Bootstrap.</p><div class="mediaobject"><img src="../Images/image00390.jpeg" alt="Converters" class="calibre10"/><div class="caption"><p class="calibre24">The second screen from the house of cards example after form submission and validation</p></div></div><p class="calibre11"> </p><p class="calibre7">We have<a id="id475" class="calibre1"/> covered a lot of validation that happens on the server side. Let's now <a id="id476" class="calibre1"/>move on to AJAX validation.</p></div><div class="book" title="Validating immediately with AJAX"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec40" class="calibre1"/>Validating immediately with AJAX</h2></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">Asynchronous JavaScript and XML</strong></span> (<span class="strong"><strong class="calibre8">AJAX</strong></span>) is a group of technologies that together solve the restriction to the retrieving of partial updates to a web page and that provide a rich interactive user experience. The key to AJAX is the term <span class="strong"><em class="calibre9">asynchronous</em></span>, which  builds on a <span class="strong"><strong class="calibre8">World Wide Web Consortium</strong></span> (<span class="strong"><strong class="calibre8">W3C</strong></span>) standard namely, the <code class="email">XmlHttpRequest</code> object. It was introduced in the Internet Explorer in 2006  and all modern <a id="id477" class="calibre1"/>web browsers by now support this <a id="id478" class="calibre1"/>object. The asynchronous <a id="id479" class="calibre1"/>mode allows the browser to make a data transfer request to the server on a separate connection; the enterprise backend response responds with a data result, usually JSON or XML. These AJAX data transfers tend to be smaller in comparison to reloading the entire page each time.</p><p class="calibre7">JSF has built-in support for AJAX requests and responses; the developer does not have to know the finer details of <code class="email">XmlHttpRequest</code> and JavaScript programming to get the benefit of an immediate response. The digital developer can start with the default JavaScript library for performing AJAX interaction.</p><p class="calibre7">It is very <a id="id480" class="calibre1"/>easy to get started with <a id="id481" class="calibre1"/>AJAX in JSF with the <code class="email">&lt;f:ajax&gt;</code> tag. This Core JSF tag registers the AJAX behavior with a UI component, and it is used to perform validation on a field. Developers are only required to place the tag inside the body content of an HTML JSF tag that represents a component, which requires validation.</p><p class="calibre7">The following code shows how to use this tag with the contact details application:</p><div class="informalexample"><pre class="programlisting">&lt;f:ajax event="blur" render="firstNameError"/&gt;</pre></div><p class="calibre7">The <code class="email">tag</code> attribute event establishes when the framework would invoke the AJAX validation. The blur value denotes that it occurs when the user moves from this component field to the next input field. So when the user presses the <span class="strong"><em class="calibre9">Tab</em></span> key on a desktop computer or navigates the UI on a phone or a tablet, validation occurs immediately, because JavaScript fires an AJAX request to the server. The second attribute, render, informs the framework about the specific UI component to render the error message to, if any. JSF receives an AJAX response, and if there is an error, it knows the HTML component ID to update with the validation message.</p><p class="calibre7">Let's look at the project <code class="email">ch04/jsf-crud-ajax-validation</code>, which is the full extract of the page view <code class="email">jsf-validation/createContactDetail.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="createContactDetail"
  styleClass="form-horizontal"
  p:role="form"&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="title" class="col-sm-3 control-label"&gt;
        Title&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:selectOneMenu class="form-control"
           label="Title" id="title"
         value="#{contactDetailControllerJV.contactDetail.title}"&gt;
        &lt;f:selectItem itemLabel="-" itemValue="" /&gt;
        &lt;f:selectItem itemValue="Mr" /&gt;
        &lt;f:selectItem itemValue="Mrs" /&gt;
        &lt;f:selectItem itemValue="Miss" /&gt;
        &lt;f:selectItem itemValue="Ms" /&gt;
        &lt;f:selectItem itemValue="Dr" /&gt;
        &lt;f:validateRequired/&gt;
        &lt;f:ajax event="blur" render="titleError"/&gt;
      &lt;/h:selectOneMenu&gt;
      &lt;h:message id="titleError"
                 for="title" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="firstName" class="col-sm-3 control-label"&gt;
        First name&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText class="form-control" label="First name"
     value="#{contactDetailControllerJV.contactDetail.firstName}"
       id="firstName" placeholder="First name"&gt;
          &lt;f:validateRequired/&gt;
          &lt;f:validateLength maximum="64" /&gt;
          &lt;f:ajax event="blur" render="firstNameError"/&gt;
      &lt;/h:inputText&gt;
      &lt;h:message id="firstNameError"
          for="firstName" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="middleName" class="col-sm-3 control-label"&gt;
        Middle name&lt;/h:outputLabel&gt;
      ...
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="lastName" class="col-sm-3 control-label"&gt;
        Last name&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText class="form-control"
   value="#{contactDetailControllerJV.contactDetail.lastName}"
       label="Last name"
       id="lastName" placeholder="Last name"&gt;
          &lt;f:validateRequired/&gt;
          &lt;f:validateLength maximum="64" /&gt;
          &lt;f:ajax event="blur" render="lastNameError"/&gt;
      &lt;/h:inputText&gt;
      &lt;h:message id="lastNameError"
         for="lastName" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  ...
&lt;/h:form&gt;</pre></div><p class="calibre7">This page view exemplifies that adding the AJAX validation to a page is extremely easy in JSF. The <code class="email">&lt;f:ajax&gt;</code> Core JSF tag is embedded in the corresponding HTML JSF tag, as you can see <a id="id482" class="calibre1"/>for the first and<a id="id483" class="calibre1"/> last name fields. The other difference between the non-AJAX and AJAX page for contact details is the addition of the identifiers such as <code class="email">firstNameError</code> and <code class="email">lastNameError</code> to the <code class="email">&lt;h:message&gt;</code> tag.  We need to add the HTML identifier elements for allowing JavaScript to look <a id="id484" class="calibre1"/>up the HTML element by ID from the browser's <span class="strong"><strong class="calibre8">Document Object Model</strong></span> (<span class="strong"><strong class="calibre8">DOM</strong></span>).</p><p class="calibre7">The page has an AJAX validation added to all the properties except for the middle name and the newsletter HTML checkbox field. AJAX validation also works with custom validators and converters.</p><p class="calibre7">The following screenshot illustrates the single property AJAX validation:</p><div class="mediaobject"><img src="../Images/image00391.jpeg" alt="Validating immediately with AJAX" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot demonstrating single validations for each input fields</p></div></div><p class="calibre11"> </p></div><div class="book" title="Validating groups of input fields"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec41" class="calibre1"/>Validating groups of input fields</h2></div></div></div><p class="calibre7">So far we have seen the JSF AJAX validation on single instances of input fields. The <code class="email">&lt;f:ajax&gt;</code> tag also <a id="id485" class="calibre1"/>works with validation on a group of components. We can enclose the tag around one or more JSF input fields and then the <code class="email">&lt;f:ajax&gt;</code> tag becomes the parent of the UI component. This causes JSF to apply the AJAX validation to  multiple components.</p><p class="calibre7">Let's add the <a id="id486" class="calibre1"/>group validation to the Date-of-Birth fields in the contact details form with the following page view:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputHidden id="aggregateDobHidden"
             label="hiddenField1" value="true"&gt;
  &lt;f:validator validatorId="dateOfBirthValidator" /&gt;
  &lt;f:attribute name="dob_dotm" value="#{dob_dotm}" /&gt;
  &lt;f:attribute name="dob_moty" value="#{dob_moty}" /&gt;
  &lt;f:attribute name="dob_year" value="#{dob_year}" /&gt;
&lt;/h:inputHidden&gt;

&lt;f:ajax event="blur" render="dobDayError dobMonthError dobYearError"&gt;
  &lt;div class="row  my-group-border"&gt;
    &lt;div class="col-sm-3"&gt;
      &lt;label class="control-label" for="dobDay"&gt;Day&lt;/label&gt;
      &lt;div class="controls"&gt;
        &lt;h:selectOneMenu id="dobDay" value="#{contactDetailControllerJV.dobDay}"
                         binding="#{dob_dotm}"
                         label="Registration Day"&gt;
          ...                        
        &lt;/h:selectOneMenu&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-3"&gt;
      &lt;label class="control-label" for="dobMonth"&gt;Month&lt;/label&gt;
      &lt;div class="controls"&gt;
        &lt;h:selectOneMenu id="dobMonth" value="#{contactDetailControllerJV.dobMonth}"
                         binding="#{dob_moty}"
                         label="Registration Month"&gt;
          ...                        
        &lt;/h:selectOneMenu&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-3"&gt;
      &lt;label class="control-label" for="dobYear"&gt;Year&lt;/label&gt;
      &lt;div class="controls"&gt;
          ...
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-12"&gt;
      &lt;h:message id="dobDayError"
       for="dobDay" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-12"&gt;
      &lt;h:message id="dobMonthError"
       for="dobMonth" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-12"&gt;
      &lt;h:message id="dobYearError"
       for="dobYear" styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-12"&gt;
      &lt;h:messages for="aggregateDobHidden"
        styleClass="alert validation-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/f:ajax&gt;</pre></div><p class="calibre7">As you can see, we<a id="id487" class="calibre1"/> surround the DOB input fields with an encompassing <code class="email">&lt;f:ajax&gt;</code> tag. The event attribute is still set to <code class="email">blur</code>. The render attribute is set to a list of the HTML element IDs for specific validation messages, namely <code class="email">dobDayError</code>, <code class="email">dobMonthError</code>, and <code class="email">dobYearError</code>.</p><p class="calibre7">The <code class="email">aggregationDobHidden</code> HTML hidden element is kept the same as in the non-AJAX example in order to illustrate that the validation does not interfere with the custom validation.</p><p class="calibre7">To recap, use the <code class="email">&lt;f:ajaxTag&gt;</code>, and embed it inside any JSF component. To validate over a group of multiple components, surround the components with <code class="email">&lt;f:ajaxTag&gt;</code>.</p><p class="calibre7">The following screenshot depicts the multiple component AJAX validation around the DOB fields. The month-of-the-year component had the browser's focus last and hence, the corresponding validation message depicts the <code class="email">onblur</code> DOM JavaScript event. Similarly, tabbing across this set of fields produces the error messages one by one.</p><div class="mediaobject"><img src="../Images/image00392.jpeg" alt="Validating groups of input fields" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the group validation for date of birth input fields</p></div></div><p class="calibre11"> </p></div><div class="book" title="AJAX custom tag in depth"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec42" class="calibre1"/>AJAX custom tag in depth</h2></div></div></div><p class="calibre7">It is useful to <a id="id488" class="calibre1"/>understand the attributes that can be applied to this Core JSF custom tag. The following table describes the attributes for <code class="email">&lt;f:ajax&gt;</code>.</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Attribute</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description </p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">delay</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies <a id="id489" class="indexterm"/>the delay in milliseconds between sending multiple AJAX requests to the server. Requests are queued up by the JSF implementation. Setting the value to none disables the feature.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">disabled</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies <a id="id490" class="indexterm"/>a Boolean value to indicate the tag status. If set to true, then the AJAX behavior is not rendered. The default value is false.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">event</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Defines a<a id="id491" class="indexterm"/> String enumeration that represents the event type of the AJAX action. By default, JSF determines the event name for the component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">execute</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Enumerates<a id="id492" class="indexterm"/> a space-delimited collection of names that represent the components that are executed on the server. The value can be a string or a value expression. The default value is <code class="literal">@this</code>, which indicates the parent component of the AJAX behavior.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">immediate</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">States a<a id="id493" class="indexterm"/> Boolean value that indicates whether the input value is processed early in the JSF lifecycle.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">listener</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Indicates<a id="id494" class="indexterm"/> the name of the listener method that will be called during a broadcast event, namely <code class="literal">AjaxBehaviorEvent</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">onerror</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies <a id="id495" class="indexterm"/>the name of a JavaScript function that will accept errors.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">onevent</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies<a id="id496" class="indexterm"/> the name of a JavaScript function that will handle the UI events.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">render</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Enumerates a collection of UI components that will be rendered on the client<a id="id497" class="indexterm"/> when the AJAX behavior completes. This value can be a space-delimited collection of component identifiers, or it can be a value expression. The default value is <code class="literal">@none</code>, which means that no components are rendered.</p>
</td></tr></tbody></table></div><p class="calibre7">From this preceding table, you will notice that the execute and render attributes may indicate additional meaningful values. The execute attribute stipulates the components to be executed on the server. The render attribute determines the affected UI components for when the AJAX behavior completes. The following table lists the attribute values:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Value </p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description </p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@all</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies <a id="id498" class="indexterm"/>that all the components are executed or rendered in the view.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@form</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies that only the components that are the children of the form are executed or rendered.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@none</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies that no components are executed or rendered.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">@this</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies that only the current component that triggered the AJAX request is executed or rendered.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">List of component identifiers</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Enumerates <a id="id499" class="indexterm"/>the identifiers of the UI components that are explicitly executed or rendered as an AJAX request.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">Expression language</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies a value expression that ultimately returns a collection of Strings, which indicates the UI components that are executed or rendered as an AJAX request-response.</p>
</td></tr></tbody></table></div></div></div>
<div class="book" title="A partial JSF lifecycle" id="aid-1BRPS1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch04lvl1sec39" class="calibre1"/>A partial JSF lifecycle</h1></div></div></div><p class="calibre7">The JSF lifecycle is, in effect, for all Faces requests and responses including those that emanate from the AJAX-enabled components. Behind the scenes, JSF instantiates a special object, <code class="email">javax.faces.context.PartialViewContext</code> for the AJAX requests and responses, and that is entered into the processing lifecycle. This context object contains the information that allows JSF to update the component model on the server-side. Based on the<a id="id500" class="calibre1"/> partial context, JSF decides whether to accomplish partial processing of the selected UI component and/or partial rendering of the UI components. Partial processing corresponds to the Apply-Requests-Values, Process-Validations, and Update-Model-Values phases of the lifecycle. Partial rendering refers to the Render-Response phase.</p><div class="mediaobject"><img src="../Images/image00393.jpeg" alt="A partial JSF lifecycle" class="calibre10"/><div class="caption"><p class="calibre24">Partial request – response lifecycle for AJAX submissions</p></div></div><p class="calibre11"> </p><p class="calibre7">The preceding diagram encapsulates our understanding of the partial context for the AJAX request <a id="id501" class="calibre1"/>and response in the JSF lifecycle.</p></div>
<div class="book" title="Handling views"><div class="book" id="aid-1CQAE2"><div class="book"><div class="book"><h1 class="title"><a id="ch04lvl1sec40" class="calibre1"/>Handling views</h1></div></div></div><p class="calibre7">In this chapter, we've chiefly examined the validation of the users' input with JSF. There were some miscellaneous concepts  regarding navigation that we glossed over. Let's now talk about <a id="id502" class="calibre1"/>handling views and navigation.</p><div class="book" title="Invoking controller methods"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec43" class="calibre1"/>Invoking controller methods</h2></div></div></div><p class="calibre7">There are <a id="id503" class="calibre1"/>several ways to invoke the controller from a<a id="id504" class="calibre1"/> page view with parameters. For many situations in the digital e-commerce applications, developers need to retrieve a particular data record, trigger a server-side action, or save a certain state from the client-side at the backend.</p><div class="book" title="Parameterized method invocations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec21" class="calibre1"/>Parameterized method invocations</h3></div></div></div><p class="calibre7">JSF allows<a id="id505" class="calibre1"/> the developer to pass parameters to methods in the page view using the Expression Language . The first feature given<a id="id506" class="calibre1"/> in <a class="calibre1" title="Chapter 3. Building JSF Forms" href="part0035.xhtml#aid-11C3M2">Chapter 3</a>, <span class="strong"><em class="calibre9">Building JSF Forms</em></span> is called Method Expression Invocation, which was introduced in JSF 2.0.</p><p class="calibre7">The following is an extract from the page view <code class="email">/jsf-miscellany/examplar-methods.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="methodExampler"
        styleClass="form-horizontal"
        p:role="form"&gt;
  ...
  &lt;div class="form-group"&gt;
    &lt;div class="col-sm-9"&gt;
    &lt;p&gt;
        Invoke JSF controller with 3 literal arguments
    &lt;/p&gt;
    &lt;p class="monospace"&gt;
        \#{examplarController.methodThreeArgs(
          'Obiwan','Ben','Kenobi')}
    &lt;/p&gt;
    &lt;h:commandButton styleClass="btn btn-primary"
       action="#{examplarController.methodThreeArgs(
         'Obiwan','Ben','Kenobi')}"
       value="Invoke" /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  ...
 
&lt;/h:form&gt; </pre></div><p class="calibre7">The preceding code depicts the <code class="email">&lt;h:commandButton&gt;</code> tag with an action value expression, which is <code class="email">#{examplarController.methodThreeArgs('Obiwan','Ben','Kenobi')}</code>. This is a method invocation with three arguments of literal string.</p><p class="calibre7">The arguments can also be references to other JSF scope instances. The following is another invocation with only two arguments that show this off:</p><div class="informalexample"><pre class="programlisting">  &lt;h:commandButton
    styleClass="btn btn-primary"
    action="#{examplarController.methodTwoArgs(
          examplarController.city, examplarController.country)}"
       value="Invoke" /&gt;</pre></div><p class="calibre7">The arguments are dynamically set from the controller bean properties. Let's look at the controller <code class="email">ExamplarController</code> now:</p><div class="informalexample"><pre class="programlisting">@Named("examplarController") @ViewScoped
public class ExamplarController {
  private String city = "London";
  private String country="United Kingdom";

  public String methodOneArg( String alpha ) {
    Flash flash = FacesContext.getCurrentInstance().
      getExternalContext().getFlash();
    flash.put("result",
      String.format("executed methodOneArg(\"%s\")",
        alpha ));
    return "examplar-methods-complete?redirect=true";
  }

  public String methodTwoArgs(
    String alpha, String beta ) {
    Flash flash = FacesContext.getCurrentInstance().
      getExternalContext().getFlash();
    flash.put("result",
      String.format("executed methodTwoArgs(\"%s\", \"%s\")",
      alpha, beta ));
    return "examplar-methods-complete?redirect=true";
  }

  public String methodThreeArgs(
    String alpha, String beta, String gamma ) {
    Flash flash = FacesContext.getCurrentInstance().
      getExternalContext().getFlash();
    flash.put("result",
      String.format("executed methodThreeArgs(\"%s\", \"%s\", \"%s\")",
      alpha, beta, gamma ));
    return "examplar-methods-complete?redirect=true";
  }

  ...
  // Getters and setters omitted
}</pre></div><p class="calibre7">There <a id="id507" class="calibre1"/>are three methods that are<a id="id508" class="calibre1"/> called <code class="email">methodOneArg()</code>, <code class="email">methodTwoArgs()</code>, and <code class="email">methodThreeArgs()</code>. The names are self-explanatory for the number of arguments that can be passed; each one saves an output result in the JSF Flash scope, before moving to the next page view, <code class="email">/jsf-miscellany/examplar-methods-complete.xhtml</code>.</p><p class="calibre7">The <a id="id509" class="calibre1"/>following is the extract <a id="id510" class="calibre1"/>of the end state Facelet view, <code class="email">exemplar-methods-complete.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;ui:composition template="/basic_layout.xhtml"&gt;
  &lt;ui:define name="title"&gt;
    &lt;title&gt; JSF Method Invocation Example &lt;/title&gt;
  &lt;/ui:define&gt;

  &lt;ui:define name="mainContent"&gt;
    &lt;h1&gt; Method Invocations Complete&lt;/h1&gt;
    &lt;h:messages globalOnly="true"
                styleClass="alert alert-danger" /&gt;
    &lt;div class="jumbotron"&gt;
      &lt;h1&gt; Complete &lt;/h1&gt;
      &lt;p&gt;
        Terrific! You completed the action.
        The result message was &lt;b&gt;#{flash['result']}&lt;/b&gt;.
      &lt;/p&gt;
    &lt;/div&gt;
    ... 
  &lt;/ui:define&gt; &lt;!--name="mainContent" --&gt;
&lt;/ui:composition&gt;</pre></div></div><div class="book" title="Passing parameters to the controller"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec22" class="calibre1"/>Passing parameters to the controller</h3></div></div></div><p class="calibre7">Before the JSF 2.0 specification was created, it was possible to send parameters to a backing<a id="id511" class="calibre1"/> bean controller using the <code class="email">&lt;f:param&gt;</code> tag inside of the body of a <code class="email">&lt;h:commandLink&gt;</code>, <code class="email">&lt;h:commandButton&gt;</code>, or <code class="email">&lt;h:link&gt;</code> tag. Although this technique is superseded by the method invocation expressions in JSF 2.0, it is still a useful technique to send out-of-bounds communication to the controller.</p><p class="calibre7">The following code shows the recipe, and we embed two <code class="email">&lt;f:param&gt;</code> elements in a <code class="email">&lt;h:commandButton&gt;</code> custom tag:</p><div class="informalexample"><pre class="programlisting">&lt;div class="form-group"&gt;
  &lt;div class="col-sm-9"&gt;
    &lt;p&gt;
        Invoke JSF controller method with parameters
    &lt;/p&gt;
    &lt;p class="monospace"&gt;
      \#{examplarController.methodPassingAttribute()
      &lt;br/&gt;
          name="callToActionText" value="FindNearestDealer"
      &lt;br/&gt;
      name="customerType" value="Motorbikes"
    &lt;/p&gt;
    &lt;h:commandButton styleClass="btn btn-primary"
       action="#{examplarController.methodPassingParameters()}"
       value="Invoke" &gt;
      &lt;f:param name="callToActionText"
              value="FindNearestDealer"/&gt;
      &lt;f:param name="customerType"
              value="Motorbikes"/&gt;
    &lt;/h:commandButton&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre7">The authoring on this page view invokes the controller's no argument method, <code class="email">methodPassingParameters()</code>. JSF passes two parameters to the target method through the Faces request with the key names <code class="email">callToActionText</code> and <code class="email">customerType</code>.</p><p class="calibre7">Let's look at the controller method that handles this invocation:</p><div class="informalexample"><pre class="programlisting">  public String methodPassingParameters() {
    Map&lt;String,String&gt; params = FacesContext.getCurrentInstance()
        .getExternalContext().getRequestParameterMap();
    String ctaText = params.get("callToActionText");
    String custType = params.get("customerType");
    Flash flash = FacesContext.getCurrentInstance().
        getExternalContext().getFlash();
    flash.put("result",
      String.format("executed methodPassingParameters() " +
        "ctaText=\"%s\", custType=%s", ctaText, custType ));
    return "examplar-methods-complete?redirect=true";
  }</pre></div><p class="calibre7">Inside the <a id="id512" class="calibre1"/>method <code class="email">methodPassingParameters()</code>, we retrieve the parameters from the <code class="email">FacesContext</code> instance by using the nested call <code class="email">getRequestParameterMap()</code>. It is then straightforward to access the parameters from the map collection of type <code class="email">Map&lt;String,String&gt;</code>. It is interesting to note that the parameters can only be Strings, and that this technique can be combined with method parameters invocations in JSF 2.0 and later.</p><p class="calibre7">The following screenshot displays the page to demonstrate the method invocation techniques described in this section:</p><div class="mediaobject"><img src="../Images/image00394.jpeg" alt="Passing parameters to the controller" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the method invocation JSF example</p></div></div><p class="calibre11"> </p></div><div class="book" title="Invoking an action event listener"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec23" class="calibre1"/>Invoking an action event listener</h3></div></div></div><p class="calibre7">The final technique for handling views invokes an action listener in the controller. Any instance <a id="id513" class="calibre1"/>method that accepts a single<a id="id514" class="calibre1"/> argument of <code class="email">javax.faces.event.ActionEvent</code> can be an action event listener. An action listener is associated with a UI component in the page markup. JSF invokes action listeners before invoking the actions, so this technique is helpful for hooking in the business logic and setting up data for the action call.</p><p class="calibre7">The following is an extract from the method invocation page that enacts this technique. We will dispense with the Bootstrap CSS markup in this code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton styleClass="btn btn-primary"
   action="#{examplarController.performAction}"
   actionListener="#{examplarController.attributeListener}"
   value="Invoke"&gt;
  &lt;f:attribute name="contactName" value="Roy Keane" /&gt;
&lt;/h:commandButton&gt;</pre></div><p class="calibre7">The <code class="email">&lt;h:commandButton&gt;</code> tag has an additional <code class="email">actionListener</code> attribute set to the expression that references the action listener method, <code class="email">attributeListener()</code>. The tag also embeds<a id="id515" class="calibre1"/> an <code class="email">&lt;f:attribute&gt;</code> to <a id="id516" class="calibre1"/>define a passed attribute. The action attribute references the method <code class="email">performAction()</code>.</p><p class="calibre7">Let's examine our <code class="email">ExamplarController</code> backing bean to see the code:</p><div class="informalexample"><pre class="programlisting">  private String contactName;

  public void attributeListener(ActionEvent event){
    contactName = (String) event.getComponent()
      .getAttributes().get("contactName");
  }

  public String performAction() {
    Flash flash = FacesContext.getCurrentInstance()
      .getExternalContext().getFlash();
    flash.put("result",
      String.format("executed performAction()
        contactName=\"%s\" ", contactName ));
    return "examplar-methods-complete?redirect=true";
  }</pre></div><p class="calibre7">On submission of the command button, JSF invokes the method <code class="email">attributeListener()</code> first with an <code class="email">ActionEvent</code> instance. We can find the component responsible for the invocation and retrieve the attributes stored on it. In this case, we retrieve the value for the attribute keyed in as <code class="email">contactName</code>. This value is stored in the controller's instance variable. (We must be careful with this technique if the scope of our backing bean is set to a scope other than <code class="email">@RequestScope</code> or <code class="email">@ViewScope</code>, because the instance variable will be shared between multiple requests over time!)</p><p class="calibre7">After the action listener returns, eventually, JSF invokes the action method <code class="email">performAction()</code>. The instance variable <code class="email">contactName</code> is available and has the current value from<a id="id517" class="calibre1"/> the page. The method proceeds<a id="id518" class="calibre1"/> to the next page view.</p></div></div><div class="book" title="Redirection pages"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec44" class="calibre1"/>Redirection pages</h2></div></div></div><p class="calibre7">If you have been following the examples in this chapter, you must have noticed that the page views have been suffixed with a query parameter <code class="email">redirect=true</code> (or <code class="email">faces-redirect=true</code>, according to the official JSF specification). This is an instruction to JSF for sending an HTTP Response back to the web client to be redirected to a URL. Why is this suffix required? It allows the user to bookmark page views, because the JSF framework effectively hides the current page view from the user by just rendering the output. The main issue is internal page forwarding that makes it difficult for the customers using a digital application to remember or bookmark their location. If the customer has a deeply nested site of information architecture, the ability to provide page redirection is key. The secondary issue is that if your web application exercises a flow of process in a linear fashion, then the web browser's URL is updated, but always shows the previous page in the process.</p><p class="calibre7">Redirection works in controller methods <code class="email">examplar-methods-complete?redirect=true</code> that cause JSF to send an HTTP Response Redirect to the browser. The web browser interprets the redirect to another HTTP GET request for a URL such as <code class="email">http://localhost:8080/jsf-crud-ajax-validation-1.0-SNAPSHOT/jsf-miscellany/examplar-methods.xhtml</code>. The consequence of the redirection is that<a id="id519" class="calibre1"/> there are at least two request-response events occurring for each page navigation or action. If you remember, the scope of <code class="email">@ViewScoped</code> or <code class="email">@RequestScoped</code> bean is available only for a short duration. By the time JSF processes the HTTP GET from the redirection instruction, the original bean has already disappeared. This is the reason why the examples use the Flow scope; that scope guarantees that the data from the controller business logic survives till the next page view is displayed.</p><p class="calibre7">The other way to specify page redirection is through <code class="email">faces-config.xml</code> for particular navigation cases. We can define a case as follows:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
  &lt;from-view-id&gt;epayment.xhtml&lt;/from-view-id&gt;
  &lt;navigation-case&gt;
    &lt;from-outcome&gt;payment-delivery&lt;/from-outcome&gt;
    &lt;to-view-id&gt;payment-deliver.xhtml&lt;/to-view-id&gt;
    &lt;redirect /&gt;
  &lt;/navigation-case&gt;
  &lt;navigation-case&gt;
    &lt;from-outcome&gt;payment-creditcard&lt;/from-outcome&gt;
    &lt;to-view-id&gt;payment-credit.xhtml&lt;/to-view-id&gt;
    &lt;redirect /&gt;
  &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p class="calibre7">This style of configuration can be useful in setting up third-party JSF packages. Of course, it also<a id="id520" class="calibre1"/> provides flexibility for library writers, and it does not pollute the Java-managed bean redirect strings. I suppose it is a horses-for-courses situation and, therefore, depends on the purpose of the project.</p><p class="calibre7">Finally, the developer can set redirection directly to page views through submission links and buttons. The following code shows this technique:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton style="btn bth-primary"
  action="epayments.xhtml?faces-redirect=true"
  value="Proceed to Paymemt" /&gt;</pre></div></div><div class="book" title="Debugging the JSF content"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch04lvl2sec45" class="calibre1"/>Debugging the JSF content</h2></div></div></div><p class="calibre7">Maybe I should have introduced this feature of JSF earlier, because learning to develop with JSF<a id="id521" class="calibre1"/> can be puzzling to beginners. It is possible to get<a id="id522" class="calibre1"/> debuggable output in a JSF application if you include the <code class="email">&lt;ui:debug/&gt;</code> custom tag element inside one of the template views. Actually, the Facelet view renderer output of the framework is responsible for this feature.</p><p class="calibre7">By embedding a <a id="id523" class="calibre1"/>single <code class="email">&lt;ui:debug&gt;</code> inside a <code class="email">&lt;ui:insert&gt;</code> tag causes JSF to add a special UI component  to the UI hierarchy tree. This debug component captures the Facelet view information and current state of the UI hierarchy, including any scoped variables in the application. Information is captured at the time of rendering . If the user presses the keys <span class="strong"><em class="calibre9">Ctrl</em></span> + <span class="strong"><em class="calibre9">Shift</em></span> + <span class="strong"><em class="calibre9">D</em></span>, JSF opens a separate browser window showing the debuggable information, which is really useful in tough situations. The main template of the application is the best place to add the <code class="email">&lt;ui:debug&gt;</code> tag.</p><p class="calibre7">The <code class="email">&lt;ui:debug&gt;</code> tag accepts the following attributes:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Name</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Type</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">hotkey</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">String</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Defines<a id="id524" class="indexterm"/> the single character of the hotkey that causes the debuggable window to open. The default is <code class="literal">d</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">rendered</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">ValueExpression</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Specifies<a id="id525" class="indexterm"/> if the debug component is rendered or not. It must be a value expression or a String literal that evaluates to <code class="literal">true</code> or <code class="literal">false</code>.</p>
</td></tr></tbody></table></div><p class="calibre7">The following screenshot shows the exemplar method invocations:</p><div class="mediaobject"><img src="../Images/image00395.jpeg" alt="Debugging the JSF content" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Clicking on<a id="id526" class="calibre1"/> the plus (<span class="strong"><strong class="calibre8">+</strong></span>) symbols expands the content so that the <a id="id527" class="calibre1"/>developers see more information dynamically.</p></div></div>
<div class="book" title="Summary" id="aid-1DOR01"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch04lvl1sec41" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This chapter focused on the different forms of JSF validation, because it is extremely important for the user to know if the data has been entered correctly. We examined the two forms of validation methods: client side and server side. We looked at the <code class="email">FacesMessage</code> instances and learnt how to create them. Afterwards, we proceeded to cover validation from the server side, particularly, the Bean Validation framework in Java EE 7. We then took an extended developer journey into JSF validation. We learnt how to create custom validators and converters. We also learnt how to perform immediate mode validation with AJAX and understood the partial context life cycle. Finally, we spent a good deal of time on handling views and passing information from the page view to the controller. Along the way, we addressed the JSF flow scope and page redirection.</p><p class="calibre7">In the next chapter, we will turn our attention to conversational scopes and start putting the useful process flow applications together. At this point, we add finesse and sophistication to our burgeoning digital JSF applications. I will you see there.</p></div>
<div class="book" title="Exercises" id="aid-1ENBI1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch04lvl1sec42" class="calibre1"/>Exercises</h1></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem">What is the fundamental difference between the <code class="email">&lt;h:outputLink&gt;</code> and <code class="email">&lt;h:commandButton&gt;</code> elements? How do you style the control elements appropriately with a CSS framework such as Bootstrap?</li><li class="listitem">In the previous chapter, there were exercises around developing a web application for registering new people to a local hobbyist book-reading club. Did you happen to write content in separate pages with no reuse?</li><li class="listitem">Apply the UI template compositing to your hobby book club project. Call this version two and save the first version for your reference. Make use of the Template Composition tags <code class="email">&lt;ui:define&gt;</code>, <code class="email">&lt;ui:composition&gt;</code>, and <code class="email">&lt;ui:insert&gt;</code> only at this stage.</li><li class="listitem">Add a <code class="email">&lt;ui:debug&gt;</code> custom tag to master the template page. What does this special tag do for the developer?</li><li class="listitem">An annoyed business stakeholder arrives at your office and tells you about an issue that they are having with spoof data. It seems that some naughty people on the Internet are faking data entry and this is causing more burden for the caseworkers. As a consultant with JSF, explain how you can protect the data in the backend database using validation. Would only a server-side validation work? Would only client-side validation work?</li><li class="listitem">With reference to the previous Hobby Book Club application, let's now add validation to the JSF form elements that you created.</li><li class="listitem">Add Bean Validation to the registrant class (<code class="email">Registrant.java</code>—you may have named this class differently in your own project). Will your users be satisfied with the validation output?</li><li class="listitem">What happens when you add only the server-side validation to an application?</li><li class="listitem">What are the differences between Bean Validation and JSF validation?</li><li class="listitem">What are the similarities between Bean Validation and JSF validation?</li><li class="listitem">How appropriate are the error messages for Bean Validation and JSF validation according to the users ?</li><li class="listitem">Start with the creation page. Validate against the registrant's name. You can validate with <code class="email">&lt;f:validateRequired&gt;</code> and <code class="email">&lt;f:validateLength&gt;</code> directly on the page view. Add appropriate <code class="email">&lt;h:messages&gt;</code> to the page view.</li><li class="listitem">Some registrants use social networks like Facebook, Twitter, and Instagram. Add some properties to the Registrant POJO. Add a URL validator to verify that the social network properties are correct. Use the regular expression validator to verify the Twitter account syntax or, perhaps, write your own custom validator.</li><li class="listitem">Download the book's source code example and run the sample code for Chapter 4. Study how validation occurs from the server side.</li><li class="listitem">Given that you have developed your project with server-side validation, you must take the Hobby Book Club web application up a notch. Add client-side validation with AJAX for control elements. You will need to add appropriate <code class="email">&lt;f:ajax&gt;</code> elements to your JSF form control elements. Don't forget that each control requires an area to render a specific error message; so, you will not add a corresponding <code class="email">&lt;h:message&gt;</code> element on the page in close proximity.</li><li class="listitem">Download the Chrome Developer Web Tools or similar web page inspection development tools, and inspect the HTML content of the JSF application. What do you observe and notice about the naming of the various HTML elements, especially the forms?</li><li class="listitem">Take a breather and add modern CSS styles to the Hobby Book Club application. Ask a colleague or friend to evaluate the user experience of your application and gather feedback. Act on the feedback; change the content around.</li><li class="listitem">Add a cancel operation to your CRUD application; what do you need to ensure that JSF does not validate the input?</li></ol><div class="calibre25"/></div></div></body></html>