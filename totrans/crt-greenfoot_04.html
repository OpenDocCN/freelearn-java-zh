<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Projectiles"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Projectiles</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Flying is learning how to throw yourself at the ground and miss."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Douglas Adams</em></span></span></td></tr></table></div><p>Actors in creative Greenfoot applications, such as games and animations, often have movement that can best be described as <span class="emphasis"><em>being launched</em></span>. For example, a soccer ball, bullet, laser, light ray, baseball, and firework are examples of this type of object. One common method of implementing this type of movement is to create a set of classes that model real-world physical properties (mass, velocity, acceleration, friction, and so on) and have game or simulation actors inherit from these classes. Some refer to this as creating a <span class="emphasis"><em>physics engine</em></span> for your game or simulation. However, this course of action is complex and often overkill. As you learned in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>, there are often simple heuristics we can use to approximate realistic motion. This is the approach we will take here.</p><p>In this chapter, you will learn about the basics of projectiles, how to make an object bounce, and a little about particle effects. We will apply what you learn to a small platform game that we will build up over the course of this chapter. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Gravity and jumping</li><li class="listitem">Bouncing</li><li class="listitem">Particle effects</li><li class="listitem">Bullets and turrets</li></ul></div><p>Creating realistic flying objects is not simple, but we will cover this topic in a methodical, step-by-step approach, and when we are done, you will be able to populate your creative scenarios with a wide variety of flying, jumping, and launched objects. It's not as simple as Douglas Adams makes it sound in his quote, but nothing worth learning ever is.</p><div class="section" title="Cupcake Counter"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Cupcake Counter</h1></div></div></div><p>It is beneficial to the <a id="id261" class="indexterm"/>learning process to discuss topics in the context of complete scenarios. Doing this forces us to handle issues that might be elided in smaller, one-off examples. In this chapter, we will build a simple platform game called <span class="strong"><strong>Cupcake Counter</strong></span> (shown in <span class="emphasis"><em>Figure 1</em></span>). We will first look at a majority of the code for the <span class="strong"><strong>World </strong></span>and <span class="strong"><strong>Actor</strong></span> classes in this game without showing the code implementing the topic of this chapter, that is, the different forms of projectile-based movement. We will then present and explain the missing code in subsequent sections. This is the same approach we took in the preceding chapter, in order to study collision detection.</p><div class="mediaobject"><img src="../Images/image00287.jpeg" alt="Cupcake Counter"/><div class="caption"><p>Figure 1: This is a screenshot of Cupcake Counter</p></div></div><p style="clear:both; height: 1em;"> </p><div class="section" title="How to play"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>How to play</h2></div></div></div><p>The goal of <span class="strong"><strong>Cupcake Counter</strong></span> <a id="id262" class="indexterm"/>is to collect as many cupcakes as you can before being hit by either a ball or a fountain. The left and right arrow keys move your character left and right and the up arrow key makes your character jump. You can also use the space bar key to jump. After touching a cupcake, it will disappear and reappear randomly on another platform. Balls will be fired from the turret at the top of the screen and fountains will appear periodically. The game will increase in difficulty as your cupcake <a id="id263" class="indexterm"/>count goes up. The game requires good jumping and avoiding skills.</p></div><div class="section" title="Implementing Cupcake Counter"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Implementing Cupcake Counter</h2></div></div></div><p>Create a scenario <a id="id264" class="indexterm"/>called <code class="literal">Cupcake Counter</code> and add each class to it as they are discussed. If you prefer, you can download the initial version of Cupcake <a id="id265" class="indexterm"/>Counter from: <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a></p></div><div class="section" title="The CupcakeWorld class"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>The CupcakeWorld class</h2></div></div></div><p>This subclass <a id="id266" class="indexterm"/>of <code class="literal">World</code> sets up all the actors associated with the scenario, including a score. It is also responsible for generating periodic enemies, generating rewards, and increasing the difficulty of the game over time. The following is the code for this class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;

public class CupcakeWorld extends World {
  private Counter score;
  private Turret turret;
  public int BCOUNT = 200;
  private int ballCounter = BCOUNT;
  public int FCOUNT = 400;
  private int fountainCounter = FCOUNT;
  private int level = 0;
  
  public CupcakeWorld() {
    super(600, 400, 1, false);
    setPaintOrder(Counter.class, Turret.class, Fountain.class,
    Jumper.class, Enemy.class, Reward.class, Platform.class);
    prepare();
  }
  
  public void act() {
    checkLevel();
  }
  
  private void checkLevel() {
    if( level &gt; 1 ) generateBalls();
    if( level &gt; 4 ) generateFountains();
    if( level % 3 == 0 ) {
      FCOUNT--;
      BCOUNT--;
      level++;
    }
  }
  
  private void generateFountains() {
    fountainCounter--;
    if( fountainCounter &lt; 0 ) {
      List&lt;Brick&gt; bricks = getObjects(Brick.class);
      int idx = Greenfoot.getRandomNumber(bricks.size());
      Fountain f = new Fountain();
      int top = f.getImage().getHeight()/2 + bricks.get(idx).getImage().getHeight()/2;
      addObject(f, bricks.get(idx).getX(),
      bricks.get(idx).getY()-top);
      fountainCounter = FCOUNT;
    }
  }
  
  private void generateBalls() {
    ballCounter--;
    if( ballCounter &lt; 0 ) {
      Ball b = new Ball();
      turret.setRotation(15 * -b.getXVelocity());
      addObject(b, getWidth()/2, 0);
      ballCounter = BCOUNT;
    }
  }
  
  public void addCupcakeCount(int num) {
    score.setValue(score.getValue() + num);
    generateNewCupcake();
  }
  
  private void generateNewCupcake() {
    List&lt;Brick&gt; bricks = getObjects(Brick.class);
    int idx = Greenfoot.getRandomNumber(bricks.size());
    Cupcake cake = new Cupcake();
    int top = cake.getImage().getHeight()/2 +
    bricks.get(idx).getImage().getHeight()/2;
    addObject(cake, bricks.get(idx).getX(),
    bricks.get(idx).getY()-top);
  }
  
  public void addObjectNudge(Actor a, int x, int y) {
    int nudge = Greenfoot.getRandomNumber(8) - 4;
    super.addObject(a, x + nudge, y + nudge);
  }
  
  private void prepare(){
    // Add Bob
    Bob bob = new Bob();
    addObject(bob, 43, 340);
    // Add floor
    BrickWall brickwall = new BrickWall();
    addObject(brickwall, 184, 400);
    BrickWall brickwall2 = new BrickWall();
    addObject(brickwall2, 567, 400);
    // Add Score
    score = new Counter();
    addObject(score, 62, 27);
    // Add turret
    turret = new Turret();
    addObject(turret, getWidth()/2, 0);
    // Add cupcake
    Cupcake cupcake = new Cupcake();
    addObject(cupcake, 450, 30);
    // Add platforms
    for(int i=0; i&lt;5; i++) {
      for(int j=0; j&lt;6; j++) {
        int stagger = (i % 2 == 0 ) ? 24 : -24;
        Brick brick = new Brick();
        addObjectNudge(brick, stagger + (j+1)*85, (i+1)*62);
      }
    }
  }
}</pre></div><p>Let's discuss the methods in this class in order. First, we have the class constructor <code class="literal">CupcakeWorld()</code>. After calling the constructor of the superclass, it calls <code class="literal">setPaintOrder()</code> to set the actors that will appear in front of other actors when displayed on the screen. You were introduced to <code class="literal">setPaintOrder()</code> in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>. The main <a id="id267" class="indexterm"/>reason why we use it here, is so that no actor will cover up the <code class="literal">Counter</code> class, which is used to display the score. Next, the constructor method calls <code class="literal">prepare()</code> to add and place the initial actors into the scenario. We will discuss the <code class="literal">prepare()</code> method later in this section.</p><p>Inside the <code class="literal">act()</code> method, we will only call the function <code class="literal">checkLevel()</code>. As the player scores points in the game, the <code class="literal">level</code> variable of the game will also increase. The <code class="literal">checkLevel()</code> function will change the game a bit according to its <code class="literal">level</code> variable. When our game first starts, no enemies are generated and the player can easily get the cupcake (the reward). This gives the player a chance to get accustomed to jumping on platforms. As the cupcake count goes up, balls and fountains will be added. As the level continues to rise, <code class="literal">checkLevel()</code> reduces the delay between creating balls (<code class="literal">BCOUNT</code>) and fountains (<code class="literal">FCOUNT</code>). The <code class="literal">level</code> variable of the game is increased in the <code class="literal">addCupcakeCount()</code> method, which we will discuss in detail soon.</p><p>The <code class="literal">generateFountains()</code> method adds a <code class="literal">Fountain</code> actor to the scenario. The rate at which we create fountains is controlled by the delay variable (refer to, <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span> to review) <code class="literal">fountainContainer</code>. After the delay, we create a fountain on a randomly chosen <code class="literal">Brick</code> (the platforms in our game). The <code class="literal">getObjects()</code> method returns all of the actors of a <a id="id268" class="indexterm"/>given class presently in the scenario. We then use <code class="literal">getRandomNumber()</code> to randomly choose a number between one and the number of <code class="literal">Brick</code> actors. Next, we use <code class="literal">addObject()</code> to place the new <code class="literal">Fountain</code> object on the randomly chosen <code class="literal">Brick</code> object.</p><p>Generating balls using the <code class="literal">generateBalls()</code> method is a little easier than generating fountains. All balls are created in the same location as the <code class="literal">turret</code> at the top of the screen and sent from there with a randomly chosen trajectory. The rate at which we generate new <code class="literal">Ball</code> actors is defined by the delay variable <code class="literal">ballCounter</code>. Once we create a <code class="literal">Ball</code> actor, we rotate the <code class="literal">turret</code> based on its <span class="emphasis"><em>x</em></span> velocity. By doing this, we create the illusion that the turret is aiming and then firing <code class="literal">Ball Actor</code>. Last, we place the newly created <code class="literal">Ball</code> actor into the scenario using the <code class="literal">addObject()</code> method.</p><p>The <code class="literal">addCupcakeCount()</code> method is called by the actor representing the player (<code class="literal">Bob</code>) every time the player collides with <code class="literal">Cupcake</code>. In this method, we increase <code class="literal">score</code> and then call <code class="literal">generateNewCupcake()</code> to add a new <code class="literal">Cupcake</code> actor to the scenario. The <code class="literal">generateNewCupcake()</code> method is very similar to <code class="literal">generateFountains()</code>, except for the lack of a delay variable, and it randomly places <code class="literal">Cupcake</code> on one of the bricks instead of a <code class="literal">Fountain</code> actor. In <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>, we demonstrated how to create a game score using the <code class="literal">Counter</code> class, a class you can import into your scenario. Please refer to that chapter for more details.</p><p>In all of our previous scenarios, we used a <code class="literal">prepare()</code> method to add actors to the scenario. The major difference between this <code class="literal">prepare()</code> method and the previous ones, is that we use the <code class="literal">addObjectNudge()</code> method instead of <code class="literal">addObject()</code> to place our platforms. The <code class="literal">addObjectNudge()</code> method simply adds a little randomness to the placement of the platforms, so that every new game is a little different. The random variation in the platforms will cause the <code class="literal">Ball</code> actors to have different bounce patterns and require the player to jump and move a bit more carefully. In the call to <code class="literal">addObjectNudge()</code>, you will notice that we used the numbers <code class="literal">85</code> and <code class="literal">62</code>. These are simply numbers that spread the platforms out appropriately, and they were discovered through trial and error.</p><p>I created a blue gradient background to use for the image of <code class="literal">CupcakeWorld</code>. Feel free to use this from the <a id="id269" class="indexterm"/>sample code you can download, create your own background image, or use one of the background images provided that come with Greenfoot.</p></div><div class="section" title="Enemies"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Enemies</h2></div></div></div><p>In Cupcake Counter, all of <a id="id270" class="indexterm"/>the actors that can end the game if collided with are subclasses of the <code class="literal">Enemy</code> class. Using inheritance is a great way to share code and reduce redundancy for a group of similar actors. However, we often will create class hierarchies in Greenfoot solely for <span class="emphasis"><em>polymorphism</em></span>. Polymorphism refers to the ability of a class in an object-orientated language to <span class="emphasis"><em>take on many forms</em></span>. We are going to use it, so that our player actor only has to check for collision with an <code class="literal">Enemy</code> class and not every specific type of <code class="literal">Enemy</code>, such as <code class="literal">Ball</code> or <code class="literal">RedBall</code>. Also, by coding this way, we are making it very easy to add code for additional enemies, and if we find that our enemies have redundant code, we can easily move that code into our <code class="literal">Enemy</code> class. In other words, we are making our code extensible and maintainable.</p><p>Here is the code for our <code class="literal">Enemy</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public abstract class Enemy extends Actor {
}</pre></div><p>The <code class="literal">Ball</code> class extends the <code class="literal">Enemy</code> class. Since <code class="literal">Enemy</code> is solely used for polymorphism, the <code class="literal">Ball</code> class contains all of the code necessary to implement bouncing and an initial trajectory. Here is the code for this class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Ball extends Enemy {
  protected int actorHeight;
  private int speedX = 0;
  
  public Ball() {
    actorHeight = getImage().getHeight();
    speedX = Greenfoot.getRandomNumber(8) - 4;
    if( speedX == 0 ) {
      speedX = Greenfoot.getRandomNumber(100) &lt; 50 ? -1 : 1;
    }
  }
  
  public void act() {
    checkOffScreen();
  }
  
  public int getXVelocity() {
    return speedX;
  }
  
  private void checkOffScreen() {
    if( getX() &lt; -20 || getX() &gt; getWorld().getWidth() + 20 ) {
      getWorld().removeObject(this);
    } else if( getY() &gt; getWorld().getHeight() + 20 ) {
      getWorld().removeObject(this);
    }
  }
}</pre></div><p>The implementation of <code class="literal">Ball</code> is missing the code to handle moving and bouncing. As we stated earlier, we will go over all the projectile-based code after providing the code we are using as the starting point for this game. In the <code class="literal">Ball</code> constructor, we randomly choose a speed in the <span class="emphasis"><em>x</em></span> direction and save it in the <code class="literal">speedX</code> instance variable. We have included one accessory method to return the value of <code class="literal">speedX</code> (<code class="literal">getXVelocity()</code>). Last, we include <code class="literal">checkOffScreen()</code> to remove <code class="literal">Ball</code> once it goes off screen. If we do not do this, we would have a form of memory leak in our application because Greenfoot will continue to allocate resources and manage any actor until it is removed from the scenario. For the <code class="literal">Ball</code> class, I <a id="id271" class="indexterm"/>choose to use the <code class="literal">ball.png</code> image, which comes with the standard installation of Greenfoot.</p><p>In this chapter, we will learn how to create a simple particle effect. Creating an effect is more about the use of a particle as opposed to its implementation. In the following code, we create a generic particle class, <code class="literal">Particles</code>, that we will extend to create a <code class="literal">RedBall</code> particle. We have organized the code in this way to easily accommodate adding particles in the future. Here is the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Particles extends Enemy {
  private int turnRate = 2;
  private int speed = 5;
  private int lifeSpan = 50;
  
  public Particles(int tr, int s, int l) {
    turnRate = tr;
    speed = s;
    lifeSpan = l;
    setRotation(-90);
  }
  
  public void act() {
    move();
    remove();
  }
  
  private void move() {
    move(speed);
    turn(turnRate);
  }
  
  private void remove() {
    lifeSpan--;
    if( lifeSpan &lt; 0 ) {
      getWorld().removeObject(this);
    }
  }
}</pre></div><p>Our particles are implemented to move up and slightly turn each call of the <code class="literal">act()</code> method. A particle will move <code class="literal">lifeSpan</code> times and then remove itself. As you might have guessed, <code class="literal">lifeSpan</code> is another use of a delay variable. The <code class="literal">turnRate</code> property can be either positive (to turn slightly right) or negative (to turn slightly left).</p><p>We only have one <a id="id272" class="indexterm"/>subclass of <code class="literal">Particles</code>, <code class="literal">RedBall</code>. This class supplies the correct image for <code class="literal">RedBall</code>, supplies the required input for the <code class="literal">Particles</code> constructor, and then scales the image according to the parameters <code class="literal">scaleX</code> and <code class="literal">scaleY</code>. Here's the implementation:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class RedBall extends Particles {
  public RedBall(int tr, int s, int l, int scaleX, int scaleY) {
    super(tr, s, l);
    getImage().scale(scaleX, scaleY);
  }
}</pre></div><p>For <code class="literal">RedBall</code>, I used the Greenfoot-supplied image <code class="literal">red-draught.png</code>.</p></div><div class="section" title="Fountains"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Fountains</h2></div></div></div><p>In this game, fountains <a id="id273" class="indexterm"/>add a unique challenge. After reaching level five (see the <code class="literal">World</code> class <code class="literal">CupcakeWorld</code>), <code class="literal">Fountain</code> objects will be generated and randomly placed in the game. <span class="emphasis"><em>Figure 2</em></span> shows a fountain in action. A <code class="literal">Fountain</code> object continually spurts <code class="literal">RedBall</code> objects into the air like water from a fountain.</p><div class="mediaobject"><img src="../Images/image00288.jpeg" alt="Fountains"/><div class="caption"><p>Figure 2: This is a close-up of a Fountain object in the game Cupcake Counter</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's take a look at the <a id="id274" class="indexterm"/>code that implements the <code class="literal">Fountain</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;

public class Fountain extends Actor {
  private int lifespan = 75;
  private int startDelay = 100;
  private GreenfootImage img;
  
  public Fountain() {
    img = new GreenfootImage(20,20);
    img.setColor(Color.blue);
    img.setTransparency(100);
    img.fill();
    setImage(img);
  }
  
  public void act() {
    if( --startDelay == 0 ) wipeView();
    if( startDelay &lt; 0 ) createRedBallShower();
  }
  
  private void wipeView() {
    img.clear();
  }
  
  private void createRedBallShower() {
  }
}</pre></div><p>The constructor for <code class="literal">Fountain</code> creates a new blue, semitransparent square and sets that to be its image. We start with a blue square to give the player of the game a warning that a fountain is about to erupt. Since fountains are randomly placed at any location, it would be unfair to just drop one on our player and instantly end the game. This is also why <code class="literal">RedBall</code> is a subclass of <code class="literal">Enemy</code> and <code class="literal">Fountain</code> is not. It is safe for the player to touch the blue square. The <code class="literal">startDelay</code> delay variable is used to pause for a short amount of time, then remove the blue <a id="id275" class="indexterm"/>square (using the function <code class="literal">wipeView()</code>), and then start the <code class="literal">RedBall</code> shower (using the <code class="literal">createRedBallShower()</code> function). We can see this in the <code class="literal">act()</code> method. The implementation for <code class="literal">createRedBallShower()</code> is given and explained in the <span class="emphasis"><em>Particle effects</em></span> section to come ahead in the chapter.</p></div><div class="section" title="Turrets"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Turrets</h2></div></div></div><p>In the game, there is a <a id="id276" class="indexterm"/>turret in the top-middle of the screen that shoots purple bouncy balls at the player. It is shown in <span class="emphasis"><em>Figure 1</em></span>. Why do we use a bouncy-ball shooting turret? <span class="emphasis"><em>Because this is our game and we can!</em></span> The implementation of the <code class="literal">Turret</code> class is very simple. Most of the functionality of rotating the turret and creating <code class="literal">Ball</code> to shoot is handled by <code class="literal">CupcakeWorld</code> in the <code class="literal">generateBalls()</code> method already discussed. The main purpose of this class is to just draw the initial image of the turret, which consists of a black circle for the base of the turret and a black rectangle to serve as the cannon. Here is the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;

public class Turret extends Actor {
  private GreenfootImage turret;
  private GreenfootImage gun;
  private GreenfootImage img;
  
  public Turret() {
    turret = new GreenfootImage(30,30);
    turret.setColor(Color.black);
    turret.fillOval(0,0,30,30);
    
    gun = new GreenfootImage(40,40);
    gun.setColor(Color.black);
    gun.fillRect(0,0,10,35);
    
    img = new GreenfootImage(60,60);
    img.drawImage(turret, 15, 15);
    img.drawImage(gun, 25, 30);
    img.rotate(0);
    
    setImage(img);
  }
}</pre></div><p>We previously talked about the <code class="literal">GreenfootImage</code> class and how to use some of its methods to do custom drawing. One new function we introduced is <code class="literal">drawImage()</code>. This method allows you to draw one <code class="literal">GreenfootImage</code> into another. This is how you compose images, and we used it to create our turret from a rectangle image and a circle image.</p></div><div class="section" title="Rewards"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Rewards</h2></div></div></div><p>We create a <code class="literal">Reward</code> class for <a id="id277" class="indexterm"/>the same reason we created an <code class="literal">Enemy</code> class. We are setting ourselves up to easily add new rewards in the future. (later in the chapter, we will assign this as an exercise). Here is the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 

public abstract class Reward extends Actor {
}</pre></div><p>The <code class="literal">Cupcake</code> class is a subclass of the <code class="literal">Reward</code> class and represents the object on the screen the player is constantly trying to collect. However, cupcakes have no actions to perform or state to keep track of; therefore, its implementation is simple:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Cupcake extends Reward {
}</pre></div><p>When creating this class, I set its image to be <code class="literal">muffin.png</code>. This is an image that comes with Greenfoot. Even though the name of the image is a muffin, it still looks like a cupcake to me.</p></div><div class="section" title="Jumpers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Jumpers</h2></div></div></div><p>The <code class="literal">Jumper</code> class is a class <a id="id278" class="indexterm"/>that will allow all subclasses of it to jump when pressing either the up arrow key or the spacebar. Most of the body of this class will be implemented in the <span class="emphasis"><em>Gravity and jumping</em></span> section to come ahead in the chapter. At this point, we just provide a placeholder implementation:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public abstract class Jumper extends Actor
{
  protected int actorHeight;
  
  public Jumper() {
    actorHeight = getImage().getHeight();
  }
  
  public void act() {
    handleKeyPresses();
  }
  
  protected void handleKeyPresses() {
  }
}</pre></div><p>The next class we are going to present is the <code class="literal">Bob</code> class. The <code class="literal">Bob</code> class extends the <code class="literal">Jumper</code> class and then adds functionality to let the player move it left and right. It also uses animation techniques <a id="id279" class="indexterm"/>discussed in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span> to make it look as though it is actually walking. Here is the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Bob extends Jumper {
  private int speed = 3;
  private int animationDelay = 0;
  private int frame = 0;
  private GreenfootImage[] leftImages;
  private GreenfootImage[] rightImages;
  private int actorWidth;
  
  private static final int DELAY = 3;
  
  public Bob() {
    super();
    
    rightImages = new GreenfootImage[5];
    leftImages = new GreenfootImage[5];
    
    for( int i=0; i&lt;5; i++ ) {
      rightImages[i] = new GreenfootImage("images/Dawson_Sprite_Sheet_0" + Integer.toString(3+i) + ".png");
      leftImages[i] = new GreenfootImage(rightImages[i]);
      leftImages[i].mirrorHorizontally();
    }
    
    actorWidth = getImage().getWidth();
  }
  
  public void act() {
    super.act();
    checkDead();
    eatReward();
  }
  
  private void checkDead() {
    Actor enemy = getOneIntersectingObject(Enemy.class);
    if( enemy != null ) {
      endGame();
    }
  }
  
  private void endGame() {
    Greenfoot.stop();
  }
  
  private void eatReward() {
    Cupcake c = (Cupcake) getOneIntersectingObject(Cupcake.class);
    if( c != null ) {
      CupcakeWorld rw = (CupcakeWorld) getWorld();
      rw.removeObject(c);
      rw.addCupcakeCount(1);
    }
  }
  
  // Called by superclass
  protected void handleKeyPresses() {
    super.handleKeyPresses();
    
    if( Greenfoot.isKeyDown("left") ) {
      if( canMoveLeft() ) {moveLeft();}
    }
    if( Greenfoot.isKeyDown("right") ) {
      if( canMoveRight() ) {moveRight();}
    }
  }
  
  private boolean canMoveLeft() {
    if( getX() &lt; 5 ) return false;
    return true;
  }
  
  private void moveLeft() {
    setLocation(getX() - speed, getY());
    if( animationDelay % DELAY == 0 ) {
      animateLeft();
      animationDelay = 0;
    }
    animationDelay++;
  }
  
  private void animateLeft() {
    setImage( leftImages[frame++]);
    frame = frame % 5;
    actorWidth = getImage().getWidth();
  }
  
  private boolean canMoveRight() {
    if( getX() &gt; getWorld().getWidth() - 5) return false;
    return true;
  }
  
  private void moveRight() {
    setLocation(getX() + speed, getY());
    if( animationDelay % DELAY == 0 ) {
      animateRight();
      animationDelay = 0;
    }
    animationDelay++;
  }
  
  private void animateRight() {
    setImage( rightImages[frame++]);
    frame = frame % 5;
    actorWidth = getImage().getWidth();
  }
}</pre></div><p>Like <code class="literal">CupcakeWorld</code>, this class is substantial. We will discuss each method it contains sequentially. First, the constructor's main duty is to set up the images for the walking animation. This type of <a id="id280" class="indexterm"/>animation was discussed in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span> in the <span class="emphasis"><em>Hurting the avatar</em></span> section and again in <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span> in the <span class="emphasis"><em>Detecting a collision with multiple objects</em></span> section. The images came from <a class="ulink" href="http://www.wikia.com">www.wikia.com</a> and were supplied, in the form of a sprite sheet, by the user Mecha Mario. A direct link to the sprite sheet is <a class="ulink" href="http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG">http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG</a>. Note that I manually copied and pasted the images I used from this sprite sheet using my favorite image editor.</p><div class="note" title="Note"><h3 class="title"><a id="note18"/>Note</h3><p><span class="strong"><strong>Free Internet resources</strong></span></p><p>Unless you are also an artist or a musician in addition to being a programmer, you are going to be hard pressed to create all of the assets you need for your Greenfoot scenario. If you look at the credits for AAA video games, you will see that the number of artists and musicians actually equal or even outnumber the programmers.</p><p>Luckily, the Internet comes to the rescue. There are a number of websites that supply legally free assets you can use. For example, the website I used to get the images for the <code class="literal">Bob</code> class supplies free content under the Creative Commons Attribution-Share Alike License 3.0 (Unported) (CC-BY-SA) license. It is very important that you check the licensing used for any asset you download off the Internet and follow those user agreements carefully. In addition, make sure that you fully credit the source of your assets. For games, you should include a <span class="emphasis"><em>Credits</em></span> screen to cite all the sources for the assets you used.</p><p>The following are some good sites for free, online assets:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><a class="ulink" href="http://www.wikia.com">www.wikia.com</a></li><li class="listitem"><a class="ulink" href="http://newgrounds.com">newgrounds.com</a></li><li class="listitem"><a class="ulink" href="http://incompetech.com">http://incompetech.com</a></li><li class="listitem"><a class="ulink" href="http://opengameart.org">opengameart.org</a></li><li class="listitem"><a class="ulink" href="http://untamed.wild-refuge.net/rpgxp.php">untamed.wild-refuge.net/rpgxp.php</a></li></ul></div></div><p>Next, we have the <code class="literal">act()</code> method. It first calls the <code class="literal">act()</code> method of its superclass. It needs to do this so that we get the jumping functionality that is supplied by the <code class="literal">Jumper</code> class. Then, we call <code class="literal">checkDead()</code> and <code class="literal">eatReward()</code>. The <code class="literal">checkDead()</code>method ends the game if this instance of the <code class="literal">Bob</code> class touches an enemy, and <code class="literal">eatReward()</code> adds one to our score, by calling the <code class="literal">CupcakeWorld</code> method <code class="literal">addCupcakeCount()</code>, every time it touches an instance of the <code class="literal">Cupcake</code> class.</p><p>The rest of the class <a id="id281" class="indexterm"/>implements moving left and right. The main method for this is <code class="literal">handleKeyPresses()</code>. Like in <code class="literal">act()</code>, the first thing we do, is call <code class="literal">handleKeyPresses()</code> contained in the <code class="literal">Jumper</code> superclass. This runs the code in <code class="literal">Jumper</code> that handles the spacebar and up arrow key presses. The key to handling key presses is the Greenfoot method <code class="literal">isKeyDown()</code> (see the following information box). We use this method to check if the left arrow or right arrow keys are presently being pressed. If so, we check whether or not the actor can move left or right using the methods <code class="literal">canMoveLeft()</code> and <code class="literal">canMoveRight()</code>, respectively. If the actor can move, we then call either <code class="literal">moveLeft()</code> or <code class="literal">moveRight()</code>.</p><div class="note" title="Note"><h3 class="title"><a id="note19"/>Note</h3><p><span class="strong"><strong>Handling key presses in Greenfoot</strong></span></p><p>In the preface of the book, we explained that we assumed that you have some experience with Greenfoot and have, minimally, completed the tutorials located on the page: <a class="ulink" href="http://www.greenfoot.org/doc">http://www.greenfoot.org/doc</a></p><p>The second tutorial explains how to control actors with the keyboard. To refresh your memory, we are going to present some information on the keyboard control here.</p><p>The primary method we use in implementing keyboard control is <code class="literal">isKeyDown()</code>. This method provides a simple way to check whether a certain key is being pressed. Here is an excerpt from Greenfoot's documentation:</p><div class="informalexample"><pre class="programlisting">public static boolean isKeyDown(java.lang.String keyName)
Check whether a given key is currently pressed down.

Parameters:
keyName:This is the name of the key to check.

This returns : true if the key is down.

Using isKeyDown() is easy. The ease of capturing and using input is one of the major strengths of Greenfoot. Here is example code that will pause the execution of the game if the "p" key is pressed:

if( Greenfoot.isKeyDown("p") {
  Greenfoot.stop();
}</pre></div></div><p>Next, we will discuss <code class="literal">canMoveLeft()</code>, <code class="literal">moveLeft()</code>, and <code class="literal">animateLeft()</code>. The <code class="literal">canMoveRight()</code>, <code class="literal">moveRight()</code>, and <code class="literal">animateRight()</code>methods mirror their functionality and will <a id="id282" class="indexterm"/>not be discussed. The sole purpose of <code class="literal">canMoveLeft()</code> is to prevent the actor from walking off the left-hand side of the screen. The <code class="literal">moveLeft()</code> method moves the actor using <code class="literal">setLocation()</code> and then animates the actor to look as though it is moving to the left-hand side. It uses a delay variable to make the walking speed look natural (not too fast). The <code class="literal">animateLeft()</code> method sequentially displays the walking-left images. This is the same animation strategy we saw in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>.</p></div><div class="section" title="Platforms"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Platforms</h2></div></div></div><p>The game contains <a id="id283" class="indexterm"/>several platforms that the player can jump or stand on. The platforms perform no actions and only serve as placeholders for images. We use inheritance to simplify collision detection. Here is the implementation of <code class="literal">Platform</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 

public class Platform extends Actor {
}</pre></div><p>Here's the implementation of <code class="literal">BrickWall</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 

public class BrickWall extends Platform {
}</pre></div><p>Here's the implementation of <code class="literal">Brick</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 

public class Brick extends Platform {
}</pre></div></div><div class="section" title="Test it out"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Test it out</h2></div></div></div><p>You should now be able to <a id="id284" class="indexterm"/>compile and test Cupcake Counter. Make sure you handle any typos or other errors you introduced while inputting the code. For now, you can only move left and right. Check out <code class="literal">Bob</code> walking. <span class="emphasis"><em>Pretty cool!</em></span> Everything else depends on some of the code we left out of the preceding implementations. We will fill out that missing code next. Let's launch some actors.</p></div><div class="section" title="Your assignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Your assignment</h2></div></div></div><p>Consider one of the <a id="id285" class="indexterm"/>locations we left out of the previous code. Try to supply the code yourself. How would you start? My suggestion would be to start with pencil and paper. Draw some figures and imagine the steps that you would need to perform to implement the functionality. Translate these steps to Java code and try them out. Doing this will help you better understand and process the upcoming solutions, even if your solution was incorrect.</p></div></div></div>
<div class="section" title="Launching actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Launching actors</h1></div></div></div><p>We are going to <a id="id286" class="indexterm"/>take the preceding incomplete implementation and turn it into a game by adding jumping, bouncing, a particle effect, and bullets fired from a turret.</p><div class="section" title="Gravity and jumping"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Gravity and jumping</h2></div></div></div><p>Presently, our player <a id="id287" class="indexterm"/>character is stuck at the bottom of the screen. We are going to fill in the missing code in the <code class="literal">Jumper</code> class and the <code class="literal">Bob</code> class to enable our character to jump and finally have a way to reach the cupcake reward at the top of the screen. Jumping is <a id="id288" class="indexterm"/>applying a force to move an object upwards. We are also going to need a downwards force operating on the object, in order for it to fall back down. As in real life, we are going to call this force <span class="emphasis"><em>gravity</em></span>. The changes to the <code class="literal">Jumper</code> class are so extensive that we are going to first look at the complete implementation and then discuss it afterwards. Here's the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public abstract class Jumper extends Actor
{
  protected int actorHeight;
  private int fallSpeed = 0;
  private boolean jumping = false;
  
  // Class Constants
  protected static final int GRAVITY = 1;
  protected static final int JUMPSTRENGTH = 12;
  
  public Jumper() {
    actorHeight = getImage().getHeight();
  }
  
  public void act() {
    handleKeyPresses();
    standOrFall();
  }
  
  protected void handleKeyPresses() {
    if( (Greenfoot.isKeyDown("space") ||
    Greenfoot.isKeyDown("up")) &amp;&amp; !jumping) {
      jump();
    }
  }
  
  private void jump() {
    fallSpeed = -JUMPSTRENGTH;
    jumping = true;
    fall();
  }
  
  private void standOrFall() {
    if( inAir() ) {
      checkHead();
      fall();
      checkLanding();
    } else {
      fallSpeed = 0;
      jumping = false;
    }
  }
  
  private void checkHead() {
    int actorHead = -actorHeight/2;
    int step = 0;
    while( fallSpeed &lt; 0 &amp;&amp; step &gt; fallSpeed
    &amp;&amp; getOneObjectAtOffset(0, actorHead + step,
    Platform.class) == null ) {
      step--;
    }
    if( fallSpeed &lt; 0 ) {
      fallSpeed = step;
    }
  }
  
  private void checkLanding() {
    int actorFeet = actorHeight/2;
    int step = 0;
    while( fallSpeed &gt; 0 &amp;&amp; step &lt; fallSpeed
    &amp;&amp; getOneObjectAtOffset(0, actorFeet + step,
    Platform.class) == null ) {
      step++;
    }
    if( fallSpeed &gt; 0 ) {
      fallSpeed = step;
    }
  }
  
  private boolean inAir() {
    Actor platform = getOneObjectAtOffset(0,
    getImage().getHeight()/2, Platform.class);
    return platform == null;
  }
  
  private void fall() {
    setLocation(getX(), getY() + fallSpeed);
    fallSpeed = fallSpeed + GRAVITY;
  }
}</pre></div><p>Please note that we have added two new instance variables (<code class="literal">fallSpeed</code> and <code class="literal">jumping</code>) and two static constants (<code class="literal">GRAVITY</code> and <code class="literal">JUMPSTRENGTH</code>). These new variables will be used throughout our code. In our <code class="literal">act()</code> method, we added the <code class="literal">standOrFall()</code> method. This method is <a id="id289" class="indexterm"/>responsible for applying gravity and detecting collisions (both for the head and feet of the actor). Before looking at that method further, let's <a id="id290" class="indexterm"/>look at the completed implementation of <code class="literal">handleKeyPresses()</code>. In this method, we detect whether the space bar or up arrow key was pressed and call <code class="literal">jump()</code> if it was. You will notice that the <code class="literal">if</code> statement also contains a check to see whether the <code class="literal">Boolean</code> variable <code class="literal">jumping</code> is <code class="literal">false</code>. We need this check to prevent double jumping (jumping again while in the middle of a jump). The <code class="literal">jump()</code> method changes <code class="literal">fallSpeed</code> to a negative value. This applies a force in the up direction on the actor. We set <code class="literal">jumping</code> to <code class="literal">true</code> (as we are now in a jumping state) and then call <code class="literal">fall()</code>. The <code class="literal">fall()</code> method applies gravity to an actor. In this method, we can see how a negative value of <code class="literal">fallSpeed</code> will propel the actor upwards.</p><p>The value of <code class="literal">fallSpeed</code> has <code class="literal">GRAVITY</code> added to it until it becomes positive. This will create a parabola-like motion, as shown in <span class="emphasis"><em>Figure 3</em></span>.</p><div class="mediaobject"><img src="../Images/image00289.jpeg" alt="Gravity and jumping"/><div class="caption"><p>Figure 3: This is the implementation of falling</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's look at the implementation of <code class="literal">standOrFall()</code>. The first thing we need to check is whether or not we are presently standing on a <code class="literal">Platform</code> object. We use the method <code class="literal">inAir()</code> to do this check. This method uses <code class="literal">getOneObjectAtOffset()</code> (see <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>) to check whether the bottom of the actor is touching a <code class="literal">Platform</code> object and returns <code class="literal">false</code> if it is. In <code class="literal">standOrFall()</code>, we do three things if we have determined that we are in the air. We check to see whether the top or bottom of the actor is colliding with <code class="literal">Platform</code> and call the <code class="literal">fall()</code> method if it is. The methods <code class="literal">checkHead()</code> and <code class="literal">checkLanding()</code> are similar. They are both used in border-based collision detection, as <a id="id291" class="indexterm"/>discussed in <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>, to <a id="id292" class="indexterm"/>detect at exactly which pixel location the collision occurred. They then change the value of <code class="literal">fallSpeed,</code> so that the actor stops at the point of collision. If we detect that we are not in the air in <code class="literal">standOrFall()</code>, then we are standing on a platform and can set <code class="literal">fallSpeed</code> to <code class="literal">0</code> (not falling) and <code class="literal">jumping</code> to <code class="literal">false</code> (not jumping).</p></div><div class="section" title="Bouncing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Bouncing</h2></div></div></div><p>Bouncing actors look great <a id="id293" class="indexterm"/>and really add a nice dimension to any game. In the mind of the player, they propel your game from a flat arrangement of pixels to a <a id="id294" class="indexterm"/>rich world in which objects obey the natural laws of physics. In Cupcake Counter, the balls shot from the turret bounce. Bouncing is implemented in the <code class="literal">Ball</code> class. First, add the following instance variables to your existing <code class="literal">Ball</code> class:</p><div class="informalexample"><pre class="programlisting">private int fallSpeed = 0;
protected static final int GRAVITY = 1; </pre></div><p>Next, we need to add code to the <code class="literal">act()</code> method that will cause an instance of the class to fall or bounce if it hits an object. Change your <code class="literal">act()</code> method to the following:</p><div class="informalexample"><pre class="programlisting">public void act() {
  fallOrBounce();
  checkOffScreen();
}</pre></div><p>The <code class="literal">fallOrBounce()</code> method is going to be complex, but we are going to use functional decomposition (break it up into smaller methods) to manage the complexity and make our code more readable. Here is its implementation:</p><div class="informalexample"><pre class="programlisting">private void fallOrBounce() {
  if( fallSpeed &lt;= 0) {
    checkHead();
  } else {
    checkLanding();
  }
}</pre></div><p>We have reduced the implementation of <code class="literal">fallOrBounce()</code> to checking whether we are about to hit our head or checking whether we are about to land on a platform. We choose between the two checks based on the value of <code class="literal">fallSpeed</code>. If <code class="literal">fallSpeed</code> is negative, then we are moving upwards and there is no need to check for landing at this point. Here is the implementation of <code class="literal">checkHead()</code>:</p><div class="informalexample"><pre class="programlisting">private void fallOrBounce() {
  if( fallSpeed &lt;= 0) {
    checkHead();
  } else {
    checkLanding();
  }
}
private void checkHead() {
  int actorHead = -actorHeight/2;
  int step = 0;
  int oldFallSpeed;
  while( fallSpeed &lt; 0 &amp;&amp; step &gt; fallSpeed &amp;&amp;
  getOneObjectAtOffset( 0, actorHead + step,
  Platform.class) == null ) {
    step--;
  }
  if( step &gt; fallSpeed ) {
    if( fallSpeed &lt; 0 ) {
      handleBounce(step);
    }
  } else {
    fall(speedX);
  }
}</pre></div><p>The <code class="literal">checkHead()</code> method uses border-based collision detection (discussed in <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>) to detect exactly when the top of the object touches a platform. If <code class="literal">step</code> ends up being greater than <code class="literal">fallSpeed</code>, then no collision occurred and we can continue letting gravity affect our trajectory by calling <code class="literal">fall()</code>. If <code class="literal">step</code> is less than <code class="literal">fallSpeed</code>, then we <a id="id295" class="indexterm"/>hit our head on a platform and we need to handle <a id="id296" class="indexterm"/>bouncing off this platform by calling <code class="literal">handleBounce()</code>. Here is the implementation of <code class="literal">handleBounce()</code>.</p><div class="informalexample"><pre class="programlisting">private void handleBounce(int step) {
  int oldFallSpeed = fallSpeed;
  fallSpeed = step; 
  fall(0);
  oldFallSpeed = (int)(oldFallSpeed * 0.7);
  fallSpeed = step - oldFallSpeed;
  fall(0);
  fallSpeed = -oldFallSpeed;
}</pre></div><p>This method handles a bounce by breaking it up into two main phases. The first phase handles the motion between the actor and the platform. The second phase handles travelling from the platform to the end location. The phases are shown in <span class="emphasis"><em>Figure 4</em></span>.</p><div class="mediaobject"><img src="../Images/image00290.jpeg" alt="Bouncing"/><div class="caption"><p>Figure 4: This shows the two main phases in handling a bounce. Phase 1 is the motion leading up to the impact and Phase 2 is the motion after impact</p></div></div><p style="clear:both; height: 1em;"> </p><p>In the first phase, we move the ball to the point of collision by setting <code class="literal">fallSpeed</code> to <code class="literal">step</code> and calling <code class="literal">fall(0)</code>. We will look at the implementation of <code class="literal">fall()</code> soon. For now, it is enough to know that <code class="literal">fall(0)</code> calls <code class="literal">setLocation()</code> to move the ball and updates <code class="literal">fallSpeed</code> by applying the affects of gravity. In the second phase of <code class="literal">handleBounce()</code>, we multiply by <code class="literal">0.7</code> in order to simulate the loss of energy that occurs in an impact. There is <a id="id297" class="indexterm"/>nothing magical or scientific about <code class="literal">0.7</code>. It just looked right when tested. We then move the remaining distance of our inertia (<code class="literal">step</code> – <code class="literal">oldFallSpeed</code>) by calling <code class="literal">fall(0)</code> again. The bounce has changed our falling direction, so the <a id="id298" class="indexterm"/>last thing we do is update <code class="literal">fallSpeed</code> to reflect this change.</p><p>Since we just used the <code class="literal">fall()</code> method, let us look at that next:</p><div class="informalexample"><pre class="programlisting">private void fall(int dx) {
  setLocation(getX() + dx, getY() + fallSpeed);
  fallSpeed = fallSpeed + GRAVITY;
}</pre></div><p>As mentioned earlier, <code class="literal">fall()</code> moves the actor using <code class="literal">setLocation()</code> according to its speed in the <span class="emphasis"><em>x</em></span> direction and how fast it is falling. The instance variable <code class="literal">fallSpeed</code> is updated to account for the slowing (or accelerating) effects of gravity.</p><p>The only method left to complete the implementation of the <code class="literal">Ball</code> class is <code class="literal">checkLanding()</code>. Here it is:</p><div class="informalexample"><pre class="programlisting">private void checkLanding() {
  int actorFeet = actorHeight/2;
  int step = 0;
  int oldFallSpeed;
  while( fallSpeed &gt; 0 &amp;&amp; step &lt; fallSpeed &amp;&amp;
  getOneObjectAtOffset(0, actorFeet + step,
  Platform.class) == null ) {
    step++;
  }
  if( step &lt; fallSpeed ) {
    if( fallSpeed &gt; 0 ) {
      handleBounce(step);
    }
  } else {
    fall(speedX);
  }
}</pre></div><p>The implementation of <code class="literal">checkLanding()</code> exactly mirrors the implementation of <code class="literal">checkHead()</code> except that it handles moving downwards instead of moving upwards.</p><p>Bouncing is a great effect and <a id="id299" class="indexterm"/>can be applied to a wide variety of actors. You could combine the implementation of bouncing with the implementation of <a id="id300" class="indexterm"/>jumping we discussed in the previous section and make a bouncing, jumping hero for your game.</p></div><div class="section" title="Particle effects"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Particle effects</h2></div></div></div><p>Particle effects work by <a id="id301" class="indexterm"/>creating a bunch of small actors to make an animation. Previously, you learned to do animations mainly by rapid image swapping. You <a id="id302" class="indexterm"/>could imagine creating a water fountain by creating 4-6 images of a fountain shooting upwards and switching between those images. Instead of doing that, we will create a fountain using a particle effect. Conveniently, you already have all the information you need to create particle effects. Particles are simply small actors that you assign a pattern of motion to. You then create a lot of them to provide the desired effect. We will do this to complete our implementation of the <code class="literal">Fountain</code> class. The only part of the implementation we left out was the code for the <code class="literal">createRedBallShower()</code> method. Here is that missing code:</p><div class="informalexample"><pre class="programlisting">private void createRedBallShower() {
  lifespan--;
  if( lifespan &lt; 0) {
    getWorld().removeObject(this);
  } else {
    int tr = Greenfoot.getRandomNumber(30) - 15;
    int s = Greenfoot.getRandomNumber(4) + 6;
    int l = Greenfoot.getRandomNumber(15) + 5;
    getWorld().addObject(new RedBall(tr, s, l, 10, 10), getX(), getY());
  }
}</pre></div><p>The instance variable <code class="literal">lifespan</code> is a delay variable that we use to determine how long the fountain will exist. Once <code class="literal">lifespan</code> is less than zero, we remove this fountain from the scenario. Otherwise, we create <code class="literal">RedBall</code> anew with a random lifespan and rate of turn and speed. These parameters to the constructor of the <code class="literal">RedBall</code> class were discussed in the <span class="emphasis"><em>Enemies</em></span> section.</p><p>Creating <code class="literal">RedBall</code> anew <a id="id303" class="indexterm"/>for every call of the <code class="literal">act()</code> method with <a id="id304" class="indexterm"/>slightly different attributes creates a really interesting fountain effect, as shown in <span class="emphasis"><em>Figure 2</em></span>.</p></div><div class="section" title="Bullets and turrets"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Bullets and turrets</h2></div></div></div><p>We have already fully <a id="id305" class="indexterm"/>implemented bullets and turrets. The <code class="literal">Turret</code> class was <a id="id306" class="indexterm"/>complete and we finished the <code class="literal">Ball</code> class (our bullet) in the <span class="emphasis"><em>Bouncing</em></span> section. What we will discuss here, are the basic steps to create a turret and a <a id="id307" class="indexterm"/>bullet and explain how what we have already <a id="id308" class="indexterm"/>done gives you the information you need to create a machine gun, cannon, tank, or other type of turret.</p><p>First, you need a turret with an image. You can dynamically create the image just as we did in the <code class="literal">Turret</code> class, or you can set it using <code class="literal">setImage()</code>. Then, turrets only need to be rotated in the direction they are firing. That is what we did in the <code class="literal">generateBalls()</code> method in <code class="literal">CupcakeWorld</code>. Bullets are just actors that are rotated in a certain direction and then continually call <code class="literal">move()</code> to move in that direction. If you rotate the turret and bullet by the same angle, place the bullet at the same starting location as the turret, and let the bullet move forward, then it will appear as if the turret fired the bullet. Does this make sense? <span class="emphasis"><em>Figure 5</em></span> summarizes this strategy.</p><div class="mediaobject"><img src="../Images/image00291.jpeg" alt="Bullets and turrets"/><div class="caption"><p>Figure 5: These are the steps necessary to create a turret firing a bullet</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Your assignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Your assignment</h2></div></div></div><p>Now, compile all of the <a id="id309" class="indexterm"/>code we just gave you and play Cupcake Counter for a while. You might start to notice why we started by having the platforms have some randomness to their placement. If we didn't, the player would quickly adapt to the falling patterns of the balls.</p><p>Your assignment for this section, is to code another random variation in the game. You could further randomize the platforms, mess with the ball speed or size, or change the power of the player's jump.</p></div></div>
<div class="section" title="Challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Challenge</h1></div></div></div><p>We have created a fairly <a id="id310" class="indexterm"/>functional game. We have a score, cool animations, collision detection, and levels in our game. After playing it, what would be the first thing you would improve? Let your friend play it. What did he/she think? Try to come up with a change that improves the game based on your experience playing it.</p><p>In addition, we designed our game so that it would be easy to add new rewards, enemies, and platforms. Add one of each to the game and add your own twist to them. For example, you could create a super cupcake that is worth five points but only lasts a short time. This will require the player to make some quick, meaningful decisions during the game.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Summary</h1></div></div></div><p>While we did not create a full physics engine, we did go over some simple techniques to give actors interesting movement. Our discussion was focused on projectile-based movement and included bouncing, jumping, firing, and particle effects. Until now, we acquired a number of creative program techniques that enable us to create a wide variety of animations, simulations, and games. However, creating a fun interactive experience is not trivial. In the next chapter, we are going to learn about game design and a process for game development that will help us create amazing interactive experiences.</p></div></body></html>