- en: Chapter 3. Understanding WebSockets and Server-sent Events in Detail
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。详细理解 WebSocket 和服务器发送事件
- en: WebSocket is one of the most promising features that HTML5 has to offer. As
    covered in [Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"),
    *WebSockets and Server-sent Events*, the traditional request-response model incurred
    an overhead due to the HTTP headers. With WebSockets, once the initial handshake
    is done the client and server or peers can communicate directly without the use
    of headers. This reduces the network latency and gives a reduction in HTTP header
    traffic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 是 HTML5 提供的最有前途的特性之一。正如在[第 2 章](ch02.html "第 2 章。WebSocket 和服务器发送事件")中所述，*WebSocket
    和服务器发送事件*，传统的请求-响应模型由于 HTTP 头部而产生了开销。使用 WebSocket，一旦完成初始握手，客户端和服务器或对等方可以直接通信，无需使用头部。这减少了网络延迟，并减少了
    HTTP 头部流量。
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, also introduced Server-sent Events and provides a comparison
    between SSE and WebSockets.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2 章](ch02.html "第 2 章。WebSocket 和服务器发送事件")，*WebSocket 和服务器发送事件*，还介绍了服务器发送事件，并提供了
    SSE 和 WebSocket 的比较。'
- en: Server-sent Events define an API where the server communicates and pushes events
    to the clients as they occur. It is a one-directional communication from the server
    to the client and has more benefits as compared to traditional polling and long
    polling techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送事件定义了一个 API，其中服务器在事件发生时与客户端通信并推送事件。这是一种从服务器到客户端的单向通信，与传统轮询和长轮询技术相比，具有更多优势。
- en: 'This chapter covers advanced concepts of WebSockets and Server-sent Events
    and covers the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 WebSocket 和服务器发送事件的先进概念，并涵盖了以下部分：
- en: Encoders and decoders in Java API for WebSockets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java API 中 WebSocket 的编码器和解码器
- en: Java WebSockets Client API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java WebSocket 客户端 API
- en: Sending different types of data such as Blob and Binary using Java API for WebSockets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java API for WebSockets 发送不同类型的数据，如 Blob 和 Binary
- en: Security and WebSockets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket 的安全性和最佳实践
- en: Best practices for WebSockets-based applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 WebSocket 的应用程序的最佳实践
- en: Developing Server-sent Events clients using Jersey API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jersey API 开发服务器发送事件客户端
- en: Best practices for Server-sent Events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送事件的最佳实践
- en: Encoders and decoders in Java API for WebSockets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java API 中 WebSocket 的编码器和解码器
- en: As seen in the previous chapter, the class-level annotation `@ServerEndpoint`
    indicates that a Java class is a WebSocket endpoint at runtime. The value attribute
    is used to specify a URI mapping for the endpoint. Additionally the user can add
    encoder and decoder attributes to encode application objects into WebSocket messages
    and WebSocket messages into application objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所示，类级别的注解 `@ServerEndpoint` 表示在运行时 Java 类是一个 WebSocket 端点。value 属性用于指定端点的
    URI 映射。此外，用户还可以添加编码器和解码器属性，将应用程序对象编码为 WebSocket 消息，并将 WebSocket 消息解码为应用程序对象。
- en: 'The following table summarizes the `@ServerEndpoint` annotation and its attributes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了 `@ServerEndpoint` 注解及其属性：
- en: '| Annotation | Attribute | Description |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 属性 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@ServerEndpoint` |   | This class-level annotation signifies that the Java
    class is a WebSockets server endpoint. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `@ServerEndpoint` |   | 这个类级别注解表示 Java 类是一个 WebSocket 服务器端点。|'
- en: '|   | `value` | The value is the URI with a leading `''/.''` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|   | `value` | 该值是带有前缀 `''/.''` 的 URI |'
- en: '|   | `encoders` | Contains a list of Java classes that act as encoders for
    the endpoint. The classes must implement the Encoder interface. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|   | `encoders` | 包含作为端点编码器的 Java 类列表。这些类必须实现 Encoder 接口。|'
- en: '|   | `decoders` | Contains a list of Java classes that act as decoders for
    the endpoint. The classes must implement the Decoder interface. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|   | `decoders` | 包含作为端点解码器的 Java 类列表。这些类必须实现 Decoder 接口。|'
- en: '|   | `configurator` | The configurator attribute allows the developer to plug
    in their implementation of `ServerEndpoint.Configurator` that is used when configuring
    the server endpoint. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|   | `configurator` | configurator 属性允许开发者插入他们的 `ServerEndpoint.Configurator`
    实现，该实现用于配置服务器端点。|'
- en: '|   | `subprotocols` | The sub protocols attribute contains a list of sub protocols
    that the endpoint can support. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   | `subprotocols` | 子协议属性包含端点可以支持的子协议列表。|'
- en: In this section we shall look at providing encoder and decoder implementations
    for our WebSockets endpoint.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨为我们的 WebSocket 端点提供编码器和解码器实现。
- en: '![Encoders and decoders in Java API for WebSockets](img/8125ENT_03_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Java API 中 WebSocket 的编码器和解码器](img/8125ENT_03_01.jpg)'
- en: The preceding diagram shows how encoders will take an application object and
    convert it to a WebSockets message. Decoders will take a WebSockets message and
    convert to an application object. Here is a simple example where a client sends
    a WebSockets message to a WebSockets java endpoint that is annotated with `@ServerEndpoint`
    and decorated with encoder and decoder class. The decoder will decode the WebSockets
    message and send back the same message to the client. The encoder will convert
    the message to a WebSockets message. This sample is also included in the code
    bundle for the book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了编码器如何将应用程序对象转换为 WebSocket 消息。解码器将 WebSocket 消息转换为应用程序对象。以下是一个简单的示例，其中客户端向一个被注解为`@ServerEndpoint`并装饰有编码器和解码器类的
    WebSocket java 端点发送 WebSocket 消息。解码器将解码 WebSocket 消息并将相同的信息发送回客户端。编码器将消息转换为 WebSocket
    消息。此示例也包含在书籍的代码包中。
- en: 'Here is the code to define `ServerEndpoint` with value for encoders and decoders:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是定义具有编码器和解码器值的`ServerEndpoint`的代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, you can see the class `BookCollection` is annotated
    with `@ServerEndpoint`. The `value=/book` attribute provides URI mapping for the
    endpoint. The `@ServerEndpoint` also takes the encoders and decoders to be used
    during the WebSocket transmission. Once a WebSocket connection has been established,
    a session is created and the method annotated with `@OnOpen` will be called. When
    the WebSocket endpoint receives a message, the method annotated with `@OnMessage`
    will be called. In our sample the method simply sends the book object using the
    `Session.getBasicRemote()` which will get a reference to the `RemoteEndpoint`
    and send the message synchronously.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到类`BookCollection`被注解为`@ServerEndpoint`。`value=/book`属性为端点提供了
    URI 映射。`@ServerEndpoint`还指定了在 WebSocket 传输期间要使用的编码器和解码器。一旦建立了 WebSocket 连接，就会创建一个会话，并调用注解为`@OnOpen`的方法。当
    WebSocket 端点接收到消息时，将调用注解为`@OnMessage`的方法。在我们的示例中，该方法简单地使用`Session.getBasicRemote()`发送书籍对象，这将获取对`RemoteEndpoint`的引用并同步发送消息。
- en: Encoders can be used to convert a custom user-defined object in a text message,
    `TextStream`, `BinaryStream`, or `BinaryMessage` format.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器可以用于将自定义用户定义的对象转换为文本消息、`TextStream`、`BinaryStream`或`BinaryMessage`格式。
- en: 'An implementation of an encoder class for text messages is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文本消息的编码器类的实现如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown in the preceding code, the encoder class implements `Encoder.Text<Book>`.
    There is an encode method that is overridden and which converts a book and sends
    it as a JSON string. (More on JSON APIs is covered in detail in the next chapter)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，编码器类实现了`Encoder.Text<Book>`。有一个被重写的编码方法，它将书籍转换为 JSON 字符串并发送。（关于 JSON
    API 的更多内容将在下一章详细讨论）
- en: Decoders can be used to decode WebSockets messages in custom user-defined objects.
    They can decode in text, `TextStream`, and binary or `BinaryStream` format.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器可以用于在自定义用户定义的对象中解码 WebSocket 消息。它们可以以文本、`TextStream`、二进制或`BinaryStream`格式进行解码。
- en: 'Here is a code for a decoder class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解码器类的代码：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, the `Decoder.Text` needs two methods to be overridden.
    The `willDecode()` method checks if it can handle this object and decode it. The
    `decode()` method decodes the string into an object of type `Book` by using the
    JSON-P API `javax.json.Json.createReader()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Decoder.Text`需要重写两个方法。`willDecode()`方法检查它是否可以处理此对象并对其进行解码。`decode()`方法使用
    JSON-P API `javax.json.Json.createReader()`将字符串解码为类型为`Book`的对象。
- en: 'The following code snippet shows the user-defined class `Book`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了用户定义的类`Book`：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Book` class is a user-defined class that takes the JSON object sent by
    the client. Here is an example of how the JSON details are sent to the WebSockets
    endpoints from JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book`类是一个用户定义的类，它接收客户端发送的 JSON 对象。以下是如何从 JavaScript 将 JSON 细节发送到 WebSocket
    端点的示例。'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The client sends the message using `websocket.send()` which will cause the `onMessage()`
    of the `BookCollection.java` to be invoked. The `BookCollection.java` will return
    the same book to the client. In the process, the decoder will decode the WebSockets
    message when it is received. To send back the same `Book` object, first the encoder
    will encode the `Book` object to a WebSockets message and send it to the client.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用`websocket.send()`发送消息，这将导致`BookCollection.java`的`onMessage()`被调用。`BookCollection.java`将向客户端返回相同的书籍。在这个过程中，当接收到
    WebSocket 消息时，解码器将对其进行解码。为了发送回相同的`Book`对象，首先编码器将`Book`对象编码为 WebSocket 消息并发送给客户端。
- en: The Java WebSocket Client API
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是 Java WebSocket 客户端 API
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, covered the Java WebSockets client API. Any POJO can
    be transformed into a WebSockets client by annotating it with `@ClientEndpoint`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。WebSocket和服务器发送事件")，*WebSocket和服务器发送事件*，介绍了Java WebSocket客户端API。任何POJO都可以通过使用`@ClientEndpoint`注解转换为WebSocket客户端。'
- en: Additionally the user can add encoders and decoders attributes to the `@ClientEndpoint`
    annotation to encode application objects into WebSockets messages and WebSockets
    messages into application objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户还可以向`@ClientEndpoint`注解添加编码器和解码器属性，以将应用程序对象编码为WebSocket消息，并将WebSocket消息解码为应用程序对象。
- en: 'The following table shows the `@ClientEndpoint` annotation and its attributes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了`@ClientEndpoint`注解及其属性：
- en: '| Annotation | Attribute | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 属性 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@ClientEndpoint` |   | This class-level annotation signifies that the Java
    class is a WebSockets client that will connect to a WebSockets server endpoint.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `@ClientEndpoint` |   | 此类级别注解表示Java类是一个WebSocket客户端，它将连接到WebSocket服务器端点。|'
- en: '|   | `value` | The value is the URI with a leading `/`. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|   | `value` | 值是带有前缀`/`的URI。|'
- en: '|   | `encoders` | Contains a list of Java classes that act as encoders for
    the endpoint. The classes must implement the encoder interface. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|   | `encoders` | 包含一个Java类列表，这些类作为端点的编码器。这些类必须实现编码器接口。|'
- en: '|   | `decoders` | Contains a list of Java classes that act as decoders for
    the endpoint. The classes must implement the decoder interface. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|   | `decoders` | 包含一个Java类列表，这些类作为端点的解码器。这些类必须实现解码器接口。|'
- en: '|   | `configurator` | The configurator attribute allows the developer to plug
    in their implementation of `ClientEndpoint.Configurator`, which is used when configuring
    the client endpoint. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|   | `configurator` | 配置器属性允许开发者插入他们自己的`ClientEndpoint.Configurator`实现，该实现用于配置客户端端点。|'
- en: '|   | `subprotocols` | The sub protocols attribute contains a list of sub protocols
    that the endpoint can support. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|   | `subprotocols` | 子协议属性包含端点可以支持的一组子协议列表。|'
- en: 'Sending different kinds of message data: blob/binary'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送不同类型的消息数据：blob/二进制
- en: Using JavaScript we can traditionally send JSON or XML as strings. However,
    HTML5 allows applications to work with binary data to improve performance. WebSockets
    supports two kinds of binary data
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript，我们传统上以字符串的形式发送JSON或XML。然而，HTML5允许应用程序处理二进制数据以改善性能。WebSocket支持两种类型的二进制数据
- en: Binary Large Objects (`blob`)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制大对象（`blob`）
- en: '`arraybuffer`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arraybuffer`'
- en: A WebSocket can work with only one of the formats at any given time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket在任何给定时间只能与一种格式一起工作。
- en: 'Using the `binaryType` property of a WebSocket, you can switch between using
    blob or `arraybuffer`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WebSocket的`binaryType`属性，您可以在使用blob或`arraybuffer`之间切换：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following code snippet shows how to display images sent by a server using
    WebSockets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用WebSocket显示服务器发送的图像。
- en: 'Here is a code snippet for how to send binary data with WebSockets:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用WebSocket发送二进制数据的代码片段：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code snippet sets the `binaryType` property of `websocket` to
    `arraybuffer`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将`websocket`的`binaryType`属性设置为`arraybuffer`。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the `onmessage` is called the `arrayBuffer` is initialized to the `message.data`.
    The `Uint8Array` type represents an array of 8-bit unsigned integers. The `image.src`
    value is in line using the data URI scheme.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`onmessage`时，`arrayBuffer`被初始化为`message.data`。`Uint8Array`类型表示一个8位无符号整数数组。`image.src`值使用数据URI方案直接嵌入。
- en: Security and WebSockets
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性和WebSocket
- en: WebSockets are secured using the web container security model. A WebSockets
    developer can declare whether the access to the WebSocket server endpoint needs
    to be authenticated, who can access it, or if it needs an encrypted connection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket使用Web容器安全模型进行安全保护。WebSocket开发者可以声明是否需要认证访问WebSocket服务器端点，谁可以访问它，或者是否需要加密连接。
- en: A WebSockets endpoint which is mapped to a `ws://` URI is protected under the
    deployment descriptor with `http:// URI` with the same `hostname,port` path since
    the initial handshake is from the HTTP connection. So, WebSockets developers can
    assign an authentication scheme, user roles, and a transport guarantee to any
    WebSockets endpoints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 映射到`ws://` URI的WebSocket端点在部署描述符中受到与具有相同`hostname,port`路径的`http:// URI`的保护，因为初始握手来自HTTP连接。因此，WebSocket开发者可以为任何WebSocket端点分配认证方案、用户角色和传输保证。
- en: We will take the same sample as we saw in [Chapter 2](ch02.html "Chapter 2. WebSockets
    and Server-sent Events"), *WebSockets and Server-sent Events*, and make it a secure
    WebSockets application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[第2章](ch02.html "第2章。WebSocket和服务器发送事件")中相同的示例，*WebSocket和服务器发送事件*，并将其制作成一个安全的WebSocket应用程序。
- en: 'Here is the `web.xml` for a secure WebSocket endpoint:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安全WebSocket端点的`web.xml`：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding snippet, we used `<transport-guarantee>CONFIDENTIAL</transport-guarantee>`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个片段所示，我们使用了`<transport-guarantee>CONFIDENTIAL</transport-guarantee>`。
- en: 'The Java EE specification followed by application servers provides different
    levels of transport guarantee on the communication between clients and application
    server. The three levels are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE规范以及应用程序服务器为客户端与应用服务器之间的通信提供了不同级别的传输保证。这三个级别是：
- en: '**Data Confidentiality (CONFIDENTIAL)**: We use this level to guarantee that
    all communication between client and server goes through the SSL layer and connections
    won''t be accepted over a non-secure channel.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据机密性（CONFIDENTIAL）**：我们使用此级别来确保客户端和服务器之间的所有通信都通过SSL层进行，并且不会接受非安全通道上的连接。'
- en: '**Data Integrity (INTEGRAL)**: We can use this level when a full encryption
    is not required but we want our data to be transmitted to and from a client in
    such a way that, if anyone changed the data, we could detect the change.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据完整性（INTEGRAL）**：当不需要完整加密但希望以这种方式将数据从客户端传输到客户端时，我们可以使用此级别，如果有人更改了数据，我们可以检测到更改。'
- en: '**Any type of connection (NONE)**: We can use this level to force the container
    to accept connections on HTTP and HTTPs.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任何类型的连接（NONE）**：我们可以使用此级别来强制容器接受HTTP和HTTPS上的连接。'
- en: The following steps should be followed for setting up SSL and running our sample
    to show a secure WebSockets application deployed in Glassfish.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置SSL并运行我们的示例以展示在Glassfish中部署的安全WebSocket应用程序时，应遵循以下步骤：
- en: 'Generate the server certificate:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成服务器证书：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Export the generated server certificate in `keystore.jks` into the file `server.cer`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的服务器证书从`keystore.jks`导出到文件`server.cer`：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create the trust-store file `cacerts.jks` and add the server certificate to
    the trust store:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建信任存储文件`cacerts.jks`并将服务器证书添加到信任存储：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Change the following JVM options so that they point to the location and name
    of the new keystore. Add this in `domain.xml` under `java-config`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改以下JVM选项，以便它们指向新的密钥库的位置和名称。在`domain.xml`下的`java-config`中添加此内容：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Restart GlassFish. If you go to `https://localhost:8181/helloworld-ws/`, you
    can see the secure WebSocket application.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动GlassFish。如果您访问`https://localhost:8181/helloworld-ws/`，您可以看到安全的WebSocket应用程序。
- en: Here is how the the headers look under Chrome Developer Tools:![Security and
    WebSockets](img/8125ENT_03_02.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是Chrome开发者工具下的头部信息看起来如何：![安全和WebSocket](img/8125ENT_03_02.jpg)
- en: Open Chrome Browser and click on **View** and then on **Developer Tools**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Chrome浏览器，点击**查看**然后点击**开发者工具**。
- en: Click on **Network**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**网络**。
- en: Select **book** under element name and click on **Frames**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在元素名称下选择**book**，然后点击**Frames**。
- en: As you can see in the preceding screenshot, since the application is secured
    using SSL the WebSockets URI, it also contains `wss://`, which means WebSockets
    over SSL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，由于应用程序使用SSL进行加密，WebSocket URI也包含`wss://`，这意味着WebSocket通过SSL。
- en: So far we have seen the encoders and decoders for WebSockets messages. We also
    covered how to send binary data using WebSockets. Additionally we have demonstrated
    a sample on how to secure WebSockets based application. We shall now cover the
    best practices for WebSocket based-applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了WebSocket消息的编码器和解码器。我们还介绍了如何使用WebSocket发送二进制数据。此外，我们还演示了如何安全地基于WebSocket的应用程序。现在，我们将介绍WebSocket应用程序的最佳实践。
- en: Best practices for WebSockets based applications
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于WebSocket的应用程序的最佳实践
- en: 'This section will cover best practices for WebSockets based applications. The
    following topics will be covered:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍基于WebSocket的应用程序的最佳实践。以下主题将涵盖：
- en: Throttling the rate of sending data
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制发送数据的速率
- en: Controlling the maximum size of the message
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制消息的最大大小
- en: Working with proxy servers and WebSockets
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与代理服务器和WebSocket一起工作
- en: Throttling the rate of sending data
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制发送数据的速率
- en: After the WebSocket connection is opened, messages can be sent using the send
    function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebSocket连接打开后，可以使用发送函数发送消息。
- en: WebSockets have a `bufferedAmount` attribute that can be used to control the
    rate of sending data. Using the `bufferedAmount` attribute you can check the number
    of bytes that have been queued but not yet sent to the server.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets有一个 `bufferedAmount` 属性，可以用来控制发送数据的速率。使用 `bufferedAmount` 属性，您可以检查已排队但尚未发送到服务器的字节数。
- en: Here is a snippet to test for the `bufferedAmount` attribute of WebSocket.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个用于测试WebSocket的 `bufferedAmount` 属性的代码片段。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This can be done periodically using the `setInterval` function. As you can see,
    the developer can periodically check for the `bufferedAmount` attribute to see
    if the number of bytes in the queue to be sent to the server exceeds some threshold.
    In that case it should delay sending messages. Once the buffered amount is less
    than the threshold it should send more messages.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `setInterval` 函数定期完成。正如您所看到的，开发者可以定期检查 `bufferedAmount` 属性，以查看要发送到服务器的队列中的字节数是否超过了某个阈值。在这种情况下，应该延迟发送消息。一旦缓冲区大小小于阈值，就应该发送更多消息。
- en: This is a good practice to check for the `bufferedAmount` and then send data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `bufferedAmount` 然后发送数据是一个好习惯。
- en: Controlling the maximum size of the message
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制消息的最大大小
- en: The `maxMessageSize` attribute on the `@OnMessage` annotation in Java class
    annotated with `@ServerEndpoint` or `@ClientEndpoint` allows the developer to
    specify the maximum size of message in bytes that can be handled by the `ClientEndpoint`
    or `ServerEndpoint`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `@ServerEndpoint` 或 `@ClientEndpoint` 注解的Java类中，`@OnMessage` 注解上的 `maxMessageSize`
    属性允许开发者指定 `ClientEndpoint` 或 `ServerEndpoint` 可以处理的字节数的最大消息大小。
- en: If the incoming message exceeds the maximum size then the connection is closed.
    This is a good practice to control the maximum size of a message so that the client
    does not deplete its resources while trying to handle a message, which it can't
    process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的消息超过最大大小，则连接将被关闭。这是一个好习惯，可以控制消息的最大大小，这样客户端在尝试处理一个它无法处理的消息时，不会耗尽其资源。
- en: Working with proxy servers and WebSockets
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与代理服务器和WebSockets一起工作
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Event*, covered how the WebSocket upgrade handshake looks. Not
    all proxy servers may support WebSockets; thus, proxy servers may not allow unencrypted
    WebSocket traffic to flow through. The clients use a `CONNECT` call which would
    never be allowed. The correct approach would be to send the request over https
    on the standard port `443`. Here is an example of the HTTP Connect sent by the
    browser client to `foo.com` on port `443`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。WebSockets和服务器发送事件")，*WebSockets和服务器发送事件*，介绍了WebSocket升级握手的过程。并非所有代理服务器都支持WebSockets；因此，代理服务器可能不允许未加密的WebSocket流量通过。客户端使用一个
    `CONNECT` 调用，这是绝对不允许的。正确的方法是将请求通过https发送到标准端口 `443`。以下是一个浏览器客户端向 `foo.com` 端口
    `443` 发送的HTTP Connect请求的示例。'
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the traffic is encrypted there is a greater chance to pass through the
    proxy server. Then the `CONNECT` statements will work and there will be an end-to-end
    encrypted tunnel for WebSockets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流量是加密的，因此有更大的机会通过代理服务器。然后 `CONNECT` 语句将工作，并且将有一个端到端的加密隧道用于WebSockets。
- en: 'The following diagram shows how clients can send HTTPS requests which get past
    the proxy server and firewall; the WebSocket secure scheme will work:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了客户端如何发送HTTPS请求，这些请求可以绕过代理服务器和防火墙；WebSocket安全方案将工作：
- en: '![Working with proxy servers and WebSockets](img/8125ENT_03_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![与代理服务器和WebSockets一起工作](img/8125ENT_03_03.jpg)'
- en: It is a good practice to use WebSocket-based applications with SSL so that the
    Proxy server does not impede WebSocket communication.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于WebSocket的应用程序与SSL一起使用是一个好习惯，这样代理服务器就不会阻碍WebSocket通信。
- en: Server-sent Events
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器发送事件
- en: We covered Server-sent Events in [Chapter 2](ch02.html "Chapter 2. WebSockets
    and Server-sent Events"), *WebSockets and Server-sent Events*, and compared and
    contrasted client/server polling alternatives as well as WebSockets. In this chapter
    we will cover more advanced topics such as developing a Server-sent Events client
    using Jersey API and best practices for Server-sent Events.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章。WebSockets和服务器发送事件")中介绍了服务器发送事件，*WebSockets和服务器发送事件*，并比较了客户端/服务器轮询替代方案以及WebSockets。在本章中，我们将介绍更高级的主题，例如使用Jersey
    API开发服务器发送事件客户端以及服务器发送事件的最佳实践。
- en: Developing a Server-sent Event client using Jersey API
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jersey API开发服务器发送事件客户端
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, gave a brief introduction to the Server-sent Events and
    JavaScript API. In this chapter we will cover the Java Client API for Server-sent
    Events, which is provided by Jersey. Jersey is an implementation of JAX-RS 2.0\.
    In addition to the features of the JAX-RS 2.0 specification, Jersey has provided
    support for Server-sent Events.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章：WebSockets和服务器发送事件")，*WebSockets和服务器发送事件*，简要介绍了服务器发送事件和JavaScript
    API。在本章中，我们将介绍由Jersey提供的服务器发送事件的Java客户端API。除了JAX-RS 2.0规范的功能外，Jersey还提供了对服务器发送事件的支持。'
- en: '`EventSource` is the class for reading `InboundEvents`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`是用于读取`InboundEvents`的类：'
- en: 'The following snippet shows how to use the `EventSource` API:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用`EventSource` API：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `EventSource` object is created with `WebTarget`. We covered `WebTarget`
    in [Chapter 1](ch01.html "Chapter 1. Building RESTful Web Services Using JAX-RS"),
    *Building RESTful Web Services using JAX-RS*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`对象是通过`WebTarget`创建的。我们在[第一章](ch01.html "第一章：使用JAX-RS构建RESTful
    Web服务")，*使用JAX-RS构建RESTful Web服务*中介绍了`WebTarget`。'
- en: When a Server-sent Event is received by the client the `onEvent()` method of
    the `EventSource` is invoked. The `InboundEvent` has the `getData()` method that
    takes the `String.class` that is the type of the message data. You can add any
    custom defined class here. The JAX-RS `MessagebodyReader` will be used to read
    the type of the message. Thus you can see the similarity in the code between using
    JavaScript API and the Jersey Client API. [Chapter 5](ch05.html "Chapter 5. RESTful
    Web Services by Example"), *Restful Web Services by Example*, will show a complete
    example using the Server Sent Event Jersey Client API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端接收到服务器发送事件时，`EventSource`的`onEvent()`方法将被调用。`InboundEvent`具有`getData()`方法，该方法接受`String.class`作为消息数据的类型。您可以在其中添加任何自定义定义的类。JAX-RS的`MessagebodyReader`将用于读取消息的类型。因此，您可以在使用JavaScript
    API和使用Jersey客户端API之间的代码中看到相似之处。[第五章](ch05.html "第五章：通过示例构建RESTful Web服务")，*通过示例构建RESTful
    Web服务*，将展示使用服务器发送事件Jersey客户端API的完整示例。
- en: Best practices for applications based on Server-sent Events
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于服务器发送事件的应用的最佳实践
- en: 'The following chapter covers the best practices for applications based on Server-sent
    Events. The following topics will be covered:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将介绍基于服务器发送事件的应用的最佳实践。以下主题将被涵盖：
- en: Checking if the event source's origin is as expected
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查事件源的来源是否符合预期
- en: Working with proxy servers and Server-sent Events
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与代理服务器和服务器发送事件一起工作
- en: Handling fault tolerance for Server-sent Events
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务器发送事件的容错性
- en: Checking if the event source's origin is as expected
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查事件源的来源是否符合预期
- en: The following snippet shows how to check for the origin of the event source
    so that it matches the application's origin.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何检查事件源的来源，以确保它与应用程序的来源相匹配。
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An event stream from an origin distinct from the origin of the content consuming
    the event stream can result in information leakage. When the events are obtained
    from the server, it is good practice to check for the events originator to see
    if it is as expected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 来自与消费事件流内容来源不同的来源的事件流可能导致信息泄露。当从服务器获取事件时，检查事件的发起者是否符合预期是一种良好的做法。
- en: Working with proxy servers and Server-sent Events
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与代理服务器和服务器发送事件一起工作
- en: Proxy servers can drop HTTP connections after a short timeout. To avoid such
    dropped connections it may be a good idea to send a comment periodically.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代理服务器可以在短时间超时后断开HTTP连接。为了避免这种断开连接的情况，定期发送注释可能是个好主意。
- en: This is how a comment is sent using Server-sent Events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用服务器发送事件发送注释的方法。
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Outboundevent.Builder` API will send a comment to the client.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Outboundevent.Builder` API将向客户端发送注释。'
- en: The comment will fire nothing yet will make sure that connections do not get
    dropped between client and server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该注释不会触发任何操作，但会确保客户端和服务器之间的连接不会断开。
- en: Handling fault tolerance for Server-sent Events
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理服务器发送事件的容错性
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, covered how you can associate IDs with events. The server
    can send event ids with events by using the following snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章：WebSockets和服务器发送事件")，*WebSockets和服务器发送事件*，介绍了如何将ID与事件关联。服务器可以通过以下代码片段使用事件ID发送事件：'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The client keeps the connection alive and tries to reconnect if the connection
    is dropped. Setting an ID lets the browser keep track of the last event fired
    so when the connection between the client and server is dropped, on reconnect
    by the client to the server the **Last-Event-ID** will be sent back to the server.
    This ensures the client does not miss any messages. The server can then send events
    that occur after the Last-Event-ID.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端保持连接活跃，并在连接断开时尝试重新连接。设置一个ID让浏览器跟踪最后触发的事件，因此当客户端与服务器之间的连接断开时，客户端在重新连接到服务器时将**最后事件ID**发送回服务器。这确保了客户端不会错过任何消息。然后服务器可以发送在最后事件ID之后发生的事件。
- en: The server may need a message queue to keep track of the different clients connected,
    check for reconnections, and send messages based on the Last-Event-ID.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能需要一个消息队列来跟踪连接的不同客户端，检查重新连接，并根据最后事件ID发送消息。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we looked at advanced topics for WebSockets and Server-sent
    Events. We demonstrated with code snippets how to use encoders and decoders and
    how to receive different kinds of data using WebSockets. We also demonstrated
    a sample that showed how WebSockets will work with SSL so that when working with
    proxy servers, the communication is encrypted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了WebSocket和服务器发送事件的先进主题。我们通过代码片段展示了如何使用编码器和解码器，以及如何使用WebSocket接收不同类型的数据。我们还演示了一个示例，展示了WebSocket如何与SSL一起工作，以便在与代理服务器一起工作时，通信是加密的。
- en: We also discussed best practices for implementing Server-sent Events and WebSockets.
    We learned how to ensure messages are not lost in Server-sent Events by associating
    IDs with events. We covered the Jersey Client API for Server-sent Events.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了实现服务器发送事件和WebSocket的最佳实践。我们学习了如何通过将ID与事件关联来确保服务器发送事件中的消息不会丢失。我们还介绍了用于服务器发送事件的Jersey客户端API。
- en: In the next chapter, we will cover more advanced topics such as JSON API in
    Java EE and the aspects of asynchronous programming to improve scalability with
    respect to various Java EE specifications such as JAX-RS 2.0, EJB and Servlets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖更多高级主题，例如Java EE中的JSON API和异步编程的方面，以提高与各种Java EE规范（如JAX-RS 2.0、EJB和Servlets）相关的可伸缩性。
