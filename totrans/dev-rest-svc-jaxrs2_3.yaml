- en: Chapter 3. Understanding WebSockets and Server-sent Events in Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSocket is one of the most promising features that HTML5 has to offer. As
    covered in [Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"),
    *WebSockets and Server-sent Events*, the traditional request-response model incurred
    an overhead due to the HTTP headers. With WebSockets, once the initial handshake
    is done the client and server or peers can communicate directly without the use
    of headers. This reduces the network latency and gives a reduction in HTTP header
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, also introduced Server-sent Events and provides a comparison
    between SSE and WebSockets.'
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent Events define an API where the server communicates and pushes events
    to the clients as they occur. It is a one-directional communication from the server
    to the client and has more benefits as compared to traditional polling and long
    polling techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers advanced concepts of WebSockets and Server-sent Events
    and covers the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Encoders and decoders in Java API for WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java WebSockets Client API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending different types of data such as Blob and Binary using Java API for WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for WebSockets-based applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Server-sent Events clients using Jersey API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for Server-sent Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoders and decoders in Java API for WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen in the previous chapter, the class-level annotation `@ServerEndpoint`
    indicates that a Java class is a WebSocket endpoint at runtime. The value attribute
    is used to specify a URI mapping for the endpoint. Additionally the user can add
    encoder and decoder attributes to encode application objects into WebSocket messages
    and WebSocket messages into application objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the `@ServerEndpoint` annotation and its attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@ServerEndpoint` |   | This class-level annotation signifies that the Java
    class is a WebSockets server endpoint. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `value` | The value is the URI with a leading `''/.''` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `encoders` | Contains a list of Java classes that act as encoders for
    the endpoint. The classes must implement the Encoder interface. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `decoders` | Contains a list of Java classes that act as decoders for
    the endpoint. The classes must implement the Decoder interface. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `configurator` | The configurator attribute allows the developer to plug
    in their implementation of `ServerEndpoint.Configurator` that is used when configuring
    the server endpoint. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `subprotocols` | The sub protocols attribute contains a list of sub protocols
    that the endpoint can support. |'
  prefs: []
  type: TYPE_TB
- en: In this section we shall look at providing encoder and decoder implementations
    for our WebSockets endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Encoders and decoders in Java API for WebSockets](img/8125ENT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows how encoders will take an application object and
    convert it to a WebSockets message. Decoders will take a WebSockets message and
    convert to an application object. Here is a simple example where a client sends
    a WebSockets message to a WebSockets java endpoint that is annotated with `@ServerEndpoint`
    and decorated with encoder and decoder class. The decoder will decode the WebSockets
    message and send back the same message to the client. The encoder will convert
    the message to a WebSockets message. This sample is also included in the code
    bundle for the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to define `ServerEndpoint` with value for encoders and decoders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see the class `BookCollection` is annotated
    with `@ServerEndpoint`. The `value=/book` attribute provides URI mapping for the
    endpoint. The `@ServerEndpoint` also takes the encoders and decoders to be used
    during the WebSocket transmission. Once a WebSocket connection has been established,
    a session is created and the method annotated with `@OnOpen` will be called. When
    the WebSocket endpoint receives a message, the method annotated with `@OnMessage`
    will be called. In our sample the method simply sends the book object using the
    `Session.getBasicRemote()` which will get a reference to the `RemoteEndpoint`
    and send the message synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Encoders can be used to convert a custom user-defined object in a text message,
    `TextStream`, `BinaryStream`, or `BinaryMessage` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of an encoder class for text messages is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the encoder class implements `Encoder.Text<Book>`.
    There is an encode method that is overridden and which converts a book and sends
    it as a JSON string. (More on JSON APIs is covered in detail in the next chapter)
  prefs: []
  type: TYPE_NORMAL
- en: Decoders can be used to decode WebSockets messages in custom user-defined objects.
    They can decode in text, `TextStream`, and binary or `BinaryStream` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code for a decoder class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `Decoder.Text` needs two methods to be overridden.
    The `willDecode()` method checks if it can handle this object and decode it. The
    `decode()` method decodes the string into an object of type `Book` by using the
    JSON-P API `javax.json.Json.createReader()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the user-defined class `Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Book` class is a user-defined class that takes the JSON object sent by
    the client. Here is an example of how the JSON details are sent to the WebSockets
    endpoints from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The client sends the message using `websocket.send()` which will cause the `onMessage()`
    of the `BookCollection.java` to be invoked. The `BookCollection.java` will return
    the same book to the client. In the process, the decoder will decode the WebSockets
    message when it is received. To send back the same `Book` object, first the encoder
    will encode the `Book` object to a WebSockets message and send it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The Java WebSocket Client API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, covered the Java WebSockets client API. Any POJO can
    be transformed into a WebSockets client by annotating it with `@ClientEndpoint`.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally the user can add encoders and decoders attributes to the `@ClientEndpoint`
    annotation to encode application objects into WebSockets messages and WebSockets
    messages into application objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the `@ClientEndpoint` annotation and its attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@ClientEndpoint` |   | This class-level annotation signifies that the Java
    class is a WebSockets client that will connect to a WebSockets server endpoint.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | `value` | The value is the URI with a leading `/`. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `encoders` | Contains a list of Java classes that act as encoders for
    the endpoint. The classes must implement the encoder interface. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `decoders` | Contains a list of Java classes that act as decoders for
    the endpoint. The classes must implement the decoder interface. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `configurator` | The configurator attribute allows the developer to plug
    in their implementation of `ClientEndpoint.Configurator`, which is used when configuring
    the client endpoint. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `subprotocols` | The sub protocols attribute contains a list of sub protocols
    that the endpoint can support. |'
  prefs: []
  type: TYPE_TB
- en: 'Sending different kinds of message data: blob/binary'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using JavaScript we can traditionally send JSON or XML as strings. However,
    HTML5 allows applications to work with binary data to improve performance. WebSockets
    supports two kinds of binary data
  prefs: []
  type: TYPE_NORMAL
- en: Binary Large Objects (`blob`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arraybuffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A WebSocket can work with only one of the formats at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `binaryType` property of a WebSocket, you can switch between using
    blob or `arraybuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The following code snippet shows how to display images sent by a server using
    WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet for how to send binary data with WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet sets the `binaryType` property of `websocket` to
    `arraybuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the `onmessage` is called the `arrayBuffer` is initialized to the `message.data`.
    The `Uint8Array` type represents an array of 8-bit unsigned integers. The `image.src`
    value is in line using the data URI scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Security and WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets are secured using the web container security model. A WebSockets
    developer can declare whether the access to the WebSocket server endpoint needs
    to be authenticated, who can access it, or if it needs an encrypted connection.
  prefs: []
  type: TYPE_NORMAL
- en: A WebSockets endpoint which is mapped to a `ws://` URI is protected under the
    deployment descriptor with `http:// URI` with the same `hostname,port` path since
    the initial handshake is from the HTTP connection. So, WebSockets developers can
    assign an authentication scheme, user roles, and a transport guarantee to any
    WebSockets endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: We will take the same sample as we saw in [Chapter 2](ch02.html "Chapter 2. WebSockets
    and Server-sent Events"), *WebSockets and Server-sent Events*, and make it a secure
    WebSockets application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `web.xml` for a secure WebSocket endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippet, we used `<transport-guarantee>CONFIDENTIAL</transport-guarantee>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java EE specification followed by application servers provides different
    levels of transport guarantee on the communication between clients and application
    server. The three levels are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Confidentiality (CONFIDENTIAL)**: We use this level to guarantee that
    all communication between client and server goes through the SSL layer and connections
    won''t be accepted over a non-secure channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Integrity (INTEGRAL)**: We can use this level when a full encryption
    is not required but we want our data to be transmitted to and from a client in
    such a way that, if anyone changed the data, we could detect the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Any type of connection (NONE)**: We can use this level to force the container
    to accept connections on HTTP and HTTPs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following steps should be followed for setting up SSL and running our sample
    to show a secure WebSockets application deployed in Glassfish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the server certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Export the generated server certificate in `keystore.jks` into the file `server.cer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the trust-store file `cacerts.jks` and add the server certificate to
    the trust store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the following JVM options so that they point to the location and name
    of the new keystore. Add this in `domain.xml` under `java-config`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart GlassFish. If you go to `https://localhost:8181/helloworld-ws/`, you
    can see the secure WebSocket application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is how the the headers look under Chrome Developer Tools:![Security and
    WebSockets](img/8125ENT_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Chrome Browser and click on **View** and then on **Developer Tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Network**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **book** under element name and click on **Frames**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, since the application is secured
    using SSL the WebSockets URI, it also contains `wss://`, which means WebSockets
    over SSL.
  prefs: []
  type: TYPE_NORMAL
- en: So far we have seen the encoders and decoders for WebSockets messages. We also
    covered how to send binary data using WebSockets. Additionally we have demonstrated
    a sample on how to secure WebSockets based application. We shall now cover the
    best practices for WebSocket based-applications.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for WebSockets based applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will cover best practices for WebSockets based applications. The
    following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Throttling the rate of sending data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the maximum size of the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with proxy servers and WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling the rate of sending data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the WebSocket connection is opened, messages can be sent using the send
    function.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets have a `bufferedAmount` attribute that can be used to control the
    rate of sending data. Using the `bufferedAmount` attribute you can check the number
    of bytes that have been queued but not yet sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a snippet to test for the `bufferedAmount` attribute of WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This can be done periodically using the `setInterval` function. As you can see,
    the developer can periodically check for the `bufferedAmount` attribute to see
    if the number of bytes in the queue to be sent to the server exceeds some threshold.
    In that case it should delay sending messages. Once the buffered amount is less
    than the threshold it should send more messages.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good practice to check for the `bufferedAmount` and then send data.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the maximum size of the message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `maxMessageSize` attribute on the `@OnMessage` annotation in Java class
    annotated with `@ServerEndpoint` or `@ClientEndpoint` allows the developer to
    specify the maximum size of message in bytes that can be handled by the `ClientEndpoint`
    or `ServerEndpoint`.
  prefs: []
  type: TYPE_NORMAL
- en: If the incoming message exceeds the maximum size then the connection is closed.
    This is a good practice to control the maximum size of a message so that the client
    does not deplete its resources while trying to handle a message, which it can't
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Working with proxy servers and WebSockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Event*, covered how the WebSocket upgrade handshake looks. Not
    all proxy servers may support WebSockets; thus, proxy servers may not allow unencrypted
    WebSocket traffic to flow through. The clients use a `CONNECT` call which would
    never be allowed. The correct approach would be to send the request over https
    on the standard port `443`. Here is an example of the HTTP Connect sent by the
    browser client to `foo.com` on port `443`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the traffic is encrypted there is a greater chance to pass through the
    proxy server. Then the `CONNECT` statements will work and there will be an end-to-end
    encrypted tunnel for WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how clients can send HTTPS requests which get past
    the proxy server and firewall; the WebSocket secure scheme will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with proxy servers and WebSockets](img/8125ENT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is a good practice to use WebSocket-based applications with SSL so that the
    Proxy server does not impede WebSocket communication.
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered Server-sent Events in [Chapter 2](ch02.html "Chapter 2. WebSockets
    and Server-sent Events"), *WebSockets and Server-sent Events*, and compared and
    contrasted client/server polling alternatives as well as WebSockets. In this chapter
    we will cover more advanced topics such as developing a Server-sent Events client
    using Jersey API and best practices for Server-sent Events.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a Server-sent Event client using Jersey API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, gave a brief introduction to the Server-sent Events and
    JavaScript API. In this chapter we will cover the Java Client API for Server-sent
    Events, which is provided by Jersey. Jersey is an implementation of JAX-RS 2.0\.
    In addition to the features of the JAX-RS 2.0 specification, Jersey has provided
    support for Server-sent Events.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EventSource` is the class for reading `InboundEvents`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows how to use the `EventSource` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `EventSource` object is created with `WebTarget`. We covered `WebTarget`
    in [Chapter 1](ch01.html "Chapter 1. Building RESTful Web Services Using JAX-RS"),
    *Building RESTful Web Services using JAX-RS*.
  prefs: []
  type: TYPE_NORMAL
- en: When a Server-sent Event is received by the client the `onEvent()` method of
    the `EventSource` is invoked. The `InboundEvent` has the `getData()` method that
    takes the `String.class` that is the type of the message data. You can add any
    custom defined class here. The JAX-RS `MessagebodyReader` will be used to read
    the type of the message. Thus you can see the similarity in the code between using
    JavaScript API and the Jersey Client API. [Chapter 5](ch05.html "Chapter 5. RESTful
    Web Services by Example"), *Restful Web Services by Example*, will show a complete
    example using the Server Sent Event Jersey Client API.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for applications based on Server-sent Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following chapter covers the best practices for applications based on Server-sent
    Events. The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking if the event source's origin is as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with proxy servers and Server-sent Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling fault tolerance for Server-sent Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if the event source's origin is as expected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following snippet shows how to check for the origin of the event source
    so that it matches the application's origin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: An event stream from an origin distinct from the origin of the content consuming
    the event stream can result in information leakage. When the events are obtained
    from the server, it is good practice to check for the events originator to see
    if it is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Working with proxy servers and Server-sent Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proxy servers can drop HTTP connections after a short timeout. To avoid such
    dropped connections it may be a good idea to send a comment periodically.
  prefs: []
  type: TYPE_NORMAL
- en: This is how a comment is sent using Server-sent Events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Outboundevent.Builder` API will send a comment to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The comment will fire nothing yet will make sure that connections do not get
    dropped between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Handling fault tolerance for Server-sent Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. WebSockets and Server-sent Events"), *WebSockets
    and Server-sent Events*, covered how you can associate IDs with events. The server
    can send event ids with events by using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The client keeps the connection alive and tries to reconnect if the connection
    is dropped. Setting an ID lets the browser keep track of the last event fired
    so when the connection between the client and server is dropped, on reconnect
    by the client to the server the **Last-Event-ID** will be sent back to the server.
    This ensures the client does not miss any messages. The server can then send events
    that occur after the Last-Event-ID.
  prefs: []
  type: TYPE_NORMAL
- en: The server may need a message queue to keep track of the different clients connected,
    check for reconnections, and send messages based on the Last-Event-ID.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we looked at advanced topics for WebSockets and Server-sent
    Events. We demonstrated with code snippets how to use encoders and decoders and
    how to receive different kinds of data using WebSockets. We also demonstrated
    a sample that showed how WebSockets will work with SSL so that when working with
    proxy servers, the communication is encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed best practices for implementing Server-sent Events and WebSockets.
    We learned how to ensure messages are not lost in Server-sent Events by associating
    IDs with events. We covered the Jersey Client API for Server-sent Events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover more advanced topics such as JSON API in
    Java EE and the aspects of asynchronous programming to improve scalability with
    respect to various Java EE specifications such as JAX-RS 2.0, EJB and Servlets.
  prefs: []
  type: TYPE_NORMAL
