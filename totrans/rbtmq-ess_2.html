<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Creating a Taxi Application
                </header>
            
            <article>
                
<p>In everyday conversation, people greet each other, exchange banter, and then eventually end the conversation and continue on their way. Low-level TCP connections function in the same way over lightweight channels in RabbitMQ. Applications that are going to exchange messages over RabbitMQ need to establish a permanent connection to the message broker. When this connection is established, a channel needs to be created so that message-oriented interactions, such as publishing and consuming messages, can be performed.</p>
<p><span>After demonstrating these fundamentals, this chapter will cover how a broker uses <strong>exchanges</strong> to determine </span><span>where each message should be delivered.</span> An exchange is like a mailman: it delivers messages to their proper queues (mailboxes) for consumers to find at a later time.</p>
<p>The basic R<span class="ILfuVd">abbitMQ concepts are shown in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-631 image-border" src="assets/18e8d28a-a508-4004-8e74-5c3d14f7e03b.png" style="width:67.42em;height:21.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 2.1: Basic R<span class="ILfuVd">abbitMQ concepts</span></div>
<p><span>By the end of this chapter, you will have a solid understanding of the application architecture behind th</span>e <strong>Complete Car</strong> (<strong>CC</strong>) <span>platform and how they sent the first message through RabbitMQ. This requires an introduction to two different types of exchanges: direct exchange, which delivers messages to a single queue, and topic exchange, which delivers messages to multiple queues based on pattern-matching routing keys.<br/></span></p>
<div class="DraftEditor-root">
<div class="DraftEditor-editorContainer">
<div class="public-DraftEditor-content">
<div class="sc-comment-editor-unstyled-block">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">To get the best start possible, following topics are covered:</p>
</div>
</div>
</div>
</div>
<ul>
<li>The application architecture behind CC</li>
<li>Establishing a connection to RabbitMQ</li>
<li>Sending the first messages</li>
<li>Adding topic messages</li>
</ul>
<p>Let's get started!</p>
<h1 id="uuid-f83fb836-e8e1-47ca-9bd7-37ac1aac744a"><span class="fontstyle0">Technical requirements</span></h1>
<p class="mce-root">The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter02">https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter02</a>.</p>
<h1 id="uuid-8162cb3d-a533-4d36-8524-2a2d77df58f0">The application architecture behind CC</h1>
<p>CC needs one application that is used by the taxi drivers and one that is used by the customer. The customer should be able to request a taxi via the application, and the taxi driver should be able to accept a request (the ride):</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-632 image-border" src="assets/9ef350c8-bc43-4d03-b857-8019b22db9a2.png" style="width:16.25em;height:7.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span class="ILfuVd">Fig 2.2: The customer requests a taxi via the CC application</span></div>
<p>The customer should be able to enter information about the starting point and the endpoint of the trip. Active drivers receive the requests and are able to accept them. The customer should, in the end, be able to follow the location of the taxi during the trip.</p>
<p class="mce-root">The following diagram shows the messaging architecture that CC wants to achieve:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-633 image-border" src="assets/74212d1d-1a7a-4c38-9195-fa1a97e55bd1.png" style="width:40.33em;height:18.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.3: CC's main application architecture</div>
<p>This flow can be explained in 10 steps, as highlighted in the preceding diagram:</p>
<ol>
<li>A customer uses CC's mobile application to book a taxi. A request is now sent from the mobile application to the Application Service. This request includes information about the trip that the customer wants to book.</li>
<li>The Application Service stores the request in a database.</li>
<li>The Application Service adds a message with information about the trip to a queue in RabbitMQ.</li>
<li>Connected taxi cars subscribe to the message (the booking request).</li>
<li>A taxi responds to the customer by sending a message back to RabbitMQ.</li>
<li>The Application Service subscribes to the messages.</li>
<li>Again, the Application Service stores the information in a database.</li>
<li>The Application Service forwards the information to the customer.</li>
<li><span>The taxi app starts to automatically send the taxi's geographical location at a given interval to RabbitMQ.</span></li>
<li><span>The location of the taxi is then passed straight to the customer's mobile application, via WebSockets, so that they know when the taxi arrives.</span></li>
</ol>
<p><span>Let's begin by taking a closer look at <em>steps</em></span> <em>1</em>, <em>2</em>, <em>3</em>, and <em>4</em>, as shown in the preceding diagram, where a customer requests a taxi (a message is published to RabbitMQ) and a taxi driver receives the request (a message is consumed from RabbitMQ).</p>
<h1 id="uuid-aaea0681-3be5-4e6a-acc5-77c87c8ef625">Establishing a solid connection to RabbitMQ</h1>
<p>As mentioned in <a href="">Chapter 1</a>, <em>A Rabbit Springs to Life</em>, a physical network connection must be established between the application servers and RabbitMQ. An <strong>Advanced Message Queuing Protocol</strong> (<strong>AMQP</strong>) connection is a link between the client and the broker that performs underlying networking tasks, including initial authentication, IP resolution, and networking:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-634 image-border" src="assets/e959981b-8e51-459f-adb4-f27147bf43aa.png" style="width:45.92em;height:11.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.4: AMQP connection between the application and RabbitMQ</div>
<p>Each AMQP connection maintains a set of underlying channels. A channel reuses a connection, forgoing the need to reauthorize and open a new TCP stream, making it more resource-efficient.</p>
<p>The following diagram illustrates a channel within a connection between an application and RabbitMQ:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-635 image-border" src="assets/43ce057b-af5f-4164-95ff-ee965b9a21b7.png" style="width:45.00em;height:11.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.5: Channels allow you to use resources more efficiently</div>
<p>Unlike creating channels, creating connections is a costly operation, very much like it is with database connections. Typically, database connections are pooled, where each instance of the pool is used by a single execution thread. AMQP is different in the sense that a single connection can be used by many threads through many multiplexed channels.</p>
<p>The handshake process for an AMQP connection requires at least seven TCP packets, and even more when using TLS. Channels can be opened and closed more frequently if needed:</p>
<ul>
<li>AMQP connections: 7 TCP packages</li>
<li>AMQP channel: 2 TCP packages</li>
<li>AMQP publish: 1 TCP package (more for larger messages)</li>
<li>AMQP close channel: 2 TCP packages</li>
<li>AMQP close connection: 2 TCP packages</li>
<li>Total 14-19 packages (plus Acks)</li>
</ul>
<p>The following diagram illustrates an overview of the information that's sent to connections and channels:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-992 image-border" src="assets/f23a471f-89ff-43ca-a643-e779f4492462.png" style="width:33.67em;height:9.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.6: The handshake process for an AMQP connection</div>
<p>Establishing a single long-lived connection between the Application Service and RabbitMQ is a good start.</p>
<p>A decision must be made regarding which programming language and client library to use. The first few examples in this book are written in Ruby, and the client library Bunny (<a href="https://github.com/ruby-amqp/bunny">https://github.com/ruby-amqp/bunny</a>) is used to publish and consume messages. Ruby is an easy language to read and understand, even if it is unfamiliar to you.</p>
<p>The application must be configured to use a certain connection endpoint, often referred to as a connection string; for example, a host and port. The connection string contains the information needed to be able to establish a connection. AMQP's assigned port number is <kbd>5672</kbd>. TLS/SSL-encrypted AMQP can be used via <span class="st">AMQPS; it's a secure version of the AMQP protocol that's assigned port</span> <kbd>5671</kbd>.</p>
<p>The library is the element that opens the TCP connection to the target IP address and port. The connection parameters have been added as a URI string to an environment variable to the code called <kbd>RABBITMQ_URI</kbd>. There is no URI standard for AMQP URIs, but this format is widely used:</p>
<pre> RABBITMQ_URI="amqp://user:password@host/vhost"</pre>
<p>According to the Ruby (Bunny) documentation, connecting to RabbitMQ is simple. The code for this is divided into code blocks, and can be found later in this chapter:</p>
<ol>
<li>Add the username, the password, and the <kbd>vhost</kbd> that were set up in <a href="">Chapter 1</a>, <em>A Rabbit Springs to Life</em>, and then add the string to an environment variable on the machine:</li>
</ol>
<pre style="padding-left: 60px">RABBITMQ_URI="amqp://cc-dev:taxi123@localhost/cc-dev-vhost"</pre>
<ol start="2">
<li>Require the <kbd>bunny</kbd> client library:</li>
</ol>
<pre style="padding-left: 60px"># Require client library<br/>require "bunny"</pre>
<ol start="3">
<li>Read the connection URI from the environment variable and start a connection:</li>
</ol>
<pre style="color: black;padding-left: 60px">connection = Bunny.new ENV['RABBITMQ_URI']<br/># Start a session with RabbitMQ <br/>connection.start</pre>
<p>This seems straightforward so far, but CC requires production-grade code that can gracefully handle failures. What if RabbitMQ is not running? Clearly, it is bad if the whole application is down. What if RabbitMQ needs to be restarted? CC wants its application to recover gracefully if any issues occur. In fact, CC wants its application to keep functioning, regardless of whether the whole messaging subsystem is working or not. The user experience must be smooth and easy to understand, as well as reliable.</p>
<p>In summary, the behavior CC wishes to achieve is as follows:</p>
<ul>
<li>If the connection to RabbitMQ is lost, it should reconnect by itself.</li>
<li>If the connection is down, sending or fetching messages should fail gracefully.</li>
</ul>
<p>When the application connects to the broker, it needs to handle connection failures. No network is reliable all the time and misconfigurations and mistakes happen; the broker might be down, and so on. While not automatic, in this case, error detection should happen early in the process.</p>
<p>To handle TCP connection failures in Bunny, it is necessary to catch the exception:</p>
<pre>begin<br/>  connection = Bunny.new ENV['RABBITMQ_URI']<br/>  connection.start<br/>rescue Bunny::TCPConnectionFailed =&gt; e<br/>  puts "Connection to server failed"<br/>end</pre>
<div>
<p>Detecting network connection failures is nearly useless if an application cannot recover from them. Recovery is an important part of error handling.</p>
<p>Some client libraries offer automatic connection recovery features that include consumer recovery. Any operation that's attempted on a closed channel will fail with an exception. If Bunny detects a TCP connection failure, it will try to reconnect every 5 seconds with no limit regarding the number of reconnection attempts. It is possible to disable automatic connection recovery by adding <kbd>automatic_recovery =&gt; false</kbd> to <kbd>Bunny.new</kbd>. This setting should only be used if you're reconnecting in some other way, or when testing the connection string.</p>
</div>
<div class="packt_infobox">
<p>Messages can be sent across languages, platforms, and <span class="st">operating systems</span>. You can choose from a number of different client libraries for different languages. There are lots of client libraries out there, but here are some that are recommended:</p>
<ul>
<li>Python: Pika</li>
<li>Node.js: amqplib</li>
<li>PHP: php-amqplib</li>
<li>Java: amqp-client</li>
<li>Clojure: Langohr</li>
</ul>
</div>
<p>This section has shown how CC manages to establish a connection to RabbitMQ. We demonstrated why a long-lived connection is recommended and how to handle some common errors. Now, it's time to create a channel inside the connection.</p>
<h2 id="uuid-cbb6ef6a-1245-458a-9549-6aff22c7ceb3">Working with channels</h2>
<p>Every AMQP protocol-related operation occurs over a channel. The channel instances are created by the connection instance. As described, a channel is a virtual (AMQP) connection inside the (TCP) connection. All operations performed by a client happen on a channel, queues are declared on channels, and messages are sent over channels.</p>
<p>A channel never exists on its own; it's always in the context of a connection:</p>
<pre># Declare a channel<br/>channel = connection.create_channel</pre>
<p><span>Channels in a connection are closed once the connection is closed or when a channel error occurs. Client libraries allow us to observe and react to channel exceptions.</span></p>
<p><span>More <strong>e</strong><strong>xceptions</strong> are usually thrown at a channel level than at the connection level.</span> Channel-level exceptions often indicate errors the application can recover from, such as, when it has no permissions, or when attempting to consume from a deleted queue. Any attempted operation on a closed channel will also fail with an exception. </p>
<div class="packt_tip">Even though channel instances are technically thread-safe, it is strongly recommended to avoid having several threads that are using the same channel concurrently.</div>
<p>CC is now able to connect to a RabbitMQ broker, open a channel, and issue a series of commands, all in a thread-safe and exception-safe manner. It's now time to build on this foundation!</p>
<h2 id="uuid-62ada928-2cf8-411a-a896-69d8f631b055">Building the taxi request tool</h2>
<p>Now, it's time to build the message flow.</p>
<p>First, the customer will send a simple HTTP request from the mobile application to the Application Service. This message will contain meta-information such as a timestamp, sender and receiver IDs, and the destination and requested taxi ID.</p>
<p>The message flow will look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-637 image-border" src="assets/c4c3407a-a481-4a0c-9d1c-6f0b2adb7b4c.png" style="width:60.42em;height:12.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.7: The frontend/backend interactions of CC's main application</div>
<p>The Application Service stores the information in a database so that all the data becomes visible for the d<span>ata analysis scripts in a later state</span>.</p>
<div class="packt_infobox">How the data is stored in the database is not handled in these examples since that's not the main case being followed in this chapter. The easiest method would be to allow the Application Service to add the information to the database. Another option is to offload the Application Service and put new messages into a message queue between the database and the Application Service and let another service subscribe to those messages and handle them; that is, store them in the database.</div>
<p>The flow between the mobile device, the Application Service, and RabbitMQ is illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-638 image-border" src="assets/09a3d121-718e-4fbc-86de-3f58c18094fa.png" style="width:69.33em;height:23.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.8: The flow between the mobile device, the Application Service, and RabbitMQ</div>
<p>Regarding our main flow, the discussion about AMQP in <a href="4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml">Chapter 1</a>, <em>A Rabbit Springs to Life</em>, detailed how messages are published to exchanges after being routed to queues to be consumed.</p>
<p>A routing strategy determines which queue (or queues) the message will be routed to. The routing strategy bases its decision on a routing key (a free-form string) and potentially on message meta-information. Think of the routing key as an address that the exchange uses to decide how the message should be routed. It also needs to be a binding between an exchange and the queue to enable a message to flow from the former to the latter.</p>
<p>Now, let's explore the direct exchange.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<h3 id="uuid-8a825bdb-29f4-4dc2-be32-18f49bb821c8">The direct exchange</h3>
<p>A direct exchange delivers messages to queues based on a message routing key. A message goes to the queue(s) whose bindings routine key matches the routing key of the message.</p>
<p>CC only has two cars, so it starts out with a simple communication system where one customer can request a taxi from one driver. In this case, one message needs to be routed to the queue acting as the inbox of that driver. Therefore, the exchange-routing strategy that will be used is a direct one, matching the destination queue name with the routing key used when the message is produced, as illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/40c44f43-019d-4d0d-8880-d292a31a6a19.jpg" style="width:88.17em;height:32.50em;"/></p>
<p class="mce-root"/>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.9: The direct exchange route messages to specific queues</div>
<p>An example use case of direct exchange could be as follows:</p>
<ol>
<li>The customer orders the taxi named <span class="packt_screen">taxi.1</span>. An HTTP request is sent from the customer's mobile application to the Application Service.</li>
<li>The Application Service sends a message to RabbitMQ with a routing key, <span class="packt_screen">taxi.1</span>. The message routing key matches the name of the queue, so the message ends up in the <span class="packt_screen">taxi.1</span> queue.</li>
</ol>
<p>The following diagram demonstrates how the direct exchange message routing would happen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1047 image-border" src="assets/71ddd244-042c-4d10-a2a0-af0476d1a2cd.png" style="width:124.08em;height:45.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.10: The direct exchange routing messages to specific queues based on the routing key</div>
<p>This may not be the most efficient approach to scale. In fact, it will be reviewed as soon as CC has more cars, but it's the easiest way to get started and <span>launch the application fast.</span></p>
<p>Let's follow the first code CC creates as the initial application and learn about the different concepts at the same time. The code at the beginning of the code block has been taken from the connection and channel section:</p>
<ol>
<li>Require the <kbd>bunny</kbd> client library.</li>
<li>Read the <kbd>URI</kbd> connection from the environment variable and start a connection.</li>
<li>Start a communication session with RabbitMQ.</li>
<li>Declare the <kbd>taxi.1</kbd> queue.</li>
<li>Declare the <kbd>taxi.1</kbd> direct exchange.</li>
<li>Bind the <kbd>taxi.1</kbd> queue to the <kbd>taxi-direct</kbd> exchange with the <kbd>taxi.1</kbd> routing key:</li>
</ol>
<pre style="padding-left: 60px"># 1. Require client library<br/>require "bunny"<br/><br/># 2. Read RABBITMQ_URI from ENV<br/>connection = Bunny.new ENV["'RABBITMQ_URI"]<br/><br/># 3. Start a communication session with RabbitMQ<br/>connection.start<br/>channel = connection.create_channel<br/><br/>def on_start(channel)<br/> # 4. Declare a queue for a given taxi<br/> queue = channel.queue("taxi.1", durable: true)<br/> # 5. Declare a direct exchange, taxi-direct<br/> exchange = channel.direct("taxi-direct", durable: true, auto_delete: true)<br/><br/> # 6. Bind the queue to the exchange<br/> queue.bind(exchange, routing_key: "taxi.1")<br/><br/> # 7. Return the exchange<br/> exchange<br/>end<br/><br/>exchange = on_start(channel)                  </pre>
<p>It's a bit of an overkill and unnecessary to declare queues and exchanges for every message that's sent, so it's highly recommended to create a method that handles the setup of the application. This should be a method that creates the connection and declares queues, exchanges, and so on. The method in this example is simply called <kbd>on_start</kbd>, which declares the queue and binds an exchange to the queue.</p>
<p>If the exchange doesn't exist when something is published to it, it will raise exceptions. If the exchange already exists, it will do nothing; otherwise, it will actually create one. This is why it's safe to declare queues every time the application starts or before publishing a message.</p>
<div class="packt_tip">Channels are killed by exceptions. In CC's case, sending to a nonexistent exchange would not only raise an exception, but it would also terminate the channel where the error occurred. Any subsequent code that tries to use the terminated channel will fail as well.</div>
<p>In addition to using the direct type, CC has configured the <kbd>durable</kbd> type, <kbd>autoDelete</kbd>, and the <kbd>argument</kbd> properties of the exchange. This exchange should not go away after a restart of RabbitMQ, nor when it's unused, which explains the values used in the configuration.</p>
<div class="packt_tip">An exchange declaration is only idempotent if the exchange properties are the same. Trying to declare an already-existing exchange with different properties will fail. Always use consistent properties in an exchange declaration. If you're making a change to the properties, delete the exchange before declaring it with the new properties. The same rule applies to a queue declaration.</div>
<p>After creating the exchange, the taxi queue is created and bound to it.</p>
<p>The queue is declared with a similar approach to an exchange, but with slightly different properties, as follows:</p>
<ul>
<li><kbd>durable</kbd>: True <span>–</span> the queue must stay declared, even after a broker restart.</li>
<li><kbd>autoDelete</kbd>: False <span>–</span> keep the queue, even if it's not being consumed anymore.</li>
<li><kbd>exclusive</kbd>: False <span>–</span> this queue should be able to be consumed by other connections (several application servers can be connected to RabbitMQ and accessed from different connections).</li>
<li><kbd>arguments</kbd>: Null <span>–</span> no need to custom configure the queue.</li>
</ul>
<p>The queue is bound to the exchange using its own name as the routing key so that the direct routing strategy can route messages to it. When this is done, publishing messages to the <kbd>taxi-direct</kbd> exchange will actually deliver messages to the taxi queue whose name matches the published routing key.</p>
<div class="packt_infobox">
<p>If no queue is bound to an exchange, or if the routing strategy can't find a matching destination queue, the message that was published to the exchange will be discarded silently. As an option, it is possible to be notified when unroutable messages are discarded, as shown in subsequent chapters.</p>
</div>
<p>Again, when the same properties are used, these operations are idempotent, so the queue can safely be declared and bound to the exchange, again and again</p>
<p>Although direct exchange has been covered in this chapter, AMQP 0-9-1 brokers provide four different types of exchanges. Depending on the binding setups you have between queues and parameters, these exchanges route messages differently. The upcoming chapters look closer at the other types of exchanges. For now, here is a short explanation of each:</p>
<ul>
<li><strong>Fanout</strong>: Messages are routed to all queues bound to the fanout exchange.</li>
<li><strong>Topic</strong>: Wildcards must form a match between the routing key and the binding's specific routing pattern.</li>
<li><strong>Headers</strong>: Use the message header attributes for routing.</li>
</ul>
<p>Now, it's time to send our first message to RabbitMQ!</p>
<h1 id="uuid-595f0f84-c100-446e-81e1-9524cc214791">Sending the first messages</h1>
<p>The basic concept and initial setup has already been covered, so let's jump in and send the first messages!</p>
<p>First, let's take a look at the <kbd>order_taxi</kbd> method, which is in charge of sending messages for the initial car request:</p>
<pre>def order_taxi(taxi, exchange)<br/>  payload = "example-message"<br/>  message_id = rand<br/> exchange.publish(payload,<br/>    routing_key: taxi,<br/>    content_type: "application/json",<br/>    content_encoding: "UTF-8",<br/>    persistent: true,<br/>    message_id: message_id)<br/>end<br/><br/>exchange = on_start(channel)<br/>order_taxi("taxi.1", exchange)</pre>
<p><kbd>order_taxi</kbd> is going to be called every time a user wants to order a taxi. There is no guarantee that the addressee has ever logged into the system, so as far as the sender is concerned, it's impossible to be sure the destination queue exists. The safest path is to declare the queue on every message sent, bearing in mind that this declare operation is idempotent, so it will not do anything if the queue already exists. This may seem strange at first, but it's the sender's responsibility to ensure the addressee's queue exists if they want to be sure the message will not get lost.</p>
<div class="packt_infobox">
<p>This is a common pattern with AMQP when there is no strong <strong>happens-before</strong> relationship between events. <strong>Re-declaration</strong> is the way to go. Conversely, the <strong>check</strong>-<strong>then</strong>-<strong>act</strong> pattern is discouraged; trying to check the pre-existence of an exchange or a queue does not guarantee success in the typical distributed environment where AMQP is used.</p>
</div>
<p>The method for publishing a message is very simple; call <kbd>publish</kbd> toward the <kbd>exchange</kbd>. Then, use the queue name as the routing key (as per the <strong>direct</strong> routing) and an array of bytes that represent the actual message payload. It's possible to add some optional message properties, which could include the following:</p>
<ul>
<li><kbd>content_type</kbd> (<strong>string</strong>): A message is published and consumed as a byte array, but nothing really says what these bytes represent. In the current situation, both publishers and consumers are in the same system, so it could be assumed that the content type is expected. That being said, always specify the content type so that messages are self-contained; whichever system ends up receiving or introspecting a message will know for sure what the byte array it contains represents.</li>
<li><span class="packt_screen"><span class="name"><kbd>content_encoding</kbd></span></span> (<strong>string</strong>): A specific encoding (UTF-8) is used when serializing string messages into byte arrays so that they can be published. Again, in order for the messages to be self-explicit, provide all the necessary meta-information to allow them to be read.</li>
<li><span class="packt_screen"><span class="name"><kbd>message_id</kbd></span></span> (<strong>string</strong>): As demonstrated later in this book, message identifiers are an important aspect of traceability in messaging and distributed applications. In the example is a random message id generated.</li>
<li><span class="packt_screen"><span class="name"><kbd>persistent</kbd></span></span> (<strong>boolean</strong>): Specifies if the message should be persisted to disk or not.</li>
</ul>
<div class="packt_tip">Do not confuse exchange and queue durability with message persistence; non-persistent messages stored in a durable queue will be gone after a broker restart, leaving you with an empty queue.<br/>
<br/>
Additionally, persistent messages in a non-persistent queue will be gone after a broker restart, also leaving you with an empty queue.<br/>
<br/>
Ensure that messages are not lost by declaring a queue as <strong>durable</strong> and setting the message delivery mode to <strong>persistent.</strong></div>
<p>But what would happen if sending the message fails, such as when the connection with RabbitMQ is broken?</p>
<div class="packt_infobox">Why would you ever use a non-persistent delivery mode? Isn't the whole point of a message broker such as RabbitMQ to guarantee that messages aren't lost? This is true, but there are circumstances where this guarantee can be relaxed. Consider a scenario where a publisher bombards the broker with a lot of non-critical messages. <span>Using a non-persistent delivery here would mean that RabbitMQ wouldn't need to constantly access the disk, thus providing better performance in this case.</span></div>
<p>Before going any further, let's take a look at the structure of an AMQP message.</p>
<h2 id="uuid-17999bb0-4402-4ede-acf6-2c7ef69ec6db">AMQP message structure</h2>
<p>The following screenshot illustrates the structure of an AMQP message and includes the four AMQP message properties just used, plus a few new ones. Note that this diagram uses the specification name of the fields and that each language implementation renames them slightly so that they can be valid names. For example, <kbd>content-type</kbd> becomes <kbd>contentType</kbd> in Java, and <kbd>content_type</kbd> in Ruby:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-640 image-border" src="assets/9b3fe337-567a-459c-97b3-1226398fa7dd.png" style="width:15.17em;height:24.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.11: Properties of an AMQP message</div>
<p>Except for <kbd>reserved</kbd>, all these properties are free to use and, unless otherwise specified, are ignored by the AMQP broker. In the case of RabbitMQ, the only field that is supported by the broker is the <kbd>user-id</kbd> field, which is validated to ensure it matches the name of the broker user that established the connection. Notice how the <kbd>headers</kbd> property allows us to add extra key-value pairs in case none of the standard properties fit the requirements.</p>
<p>The next section explains how messages are consumed.</p>
<h2 id="uuid-5b96e4b3-299b-4cc6-9fbb-6db7065d2c83">Consuming messages</h2>
<p>Now, let's turn our attention to the method in charge of retrieving messages, which is <em>step 4</em> in the main architecture of CC, which can be found in the <em>The application architecture behind CC </em>section.</p>
<p><span>Here, the taxi application can check the queue for new messages at a regular interval. This is a so-called synchronous approach.</span> This would mean holding the application thread in charge of dealing with the poll requests until all pending messages have been removed from the queue, as illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-911 image-border" src="assets/2c2137d3-3784-4d43-90d1-4ce304c5d344.png" style="width:122.67em;height:41.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.12: A client asking for new messages in the broker</div>
<p>A frontend regularly polling the backend for messages would soon start to take its toll in terms of load, meaning that the overall solution would begin to suffer from performance degradation. </p>
<p><span>Instead, CC wisely decides to build the solution in favor of a</span> server-push <span>approach. The idea is to server-push messages to the clients from the broker.</span> Luckily, RabbitMQ offers two ways to receive messages: there's the polling-based <kbd>basic.get</kbd> method and the push-based <kbd>basic.consume</kbd> method. As illustrated in the following diagram, messages are pushed to the consumer:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img class="aligncenter size-full wp-image-912 image-border" src="assets/152412b4-01d6-4e4a-ac95-e9fc397b1f52.png" style="width:123.17em;height:36.75em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 2.13: Consumer subscribing messages from the broker</div>
<p><span>The</span> <kbd>subscribe</kbd> method <span>adds a consumer to the queue, which then subscribes to receive message deliveries.</span></p>
<div class="packt_tip">Make sure that the consumer consumes messages from the queue instead of using basic GET actions. The <kbd>basic.get</kbd> command is comparatively expensive when it comes to resources.</div>
<p>With <kbd>subscribe</kbd>, the messages are delivered to the client from the broker when new messages are ready and the client has availability. This allows, in general, the smooth processing of messages. Additionally, using <kbd>subscribe</kbd> means that a consumer is connected as long as the channel it was declared on is available or until the client cancels it.</p>
<p>The message process is running smoothly and effortlessly, almost as if nothing is happening! That is, of course, until alerts are set in motion to acknowledge and/or negative acknowledge whether a part of the process has run as expected, or not as planned.</p>
<h3 id="uuid-41afb830-e4c8-4255-8361-287120f67225">Acknowledgment and <span class="ILfuVd"><span class="e24Kjd">negative acknowledgment<br/></span></span></h3>
<p>RabbitMQ needs to know when a message can be considered <strong>successful</strong> in terms of being sent to the consumer as expected. The broker should then delete messages from the queue once the broker receives the response; otherwise, the queue would overflow. The client can reply to the broker by either acking (acknowledge) the message when it receives it or when the consumer has completely processed the message. In either situation, once the message has been ack:ed, it's removed from the queue.</p>
<p>Therefore, it's up to the consumer to acknowledge a message if and only if it is done with processing, or if it is certain that there is no risk of losing the message if it is processed asynchronously.</p>
<p>To avoid a situation where a message could be forever lost (for example, worker crashed, exceptions, and so on), the consuming application should not acknowledge a message until it is completely finished with it.</p>
<p>A message is rejected by an application when the application indicates to the broker that processing has failed or cannot be accomplished at the time. Nack, or negative-acknowledge, tells RabbitMQ that a message was not handled as instructed. Nack'ed messages, by default, are sent back to the queue for another try.</p>
<p>Acknowledges will be covered in detail in <a href="4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml">Chapter 3</a>, <em>Sending Messages to Multiple Taxi Drivers</em>.</p>
<p>Ready? Set? Time to RUN, Rabbit!</p>
<h3 id="uuid-cbb1c63a-b396-41a3-a722-d08c57953136">Running the code</h3>
<p class="mce-root">Now, it's time to set up some code for the consumer. You'll be able to recognize most of this code from the previous section, <em>Sending the first messages:</em></p>
<ol>
<li>Require client libraries.</li>
<li>Read <kbd>RABBITMQ_URI</kbd> from <kbd>ENV</kbd>.</li>
<li>Start a communication session with RabbitMQ.</li>
<li>Declare a queue for a given taxi.</li>
<li>Declare a direct exchange, <kbd>taxi-direct</kbd>.</li>
<li>Bind the queue to the exchange.</li>
<li>Subscribe to the queue.</li>
</ol>
<p>What follows is the code that's required for the initial consumer setup:</p>
<pre># example_consumer.rb<br/># 1. Require client library<br/>require "bunny"<br/><br/># 2. Read RABBITMQ_URI from ENV<br/>connection = Bunny.new ENV["RABBITMQ_URI"]<br/><br/># 3. Start a communication session with RabbitMQ<br/>connection.start<br/>channel = connection.create_channel<br/><br/># Method for the processing<br/>def process_order(info)<br/><br/>  puts "Handling taxi order"<br/>  puts info<br/>  sleep 5.0<br/>  puts "Processing done"<br/>end<br/><br/>def taxi_subscribe(channel, taxi)<br/>  # 4. Declare a queue for a given taxi<br/>  queue = channel.queue(taxi, durable: true)<br/><br/>  # 5. Declare a direct exchange, taxi-direct<br/>  exchange = channel.direct("taxi-direct", durable: true, auto_delete: true)<br/><br/>  # 6. Bind the queue to the exchange<br/>  queue.bind(exchange, routing_key: taxi)<br/><br/>  # 7. Subscribe from the queue<br/>  queue.subscribe(block: true, manual_ack: false) do |delivery_info, properties, payload|<br/>    process_order(payload)<br/>  end<br/>end<br/><br/>taxi = "taxi.1"<br/>taxi_subscribe(channel, taxi)                            </pre>
<p>Here, two flags were added to the <kbd>subscribe</kbd> method that need to be explained. Let's look at them in detail:</p>
<ul>
<li><span class="default"><kbd>block</kbd> (Boolean, default <kbd>false</kbd>): Should the call block the calling thread? This option can be useful for keeping the main thread of a script alive. It is incompatible with automatic connection recovery and is not generally recommended.</span></li>
<li><kbd>manual_ack</kbd> (Boolean, default <kbd>false</kbd>): In CC's case, since the risk of losing a message is acceptable during this phase, the system does not manually acknowledge messages. Instead, it informs the broker to consider them as acknowledged as soon as it fetches them (more on manual acknowledgment later in this book).</li>
</ul>
<p>And that's it! CC now has a working order request inbox ready to be tested. Next, we'll look at the management console when activated taxis are running.</p>
<h2 id="uuid-e3e34327-8acf-443f-8f05-1710ce533dbd">Running the application</h2>
<p>With the application running and a server connected to RabbitMQ, the following established connections can be seen from the management console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-641 image-border" src="assets/90a38a53-a625-4f9f-a15f-b3a8c4ff7c1a.png" style="width:167.50em;height:76.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.14: The management console provides connection information</div>
<p>Notice how the upstream and downstream network throughputs are clearly represented, and that the channels that get opened and closed very quickly are hard to see from the management console. So, let's look at the following exchanges:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-913 image-border" src="assets/91175a73-136f-44c6-b528-217c23549537.png" style="width:67.83em;height:39.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.15: The taxi-direct direct exchange showing up in the management console</div>
<p>The user exchange and the rate of messages coming in and out are shown in the management console. The fact that they are being consumed as fast as they come in is a good sign that the current architecture is sufficient for CC's needs and that messages are not piling up. But what are all these other exchanges that haven't been created by code and where are they coming from? The nameless exchange represented as (<span class="packt_screen">AMQP default</span>) and all the exchanges with names that start with <span class="packt_screen">amq.</span> are defined by the AMQP specification and, as such, must be provided by default by RabbitMQ. Now, what about queues? Let's have a look:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-914 image-border" src="assets/9e8a32d8-41e2-46fc-a8fb-79fd4cb2acb1.png" style="width:137.17em;height:67.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.16: Each client-to-taxi inbox queue is visible in the management console</div>
<p>As expected, there is one queue per taxi and some nifty usage statistics. Notice how the <span class="packt_screen">ack</span> column is empty, which is no surprise, given how message acknowledgment works. The queue is receiving messages while letting RabbitMQ know it won't be acknowledging them, so there is no activity related to acknowledging messages.</p>
<div class="packt_tip"><br/>
With enough RAM, RabbitMQ can deal with hundreds of queues and bindings without a problem, so multiple queues are not an issue.</div>
<p>Confident about its architecture and implementation, CC rolls out the client-to-taxi ordering subsystem. The client can send the request and the taxi can handle the request.</p>
<p>CC quickly expands the company with two new environmentally friendly cars. As in the previous solution, a client needs to send an order request message to a certain driver. Now, a new feature was requested <span>–</span> the capacity to send a message to a group of taxi cars. It should be possible for clients to select a normal taxi or an environmentally friendly taxi. Let's see how CC will implement this new feature through the power of RabbitMQ.</p>
<p class="mce-root"/>
<h1 id="uuid-4d209714-aa6f-46e5-adf7-4ac9094ef70e">Adding topic messages</h1>
<p>CC's application allows its taxis to organize themselves into groups by registering their topics of interest. The new feature to roll out will allow clients to send an order request to all taxis within a particular topic. It turns out that this feature matches a specific exchange routing rule, not surprisingly called topic! This type of exchange allows us to route the message to all the queues that have been bound with a routing key matching the routing key of the message. So, unlike the direct exchange that routes a message to one queue maximum, the topic exchange can route it to multiple queues. Two other examples of where topic-based routing could be applied are to location-specific data, such as traffic warning broadcasts, or to trip price updates.</p>
<div class="packt_infobox">
<p>A routing pattern consists of several words separated by dots. A best practice to follow is to structure routing keys from the most general element to the most specific one, such as <span><kbd>news.economy.usa</kbd> </span><span>or <kbd>europe.sweden.stockholm</kbd>.<br/></span><span>The topic exchange supports strict routing key matching and will also perform wildcard matching using </span><kbd>*</kbd> <span>and</span> <kbd>#</kbd> <span>as placeholders for exactly one word and zero or more words, respectively.</span></p>
</div>
<p>The following diagram illustrates how the topic exchange will be used in CC's application. Notice how the single inbox queue remains unchanged and simply gets connected to the topic exchange via extra bindings, each of them reflecting the interest of a user:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-644 image-border" src="assets/3f964e6f-517b-466a-a0eb-9965c3fb05a2.png" style="width:68.33em;height:29.67em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 2.17: The topic exchange sending thematic messages to eco queues</div>
<p>Because the same inbox is used for everything, the code that's already in place for fetching messages doesn't need to be changed. In fact, this whole feature can be implemented with only a few additions. The first of these additions takes care of declaring the topic exchange in the existing <kbd>on_start</kbd> method, as follows:</p>
<pre>def on_start(channel)<br/>  # Declare and return the topic exchange, taxi-topic<br/>  channel.topic("taxi-topic", durable: true, auto_delete: true)<br/>end</pre>
<p>There's nothing really new or fancy here; the main difference is that this exchange is called <kbd>taxi-topic</kbd> and is a <kbd>topic</kbd> type of exchange. Sending a message is even simpler than with the client-to-taxi feature because there is no attempt to create the addressee's queue. It wouldn't make sense for the sender to iterate through all the users to create and bind their queues, as only users already subscribed to the target topic at the time of sending will get the message, which is exactly the expected functionality. The <kbd>order_taxi</kbd> method is listed here:</p>
<pre># Publishing an order to the exchange<br/>def order_taxi(type, exchange)<br/>  payload = "example-message"<br/>  message_id = rand<br/>  exchange.publish(payload,<br/>                   routing_key: type,<br/>                   content_type: "application/json",<br/>                   content_encoding: "UTF-8",<br/>                   persistent: true,<br/>                   message_id: message_id)<br/>end<br/><br/>exchange = on_start(channel)<br/># Order will go to any eco taxi<br/>order_taxi('taxi.eco', exchange) <br/># Order will go to any eco taxi<br/>order_taxi('taxi.eco', exchange) <br/># Order will go to any taxi<br/>order_taxi('taxi', exchange) <br/># Order will go to any taxi<br/>order_taxi('taxi', exchange) </pre>
<p>The difference is that, now, messages are published to the <kbd>taxi-topic</kbd> exchange. The rest of the code that creates and publishes the message is exactly the same as the client-to-taxi messaging. Lastly, information needs to be added when a new taxi subscribes or unsubscribes from certain topics:</p>
<pre># example_consumer.rb<br/><br/>def taxi_topic_subscribe(channel, taxi, type)<br/>  # Declare a queue for a given taxi<br/>  queue = channel.queue(taxi, durable: true)<br/><br/>  # Declare a topic exchange<br/>  exchange = channel.topic('taxi-topic', durable: true, auto_delete: true)<br/><br/>  # Bind the queue to the exchange<br/>  queue.bind(exchange, routing_key: type)<br/><br/>  # Bind the queue to the exchange to make sure the taxi will get any order<br/>  queue.bind(exchange, routing_key: 'taxi')<br/><br/>  # Subscribe from the queue<br/>  queue.subscribe(block:true,manual_ack: false) do |delivery_info, properties, payload|<br/>    process_order(payload)<br/>  end<br/>end<br/><br/>taxi = "taxi.3"<br/>taxi_topic_subscribe(channel, taxi, "taxi.eco.3")</pre>
<p><kbd>taxi.3</kbd> is the new environmentally friendly taxi, now ready to receive orders from clients that want an environmentally friendly car.</p>
<p>The AMQP specification does not provide any means to introspect the current bindings of a queue, so it is not possible to iterate them and remove the ones not needed anymore in order to reflect a change in a taxi's topics of interest. This is not a terrible concern because the application is required to maintain this state anyway.</p>
<div class="mce-root packt_infobox">The RabbitMQ management console exposes a REST API that can be used to perform queue binding introspection, among many other features not covered by the AMQP specification. More about that in upcoming chapters.</div>
<p>With this new code in place, everything works as expected. No code changes are needed to retrieve the new client-to-taxi orders because they arrive in the same inbox queue as the previous messages. Topical messages are sent and received correctly by the taxi cars, and all this happens with a minimal change and no increase in the number of queues. When connected to the management console, click on the <span class="packt_screen">Exchanges</span> tab; the only visible difference is the new exchange topic; that is, <kbd>taxi-topic</kbd>.</p>
<h1 id="uuid-114f2c3d-1300-4725-9c7a-1ef1b0096607">Summary</h1>
<p>This chapter covered how to connect to RabbitMQ and how to send and receive order messages. The car order system was successfully created, and direct and topic exchanges were put in motion in the context of CC's client-to-taxi and client-to-taxis features.</p>
<p>As Complete Car grows, so does the demand for new features in the taxi application. What's next for CC as it meets user demand? The next chapter explains how to work with channels and queues to expand the features of the app.</p>


            </article>

            
        </section>
    </body></html>