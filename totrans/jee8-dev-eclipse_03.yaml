- en: Creating JEE Database Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to use source control management software
    from Eclipse. Specifically, we learned how to use SVN and Git from Eclipse. In
    this chapter, we will get back to discussing JEE application development. Most
    web applications today require access to the database. In this chapter, we will
    learn two ways to access databases from JEE web applications: using JDBC APIs,
    and using JPA APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: JDBC4 has been part of JDK since version 1.1\. It provides uniform APIs to access
    different relational databases. Between JDBC APIs and the database sits the JDBC
    driver for that database (either provided by the vendor of the database or a third-party
    vendor). JDBC translates common API calls to database-specific calls. The results
    returned from the database are also converted into objects of common data access
    classes. Although JDBC APIs require you to write a lot more code to access the
    database, it is still popular in JEE web applications because of its simplicity,
    flexibility of using database-specific SQL statements, and low learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: JPA is the result of **Java Specification Request** 220 (which stands for **JSR**).
    One of the problems of using JDBC APIs directly is converting object representation
    of data to relation data. Object representation is in your JEE application, which
    needs to be mapped to tables and columns in the relational database. The process
    is reversed when handling data returned from the relational database. If there
    is a way to automatically map object-oriented representation of data in web applications
    to relational data, it would save a lot of developer time. This is also called
    **object-relational mapping** (**ORM**). Hibernate ([http://hibernate.org/](http://hibernate.org/))
    is a very popular framework for ORM in Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the concepts of such popular third-party ORM frameworks were incorporated
    in JPA. Just as JDBC provides uniform APIs for accessing relational databases,
    JPA provides uniform APIs for accessing ORM libraries. Third-party ORM frameworks
    provide implementations of JPA on top of their own framework. The JPA implementation
    may use the JDBC APIs underneath.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore many features of JDBC and JPA in this chapter as we build applications
    using these frameworks. In fact, we will build the same application, once using
    JDBC and then using JPA.
  prefs: []
  type: TYPE_NORMAL
- en: The application that we are going to build is for student-course management.
    The goal is to take an example that can show how to model relationships between
    tables and use them in JEE applications. We will use a MySQL database and Tomcat
    web application container. Although this chapter is about database programming
    in JEE, we will revisit some of the things we learned about JSTL and JSF in [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. We will use them to create user interfaces for our database
    web application. Make sure that you have configured Tomcat in Eclipse as described
    in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Core JDBC concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JDBC to access the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JDBC connection pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core JPA concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JPA to map entities (classes) to tables in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring relationships between JPA entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first create a database and tables for this application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways of creating database tables and relationships in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use **data description language** (**DDL**) statements directly at MySQL
    Command Prompt from the Terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use MySQL Workbench and create tables directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create an entity-relationship diagram in MySQL Workbench, export it
    to create a DDL script, and then run this script to create tables and relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the third option. If you just want to get the script to create tables
    and want to skip creating the ER diagram, then jump to the *Script to create tables
    and relationships* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not already installed MySQL and MySQL Workbench, then refer to
    [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse*, for instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open MySQL Workbench. Select the File | New Model menu. A blank model will
    be created with the option to create ER diagrams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Creating a new MySQL Workbench model'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the Add Diagram icon; a blank ER diagram will be opened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Creating a new ER diagram'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the new schema is named `mydb`. Double-click on it to open properties
    of the schema. Rename the schema`course_management`:![](img/00095.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.3: Renaming the schema'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hover over the toolbar buttons on the left-hand side of the page, and you will
    see tool tips about their functions. Click on the button for a new table and then
    click on the blank page. This will insert a new table with the name `table1`.
    Double-click the table icon to open the Properties page of the table. In the Properties
    page, change the name of the table to `Course`:![](img/00096.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.4: Creating a table in ER diagram'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will now create columns of the table. Double-click on the first column and
    name it id. Check the PK (**primary key**), NN (**not null**), and AI (**auto
    increment**) checkboxes. Add other columns as shown in the following screenshot:![](img/00097.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.5: Creating columns in a table in the ER diagram'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Create other tables, namely `Student` and `Teacher`, as shown in the following
    screenshot:![](img/00098.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.6: Creating additional tables'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that if you want to edit column properties of any table, then double-click
    the table in the ER diagram. Just selecting a table by a single click would not
    change the table selection in the Properties page. All columns in all tables are
    required (not null), except the `last_name` column in `Student` and `Teacher`
    tables.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will now create relationships between the tables. One course can have many
    students, and students can take many courses. So, there is a many-to-many relationship
    between `Course` and `Student`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will assume that one course is taught by only one teacher. However, a teacher
    can teach more than one course. Therefore, there is a many-to-one relationship
    between `Course` and `Teacher`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now model these relationships in the ER diagram:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we will create a non-identifying relationship between `Course` and `Teacher`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the non-identifying one-to-many button in the toolbar (dotted lines
    and 1:n).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the `Course` table first and then on the `Teacher` table. It
    will create a relationship as shown in *Figure 4.7*. Note that a foreign key `Teacher_id`
    is created in the `Course` table. We don't want to make a `Teacher_id` field required
    in `Course`. A course can exist without a teacher in our application. Therefore,
    double-click on the link joining `Course` and `Teacher` tables.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the Foreign Key tab.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Referenced Table side, uncheck the Mandatory checkbox:![](img/00099.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.7: Creating a one-to-many relationship between tables'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creation of a many-to-many relationship requires a link table to be created.
    To create a many-to-many relationship between `Course` and `Student`, click on
    the icon for many-to-many (n:m) and then click on the `Course` table and `Student`
    table. This will create a third table (link table) called `Course_has_Student`.
    We will rename this table `Course_Student`. The final diagram is as shown in the
    following screenshot:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.8: ER diagram for the course management example'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Follow these steps to create DDL scripts from the ER diagram:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the File | Export | Forward Engineer SQL Create Script... menu.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the SQL Export Options page, select checkboxes for two options:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate DROP Statements Before Each CREATE Statement
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate DROP SCHEMA
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the Output SQL Script File path if you want to save the script.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the last page of the Export wizard, you will see the script generated by
    MySQL Workbench. Copy this script by clicking the Copy to Clipboard button.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Script to create tables and relationships
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the DDL script to create tables and relationships for the
    course management example:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Creating tables in MySQL
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now create tables and relationships in the MySQL database by using the
    script created in the previous section.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure that MySQL is running and there is an open connection to the server
    from MySQL Workbench (see [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*, for more details):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new query tab (the first button in the toolbar) and paste the preceding
    script.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the query.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the execution, refresh schemas in the left-hand pane. You should
    see the course_management schema and the tables created in it.![](img/00101.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.9: MySQL schema for the course management example'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a database application using JDBC
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use JDBC to create a simple course management web application.
    We will use the MySQL schema created in the previous section. Furthermore, we
    will create the web application using Tomcat; we have already seen how to create
    one in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*. We have also learned how to use JSTL and JSF in
    the same chapter. In this section, we will use JSTL and JDBC to create the course
    management application, and in the next section, we will use JSF and JPA to create
    the same application. We will use Maven (as described in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*) for project management, and of course,
    our IDE is going to be Eclipse JEE.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a project and setting up Maven dependencies
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will perform the following steps to create the Maven project for our application:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Maven web project as described in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `CourseManagementJDBC`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add dependencies for servlet and JSP, but do not add a dependency for JSF.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To add the dependency for JSTL, open `pom.xml` and go to the Dependencies tab.
    Click on the Add... button. Type `javax.servlet` in the search box and select
    jstl:![](img/00102.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.10: Adding a dependency for jstl'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the dependency for the MySQL JDBC driver too:![](img/00103.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.11: Adding dependency for the MySQL JDBC driver'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the `pom.xml` file after adding dependencies:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that the dependencies for servlet and JSP are marked as provided, which
    means that they will be provided by the web container (Tomcat) and will not be
    packaged with the application.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The description of how to configure Tomcat and add a project to it is skipped
    here. Refer to [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, for these details. This section will
    also not repeat information on how to run JSP pages and about JSTL that were covered
    in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating JavaBeans for data storage
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We will first create JavaBean classes for `Student`, `Course`, and `Teacher`.
    Since both student and teacher are people, we will create a new class called `Person`
    and have `Student` and `Teacher` classes extend it. Create these JavaBeans in
    the `packt.book.jee.eclipse.ch4.beans` package as follows.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code for the `Course` bean will be as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The code for the `Person` bean will be as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The code for the `Student` bean will be as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Teacher` bean will be as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Creating JSP to add a course
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now create a JSP page to add new courses. Right-click on the project in
    Package Explorer and select the New | Other... option. Type `jsp` in the filter
    box and select JSP File. Name the file `addCourse.jsp`. Eclipse will create the
    file in the `src/main/webapp` folder of the project.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the following code in `addCourse.jsp`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Most of the code should be familiar, if you have read [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application* (see the *Using JSTL *section). We have
    a form to add courses. At the top of the file, we check whether the `post` request
    is made; if so, store content of the form in `courseBean` (make sure that names
    of the `form` field are the same as the members defined in the bean). The new
    tag that we have used here is `<c:catch>`. It is like a *try-catch* block in Java.
    Any exception thrown from within the body of `<c:catch>` is assigned to the variable
    name declared in the `var` attribute. Here, we are not doing anything with `beanStorageException`;
    we are suppressing the exception. When an exception is thrown, the `credits` field
    of the `Course` bean will remain set to zero and it will be caught in the `courseBean.isValidCourse`
    method. If the course data is valid, then we redirect the request to the `listCourse.jsp`
    page using the JSTL `<c:redirect>` tag.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to add the `isValidCourse` method in the `Course` bean. Therefore,
    open the class in the editor and add the following method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to create `listCourse.jsp`. For now, just create a simple JSP
    with no JSTL/Java code and with only one header in the `body` tag:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on `addCourse.jsp` in Package Explorer and select Run As | Run on
    Server. If you have configured Tomcat properly and added your project in Tomcat
    (as described in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*), then you should see the JSP page running
    in the internal Eclipse browser. Test the page with both valid and invalid data
    (a wrong credit value; for example, a non-numeric value). If the data entered
    is valid, then you would be redirected to `listCourse.jsp`, or else the same page
    would be displayed with the error message.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Before we start writing JDBC code, let's learn some fundamental concepts of
    JDBC.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: JDBC concepts
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before performing any operations in JDBC, we need to establish a connection
    to the database. Here are some of the important classes/interfaces in JDBC for
    executing SQL statements:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| **JDBC class/interface** | **Description** |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `java.sql.Connection` | Represents the connection between the application
    and the backend database. Must for performing any action on the database. |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `java.sql.DriverManager` | Manages JDBC drivers used in the application.
    Call the `DriverManager.getConnection` static method to obtain the connection.
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `java.sql.Statement` | Used for executing static SQL statements. |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `java.sql.PreparedStatement` | Used for preparing parameterized SQL statements.
    SQL statements are pre-compiled and can be executed repeatedly with different
    parameters. |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `Java.sqlCallableStatement` | Used for executing a stored procedure. |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `java.sql.ResultSet` | Represents a row in the database table in the result
    returned after execution of an SQL query by `Statement` or `PreparedStatement`.
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: You can find all the interfaces for JDBC at [http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html](http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Many of these are interfaces, and implementations of these interfaces are provided
    by the JDBC drivers.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating database connections
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that the JDBC driver for the database you want to connect to is downloaded
    and is in the classpath. In our project, we have already ensured this by adding
    a dependency in Maven. Maven downloads the driver and adds it to the class path
    of our web application.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is always a good practice to make sure that the JDBC driver class is available
    when the application is running. If it is not, we can set a suitable error message
    and not perform any JDBC operations. The name of the MySQL JDBC driver class is
    `com.mysql.cj.jdbc.Driver`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, get the connection by calling the `DriverManager.getConnection` method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The connection URL contains the following details: hostname of the MySQL database
    server, port on which it is running (default is 3306), and the schema name (database
    name that you want to connect to). You can pass username and password to connect
    to the database as URL parameters.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a connection is an expensive operation. Also, database servers allow
    a certain maximum number of connections to it, so connections should be created
    sparingly. It is advisable to cache database connections and reuse. However, make
    sure that you close the connection when you no longer need it, for example, in
    the `final` blocks of your code. Later, we will see how to create a pool of connections
    so that we create a limited number of connections, take them out of the pool when
    required, perform the required operations, and return them to the pool so that
    they can be reused.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Executing SQL statements
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Use `Statement` for executing static SQL (having no parameters) and `PreparedStatement`
    for executing parameterized statements.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To avoid the risk of SQL injection, refer to [https://www.owasp.org/index.php/SQL_injection](https://www.owasp.org/index.php/SQL_injection).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To execute any `Statement`, you first need to create the statement using the `Connection`
    object. You can then perform any SQL operation, such as `create`, `update`, `delete`,
    and `select`. The `Select` statement (query) returns a `ResultSet` object. Iterate
    over the `ResultSet` object to get individual rows.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, the following code gets all rows from the `Course` table:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Things to note:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Call `Connection.createStatement ()` to create an instance of `Statement`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Statement.executeQuery` returns `ResultSet`. If the SQL statement is not a
    query, for example `create`, `update`, and `delete` statements, then call `Statement.execute`
    (which returns `true` if the statement is executed successfully; or else, `false`)
    or call `Statement.executeUpdate` (which returns the number of rows affected or
    zero if none is affected).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the SQL statement to the `Statement.executeQuery` function. This can be
    any valid SQL string understood by the database.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate over `ResultSet` by calling the `next` method, until it returns `false`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Call different variations of `get` methods (depending on the data type of the
    column) to obtain values of columns in the current row that the `ResultSet` is
    pointing to. You can either pass positional index of the column in SQL that you
    passed to `executeQuery` or column names as used in the database table or alias
    specified in the SQL statement. For example, we would use the following code if
    we had specified column names in the SQL:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we could retrieve column values as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you close `ResultSet` and `Statement`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of getting all courses, if you want to get a specific course, you would
    want to use `PreparedStatement`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we are trying to get the course with ID `10`. We first get
    an instance of `PreparedStatement` by calling `Connection.prepareStatement`. Note
    that you need to pass an SQL statement as an argument to this function. Parameters
    in the query are replaced by the `?` placeholder. We then set the value of the
    parameter by calling `stmt.setInt`. The first argument is the position of the
    parameter (it starts from `1`) and the second argument is the value. There are
    many variations of the `set` method for different data types.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Handling transactions
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to perform multiple changes to the database as a single unit, that
    is, either all changes should be done or none, then you need to start a transaction
    in JDBC. You start a transaction by calling `Connection. setAutoCommit(false)`.
    Once all operations are executed successfully, commit the changes to the database
    by calling `Connection.commit`. If for any reason you want to abort the transaction,
    call `Connection.rollback()`. Changes are not done in the database until you call
    `Connection.commit`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example of inserting a bunch of courses into the database. Although
    in a real application, it may not make sense to abort a transaction when one of
    the courses is not inserted, here we assume that either all courses must be inserted
    into the database or none:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: There is more to learn about transactions than explained here. Refer to Oracle's
    JDBC tutorial at [http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html](http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a JDBC database connection pool
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, a JDBC database connection is an expensive operation and
    connection objects should be reused. Connection pools are used for this purpose.
    Most web containers provide their own implementation of a connection pool along
    with ways to configure it using JNDI. Tomcat also lets you configure a connection
    pool using JNDI. The advantage of configuring a connection pool using JNDI is
    that the database configuration parameters, such as hostname and port, remain
    outside the source code and can be easily modified. See [http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html](http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: However, a Tomcat connection pool can also be used without JNDI, as described
    in the preceding link. In this example, we will use a connection pool without
    JNDI. The advantage is that you can use the connection pool implementation provided
    by a third party; your application then becomes easily portable to other web containers.
    With JNDI, you can also port your application, as long as you create the JNDI
    context and resources in the web container that you are switching to.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will add the dependency of the Tomcat connection pool library to Maven''s
    `pom.xml`. Open the `pom.xml` file and add the following dependencies (see [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*, to know how to add dependencies to Maven):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that you can use any other implementation of the JDBC connection pool.
    One such connection pool library is HikariCP ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also want to move the database properties out of the code. Therefore, create
    a file called `db.properties` in `src/main/resources`. Maven puts all files in
    this folder in the classpath of the application. Add the following properties
    in `db.properties`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create a singleton class to create JDBC connections using the Tomcat
    connection pool. Create a `packt.book.jee.eclipse.ch4.db.connection` package and
    create a `DatabaseConnectionFactory` class in it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We must call the `init` method of `DatabaseConnectionFactory` before getting
    connections from it. We will create a servlet and load it on startup. Then, we
    will call `DatabaseConnectionFactory.init` from the `init` method of the servlet.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create `package packt.book.jee.eclipse.ch4.servlet` and then create an `InitServlet` class
    in it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that we have used the `@WebServlet` annotation to mark this class as a
    servlet and the `loadOnStartup` attribute is set to `1`, to tell the web container
    to load this servlet on startup.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can call the following statement to get a `Connection` object from anywhere
    in the application:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: If there are no more connections available in the pool, then the `getConnection`
    method throws an exception (in particular, in the case of the `Tomcat` datasource,
    it throws `PoolExhaustedException`). When you close the connection that was obtained
    from the connection pool, the connection is returned to the pool for reuse.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Saving courses in database tables using JDBC
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have figured out how to use the JDBC connection pool and get a connection
    from it, let's write the code to save a course to the database.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will create **Course Data Access Object** (**CourseDAO**), which will have
    functions required to directly interact with the database. We are thus separating
    the code to access the database from the UI and business code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create `package packt.book.jee.eclipse.ch4.dao`. Create a class called `CourseDAO`
    in it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We have already seen how to insert a record using JDBC. The only new thing
    in the preceding code is to get the autogenerated ID. Recall that the `id` column
    in the `Course` table is autogenerated. This is the reason that we did not specify
    it in the insert SQL:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'When we prepare a statement, we are telling the driver to get the autogenerated
    ID. After the row is inserted into the table, we get the autogenerated ID by calling
    the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We have already created `addCourse.jsp`. Somehow `addCourse.jsp` needs to send
    the form data to `CourseDAO` in order to save the data in the database. `addCourse.jsp`
    already has access to the `Course` bean and saves the form data in it. So, it
    makes sense for the `Course` bean to interface between `addCourse.jsp` and `CourseDAO`.
    Let''s modify the `Course` bean to add an instance of `CourseDAO` as a member
    variable and then create a function to add a course (instance of `CourseDAO`)
    to the database:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then modify `addCourse.jsp` to call the `addCourse` method of the `Course`
    bean. We will have to add this code after the form is submitted and the data is
    validated:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'One thing to note in the preceding code is the following statement:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You can insert **Expression Language** (**EL**) in JSP as discussed previously.
    This method does not return anything (it is a void method). Therefore, we didn''t
    use the `<c:set>` tag. Furthermore, note that the call is made within the `<c:catch>`
    tag. If any `SQLException` is thrown from the method, then it will be assigned
    to the `addCourseException` variable. We then check whether `addCourseException`
    is set in the `<c:when>` tag. If the value is not null, then it means that the
    exception was thrown. We set the error message, which is later displayed on the
    same page. If no error is thrown, then the request is redirected to `listCourse.jsp`.
    Here is the complete code of `addCourse.jsp`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Run the page, either in Eclipse or outside (see [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, to know how to run JSP in Eclipse and
    view it in Eclipse's internal browser) and add a couple of courses.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting courses from database tables using JDBC
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now modify `listCourses.jsp` to display the courses that we have added
    using `addCourse.jsp`. However, we first need to add a method in `CourseDAO` to
    get all courses from the database.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the `Course` table has a one-to-many relationship with `Teacher`.
    It stores the teacher ID in it. Further, the teacher ID is not a required field,
    so a course can exist in the `Course` table with null `teacher_id`. To get all
    the details of a course, we need to get the teacher for the course too. However,
    we cannot create a simple join in an SQL query to get the details of a course
    and of the teacher for each course, because a teacher may not have been set for
    the course. In such cases, we use the *left outer join*, which returns all records
    from the table on the left-hand side of the join, but only matching records from
    the table on the right-hand side of the join. Here is the SQL statement to get
    all courses and teachers for each course:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the preceding query in `CourseDAO` to get all courses. Open the `CourseDAO`
    class and add the following method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We have used `Statement` to execute the query because it is a static query.
    We have used `StringBuilder` to build the SQL statement because it is a relatively
    large query (compared to those that we have written so far) and we would like
    to avoid concatenation of string objects, because Strings are immutable. After
    executing the query, we iterate over the resultset and create a `Course` object
    and add it to the list of courses, which is returned at the end.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: One interesting thing here is the use of `ResultSet.wasNull`. We want to check
    whether the `teacher_id` field in the `Course` table for that particular row was
    null. Therefore, immediately after calling `rs.getInt("teacherId")`, we check
    whether the value fetched by `ResultSet` was null by calling `rs.wasNull`. If
    `teacher_id` was null, then the teacher was not set for that course, so we continue
    the loop, skipping the code to create a `Teacher` object.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the final block, we catch an exception when closing `ResultSet`, `Statement`,
    and `Connection` and ignore it.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now add a method in the `Course` bean to fetch courses by calling the `getCourses`
    method of `CourseDAO`. Open the `Course` bean and add the following method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to modify `listCourse.jsp` to display courses. Open the JSP
    and replace the existing code with the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Most of the code should be easy to understand because we have used similar
    code in previous examples. At the beginning of the script, we create a `Course`
    bean and get all the courses and assign the course list to a variable called `courses`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To display courses, we create a HTML table and set its headers. A new thing
    in the preceding code is the use of the `<c:forEach>` JSTL tag to iterate over
    the list. The `forEach` tag takes the following two attributes:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: List of objects
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable name of a single item when iterating over the list
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding case, the list of objects is provided by the `courses` variable
    that we set at the beginning of the script and we identify a single item in the
    list with the variable name `course`. We then display the course details and teacher
    for the course, if any.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Writing code to add `Teacher` and `Student` and list them is left to readers
    as an exercise. The code would be very similar to that for `course`, but with
    different table and class names.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Completing add course functionality
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We still haven't completed the functionality for adding a new course; we need
    to provide an option to assign a teacher to a course when adding a new course.
    Assuming that you have implemented `TeacherDAO` and created `addTeacher` and `getTeachers`
    methods in the `Teacher` bean, we can now complete the add course functionality.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, modify `addCourse` in `CourseADO` to save the teacher ID for each course,
    if it is not zero. The SQL statement to insert course changes is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We have added the `Teacher_id` column and the corresponding parameter holder
    `?`. We will set `Teacher_id` to null if it is zero; or else the actual value:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then modify the `Course` bean to save the teacher ID that will be passed
    along with the `POST` request from the HTML form:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will modify `addCourse.jsp` to display the drop-down list of teachers
    when adding a new course. We first need to get the list of teachers. Therefore,
    we will create a `Teacher` bean and call the `getTeachers` method on it. We will
    do this just before the Add Course header:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will display the HTML drop-down list in the form and populate it
    with teacher names:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Download the accompanying code for this chapter to see the complete source code
    of `CourseDAO` and `addCourse.jsp`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: With this, we conclude our discussion on using JDBC to create a web application
    that uses a database. With the examples that you have seen so far, you should
    be in a good position to complete the remaining application by adding functionality
    to modify and delete records in the database. The `update` and `delete` SQL statements
    can be executed by `Statement` or `PreparedStatement`, just as `insert` statements
    are executed using these two classes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Eclipse Data Source Explorer
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is sometimes useful if you can see data in database tables from your IDE
    and can modify it. This is possible in Eclipse JEE using Data Source Explorer.
    This view is displayed in a tab at the lower pane, just below editors, in the
    Java EE perspective. If you do not see the view, or have closed the view, you
    can reopen it by selecting the Window | Show View | Other menu. Type `data source`
    in the filter textbox and you should see the view name under the Data Management
    group. Open the view:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.12: Data Source Explorer'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Right-click on the Database Connections node and select New. From the list,
    select MySQL:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.13: Select the MySQL Connection Profile'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click Next. If the drivers list is empty, you haven''t configured the driver
    yet. Click on the icon next to the drop-down list for drivers to open the configuration
    page:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.14: Selecting Database Driver in JDBC New Driver Definition page'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select the appropriate MySQL version and click on the JAR List tab:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.15: Adding Driver Files in JDBC New Driver Definition page'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Remove any files from the Driver files list. Click on the Add JAR/Zip... button.
    This opens the File Open dialog. Select the JAR file for the MySQL driver version
    that you have selected. Since Maven has already downloaded the JAR file for you,
    you can select it from the local Maven repository. On OS X and Linux, the path
    is `~/.m2/repository/mysql/mysql-connector-java/<version_num>/mysql_connector_java_version_num/mysql-connector-java-version_num.jar`
    (`version_num` is a placeholder for the actual version number in the path). On
    Windows, you can find the Maven repository at `C:\Users\{your-username}\.m2` and
    then, the relative path for the MySQL driver is the same as that in OS X.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have trouble finding the JAR in the local Maven repository, you can download
    the JAR file (for the MySQL JDBC driver) from [http://dev.mysql.com/downloads/connector/j/.](http://dev.mysql.com/downloads/connector/j/.)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you specify the correct driver JAR file, you need to set the following
    properties:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.16: Setting JDBC driver properties'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click Next and then Finish. A new database connection will be added in Data
    Source Explorer. You can now browse the database schema and tables:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.17: Browsing tables in Data Source Explorer'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Right-click on any table to see the menu options available for different actions:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.18: Table menu options in Data Source Explorer'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the Edit menu to open a page in the editor where you can see the existing
    records in the table. You can also modify or add new data in the same page. Select
    the Load option to load data from an external file into the table. Select the Extract
    option to export data from the table.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating database applications using JPA
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to create the *Course Management* application
    using JDBC and JSTL. In this section, we will build the same application using
    JPA and JSF. We have learned how to create a web application using JSF in [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. We will use much of that knowledge in this section.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this chapter, JPA is an ORM framework, which
    is now part of the JEE specification. At the time of writing, it is in version
    2.2\. We will learn a lot about JPA as we develop our application.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the Maven project called `CourseManagementJPA` with group ID `packt.book.jee_eclipse`
    and artifact ID `CourseManagementJPA`. Eclipse JEE has great tools for creating
    applications using JPA, but you need to convert your project to a JPA project.
    We will see how to do this later in this section.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating user interfaces for adding courses using JSF
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we write any data access code using JPA, let''s first create the user
    interface using JSF. As we have learned in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, we need to add Maven dependencies for
    JSF. Add the following dependencies in `pom.xml`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: When you run the application later, if Tomcat throws an exception for not finding `javax.faces.webapp.FacesServlet`
    then you may have to download `jsf-api-2.2.16.jar` ([http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar](http://central.maven.org/maven2/com/sun/faces/jsf-api/2.2.16/jsf-api-2.2.16.jar)),
    and `jsf-impl-2.2.16.jar` ([http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar](http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar)),
    and copy them to the `<tomcat-install-folder>/lib` folder. Set scopes for these
    two libraries as provided: `<scope>provided</scope>` in `pom.xml`. Then clean
    the project (Run As | Maven Clean) and install it again (Run As | Maven Install).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to add `web.xml`, add a declaration for the JSF servlet in it, and
    add the servlet mapping. Eclipse provides you a very easy way to add `web.xml`
    (which should be in the `WEB-INF` folder). Right-click on the project and select
    the Java EE Tools | Generate Deployment Descriptor Stub menu. This creates the
    `WEB-INF` folder under `src/main/webapp` and creates `web.xml` in the `WEB-INF`
    folder with the default content. Now, add the following servlet and mapping:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Let's now create JavaBeans for `Course`, `Teacher`, `Student`, and `Person`,
    just as we created them in the previous example for JDBC. Create a `packt.book.jee.eclipse.ch4.jpa.bean`
    package and create the following JavaBeans.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the source code of the `Course` bean (in `Course.java`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the source code of the `Person` bean (in `Person.java`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the source code of the `Student` bean (in `Student.java`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'And, finally, here is the source code of the `Teacher` bean (in `Teacher.java`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: All are JSF managed beans in `RequestScope`. Refer to the JSF discussion in
    [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*, for more about managed beans and scopes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These beans are now ready to use in JSF pages. Create a JSF page and name it
    `addCourse.xhtml` and add the following content:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The page uses JSF tags and managed beans to get and set values. Notice the value
    of the `action` attribute of the `h:commandButton` tag—it is the `courseServiceBean.addCourse` method,
    which will be called when the Add button is clicked. In the application that we
    created using JDBC, we wrote code to interact with DAOs in the JavaBeans. For
    example, the `Course` bean had the `addCourse` method. However, in the JPA project
    we will handle it differently. We will create service bean classes (they are also
    managed beans, just like `Course`) to interact with the data access objects and
    have the `Course` bean contain only the values set by the user.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a package named `packt.book.jee.eclipse.ch4.jpa.service_bean`. Create
    the class named `CourseServiceBean` in this package with the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`CourseServiceBean` is a managed bean and it contains the `errMsg` field (to
    store any error message during the processing of requests), the `addCourse` method,
    and the `course` field (which is annotated with `@ManagedProperty`).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `ManagedProperty` annotation tells the JSF implementation to inject another
    bean (specified as the `value` attribute) in the current bean. Here, we expect
    `CourseServiceBean` to have access to the `course` bean at runtime, without instantiating
    it. This is part of the **dependency injection** (**DI**) framework supported
    by Java EE. We will learn more about the DI framework in Java EE in later chapters.
    The `addCourse` function doesn't do much at this point, it just returns the `"listCourse"`
    string. If you want to execute `addCourse.xhtml` at this point, create a `listCourse.xml`
    file with some placeholder content and test `addCourse.xhtml`. We will add more
    content to `listCourse.xml` later in this section.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: JPA concepts
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: JPA is an ORM framework in JEE. It provides a set of APIs that the JPA implementation
    providers are expected to implement. There are many JPA providers, such as **EclipseLink**
    ([https://eclipse.org/eclipselink/](https://eclipse.org/eclipselink/)), **Hibernate
    JPA** ([http://hibernate.org/orm/](http://hibernate.org/orm/)), and **OpenJPA**
    ([http://openjpa.apache.org/](http://openjpa.apache.org/)). Before we start writing
    the persistence code using JPA, it is important to understand basic concepts of
    JPA.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Entity represents a single object instance that is typically related to one
    table. Any **Plain Old Java Object** (**POJO**) can be converted to an entity
    by annotating the class with `@Entity`. Members of the class are mapped to columns
    of a table in the database. Entity classes are simple Java classes, so they can
    extend or include other Java classes or even another JPA entity. We will see an
    example of this in our application. You can also specify validation rules for
    members of the Entity class; for example, you can mark a member as not null using
    the `@NotNull` annotation. These annotations are provided by Java EE Bean Validation
    APIs. See [https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ](https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ) for
    a list of validation annotations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: EntityManager
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '`EntityManager` provides the persistence context in which the entities exist.
    The persistence context also allows you to manage transactions. Using `EntityManager`
    APIs, you can perform query and write operations on entities. The entity manager
    can be web-container-managed (in which case an instance of `EntityManager` is
    injected by the container), or application-managed. In this chapter, we are going
    to look at application-managed entity managers. We will visit container-managed
    entity managers in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, when we learn about EJBs. The persistence
    unit of the entity manager defines the database connectivity information and groups
    entities that become part of the persistence unit. It is defined in the configuration
    file called `persistence.xml` and is expected to be in `META-INF` in the class
    path.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`EntityManager` has its own persistence context, which is a cache of entities.
    Updates to entities are first done in the cache and then pushed to the database
    when a transaction is committed or when the data is explicitly pushed to the database.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: When an application is managing `EntityManager`, it is advisable to have only
    one instance of `EntityManager` for a persistence unit.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: EntityManagerFactory
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '`EntityManagerFactory` creates `EntityManager`. `EntityManagerFactory` itself
    is obtained by calling a static `Persistence.createEntityManagerFactory` method.
    An argument to this function is a `persistence-unit` name that you have specified
    in `persistence.xml`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a JPA application
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the typical steps in creating a JPA application:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a database schema (tables and relationships). Optionally, you can create
    tables and relationships from JPA entities. We will see an example of this. However,
    it should be mentioned here that although creating tables from JPA entities is
    fine for development, it is not recommended in the production environment; doing
    so may result in a non-optimized database model.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `persistence.xml` and specify the database configurations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create entities and relationships.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Get an instance of `EntityManagerFactory` by calling `Persistence.createEntityManagerFactory`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of `EntityManager` from `EntityManagerFactory`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a transaction on `EntityManager` if you are performing `insert` or `update`
    operations on the entity.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform operations on the entity.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the transaction.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example snippet:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: You can find a description of JPA annotations at [http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm](http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: JPA tools in Eclipse EE make adding many of the annotations very easy, as we
    will see in this section.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a new MySQL schema
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we will create a separate MySQL schema (we won't use the same
    schema that we created for the JDBC application, although it is possible to do
    so). Open MySQL Workbench and connect to your MySQL database (see [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*, if you do not know how to connect to the MySQL
    database from MySQL Workbench).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Right-click in the Schema window and select Create Schema...:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.19: Creating a new MySQL schema'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Name the new schema `course_management_jpa` and click Apply. We are going to
    use this schema for the JPA application.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Setting up a Maven dependency for JPA
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will use the EclipseLink ([https://eclipse.org/eclipselink/](https://eclipse.org/eclipselink/))
    JPA implementation. We will use the MySQL JDBC driver and Bean Validation framework
    for validating members of entities. Finally, we will use Java annotations provided
    by JSR0250\. So, let''s add Maven dependencies for all these:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Converting a project into a JPA project
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many JPA tools become active in Eclipse JEE only if the project is a JPA project.
    Although we have created a Maven project, it is easy to add an Eclipse JPA facet
    to it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the project and select Configure | Convert to JPA Project:![](img/00112.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.20: Addding a JPA facet to a project'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure JPA is selected.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next page, select EclipseLink 2.5.x as the platform.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For the JPA implementation type, select Disable Library Configuration.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The drop-down list for Connection lists any connections you might have configured
    in Data Source Explorer. For now, do not select any connection. At the bottom
    of the page, select the Discover annotated classes automatically option:![](img/00113.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.21: Configuring a JPA facet'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Click Finish.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the JPA Content group is created under the project and `persistence.xml`
    is created in it. Open `persistence.xml` in the editor.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Connection tab and change Transaction type to Resource Local. We
    have selected Resource Local because, in this chapter, we are going to manage
    `EntityManager`. If you want the JEE container to manage `EntityManager`, then
    you should set Transaction type to JTA. We will see an example of the JTA transaction
    type in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Application with EJB*.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter EclipseLink connection pool attributes as shown in the following screenshot
    and save the file:![](img/00114.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.22: Setting up Persistence Unit Connection'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, click on the Schema Generation tab. Here, we will set the options to generate
    database tables and relationships from entities. Select the options as shown in
    the following screenshot:![](img/00115.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.23: Setting up Schema Generation options of Persistence Unit'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the content of the `persistence.xml` file after setting the preceding
    options:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Creating entities
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already created JavaBeans for `Course`, `Person`, `Student`, and `Teacher`.
    We will now convert them to JPA entities using the `@Entity` annotation. Open
    `Course.java` and add the following annotations:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The same bean can act as a managed bean for JSF and an entity for JPA. Note
    that if the name of the class is different from the table name in the database,
    you will need to specify a `name` attribute of the `@Entity` annotation. For example,
    if our `Course` table were called `SchoolCourse`, then the entity declaration
    would be as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To specify the primary key of the `Entity`, use the `@Id` annotation. In the
    `Course` table, `id` is the primary key and is autogenerated. To indicate autogeneration
    of the value, use the `@GeneratedValue` annotation. Use the `@column` annotation
    to indicate that the member variable corresponds to a column in the table. So,
    the annotations for `id` are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You can specify validations for a column using Bean Validation framework annotations,
    as mentioned earlier. For example, the course name should not be null:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Furthermore, the minimum value of credits should be `1`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding examples, the `@Column` annotation is not required to specify
    the name of the column if the field name is the same as the column name.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are using JPA entities to create tables and want to exactly specify the
    type of columns, then you can use the `columnDefinition` attribute of the `@Column`
    annotation; for example, to specify a column of type `varchar` with length `20`,
    you could use `@Column(columnDefinition="VARCHAR(20)")`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Refer to [https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html](https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html) to
    see all the attributes of the `@Column` annotation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will add more annotations to `Course Entity` as needed later. For now, let''s
    turn our attention to the `Person` class. This class is the parent class of the `Student`
    and `Teacher` classes. However, in the database, there is no `Person` table and
    all the fields of `Person` and `Student` are in the `Student` table; and the same
    for the `Teacher` table. So, how do we model this in JPA? Well, JPA supports inheritance
    of entities and provides control over how they should be mapped to database tables.
    Open the `Person` class and add the following annotations:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We are not only identifying the `Person` class as `Entity`, but we are also
    indicating that it is used for inheritance (using `@Inheritance`). The inheritance
    strategy decides how tables are mapped to classes. There are three possible strategies:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SINGLE_TABLE`: In this case, fields of parent and child classes would be mapped
    to the table of the parent class. If we use this strategy, then the fields of
    `Person`, `Student`, and `Teacher` will be mapped to the table for the `Person`
    entity.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TABLE_PER_CLASS`: In this case, each concrete class (non-abstract class) is
    mapped to a table in the database. All fields of the parent class are also mapped
    to the table for the child class. For example, all fields of `Person` and `Student`
    will be mapped to columns in the `Student` table. Since `Person` is marked as
    abstract, no table will be mapped by the `Person` class. It exists only to provide
    inheritance support in the application.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JOINED`: In this case, the parent and its children are mapped to separate
    tables. For example, `Person` will be mapped to the `Person` table, and `Student`
    and `Teacher` will be mapped to the corresponding tables in the database.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As per the schema that we created for the JDBC application, we have `Student`
    and `Teacher` tables with all the required columns and there is no `Person` table.
    Therefore, we have selected the `TABLE_PER_CLASS` strategy here.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: See more information about entity inheritance in JPA at [https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN](https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The fields `id`, `firstName`, and `lastName` in the `Person` table are shared
    by `Student` and `Teacher`. Therefore, we need to mark them as columns in the
    tables and set the primary key. So, add the following annotations to the fields
    in the `Person` class:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here, column names in the table do not match class fields. Therefore, we have
    to specify the name attribute in `@Column` annotations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now mark the `Student` class as `Entity`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Student` class has a `Date` field called `enrolledSince`, which is of
    the `java.util.Date` type. However, JDBC and JPA use the `java.sql.Date` type.
    If you want JPA to automatically convert `java.sql.Date` to `java.util.Date`,
    then you need to mark the field with the `@Temporal` annotation:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Teacher` class and add the `@Entity` annotation to it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, map the `designation` field in the class:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We have now added annotations for all tables and their fields that do not participate
    in table relationships. We will now model the relationships between tables in
    our classes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring entity relationships
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will model the relationship between `Course` and `Teacher`. There
    is a one-to-many relationship between them: one teacher may teach a number of
    courses. Open `Course.java` in the editor. Open the JPA perspective in Eclipse
    JEE (Window | Open Perspective | JPA menu).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring many-to-one relationships
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `Course.java` open in the editor, click on the JPA Details tab in the
    lower window (just below the editor window). In `Course.java`, click on the `teacher`
    member variable. The JPA Details tab shows the details of this attribute:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.24: JPA details of an entity attribute'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Target entity is auto-selected (as `Teacher`) because we have marked `Teacher`
    as an entity and the type of the `teacher` field is `Teacher`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: However, Eclipse has assumed a one-to-one relationship between `Course` and
    `Teacher`, which is not correct. There is a many-to-one relationship between `Course`
    and `Teacher`. To change this, click on the (one_to_one) hyperlink at the top
    of the JPA Details view and select the Many To One in Mapping Type Selection dialog
    box.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Select only Merge and Refresh cascade options; otherwise, duplicate entries
    will be added in the `Teacher` table for every `Teacher` that you selected for
    a `Course`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: See [https://javaee.github.io/tutorial/persistence-intro002.html#BNBQH](https://javaee.github.io/tutorial/persistence-intro002.html#BNBQH) for
    more details on entity relationships and cascade options.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you select Merge and Refresh cascade options, the `cascade` attribute
    added to the annotation is added to the `teacher` field in the `Course` entity:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Scroll down the JPA Details page to see Joining Strategy. This determines how
    columns in `Course` and `Teacher` tables are joined:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.25: Editing Joining Strategy in an entity relationship'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the default joining strategy is that the `teacher_id` column in the `Course`
    table maps to the `id` column in the `Teacher` table. Eclipse has just guessed
    `teacher_id` (the appended `id` to the `teacher` field in the `Course` entity),
    but if we had a different join column in the `Course` table, for example, `teacherId`,
    then we would need to override the default join columns. Click on the Override
    default checkbox and then on the Edit button on the right-hand side of the textbox:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.26: Editing Join Column'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our case, the default options match the table columns, so we will keep them
    unchanged. When you select the Override default checkbox, the `@JoinColumn` annotation
    is added to the `teacher` field in the `Course` entity:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: All the required annotations for the `teacher` field are now added.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring many-to-many relationships
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now configure `Course` and `Student` entities for a many-to-many relationship
    (a course can have many students, and one student can take many courses).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Many-to-many relations could be unidirectional or bidirectional. For example,
    you may only want to track students enrolled in the courses (so the `Course` entity
    will have a list of students) and not students taking the courses (the `Student`
    entity does not keep a list of courses). This is an unidirectional relationship
    where only the `Course` entity knows about the students, but the `Student` entity
    does not know about the courses).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In a bidirectional relationship, each entity knows about the other one. Therefore,
    the `Course` entity will keep a list of students and the `Student` entity will
    keep a list of courses. We will configure the bidirectional relationship in this
    example.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A many-to-many relationship also has one owning side and the other inverse side.
    You can mark either entity in the relationship as the owning entity. From the
    configuration point of view, the inverse side is marked by the `mappedBy` attribute
    to the `@ManyToMany` annotation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In our application, we will make `Student` as the owning side of the relationship
    and `Course` as the inverse side. A many-to-many relationship in the database
    needs a join table, which is configured in the owning entity using the `@JoinTable`
    annotation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will first configure a many-to-many relationship in the `Course` entity.
    Add a member variable in `Course` to hold a list of `Student` entities and add
    the getter and the setter for it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, click on the `students` field (added previously) and notice the settings
    in the JPA Details view:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00119.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.27: Default JPA details for the students field in Course Entity'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Because the `students` field is a list of `Student` entities, Eclipse has assumed
    a one-to-many relationship (see the link at the top of the JPA Details view).
    We need to change this. Click on the one_to_many link and select Many To Many.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the Merge and Refresh cascade options. Since we are putting a `Course`
    entity on the inverse side of the relationship, select Mapped By as Joining Strategy.
    Enter `courses` in the Attributes text field. The compiler will show an error
    for this because we don''t have a `courses` field in the `Student` entity yet.
    We will fix this shortly. The JPA settings for the `students` field should be
    as shown in the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.28: Modified JPA settings for the students field in Course Entity'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Annotations for the `students` field in the `Course` entity should be as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Open `Student.java` in the editor. Add the `courses` field and the getter and
    the setter for it. Click on the `courses` field in the file and change the relationship
    from one-to-many to many-to-many in JPA Details view (as described previously
    for the `students` field in the `Course` entity). Select the Merge and Refresh
    cascade options. In the Joining Strategy section, make sure that the Join table
    option is selected. Eclipse creates the default join table by concatenating the
    owning table and the inverse table, separated by an underscore (in this case `Student_Course`).
    Change this to Course_Student to make it consistent with the schema that we created
    for the JDBC application.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the Join columns section, select the Override default checkbox. Eclipse has
    named the join columns `students_id->id`, but in the Course_Student table we created
    in the JDBC application, we had a column named `student_id`. So, click the Edit
    button and change the name to student_id.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, change Inverse join columns from `courses_id->id` to `course_id->id`.
    After these changes, the JPA Details for the `courses` field should be as shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.29: JPA Details for the courses field in Student entity'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The previous settings create the following annotations for the `courses` field:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We have set all the entity relationships required for our application. Download
    the accompanying code for this chapter to see the complete source code for `Course`,
    `Student`, and `Teacher` entities.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to add the entities we created previously in `persistence.xml`. Open
    the file and make sure that the General tab is open. In the Managed Classes session,
    click the Add button. Type the name of the entity you want to add (for example,
    `Student`) and select the class from the list. Add all the four entities we have
    created:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.30: Add entities in persistence.xml'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating database tables from entities
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create database tables from entities and relationships
    that we have modeled:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the project and select JPA Tool | Generate Tables from Entities:![](img/00123.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.31: JPA Details for the courses field in Student entity'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Because we haven't configured any schema for our JPA project, the Schema drop-down
    will be empty. Click the Add a connection to JPA project link:![](img/00124.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.32: JPA project properties'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the Add connection link and create a connection to the `course_management_jpa`
    schema we created earlier. We have already seen how to create a connection to
    the MySQL schema in the *Using Eclipse Data Source Explorer* section of this chapter.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `course_management_jpa` in the drop-down list shown in *Figure 4.31*
    and click Next:![](img/00125.jpeg)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.33: Schema Generation from entities'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Click Finish.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Eclipse generates DDL scripts for creating tables and relationships and executes
    these scripts in the selected schema. Once the script is run successfully, open
    the Data Source Explorer view (see the *Using Eclipse Data Source Explorer *section
    of this chapter) and browse tables in course_management_jpa connection. Make sure
    that tables and fields are created according to the entities we have created:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.34: Tables created from JPA entities'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This feature of Eclipse and JPA makes it very easy to update the database as
    you modify your entities.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using JPA APIs to manage data
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create classes that use JPA APIs to manage data for our course management application.
    We will create service classes for Course, Teacher, and Student entities and add
    methods that directly access the database through JPA APIs.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As mentioned in the *JPA concepts* section, it is a good practice to cache an
    instance of `EntityManagerFactory` in our application. Furthermore, managed beans
    of JSF act as a link between the UI and the backend code, and as a conduit to
    transfer data between the UI and the data access objects. Therefore, they must
    have an instance of the data access objects (which use JPA to access data from
    the database). To cache an instance of `EntityManagerFactory`, we will create
    another managed bean, whose only job is to make the `EntityManagerFactory` instance
    available to other managed beans.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an `EntityManagerFactoryBean` class in the `packt.book.jee.eclipse.ch4.jpa.service_bean`
    package. This package contains all the managed beans. `EntityManagerFactoryBean`
    creates an instance of `EntityManagerFactory` in the constructor and provides
    a getter method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the argument passed in the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: It is the name of the persistence unit in `persistence.xml`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now let's create service classes that actually use the JPA APIs to access database
    tables.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a package called `packt.book.jee.eclipse.ch4.jpa.service`. Create the
    class named `CourseService`. Every service class will need access to `EntityManagerFactory`.
    So, create a private member variable as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor takes an instance of `EntityManagerFactoryBean` and gets the
    reference of `EntityManagerFactory` from it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now add a function to get all `courses` from the database:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note how `CriteriaBuilder`, `CriteriaQuery`, and `TypesQuery` are used to get
    all the courses. It is a type-safe way to execute the query.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: See [https://javaee.github.io/tutorial/persistence-criteria.html#GJITV](https://javaee.github.io/tutorial/persistence-criteria.html#GJITV)
    for detailed discussion on how to use the JPA criteria APIs.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We could have done the same thing using **Java Persistence Query Language**
    (**JQL**)—[http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html](http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html)—but
    it is not type-safe. However, here is an example of using JQL to write the `getCourses`
    function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to insert the course into the database:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The code is quite simple. We get the entity manager and then start a transaction,
    because it is an `update` operation. Then, we call the `persist` method on `EntityManager`
    by passing an instance of `Course` to save. Then, we commit the transaction. The
    methods to update and delete are also simple. Here is the entire source code of
    `CourseService`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now create `StudentService` and `TeacherService` classes with the following
    methods:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Wiring user interface with JPA service classes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all data access classes ready, we need to connect the user
    interface that we have created for adding courses, `addCourse.xhtml`, to pass
    data and get data from the JPA service classes. As mentioned previously, we are
    going to do this using managed beans, in this case, `CourseServiceBean`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CourseServiceBean` will need to create an instance of `CourseService` and
    call the `addCourse` method. Open `CourseServiceBean` and create a member variable
    as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need an instance of the `EntityManagerFactoryBean` managed bean that
    we created earlier:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `factoryBean` instance is injected by the JSF runtime and is available
    only after the managed bean is completely constructed. However, for this bean
    to be injected, we need to provide a setter method. Therefore, add a setter method
    for `factoryBean`. We can have JSF call a method of our bean after it is fully
    constructed by annotating the method with `@PostConstruct`. So, let''s create
    a method called `postConstruct`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, modify the `addCourse` method to call our service method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the `listCourse.xhtml` page will need to get a list of courses, let''s
    also add the `getCourses` method in `CourseServiceBean`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is `CourseServiceBean` after the preceding changes:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will write the code to display a list of courses in `listCourse.xhtml`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Because of space constraints, we will not discuss how to add functionality to
    delete/update courses, or to create a course with the `Teacher` field selected.
    Please download the source code for the examples discussed in this chapter to
    see completed projects.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build web applications that require accessing
    data from a relational database. First, we built a simple *Course Management*
    application using JDBC and JSTL, and then, the same application was built using
    JPA and JSF.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: JPA is preferred to JDBC because you end up writing a lot less code. The code
    to map object data to relational data is created for you by the JPA implementation.
    However, JDBC is still being used in many web applications because it is simpler
    to use. Although JPA has a moderate learning curve, JPA tools in Eclipse EE can
    make using JPA APIs a bit easier, particularly configuring entities, relationships,
    and `persistence.xml`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next chapter, we will deviate a bit from our discussion on JEE and see
    how to write and run unit tests for Java applications. We will also see how to
    measure code coverage after running the unit tests.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
