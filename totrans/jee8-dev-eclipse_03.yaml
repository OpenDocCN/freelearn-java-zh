- en: Creating JEE Database Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 JEE 数据库应用程序
- en: 'In the previous chapter, we learned how to use source control management software
    from Eclipse. Specifically, we learned how to use SVN and Git from Eclipse. In
    this chapter, we will get back to discussing JEE application development. Most
    web applications today require access to the database. In this chapter, we will
    learn two ways to access databases from JEE web applications: using JDBC APIs,
    and using JPA APIs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何从 Eclipse 使用源代码管理软件。具体来说，我们学习了如何从 Eclipse 使用 SVN 和 Git。在本章中，我们将回到讨论
    JEE 应用程序开发。如今，大多数网络应用程序都需要访问数据库。在本章中，我们将学习两种从 JEE 网络应用程序访问数据库的方法：使用 JDBC API 和使用
    JPA API。
- en: JDBC4 has been part of JDK since version 1.1\. It provides uniform APIs to access
    different relational databases. Between JDBC APIs and the database sits the JDBC
    driver for that database (either provided by the vendor of the database or a third-party
    vendor). JDBC translates common API calls to database-specific calls. The results
    returned from the database are also converted into objects of common data access
    classes. Although JDBC APIs require you to write a lot more code to access the
    database, it is still popular in JEE web applications because of its simplicity,
    flexibility of using database-specific SQL statements, and low learning curve.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC4 自 JDK 1.1 版本以来一直是 JDK 的一部分。它提供了统一的 API 来访问不同的关系型数据库。在 JDBC API 和数据库之间，是针对该数据库的
    JDBC 驱动程序（由数据库供应商提供或第三方供应商提供）。JDBC 将常见的 API 调用转换为数据库特定的调用。数据库返回的结果也被转换为通用数据访问类的对象。尽管
    JDBC API 要求你编写更多的代码来访问数据库，但由于其简单性、使用数据库特定 SQL 语句的灵活性以及低学习曲线，它仍然在 JEE 网络应用程序中很受欢迎。
- en: JPA is the result of **Java Specification Request** 220 (which stands for **JSR**).
    One of the problems of using JDBC APIs directly is converting object representation
    of data to relation data. Object representation is in your JEE application, which
    needs to be mapped to tables and columns in the relational database. The process
    is reversed when handling data returned from the relational database. If there
    is a way to automatically map object-oriented representation of data in web applications
    to relational data, it would save a lot of developer time. This is also called
    **object-relational mapping** (**ORM**). Hibernate ([http://hibernate.org/](http://hibernate.org/))
    is a very popular framework for ORM in Java applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 是 Java 规范请求 220（代表 JSR）的结果。使用 JDBC API 直接的一个问题是将数据对象表示转换为关系数据。对象表示位于你的 JEE
    应用程序中，需要映射到关系数据库中的表和列。处理从关系数据库返回的数据时，这个过程是相反的。如果有一种方法可以自动将网络应用程序中的面向对象的数据表示映射到关系数据，这将节省开发者大量的时间。这也被称为
    **对象关系映射**（ORM）。Hibernate ([http://hibernate.org/](http://hibernate.org/)) 是 Java
    应用程序中非常流行的 ORM 框架。
- en: Many of the concepts of such popular third-party ORM frameworks were incorporated
    in JPA. Just as JDBC provides uniform APIs for accessing relational databases,
    JPA provides uniform APIs for accessing ORM libraries. Third-party ORM frameworks
    provide implementations of JPA on top of their own framework. The JPA implementation
    may use the JDBC APIs underneath.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '许多流行的第三方 ORM 框架的概念都被纳入了 JPA。正如 JDBC 为访问关系型数据库提供了统一的 API 一样，JPA 为访问 ORM 库提供了统一的
    API。第三方 ORM 框架在其自己的框架之上提供了 JPA 的实现。JPA 实现可能使用 JDBC API 作为底层。 '
- en: We will explore many features of JDBC and JPA in this chapter as we build applications
    using these frameworks. In fact, we will build the same application, once using
    JDBC and then using JPA.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建使用这些框架的应用程序，同时探索 JDBC 和 JPA 的许多特性。实际上，我们将构建同一个应用程序，一次使用 JDBC，然后使用
    JPA。
- en: The application that we are going to build is for student-course management.
    The goal is to take an example that can show how to model relationships between
    tables and use them in JEE applications. We will use a MySQL database and Tomcat
    web application container. Although this chapter is about database programming
    in JEE, we will revisit some of the things we learned about JSTL and JSF in [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. We will use them to create user interfaces for our database
    web application. Make sure that you have configured Tomcat in Eclipse as described
    in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序是用于学生课程管理。目标是提供一个示例，展示如何建模表之间的关系并在 JEE 应用程序中使用它们。我们将使用 MySQL 数据库和
    Tomcat 网络应用程序容器。尽管本章是关于 JEE 的数据库编程，但我们将回顾我们在[第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建简单的
    JEE 网络应用程序”中学到的一些关于 JSTL 和 JSF 的内容。我们将使用它们来创建数据库网络应用程序的用户界面。请确保您已按照[第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建简单的
    JEE 网络应用程序”中所述在 Eclipse 中配置了 Tomcat。
- en: 'We will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Core JDBC concepts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心JDBC概念
- en: Using JDBC to access the database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDBC 访问数据库
- en: Using JDBC connection pool
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDBC 连接池
- en: Core JPA concepts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心JPA概念
- en: Using JPA to map entities (classes) to tables in the database
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JPA 将实体（类）映射到数据库中的表
- en: Configuring relationships between JPA entities
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置JPA实体之间的关系
- en: Let's first create a database and tables for this application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为这个应用程序创建一个数据库和表。
- en: Creating database schema
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库架构
- en: 'There are many ways of creating database tables and relationships in MySQL:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中创建数据库表和关系有许多方法：
- en: You can use **data description language** (**DDL**) statements directly at MySQL
    Command Prompt from the Terminal
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以直接在终端的 MySQL 命令提示符中使用 **数据描述语言**（**DDL**）语句
- en: You can use MySQL Workbench and create tables directly
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 MySQL Workbench 直接创建表
- en: You can create an entity-relationship diagram in MySQL Workbench, export it
    to create a DDL script, and then run this script to create tables and relationships
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 MySQL Workbench 中创建实体-关系图，将其导出以创建 DDL 脚本，然后运行此脚本以创建表和关系
- en: We will use the third option. If you just want to get the script to create tables
    and want to skip creating the ER diagram, then jump to the *Script to create tables
    and relationships* section of this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第三个选项。如果您只想获取创建表的脚本并跳过创建 ER 图，请跳转到本章的“创建表和关系的脚本”部分。
- en: 'If you have not already installed MySQL and MySQL Workbench, then refer to
    [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse*, for instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装 MySQL 和 MySQL Workbench，请参阅[第 1 章](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“介绍
    JEE 和 Eclipse”，获取说明：
- en: 'Open MySQL Workbench. Select the File | New Model menu. A blank model will
    be created with the option to create ER diagrams:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 MySQL Workbench。选择“文件 | 新模型”菜单。将创建一个空白模型，并可以选择创建 ER 图：
- en: '![](img/00093.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: 'Figure 4.1: Creating a new MySQL Workbench model'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：创建新的 MySQL Workbench 模型
- en: 'Double-click the Add Diagram icon; a blank ER diagram will be opened:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“添加图”图标；将打开一个空白 ER 图：
- en: '![](img/00094.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: 'Figure 4.2: Creating a new ER diagram'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：创建新的 ER 图
- en: By default, the new schema is named `mydb`. Double-click on it to open properties
    of the schema. Rename the schema`course_management`:![](img/00095.jpeg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，新架构命名为 `mydb`。双击它以打开架构属性。重命名架构为 `course_management`：![](img/00095.jpeg)
- en: 'Figure 4.3: Renaming the schema'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3：重命名架构
- en: Hover over the toolbar buttons on the left-hand side of the page, and you will
    see tool tips about their functions. Click on the button for a new table and then
    click on the blank page. This will insert a new table with the name `table1`.
    Double-click the table icon to open the Properties page of the table. In the Properties
    page, change the name of the table to `Course`:![](img/00096.jpeg)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面左侧的工具栏按钮上悬停，您将看到有关其功能的工具提示。单击创建新表的按钮，然后单击空白页面。这将插入一个名为 `table1` 的新表。双击表图标以打开表的属性页面。在属性页面中，将表名更改为
    `Course`：![](img/00096.jpeg)
- en: 'Figure 4.4: Creating a table in ER diagram'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.4：在 ER 图中创建表
- en: We will now create columns of the table. Double-click on the first column and
    name it id. Check the PK (**primary key**), NN (**not null**), and AI (**auto
    increment**) checkboxes. Add other columns as shown in the following screenshot:![](img/00097.jpeg)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建表的列。双击第一列并命名为id。勾选PK（**主键**）、NN（**非空**）和AI（**自动递增**）复选框。添加其他列，如下面的截图所示！[](img/00097.jpeg)
- en: 'Figure 4.5: Creating columns in a table in the ER diagram'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.5：在ER图中创建表格的列
- en: Create other tables, namely `Student` and `Teacher`, as shown in the following
    screenshot:![](img/00098.jpeg)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建其他表格，即`Student`和`Teacher`，如下面的截图所示！[](img/00098.jpeg)
- en: 'Figure 4.6: Creating additional tables'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.6：创建额外的表格
- en: Note that if you want to edit column properties of any table, then double-click
    the table in the ER diagram. Just selecting a table by a single click would not
    change the table selection in the Properties page. All columns in all tables are
    required (not null), except the `last_name` column in `Student` and `Teacher`
    tables.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果您想编辑任何表格的列属性，请在ER图中双击该表格。仅通过单次点击选择表格不会改变属性页中的表格选择。所有表格中的所有列都是必需的（非空），除了`Student`和`Teacher`表中的`last_name`列。
- en: We will now create relationships between the tables. One course can have many
    students, and students can take many courses. So, there is a many-to-many relationship
    between `Course` and `Student`.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将在表格之间创建关系。一门课程可以有多个学生，学生也可以选修多门课程。因此，`Course`和`Student`之间存在多对多关系。
- en: We will assume that one course is taught by only one teacher. However, a teacher
    can teach more than one course. Therefore, there is a many-to-one relationship
    between `Course` and `Teacher`.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将假设只有一位教师教授一门课程。然而，一位教师可以教授多门课程。因此，`Course`和`Teacher`之间存在多对一关系。
- en: 'Let''s now model these relationships in the ER diagram:'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们在ER图中建模这些关系：
- en: First, we will create a non-identifying relationship between `Course` and `Teacher`.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建`Course`和`Teacher`之间的非标识关系。
- en: Click on the non-identifying one-to-many button in the toolbar (dotted lines
    and 1:n).
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中点击非标识的一对多按钮（虚线和1:n）。
- en: Then, click on the `Course` table first and then on the `Teacher` table. It
    will create a relationship as shown in *Figure 4.7*. Note that a foreign key `Teacher_id`
    is created in the `Course` table. We don't want to make a `Teacher_id` field required
    in `Course`. A course can exist without a teacher in our application. Therefore,
    double-click on the link joining `Course` and `Teacher` tables.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，首先点击`Course`表，然后点击`Teacher`表。这将创建如图*图4.7*所示的关联。注意，在`Course`表中创建了一个外键`Teacher_id`。我们不想在`Course`中使`Teacher_id`字段成为必填项。在我们的应用程序中，课程可以没有教师而存在。因此，双击连接`Course`和`Teacher`表的链接。
- en: Then, click on the Foreign Key tab.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 外键标签页。
- en: On the Referenced Table side, uncheck the Mandatory checkbox:![](img/00099.jpeg)
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 引用表一侧，取消勾选必填复选框！[](img/00099.jpeg)
- en: 'Figure 4.7: Creating a one-to-many relationship between tables'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.7：在表格之间创建一对一关系
- en: 'Creation of a many-to-many relationship requires a link table to be created.
    To create a many-to-many relationship between `Course` and `Student`, click on
    the icon for many-to-many (n:m) and then click on the `Course` table and `Student`
    table. This will create a third table (link table) called `Course_has_Student`.
    We will rename this table `Course_Student`. The final diagram is as shown in the
    following screenshot:'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建多对多关系需要创建一个链接表。要创建`Course`和`Student`之间的多对多关系，点击多对多（n:m）图标，然后点击 `Course`表和 `Student`表。这将创建一个名为`Course_has_Student`的第三张表（链接表）。我们将此表重命名为`Course_Student`。最终的图如下所示：
- en: '![](img/00100.jpeg)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: 'Figure 4.8: ER diagram for the course management example'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.8：课程管理示例的ER图
- en: 'Follow these steps to create DDL scripts from the ER diagram:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下步骤从ER图创建DDL脚本：
- en: Select the File | Export | Forward Engineer SQL Create Script... menu.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 文件 | 导出 | 前向工程SQL创建脚本... 菜单。
- en: 'On the SQL Export Options page, select checkboxes for two options:'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SQL导出选项页，选择两个选项的复选框：
- en: Generate DROP Statements Before Each CREATE Statement
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个CREATE语句之前生成DROP语句
- en: Generate DROP SCHEMA
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成DROP SCHEMA
- en: Specify the Output SQL Script File path if you want to save the script.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想保存脚本，请指定 输出SQL脚本文件路径。
- en: On the last page of the Export wizard, you will see the script generated by
    MySQL Workbench. Copy this script by clicking the Copy to Clipboard button.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导出向导的最后一步，您将看到MySQL Workbench生成的脚本。通过点击 复制到剪贴板按钮来复制此脚本。
- en: Script to create tables and relationships
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表和关系的脚本
- en: 'The following is the DDL script to create tables and relationships for the
    course management example:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的 DDL 脚本用于创建表和关系，用于课程管理示例：
- en: '[PRE0]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating tables in MySQL
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 MySQL 中创建表
- en: Let's now create tables and relationships in the MySQL database by using the
    script created in the previous section.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们现在使用上一节中创建的脚本在 MySQL 数据库中创建表和关系。
- en: 'Make sure that MySQL is running and there is an open connection to the server
    from MySQL Workbench (see [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*, for more details):'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保 MySQL 正在运行，并且从 MySQL Workbench 到服务器的连接是开放的（有关更多详细信息，请参阅第 1 章，[介绍 JEE 和 Eclipse](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)）：
- en: Create a new query tab (the first button in the toolbar) and paste the preceding
    script.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的查询标签页（工具栏中的第一个按钮）并粘贴前面的脚本。
- en: Execute the query.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查询。
- en: At the end of the execution, refresh schemas in the left-hand pane. You should
    see the course_management schema and the tables created in it.![](img/00101.jpeg)
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行完成后，在左侧面板中刷新模式。你应该会看到 course_management 模式以及其中创建的表！![img/00101.jpeg](img/00101.jpeg)
- en: 'Figure 4.9: MySQL schema for the course management example'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.9：课程管理示例的 MySQL 模式
- en: Creating a database application using JDBC
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDBC 创建数据库应用程序
- en: In this section, we will use JDBC to create a simple course management web application.
    We will use the MySQL schema created in the previous section. Furthermore, we
    will create the web application using Tomcat; we have already seen how to create
    one in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*. We have also learned how to use JSTL and JSF in
    the same chapter. In this section, we will use JSTL and JDBC to create the course
    management application, and in the next section, we will use JSF and JPA to create
    the same application. We will use Maven (as described in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*) for project management, and of course,
    our IDE is going to be Eclipse JEE.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 JDBC 创建一个简单的课程管理 Web 应用程序。我们将使用上一节中创建的 MySQL 模式。此外，我们将使用 Tomcat 创建
    Web 应用程序；我们已经在第 2 章中看到了如何创建它，[创建简单的 JEE Web 应用程序](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)。在同一章中，我们还学习了如何使用
    JSTL 和 JSF。在本节中，我们将使用 JSTL 和 JDBC 创建课程管理应用程序，在下一节中，我们将使用 JSF 和 JPA 创建相同的应用程序。我们将使用
    Maven（如第 2 章中所述，[创建简单的 JEE Web 应用程序](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)）进行项目管理，当然，我们的
    IDE 将是 Eclipse JEE。
- en: Creating a project and setting up Maven dependencies
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目和设置 Maven 依赖项
- en: 'We will perform the following steps to create the Maven project for our application:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将执行以下步骤来创建我们应用程序的 Maven 项目：
- en: Create a Maven web project as described in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 2 章中所述创建 Maven Web 项目，[创建简单的 JEE Web 应用程序](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)。
- en: Name the project `CourseManagementJDBC`.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `CourseManagementJDBC`。
- en: Add dependencies for servlet and JSP, but do not add a dependency for JSF.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 servlet 和 JSP 的依赖项，但不要添加 JSF 的依赖项。
- en: To add the dependency for JSTL, open `pom.xml` and go to the Dependencies tab.
    Click on the Add... button. Type `javax.servlet` in the search box and select
    jstl:![](img/00102.jpeg)
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加 JSTL 的依赖项，打开 `pom.xml` 并转到依赖项选项卡。点击“添加...”按钮。在搜索框中输入 `javax.servlet` 并选择
    jstl：![img/00102.jpeg](img/00102.jpeg)
- en: 'Figure 4.10: Adding a dependency for jstl'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.10：添加 jstl 的依赖项：![img/00103.jpeg](img/00103.jpeg)
- en: Add the dependency for the MySQL JDBC driver too:![](img/00103.jpeg)
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也添加 MySQL JDBC 驱动程序的依赖项：![img/00103.jpeg](img/00103.jpeg)
- en: 'Figure 4.11: Adding dependency for the MySQL JDBC driver'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.11：添加 MySQL JDBC 驱动程序的依赖项
- en: 'Here is the `pom.xml` file after adding dependencies:'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在添加依赖项后，这是 `pom.xml` 文件：
- en: '[PRE1]'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the dependencies for servlet and JSP are marked as provided, which
    means that they will be provided by the web container (Tomcat) and will not be
    packaged with the application.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，servlet 和 JSP 的依赖项被标记为 provided，这意味着它们将由 Web 容器（Tomcat）提供，并且不会与应用程序一起打包。
- en: The description of how to configure Tomcat and add a project to it is skipped
    here. Refer to [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, for these details. This section will
    also not repeat information on how to run JSP pages and about JSTL that were covered
    in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里省略了如何配置 Tomcat 并向其中添加项目的描述。有关这些详细信息，请参阅[第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“创建简单的
    JEE Web 应用程序”。本节也不会重复介绍如何在[第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)“创建简单的
    JEE Web 应用程序”中提到的运行 JSP 页面和关于 JSTL 的信息。
- en: Creating JavaBeans for data storage
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于数据存储的 JavaBeans
- en: We will first create JavaBean classes for `Student`, `Course`, and `Teacher`.
    Since both student and teacher are people, we will create a new class called `Person`
    and have `Student` and `Teacher` classes extend it. Create these JavaBeans in
    the `packt.book.jee.eclipse.ch4.beans` package as follows.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将首先为 `Student`、`Course` 和 `Teacher` 创建 JavaBean 类。由于学生和教师都是人，我们将创建一个新的类 `Person`，并让
    `Student` 和 `Teacher` 类继承它。按照以下方式在 `packt.book.jee.eclipse.ch4.beans` 包中创建这些 JavaBeans。
- en: 'The code for the `Course` bean will be as follows:'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Course` 实体的代码如下：'
- en: '[PRE2]'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code for the `Person` bean will be as follows:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Person` Bean 的代码如下：'
- en: '[PRE3]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code for the `Student` bean will be as follows:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Student` Bean 的代码如下：'
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Teacher` bean will be as follows:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Teacher` 实体的代码如下：'
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating JSP to add a course
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于添加课程的 JSP 页面
- en: Let's now create a JSP page to add new courses. Right-click on the project in
    Package Explorer and select the New | Other... option. Type `jsp` in the filter
    box and select JSP File. Name the file `addCourse.jsp`. Eclipse will create the
    file in the `src/main/webapp` folder of the project.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们创建一个用于添加新课程的 JSP 页面。在包资源管理器中右键单击项目，然后选择“新建 | 其他...”选项。在过滤器框中输入 `jsp` 并选择
    JSP 文件。将文件命名为 `addCourse.jsp`。Eclipse 将在项目的 `src/main/webapp` 文件夹中创建该文件。
- en: 'Type the following code in `addCourse.jsp`:'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `addCourse.jsp` 文件中输入以下代码：
- en: '[PRE6]'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most of the code should be familiar, if you have read [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application* (see the *Using JSTL *section). We have
    a form to add courses. At the top of the file, we check whether the `post` request
    is made; if so, store content of the form in `courseBean` (make sure that names
    of the `form` field are the same as the members defined in the bean). The new
    tag that we have used here is `<c:catch>`. It is like a *try-catch* block in Java.
    Any exception thrown from within the body of `<c:catch>` is assigned to the variable
    name declared in the `var` attribute. Here, we are not doing anything with `beanStorageException`;
    we are suppressing the exception. When an exception is thrown, the `credits` field
    of the `Course` bean will remain set to zero and it will be caught in the `courseBean.isValidCourse`
    method. If the course data is valid, then we redirect the request to the `listCourse.jsp`
    page using the JSTL `<c:redirect>` tag.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您已经阅读了[第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)“创建简单的
    JEE Web 应用程序”（见 *使用 JSTL* 部分），那么大部分代码应该都很熟悉。我们有一个表单来添加课程。在文件顶部，我们检查是否发出了 `post`
    请求；如果是，将表单内容存储在 `courseBean` 中（确保 `form` 字段的名称与在 Bean 中定义的成员名称相同）。我们在这里使用的新标签是
    `<c:catch>`。它类似于 Java 中的 *try-catch* 块。在 `<c:catch>` 的主体中抛出的任何异常都将分配给在 `var` 属性中声明的变量名称。在这里，我们不对
    `beanStorageException` 做任何事情；我们只是抑制异常。当抛出异常时，`Course` Bean 的 `credits` 字段将保持为零，并在
    `courseBean.isValidCourse` 方法中被捕获。如果课程数据有效，则使用 JSTL `<c:redirect>` 标签将请求重定向到 `listCourse.jsp`
    页面。
- en: 'We need to add the `isValidCourse` method in the `Course` bean. Therefore,
    open the class in the editor and add the following method:'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要在 `Course` Bean 中添加 `isValidCourse` 方法。因此，在编辑器中打开该类，并添加以下方法：
- en: '[PRE7]'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to create `listCourse.jsp`. For now, just create a simple JSP
    with no JSTL/Java code and with only one header in the `body` tag:'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要创建 `listCourse.jsp`。目前，只需创建一个简单的 JSP 文件，不包含 JSTL/Java 代码，且在 `body` 标签中只有一个标题：
- en: '[PRE8]'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Right-click on `addCourse.jsp` in Package Explorer and select Run As | Run on
    Server. If you have configured Tomcat properly and added your project in Tomcat
    (as described in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*), then you should see the JSP page running
    in the internal Eclipse browser. Test the page with both valid and invalid data
    (a wrong credit value; for example, a non-numeric value). If the data entered
    is valid, then you would be redirected to `listCourse.jsp`, or else the same page
    would be displayed with the error message.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在包资源管理器中右键单击`addCourse.jsp`并选择运行方式 | 在服务器上运行。如果你已经正确配置了Tomcat并将你的项目添加到Tomcat中（如第2章[part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55]，*创建一个简单的JEE
    Web应用程序*）中所述），那么你应该看到JSP页面在Eclipse内部浏览器中运行。使用有效和无效数据（例如，错误的学分值；例如，非数值）测试页面。如果输入的数据有效，则会被重定向到`listCourse.jsp`，否则会显示相同的页面并带有错误消息。
- en: Before we start writing JDBC code, let's learn some fundamental concepts of
    JDBC.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们开始编写JDBC代码之前，让我们学习一些JDBC的基本概念。
- en: JDBC concepts
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDBC概念
- en: 'Before performing any operations in JDBC, we need to establish a connection
    to the database. Here are some of the important classes/interfaces in JDBC for
    executing SQL statements:'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在JDBC中执行任何操作之前，我们需要与数据库建立连接。以下是JDBC中用于执行SQL语句的一些重要类/接口：
- en: '| **JDBC class/interface** | **Description** |'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| **JDBC类/接口** | **描述** |'
- en: '| `java.sql.Connection` | Represents the connection between the application
    and the backend database. Must for performing any action on the database. |'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `java.sql.Connection` | 表示应用程序与后端数据库之间的连接。执行数据库上的任何操作所必需的。|'
- en: '| `java.sql.DriverManager` | Manages JDBC drivers used in the application.
    Call the `DriverManager.getConnection` static method to obtain the connection.
    |'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `java.sql.DriverManager` | 管理应用程序中使用的JDBC驱动程序。通过调用`DriverManager.getConnection`静态方法来获取连接。|'
- en: '| `java.sql.Statement` | Used for executing static SQL statements. |'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `java.sql.Statement` | 用于执行静态SQL语句。|'
- en: '| `java.sql.PreparedStatement` | Used for preparing parameterized SQL statements.
    SQL statements are pre-compiled and can be executed repeatedly with different
    parameters. |'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `java.sql.PreparedStatement` | 用于准备参数化SQL语句。SQL语句被预编译，可以重复使用不同的参数执行。|'
- en: '| `Java.sqlCallableStatement` | Used for executing a stored procedure. |'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `Java.sqlCallableStatement` | 用于执行存储过程。|'
- en: '| `java.sql.ResultSet` | Represents a row in the database table in the result
    returned after execution of an SQL query by `Statement` or `PreparedStatement`.
    |'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `java.sql.ResultSet` | 表示由`Statement`或`PreparedStatement`执行SQL查询后返回的结果集中的数据库表中的行。|'
- en: You can find all the interfaces for JDBC at [http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html](http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html).
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html](http://docs.oracle.com/javase/8/docs/api/java/sql/package-frame.html)找到所有JDBC接口。
- en: Many of these are interfaces, and implementations of these interfaces are provided
    by the JDBC drivers.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中许多是接口，这些接口的实现由JDBC驱动程序提供。
- en: Creating database connections
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库连接
- en: Make sure that the JDBC driver for the database you want to connect to is downloaded
    and is in the classpath. In our project, we have already ensured this by adding
    a dependency in Maven. Maven downloads the driver and adds it to the class path
    of our web application.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你想要连接到的数据库的JDBC驱动程序已下载并位于类路径中。在我们的项目中，我们已经通过在Maven中添加依赖项来确保这一点。Maven下载驱动程序并将其添加到我们的Web应用程序的类路径中。
- en: 'It is always a good practice to make sure that the JDBC driver class is available
    when the application is running. If it is not, we can set a suitable error message
    and not perform any JDBC operations. The name of the MySQL JDBC driver class is
    `com.mysql.cj.jdbc.Driver`:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保当应用程序运行时JDBC驱动程序类是可用的。如果不是，我们可以设置一个合适的错误消息并且不执行任何JDBC操作。MySQL JDBC驱动程序类的名称是`com.mysql.cj.jdbc.Driver`：
- en: '[PRE9]'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, get the connection by calling the `DriverManager.getConnection` method:'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，通过调用`DriverManager.getConnection`方法来获取连接：
- en: '[PRE10]'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The connection URL contains the following details: hostname of the MySQL database
    server, port on which it is running (default is 3306), and the schema name (database
    name that you want to connect to). You can pass username and password to connect
    to the database as URL parameters.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接URL包含以下详细信息：MySQL数据库服务器的hostname、它运行的端口号（默认为3306）以及模式名称（你想要连接到的数据库名称）。你可以通过URL参数传递用户名和密码来连接到数据库。
- en: Creating a connection is an expensive operation. Also, database servers allow
    a certain maximum number of connections to it, so connections should be created
    sparingly. It is advisable to cache database connections and reuse. However, make
    sure that you close the connection when you no longer need it, for example, in
    the `final` blocks of your code. Later, we will see how to create a pool of connections
    so that we create a limited number of connections, take them out of the pool when
    required, perform the required operations, and return them to the pool so that
    they can be reused.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建连接是一个昂贵的操作。此外，数据库服务器允许连接到它的最大连接数，因此应该谨慎创建连接。建议缓存数据库连接并重用。但是，确保在不再需要时关闭连接，例如在代码的`final`块中。稍后，我们将看到如何创建连接池，以便我们创建有限数量的连接，在需要时从池中取出，执行所需的操作，然后将它们返回到池中以便重用。
- en: Executing SQL statements
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行SQL语句
- en: Use `Statement` for executing static SQL (having no parameters) and `PreparedStatement`
    for executing parameterized statements.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`Statement`执行静态SQL（没有参数）和`PreparedStatement`执行参数化语句。
- en: To avoid the risk of SQL injection, refer to [https://www.owasp.org/index.php/SQL_injection](https://www.owasp.org/index.php/SQL_injection).
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了避免SQL注入的风险，请参阅[https://www.owasp.org/index.php/SQL_injection](https://www.owasp.org/index.php/SQL_injection)。
- en: To execute any `Statement`, you first need to create the statement using the `Connection`
    object. You can then perform any SQL operation, such as `create`, `update`, `delete`,
    and `select`. The `Select` statement (query) returns a `ResultSet` object. Iterate
    over the `ResultSet` object to get individual rows.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要执行任何`Statement`，首先需要使用`Connection`对象创建语句。然后，您可以执行任何SQL操作，例如`create`、`update`、`delete`和`select`。`Select`语句（查询）返回一个`ResultSet`对象。遍历`ResultSet`对象以获取单独的行。
- en: 'For example, the following code gets all rows from the `Course` table:'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下代码从`Course`表中获取所有行：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Things to note:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意事项：
- en: Call `Connection.createStatement ()` to create an instance of `Statement`.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Connection.createStatement()`来创建`Statement`实例。
- en: '`Statement.executeQuery` returns `ResultSet`. If the SQL statement is not a
    query, for example `create`, `update`, and `delete` statements, then call `Statement.execute`
    (which returns `true` if the statement is executed successfully; or else, `false`)
    or call `Statement.executeUpdate` (which returns the number of rows affected or
    zero if none is affected).'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Statement.executeQuery`返回`ResultSet`。如果SQL语句不是一个查询，例如`create`、`update`和`delete`语句，那么调用`Statement.execute`（如果语句执行成功则返回`true`；否则返回`false`）或调用`Statement.executeUpdate`（返回受影响的行数或如果没有行受影响则返回零）。'
- en: Pass the SQL statement to the `Statement.executeQuery` function. This can be
    any valid SQL string understood by the database.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SQL语句传递给`Statement.executeQuery`函数。这可以是数据库理解的任何有效SQL字符串。
- en: Iterate over `ResultSet` by calling the `next` method, until it returns `false`.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`next`方法遍历`ResultSet`，直到它返回`false`。
- en: 'Call different variations of `get` methods (depending on the data type of the
    column) to obtain values of columns in the current row that the `ResultSet` is
    pointing to. You can either pass positional index of the column in SQL that you
    passed to `executeQuery` or column names as used in the database table or alias
    specified in the SQL statement. For example, we would use the following code if
    we had specified column names in the SQL:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用不同的`get`方法变体（根据列的数据类型而定）以获取当前行中`ResultSet`所指向的列的值。您可以选择传递传递给`executeQuery`的SQL中的列的位置索引，或者传递数据库表或SQL语句中指定的别名中使用的列名。例如，如果我们已经在SQL中指定了列名，我们会使用以下代码：
- en: '[PRE12]'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we could retrieve column values as follows:'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们可以按以下方式检索列值：
- en: '[PRE13]'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure you close `ResultSet` and `Statement`.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保关闭`ResultSet`和`Statement`。
- en: 'Instead of getting all courses, if you want to get a specific course, you would
    want to use `PreparedStatement`:'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想获取特定的课程而不是所有课程，您应该使用`PreparedStatement`：
- en: '[PRE14]'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we are trying to get the course with ID `10`. We first get
    an instance of `PreparedStatement` by calling `Connection.prepareStatement`. Note
    that you need to pass an SQL statement as an argument to this function. Parameters
    in the query are replaced by the `?` placeholder. We then set the value of the
    parameter by calling `stmt.setInt`. The first argument is the position of the
    parameter (it starts from `1`) and the second argument is the value. There are
    many variations of the `set` method for different data types.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们试图获取 ID 为 `10` 的课程。我们首先通过调用 `Connection.prepareStatement` 获取 `PreparedStatement`
    的实例。请注意，您需要将 SQL 语句作为参数传递给此函数。查询中的参数由 `?` 占位符替换。然后，我们通过调用 `stmt.setInt` 设置参数的值。第一个参数是参数的位置（它从
    `1` 开始），第二个参数是值。对于不同的数据类型，`set` 方法有许多变体。
- en: Handling transactions
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事务
- en: If you want to perform multiple changes to the database as a single unit, that
    is, either all changes should be done or none, then you need to start a transaction
    in JDBC. You start a transaction by calling `Connection. setAutoCommit(false)`.
    Once all operations are executed successfully, commit the changes to the database
    by calling `Connection.commit`. If for any reason you want to abort the transaction,
    call `Connection.rollback()`. Changes are not done in the database until you call
    `Connection.commit`.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想将多个更改作为单个单元对数据库进行操作，也就是说，所有更改都应该完成或一个都不做，那么您需要在 JDBC 中启动一个事务。您通过调用 `Connection.setAutoCommit(false)`
    来启动事务。一旦所有操作都成功执行，通过调用 `Connection.commit` 将更改提交到数据库。如果出于任何原因想要中止事务，请调用 `Connection.rollback()`。直到您调用
    `Connection.commit`，更改都不会在数据库中完成。
- en: 'Here is an example of inserting a bunch of courses into the database. Although
    in a real application, it may not make sense to abort a transaction when one of
    the courses is not inserted, here we assume that either all courses must be inserted
    into the database or none:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个将一系列课程插入数据库的示例。虽然在实际应用程序中，当其中一个课程未插入时中止事务可能没有意义，但在这里我们假设要么所有课程都必须插入到数据库中，要么一个都不插入：
- en: '[PRE15]'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is more to learn about transactions than explained here. Refer to Oracle's
    JDBC tutorial at [http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html](http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html).
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于事务，还有更多内容需要学习，这里没有解释。请参阅 Oracle 的 JDBC 教程 [http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html](http://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html)。
- en: Using a JDBC database connection pool
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDBC 数据库连接池
- en: As mentioned before, a JDBC database connection is an expensive operation and
    connection objects should be reused. Connection pools are used for this purpose.
    Most web containers provide their own implementation of a connection pool along
    with ways to configure it using JNDI. Tomcat also lets you configure a connection
    pool using JNDI. The advantage of configuring a connection pool using JNDI is
    that the database configuration parameters, such as hostname and port, remain
    outside the source code and can be easily modified. See [http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html](http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html).
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，JDBC 数据库连接是一个昂贵的操作，并且连接对象应该被重用。为此目的，使用连接池。大多数 Web 容器都提供了自己的连接池实现，并提供了使用
    JNDI 配置它的方法。Tomcat 也允许您使用 JNDI 配置连接池。使用 JNDI 配置连接池的优势在于，数据库配置参数，如主机名和端口号，保留在源代码之外，并且可以轻松修改。请参阅
    [http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html](http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html)。
- en: However, a Tomcat connection pool can also be used without JNDI, as described
    in the preceding link. In this example, we will use a connection pool without
    JNDI. The advantage is that you can use the connection pool implementation provided
    by a third party; your application then becomes easily portable to other web containers.
    With JNDI, you can also port your application, as long as you create the JNDI
    context and resources in the web container that you are switching to.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，Tomcat 连接池也可以在不使用 JNDI 的情况下使用，如前一个链接中所述。在这个例子中，我们将使用不带 JNDI 的连接池。优势在于，您可以使用第三方提供的连接池实现；然后，您的应用程序可以轻松地移植到其他
    Web 容器。使用 JNDI，只要您在您要切换到的 Web 容器中创建 JNDI 上下文和资源，您也可以移植您的应用程序。
- en: 'We will add the dependency of the Tomcat connection pool library to Maven''s
    `pom.xml`. Open the `pom.xml` file and add the following dependencies (see [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*, to know how to add dependencies to Maven):'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将向Maven的`pom.xml`文件中添加Tomcat连接池库的依赖项。打开`pom.xml`文件，并添加以下依赖项（参见[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建一个简单的JEE
    Web应用程序*，了解如何向Maven添加依赖项）：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that you can use any other implementation of the JDBC connection pool.
    One such connection pool library is HikariCP ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)).
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以使用任何其他的JDBC连接池实现。其中一个这样的连接池库是HikariCP ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP))。
- en: 'We also want to move the database properties out of the code. Therefore, create
    a file called `db.properties` in `src/main/resources`. Maven puts all files in
    this folder in the classpath of the application. Add the following properties
    in `db.properties`:'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还希望将数据库属性从代码中移除。因此，在`src/main/resources`中创建一个名为`db.properties`的文件。Maven将所有文件放在这个文件夹中，并将其放在应用程序的类路径中。在`db.properties`中添加以下属性：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will create a singleton class to create JDBC connections using the Tomcat
    connection pool. Create a `packt.book.jee.eclipse.ch4.db.connection` package and
    create a `DatabaseConnectionFactory` class in it:'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建一个单例类来使用Tomcat连接池创建JDBC连接。创建一个`packt.book.jee.eclipse.ch4.db.connection`包，并在其中创建一个`DatabaseConnectionFactory`类：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We must call the `init` method of `DatabaseConnectionFactory` before getting
    connections from it. We will create a servlet and load it on startup. Then, we
    will call `DatabaseConnectionFactory.init` from the `init` method of the servlet.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在从它获取连接之前，我们必须调用`DatabaseConnectionFactory`的`init`方法。我们将创建一个servlet并在启动时加载它。然后，我们将从servlet的`init`方法中调用`DatabaseConnectionFactory.init`。
- en: 'Create `package packt.book.jee.eclipse.ch4.servlet` and then create an `InitServlet` class
    in it:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建`package packt.book.jee.eclipse.ch4.servlet`，然后在其中创建一个`InitServlet`类：
- en: '[PRE19]'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we have used the `@WebServlet` annotation to mark this class as a
    servlet and the `loadOnStartup` attribute is set to `1`, to tell the web container
    to load this servlet on startup.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用了`@WebServlet`注解来标记这个类为servlet，并将`loadOnStartup`属性设置为`1`，以告诉web容器在启动时加载这个servlet。
- en: 'Now we can call the following statement to get a `Connection` object from anywhere
    in the application:'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在应用程序的任何地方调用以下语句来获取一个`Connection`对象：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If there are no more connections available in the pool, then the `getConnection`
    method throws an exception (in particular, in the case of the `Tomcat` datasource,
    it throws `PoolExhaustedException`). When you close the connection that was obtained
    from the connection pool, the connection is returned to the pool for reuse.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果连接池中没有更多的连接可用，那么`getConnection`方法会抛出一个异常（特别是在`Tomcat`数据源的情况下，它会抛出`PoolExhaustedException`）。当你关闭从连接池获得的连接时，连接会被返回到池中以供重用。
- en: Saving courses in database tables using JDBC
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC在数据库表保存课程
- en: Now that we have figured out how to use the JDBC connection pool and get a connection
    from it, let's write the code to save a course to the database.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚如何使用JDBC连接池并从中获取连接，让我们编写将课程保存到数据库的代码。
- en: We will create **Course Data Access Object** (**CourseDAO**), which will have
    functions required to directly interact with the database. We are thus separating
    the code to access the database from the UI and business code.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建**课程数据访问对象**（**CourseDAO**），它将具有直接与数据库交互所需的功能。因此，我们将访问数据库的代码与UI和业务代码分离。
- en: 'Create `package packt.book.jee.eclipse.ch4.dao`. Create a class called `CourseDAO`
    in it:'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建`package packt.book.jee.eclipse.ch4.dao`。在它里面创建一个名为`CourseDAO`的类：
- en: '[PRE21]'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have already seen how to insert a record using JDBC. The only new thing
    in the preceding code is to get the autogenerated ID. Recall that the `id` column
    in the `Course` table is autogenerated. This is the reason that we did not specify
    it in the insert SQL:'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用JDBC插入记录。前述代码中唯一的新内容是获取自动生成的ID。回想一下，`Course`表中的`id`列是自动生成的。这就是为什么我们没有在插入SQL中指定它的原因：
- en: '[PRE22]'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we prepare a statement, we are telling the driver to get the autogenerated
    ID. After the row is inserted into the table, we get the autogenerated ID by calling
    the following:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们准备一个语句时，我们是在告诉驱动程序获取自动生成的ID。在行被插入到表中之后，我们通过调用以下代码来获取自动生成的ID：
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have already created `addCourse.jsp`. Somehow `addCourse.jsp` needs to send
    the form data to `CourseDAO` in order to save the data in the database. `addCourse.jsp`
    already has access to the `Course` bean and saves the form data in it. So, it
    makes sense for the `Course` bean to interface between `addCourse.jsp` and `CourseDAO`.
    Let''s modify the `Course` bean to add an instance of `CourseDAO` as a member
    variable and then create a function to add a course (instance of `CourseDAO`)
    to the database:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经创建了 `addCourse.jsp`。某种方式下，`addCourse.jsp` 需要将表单数据发送到 `CourseDAO` 以将数据保存到数据库中。`addCourse.jsp`
    已经可以访问 `Course` 实体，并将表单数据保存在其中。因此，`Course` 实体在 `addCourse.jsp` 和 `CourseDAO` 之间作为接口是有意义的。让我们修改
    `Course` 实体，添加一个 `CourseDAO` 实例作为成员变量，然后创建一个向数据库添加课程（`CourseDAO` 实例）的功能：
- en: '[PRE24]'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will then modify `addCourse.jsp` to call the `addCourse` method of the `Course`
    bean. We will have to add this code after the form is submitted and the data is
    validated:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将修改 `addCourse.jsp` 以调用 `Course` 实体的 `addCourse` 方法。我们将在表单提交和数据验证后添加此代码：
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One thing to note in the preceding code is the following statement:'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中需要注意的一点是以下语句：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can insert **Expression Language** (**EL**) in JSP as discussed previously.
    This method does not return anything (it is a void method). Therefore, we didn''t
    use the `<c:set>` tag. Furthermore, note that the call is made within the `<c:catch>`
    tag. If any `SQLException` is thrown from the method, then it will be assigned
    to the `addCourseException` variable. We then check whether `addCourseException`
    is set in the `<c:when>` tag. If the value is not null, then it means that the
    exception was thrown. We set the error message, which is later displayed on the
    same page. If no error is thrown, then the request is redirected to `listCourse.jsp`.
    Here is the complete code of `addCourse.jsp`:'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 JSP 中插入 **表达式语言**（**EL**），正如之前所讨论的。这种方法不返回任何内容（它是一个无返回值的方法）。因此，我们没有使用 `<c:set>`
    标签。此外，请注意调用是在 `<c:catch>` 标签内进行的。如果方法抛出任何 `SQLException`，则它将被分配给 `addCourseException`
    变量。然后我们在 `<c:when>` 标签中检查 `addCourseException` 是否已设置。如果值不为 null，则意味着抛出了异常。我们设置错误消息，该消息稍后将在同一页面上显示。如果没有抛出错误，则请求将被重定向到
    `listCourse.jsp`。以下是 `addCourse.jsp` 的完整代码：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the page, either in Eclipse or outside (see [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, to know how to run JSP in Eclipse and
    view it in Eclipse's internal browser) and add a couple of courses.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行页面，无论是在 Eclipse 中还是在 Eclipse 的内部浏览器外（参见第 2 章，[创建一个简单的 JEE Web 应用程序](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，了解如何在
    Eclipse 中运行 JSP 并在 Eclipse 的内部浏览器中查看它），并添加几门课程。
- en: Getting courses from database tables using JDBC
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDBC 从数据库表获取课程
- en: We will now modify `listCourses.jsp` to display the courses that we have added
    using `addCourse.jsp`. However, we first need to add a method in `CourseDAO` to
    get all courses from the database.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将修改 `listCourses.jsp` 以显示我们使用 `addCourse.jsp` 添加的课程。然而，我们首先需要在 `CourseDAO`
    中添加一个方法来从数据库获取所有课程。
- en: 'Note that the `Course` table has a one-to-many relationship with `Teacher`.
    It stores the teacher ID in it. Further, the teacher ID is not a required field,
    so a course can exist in the `Course` table with null `teacher_id`. To get all
    the details of a course, we need to get the teacher for the course too. However,
    we cannot create a simple join in an SQL query to get the details of a course
    and of the teacher for each course, because a teacher may not have been set for
    the course. In such cases, we use the *left outer join*, which returns all records
    from the table on the left-hand side of the join, but only matching records from
    the table on the right-hand side of the join. Here is the SQL statement to get
    all courses and teachers for each course:'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`Course` 表与 `Teacher` 表之间存在一对一的关系。它存储了教师 ID。此外，教师 ID 不是必填字段，因此课程可以在 `Course`
    表中以 `null` 的 `teacher_id` 存在。要获取一个课程的全部详细信息，我们需要获取该课程的教师。然而，我们无法在 SQL 查询中创建一个简单的连接来获取课程和每个课程的教师的详细信息，因为可能没有为课程设置教师。在这种情况下，我们使用
    *左外连接*，它返回连接左侧表的所有记录，但只返回连接右侧表匹配的记录。以下是获取所有课程和每个课程的教师的 SQL 语句：
- en: '[PRE28]'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will use the preceding query in `CourseDAO` to get all courses. Open the `CourseDAO`
    class and add the following method:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在 `CourseDAO` 中使用前面的查询来获取所有课程。打开 `CourseDAO` 类并添加以下方法：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have used `Statement` to execute the query because it is a static query.
    We have used `StringBuilder` to build the SQL statement because it is a relatively
    large query (compared to those that we have written so far) and we would like
    to avoid concatenation of string objects, because Strings are immutable. After
    executing the query, we iterate over the resultset and create a `Course` object
    and add it to the list of courses, which is returned at the end.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`Statement`来执行查询，因为它是一个静态查询。我们使用`StringBuilder`来构建SQL语句，因为它是一个相对较大的查询（与之前所写的查询相比），我们希望避免字符串对象的连接，因为字符串是不可变的。在执行查询后，我们遍历结果集，创建一个`Course`对象并将其添加到课程列表中，最后返回该列表。
- en: One interesting thing here is the use of `ResultSet.wasNull`. We want to check
    whether the `teacher_id` field in the `Course` table for that particular row was
    null. Therefore, immediately after calling `rs.getInt("teacherId")`, we check
    whether the value fetched by `ResultSet` was null by calling `rs.wasNull`. If
    `teacher_id` was null, then the teacher was not set for that course, so we continue
    the loop, skipping the code to create a `Teacher` object.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里一个有趣的事情是使用`ResultSet.wasNull`。我们想检查特定行的`Course`表中的`teacher_id`字段是否为null。因此，在调用`rs.getInt("teacherId")`之后，我们通过调用`rs.wasNull`来检查通过`ResultSet`获取的值是否为null。如果`teacher_id`为null，则表示该课程没有设置教师，所以我们继续循环，跳过创建`Teacher`对象的代码。
- en: In the final block, we catch an exception when closing `ResultSet`, `Statement`,
    and `Connection` and ignore it.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后的代码块中，我们在关闭`ResultSet`、`Statement`和`Connection`时捕获异常并忽略它。
- en: 'Let''s now add a method in the `Course` bean to fetch courses by calling the `getCourses`
    method of `CourseDAO`. Open the `Course` bean and add the following method:'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们向`Course`对象中添加一个方法来通过调用`CourseDAO`的`getCourses`方法来获取课程。打开`Course`对象并添加以下方法：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are now ready to modify `listCourse.jsp` to display courses. Open the JSP
    and replace the existing code with the following:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在准备好修改`listCourse.jsp`以显示课程。打开JSP并替换现有的代码为以下内容：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Most of the code should be easy to understand because we have used similar
    code in previous examples. At the beginning of the script, we create a `Course`
    bean and get all the courses and assign the course list to a variable called `courses`:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大部分代码应该很容易理解，因为我们已经在之前的例子中使用过类似的代码。在脚本开始时，我们创建一个`Course`对象并获取所有课程，将课程列表赋值给名为`courses`的变量：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To display courses, we create a HTML table and set its headers. A new thing
    in the preceding code is the use of the `<c:forEach>` JSTL tag to iterate over
    the list. The `forEach` tag takes the following two attributes:'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要显示课程，我们创建一个HTML表格并设置其标题。在前面的代码中，新的一步是使用`<c:forEach>` JSTL标签来遍历列表。`forEach`标签包含以下两个属性：
- en: List of objects
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象列表
- en: Variable name of a single item when iterating over the list
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历列表时单个项目的变量名
- en: In the preceding case, the list of objects is provided by the `courses` variable
    that we set at the beginning of the script and we identify a single item in the
    list with the variable name `course`. We then display the course details and teacher
    for the course, if any.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，对象列表是由我们在脚本开始时设置的`courses`变量提供的，我们用变量名`course`来标识列表中的单个项目。然后我们显示课程详情和教师信息（如果有）。
- en: Writing code to add `Teacher` and `Student` and list them is left to readers
    as an exercise. The code would be very similar to that for `course`, but with
    different table and class names.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写添加`Teacher`和`Student`并列出它们的代码留给读者作为练习。代码将与`course`非常相似，但表和类名不同。
- en: Completing add course functionality
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成添加课程功能
- en: We still haven't completed the functionality for adding a new course; we need
    to provide an option to assign a teacher to a course when adding a new course.
    Assuming that you have implemented `TeacherDAO` and created `addTeacher` and `getTeachers`
    methods in the `Teacher` bean, we can now complete the add course functionality.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还没有完成添加新课程的功能；我们需要在添加新课程时提供一个选项来为课程分配教师。假设你已经实现了`TeacherDAO`并在`Teacher`对象中创建了`addTeacher`和`getTeachers`方法，我们现在可以完成添加课程的功能。
- en: 'First, modify `addCourse` in `CourseADO` to save the teacher ID for each course,
    if it is not zero. The SQL statement to insert course changes is as follows:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，修改`CourseADO`中的`addCourse`以保存每个课程的教师ID，如果它不是零。插入课程更改的SQL语句如下：
- en: '[PRE33]'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have added the `Teacher_id` column and the corresponding parameter holder
    `?`. We will set `Teacher_id` to null if it is zero; or else the actual value:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了`Teacher_id`列和相应的参数持有者`?`。如果它是零，我们将`Teacher_id`设置为null；否则设置为实际值：
- en: '[PRE34]'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will then modify the `Course` bean to save the teacher ID that will be passed
    along with the `POST` request from the HTML form:'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将修改`Course`对象以保存将随HTML表单的`POST`请求一起传递的教师ID：
- en: '[PRE35]'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we will modify `addCourse.jsp` to display the drop-down list of teachers
    when adding a new course. We first need to get the list of teachers. Therefore,
    we will create a `Teacher` bean and call the `getTeachers` method on it. We will
    do this just before the Add Course header:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`addCourse.jsp`以在添加新课程时显示教师下拉列表。我们首先需要获取教师列表。因此，我们将创建一个`Teacher`对象，并在其上调用`getTeachers`方法。我们将在“添加课程”标题之前做这件事：
- en: '[PRE36]'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we will display the HTML drop-down list in the form and populate it
    with teacher names:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在表单中显示HTML下拉列表，并用教师姓名填充它：
- en: '[PRE37]'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Download the accompanying code for this chapter to see the complete source code
    of `CourseDAO` and `addCourse.jsp`.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下载本章的配套代码，以查看`CourseDAO`和`addCourse.jsp`的完整源代码。
- en: With this, we conclude our discussion on using JDBC to create a web application
    that uses a database. With the examples that you have seen so far, you should
    be in a good position to complete the remaining application by adding functionality
    to modify and delete records in the database. The `update` and `delete` SQL statements
    can be executed by `Statement` or `PreparedStatement`, just as `insert` statements
    are executed using these two classes.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了关于使用JDBC创建使用数据库的Web应用程序的讨论。通过您迄今为止看到的示例，您应该能够通过添加修改和删除数据库记录的功能来完成剩余的应用程序。`update`和`delete`
    SQL语句可以通过`Statement`或`PreparedStatement`执行，就像`insert`语句使用这两个类一样执行。
- en: Using Eclipse Data Source Explorer
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eclipse数据源浏览器
- en: 'It is sometimes useful if you can see data in database tables from your IDE
    and can modify it. This is possible in Eclipse JEE using Data Source Explorer.
    This view is displayed in a tab at the lower pane, just below editors, in the
    Java EE perspective. If you do not see the view, or have closed the view, you
    can reopen it by selecting the Window | Show View | Other menu. Type `data source`
    in the filter textbox and you should see the view name under the Data Management
    group. Open the view:'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您可以从IDE中查看数据库表中的数据并修改它，有时会很有用。在Eclipse JEE中使用数据源浏览器就可以做到这一点。此视图在Java EE视图中显示在底部面板的标签中，位于编辑器下方。如果您看不到此视图或已关闭视图，可以通过选择“窗口
    | 显示视图 | 其他”菜单重新打开它。在过滤器文本框中输入“数据源”，您应该在“数据管理”组下看到视图名称。打开视图：
- en: '![](img/00104.jpeg)'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片5](img/00104.jpeg)'
- en: 'Figure 4.12: Data Source Explorer'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片3](img/00105.jpeg)'
- en: 'Right-click on the Database Connections node and select New. From the list,
    select MySQL:'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右键点击数据库连接节点，选择新建。从列表中选择MySQL：
- en: '![](img/00105.jpeg)'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片6](img/00105.jpeg)'
- en: 'Figure 4.13: Select the MySQL Connection Profile'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.13：选择MySQL连接配置文件
- en: 'Click Next. If the drivers list is empty, you haven''t configured the driver
    yet. Click on the icon next to the drop-down list for drivers to open the configuration
    page:'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击“下一步”。如果驱动程序列表为空，您尚未配置驱动程序。点击下拉列表旁边的图标以打开配置页面：
- en: '![](img/00106.jpeg)'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片7](img/00106.jpeg)'
- en: 'Figure 4.14: Selecting Database Driver in JDBC New Driver Definition page'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片2](img/00104.jpeg)'
- en: 'Select the appropriate MySQL version and click on the JAR List tab:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择适当的MySQL版本，然后点击JAR列表标签：
- en: '![](img/00107.jpeg)'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片1](img/00107.jpeg)'
- en: 'Figure 4.15: Adding Driver Files in JDBC New Driver Definition page'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片4](img/00106.jpeg)'
- en: Remove any files from the Driver files list. Click on the Add JAR/Zip... button.
    This opens the File Open dialog. Select the JAR file for the MySQL driver version
    that you have selected. Since Maven has already downloaded the JAR file for you,
    you can select it from the local Maven repository. On OS X and Linux, the path
    is `~/.m2/repository/mysql/mysql-connector-java/<version_num>/mysql_connector_java_version_num/mysql-connector-java-version_num.jar`
    (`version_num` is a placeholder for the actual version number in the path). On
    Windows, you can find the Maven repository at `C:\Users\{your-username}\.m2` and
    then, the relative path for the MySQL driver is the same as that in OS X.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从驱动程序文件列表中删除任何文件。点击“添加JAR/ZIP...”按钮。这将打开文件打开对话框。选择您已选择的MySQL驱动程序的JAR文件。由于Maven已经为您下载了JAR文件，您可以从本地Maven仓库中选择它。在OS
    X和Linux上，路径是`~/.m2/repository/mysql/mysql-connector-java/<version_num>/mysql_connector_java_version_num/mysql-connector-java-version_num.jar`（`version_num`是路径中实际版本号的占位符）。在Windows上，您可以在`C:\Users\{your-username}\.m2`找到Maven仓库，然后MySQL驱动程序的相对路径与OS
    X上的相同。
- en: If you have trouble finding the JAR in the local Maven repository, you can download
    the JAR file (for the MySQL JDBC driver) from [http://dev.mysql.com/downloads/connector/j/.](http://dev.mysql.com/downloads/connector/j/.)
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在本地 Maven 仓库中找不到 JAR 文件，你可以从 [http://dev.mysql.com/downloads/connector/j/](http://dev.mysql.com/downloads/connector/j/)
    下载 JAR 文件（MySQL JDBC 驱动程序）。
- en: 'Once you specify the correct driver JAR file, you need to set the following
    properties:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦指定了正确的驱动程序 JAR 文件，你需要设置以下属性：
- en: '![](img/00108.jpeg)'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/00108.jpeg](img/00108.jpeg)'
- en: 'Figure 4.16: Setting JDBC driver properties'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.16：设置 JDBC 驱动程序属性
- en: 'Click Next and then Finish. A new database connection will be added in Data
    Source Explorer. You can now browse the database schema and tables:'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击“下一步”然后“完成”。将在数据源资源管理器中添加一个新的数据库连接。你现在可以浏览数据库模式和表：
- en: '![](img/00109.jpeg)'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/00109.jpeg](img/00109.jpeg)'
- en: 'Figure 4.17: Browsing tables in Data Source Explorer'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.17：在数据源资源管理器中浏览表
- en: 'Right-click on any table to see the menu options available for different actions:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右键单击任何表以查看不同操作可用的菜单选项：
- en: '![](img/00110.jpeg)'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/00110.jpeg](img/00110.jpeg)'
- en: 'Figure 4.18: Table menu options in Data Source Explorer'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.18：数据源资源管理器中的表菜单选项
- en: Select the Edit menu to open a page in the editor where you can see the existing
    records in the table. You can also modify or add new data in the same page. Select
    the Load option to load data from an external file into the table. Select the Extract
    option to export data from the table.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择“编辑”菜单以在编辑器中打开一个页面，你可以看到表中现有的记录。你还可以在同一页面上修改或添加新数据。选择“加载”选项将数据从外部文件加载到表中。选择“提取”选项将数据从表中导出。
- en: Creating database applications using JPA
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JPA 创建数据库应用程序
- en: In the previous section, we learned how to create the *Course Management* application
    using JDBC and JSTL. In this section, we will build the same application using
    JPA and JSF. We have learned how to create a web application using JSF in [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. We will use much of that knowledge in this section.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 JDBC 和 JSTL 创建 *课程管理* 应用程序。在本节中，我们将使用 JPA 和 JSF 构建相同的应用程序。我们在
    [第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建一个简单的 JEE Web
    应用程序* 中学习了如何使用 JSF 创建一个 Web 应用程序。我们将在本节中大量使用这些知识。
- en: As mentioned at the beginning of this chapter, JPA is an ORM framework, which
    is now part of the JEE specification. At the time of writing, it is in version
    2.2\. We will learn a lot about JPA as we develop our application.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如本章开头所述，JPA 是一个 ORM 框架，现在是 JEE 规范的一部分。在撰写本文时，它处于 2.2 版本。随着我们开发应用程序，我们将学习很多关于
    JPA 的知识。
- en: Create the Maven project called `CourseManagementJPA` with group ID `packt.book.jee_eclipse`
    and artifact ID `CourseManagementJPA`. Eclipse JEE has great tools for creating
    applications using JPA, but you need to convert your project to a JPA project.
    We will see how to do this later in this section.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个名为 `CourseManagementJPA` 的 Maven 项目，其组 ID 为 `packt.book.jee_eclipse`，组件
    ID 为 `CourseManagementJPA`。Eclipse JEE 有创建使用 JPA 的应用程序的强大工具，但你需要将你的项目转换为 JPA 项目。我们将在本节后面看到如何做到这一点。
- en: Creating user interfaces for adding courses using JSF
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSF 创建添加课程的用户界面
- en: 'Before we write any data access code using JPA, let''s first create the user
    interface using JSF. As we have learned in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, we need to add Maven dependencies for
    JSF. Add the following dependencies in `pom.xml`:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们使用 JPA 编写任何数据访问代码之前，让我们首先使用 JSF 创建用户界面。正如我们在 [第 2 章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建一个简单的
    JEE Web 应用程序* 中所学的，我们需要在 `pom.xml` 中添加 Maven 依赖项以支持 JSF。在 `pom.xml` 中添加以下依赖项：
- en: '[PRE38]'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you run the application later, if Tomcat throws an exception for not finding `javax.faces.webapp.FacesServlet`
    then you may have to download `jsf-api-2.2.16.jar` ([http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar](http://central.maven.org/maven2/com/sun/faces/jsf-api/2.2.16/jsf-api-2.2.16.jar)),
    and `jsf-impl-2.2.16.jar` ([http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar](http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar)),
    and copy them to the `<tomcat-install-folder>/lib` folder. Set scopes for these
    two libraries as provided: `<scope>provided</scope>` in `pom.xml`. Then clean
    the project (Run As | Maven Clean) and install it again (Run As | Maven Install).
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您稍后运行应用程序时，如果 Tomcat 抛出找不到 `javax.faces.webapp.FacesServlet` 的异常，那么您可能需要下载
    `jsf-api-2.2.16.jar` ([http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar](http://central.maven.org/maven2/com/sun/faces/jsf-api/2.2.16/jsf-api-2.2.16.jar))
    和 `jsf-impl-2.2.16.jar` ([http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar](http://central.maven.org/maven2/com/sun/faces/jsf-impl/2.2.16/jsf-impl-2.2.16.jar))，并将它们复制到
    `<tomcat-install-folder>/lib` 文件夹中。将这些库的作用域设置为提供：在 `pom.xml` 中设置为 `<scope>provided</scope>`。然后清理项目（运行
    As | Maven Clean）并重新安装（运行 As | Maven Install）。
- en: 'We need to add `web.xml`, add a declaration for the JSF servlet in it, and
    add the servlet mapping. Eclipse provides you a very easy way to add `web.xml`
    (which should be in the `WEB-INF` folder). Right-click on the project and select
    the Java EE Tools | Generate Deployment Descriptor Stub menu. This creates the
    `WEB-INF` folder under `src/main/webapp` and creates `web.xml` in the `WEB-INF`
    folder with the default content. Now, add the following servlet and mapping:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要添加 `web.xml`，在其中添加对 JSF Servlet 的声明，并添加 Servlet 映射。Eclipse 提供了一种非常简单的方法来添加
    `web.xml`（它应该位于 `WEB-INF` 文件夹中）。在项目上右键单击，选择 Java EE Tools | Generate Deployment
    Descriptor Stub 菜单。这将在 `src/main/webapp` 下的 `WEB-INF` 文件夹中创建 `WEB-INF` 文件夹，并在
    `WEB-INF` 文件夹中创建具有默认内容的 `web.xml`。现在，添加以下 Servlet 和映射：
- en: '[PRE39]'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's now create JavaBeans for `Course`, `Teacher`, `Student`, and `Person`,
    just as we created them in the previous example for JDBC. Create a `packt.book.jee.eclipse.ch4.jpa.bean`
    package and create the following JavaBeans.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `Course`、`Teacher`、`Student` 和 `Person` 的 JavaBeans，就像我们在上一个例子中为 JDBC
    创建它们一样。创建一个名为 `packt.book.jee.eclipse.ch4.jpa.bean` 的包，并创建以下 JavaBeans。
- en: 'Here is the source code of the `Course` bean (in `Course.java`):'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `Course` Bean 的源代码（在 `Course.java` 中）：
- en: '[PRE40]'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is the source code of the `Person` bean (in `Person.java`):'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `Person` Bean 的源代码（在 `Person.java` 中）：
- en: '[PRE41]'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the source code of the `Student` bean (in `Student.java`):'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `Student` Bean 的源代码（在 `Student.java` 中）：
- en: '[PRE42]'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And, finally, here is the source code of the `Teacher` bean (in `Teacher.java`):'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，以下是 `Teacher` Bean 的源代码（在 `Teacher.java` 中）：
- en: '[PRE43]'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All are JSF managed beans in `RequestScope`. Refer to the JSF discussion in
    [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*, for more about managed beans and scopes.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些都是 `RequestScope` 中的 JSF 管理Bean。有关管理Bean和作用域的更多信息，请参阅[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中的
    JSF 讨论内容，*创建一个简单的 JEE Web 应用程序*。
- en: 'These beans are now ready to use in JSF pages. Create a JSF page and name it
    `addCourse.xhtml` and add the following content:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些豆子现在可以用于 JSF 页面。创建一个 JSF 页面，并将其命名为 `addCourse.xhtml`，然后添加以下内容：
- en: '[PRE44]'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The page uses JSF tags and managed beans to get and set values. Notice the value
    of the `action` attribute of the `h:commandButton` tag—it is the `courseServiceBean.addCourse` method,
    which will be called when the Add button is clicked. In the application that we
    created using JDBC, we wrote code to interact with DAOs in the JavaBeans. For
    example, the `Course` bean had the `addCourse` method. However, in the JPA project
    we will handle it differently. We will create service bean classes (they are also
    managed beans, just like `Course`) to interact with the data access objects and
    have the `Course` bean contain only the values set by the user.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该页面使用 JSF 标签和管理Bean来获取和设置值。注意 `h:commandButton` 标签的 `action` 属性值——它是 `courseServiceBean.addCourse`
    方法，当点击添加按钮时将被调用。在我们使用 JDBC 创建的应用程序中，我们编写了与 JavaBean 中的 DAO 交互的代码。例如，`Course` Bean
    有 `addCourse` 方法。然而，在 JPA 项目中，我们将以不同的方式处理。我们将创建服务Bean类（它们也是管理Bean，就像 `Course`
    一样）来与数据访问对象交互，并让 `Course` Bean 只包含用户设置的值。
- en: 'Create a package named `packt.book.jee.eclipse.ch4.jpa.service_bean`. Create
    the class named `CourseServiceBean` in this package with the following code:'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个名为 `packt.book.jee.eclipse.ch4.jpa.service_bean` 的包。在这个包中创建一个名为 `CourseServiceBean`
    的类，其代码如下：
- en: '[PRE45]'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`CourseServiceBean` is a managed bean and it contains the `errMsg` field (to
    store any error message during the processing of requests), the `addCourse` method,
    and the `course` field (which is annotated with `@ManagedProperty`).'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CourseServiceBean` 是一个托管豆，它包含 `errMsg` 字段（用于存储在请求处理过程中的任何错误消息）、`addCourse`
    方法以及 `course` 字段（该字段注解了 `@ManagedProperty`）。'
- en: The `ManagedProperty` annotation tells the JSF implementation to inject another
    bean (specified as the `value` attribute) in the current bean. Here, we expect
    `CourseServiceBean` to have access to the `course` bean at runtime, without instantiating
    it. This is part of the **dependency injection** (**DI**) framework supported
    by Java EE. We will learn more about the DI framework in Java EE in later chapters.
    The `addCourse` function doesn't do much at this point, it just returns the `"listCourse"`
    string. If you want to execute `addCourse.xhtml` at this point, create a `listCourse.xml`
    file with some placeholder content and test `addCourse.xhtml`. We will add more
    content to `listCourse.xml` later in this section.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ManagedProperty` 注解告诉 JSF 实现将另一个豆（指定为 `value` 属性）注入当前豆中。在这里，我们期望 `CourseServiceBean`
    在运行时能够访问 `course` 豆，而不需要实例化它。这是 Java EE 支持的 **依赖注入（DI**） 框架的一部分。我们将在后面的章节中了解更多关于
    Java EE 中的 DI 框架的内容。在这一点上，`addCourse` 函数并没有做什么，它只是返回了 `"listCourse"` 字符串。如果你现在想执行
    `addCourse.xhtml`，创建一个包含一些占位符内容的 `listCourse.xml` 文件并测试 `addCourse.xhtml`。我们将在本节的后面添加更多内容到
    `listCourse.xml`。'
- en: JPA concepts
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPA 概念
- en: JPA is an ORM framework in JEE. It provides a set of APIs that the JPA implementation
    providers are expected to implement. There are many JPA providers, such as **EclipseLink**
    ([https://eclipse.org/eclipselink/](https://eclipse.org/eclipselink/)), **Hibernate
    JPA** ([http://hibernate.org/orm/](http://hibernate.org/orm/)), and **OpenJPA**
    ([http://openjpa.apache.org/](http://openjpa.apache.org/)). Before we start writing
    the persistence code using JPA, it is important to understand basic concepts of
    JPA.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: JPA 是 JEE 中的一个 ORM 框架。它提供了一组 API，JPA 实现提供者预期将实现这些 API。有许多 JPA 提供者，例如 **EclipseLink**
    ([https://eclipse.org/eclipselink/](https://eclipse.org/eclipselink/))、**Hibernate
    JPA** ([http://hibernate.org/orm/](http://hibernate.org/orm/)) 和 **OpenJPA** ([http://openjpa.apache.org/](http://openjpa.apache.org/))。在我们开始使用
    JPA 编写持久化代码之前，了解 JPA 的基本概念是很重要的。
- en: Entity
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: Entity represents a single object instance that is typically related to one
    table. Any **Plain Old Java Object** (**POJO**) can be converted to an entity
    by annotating the class with `@Entity`. Members of the class are mapped to columns
    of a table in the database. Entity classes are simple Java classes, so they can
    extend or include other Java classes or even another JPA entity. We will see an
    example of this in our application. You can also specify validation rules for
    members of the Entity class; for example, you can mark a member as not null using
    the `@NotNull` annotation. These annotations are provided by Java EE Bean Validation
    APIs. See [https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ](https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ) for
    a list of validation annotations.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实体代表一个单个对象实例，通常与一个表相关联。任何 **纯 Java 对象（POJO**）都可以通过在类上注解 `@Entity` 转换为实体。类的成员映射到数据库表中的列。实体类是简单的
    Java 类，因此它们可以扩展或包含其他 Java 类，甚至另一个 JPA 实体。我们将在我们的应用程序中看到这个例子。您还可以为实体类的成员指定验证规则；例如，您可以使用
    `@NotNull` 注解标记一个成员为非空。这些注解由 Java EE Bean Validation API 提供。有关验证注解的列表，请参阅 [https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ](https://javaee.github.io/tutorial/bean-validation002.html#GIRCZ)。
- en: EntityManager
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理实体管理器
- en: '`EntityManager` provides the persistence context in which the entities exist.
    The persistence context also allows you to manage transactions. Using `EntityManager`
    APIs, you can perform query and write operations on entities. The entity manager
    can be web-container-managed (in which case an instance of `EntityManager` is
    injected by the container), or application-managed. In this chapter, we are going
    to look at application-managed entity managers. We will visit container-managed
    entity managers in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, when we learn about EJBs. The persistence
    unit of the entity manager defines the database connectivity information and groups
    entities that become part of the persistence unit. It is defined in the configuration
    file called `persistence.xml` and is expected to be in `META-INF` in the class
    path.'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EntityManager`提供了实体存在的持久化上下文。持久化上下文还允许您管理事务。使用`EntityManager` API，您可以在实体上执行查询和写操作。实体管理器可以是Web容器管理的（在这种情况下，`EntityManager`的实例由容器注入），或者应用程序管理的。在本章中，我们将探讨应用程序管理的实体管理器。当学习EJB时，我们将在[第7章](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)“使用EJB创建JEE应用程序”中访问容器管理的实体管理器。实体管理器的持久化单元定义了数据库连接信息并将实体分组为持久化单元的一部分。它在名为`persistence.xml`的配置文件中定义，并期望在类路径中的`META-INF`中。'
- en: '`EntityManager` has its own persistence context, which is a cache of entities.
    Updates to entities are first done in the cache and then pushed to the database
    when a transaction is committed or when the data is explicitly pushed to the database.'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EntityManager`有自己的持久化上下文，这是一个实体缓存。实体的更新首先在缓存中完成，然后在事务提交或数据被显式推送到数据库时推送到数据库。'
- en: When an application is managing `EntityManager`, it is advisable to have only
    one instance of `EntityManager` for a persistence unit.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序管理`EntityManager`时，建议为持久化单元只有一个`EntityManager`实例。
- en: EntityManagerFactory
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: EntityManagerFactory
- en: '`EntityManagerFactory` creates `EntityManager`. `EntityManagerFactory` itself
    is obtained by calling a static `Persistence.createEntityManagerFactory` method.
    An argument to this function is a `persistence-unit` name that you have specified
    in `persistence.xml`.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EntityManagerFactory`创建`EntityManager`。`EntityManagerFactory`本身是通过调用静态的`Persistence.createEntityManagerFactory`方法获得的。这个函数的参数是一个在`persistence.xml`中指定的`persistence-unit`名称。'
- en: Creating a JPA application
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建JPA应用程序
- en: 'The following are the typical steps in creating a JPA application:'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建JPA应用程序的典型步骤如下：
- en: Create a database schema (tables and relationships). Optionally, you can create
    tables and relationships from JPA entities. We will see an example of this. However,
    it should be mentioned here that although creating tables from JPA entities is
    fine for development, it is not recommended in the production environment; doing
    so may result in a non-optimized database model.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库模式（表和关系）。可选地，您可以从JPA实体创建表和关系。我们将看到这个示例。然而，应该在这里提到，虽然从JPA实体创建表对于开发来说是可以的，但在生产环境中并不推荐这样做；这样做可能会导致非优化的数据库模型。
- en: Create `persistence.xml` and specify the database configurations.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`persistence.xml`并指定数据库配置。
- en: Create entities and relationships.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实体和关系。
- en: Get an instance of `EntityManagerFactory` by calling `Persistence.createEntityManagerFactory`.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`Persistence.createEntityManagerFactory`来获取`EntityManagerFactory`的实例。
- en: Create an instance of `EntityManager` from `EntityManagerFactory`.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`EntityManagerFactory`创建`EntityManager`的实例。
- en: Start a transaction on `EntityManager` if you are performing `insert` or `update`
    operations on the entity.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在实体上执行`insert`或`update`操作，请在`EntityManager`上启动事务。
- en: Perform operations on the entity.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对实体执行操作。
- en: Commit the transaction.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交事务。
- en: 'Here is an example snippet:'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一个示例片段：
- en: '[PRE46]'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can find a description of JPA annotations at [http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm](http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm).
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在[http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm](http://www.eclipse.org/eclipselink/documentation/2.7/jpa/extensions/annotations_ref.htm)找到JPA注解的描述。
- en: JPA tools in Eclipse EE make adding many of the annotations very easy, as we
    will see in this section.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Eclipse EE中的JPA工具使得添加许多注解变得非常容易，正如我们将在本节中看到的。
- en: Creating a new MySQL schema
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的MySQL模式
- en: For this example, we will create a separate MySQL schema (we won't use the same
    schema that we created for the JDBC application, although it is possible to do
    so). Open MySQL Workbench and connect to your MySQL database (see [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*, if you do not know how to connect to the MySQL
    database from MySQL Workbench).
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于此示例，我们将创建一个单独的 MySQL 模式（我们不会使用为 JDBC 应用程序创建的相同模式，尽管这样做是可能的）。打开 MySQL Workbench
    并连接到您的 MySQL 数据库（如果您不知道如何从 MySQL Workbench 连接到 MySQL 数据库，请参阅第 1 章[介绍 JEE 和 Eclipse](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)）。
- en: 'Right-click in the Schema window and select Create Schema...:'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模式窗口中右键单击并选择创建模式...：
- en: '![](img/00111.jpeg)'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: 'Figure 4.19: Creating a new MySQL schema'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.19：创建新的 MySQL 模式
- en: Name the new schema `course_management_jpa` and click Apply. We are going to
    use this schema for the JPA application.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将新模式命名为 `course_management_jpa` 并点击应用。我们将使用此模式进行 JPA 应用程序。
- en: Setting up a Maven dependency for JPA
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 JPA 的 Maven 依赖项
- en: 'In this example, we will use the EclipseLink ([https://eclipse.org/eclipselink/](https://eclipse.org/eclipselink/))
    JPA implementation. We will use the MySQL JDBC driver and Bean Validation framework
    for validating members of entities. Finally, we will use Java annotations provided
    by JSR0250\. So, let''s add Maven dependencies for all these:'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用 EclipseLink ([https://eclipse.org/eclipselink/](https://eclipse.org/eclipselink/))
    JPA 实现。我们将使用 MySQL JDBC 驱动程序和 Bean 验证框架来验证实体的成员。最后，我们将使用由 JSR0250 提供的 Java 注解。因此，让我们为所有这些添加
    Maven 依赖项：
- en: '[PRE47]'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Converting a project into a JPA project
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将项目转换为 JPA 项目
- en: 'Many JPA tools become active in Eclipse JEE only if the project is a JPA project.
    Although we have created a Maven project, it is easy to add an Eclipse JPA facet
    to it:'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多 JPA 工具仅在项目是 JPA 项目时才在 Eclipse JEE 中激活。尽管我们创建了一个 Maven 项目，但很容易向其中添加 Eclipse
    JPA 特性：
- en: Right-click on the project and select Configure | Convert to JPA Project:![](img/00112.jpeg)
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目并选择配置 | 转换为 JPA 项目！[](img/00112.jpeg)
- en: 'Figure 4.20: Addding a JPA facet to a project'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.20：向项目添加 JPA 特性
- en: Make sure JPA is selected.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已选择 JPA。
- en: On the next page, select EclipseLink 2.5.x as the platform.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页上，选择 EclipseLink 2.5.x 作为平台。
- en: For the JPA implementation type, select Disable Library Configuration.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 JPA 实现类型，选择禁用库配置。
- en: The drop-down list for Connection lists any connections you might have configured
    in Data Source Explorer. For now, do not select any connection. At the bottom
    of the page, select the Discover annotated classes automatically option:![](img/00113.jpeg)
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接下拉列表列出了在数据源资源管理器中配置的所有连接。目前，请不要选择任何连接。在页面底部，选择自动发现注解类选项！[](img/00113.jpeg)
- en: 'Figure 4.21: Configuring a JPA facet'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.21：配置 JPA 特性
- en: Click Finish.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: Notice that the JPA Content group is created under the project and `persistence.xml`
    is created in it. Open `persistence.xml` in the editor.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，JPA 内容组是在项目下创建的，`persistence.xml` 也创建在其中。在编辑器中打开 `persistence.xml`。
- en: Click on the Connection tab and change Transaction type to Resource Local. We
    have selected Resource Local because, in this chapter, we are going to manage
    `EntityManager`. If you want the JEE container to manage `EntityManager`, then
    you should set Transaction type to JTA. We will see an example of the JTA transaction
    type in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Application with EJB*.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“连接”选项卡并将事务类型更改为资源本地。我们选择资源本地是因为，在本章中，我们将管理 `EntityManager`。如果您想让 JEE 容器管理
    `EntityManager`，则应将事务类型设置为 JTA。我们将在第 7 章[创建 JEE 应用程序与 EJB](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中看到一个
    JTA 事务类型的示例。
- en: Enter EclipseLink connection pool attributes as shown in the following screenshot
    and save the file:![](img/00114.jpeg)
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图输入 EclipseLink 连接池属性并保存文件！[](img/00114.jpeg)
- en: 'Figure 4.22: Setting up Persistence Unit Connection'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.22：设置持久化单元连接
- en: Next, click on the Schema Generation tab. Here, we will set the options to generate
    database tables and relationships from entities. Select the options as shown in
    the following screenshot:![](img/00115.jpeg)
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击“模式生成”选项卡。在这里，我们将设置从实体生成数据库表和关系的选项。选择以下截图所示的选项！[](img/00115.jpeg)
- en: 'Figure 4.23: Setting up Schema Generation options of Persistence Unit'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.23：设置持久化单元的模式生成选项
- en: 'Here is the content of the `persistence.xml` file after setting the preceding
    options:'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置前面的选项后，以下是 `persistence.xml` 文件的内容：
- en: '[PRE48]'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Creating entities
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实体
- en: 'We have already created JavaBeans for `Course`, `Person`, `Student`, and `Teacher`.
    We will now convert them to JPA entities using the `@Entity` annotation. Open
    `Course.java` and add the following annotations:'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经为`Course`、`Person`、`Student`和`Teacher`创建了JavaBeans。现在，我们将使用`@Entity`注解将它们转换为JPA实体。打开`Course.java`并添加以下注解：
- en: '[PRE49]'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The same bean can act as a managed bean for JSF and an entity for JPA. Note
    that if the name of the class is different from the table name in the database,
    you will need to specify a `name` attribute of the `@Entity` annotation. For example,
    if our `Course` table were called `SchoolCourse`, then the entity declaration
    would be as follows:'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同一个Bean可以同时作为JSF的管理Bean和JPA的实体。请注意，如果类的名称与数据库中的表名不同，你需要指定`@Entity`注解的`name`属性。例如，如果我们的`Course`表被命名为`SchoolCourse`，那么实体声明将如下所示：
- en: '[PRE50]'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To specify the primary key of the `Entity`, use the `@Id` annotation. In the
    `Course` table, `id` is the primary key and is autogenerated. To indicate autogeneration
    of the value, use the `@GeneratedValue` annotation. Use the `@column` annotation
    to indicate that the member variable corresponds to a column in the table. So,
    the annotations for `id` are as follows:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要指定`Entity`的主键，使用`@Id`注解。在`Course`表中，`id`是主键，并且是自动生成的。为了指示值的自动生成，使用`@GeneratedValue`注解。使用`@Column`注解来指示成员变量对应于表中的列。因此，`id`的注解如下所示：
- en: '[PRE51]'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can specify validations for a column using Bean Validation framework annotations,
    as mentioned earlier. For example, the course name should not be null:'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用前面提到的Bean Validation框架注解为列指定验证。例如，课程名称不应为空：
- en: '[PRE52]'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Furthermore, the minimum value of credits should be `1`:'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，学分的最低值应为`1`：
- en: '[PRE53]'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding examples, the `@Column` annotation is not required to specify
    the name of the column if the field name is the same as the column name.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果字段名与列名相同，则不需要`@Column`注解来指定列名。
- en: If you are using JPA entities to create tables and want to exactly specify the
    type of columns, then you can use the `columnDefinition` attribute of the `@Column`
    annotation; for example, to specify a column of type `varchar` with length `20`,
    you could use `@Column(columnDefinition="VARCHAR(20)")`.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用JPA实体来创建表并希望精确指定列的类型，那么你可以使用`@Column`注解的`columnDefinition`属性；例如，为了指定类型为`varchar`且长度为`20`的列，你可以使用`@Column(columnDefinition="VARCHAR(20)")`。
- en: Refer to [https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html](https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html) to
    see all the attributes of the `@Column` annotation.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参考[https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html](https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html)以查看`@Column`注解的所有属性。
- en: 'We will add more annotations to `Course Entity` as needed later. For now, let''s
    turn our attention to the `Person` class. This class is the parent class of the `Student`
    and `Teacher` classes. However, in the database, there is no `Person` table and
    all the fields of `Person` and `Student` are in the `Student` table; and the same
    for the `Teacher` table. So, how do we model this in JPA? Well, JPA supports inheritance
    of entities and provides control over how they should be mapped to database tables.
    Open the `Person` class and add the following annotations:'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在需要时向`Course Entity`添加更多注解。现在，让我们将注意力转向`Person`类。这个类是`Student`和`Teacher`类的父类。然而，在数据库中，没有`Person`表，`Person`和`Student`的所有字段都在`Student`表中；对于`Teacher`表也是如此。那么，我们如何在JPA中建模这种情况？JPA支持实体的继承，并提供控制它们如何映射到数据库表的方式。打开`Person`类并添加以下注解：
- en: '[PRE54]'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are not only identifying the `Person` class as `Entity`, but we are also
    indicating that it is used for inheritance (using `@Inheritance`). The inheritance
    strategy decides how tables are mapped to classes. There are three possible strategies:'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不仅将`Person`类标识为`Entity`，而且还表明它用于继承（使用`@Inheritance`）。继承策略决定了如何将表映射到类。有三种可能的策略：
- en: '`SINGLE_TABLE`: In this case, fields of parent and child classes would be mapped
    to the table of the parent class. If we use this strategy, then the fields of
    `Person`, `Student`, and `Teacher` will be mapped to the table for the `Person`
    entity.'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINGLE_TABLE`：在这种情况下，父类和子类的字段将被映射到父类的表中。如果我们使用这种策略，那么`Person`、`Student`和`Teacher`的字段将被映射到`Person`实体对应的表中。'
- en: '`TABLE_PER_CLASS`: In this case, each concrete class (non-abstract class) is
    mapped to a table in the database. All fields of the parent class are also mapped
    to the table for the child class. For example, all fields of `Person` and `Student`
    will be mapped to columns in the `Student` table. Since `Person` is marked as
    abstract, no table will be mapped by the `Person` class. It exists only to provide
    inheritance support in the application.'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TABLE_PER_CLASS`：在这种情况下，每个具体类（非抽象类）映射到数据库中的一个表。父类的所有字段也映射到子类的表中。例如，`Person`和`Student`的所有字段都将映射到`Student`表的列中。由于`Person`被标记为抽象的，`Person`类不会映射任何表。它仅存在于为应用程序提供继承支持。'
- en: '`JOINED`: In this case, the parent and its children are mapped to separate
    tables. For example, `Person` will be mapped to the `Person` table, and `Student`
    and `Teacher` will be mapped to the corresponding tables in the database.'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JOINED`：在这种情况下，父级及其子级映射到单独的表。例如，`Person`将映射到`Person`表，而`Student`和`Teacher`将映射到数据库中的相应表。'
- en: As per the schema that we created for the JDBC application, we have `Student`
    and `Teacher` tables with all the required columns and there is no `Person` table.
    Therefore, we have selected the `TABLE_PER_CLASS` strategy here.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据我们为JDBC应用程序创建的架构，我们有`Student`和`Teacher`表，包含所有必要的列，并且没有`Person`表。因此，我们在这里选择了`TABLE_PER_CLASS`策略。
- en: See more information about entity inheritance in JPA at [https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN](https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN).
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在JPA中了解更多关于实体继承的信息，请访问[https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN](https://javaee.github.io/tutorial/persistence-intro003.html#BNBQN)。
- en: 'The fields `id`, `firstName`, and `lastName` in the `Person` table are shared
    by `Student` and `Teacher`. Therefore, we need to mark them as columns in the
    tables and set the primary key. So, add the following annotations to the fields
    in the `Person` class:'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Person`表中的`id`、`firstName`和`lastName`字段被`Student`和`Teacher`共享。因此，我们需要将它们标记为表中的列，并设置主键。所以，向`Person`类中的字段添加以下注解：'
- en: '[PRE55]'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, column names in the table do not match class fields. Therefore, we have
    to specify the name attribute in `@Column` annotations.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，表中的列名与类字段不匹配。因此，我们必须在`@Column`注解中指定名称属性。
- en: 'Let''s now mark the `Student` class as `Entity`:'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在将`Student`类标记为`Entity`：
- en: '[PRE56]'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `Student` class has a `Date` field called `enrolledSince`, which is of
    the `java.util.Date` type. However, JDBC and JPA use the `java.sql.Date` type.
    If you want JPA to automatically convert `java.sql.Date` to `java.util.Date`,
    then you need to mark the field with the `@Temporal` annotation:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Student`类有一个名为`enrolledSince`的`Date`字段，其类型为`java.util.Date`。然而，JDBC和JPA使用的是`java.sql.Date`类型。如果您希望JPA自动将`java.sql.Date`转换为`java.util.Date`，则需要使用`@Temporal`注解标记该字段：'
- en: '[PRE57]'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Open the `Teacher` class and add the `@Entity` annotation to it:'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开`Teacher`类，并向其添加`@Entity`注解：
- en: '[PRE58]'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, map the `designation` field in the class:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，映射类中的`designation`字段：
- en: '[PRE59]'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have now added annotations for all tables and their fields that do not participate
    in table relationships. We will now model the relationships between tables in
    our classes.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已为所有不参与表关系的表和字段添加了注解。接下来，我们将建模我们类中表之间的关系。
- en: Configuring entity relationships
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置实体关系
- en: 'First, we will model the relationship between `Course` and `Teacher`. There
    is a one-to-many relationship between them: one teacher may teach a number of
    courses. Open `Course.java` in the editor. Open the JPA perspective in Eclipse
    JEE (Window | Open Perspective | JPA menu).'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们将建模`Course`和`Teacher`之间的关系。它们之间存在一对一的关系：一位教师可以教授多门课程。在编辑器中打开`Course.java`。在Eclipse
    JEE中打开JPA视角（窗口 | 打开视角 | JPA菜单）。
- en: Configuring many-to-one relationships
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置多对一关系
- en: 'With `Course.java` open in the editor, click on the JPA Details tab in the
    lower window (just below the editor window). In `Course.java`, click on the `teacher`
    member variable. The JPA Details tab shows the details of this attribute:'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编辑器中打开`Course.java`文件，点击下窗口中的JPA Details标签页（位于编辑器窗口下方）。在`Course.java`中，点击`teacher`成员变量。JPA
    Details标签页会显示这个属性的详细信息：
- en: '![](img/00116.jpeg)'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: 'Figure 4.24: JPA details of an entity attribute'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.24：实体属性的JPA详情
- en: Target entity is auto-selected (as `Teacher`) because we have marked `Teacher`
    as an entity and the type of the `teacher` field is `Teacher`.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标实体自动选择（作为`Teacher`），因为我们已将`Teacher`标记为实体，且`teacher`字段的类型为`Teacher`。
- en: However, Eclipse has assumed a one-to-one relationship between `Course` and
    `Teacher`, which is not correct. There is a many-to-one relationship between `Course`
    and `Teacher`. To change this, click on the (one_to_one) hyperlink at the top
    of the JPA Details view and select the Many To One in Mapping Type Selection dialog
    box.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Select only Merge and Refresh cascade options; otherwise, duplicate entries
    will be added in the `Teacher` table for every `Teacher` that you selected for
    a `Course`.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: See [https://javaee.github.io/tutorial/persistence-intro002.html#BNBQH](https://javaee.github.io/tutorial/persistence-intro002.html#BNBQH) for
    more details on entity relationships and cascade options.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you select Merge and Refresh cascade options, the `cascade` attribute
    added to the annotation is added to the `teacher` field in the `Course` entity:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Scroll down the JPA Details page to see Joining Strategy. This determines how
    columns in `Course` and `Teacher` tables are joined:'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.25: Editing Joining Strategy in an entity relationship'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the default joining strategy is that the `teacher_id` column in the `Course`
    table maps to the `id` column in the `Teacher` table. Eclipse has just guessed
    `teacher_id` (the appended `id` to the `teacher` field in the `Course` entity),
    but if we had a different join column in the `Course` table, for example, `teacherId`,
    then we would need to override the default join columns. Click on the Override
    default checkbox and then on the Edit button on the right-hand side of the textbox:'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.26: Editing Join Column'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our case, the default options match the table columns, so we will keep them
    unchanged. When you select the Override default checkbox, the `@JoinColumn` annotation
    is added to the `teacher` field in the `Course` entity:'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: All the required annotations for the `teacher` field are now added.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring many-to-many relationships
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now configure `Course` and `Student` entities for a many-to-many relationship
    (a course can have many students, and one student can take many courses).
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Many-to-many relations could be unidirectional or bidirectional. For example,
    you may only want to track students enrolled in the courses (so the `Course` entity
    will have a list of students) and not students taking the courses (the `Student`
    entity does not keep a list of courses). This is an unidirectional relationship
    where only the `Course` entity knows about the students, but the `Student` entity
    does not know about the courses).
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In a bidirectional relationship, each entity knows about the other one. Therefore,
    the `Course` entity will keep a list of students and the `Student` entity will
    keep a list of courses. We will configure the bidirectional relationship in this
    example.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A many-to-many relationship also has one owning side and the other inverse side.
    You can mark either entity in the relationship as the owning entity. From the
    configuration point of view, the inverse side is marked by the `mappedBy` attribute
    to the `@ManyToMany` annotation.
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多对多关系也有一个拥有方和一个反向方。您可以在关系中的任何实体上标记为拥有实体。从配置的角度来看，反向方通过`mappedBy`属性标记为`@ManyToMany`注解。
- en: In our application, we will make `Student` as the owning side of the relationship
    and `Course` as the inverse side. A many-to-many relationship in the database
    needs a join table, which is configured in the owning entity using the `@JoinTable`
    annotation.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将`Student`作为关系的拥有方，将`Course`作为反向方。数据库中的多对多关系需要一个连接表，该表通过`@JoinTable`注解在拥有实体中进行配置。
- en: 'We will first configure a many-to-many relationship in the `Course` entity.
    Add a member variable in `Course` to hold a list of `Student` entities and add
    the getter and the setter for it:'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先将在`Course`实体中配置一个多对多关系。在`Course`中添加一个成员变量以保存`Student`实体列表，并添加其getter和setter：
- en: '[PRE62]'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, click on the `students` field (added previously) and notice the settings
    in the JPA Details view:'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，点击之前添加的`students`字段，并注意JPA Details视图中的设置：
- en: '![](img/00119.jpeg)'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片3](img/00119.jpeg)'
- en: 'Figure 4.27: Default JPA details for the students field in Course Entity'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.27：Course实体中students字段的默认JPA详情
- en: Because the `students` field is a list of `Student` entities, Eclipse has assumed
    a one-to-many relationship (see the link at the top of the JPA Details view).
    We need to change this. Click on the one_to_many link and select Many To Many.
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为`students`字段是一个`Student`实体的列表，Eclipse已经假设了一个一对一的关系（参见JPA Details视图顶部的链接）。我们需要更改这一点。点击`one_to_many`链接并选择多对多。
- en: 'Check the Merge and Refresh cascade options. Since we are putting a `Course`
    entity on the inverse side of the relationship, select Mapped By as Joining Strategy.
    Enter `courses` in the Attributes text field. The compiler will show an error
    for this because we don''t have a `courses` field in the `Student` entity yet.
    We will fix this shortly. The JPA settings for the `students` field should be
    as shown in the following screenshot:'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查合并和刷新级联选项。由于我们在关系的反向侧放置了一个`Course`实体，请选择通过映射作为连接策略。在属性文本字段中输入`courses`。编译器将显示错误，因为我们还没有在`Student`实体中添加`courses`字段。我们将很快修复这个问题。`students`字段的JPA设置应如图所示：
- en: '![](img/00120.jpeg)'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片2](img/00120.jpeg)'
- en: 'Figure 4.28: Modified JPA settings for the students field in Course Entity'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.28：Course实体中students字段的修改后的JPA设置
- en: 'Annotations for the `students` field in the `Course` entity should be as follows:'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Course`实体中`students`字段的注解应如下所示：'
- en: '[PRE63]'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Open `Student.java` in the editor. Add the `courses` field and the getter and
    the setter for it. Click on the `courses` field in the file and change the relationship
    from one-to-many to many-to-many in JPA Details view (as described previously
    for the `students` field in the `Course` entity). Select the Merge and Refresh
    cascade options. In the Joining Strategy section, make sure that the Join table
    option is selected. Eclipse creates the default join table by concatenating the
    owning table and the inverse table, separated by an underscore (in this case `Student_Course`).
    Change this to Course_Student to make it consistent with the schema that we created
    for the JDBC application.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编辑器中打开`Student.java`。添加`courses`字段及其getter和setter。在文件中点击`courses`字段，并在JPA Details视图中将关系从一对一更改为多对多（如之前对`Course`实体中的`students`字段所描述）。选择合并和刷新级联选项。在连接策略部分，确保选择了连接表选项。Eclipse通过连接拥有表和反向表，并用下划线分隔（在这种情况下为`Student_Course`）创建默认的连接表。将其更改为`Course_Student`以使其与为JDBC应用程序创建的模式保持一致。
- en: In the Join columns section, select the Override default checkbox. Eclipse has
    named the join columns `students_id->id`, but in the Course_Student table we created
    in the JDBC application, we had a column named `student_id`. So, click the Edit
    button and change the name to student_id.
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在连接列部分，选择覆盖默认选项。Eclipse已将连接列命名为`students_id->id`，但在我们在JDBC应用程序中创建的`Course_Student`表中，我们有一个名为`student_id`的列。因此，点击编辑按钮并将名称更改为`student_id`。
- en: 'Similarly, change Inverse join columns from `courses_id->id` to `course_id->id`.
    After these changes, the JPA Details for the `courses` field should be as shown
    in the following screenshot:'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，将反向连接列从`courses_id->id`更改为`course_id->id`。在这些更改之后，`courses`字段的JPA Details应如图所示：
- en: '![](img/00121.jpeg)'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片1](img/00121.jpeg)'
- en: 'Figure 4.29: JPA Details for the courses field in Student entity'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.29：学生实体中courses字段的JPA详情
- en: 'The previous settings create the following annotations for the `courses` field:'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的设置为`courses`字段创建了以下注解：
- en: '[PRE64]'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have set all the entity relationships required for our application. Download
    the accompanying code for this chapter to see the complete source code for `Course`,
    `Student`, and `Teacher` entities.
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经设置了应用程序所需的所有实体关系。下载本章附带的代码，以查看`Course`、`Student`和`Teacher`实体的完整源代码。
- en: 'We need to add the entities we created previously in `persistence.xml`. Open
    the file and make sure that the General tab is open. In the Managed Classes session,
    click the Add button. Type the name of the entity you want to add (for example,
    `Student`) and select the class from the list. Add all the four entities we have
    created:'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要在`persistence.xml`中添加我们之前创建的实体。打开文件，确保“常规”选项卡已打开。在“管理类”会话中，点击“添加”按钮。输入要添加的实体名称（例如，`Student`），并从列表中选择类。添加我们创建的所有四个实体：
- en: '![](img/00122.jpeg)'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/00122.jpeg](img/00122.jpeg)'
- en: 'Figure 4.30: Add entities in persistence.xml'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.30：在persistence.xml中添加实体
- en: Creating database tables from entities
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从实体创建数据库表
- en: 'Follow these steps to create database tables from entities and relationships
    that we have modeled:'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下步骤从我们已建模的实体和关系创建数据库表：
- en: Right-click on the project and select JPA Tool | Generate Tables from Entities:![](img/00123.jpeg)
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目，选择JPA工具 | 从实体生成表：![img/00123.jpeg](img/00123.jpeg)
- en: 'Figure 4.31: JPA Details for the courses field in Student entity'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.31：学生实体中courses字段的JPA详情
- en: Because we haven't configured any schema for our JPA project, the Schema drop-down
    will be empty. Click the Add a connection to JPA project link:![](img/00124.jpeg)
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有为我们的JPA项目配置任何模式，因此“模式”下拉菜单将为空。点击“添加JPA项目连接”链接：![img/00124.jpeg](img/00124.jpeg)
- en: 'Figure 4.32: JPA project properties'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.32：JPA项目属性
- en: Click the Add connection link and create a connection to the `course_management_jpa`
    schema we created earlier. We have already seen how to create a connection to
    the MySQL schema in the *Using Eclipse Data Source Explorer* section of this chapter.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加连接”链接，创建到我们之前创建的`course_management_jpa`模式的连接。我们已经在本章的“使用Eclipse数据源资源管理器”部分中看到了如何创建到MySQL模式的连接。
- en: Select `course_management_jpa` in the drop-down list shown in *Figure 4.31*
    and click Next:![](img/00125.jpeg)
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图4.31所示的下拉列表中选择`course_management_jpa`，然后点击下一步：![img/00125.jpeg](img/00125.jpeg)
- en: 'Figure 4.33: Schema Generation from entities'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.33：从实体生成模式
- en: Click Finish.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: 'Eclipse generates DDL scripts for creating tables and relationships and executes
    these scripts in the selected schema. Once the script is run successfully, open
    the Data Source Explorer view (see the *Using Eclipse Data Source Explorer *section
    of this chapter) and browse tables in course_management_jpa connection. Make sure
    that tables and fields are created according to the entities we have created:'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Eclipse生成创建表和关系的DDL脚本，并在所选模式中执行这些脚本。一旦脚本成功运行，打开数据源资源管理器视图（参见本章的“使用Eclipse数据源资源管理器”部分），在`course_management_jpa`连接中浏览表。确保表和字段是根据我们创建的实体创建的：
- en: '![](img/00126.jpeg)'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/00126.jpeg](img/00126.jpeg)'
- en: 'Figure 4.34: Tables created from JPA entities'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.34：从JPA实体创建的表
- en: This feature of Eclipse and JPA makes it very easy to update the database as
    you modify your entities.
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Eclipse和JPA的这个特性使得在修改实体时更新数据库变得非常容易。
- en: Using JPA APIs to manage data
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA API管理数据
- en: We will now create classes that use JPA APIs to manage data for our course management application.
    We will create service classes for Course, Teacher, and Student entities and add
    methods that directly access the database through JPA APIs.
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将创建使用JPA API来管理课程管理应用程序数据的类。我们将为`Course`、`Teacher`和`Student`实体创建服务类，并添加直接通过JPA
    API访问数据库的方法。
- en: As mentioned in the *JPA concepts* section, it is a good practice to cache an
    instance of `EntityManagerFactory` in our application. Furthermore, managed beans
    of JSF act as a link between the UI and the backend code, and as a conduit to
    transfer data between the UI and the data access objects. Therefore, they must
    have an instance of the data access objects (which use JPA to access data from
    the database). To cache an instance of `EntityManagerFactory`, we will create
    another managed bean, whose only job is to make the `EntityManagerFactory` instance
    available to other managed beans.
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同在 *JPA 概念* 部分所述，将 `EntityManagerFactory` 的实例缓存到我们的应用程序中是一个好的实践。此外，JSF 的托管
    Bean 作为 UI 和后端代码之间的链接，以及 UI 和数据访问对象之间传输数据的通道。因此，它们必须有一个数据访问对象（使用 JPA 从数据库访问数据）的实例。为了缓存
    `EntityManagerFactory` 的实例，我们将创建另一个托管 Bean，其唯一的工作是使 `EntityManagerFactory` 实例对其他托管
    Bean 可用。
- en: 'Create an `EntityManagerFactoryBean` class in the `packt.book.jee.eclipse.ch4.jpa.service_bean`
    package. This package contains all the managed beans. `EntityManagerFactoryBean`
    creates an instance of `EntityManagerFactory` in the constructor and provides
    a getter method:'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `packt.book.jee.eclipse.ch4.jpa.service_bean` 包中创建一个 `EntityManagerFactoryBean`
    类。此包包含所有托管 Bean。`EntityManagerFactoryBean` 在构造函数中创建一个 `EntityManagerFactory` 实例并提供一个获取器方法：
- en: '[PRE65]'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note the argument passed in the following:'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下传递的参数：
- en: '[PRE66]'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It is the name of the persistence unit in `persistence.xml`.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `persistence.xml` 中持久化单元的名称。
- en: Now let's create service classes that actually use the JPA APIs to access database
    tables.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们创建实际使用 JPA API 访问数据库表的服务类。
- en: 'Create a package called `packt.book.jee.eclipse.ch4.jpa.service`. Create the
    class named `CourseService`. Every service class will need access to `EntityManagerFactory`.
    So, create a private member variable as follows:'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个名为 `packt.book.jee.eclipse.ch4.jpa.service` 的包。创建一个名为 `CourseService` 的类。每个服务类都需要访问
    `EntityManagerFactory`。因此，创建一个如下所示的私有成员变量：
- en: '[PRE67]'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The constructor takes an instance of `EntityManagerFactoryBean` and gets the
    reference of `EntityManagerFactory` from it:'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数接受一个 `EntityManagerFactoryBean` 实例，并从中获取 `EntityManagerFactory` 的引用：
- en: '[PRE68]'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s now add a function to get all `courses` from the database:'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们添加一个从数据库获取所有 `courses` 的函数：
- en: '[PRE69]'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note how `CriteriaBuilder`, `CriteriaQuery`, and `TypesQuery` are used to get
    all the courses. It is a type-safe way to execute the query.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `CriteriaBuilder`、`CriteriaQuery` 和 `TypesQuery` 如何用于获取所有课程。这是一种类型安全的查询执行方式。
- en: See [https://javaee.github.io/tutorial/persistence-criteria.html#GJITV](https://javaee.github.io/tutorial/persistence-criteria.html#GJITV)
    for detailed discussion on how to use the JPA criteria APIs.
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关如何使用 JPA 条件 API 的详细讨论，请参阅 [https://javaee.github.io/tutorial/persistence-criteria.html#GJITV](https://javaee.github.io/tutorial/persistence-criteria.html#GJITV)。
- en: 'We could have done the same thing using **Java Persistence Query Language**
    (**JQL**)—[http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html](http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html)—but
    it is not type-safe. However, here is an example of using JQL to write the `getCourses`
    function:'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用 **Java Persistence Query Language** (**JQL**)——[http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html](http://www.oracle.com/technetwork/articles/vasiliev-jpql-087123.html)——来完成相同的事情，但它不是类型安全的。然而，这里有一个使用
    JQL 编写 `getCourses` 函数的示例：
- en: '[PRE70]'
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add a method to insert the course into the database:'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加一个将课程插入数据库的方法：
- en: '[PRE71]'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The code is quite simple. We get the entity manager and then start a transaction,
    because it is an `update` operation. Then, we call the `persist` method on `EntityManager`
    by passing an instance of `Course` to save. Then, we commit the transaction. The
    methods to update and delete are also simple. Here is the entire source code of
    `CourseService`:'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码相当简单。我们获取实体管理器并开始一个事务，因为这是一个 `update` 操作。然后，我们通过传递一个 `Course` 实例来调用 `EntityManager`
    上的 `persist` 方法以保存。然后，我们提交事务。更新和删除的方法也很简单。以下是 `CourseService` 的整个源代码：
- en: '[PRE72]'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s now create `StudentService` and `TeacherService` classes with the following
    methods:'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们创建具有以下方法的 `StudentService` 和 `TeacherService` 类：
- en: '[PRE73]'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Wiring user interface with JPA service classes
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户界面与 JPA 服务类连接
- en: Now that we have all data access classes ready, we need to connect the user
    interface that we have created for adding courses, `addCourse.xhtml`, to pass
    data and get data from the JPA service classes. As mentioned previously, we are
    going to do this using managed beans, in this case, `CourseServiceBean`.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有数据访问类，我们需要将我们为添加课程创建的用户界面 `addCourse.xhtml` 连接到 JPA 服务类，以便传递数据和从
    JPA 服务类获取数据。如前所述，我们将使用托管 Bean 来完成这项工作，在这种情况下，`CourseServiceBean`。
- en: '`CourseServiceBean` will need to create an instance of `CourseService` and
    call the `addCourse` method. Open `CourseServiceBean` and create a member variable
    as follows:'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CourseServiceBean`需要创建`CourseService`的一个实例并调用`addCourse`方法。打开`CourseServiceBean`并创建如下成员变量：'
- en: '[PRE74]'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We also need an instance of the `EntityManagerFactoryBean` managed bean that
    we created earlier:'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要我们之前创建的`EntityManagerFactoryBean`托管Bean的一个实例：
- en: '[PRE75]'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `factoryBean` instance is injected by the JSF runtime and is available
    only after the managed bean is completely constructed. However, for this bean
    to be injected, we need to provide a setter method. Therefore, add a setter method
    for `factoryBean`. We can have JSF call a method of our bean after it is fully
    constructed by annotating the method with `@PostConstruct`. So, let''s create
    a method called `postConstruct`:'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`factoryBean`实例由JSF运行时注入，并且只有在托管Bean完全构建之后才可用。然而，为了使此Bean能够注入，我们需要提供一个setter方法。因此，为`factoryBean`添加一个setter方法。我们可以通过在方法上注解`@PostConstruct`来让JSF在Bean完全构建后调用我们的Bean的方法。所以，让我们创建一个名为`postConstruct`的方法：'
- en: '[PRE76]'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, modify the `addCourse` method to call our service method:'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，修改`addCourse`方法以调用我们的服务方法：
- en: '[PRE77]'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Since the `listCourse.xhtml` page will need to get a list of courses, let''s
    also add the `getCourses` method in `CourseServiceBean`:'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`listCourse.xhtml`页面需要获取课程列表，因此我们也在`CourseServiceBean`中添加了`getCourses`方法：
- en: '[PRE78]'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here is `CourseServiceBean` after the preceding changes:'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的更改之后，这是`CourseServiceBean`的代码：
- en: '[PRE79]'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we will write the code to display a list of courses in `listCourse.xhtml`:'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们将编写在`listCourse.xhtml`中显示课程列表的代码：
- en: '[PRE80]'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Because of space constraints, we will not discuss how to add functionality to
    delete/update courses, or to create a course with the `Teacher` field selected.
    Please download the source code for the examples discussed in this chapter to
    see completed projects.
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于空间限制，我们不会讨论如何添加删除/更新课程的功能，或者如何创建带有`Teacher`字段选中的课程。请下载本章讨论的示例的源代码，以查看完成的项目。
- en: Summary
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to build web applications that require accessing
    data from a relational database. First, we built a simple *Course Management*
    application using JDBC and JSTL, and then, the same application was built using
    JPA and JSF.
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何构建需要从关系型数据库访问数据的Web应用程序。首先，我们使用JDBC和JSTL构建了一个简单的*课程管理*应用程序，然后，使用JPA和JSF构建了相同的应用程序。
- en: JPA is preferred to JDBC because you end up writing a lot less code. The code
    to map object data to relational data is created for you by the JPA implementation.
    However, JDBC is still being used in many web applications because it is simpler
    to use. Although JPA has a moderate learning curve, JPA tools in Eclipse EE can
    make using JPA APIs a bit easier, particularly configuring entities, relationships,
    and `persistence.xml`.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与JDBC相比，JPA更受欢迎，因为最终你写的代码要少得多。映射对象数据到关系型数据的代码由JPA实现为你创建。然而，JDBC仍然被许多Web应用程序使用，因为它更简单易用。尽管JPA的学习曲线适中，但Eclipse
    EE中的JPA工具可以使使用JPA API变得更容易一些，尤其是在配置实体、关系和`persistence.xml`方面。
- en: In the next chapter, we will deviate a bit from our discussion on JEE and see
    how to write and run unit tests for Java applications. We will also see how to
    measure code coverage after running the unit tests.
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章中，我们将稍微偏离我们对JEE的讨论，看看如何为Java应用程序编写和运行单元测试。我们还将了解如何在运行单元测试后测量代码覆盖率。
