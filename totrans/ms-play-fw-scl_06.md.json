["```java\nsealed trait Step[E, +A] {\n\n  def it: Iteratee[E, A] = this match {\n    case Step.Done(a, e) => Done(a, e)\n    case Step.Cont(k) => Cont(k)\n    case Step.Error(msg, e) => Error(msg, e)\n  }\n\n}\n\nobject Step {\n\n  //done state of an iteratee\n  case class Done[+A, E](a: A, remaining: Input[E]) extends Step[E, A]\n\n  //continuing state of an iteratee.\n  case class Cont[E, +A](k: Input[E] => Iteratee[E, A]) extends Step[E, A]\n\n  //error state of an iteratee\n  case class Error[E](msg: String, input: Input[E]) extends Step[E, Nothing]\n}\n```", "```java\nsealed trait Input[+E] {\n  def map[U](f: (E => U)): Input[U] = this match {\n    case Input.El(e) => Input.El(f(e))\n    case Input.Empty => Input.Empty\n    case Input.EOF => Input.EOF\n  }\n}\n\nobject Input {\n\n  //An input element\n  case class El[+E](e: E) extends Input[E]\n\n  // An empty input\n  case object Empty extends Input[Nothing]\n\n  // An end of file input\n  case object EOF extends Input[Nothing]\n\n}\n```", "```java\ndef readLine(line: List[Array[Byte]] = Nil): Iteratee[Array[Byte], String] = Cont {\n      case Input.El(data) => {\n        val s = data.takeWhile(_ != '\\n')\n        if (s.length == data.length) {\n          readLine(s :: line)\n        } else {\n          Done(new String(Array.concat((s :: line).reverse: _*), \"UTF-8\").trim(), elOrEmpty(data.drop(s.length + 1)))\n        }\n      }\n      case Input.EOF => {\n        Error(\"EOF found while reading line\", Input.Empty)\n      }\n      case Input.Empty => readLine(line)\n    }\n```", "```java\ndef apply[T](debugName: String)(f: RequestHeader => Iteratee[Array[Byte], Either[Result, T]]): BodyParser[T] = new BodyParser[T] {\n    def apply(rh: RequestHeader) = f(rh)\n    override def toString = \"BodyParser(\" + debugName + \")\"\n  }\n```", "```java\ndef raw(memoryThreshold: Int): BodyParser[RawBuffer] = BodyParser(\"raw, memoryThreshold=\" + memoryThreshold) { request =>\n      import play.core.Execution.Implicits.internalContext\n      val buffer = RawBuffer(memoryThreshold)\n      Iteratee.foreach[Array[Byte]](bytes => buffer.push(bytes)).map { _ =>\n buffer.close()\n Right(buffer)\n }\n    }\n```", "```java\ndef file(to: File): BodyParser[File] = BodyParser(\"file, to=\" + to) { request =>\n      import play.core.Execution.Implicits.internalContext\n      Iteratee.fold[Array[Byte], FileOutputStream](new FileOutputStream(to)) {\n (os, data) =>\n os.write(data)\n os\n }.map { os =>\n os.close()\n Right(to)\n }\n    }\n```", "```java\ntrait Enumerator[E] {\n  parent =>\n  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]\n  ...\n}\nobject Enumerator{\ndef apply[E](in: E*): Enumerator[E] = in.length match {\n    case 0 => Enumerator.empty\n    case 1 => new Enumerator[E] {\n      def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = i.pureFoldNoEC {\n        case Step.Cont(k) => k(Input.El(in.head))\n        case _ => i\n      }\n    }\n    case _ => new Enumerator[E] {\n      def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = enumerateSeq(in, i)\n    }\n  }\n...\n}\n```", "```java\n  val line: String = \"What we need is not the will to believe, but the wish to find out.\"\n  val words: Seq[String] = line.split(\" \")\n\n  val src: Enumerator[String] = Enumerator(words: _*)\n\n  val sink: Iteratee[String, Int] = Iteratee.fold[String, Int](0)((x, y) => x + y.length)\n  val flow: Future[Iteratee[String, Int]] = src(sink)\n\n  val result: Future[Int] = flow.flatMap(_.run)\n```", "```java\n    val src: Enumerator[String] = Enumerator(words: _*)\n    ```", "```java\n    val flow: Future[Iteratee[String, Int]] = src(sink)\n    ```", "```java\n    val result: Future[Int] = flow.flatMap(_.run)\n    ```", "```java\nval src: Enumerator[String] = Enumerator(words: _*)\nval sink: Iteratee[String, Int] = Iteratee.fold[String, Int](0)((x, y) => x + y.length)\nval result: Future[Int] = src |>>> sink\n```", "```java\nval dataStream: Enumerator[String] = Enumerator.generateM {\n  Promise.timeout(Some(\"alive\"), 100 millis)\n}\n```", "```java\n  val unicastSrc = Concurrent.unicast[String](\n    channel =>\n      channel.push(line)\n  )\n\n  val unicastResult: Future[Int] = unicastSrc |>>> sink\n```", "```java\ndef unicast[E](onStart: (Channel[E]) â‡’ Unit,\n    onComplete: â‡’ Unit = (),\n    onError: (String, Input[E]) â‡’ Unit = (_: String, _: Input[E]) => ())(implicit ec: ExecutionContext): Enumerator[E] {â€¦}\n```", "```java\nval unicastSrc2 = Concurrent.unicast[String](\n    channel => channel.push(line),\n    onError = { (msg, str) => Logger.error(s\"encountered $msg for $str\")}\n      )\n```", "```java\n  val (broadcastSrc: Enumerator[String], channel: Concurrent.Channel[String]) = Concurrent.broadcast[String]  \n  private val vowels: Seq[Char] = Seq('a', 'e', 'i', 'o', 'u')\n\n  def getVowels(str: String): String = {\n    val result = str.filter(c => vowels.contains(c))\n    result\n  }\n\n  def getConsonants(str: String): String = {\n    val result = str.filterNot(c => vowels.contains(c))\n    result\n  }\n\n  val vowelCount: Iteratee[String, Int] = Iteratee.fold[String, Int](0)((x, y) => x + getVowels(y).length)\n\n  val consonantCount: Iteratee[String, Int] = Iteratee.fold[String, Int](0)((x, y) => x + getConsonants(y).length)\n\n  val vowelInfo: Future[Int]  = broadcastSrc |>>> vowelCount\n  val consonantInfo: Future[Int]  = broadcastSrc |>>> consonantCount\n\n  words.foreach(w => channel.push(w))\n  channel.end()\n\n  vowelInfo onSuccess { case count => println(s\"vowels:$count\")}\n  consonantInfo onSuccess { case count => println(s\"consonants:$count\")}\n```", "```java\ntrait Enumeratee[From, To] {\n...\ndef applyOn[A](inner: Iteratee[To, A]): Iteratee[From, Iteratee[To, A]]\n\ndef apply[A](inner: Iteratee[To, A]): Iteratee[From, Iteratee[To, A]] = applyOn[A](inner)\n...\n}\n```", "```java\n  def flatten[From, To](futureOfEnumeratee: Future[Enumeratee[From, To]]) = new Enumeratee[From, To] {\n    def applyOn[A](it: Iteratee[To, A]): Iteratee[From, Iteratee[To, A]] =\n      Iteratee.flatten(futureOfEnumeratee.map(_.applyOn[A](it))(dec))\n  }\n```", "```java\nval line: String = \"What we need is not the will to believe, but the wish to find out.\".toUpperCase\n```", "```java\n  val toSmallCase: Enumeratee[String, String] = Enumeratee.map[String] {\n    s => s.toLowerCase\n  }\n```", "```java\nval line: String = \"What we need is not the will to believe, but the wish to find out.\".toUpperCase\nval words: Seq[String] = line.split(\" \")\n\nval src: Enumerator[String] = Enumerator(words: _*)\n\nprivate val vowels: Seq[Char] = Seq('a', 'e', 'i', 'o', 'u')\ndef getVowels(str: String): String = {\n  val result = str.filter(c => vowels.contains(c))\n  result\n}\n\nsrc.through(toSmallCase) |>>> vowelCount\n\n```", "```java\nsrc &> toSmallCase |>>> vowelCount\n```", "```java\nsrc |>>> toSmallCase.transform(vowelCount)\n```", "```java\nsrc |>>> toSmallCase &>> vowelCount\n```", "```java\nval filterVowel: Enumeratee[String, String] = Enumeratee.map[String] {\n  str => str.filter(c => vowels.contains(c))\n}\n```", "```java\ntoSmallCase.compose(filterVowel)\n```", "```java\nsrc |>>> toSmallCase.compose(filterVowel) &>> sink\n```", "```java\n  val sink: Iteratee[String, Int] = Iteratee.fold[String, Int](0)((x, y) => x + y.length)\n```", "```java\nsrc |>>> toSmallCase ><> filterVowel &>> sink\n```", "```java\n  val toInt: Enumeratee[String, Int] = Enumeratee.map[String] {\n    str => str.length\n  }\n  val sum: Iteratee[Int, Int] = Iteratee.fold[Int, Int](0)((x, y) => x + y)\n  src |>>> toSmallCase ><> filterVowel ><> toInt &>> sum\n\n```"]