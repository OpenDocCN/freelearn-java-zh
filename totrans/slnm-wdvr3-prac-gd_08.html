<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Setting up Selenium Grid</h1>
                </header>
            
            <article>
                
<p>Now that we know what RemoteWebDriver is and how it works, we are ready to learn about Selenium Grid. In this chapter, we will cover the following topics:</p>
<ul>
<li>Why we need Selenium Grid</li>
<li>What Selenium Grid is</li>
<li>How we can use Selenium Grid</li>
<li>Test cases using Selenium Grid</li>
<li>Configuring Selenium Grid</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring Selenium Grid</h1>
                </header>
            
            <article>
                
<p>Let's try to understand why we need Selenium Grid by analyzing a scenario. You have a web application that needs to be tested on the following browser-machine combinations:</p>
<ul>
<li>Google Chrome on Windows 10</li>
<li>Google Chrome on macOS</li>
<li>Internet Explorer 11 on Windows 10</li>
<li>Firefox on Linux</li>
</ul>
<p>We can simply alter the test script we created in the previous chapter and point to the Selenium Standalone Server running on each of these combinations (that is, Windows 10, macOS, or Linux), as shown in the following code.</p>
<p>Windows 10: </p>
<pre>DesiredCapabilities caps = <span>new </span>DesiredCapabilities()<span>;<br/></span>caps.setBrowserName(<span>"chrome"</span>)<span>;<br/></span>caps.setPlatform(Platform.<span>WIN10</span>)<span>;<br/>WebDriver driver = new RemoteWebDriver(new URL("http://&lt;win_10_ip&gt;:4444/wd/hub"), capabilities);</span></pre>
<p>macOS: </p>
<pre>DesiredCapabilities caps = <span>new </span>DesiredCapabilities()<span>;<br/></span>caps.setBrowserName(<span>"chrome"</span>)<span>;<br/></span>caps.setPlatform(Platform.<span>MAC</span>)<span>;<br/>WebDriver driver = new RemoteWebDriver(new URL("http://&lt;mac_os_ip&gt;:4444/wd/hub"), capabilities);<br/></span></pre>
<p>Linux: </p>
<pre>DesiredCapabilities caps = <span>new </span>DesiredCapabilities()<span>;<br/></span>caps.setBrowserName(<span>"chrome"</span>)<span>;<br/></span>caps.setPlatform(Platform.LINUX)<span>;<br/>WebDriver driver = new RemoteWebDriver(new URL("http://&lt;linux_ip&gt;:4444/wd/hub"), capabilities);</span></pre>
<p>In the preceding code, your test scripts are tightly coupled to the machines that host the target platform and the target browsers. If the Windows 10 host changes, you should refactor your test script to handle that. This is not an ideal way to design your tests. The focus of your test scripts should be on the functionality of your web application and not on the infrastructure that is used to execute these test scripts. There should be a central point to manage all the different environments. To solve this, we make use of <strong>Selenium Grid</strong>.</p>
<p>The <strong>Selenium Grid</strong> offers a cross-browser testing environment with several different platforms (such as Windows, Mac, and Linux) to execute tests. The Selenium Grid is managed from a central point, called the <strong>hub.</strong> The hub has the information of all the different testing platforms, known as <strong>nodes</strong> (the machines that have the desired operating systems and browser versions and connected to the hub). The hub<strong> </strong>assigns these nodes to execute tests whenever the test scripts request them, based on the capabilities requested by the test. The following diagram shows what a Selenium Grid looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fbc7b253-0888-47d2-a7e7-4279585bd71d.png" style="width:33.67em;height:31.92em;"/></div>
<p>In the preceding diagram, there is one <span class="packt_screen">hub</span>, four <em><span class="packt_screen">nodes</span></em> of different platforms, and the machine where the test scripts are located. The test script will communicate with the hub and request a target platform to be executed. The hub assigns a node with the target platform to the test script. The node executes the test script and sends the result back to the hub, which in turn forwards the results to the test script. This is what Selenium Grid looks like and how it works at a high level.</p>
<p>Now that we have seen how Selenium Grid works theoretically, let's see what works as hubs and nodes in it. Fortunately, as we are dealing with Selenium Grid, we can use the same Remote WebDriver server that we used in the previous chapter to work as Selenium Grid as well. If you remember, we used <kbd>seleniumserver-standalone-3.12.0.jar</kbd> to start as a Selenium Standalone Server. We can use the same JAR file to be started in the hub mode on the hub machine, and a copy of the JAR file can be started in the node mode on the node machine. Try executing the following command on your JAR file:</p>
<pre>java –jar selenium-server-standalone-3.12.0.jar –help</pre>
<p class="mce-root"/>
<p>The following output shows how to use the server in a grid environment:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8247e16b-eaa5-4054-979b-90ffc3ad7c72.png" style="width:43.83em;height:44.25em;"/></div>
<p>You will see two options: to use it as a Standalone Server, which acts as a Remote WebDriver, and to use it in a grid environment, which describes Selenium Grid. In this chapter, we will use this JAR file as a Selenium Grid.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the hub</h1>
                </header>
            
            <article>
                
<p>The hub is the central point of a Selenium Grid. It has a registry of all the available nodes that are connected and part of a particular grid. The hub is a Selenium Standalone server running in the hub mode, listening on port <kbd>4444</kbd> of a machine by default. The test scripts will try to connect to the hub on this port, just as any Remote WebDriver. The hub will take care of rerouting the test-script traffic to the appropriate test-platform node. Let's see how we can start a hub node. Navigate to the location where you have your Selenium server JAR file and execute the following command:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role hub</pre>
<p>Doing this will start your server in the hub mode. By default, the server starts listening on port <kbd>4444</kbd>; however, you can start your server on the port of your choice. Suppose you want to start the server on port <kbd>1111</kbd>; it can be done as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role hub –port 1111</pre>
<p>The following screenshot shows the console output of the Grid Hub being started on port <kbd>1111</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6459fe27-fa58-4c64-b753-8cccc6bc503b.png"/></div>
<p>All the test scripts should connect to the hub on this port. Now launch your browser and connect to the machine that is hosting your hub on port <kbd>1111</kbd>. Here, the machine that is hosting my hub has the IP address 192.168.0.101.</p>
<p>What you should see on your browser is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f77746ed-d5f5-4e91-9b25-a59b4462e838.png" style="width:42.42em;height:15.42em;"/></p>
<p>It shows the version of the server that is being used as the Grid Hub. Now click the <span class="packt_screen">Console</span> link to navigate to the Grid Console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1af75304-9500-4607-a906-510654f2310b.png" style="width:44.33em;height:26.08em;"/></div>
<p>As you can see, the page talks about many configuration parameters. We will discuss these configuration parameters in the <em>Configuring Selenium Grid</em> section. So, you've now learned how to start a grid on a port and listen for connections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the node</h1>
                </header>
            
            <article>
                
<p>As our hub is up and running, it's now time to start a node and connect it to the hub. In this example, we will configure a macOS machine that has Chrome installed on it. So, if any test script requests the hub for a macOS platform and Chrome browser, the hub will choose this node. Let's see how we can start the node. The command to start the node and register with the hub is as follows:</p>
<pre>java –jar selenium-server-standalone-3.12.0.jar –role node –hub http://192.168.0.101:1111/grid/register</pre>
<p>This will start the Selenium server in the node mode and register this node with the already-started hub:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91992fe4-f543-45ad-abe3-006e42cbc925.png"/></p>
<p>If you go back to the Grid Console on the browser, you will see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/77dc8da7-4873-4de6-9730-50f8447e3f8e.png" style="width:42.92em;height:19.83em;"/></p>
<p class="mce-root"/>
<p>The preceding screenshot shows the <span class="packt_screen">http://192.168.0.101:16784</span> node URL, which, in this case, is running on the Mac platform. By default, the number of browsers listed for every node is 11: 5 for Firefox, five for Chrome, and one for IE. This can be overridden by specifying the <kbd>browser</kbd> option, which we will see in the <em>Configuring Selenium Grid</em> section. </p>
<p>Similarly, start another node on Windows and register to the hub using the same command used to start the node on macOS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying the existing test script to use Selenium Grid</h1>
                </header>
            
            <article>
                
<p>So far, we have seen test scripts that run on our local machines or on Selenium Standalone servers. Executing test scripts on Selenium Grid is very similar to executing tests on Remote WebDriver, except that you will also mention the platform details for Grid.</p>
<p>Let's look at a test script that uses the Remote WebDriver server:</p>
<pre><span>public class </span>SearchTest {<br/><br/>    WebDriver <span>driver</span><span>;<br/></span><span><br/></span><span>    </span><span>@BeforeMethod<br/></span><span>    </span><span>public void </span><span>setup</span>() <span>throws </span>MalformedURLException {<br/><br/>        DesiredCapabilities caps = <span>new </span>DesiredCapabilities()<span>;<br/></span><span><br/></span><span>        </span>caps.setBrowserName(<span>"chrome"</span>)<span>;<br/></span><span>        </span>caps.setPlatform(Platform.<span>MAC</span>)<span>;<br/></span><span><br/></span><span>        </span><span>driver </span>= <span>new </span>RemoteWebDriver(<span>new </span>URL(<span>"http://192.168.0.101:1111/wd/hub"</span>)<span>, </span>caps)<span>;<br/></span><span>        </span><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com/"</span>)<span>;<br/></span><span><br/></span><span>    </span>}<br/><br/>    <span>@Test<br/></span><span>    </span><span>public void </span><span>searchProduct</span>() {<br/><br/>        <span>// find search box and enter search string<br/></span><span>        </span>WebElement searchBox = <span>driver</span>.findElement(By.<span>name</span>(<span>"q"</span>))<span>;<br/></span><span><br/></span><span>        </span>searchBox.sendKeys(<span>"Phones"</span>)<span>;<br/></span><span><br/></span><span>        </span>WebElement searchButton =<br/>                <span>driver</span>.findElement(By.<span>className</span>(<span>"search-button"</span>))<span>;<br/></span><span><br/></span><span>        </span>searchButton.click()<span>;<br/></span><span><br/></span><span>        </span><span>assertThat</span>(<span>driver</span>.getTitle())<br/>                .isEqualTo(<span>"Search results for: 'Phones'"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@AfterMethod<br/></span><span>    </span><span>public void </span><span>tearDown</span>() {<br/>        <span>driver</span>.quit()<span>;<br/></span><span>    </span>}<br/>} </pre>
<p>Now try executing the preceding test script and observe the log output of the hub and the node. The output log of the hub is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1aa8480-8f1b-499d-bf4f-f24a999d0261.png"/></p>
<p>The sequence of steps that happens at the hub end is as follows:</p>
<ol>
<li>The hub gets a request to create a new session for <kbd>platform=MAC, browserName=chrome</kbd>.</li>
<li>It verifies the available nodes that match the <kbd>capabilities</kbd> request.</li>
<li>If available, it creates a new session with the node host; if not, it rejects the request from the test script, saying that the desired capabilities don't match any of the registered nodes.</li>
<li>If a session is created with the node host in the preceding step, create a new test-slot session and hand over the test script to the node. Similarly, the output you should see in the console log of the hub is as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4c9ca183-59a5-45a3-a5f0-b81d29f053cd.png"/></p>
<p class="mce-root"/>
<p>The sequence of steps performed on the node is as follows:</p>
<ol>
<li>The node host creates a new session with the requested desired capabilities. This will launch the browser.</li>
<li>It executes the test script's steps on the launched browser.</li>
<li>It ends the session and forwards the result to the hub, which in turn sends it to the test script.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requesting for non-registered capabilities</h1>
                </header>
            
            <article>
                
<p>The hub will reject the request from the test script when the test script asks for a capability that is not registered with the hub. Let's modify the preceding test script to request the Opera browser instead of Chrome. The test script should look as follows:</p>
<pre><span>@BeforeMethod<br/></span><span>public void </span><span>setup</span>() <span>throws </span>MalformedURLException {<br/><br/>    DesiredCapabilities caps = <span>new </span>DesiredCapabilities()<span>;<br/></span><span><br/></span><span>    </span>caps.setBrowserName(<span>"opera"</span>)<span>;<br/></span><span>    </span>caps.setPlatform(Platform.<span>MAC</span>)<span>;<br/></span><span><br/></span><span>    </span><span>driver </span>= <span>new </span>RemoteWebDriver(<span>new </span>URL(<span>"http://192.168.0.101:1111/wd/hub"</span>)<span>, </span>caps)<span>;<br/></span><span>    </span><span>driver</span>.get(<span>"http://demo-store.seleniumacademy.com/"</span>)<span>;<br/></span><span><br/></span>}</pre>
<p>The hub checks whether there is any node that matches the desired capabilities. If it doesn't find one (as in this case), it will reject the request from the test script by throwing a <kbd>CapabilityNotPresentOnTheGridException</kbd> exception, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c0e6b5a2-26eb-47c3-b637-65aa72d3d77e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queuing up the request if the node is busy </h1>
                </header>
            
            <article>
                
<p>By default, you can send five test-script requests to any node. Although it is possible to change that configuration, let's see what happens when a node is already serving five requests, and you fire up another request for that node via the hub. The hub will keep polling the node until it gets a free test slot from the node. The test scripts are made to wait during this time. The hub says there are no free slots for the sixth session to be established with the same node. Meanwhile, on the node host, the node tries to create sessions for the five requests and starts executing the test scripts. </p>
<p>Upon creating the sessions, five Chrome windows are launched and the test scripts are executed on them. After serving the first five test-script requests, the hub will establish the waiting sixth session with the node, and the sixth request will be served.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with two nodes with matching capabilities                                              </h1>
                </header>
            
            <article>
                
<p>There are many configuration options that Selenium Grid provides to control the behavior of a node and a hub while you execute your test scripts. We will discuss them here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Selenium Grid</h1>
                </header>
            
            <article>
                
<p>There are many configuration options that Selenium Grid provides to control the behavior of a node and a hub while you execute your test scripts. We will discuss them here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying node-configuration parameters</h1>
                </header>
            
            <article>
                
<p class="p1">In this section, we will go through the configuration parameters for a node.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting supported browsers by a node</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, when we register a node with a hub, by default, the node is shown as supporting five instances of the Firefox browser, five instances of the Chrome browser, and one instance of Internet Explorer, irrespective of whether the node actually supports them. But to register your node with the browsers of your choice, Selenium Grid provides a browser option, using which we can achieve this. Let's say we want our node to be registered to support Firefox, Chrome, and Safari; we can do that using the following command:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role node -hub http://192.168.0.1:1111/grid/register -browser browserName=firefox -browser browserName=chrome -browser browserName=safari</pre>
<p>The <span class="packt_screen">Grid Console</span> looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bf5f2d66-9ec1-4d46-9a7b-83d57842e2b6.png" style="width:44.25em;height:19.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting node timeouts</h1>
                </header>
            
            <article>
                
<p>This parameter is set when registering a node with a hub. The value provided to these parameters is the time in seconds that a hub can actually wait before it terminates a test script execution on a node if the test script doesn't perform any kind of activity on the node.</p>
<p>The command to configure your node with a node timeout is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role node -hub http://192.168.0.1:1111/grid/register -nodeTimeout 300</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, we have registered a node with a node timeout value of 300 seconds. So, the hub will terminate the test script if it doesn't perform any activity on the node for more than 300 seconds.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting the limit on browser instances</h1>
                </header>
            
            <article>
                
<p>We have seen that, by default, there are 11 instances of browsers getting registered to a node. We have seen how to register our own browser. In this section, we will see how many instances of those browsers we can allow in our node. For this to be controlled, Selenium Grid comes out with a configuration parameter, called <kbd>maxInstances</kbd>, using which we can specify how many instances of a particular browser we want our node to provide. The command to do that is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role node -hub http://192.168.0.1:1111/grid/register -browser "browserName=firefox,max Instances=3" -browser "browserName=chrome,maxInstances=3" -browser "browserName=safari,maxInstances=1"</pre>
<p>Here, we are registering a node that provides three instances of Firefox, three instances of Chrome, and one instance of Safari. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reregistering the node automatically</h1>
                </header>
            
            <article>
                
<p>If the hub crashes or restarts after a node registers to it, all the information of the nodes that are already registered is lost. Going back to each of the nodes and reregistering them manually would prove to be tedious. The impact will be even worse if we haven't realized that the hub has restarted, because all the test scripts would fail as a result. So, to handle this kind of situation, Selenium Grid provides a configuration parameter to a node, through which we can specify the node to reregister itself automatically to the hub after a specified amount of time. If not specified, the default time of reregistration is five seconds. This way, we really don't have to worry; even if the hub crashes or restarts, our node will try to reregister every five seconds.</p>
<p>If you want to modify this time interval, the configuration parameter to deal with is <kbd>registerCycle</kbd>. The command to specify is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role node -hub http://192.168.0.1:1111/grid/register -registerCycle 10000</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="p1">The output you will see on the node log console during startup is as follows:</p>
<pre>17:47:01.231 INFO - starting auto register thread. Will try to register every 10000 ms.<br/> 17:47:01.232 INFO - Registering the node to hub :http://192.168.0.1:1111/grid/register</pre>
<p class="mce-root">The node will try to register to the hub every 1,000 milliseconds.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting node health-check times</h1>
                </header>
            
            <article>
                
<p>Using this configuration parameter, we can specify how frequently the hub can poll a node for its availability. The parameter that is used to achieve this is <kbd>nodePolling</kbd>. By specifying this to the hub at the node level, each node can specify its own frequency at which it can be health-checked. The command to configure your node is as follows:</p>
<pre> java -jar selenium-server-standalone-3.12.0.jar -role node -hub http://192.168.0.1:1111/grid/register -nodePolling 10</pre>
<p>Now the hub will poll this node every 10 seconds, to check its availability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unregistering an unavailable node</h1>
                </header>
            
            <article>
                
<p>Although the <kbd>nodePolling</kbd> configuration will make the hub poll the node often, the <kbd>unregisterIfStillDownAfter</kbd> configuration will let the hub unregister the node if the poll doesn't produce an expected result. Let's say a node is down, and the hub tries to poll the node and is unable to connect to it. At this point, how long the hub is going to poll for the availability of the node is determined by the <kbd>unregisterIfStillDownAfter</kbd> parameter. Beyond this time, the hub will unregister the node.</p>
<p>The command to do that is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role node -hub http://192.168.0.1:1111/grid/register -nodePolling 5 -unregistIfStillDownAfter 20000</pre>
<p>Here, the hub will poll the node every five seconds; if the node is down, the polling will continue for 20 seconds, that is, the hub will poll four times and then unregister the node from the grid.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting the browser timeout</h1>
                </header>
            
            <article>
                
<p>This configuration is to let the node know how long it should wait before it ends a test script session when the browser seems to hang. After this time, the node will abort the browser session and start with the next waiting test script. The configuration parameter for this is <kbd>browserTimeout</kbd>. The command to specify that is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role node -hub http://192.168.0.1:1111/grid/register –browserTimeout 60</pre>
<p>So, these are the some of the configuration parameters that you can specify at the node's end to have better control over the Selenium Grid environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hub-configuration parameters</h1>
                </header>
            
            <article>
                
<p>This section talks about some of the configuration parameters on the hub side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Waiting for a match of the desired capability</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, when the test script asks for a test platform with a desired capability, the hub will reject the request if it doesn't find a suitable node with the desired capability.</p>
<p>Altering the value for the <kbd>throwOnCapabilityNotPresent</kbd> parameter can alter this behavior. By default, it is set to <kbd>true</kbd>, which means the hub will reject the request if it doesn't find a suitable node with that capability. But setting this parameter to <kbd>false</kbd> will queue the request, and the hub will wait until a node with that capability is added to the grid. The command that has to be invoked is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role hub -port 1111 -throwOnCapabilityNotPresent false</pre>
<p>Now the hub will not reject the request, but will place the request in a queue and wait until the requested platform is available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customized CapabilityMatcher</h1>
                </header>
            
            <article>
                
<p>By default, the hub will use the <kbd>org.openqa.grid.internal.utils. DefaultCapabilityMatcher</kbd> class to match the requested node. If you do not like the implementation logic of the <kbd>DefaultCapabilityMatcher</kbd> class, you can extend the class, implement your own <kbd>CapabilityMatcher</kbd> class, and provide your own logic in it.</p>
<p class="mce-root"/>
<p>Once developed, you can ask the hub to use that class to match the capabilities with the nodes, using a configuration parameter named <kbd>capabilityMatcher</kbd>. The command to achieve this is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role hub -port 1111 -capabilityMatcher com.yourcomp.CustomCapabilityMatcher</pre>
<p>The hub will use the logic defined in your <kbd>CustomCapabilityMatcher</kbd> class to identify the nodes to be assigned to the test-script requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WaitTimeout for a new session</h1>
                </header>
            
            <article>
                
<p>When a capability-matched node is busy executing other test scripts, the latest test script will wait for the node to be available. By default, there is no wait timeout; that is, the test script will wait for the node to be available indefinitely. To alter that behavior and to let the test script throw an exception if it doesn't get the node within a limited time, Selenium Grid opens a configuration that enables the test script to do so. The configuration parameter controlling that behavior is <kbd>newSessionWaitTimeout</kbd>. The command for that is as follows:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role hub -port 1111 -newSessionWaitTimeout 120000</pre>
<p>Here, the test script will wait for two minutes before it throws an exception saying it couldn't obtain a node to execute itself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Different ways to specify the configuration</h1>
                </header>
            
            <article>
                
<p>There are two ways to specify the configuration parameter to the Selenium Grid's hub and node. The first one is what we have seen all this time; that is, specifying the configuration parameters over the command line. The second way of doing it is by providing a JSON file that contains all these configuration parameters.</p>
<p>A node configuration file (say, <kbd>nodeConfig.json</kbd>) — a typical JSON file having all the configuration parameters — looks similar to the following:</p>
<pre>{<br/>  "class": "org.openqa.grid.common.RegistrationRequest",<br/>  "capabilities": [<br/>   {<br/>   "seleniumProtocol": "WebDriver",<br/>   "browserName": "internet explorer",<br/>   "version": "10",<br/>   "maxInstances": 1,<br/>   "platform" : "WINDOWS"<br/>   }<br/>  ],<br/>  "configuration": {<br/>   "port": 5555,<br/>   "register": true,<br/>   "host": "192.168.1.102",<br/>   "proxy": "org.openqa.grid.selenium.proxy.<br/>   DefaultRemoteProxy",<br/>   "maxSession": 2,<br/>   "hubHost": "192.168.1.100",<br/>   "role": "webdriver",<br/>   "registerCycle": 5000,<br/>   "hub": "http://192.168.1.101:111/grid/register",<br/>   "hubPort": 1111,<br/>   "remoteHost": "http://192.168.1.102:5555"<br/>  }<br/>}</pre>
<p>Once these files are configured, they can be provided to the node and the hub, using the following command:</p>
<pre>java -jar selenium-server-standalone-3.12.0.jar -role node -nodeConfig nodeconfig.json </pre>
<p>This way, you can specify the configuration of your hub and node using JSON files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using cloud-based grids for cross-browser testing</h1>
                </header>
            
            <article>
                
<p>To set up a Selenium Grid for cross-browser testing, you need to set up physical or virtual machines with different browsers and operating systems. This requires an investment in the required hardware, software, and support to run the test lab. You also need to put in effort to keep this infrastructure updated with the latest versions and patches. Not everybody can afford these costs and the effort.</p>
<p>Instead of investing and setting up a cross-browser test lab, you can easily outsource a virtual test lab to a third-party cloud provider for cross-browser testing. The Sauce Labs and BrowserStack are leading cloud-based cross-browser testing cloud providers. Both of these have support for over 400 different browser and operating system configurations, including mobile and tablet devices, and support running Selenium WebDriver tests in their cloud.</p>
<p class="mce-root"/>
<p>Here, we will set up and run a test in the Sauce Labs cloud. The steps are similar if you want to run tests with BrowserStack.</p>
<p>Let's set up and run a test with Sauce Labs. You need a free Sauce Labs account, to begin with. Register for a free account on Sauce Labs at <a href="https://saucelabs.com/">https://saucelabs.com/,</a> and get the username and access key. Sauce Labs provides all the needed hardware and software infrastructure to run your tests in the cloud. You can get the access key from the Sauce Labs dashboard after you log in from the <span class="packt_screen">My Account</span> page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d93aacf3-b822-4864-80df-e010bfede7a3.png"/></div>
<p>Let's create a new test to execute on the Sauce Labs cloud. We need to add the Sauce username and access key to the test, and change the Grid address to the Sauce Labs Grid address instead of the local Selenium Grid, as shown in the following code example:</p>
<pre><span>public class </span>BmiCalculatorTest {<br/><br/>    WebDriver driver<span>;<br/></span><span><br/></span><span>    </span>@BeforeMethod<br/>    <span>public void </span>setUp() <span>throws </span>Exception {<br/><br/>        String SAUCE_USER = <span>"upgundecha"</span><span>;<br/></span><span>        </span>String SAUCE_KEY = <span>"5768f2a9-33be-4ebd-9a5f-3826d7c38ec9"</span><span>;<br/></span><span><br/></span><span>        </span>DesiredCapabilities caps = <span>new </span>DesiredCapabilities()<span>;<br/></span><span>        </span>caps.setCapability(<span>"platform"</span><span>, </span><span>"OS X 10.9"</span>)<span>;<br/></span><span>        </span>caps.setCapability(<span>"browserName"</span><span>, </span><span>"Safari"</span>)<span>;<br/></span><span>        </span>caps.setCapability(<span>"name"</span><span>, </span><span>"BMI Calculator Test"</span>)<span>;<br/></span><span>        </span>driver = <span>new </span>RemoteWebDriver(<br/>                <span>new </span>URL(MessageFormat.format(<span>"http://{0}:{1}@ondemand.saucelabs.com:80/wd/hub'"</span><span>,<br/></span><span>                </span>SAUCE_USER<span>, </span>SAUCE_KEY))<span>, </span>caps)<span>;<br/></span><span>        </span>driver.get(<span>"http://bit.ly/1zdNrFZ"</span>)<span>;<br/></span><span><br/></span><span>    </span>}<br/><br/>    @Test<br/>    <span>public void </span>testBmiCalc() {<br/>        WebElement height = driver.findElement(By.name(<span>"heightCMS"</span>))<span>;<br/></span><span>        </span>height.sendKeys(<span>"181"</span>)<span>;<br/></span><span><br/></span><span>        </span>WebElement weight = driver.findElement(By.name(<span>"weightKg"</span>))<span>;<br/></span><span>        </span>weight.sendKeys(<span>"80"</span>)<span>;<br/></span><span><br/></span><span>        </span>WebElement calculateButton = driver.findElement(By.id(<span>"Calculate"</span>))<span>;<br/></span><span>        </span>calculateButton.click()<span>;<br/></span><span><br/></span><span>        </span>WebElement bmi = driver.findElement(By.name(<span>"bmi"</span>))<span>;<br/></span><span>        </span>assertEquals(bmi.getAttribute(<span>"value"</span>)<span>, </span><span>"24.4"</span>)<span>;<br/></span><span><br/></span><span>        </span>WebElement bmi_category = driver.findElement(By.name(<span>"bmi_category"</span>))<span>;<br/></span><span>        </span>assertEquals(bmi_category.getAttribute(<span>"value"</span>)<span>, </span><span>"Normal"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    @AfterMethod<br/>    <span>public void </span>tearDown() <span>throws </span>Exception {<br/>        driver.quit()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>When you execute the test, it will connect to Sauce Lab's hub and request the desired operating system and browser configuration. The sauce Labs cloud-management software automatically assigns a virtual machine for our test to run on a given configuration. We can monitor this run on a dashboard, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dc6ef1a3-3007-4769-8682-456574cbfa93.png"/></p>
<p>We can further drill down into the session and see exactly what happened during the run. It provides details of the Selenium commands, screenshots, logs, and a video of the execution on multiple tabs, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fae2e51c-21b7-4d7b-9b47-2f29c7a10bd8.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Selenium details window</span></div>
<div class="packt_tip">You can also test applications that are securely hosted on internal servers, by using the Sauce Connect utility. sauce connect creates a secure tunnel between your machine and the Sauce cloud.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about Selenium Grid, how a hub and node will work, and, more importantly, how to configure your Selenium Grid to have better control over the environment and infrastructure. The Selenium Grid will enable cross-browser testing for the application by covering combinations of operating systems and browsers. We also saw how to use cloud services, such as Sauce Labs, to execute tests in a remote cloud environment.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the next <a href="608e2a19-b767-45e2-97e9-446eb16b35b6.xhtml">chapter</a>, we will learn how to create reusable and modular tests using the Page Object pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which argument can be used to specify how many browser instances can be supported by the node?</li>
<li>Explain how Selenium Grid can be used to support Cross Browser Testing.</li>
<li>What is the URL you need to specify with RemoteWebDriver to run tests on Selenium Grid?</li>
<li>Selenium Grid Hub acts as a load balancer— true or false?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further information</h1>
                </header>
            
            <article>
                
<p><span>You can check out the following link for more information about the topics covered in this chapter:</span></p>
<ul>
<li>Read more about Selenium Grid at <a href="https://www.seleniumhq.org/docs/07_selenium_grid.jsp">https://www.seleniumhq.org/docs/07_selenium_grid.jsp</a></li>
</ul>


            </article>

            
        </section>
    </body></html>