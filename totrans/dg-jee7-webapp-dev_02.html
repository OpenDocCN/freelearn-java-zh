<html><head></head><body><div class="book" title="Chapter&#xA0;2.&#xA0;JavaServer Faces Lifecycle"><div class="book" id="aid-NQU22"><div class="book"><div class="book"><h1 class="title"><a id="ch02" class="calibre1"/>Chapter 2. JavaServer Faces Lifecycle</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote1" summary="Block quote"><tr class="calibre12"><td valign="top" class="calibre13"> </td><td valign="top" class="calibre13"><p class="calibre14"><span><em class="calibre15">"No two people on earth are alike, and it's got to be that way in music or it isn't music"</em></span></p></td><td valign="top" class="calibre13"> </td></tr><tr class="calibre12"><td valign="top" class="calibre13"> </td><td colspan="2" valign="top" class="calibre16">--<span><span><em class="calibre15">Billie Holiday</em></span></span></td></tr></table></div><p class="calibre7">Java has been a complete success in the server side for a long time: since the year 2000. Businesses have trusted the JVM, Java programming language, and abundance of frameworks as their platform of choice for enterprise software. So, are we correct in continuing to put our trust in the JVM as digital web engineers? I think the answer to that question, and because you are reading this book, is yes!</p><p class="calibre7">This chapter is an<a id="id100" class="calibre1"/> expansive overview of the <span class="strong"><strong class="calibre8">JavaServer Faces</strong></span> (<span class="strong"><strong class="calibre8">JSF</strong></span>) concepts. We will start with the history and purpose of JSF and how it relates to the fundamental design pattern: the <span class="strong"><strong class="calibre8">Model-View-Controller</strong></span> (<span class="strong"><strong class="calibre8">MVC</strong></span>). We <a id="id101" class="calibre1"/>will explore the life cycle concepts in JSF, which is one of the key concepts that separates it from the other Java web application frameworks. Moreover, we will examine some JSF code, including the nefarious concept of managed beans. We will also cover how a JSF application navigates between the POJOs and pages. To sweeten this, we will meander in the powerful expression language for page authors. By the time we finish the chapter, we will have built a solid foundation of knowledge.</p><div class="book" title="Introduction to JSF"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec18" class="calibre1"/>Introduction to JSF</h1></div></div></div><p class="calibre7">JSF is a specification to build a web user interface from a component model. It encompasses a MVC and templating framework. JSF is a standard library of the Java EE platform. The <a id="id102" class="calibre1"/>
<span class="strong"><strong class="calibre8">Java Community Process</strong></span> (<span class="strong"><strong class="calibre8">JCP</strong></span>) controls <a id="id103" class="calibre1"/>the specifications, and the current <a id="id104" class="calibre1"/>version is JSF 2.2, which is defined by <span class="strong"><strong class="calibre8">Java Specification Request</strong></span> (<span class="strong"><strong class="calibre8">JSR</strong></span>) 334 (<a class="calibre1" href="https://www.jcp.org/en/jsr/detail?id=344">https://www.jcp.org/en/jsr/detail?id=344</a>).</p><p class="calibre7">Originally, the promise behind JSF was to bring rapid user interface development to server-side Java. This statement was true when JSF was first conceived; but of course, it is still useful if you <a id="id105" class="calibre1"/>would rather not write a lot of JavaScript code and hand crafted boilerplate so as to handle the transformation of an HTTP request to the Java invocations and back-to-page responses. Web technology and, in particular, digital development has leaped off the web pages since JSF 1.0 was conceived in 2004. Back then, JavaScript was not taken as a programming language so seriously as it is now; there was no responsive web design and there was certainly less demand for mobile web programming. Nowadays, it is common to see terms such as mobile first or digital by default. This means that websites consider all sorts of screen sizes and devices and recognize that people can view the content on a smartphone or tablet. Some people (your target customers) do not have access to a desktop PC or laptop.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre7">See Cameron Moll's pioneering—but now slightly dated—e-book on mobile web design (<a class="calibre1" href="http://mobilewebbook.com/">http://mobilewebbook.com/</a>). The UK government places great emphasis on the term, Digital by Default (<a class="calibre1" href="https://www.gov.uk/service-manual/digital-by-default">https://www.gov.uk/service-manual/digital-by-default</a>), which has been followed up by the expansive Default to Open term from the United States Digital Service (<a class="calibre1" href="https://playbook.cio.gov/">https://playbook.cio.gov/</a>).</p></div><p class="calibre7">JSF was conceived as a user interface technology that could allow even a Java engineer to build frontend in the same way as a JavaFX (or Swing) application. The idea was to allow the developers (not designers) to assemble an HTML page using a custom editor. The JSF applications were designed to be themed. The intention of the framework was to allow a render kit to produce different forms of output. A render kit might generate a PDF output, another type would generate an HTML output, and yet another would generate specific mobile content in the form of <span class="strong"><strong class="calibre8">Wireless Application Protocol</strong></span> (<span class="strong"><strong class="calibre8">WAP</strong></span>) (WAP was a technology <a id="id106" class="calibre1"/>that was afforded much attention before Apple produced the first iPhone in 2007). Technology has moved on in leaps and bounds!</p><p class="calibre7">Although there is much criticism of JSF as web technology to produce serious applications, it has the support of the Java EE platform. Facelets is a useful template framework to build sharable components and partial content for web pages. JSF has a lifecycle model that integrates into a POJO, and this means that it works seamlessly with the Context and Dependency Injection (CDI) beans. Moreover, JSF has been kept up to date with the changes taking place in the digital landscape. JSF 2.2 supports HTML5 friendly markup. It supports AJAX events and allows the events to be queued. It allows a W3C sanction ID attribute for all the elements for the HTML5 content. JSF 2.2 introduces Faces Flow, which adds the ability to take the user through the sets of screens, workflows, and wizards. Above all, JSF 2.2 (JSR 334) represents a commitment to continually support a standard component-based framework for the Java EE platform.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">Mojarra 2.2</strong></span>
</p><p class="calibre7">In order for JSF to become a standard of the Java EE platform, it requires a JSR and reference implementation. For JSF, the reference implementation project is called Mojarra. The <a id="id107" class="calibre1"/>software is open source and supported by the<a id="id108" class="calibre1"/> Oracle Corporation (<a class="calibre1" href="https://javaserverfaces.java.net/">https://javaserverfaces.java.net/</a>). The reference implementation is part of the GlassFish 4 application server.</p></div><div class="book" title="JSF 1.0 and 2.0 history"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec10" class="calibre1"/>JSF 1.0 and 2.0 history</h2></div></div></div><p class="calibre7">The concept of JSF was first discussed around 2001. It was a part of the Sun Microsystems <a id="id109" class="calibre1"/>project called Project Rave and then announced as JSR 127. The<a id="id110" class="calibre1"/> technology, although an improvement over the action-request-based framework of the era such as <a id="id111" class="calibre1"/>Apache Struts, was met with lukewarm fanfare in 2003 and 2004. A maintenance version 1.1 was released in 2004, but only in 2006 did the JSF 1.2 specification become an official part of the umbrella specification: Java EE 5.</p><p class="calibre7">By this time, however, the developer mindshare had already evolved into the AJAX techniques, partial applications, and non-JVM software such as Ruby and Ruby on Rails. JSF 1.2 was encumbered by the default templating technology of the platform, JavaServer Pages. JSP proved unsuitable for JSF because the life cycle of the interception of the requests and the generation of the responses were essentially incompatible. The search for alternatives led to the creation of Facelets, which were designed to work explicitly with JSF.</p><p class="calibre7">In 2009, Facelets became the default template solution in JSF 2.0 (JSR 314), which was also a part of Java EE 6. JSF 2.0 added annotations for validation and conversion. JSF 2.0 defined a standard AJAX component life cycle and it also added improvements for graphical editors. JSF 2.0 introduced a resource handle for the web content, including images, JavaScript, and CSS files.</p></div><div class="book" title="Key JSF 2.2 features"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec11" class="calibre1"/>Key JSF 2.2 features</h2></div></div></div><p class="calibre7">The big ticket<a id="id112" class="calibre1"/> features of the JSF 2.2 specification are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It provides the support for the HTML5 friendly markup, which is a boon to web designers and interface developers.</li><li class="listitem">The Resource Library Contracts is a new system in JSF to build reusable themes through bundling the Facelet views, components, style sheets, and other resources including internationalization.</li><li class="listitem">It provides the new URI locators that are consistent with the Java EE 7 umbrella specification. The Oracle Corporation purchased Sun Microsystems in 2010, and so, the old URIs of the form <a class="calibre1" href="http://java.sun.com/jsf/core">http://java.sun.com/jsf/core</a> were transformed to <a class="calibre1" href="http://xmlns.jcp.org/jsf/core">http://xmlns.jcp.org/jsf/core</a> reflecting the namespace of the JCP web domain.</li><li class="listitem">Faces Flows allow <a id="id113" class="calibre1"/>an application to be modeled as a directed graph of pages and views. With Faces Flows, we can build the basis of a workflow application in terms of the user interface. As a digital engineer, we can assemble a subdivision of the applications in a greater whole. These types of workflows lend themselves to the conversational scope of the CDI beans. You will learn more about flows in detail in <a class="calibre1" title="Chapter 6. JSF Flows and Finesse" href="part0057.xhtml#aid-1MBG21">Chapter 6</a>, <span class="strong"><em class="calibre9">JSF Flows and Finesse</em></span>.</li><li class="listitem">Stateless Views allow the developers to build the components that have no server-side state. Usually, the JSF components will save the state of the user interface component on either the server or the client, but sometimes a view does not require this extra resource, and thus, having a stateless view affords the scalability of the web application on servers.</li><li class="listitem">It provides the ability to correctly handle the content of the browser from the client window: tab, browser window, pop-up dialog, or modal dialog.</li></ul></div><p class="calibre7">JSF 2.2 is backward compatible with Faces 2.1 and 2.0. An application built against Faces 2.0 or 2.1 will not require changes in order to run with Faces 2.2; however, going the other way and using specific 2.2 features will not run in these older environments.</p><p class="calibre7">JSF is based on the following Java API specifications:</p><div class="book"><ul class="itemizedlist"><li class="listitem">JavaServer Pages 2.2 and JavaServer Pages Tag Library (JSTL) 1.2</li><li class="listitem">Java Servlet 3.0</li><li class="listitem">Java SE 7</li><li class="listitem">Java EE 7</li><li class="listitem">Java Beans 1.01</li></ul></div></div><div class="book" title="Why choose JSF over alternatives?"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec12" class="calibre1"/>Why choose JSF over alternatives?</h2></div></div></div><p class="calibre7">JSF is the only Java web application framework that is certified as a JCP standard so far. Of course, there are alternatives; in fact, there may be as many as 100 different Java web frameworks, and <a id="id114" class="calibre1"/>the majority of them will be open source. However, they will vary according to the vision, implementation, age of the code base, and who actually maintains it as a repository. It is no good for a business if the web framework that your application works against is built with yesterday's technology because the web is constantly evolving. Equally, the web framework has to evolve with the times or it will eventually become irrelevant. Businesses trust that JSF is a standard that has the guarantees that the technology will be supported for the long term.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre7">In fact, MVC (JSR 371) will be the other standard web application framework in Java EE 8. You will learn about MVC in <a class="calibre1" title="Chapter 9. Java EE MVC Framework" href="part0087.xhtml#aid-2IV0U1">Chapter 9</a>, <span class="strong"><em class="calibre9">Java EE MVC Framework</em></span>.</p></div><p class="calibre7">It is perfectly <a id="id115" class="calibre1"/>understandable that an application architect may want to choose a web framework other than JSF for their business requirements. Apache Struts 2, Spring MVC, and Apache Wicket are a few that I would mention in passing. Apache Struts 2 and Spring MVC are generally considered to be request-oriented frameworks. Apache Wicket is a component-oriented framework and a direct competitor to JSF. Apache Struts was one of the most famous web application frameworks in the early 2000s and certainly the first to break the mold.</p><p class="calibre7">The world of web frameworks does not stop with Java. Most developers will have heard of Ruby on Rails, which is an off-JVM technology. A few engineers will know about the Play framework for both the Java and Scala developers, and then there are solutions based around the Groovy language such as Grails.</p><p class="calibre7">Whatever framework you choose for a web application essentially dictates the Java-based frontend architecture for your developer. Whatever you do, my strong recommendation is not to invent your own web application framework. The strength of open source is the community of developers that is diverse with from thousands of different companies, endeavors, and cultures.</p><p class="calibre7">If you choose JSF, then it is more than likely that you, as a customer, want to maintain your investment in the Java platform. The core strength of your JSF enterprise application is the rich components, and you rely on the model to add the default benefits such as easier validation, type conversion, and mapping of HTTP request parameters so as to bean the properties. Many experienced Java EE engineers will have experience in the JSF framework, so you will be in great company.</p></div></div></div>
<div class="book" title="The MVC design pattern" id="aid-OPEK1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec19" class="calibre1"/>The MVC design pattern</h1></div></div></div><p class="calibre7">The MVC design <a id="id116" class="calibre1"/>describes a set of design patterns that aim to separate the concerns of a user interface from the application logic that semantically binds them. The Model describes the business logic. The View denotes the presentation—the abstract surface that the user senses and also interacts with. The Controller denotes the component that handles the interaction between the model and view. The original idea of MVC stemmed from Trygve Reenskaug, who introduced the concept in the Smalltalk programming language during the 1970s. The pattern was subsequently implemented and popularized in the Smalltalk-80 before it was adopted in the wider software engineering community. MVC is famous for its ideas about the division of labor and the separation of responsibilities between the components.</p><p class="calibre7">We call it MVC<a id="id117" class="calibre1"/> patterns because the plural term describes a set of related derivatives of the classic pattern as group patterns.</p><p class="calibre7">The MVC pattern<a id="id118" class="calibre1"/> has subsequently <a id="id119" class="calibre1"/>evolved, giving rise to variants such as the <span class="strong"><strong class="calibre8">Hierarchical model–view–controller</strong></span> (<span class="strong"><strong class="calibre8">HMVC</strong></span>), <span class="strong"><strong class="calibre8">Model-view-presenter</strong></span> (<span class="strong"><strong class="calibre8">MVP</strong></span>), <span class="strong"><strong class="calibre8">Model View ViewModel</strong></span> (<span class="strong"><strong class="calibre8">MVVM</strong></span>), and<a id="id120" class="calibre1"/> others that adapted MVC to different contexts.</p><div class="book" title="MVC in JSF"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec13" class="calibre1"/>MVC in JSF</h2></div></div></div><p class="calibre7">How does the <a id="id121" class="calibre1"/>MVC map to JSF? This has been answered in<a id="id122" class="calibre1"/> the following points:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Model</strong></span>: In JSF and Java EE, the model is the component or a set of components<a id="id123" class="calibre1"/> that handles the business data and logic. The model is either a CDI bean, EJB, or some other component that is compatible with the life cycle of the web container and the JSF framework.</li><li class="listitem"><span class="strong"><strong class="calibre8">Controller</strong></span>: A lot of the responsibility of the controller logic in the classic design pattern is taken care of by the framework. In JSF, one can consider the start of the <a id="id124" class="calibre1"/>controller as FacesServlet, which is responsible for dispatching the incoming HTTP request to the correct managed bean.</li><li class="listitem"><span class="strong"><strong class="calibre8">View</strong></span>: In JSF, the <a id="id125" class="calibre1"/>view is the rendering group that contains the UI components and their respective beans. Usually, the view is described in a page description language, for which JSF 2.0 is Facelets. The render kit of JSF composes the UI components and beans in a full page.</li></ul></div><p class="calibre7">The following diagram illustrates the MVC patterns in a perspective of the JSF framework:</p><div class="mediaobject"><img src="../Images/image00374.jpeg" alt="MVC in JSF" class="calibre10"/><div class="caption"><p class="calibre24">The Model View Controller pattern is terms of JSF framework</p></div></div><p class="calibre11"> </p></div></div>
<div class="book" title="Facelets" id="aid-PNV61"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec20" class="calibre1"/>Facelets</h1></div></div></div><p class="calibre7">The JSF specification<a id="id126" class="calibre1"/> defines a <span class="strong"><strong class="calibre8">View Declaration Language</strong></span> (<span class="strong"><strong class="calibre8">VDL</strong></span>) to render the output of the pages. In JSF 1.0, this was JavaServer Pages; but in JSF 2.0, the VDL was changed to Facelets by default. Facelets are the default view handler for JSF 2.0 and are defined as XHTML files.</p><p class="calibre7">Facelets can be<a id="id127" class="calibre1"/> used in a templating situation. A Facelets file can reference a master template as a composition, and the view can provide the content that will look like a cookie cutter being supplied to the template. A Facelet that utilizes a reference template is known as a template client. The placeholder content in the template client will override the default content in the master template. In this way, Facelets can be reused in order to share the content. The template clients may become master templates and thus, a hierarchy of views can be derived.</p><p class="calibre7">Facelets also provide reuse by the custom tags. It is possible for engineers to write their own custom tags through the XHTML files and metadata. The designer and developer will provide the content through a tag library descriptor file.</p><p class="calibre7">The final option to template that Facelets provide is the Composite Component Composition. This<a id="id128" class="calibre1"/> mechanism allows a composition to be reused in the other Facelet views so that they appear like first-class components. The template files, however, must be created in a special directory in order to allow the internal composition handler to succeed.</p></div>
<div class="book" title="The request processing lifecycle"><div class="book" id="aid-QMFO2"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec21" class="calibre1"/>The request processing lifecycle</h1></div></div></div><p class="calibre7">JSF has a request-response processing lifecycle that is built around the HTTP protocol. JSF is built <a id="id129" class="calibre1"/>on top of the Java Servlet specification that takes care of translating the request user agent, which in the majority of the cases, is a web browser to a known endpoint. For JSF, the first port of call is <code class="email">javax.faces.webapp.FacesServlet</code>. This servlet will simply dispatch the incoming request to the controller, and this component can elect to generate a response or delegate the output to the internal JSF controller implementation.</p><p class="calibre7">There are three circumstances for JSF in the request processing lifecycle. The first is the invocation to the JSF controller with a Faces request, which ultimately generates a Faces response.</p><p class="calibre7">The second is a request to retrieve a resource such as a CSS or JavaScript file or image or some other media file. However, a Faces resource request, which does not require the execution of logic, causes the JSF framework to furnish the output as a Faces resource response.</p><p class="calibre7">The last one is a page request to retrieve the content that has nothing to do with JSF, and this is called a Non-Faces request and subsequently derives a Non-Faces response. An HTTP request to a JAX-RS service endpoint is an example of a Non-Faces request and response. Let's have a look at the following figure:</p><div class="mediaobject"><img src="../Images/image00375.jpeg" alt="The request processing lifecycle" class="calibre10"/><div class="caption"><p class="calibre24">JSF request and response processing</p></div></div><p class="calibre11"> </p><p class="calibre7">The JSF framework<a id="id130" class="calibre1"/> first determines if the incoming request is for a resource. If it is, then the framework serves up the resource and sends the bytes, content type, and data to the user agent.</p><p class="calibre7">The interesting work happens when the incoming request is treated as a Face request; the JSF framework handles this processing in a linear workflow. This process is known as the execute and render lifecycle.</p><div class="book" title="The execute and render lifecycle"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec14" class="calibre1"/>The execute and render lifecycle</h2></div></div></div><p class="calibre7">The<a id="id131" class="calibre1"/> following diagram shows the<a id="id132" class="calibre1"/> JSF lifecycle to process a Faces request:</p><div class="mediaobject"><img src="../Images/image00376.jpeg" alt="The execute and render lifecycle" class="calibre10"/><div class="caption"><p class="calibre24">The execute and render lifecycle phases inside the JSF framework</p></div></div><p class="calibre11"> </p><p class="calibre7">The standard request processing lifecycle starts with a Faces request stimulus to the <span class="strong"><strong class="calibre8">Restore View</strong></span> stage. JSF maintains a <code class="email">javax.faces.context.FacesContext</code> instance for the lifecycle. This object instance contains all of the information that is associated with a single Faces request. FacesContext is passed along to the various stages.</p><div class="book" title="Restore View"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec01" class="calibre1"/>Restore View</h3></div></div></div><p class="calibre7">Restore View<a id="id133" class="calibre1"/> is a phase of the lifecycle where<a id="id134" class="calibre1"/> the JSF framework ensures that the tree of the components and their states match the form when the view was originally generated at the response. In other words, JSF has to rebuild the view accurately before it can start inserting the changes and apply the form property values from the Faces request. The reason for this phase to exist is that the state of the overall input can change dynamically between requests. What follows is the technical depth description.</p><p class="calibre7">Restore View <a id="id135" class="calibre1"/>determines if the request is a postback <a id="id136" class="calibre1"/>or an initial request according to the algorithm. Every view in JSF has its unique identifier, <code class="email">viewId</code>, and this is usually stored in a map collection internally in the framework's implementation. The framework calls the <code class="email">initView()</code> method on the <code class="email">javax.faces.application.ViewHandler</code> instance, which is associated with the view. Restore View constructs or retrieves the view so as to display to the user agent.</p><p class="calibre7">If the view already exists, then the request is a postback. JSF will then restore the view with <code class="email">viewId</code> using the previously saved state. The state can be stored on the server or client. This behavior is configured from the Web XML deployment behavior for the application.</p><p class="calibre7">For an entirely new view, JSF creates a new instance of the type <code class="email">javax.faces.component.UIViewRoot</code>, which is initially empty and sets the associated properties on it, such as the locale and character set. JSF then populates the view with the UI components in a tree data structure.</p></div><div class="book" title="Apply Request Values"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec02" class="calibre1"/>Apply Request Values</h3></div></div></div><p class="calibre7">After the component tree is restored, JSF maps the request information parameters to the component<a id="id137" class="calibre1"/> properties. The framework<a id="id138" class="calibre1"/> iterates over the component objects in the tree. Each component retrieves the data from the request object, which are usually the request parameters but can be cookies, session attributes, or even header parameters. Hence, the new values are stored with the UI component locally. The values are extracted from the request information, and at this phase, the values are still strings. This stage is called the Apply Request Values phase.</p><p class="calibre7">During this stage, JSF will attempt to apply conversion on the component properties where it is appropriate. If the conversion or validation fails, then the error message is queued on FacesContext.</p><p class="calibre7">The Apply Request Values phase adds events to an internal JSF event queue when a command button or link is clicked on. JSF has certain special conditions in which an event handler is allowed to break the linear flow of processing and skip to the final stage: Render Response.</p></div><div class="book" title="Process Validations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec03" class="calibre1"/>Process Validations</h3></div></div></div><p class="calibre7">The Process Validation phase<a id="id139" class="calibre1"/> is the<a id="id140" class="calibre1"/> stage where the submitted string values, which are stored with the component, are converted to local values. These local values can be Java objects of any type. It is in this phase that the validators that are associated with the component can verify the value of the local values. If the validation passes and all the<a id="id141" class="calibre1"/> required validators are invoked successfully, then <a id="id142" class="calibre1"/>the JSF life cycle continues to the next phase. If the validation fails or there have been conversion errors from the previous lifecycle phase—the Apply Request Values phase—then the JSF framework skips directly to the Render Response phase. The web user then has a chance to enter the correct data in, say, an HTML input form.</p><p class="calibre7">As a JSF developer, it is up to you to attach validators to the UI components with inputs, which are important to check.</p></div><div class="book" title="Update Model Values"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec04" class="calibre1"/>Update Model Values</h3></div></div></div><p class="calibre7">After the <a id="id143" class="calibre1"/>conversion and validation <a id="id144" class="calibre1"/>phases, JSF enters the Update Model Values stage. At this point, the local values are considered as safe so as to update the model. Remember that in JSF versus MVC parlance, the model is likely to be your managed backing bean, CDI bean, or an EJB or aggregate object. JSF updates the beans that are referenced by the component.</p></div><div class="book" title="Invoke Application"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec05" class="calibre1"/>Invoke Application</h3></div></div></div><p class="calibre7">In the life cycle, we arrive at the phase where the model has been updated, and conversion <a id="id145" class="calibre1"/>and validation has been <a id="id146" class="calibre1"/>applied. JSF calls this the Invoke Application phase, and here, finally, business logic is invoked. JSF calls the method that is named by the action method of the command button or link component. The Invoke Application phase is a result of the user submitting an HTML form or invoking a navigation anchor link, so the JSF framework executes the corresponding method of the backing bean.</p><p class="calibre7">The method may elect to return a simple outcome string. Since JSF 2.0, methods are allowed to return a simple string that refers to the view by its name. Alternatively, the method may build its own response programmatically using the FacesContext instance or may return the navigation view ID that is passed to a navigation handler, which in turn looks up the next page.</p></div><div class="book" title="Render Response"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec06" class="calibre1"/>Render Response</h3></div></div></div><p class="calibre7">The last phase<a id="id147" class="calibre1"/> in the lifecycle is the <a id="id148" class="calibre1"/>Render Response phase. This stage has the requirement to encode the Faces response and the JSF framework sends this output to the requesting user agent, which is usually a web browser. As soon as the data is sent down the network to the client, the life cycle is complete for the request and response. A new lifecycle begins on the next request.</p></div><div class="book" title="Event handling"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec07" class="calibre1"/>Event handling</h3></div></div></div><p class="calibre7">Between <a id="id149" class="calibre1"/>certain phases, you will have noticed the Process Event stages. JSF allows the listeners to be registered against the framework in order to observe events. These are called Phase Listeners. They are special because they can <a id="id150" class="calibre1"/>be active in behavior and cause the lifecycle to <a id="id151" class="calibre1"/>skip or they can be passive in behavior to just monitor some aspects of the user interface that is interesting to the application. These mini-extension points are quite useful and powerful for application builders and thus are a major differentiator between JSF and the other web frameworks.</p></div></div></div>
<div class="book" title="A basic JSF example"><div class="book" id="aid-RL0A2"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec22" class="calibre1"/>A basic JSF example</h1></div></div></div><p class="calibre7">We have covered just <a id="id152" class="calibre1"/>enough theory on the JSF framework. I think it is time for my readers to see some code. The first code is the XHTML file to display a basic web page on a site. The source code is available on the book's website in the author's public GitHub account at <a class="calibre1" href="http://github.com/peter_pilgrim/digital_javaee7">http://github.com/peter_pilgrim/digital_javaee7</a>.</p><p class="calibre7">Here is the XHTML source code for the initial Facelets view, and the file is called <code class="email">index.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      
      &gt;

  &lt;h:head&gt;
    &lt;title&gt;Digital Java EE 7 - Sample JSF&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    This is the simplest JSF example possible.

    &lt;h:form&gt;
      &lt;h:commandButton action="#{basicFlow.serveResponse}" value="Invoke Action" /&gt;
    &lt;/h:form&gt;

    &lt;h:link outcome="composition1.xhtml"&gt;
      Composition 1
    &lt;/h:link&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">It is worth reminding you that this file is not an HTML5 document; although JSF 2.2 can cope with the document grammar, we must walk before we can run. XHTML is a format of HTML that uses an XML schema namespace to add additional tags. Hence, there are JSF-specific namespaces for HTML, UI, and F. See further onward for a description of these namespaces.</p><p class="calibre7">The <code class="email">&lt;h:head&gt;</code>, <code class="email">&lt;h:body&gt;</code>, and <code class="email">&lt;h:form&gt;</code> custom tags resemble the standard HTML element tags that <a id="id153" class="calibre1"/>everyone knows about in web development. This is because they are designed to reflect this purpose deliberately. In fact, these are the JSF customs tags that add the functionalities and in the end, render the equivalent HTML element output.</p><p class="calibre7">You are probably wondering that what an earth is a <code class="email">&lt;h:link&gt;</code> element. This is simply JSF's way of rendering an HTML anchor tag. The outcome tag attribute references another XHTML directly, and after JSF 2.0, developers are allowed to write this in code.</p><p class="calibre7">The <code class="email">&lt;h:commandButton&gt;</code> tag is an example of a JSF form button that ultimately renders an HTML submit element tag. This tag accepts an action attribute that refers to a special string. The string is an example of the expression language; it references a method name of a bean.</p><p class="calibre7">Here is the code for the JSF managed bean, <code class="email">BasicFlow</code>:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital.javaee.jsfcomps;

import javax.enterprise.context.RequestScoped;
import javax.inject.Named;

@Named
@RequestScoped
public class BasicFlow {
    public String serveResponse() {
        return "endState.xhtml";
    }
}</pre></div><p class="calibre7">
<code class="email">BasicFlow</code> is a CDI bean with the request scope life cycle as declared by the <code class="email">@javax.enterprise.context.RequestScoped</code> annotation. The bean is created by the CDI framework at the beginning of the servlet request lifecycle and is finished and left for the garbage collection once the servlet response is complete.</p><p class="calibre7">In JSF 2.2, we will use the <code class="email">@javax.inject.Named</code> annotation to specify the bean that is available to the JSF framework. We can explicitly write the annotation as <code class="email">@Named("basicFlow")</code>, but the default is the camel case identifier of the simple class name. We recommend that a digital developer should not use the older <code class="email">@javax.faces.bean.ManagedBean</code> annotation as it is now targeted for deprecation in a future JSF specification.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre7">Make sure that your POJOs are actually CDI beans. Confusion can abound with JSF if you are using the wrong import for JSF. At deployment time, you will be unable to inject or find the backing bean in an expression like <code class="email">#{basicFlow.serveResponse}</code>. Check that you are importing <code class="email">javax.enterprise.context.RequestScoped</code> and not importing the deprecated <code class="email">javax.faces.bean.RequestScoped</code> annotation.</p></div><p class="calibre7">The <code class="email">#{basicFlow.serveResponse}</code> string is an example of the <span class="strong"><strong class="calibre8">Expression Language</strong></span> (<span class="strong"><strong class="calibre8">EL</strong></span>), which is a mechanism for the page content to communicate with the backing beans while maintaining a <a id="id154" class="calibre1"/>separation of concerns. The first <code class="email">BasicFlow</code> element refers <a id="id155" class="calibre1"/>to the backing bean instance and the second <code class="email">serverResponse</code> element refers to the <code class="email">serveResponse()</code> method. So, this is an EL expression that references the backing bean method. We will learn a lot more about expression languages later in this chapter.</p><p class="calibre7">You can see that the response is a simple string, which is the next VDL file: <code class="email">endState.xhtml</code>. Strictly speaking, the suffix can be left off and the JSF framework will determine the correct view.</p><p class="calibre7">The <code class="email">endState.xhtml</code> Facelet view file looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html 
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;Digital Java EE 7 - End State&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;p&gt;
      This is the &lt;strong&gt;end state&lt;/strong&gt;.
    &lt;/p&gt;
    &lt;h:link outcome="index.xhtml"&gt;
      Go back to the start
    &lt;/h:link&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">This is a JSF view that allows the user to go back to the start view with an <code class="email">&lt;h:link&gt;</code> element.</p><div class="book" title="A web deployment descriptor"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec15" class="calibre1"/>A web deployment descriptor</h2></div></div></div><p class="calibre7">In order to get<a id="id156" class="calibre1"/> the best out of the JSF framework, we<a id="id157" class="calibre1"/> recommend configuring a web application deployment descriptor. This file is a special XML document that declaratively describes the entry servlet endpoints, servlet mapping, and other environment resources. The code for the XML file is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app 
     
     xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
     http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
     version="3.1" metadata-complete="false"&gt;

  &lt;display-name&gt;
    jsf-compositions-1.0-SNAPSHOT
  &lt;/display-name&gt;

  &lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      javax.faces.webapp.FacesServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.xhtml&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

  &lt;context-param&gt;
    &lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt;
    &lt;param-value&gt;Development&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.xhtml&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
&lt;/web-app&gt;</pre></div><p class="calibre7">The preceding file has the <code class="email">WEB-INF/web.xml</code> path. In order to activate the JSF framework, the deployment descriptor declares the servlet with a fully qualified class name; <code class="email">javax.faces.webapp.FacesServlet</code>. Note that the servlet is mapped to serve the <code class="email">*.xhtml</code> files.</p><p class="calibre7">We will define the active phase of the current project with the context parameter <code class="email">javax.faces.PROJECT_STAGE</code> and an appropriate value. In the preceding example, the stage is set to <code class="email">Development</code> but after the application goes live, then we might want to switch the value to <code class="email">Production</code>. Switching to <code class="email">Production</code> improves the performance and disables <a id="id158" class="calibre1"/>some of the debugging output.</p><p class="calibre7">You will find the<a id="id159" class="calibre1"/> deployment descriptor in the book's source code as part of the project <code class="email">ch02/jsf-compositions</code>. Once you add the project to an IDE—say, IntelliJ, Eclipse, or NetBeans—you can view the output from the application server at the URL <code class="email">http://localhost:8080/jsf-compositions-1.0-SNAPSHOT/</code>.</p></div><div class="book" title="JSF XML namespaces"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec16" class="calibre1"/>JSF XML namespaces</h2></div></div></div><p class="calibre7">Here is a <a id="id160" class="calibre1"/>table <a id="id161" class="calibre1"/>describing the common JSF and related namespaces:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Namespace</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description </p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">h</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsf/html">http://xmlns.jcp.org/jsf/html</a>
</p>
<p class="calibre14">This defines <a id="id162" class="indexterm"/>the standard tag JSF library for the HTML renderers and components such as <code class="literal">h:link</code>, <code class="literal">h:commandButton</code>, and so on.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">f</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsf/core">http://xmlns.jcp.org/jsf/core</a>
</p>
<p class="calibre14">This <a id="id163" class="indexterm"/>defines the standard tag JSF library for the core functionality that is independent of any render kit. This library includes the tags to handle the validation and conversion.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">ui</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsf/facelet">http://xmlns.jcp.org/jsf/facelet</a>
</p>
<p class="calibre14">This<a id="id164" class="indexterm"/> defines the standard tag JSF library to template the support including the composition of the views.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">cc</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsf/composite">http://xmlns.jcp.org/jsf/composite</a>
</p>
<p class="calibre14">This<a id="id165" class="indexterm"/> defines the standard <code class="literal">tag</code> library to build the composite components.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">jsf</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsf">http://xmlns.jcp.org/jsf</a>
</p>
<p class="calibre14">This<a id="id166" class="indexterm"/> defines the tags to support HTML5 friendly output.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">p</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsf/passthrough">http://xmlns.jcp.org/jsf/passthrough</a>
</p>
<p class="calibre14">This<a id="id167" class="indexterm"/> defines the tags to support the HTML5 friendly output with the pass-through <code class="literal">tag</code> attributes.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">c</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsp/jstl/core">http://xmlns.jcp.org/jsp/jstl/core</a>
</p>
<p class="calibre14">This <a id="id168" class="indexterm"/>defines the JSTL 1.2 tag library for the JSP core behaviors. These tags include <code class="literal">&lt;c:forEach&gt;</code>, <code class="literal">&lt;c:if&gt;</code>, <code class="literal">&lt;c:choose&gt;</code>, and <code class="literal">&lt;c:catch&gt;</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">fn</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">
<a class="indexterm" href="http://xmlns.jcp.org/jsp/jstl/ficmtion">http://xmlns.jcp.org/jsp/jstl/ficmtion</a>
</p>
<p class="calibre14">This <a id="id169" class="indexterm"/>defines the JSTL 1.2 tag library for the JSP functions. These tags include <code class="literal">&lt;fn:upperCase&gt;</code>, <code class="literal">&lt;fn:length&gt;</code>, and <code class="literal">&lt;fn:contains&gt;</code>.</p>
</td></tr></tbody></table></div><p class="calibre7">An abbreviated name such as <code class="email">fn</code> must be added to the root XML document element, which in the <a id="id170" class="calibre1"/>majority of cases is an HTML element.</p></div></div>
<div class="book" title="A Composition example" id="aid-SJGS1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec23" class="calibre1"/>A Composition example</h1></div></div></div><p class="calibre7">Let's delve into <a id="id171" class="calibre1"/>some code to demonstrate the JSF composition before we close this chapter. We will start with a simple JSF template that lies out a web page in two areas: a top area and the main area.</p><p class="calibre7">This <code class="email">template-top.xhtml</code> file is the JSF view that performs the following:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;

  &lt;h:head&gt;
    &lt;title&gt;Digital Java EE 7 - Sample JSF&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;
    &lt;meta name="description" content="XeNoNiQUE"/&gt;
    &lt;meta name="author" content="Peter Pilgrim"/&gt;

      &lt;h:outputStylesheet library="styles" name="main.css" rel="stylesheet"/&gt;
      &lt;h:outputStylesheet name="/styles/top.css" rel="stylesheet"/&gt;
  &lt;/h:head&gt;

  &lt;h:body&gt;
    &lt;div id="content"&gt;
      &lt;div id="top" class="topContent"&gt;
        &lt;ui:insert name="top"&gt;
          Reserved for Top Content
        &lt;/ui:insert&gt;
      &lt;/div&gt;

      &lt;div id="main" class="mainContent"&gt;
        &lt;ui:insert name="content"&gt;
          Reserved for Main Content
        &lt;/ui:insert&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The preceding code is the template master. So far so good. This resembles a standard web page with HTML elements and we can see that the page uses the nested DIV elements to structure the content. I will draw your attention to the <code class="email">&lt;h:outputStylesheet&gt;</code> tag, which denotes<a id="id172" class="calibre1"/> that we should include a couple of cascading style sheets as resources.</p><p class="calibre7">The <code class="email">ui:insert</code> tag is the composition JSF tag that denotes an area of the template that will be replaced by a placeholder in a client template. An insertion placeholder must have a name and we have two in this example, namely top and content. Note that the <code class="email">ui:insert</code> tags are inserted in the body content of the HTML <code class="email">div</code> elements.</p><p class="calibre7">Here is the code for the client template as <code class="email">composition1.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
  &lt;ui:composition template="/template-top.xhtml"&gt;
    &lt;ui:define name="top"&gt;
      &lt;h1&gt;layout composition 1&lt;/h1&gt;
    &lt;/ui:define&gt;

    &lt;ui:define name="content"&gt;
      The is the main content
      &lt;h:form&gt;
        &lt;h:commandButton action="#{basicFlow.serveResponse}" value="Invoke Action" /&gt;
      &lt;/h:form&gt;
    &lt;/ui:define&gt;
  &lt;/ui:composition&gt;
&lt;/html&gt;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">Downloading the example code</strong></span>
</p><p class="calibre7">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre7">The key annotation in this file is the <code class="email">&lt;ui:composition&gt;</code> JSF custom tag that references the master template that is being used. The template attribute refers the path to the file.</p><p class="calibre7">The two <code class="email">&lt;ui:define&gt;</code> tags define the name placeholders with the content that substitutes for the default content in the master template. In this example, the placeholders are top and content.</p><p class="calibre7">Here are the screenshots of this process. The first screenshot is the initial Facelets view, <code class="email">index.xhtml</code>:</p><div class="mediaobject"><img src="../Images/image00377.jpeg" alt="A Composition example" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The second is <a id="id173" class="calibre1"/>the second Facelets view, <code class="email">endState.xhtml</code>:</p><div class="mediaobject"><img src="../Images/image00378.jpeg" alt="A Composition example" class="calibre10"/></div><p class="calibre11"> </p><div class="book" title="JSF serving resources"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec17" class="calibre1"/>JSF serving resources</h2></div></div></div><p class="calibre7">JSF expects <a id="id174" class="calibre1"/>our web resources to be placed in the <code class="email">resources</code> folder by default. A quick look at the following file directory will help you understand:</p><p class="calibre7">
<code class="email">jsf-composition</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp/resources</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp/resources/images</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp/resources/javascripts</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp/resources/styles</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp/WEB-INF</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp/WEB-INF/classes</code>
</p><p class="calibre7">
<code class="email">jsf-composition/src/main/webapp/WEB-INF/lib</code>
</p><p class="calibre7">In this simplified view of the Gradle project, we can see the folders, images, JavaScript, and CSS files that are placed under the <code class="email">resource</code> folder. Let's remind ourselves of the JSF view code again, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputStylesheet library="styles" name="main.css" rel="stylesheet"/&gt;
&lt;h:outputStylesheet name="/styles/top.css" rel="stylesheet"/&gt;</pre></div><p class="calibre7">These tags are essentially referring to two files: <code class="email">resources/style/top.css</code> and <code class="email">resources/style/main.css</code>.</p><p class="calibre7">In order for these<a id="id175" class="calibre1"/> tags to work, the resource must be placed under the resources folder or it can be placed in the <code class="email">META-INF/resources</code> folder of a web application JAR file that is deployed with the web application. The specification lists the following two options:</p><div class="informalexample"><pre class="programlisting">&lt;ROOT&gt;/resources/&lt;RES-ID&gt;</pre></div><p class="calibre7">Otherwise, you can use this:</p><div class="informalexample"><pre class="programlisting">&lt;ROOT&gt;/WEB-INF/lib/&lt;DEPENDANT-JAR&gt;/META-INF/resources/&lt;RES-ID&gt;</pre></div><p class="calibre7">Here, <code class="email">&lt;ROOT&gt;</code> is the project web root, <code class="email">&lt;DEPENDANT-JAR&gt;</code> is a third-party dependent JAR, and <code class="email">&lt;RES-ID&gt;</code> is the resource identifier.</p><p class="calibre7">
<code class="email">&lt;RES-ID&gt;</code> can be further broken up into formal parts, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;RES-ID&gt; ::=
   [ &lt;LOCALE-PREFIX&gt; / ] + 
   [ &lt;LIBRARY-NAME&gt; / ] [ &lt;LIBRARY-VERSION&gt; / ] +
   &lt;RESOURCE-NAME&gt; [ / &lt;RESOURCE-VERSION&gt; ]</pre></div><p class="calibre7">The term parts inside <code class="email">[]</code> are optional except for the resource name. It is therefore possible to have a resource identifier that is completely internationalized, versioned, and modularized in a library. Perhaps your project might utilize the following resource:</p><div class="informalexample"><pre class="programlisting">/en_us/sportsBulletin/v1_2_3/top_masters_golfer/2015_may.png</pre></div><p class="calibre7">What happens if you want to buck the trend and change the default location for the resources in JSF 2.2? It is possible to configure an alternative folder in the <code class="email">web.xml</code> deployment descriptor file. You can set a context parameter variable: <code class="email">javax.faces.WEBAPP_RESOURCES_DIRECTORY</code>.</p><p class="calibre7">Here is an extract of the descriptor that defines the resources folder as asset:</p><div class="informalexample"><pre class="programlisting">  &lt;context-param&gt;
    &lt;param-name&gt;
    javax.faces.WEBAPP_RESOURCES_DIRECTORY&lt;/param-name&gt;
    &lt;param-value&gt;assets&lt;/param-value&gt;
  &lt;/context-param&gt;</pre></div><p class="calibre7">We will cover the full extent of the JSF custom tags and how to submit the HTML forms in <a class="calibre1" title="Chapter 3. Building JSF Forms" href="part0035.xhtml#aid-11C3M2">Chapter 3</a>, <span class="strong"><em class="calibre9">Building JSF Forms</em></span> and <a class="calibre1" title="Chapter 4. JSF Validation and AJAX" href="part0043.xhtml#aid-190861">Chapter 4</a>, <span class="strong"><em class="calibre9">JSF Validation and AJAX</em></span>.</p></div></div>
<div class="book" title="Expression language"><div class="book" id="aid-TI1E2"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec24" class="calibre1"/>Expression language</h1></div></div></div><p class="calibre7">The expression language version 3.0 is now a separate specification in Java EE 7. It allows the <a id="id176" class="calibre1"/>page author to reference the bean properties, invoke methods, and perform arithmetic operations in the page description language. Originally, EL was a part of the JavaServer Pages specification, and it also became useful for the JSF technology. There are two types of EL: immediate evaluation and deferred evaluation. JSP relied on the immediate form, whereas JSF—because of its lifecycle management of request and response—required a deferred form. EL 3.0 represents the<a id="id177" class="calibre1"/> final unification of these strategies.</p><p class="calibre7">EL is useful for the page authors so that the digital developer can reference the properties in the managed beans, CDI components, and reference methods in a controller. EL is also used to invoke methods in a controller. EL is used to retrieve values from the beans but it can also set values.</p><div class="book" title="Immediate and deferred expressions"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec18" class="calibre1"/>Immediate and deferred expressions</h2></div></div></div><p class="calibre7">The syntax of an expression has two forms: <code class="email">${expression}</code> and <code class="email">#{expression}</code>. The beginning dollar <a id="id178" class="calibre1"/>character denotes an expression that is evaluated immediately. The beginning hash character denotes an expression <a id="id179" class="calibre1"/>that is deferred later.</p><p class="calibre7">An immediate expression<a id="id180" class="calibre1"/> is always evaluated immediately, and as a <a id="id181" class="calibre1"/>consequence, they can only be used to read the values and not to set them. The evaluation takes place when the page is rendered, which is normally the case for JavaServer Pages.</p><p class="calibre7">As we are building applications with JSF, we will mostly use deferred expressions in the book. A deferred expression means that the technology behind the scenes is responsible for taking the literal text and interpreting it into a result or invoking a function that returns a result.</p><p class="calibre7">Let's quickly jump ahead a little and introduce a JSF custom tag called <code class="email">&lt;h:inputText&gt;</code>. This tag renders an HTML input element with a type as text. The tag accepts an <code class="email">id</code> attribute to specify an HTML identifier; however, I want to draw your attention to the value attribute, which specifies an EL value expression.</p><p class="calibre7">We can write a value expression that is immediately evaluated as in JSP. Here is the code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText id="firstName" value="${employee.firstName}"/&gt;</pre></div><p class="calibre7">This would work as a read-only value. However, it is not possible to apply the value to the employee bean using JSF because the expression is not evaluated in any life cycle state.</p><p class="calibre7">If we change the expression from an immediate to a deferred form, then we will see the following behavior:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText id="firstName" value="#{employee.firstName}"/&gt;</pre></div><p class="calibre7">With this change, the EL is evaluated immediately during the Render Response phase of the lifecycle. The JSF implementation performs the evaluation and retrieves the value of the <code class="email">firstName</code> property from the bean called employee.</p><p class="calibre7">When the<a id="id182" class="calibre1"/> form is posted back to the server as a Faces <a id="id183" class="calibre1"/>request, which by the way is also<a id="id184" class="calibre1"/> known as a <code class="email">postback</code> event, the JSF implementation has a <a id="id185" class="calibre1"/>chance to retrieve the value at a deferred time. It is at these later life cycle states—Apply Request Values, Process Validation, and Update Model—that the value expression is evaluated and the value from the Faces request is injected into the target bean property.</p></div><div class="book" title="Value expressions"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec19" class="calibre1"/>Value expressions</h2></div></div></div><p class="calibre7">A value expression<a id="id186" class="calibre1"/> is one that returns a single result. The <a id="id187" class="calibre1"/>value is retrieved from the object graph in the implementation that manages the collections of the Java instances. For Java EE, this is either JSF or JSP provider, and for application servers, it is a Context and Dependency Injection provider. CDI maintains a set of collections internally of the <code class="email">@javax.inject.Named</code> beans. (Please wait for the explanation of the named beans or head straight for <a class="calibre1" title="Chapter 3. Building JSF Forms" href="part0035.xhtml#aid-11C3M2">Chapter 3</a>, <span class="strong"><em class="calibre9">Building JSF Forms</em></span>.) In particular, JSF traditionally keeps a record of the managed beans annotated with <code class="email">@javax.faces.bean.ManagedBean</code>.</p><p class="calibre7">JSP will search for the named object in the page scope, request scope, session scope, and then the application scope of the servlet container. Behind the scenes, there is a subclass of the abstract class <code class="email">javax.el.ELResolver</code>, which is responsible for evaluation. This class has useful methods, such as <code class="email">getValue()</code>, <code class="email">setValue()</code>, <code class="email">isReadOnly()</code>, and <code class="email">invoke()</code> that developers can use to add evaluation to their own applications programmatically.</p><p class="calibre7">In any case, the first port of call of value expressions is the object instance with an identified name. This is known as the initial term. Afterwards, the evaluation logic can traverse through the object graph through a named property using the dot-notation (<code class="email">.</code>). The evaluation continues through the subsequent terms in the expression. Let's stick with JSF for the moment and consider that the <code class="email">#{employee.firstName}</code> expression will evaluate a deferred search for the object named employee in the scope. The EL resolver will then look up the property in the bean named <code class="email">firstName</code>, which in turn will be a call to the <code class="email">getFirstName()</code> method. The job will be completed and the EL resolver returns the result value of the property.</p><p class="calibre7">EL also works with Java Collections. In particular, the <code class="email">java.util.Map</code> collections are treated specially. A standard EL assumes that the collection has a key of a String type we can think of this as <code class="email">Map&lt;String,Object&gt;</code>. The entries in Map may be accessed using the dot notation or square bracket notation <code class="email">[]</code>.</p><p class="calibre7">The following table of value expressions will make this scheme clear for more complex expressions:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Expression</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Meaning</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">Employee</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This finds the initial term associated with the name <code class="literal">employee</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">employee.firstName</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This resolves the named instance and invokes <code class="literal">getFirstName()</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">employee.department.name</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This resolves the object, invokes <code class="literal">getFirstName()</code>, retrieves the next object, and invokes <code class="literal">getName()</code> on this object</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">employee["firstName"]</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is equivalent to the dot notation <code class="literal">employee.firstName</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">employee['firstName']</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is equivalent to the dot notation <code class="literal">employee.firstName</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">capitalCities['Brazil']</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This finds the name instance and, assuming that <code class="literal">capitalCities</code> is a type of <code class="literal">java.util.Map</code>, retrieves the value with the key <code class="literal">Brazil</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">capitalCities["Brazil"]</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is a map expression equivalent to the previous</p>
</td></tr></tbody></table></div><p class="calibre7">The square bracket notation <code class="email">[]</code> is very useful with the string that contains dashes and/or a period character. This notation helps when you want to extract a message from a resource bundle for<a id="id188" class="calibre1"/> internationalization purposes. You can write a <a id="id189" class="calibre1"/>value expression as: <code class="email">appMessages["registeredTraveller.applicant.firstName.required"]</code>.</p><p class="calibre7">The square bracket notation allows us to write peculiar expressions. We can write the following value expression:</p><div class="informalexample"><pre class="programlisting">${employee['class'].simpleName}</pre></div><p class="calibre7">This translates to the following equivalent Java code:</p><div class="informalexample"><pre class="programlisting">employee.getClass().getSimpleName()</pre></div><div class="book" title="Map expressions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec08" class="calibre1"/>Map expressions</h3></div></div></div><p class="calibre7">The EL handles <a id="id190" class="calibre1"/>the Map objects seamlessly with the square<a id="id191" class="calibre1"/> bracket notation <code class="email">[]</code>. If the expression evaluates to a reference that accesses or reads the value associated with Map key on the right-hand-side (an <code class="email">rvalue</code>), then the EL resolver translates to a <code class="email">Map.get("key")</code> call. The following are the expressions to read a value:</p><div class="informalexample"><pre class="programlisting">${capitalCitiesMap['France']}   
  // translates to capitalCitiesMap.get("France")
#{capitialCitesMap['France']}  // ditto, but deferred</pre></div><p class="calibre7">If the expression<a id="id192" class="calibre1"/> is bound to the left-hand side (an <code class="email">lvalue</code>), then the<a id="id193" class="calibre1"/> EL resolver translates to <code class="email">Map.put("key", newValue)</code>.</p></div><div class="book" title="List expressions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec09" class="calibre1"/>List expressions</h3></div></div></div><p class="calibre7">The EL can<a id="id194" class="calibre1"/> retrieve objects from an index array with the <a id="id195" class="calibre1"/>square bracket notation. It works exactly like a Map expression except that the key must evaluate to a literal integer. In EL, the array index number starts at zero, as expected.</p><p class="calibre7">So, these following value expressions are valid if <code class="email">departmentList</code> is a type of <code class="email">java.util.List</code> and <code class="email">departmentArray</code> is a primitive array:</p><div class="informalexample"><pre class="programlisting">${departmentList[0].name}
${departmentArray[0].name}</pre></div><p class="calibre7">These are the equivalent pseudo Java statements:</p><div class="informalexample"><pre class="programlisting">List&lt;Department&gt; department = resolve(...)
departmentList.get(0).getName()

Department departmentArray[] = resolve(...)
departmentArray[0].getName()</pre></div></div><div class="book" title="Resolving the initial term"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec10" class="calibre1"/>Resolving the initial term</h3></div></div></div><p class="calibre7">The EL relies <a id="id196" class="calibre1"/>on the ability to look up the initial term from the servlet container, JSF list of the managed beans, and CDI scopes with the named beans. Essentially, you can give a JSF bean any name that you want, except you should avoid predefined objects. The initial term is the first part of an expression.</p><p class="calibre7">In the servlet container, you can refer to several predefined objects. As an example, <code class="email">requestScope</code> is a map collection of all the request scope attributes on a page. The request is also a predefined object in the EL that represents the <code class="email">javax.servlet.http.HttpServletRequest</code> instance that is passed to the JSF view. We can use this to retrieve the web application context path in an <code class="email">lvalue</code> expression, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;link href="#{request.contextPath}/resources/styles/main.css" rel="stylesheet"/&gt;</pre></div><p class="calibre7">The preceding code is extremely helpful to ensure that the resources can be found in a JSF application. It is used to create reliable relative URLs. We will explain more in <a class="calibre1" title="Chapter 4. JSF Validation and AJAX" href="part0043.xhtml#aid-190861">Chapter 4</a>, <span class="strong"><em class="calibre9">JSF Validation and AJAX</em></span>.</p><p class="calibre7">Resolution of the initial term begins by checking whether the initial term in the expression is a predefined object or not. If it is a predefined object, then the resolver continues this object. If it is not, then the JSF implementation searches for the object name in one of the servlet container scopes in this order: <code class="email">requestScope</code>, <code class="email">sessionScope</code>, or <code class="email">applicationScope</code>.</p><p class="calibre7">If the object is not found by name, the JSF 2.2 framework will delegate to <code class="email">ELResolver</code>, which will search for the equivalent CDI scopes for the instance and will then look at the registered <a id="id197" class="calibre1"/>or annotated managed beans.</p><p class="calibre7">The following table<a id="id198" class="calibre1"/> lists the predefined object instances in the expression language:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Predefined Name</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">applicationScope</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id199" class="indexterm"/> is a Map collection of the application scope attributes (<code class="literal">javax.servlet.ServletContext.getAttributes()</code>)</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">application</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id200" class="indexterm"/> refers to the <code class="literal">ServletContext</code> instance</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">cookie</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is <a id="id201" class="indexterm"/>a Map collection of the cookie names and values</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">facesContext</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is<a id="id202" class="indexterm"/> the <code class="literal">javax.faces.context.FacesContext</code> instance of this page and life cycle</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">header</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is<a id="id203" class="indexterm"/> a Map collection of the HTTP header parameters that only yield the first elements of the multiple values</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">headerValues</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is a<a id="id204" class="indexterm"/> Map collection of the HTTP header parameters yielding a <code class="literal">String[]</code> array of values</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">initParam</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id205" class="indexterm"/> is a Map collection of the web application initialization parameters </p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">param</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is <a id="id206" class="indexterm"/>a Map collection of the HTTP request parameters with only the first element in any array of values </p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">paramValue</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is<a id="id207" class="indexterm"/> a Map collection of the HTTP request parameters yielding a <code class="literal">String[]</code> array of values</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">requestScope</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id208" class="indexterm"/>is a Map collecction of the request scope attributes (<code class="literal">HttpServletRequest.getAttributes()</code>)</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">request</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id209" class="indexterm"/> refers to the <code class="literal">HttpServletRequest</code> instance</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">sessionScope</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is<a id="id210" class="indexterm"/> a Map collection of the session scope attributes (<code class="literal">HttpSession.getAttributes()</code>)</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">session</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id211" class="indexterm"/> refers to the <code class="literal">HttpSession</code> instance</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">View</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id212" class="indexterm"/> is the <code class="literal">javax.faces.component.UIViewRoot</code> instance of the page</p>
</td></tr></tbody></table></div><p class="calibre7">Let's move on to method expressions.</p></div></div><div class="book" title="Method expressions"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec20" class="calibre1"/>Method expressions</h2></div></div></div><p class="calibre7">EL also permits the <a id="id213" class="calibre1"/>association to a method on an object instance. This type of reference is called a method binding expression. The <a id="id214" class="calibre1"/>JSF framework permits method expressions to reference the action methods, validators, converters, and phase listeners. A method expression invokes a method on a named object instance and then returns the results, if any.</p><p class="calibre7">A good example <a id="id215" class="calibre1"/>of a method expression is an action handler on a managed bean, which you already witnessed in the basic JSF example in this chapter.</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton action="#{basicFlow.serveResponse}" value="Invoke Action" /&gt;</pre></div><p class="calibre7">The <code class="email">#{basicFlow.serverResponse}</code> expression is a method binding that refers to the controller, the CDI bean named <code class="email">BasicFlow</code>, and the <code class="email">serveResponse()</code> method.</p><div class="book" title="Parameterized method expressions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec11" class="calibre1"/>Parameterized method expressions</h3></div></div></div><p class="calibre7">EL also<a id="id216" class="calibre1"/> supports method invocation <a id="id217" class="calibre1"/>with parameters. The parameters can be literal constants. They can also be names of the terms in the scope of the page. This provides a very powerful way to build applications with the list collections and other complicated data structures.</p><p class="calibre7">Here is an example of the expression that uses the method parameters code:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText action="#{complexFlow.process('SALE',productLine)}" value="Purchase Products/&gt;</pre></div><p class="calibre7">The <code class="email">process()</code> method is invoked on the object instance that is resolved with the <code class="email">complexFlow</code> initial term. The first parameter is a literal string. The second parameter is the value of the <code class="email">subterm</code>, <code class="email">productLine</code>, which we will assume is available to the EL resolver.</p><p class="calibre7">It is also possible to get the size of the collection by definition because this is a no-arguments <a id="id218" class="calibre1"/>call. This expression<a id="id219" class="calibre1"/> looks like <code class="email">#{genericSearchResult.size()}</code>, assuming that the initial term references a type of <code class="email">java.util.Collection</code> or <code class="email">java.util.Map</code>.</p></div></div><div class="book" title="Arithmetic expressions"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec21" class="calibre1"/>Arithmetic expressions</h2></div></div></div><p class="calibre7">We can use <a id="id220" class="calibre1"/>arithmetic operators to perform <a id="id221" class="calibre1"/>calculations in the expressions. The expressions may also feature the relational and logical operators.</p><p class="calibre7">In EL, the following are the reserved operators:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Arithmetic operators: <code class="email">+</code> <code class="email">-</code> <code class="email">*</code> <code class="email">/</code> <code class="email">div</code> <code class="email">%</code> <code class="email">mod</code></li><li class="listitem">Relational operators: <code class="email">==</code> or <code class="email">eq</code>, <code class="email">!=</code> or <code class="email">ne</code>, <code class="email">&lt;</code> or <code class="email">lt</code>, <code class="email">&gt;</code> or <code class="email">gt</code>, <code class="email">&lt;=</code> or <code class="email">le</code>, <code class="email">&gt;=</code> or <code class="email">ge</code></li><li class="listitem">Logical operators: <code class="email">&amp;&amp;</code> and, <code class="email">||</code> or, <code class="email">!</code> <code class="email">not</code></li><li class="listitem">Empty operator: empty</li></ul></div><p class="calibre7">Here is an example of some of these arithmetic expressions in use:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt; The expression \#{1+5*2-3/4} evaluates to: #{1+5*2-3/4} &lt;/p&gt;
&lt;p&gt; The expression \#{(2014 div 4) mod 3} evaluates to: #{(2014 div 4) mod 3} &lt;/p&gt;
&lt;p&gt; The expression \#{2018 lt 2022} evaluates to: #{2018 lt 2022} &lt;/p&gt;
&lt;p&gt; The expression \#{0.75 == 3/4} evaluates to: #{0.75 == 3/4} &lt;/p&gt;</pre></div><p class="calibre7">Note the use of the escape character—the backslash (<code class="email">\</code>), which prevents the JSF view from interpreting the expression. We can also render the expressions directly on the page without the need for a <code class="email">&lt;h:outputText/&gt;</code> custom tag. This is a nice treat for the page authors.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip11" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">Preserve the MVC Model</strong></span>
</p><p class="calibre7">It is better to place business logic in a controller bean rather than populating the page with complicated conditions.</p></div></div></div>
<div class="book" title="Page navigation"><div class="book" id="aid-UGI02"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec25" class="calibre1"/>Page navigation</h1></div></div></div><p class="calibre7">After JSF 2, it is very<a id="id222" class="calibre1"/> easy to provide navigation in a controller. In the <code class="email">BasicFlow</code> controller from the earlier JSF example, we relied on implicit page navigation. The developer can specify the next page to render simply by returning a simple string.</p><p class="calibre7">Here is the controller class again:</p><div class="informalexample"><pre class="programlisting">@Named @RequestScoped
public class BasicFlow {
    public String serveResponse() {
        return "endState.xhtml";
    }
}</pre></div><p class="calibre7">In JSF 1, the page navigation was determined explicitly in a Faces Configuration XML file: <code class="email">/WEB-INF/faces-config.xml</code>, which made the development harder because of the enforced cognitive indirection. The purpose of <code class="email">faces-config.xml</code> is to define the configuration for a JSF web application. The developer can define the navigation rules, inject bean properties, define the properties file, and declare the resource bundles and locales. They can register the converters, validators, and renderer components.</p><p class="calibre7">Explicit page navigation is useful for the defined information architecture paths. Writing the page navigation is easier to share in a team. It can be incredibly quick to make prototypes for business stakeholders. However, explicit navigation is probably redundant if your controllers and rendered pages map directly in a one-to-one relationship.</p><div class="book" title="The navigation rules"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec22" class="calibre1"/>The navigation rules</h2></div></div></div><a id="id223" class="calibre1"/><p class="calibre7">JSF also supports explicit navigation rules in the Faces Configuration XML file. I should warn you that this is the old style in JSF 1.<span class="strong"><em class="calibre9">x</em></span> to describe the navigation between the pages explicitly. In JSF 2.<span class="strong"><em class="calibre9">x</em></span>, navigation rules are no longer required, and if you want to describe the page navigation better, remind yourself to learn about Faces Flows (See <a class="calibre1" title="Chapter 6. JSF Flows and Finesse" href="part0057.xhtml#aid-1MBG21">Chapter 6</a>, <span class="strong"><em class="calibre9">JSF Flows and Finesse</em></span>). However, there is a reasonable chance that, in your professional work, you will encounter older JSF applications, and therefore, you will need to learn how the JSF navigation rules are designed.</p><p class="calibre7">With this in mind, here is how navigation works explicitly. Suppose that we have a simple page where we can choose between a collection of fruits and vegetables in a set of pages. We can also elect to cancel the choice.</p><p class="calibre7">Here is a representation of these rules in the standard Faces Configuration file, <code class="email">faces-config.xml</code>. This file is normally found in <code class="email">src/main/webapp/WEB-INF</code> in Maven and Gradle projects:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;faces-config 
  
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
   http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"
  version="2.2"&gt;
  &lt;navigaton-rule&gt;
    &lt;from-view-id&gt;/order-start.xhtml&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
      &lt;from-outcome&gt;cancel&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/cancel.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
  &lt;navigation-case&gt;
      &lt;from-outcome&gt;fruit&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/fruit.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
  &lt;navigation-case&gt;
      &lt;from-outcome&gt;vegetable&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/vegetable.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
  &lt;/navigation-case&gt;
&lt;/faces-config&gt;</pre></div><p class="calibre7">Explicit navigation is determined by a set of rules that the JSF framework applies. The developers will write a series of compound elements in the &lt;<code class="email">navigation-rule&gt;</code> tag. The context of the rule is determined by the <code class="email">&lt;from-view-id&gt;</code> element, which references a specific view page, <code class="email">/order-start.xhtml</code>, or it can be a wildcard rule (asterisk <code class="email">*</code>) that applies to more than one navigation case. Each navigation rule has a collection of the <code class="email">&lt;navigation-case&gt;</code> elements. Each case requires a <code class="email">&lt;from-outcome&gt;</code> and <code class="email">&lt;to-view-id&gt;</code> element. The outcome identifies the literal string, which is returned by the controller method and the view ID is the destination view. So, in the cancellation case, the outcome string identified by cancel will navigate to the <code class="email">/cancel.xhtml</code> view.</p><p class="calibre7">The advantage of the indirection mapping of the outcome to the view page is obvious. The outcome code in the controller remains the same but the destination view can change.</p><p class="calibre7">We can write a<a id="id224" class="calibre1"/> JSF controller that handles these navigation rules. This is an extract of the <code class="email">ProductTypeController</code> class:</p><div class="informalexample"><pre class="programlisting">@Named @ViewScoped
public class ProductTypeController {
  public String productType;
  /* ... getter and setter omitted */

  public String cancel() { return "cancel";}
  public String navigate() {
    if ("fruit".equalsIgnoreCase(productType)) {
      return "fruit";
    }
    else {
      return "vegetable";
    }
  }
}</pre></div><p class="calibre7">The <code class="email">cancel()</code> method <a id="id225" class="calibre1"/>simply returns the cancel outcome, which JSF maps to the <code class="email">/cancel.xhtml</code> page because the navigation case matches the outcome. The <code class="email">navigate() </code>method sets outcome depending on the <code class="email">productType</code> property. There can only be two outcomes in the <code class="email">fruit</code> and <code class="email">vegetable</code> methods, and the navigation case ensures that the <code class="email">fruit.xhtml</code> and <code class="email">vegetable.xhtml</code> pages are rendered respectively.</p></div><div class="book" title="Wildcards"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec23" class="calibre1"/>Wildcards</h2></div></div></div><p class="calibre7">Navigation rules<a id="id226" class="calibre1"/> may also have wildcard views. A wildcard navigation rule occurs where the asterisk (<code class="email">*</code>) character prepends to the URI path in the <code class="email">&lt;from-view-id&gt;</code> element.</p><p class="calibre7">Suppose we have a <a id="id227" class="calibre1"/>website with protected pages that should not be displayable unless the user is logged in as a registered user. We can write a navigation rule that is shared for all the pages under the protected area. Let's say we want to secure any web pages under the URI <code class="email">/secured</code>:</p><div class="informalexample"><pre class="programlisting">&lt;faces-config ...&gt;
  &lt;navigaton-rule&gt;
    &lt;from-view-id&gt;/secured/*&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
      &lt;from-outcome&gt;login&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/login.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
    &lt;navigation-case&gt;
      &lt;from-outcome&gt;register&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/register.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
  &lt;/navigation-case&gt;
  ... more rules ...
&lt;/faces-config&gt;</pre></div><p class="calibre7">The wildcard <code class="email">from-view-id /secured/*</code> identifies all the pages that start with the <code class="email">/secured/</code> prefix. You are allowed to have only one wildcard in a URI path.</p><p class="calibre7">Using wildcards in an outcome brings forth the question of precedence. When does a wildcard <code class="email">view id</code> take precedence over a direct outcome? Here is a navigation case extract of the Faces Configuration XML where we set the source page view:</p><div class="informalexample"><pre class="programlisting">&lt;from-view-id&gt;stocks.xhtml&lt;/from-view-id&gt;
// Has higher precedure than 
&lt;from-view-id&gt;*&lt;/from-view-id&gt;</pre></div><p class="calibre7">A direct <code class="email">view id</code> always has a higher precedence over an equivalent wildcard view. JSF chooses the navigation case of a direct view, <code class="email">stocks.xhtml</code>, over the wildcard view, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;from-view-id&gt;/secured/portfolio/*&lt;/from-view-id&gt;
// Has higher precedure than 
&lt;from-view-id&gt;/secured/*&lt;/from-view-id&gt;</pre></div><p class="calibre7">If there are multiple <a id="id228" class="calibre1"/>wildcard views that are in competition for a<a id="id229" class="calibre1"/> match, then the longest match is chosen. JSF chooses the navigation case in the longest matching view, which is in the illustration <code class="email">/secured/portfolio/*</code>.</p></div><div class="book" title="Conditional navigation"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec24" class="calibre1"/>Conditional navigation</h2></div></div></div><p class="calibre7">A JSF explicit page<a id="id230" class="calibre1"/> navigation also supports the idea of <a id="id231" class="calibre1"/>conditional navigation in the Faces configuration file. This allows the developer to declaratively set up the navigation rules based on the dynamic state of the application. Conditional navigation is achieved by using the <code class="email">&lt;if&gt;</code> element tag, as shown in the next example:</p><div class="informalexample"><pre class="programlisting">&lt;faces-config&gt;
  &lt;navigaton-rule&gt;
    &lt;from-view-id&gt;/shopping-cart.xhtml&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
      &lt;from-outcome&gt;nextPage&lt;/from-outcome&gt;
      &lt;if&gt;#{user.registered}&lt;/if&gt;
      &lt;to-view-id&gt;/existing-customer.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
    &lt;navigation-case&gt;
      &lt;from-outcome&gt;nextPage&lt;/from-outcome&gt;
      &lt;if&gt;#{!user.registered}&lt;/if&gt;
      &lt;to-view-id&gt;/new-customer.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
  &lt;/navigation-case&gt;
&lt;/faces-config&gt;</pre></div><p class="calibre7">The body content of <code class="email">&lt;if&gt;</code> is a deferred value expression, which is evaluated in the JSF lifecycle and should return a Boolean value. In the code, the <code class="email">#{user.registered}</code> expression is evaluated to the bean with the current logged-in user profile bean and property called registered. The <code class="email">#{!user.registered}</code> expression evaluates the negation—note the use of the exclamation character for the operator.</p></div><div class="book" title="Static navigation"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch02lvl2sec25" class="calibre1"/>Static navigation</h2></div></div></div><p class="calibre7">To complete the<a id="id232" class="calibre1"/> digital developer story about page navigation, it is time to look at static navigation with JSF. Static navigation allows us to traverse from one JSF page to another without invoking a managed bean controller. It is useful for the page views where there is no requirement for a server-side Java code or where there are no HTML input elements. Static navigation is achieved from a combination of markups on the Facelets view and explicit navigation rules.</p><p class="calibre7">In the earlier <code class="email">Basic JSF</code> example, we had a page view with <code class="email">&lt;h:link&gt;</code>. Let's change this to <code class="email">&lt;h:commandButton&gt;</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  ...
  &lt;h:commandButton action="your-next-view"&gt;
      Composition 1
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p class="calibre7">The action attribute specifies the name of outcome to navigate. We will replace the old element with the <code class="email">&lt;h:commandButton&gt;</code> JSF tag. The action attribute specifies the value expression. JSF looks for the initial term in several contexts but it will also search the Faces configuration to match the navigation rule. For this traversal to work, we also require a navigation rule in the Faces configuration:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-case&gt;
  &lt;from-outcome&gt;your-next-view&lt;/from-outcome&gt;
  &lt;to-view-id&gt;/shopping-cart.xhtml&lt;/to-view-id&gt;
&lt;/navigation-case&gt;</pre></div><p class="calibre7">The navigation rule matches the <code class="email">your-next-view</code> outcome from the Facelets view, and so JSF can navigate to the destination page.</p><p class="calibre7">I think we will stop here regarding the page navigation topic. We will continue our developer digital journey with page navigation in <a class="calibre1" title="Chapter 4. JSF Validation and AJAX" href="part0043.xhtml#aid-190861">Chapter 4</a>, <span class="strong"><em class="calibre9">JSF Validation and AJAX</em></span>.</p></div></div>
<div class="book" title="Summary" id="aid-VF2I1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec26" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This chapter has been a robust adventure in the world of JSF. You should be able to understand the theory of how the framework has been put together. We covered the key features of JSF such as an HTML5 friendly markup and a templating engine. JSF is a part of the Java EE platform and is available on many application servers and servlet containers. We learned how the JSF framework relates to the Model-View-Controller design pattern.</p><p class="calibre7">You should be able to understand the request and response processing lifecycle and the phase change state model in JSF under the execute and render lifecycle.</p><p class="calibre7">Towards the middle chapter, we inspected the JSF basic pages, custom tag libraries, Facelets views, and a simple backing bean. We also observed a composition layout with both the master and client templates.</p><p class="calibre7">We also went in detail in the powerful EL framework, which is a part of Java EE 7 and JSF 2.2. EL is a very important facility for the server-side Java applications, especially if they are built against Faces. To finish the journey, we looked at both implicit and explicit page navigation.</p><p class="calibre7">We now have enough knowledge to constitute a JSF foundation. In the next chapter, we will look at beefing up our JSF knowledge with the HTML forms and set the ground running with validation. In the subsequent chapters, we will definitely lose the XHTML documents and add HTML5 so that we can develop more modern websites.</p></div>
<div class="book" title="Exercises" id="aid-10DJ41"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch02lvl1sec27" class="calibre1"/>Exercises</h1></div></div></div><p class="calibre7">Here are the questions for this chapter:</p><div class="book"><ol class="orderedlist"><li class="listitem">Where else in computer science might one find the Model-View-Controller design pattern?</li><li class="listitem">Why do you think that keen computer scientists and architects wanted to separate business logic from the presentation view code?</li><li class="listitem">Consider a situation where you have been contracted by the municipal government for a local territory.</li><li class="listitem">You have been asked to write an electoral roll web application for the voters to replace the traditional paper trail. Instead of sending official letters to the citizens and waiting to receive the filled-in forms, the citizens will be able to register for the electoral roll online. What constitutes the Model-View-Controller in this application?</li><li class="listitem">What parts of the JSF life cycle map to the Model-View-Controller pattern?</li><li class="listitem">Describe when and where the framework will encounter the Restore View phase.</li><li class="listitem">Describe the process of an HTML form submission. What happens in JSF transferring the contents of an HTML form to the Java POJOS?</li><li class="listitem">When a customer enters an invalid value in a form, describe the phases of the JSF life cycle that will process the Faces request. What do you think is added to the Faces response? Why?</li><li class="listitem">Why have the JSF specification writers explicitly designed a special Render Response phase?</li><li class="listitem">JSF has explicitly separated the valuation from the invocation of business logic in a backing bean (or action controller). Other web frameworks have a validation code in the backing beans. Outline the pros and cons of both the approaches.</li><li class="listitem">Download the code for chapter 2 and study how the web application is laid out. If you are feeling brave, modify one of the project examples. Add another string property to the backing bean, and then add a JSF form text field (hint: <code class="email">&lt;f:inputText&gt;</code>). What happens? If your changes go wrong, you can always revert the changes.</li></ol><div class="calibre25"/></div></div></body></html>