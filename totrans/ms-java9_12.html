<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Concurrency and Reactive Programming</h1>
                </header>
            
            <article>
                
<p>In the previous <span>chapter, we covered several <strong>Java Enhancement Proposals</strong> (<strong>JEPs</strong>) that were incorporated into the Java 9 platform. These JEPs represented a wide range of tools and updates to APIs to make developing with Java easier, with greater optimization possibilities for our Java applications. We looked at the new HTTP client, changes to Javadoc and the Doclet API, the new JavaScript parser, JAR and JRE changes, the new Java-level JVM compiler interface, the new support for TIFF images, platform logging, XML catalog support, collections, and the new platform-specific desktop features. We also looked at enhancements to method handling and the deprecation annotation.</span></p>
<p class="mce-root">In this chapter <span>we will cover concurrency enhancements introduced with the Java 9 platform. Our primary focus</span> will <span>be the support for reactive programming, a concurrency enhancement that is provided by the <kbd>Flow</kbd> class API. Reactive programming is a new concept for Java 9, so we will take an exploratory approach to the topic. We will also explore additional concurrency enhancements introduced in Java 9.</span></p>
<p>Specifically, we will cover the following topics:</p>
<ul>
<li>Reactive programming</li>
<li>The new <kbd>Flow</kbd> API</li>
<li>Additional concurrency updates</li>
<li>Spin-wait hints</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Programming</h1>
                </header>
            
            <article>
                
<p>Reactive programming is when applications react to an asynchronous data stream as it occurs. The following image illustrates the flow:</p>
<div class="CDPAlignCenter CDPAlign"><img height="192" width="290" src="assets/d1dd7408-4b2c-45c4-a860-372e960daefa.png"/></div>
<p>Reactive programming is not a fancy software engineering term only used by academics. It is, in fact, a programming model that can result in much greater efficiencies as opposed to the more common method of having applications iterate over data that is in memory.</p>
<p>There is more to reactive programming. First, let's consider that the data stream is provided by a publisher in an asynchronous manner to the subscriber.</p>
<div class="packt_infobox">Data streams are a binary input/output of strings and primitive data types. The <kbd>DataInput</kbd> interface is used for an input stream and the <kbd>DataOutput</kbd> interface is used for output streams.</div>
<p>Processors, or a chain of processors, can be used to transform the data stream without the publisher or subscriber being impacted. In the following example, the <strong>Processors</strong> work on the stream of data without <strong>Publisher</strong> or <strong>Subscriber</strong> involvement, or even awareness:</p>
<div class="CDPAlignCenter CDPAlign"><img height="170" width="331" src="assets/c4263677-4fe1-4d74-bc3d-b70ad1f721fb.png"/></div>
<p>In addition to greater efficiency, reactive programming represents several additional benefits, which are highlighted here:</p>
<ul>
<li>The code base can be less verbose, making it:
<ul>
<li>Easier to code</li>
<li>Easier to maintain</li>
<li>Easier to read</li>
</ul>
</li>
<li>Stream processing results in memory efficiencies</li>
<li>This is a solution for a variety of programming applications</li>
<li>Less boiler-plate code needs to be written, so development time can be focused on programming core functionalities</li>
<li>The following types of programming require less time and code:
<ul>
<li>Concurrency</li>
<li>Low-level threading</li>
<li>Synchronization</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive programming standardization</h1>
                </header>
            
            <article>
                
<p>There are standards in many aspects of software development, and reactive programming has not escaped this. There is a <strong>Reactive Streams</strong> initiative to standardize asynchronous stream processing. The specific focus, in the context of Java, is with the JVM and JavaScript.</p>
<p>The Reactive Streams initiative aims at tackling the issue of governing how the data stream is exchanged between threads. As you will recall from the previous section, the idea of processors is predicated on there being no impact on the publisher or receiver. This no-impact mandate stipulates that the following are not required:</p>
<ul>
<li>Data buffering</li>
<li>Data translation</li>
<li>Conversion</li>
</ul>
<p>The basic semantics of the standard define the regulation of data stream element transmission. This standard was specifically established for delivery with the Java 9 platform. Reactive Streams includes a library that will help developers convert from <kbd>org.reactivestreams</kbd> and <kbd>java.util.concurrent.Flow</kbd> namespaces.</p>
<p>The key to being successful with reactive programming and the Reactive Streams standardization is understanding the relevant terminology:</p>
<table>
<tbody>
<tr>
<td><strong>Term</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>Demand</td>
<td>Demand refers to the subscriber's request for more elements as well as referring to the total number of elements requested that have not been fulfilled by the publisher yet.</td>
</tr>
<tr>
<td>Demand</td>
<td>Demand also refers to the total number of elements requested that have not been fulfilled by the publisher yet.</td>
</tr>
<tr>
<td>External synchronization</td>
<td>External access coordination for thread safety.</td>
</tr>
<tr>
<td>Non-obstructing</td>
<td>Methods are said to be non-obstructing if they rapidly execute without the requirement for heavy computations. Non-obstructing methods do not delay a subscriber's thread execution.</td>
</tr>
<tr>
<td>NOP</td>
<td>NOP execution is execution that can be called repeatedly without impact to the calling thread.</td>
</tr>
<tr>
<td>Responsivity</td>
<td>This term refers to a component's ability to respond.</td>
</tr>
<tr>
<td>Return normally</td>
<td>Return normally refers to when there are no errors--the normal condition. The <kbd>onError</kbd> method is the only way permitted by the standard to inform the subscriber of a failure.</td>
</tr>
<tr>
<td>Signal</td>
<td>
<p class="mce-root">One of the following methods:</p>
<ul>
<li><kbd>cancel</kbd></li>
<li><kbd>onComplete</kbd></li>
<li><kbd>onError</kbd></li>
<li><kbd>onNext</kbd></li>
<li><kbd>onSubscribe</kbd></li>
<li><kbd>request</kbd></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>You can obtain the standard on Maven Central (<a href="https://search.maven.org">https://search.maven.org</a>). Here is the standard from Maven Central as of the publication date of this book:</p>
<pre>    &lt;dependency&gt;<br/>      &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt;<br/>      &lt;artifactId&gt;reative-streams&lt;/artifactId&gt;<br/>      &lt;version&gt;1.0.1&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/><br/>    &lt;dependency&gt;<br/>      &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt;<br/>      &lt;artifact&gt;reactive-streams-tck&lt;/artifactId&gt;<br/>      &lt;version&gt;1.0.0&lt;/version&gt;<br/>      &lt;scope&gt;test&lt;/scope&gt;<br/>    &lt;/dependency&gt;</pre>
<p>In the next section, we will look at the Flow APIs in the Java 9 platform, as they correspond to the Reactive Streams specification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The New Flow API</h1>
                </header>
            
            <article>
                
<p>The <kbd>Flow</kbd> class is part of the <kbd>java.util.concurrent</kbd> package. It helps developers incorporate reactive programming in their applications. The class has one method, <kbd>defaultBufferSize()</kbd>, and four interfaces.</p>
<p>The <kbd>defaultBufferSize()</kbd> is a static method that returns the default buffer size for publishing and subscribing buffering. This default value is <kbd>256</kbd> and it is returned as an <kbd>int</kbd>. Let's look at the four interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flow.Publisher interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>Flow.Publisher</kbd> interface is a functional interface. A <kbd>Publisher</kbd> is a producer of data sent to subscribers:</p>
<pre class="mce-root">    @FunctionalInterface<br/>    public static interface Flow.Publisher&lt;T&gt;</pre>
<p><span>This functional interface can serve as a lambda expression assignment target.</span> It only takes one argument--the subscribed item type <kbd>&lt;T&gt;</kbd>. It has one method:</p>
<ul>
<li><kbd><span>void onSubscribe(Flow.Subscription subscription)</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flow.Subscriber interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>Flow.Subscriber</kbd> interface is used to receive messages and its implementation is shown here:</p>
<pre>    public static interface Flow.Subscriber&lt;T&gt;</pre>
<p><span>This interface is set up to receive messages.</span> It only takes one argument--the subscribed item type <kbd>&lt;T&gt;</kbd>. It has the following methods:</p>
<ul>
<li><kbd><span>void onComplete()</span></kbd></li>
<li><kbd><span>void onError(Throwable throwable)</span></kbd></li>
<li><kbd><span>void onNext(T item)</span></kbd></li>
<li><kbd><span>void onSubscribe(Flow.Subscription subscription)</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flow.Subscription interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>Flow.Subscription</kbd> interface ensures that only subscribers receive what is requested. Also, as you will see here, a subscription can be cancelled at anytime:</p>
<pre>    public static interface Flow.Subscription</pre>
<p><span>This interface does not take any arguments and is the linkage that controls the messages between instances of <kbd>Flow.Publisher</kbd> and <kbd>Flow.Subscriber</kbd>. It has the following</span> methods:</p>
<ul>
<li><kbd><span>void cancel()</span></kbd></li>
<li><kbd><span>void request(long n)</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flow.Processor interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>Flow.Processor</kbd> interface <span>can serve as both a <kbd>Subscriber</kbd> and a <kbd>Publisher</kbd>. The</span> implementation is provided here:</p>
<pre>    static interface Flow.Processor&lt;T,R&gt; extends Flow.Subscriber&lt;T&gt;,<br/>     Flow.Publisher&lt;R&gt;</pre>
<p><span>This interface</span> takes two arguments--the subscribed item type <kbd>&lt;T&gt;</kbd> and the published item type <kbd>&lt;R&gt;</kbd>. It does not have its own methods, but does inherit the following method from <kbd>java.util.concurrent.Flow.Publisher</kbd>:</p>
<ul>
<li><kbd>void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)</kbd></li>
</ul>
<p><kbd>Flow.Processor</kbd> also inherits the following methods from the <kbd>java.util.concurrent.Flow.Subscriber</kbd> interface:</p>
<ul>
<li><kbd><span>void onComplete()</span></kbd></li>
<li><kbd><span>void onError(Throwable throwable)</span></kbd></li>
<li><kbd><span>void onNext(T item)</span></kbd></li>
<li><kbd><span>void onSubscribe(Flow.Subscription subscription)</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation</h1>
                </header>
            
            <article>
                
<p>In any given implementation of reactive programming, we will have a <kbd>Subscriber</kbd> that requests data and a <kbd>Publisher</kbd> that provides the data. Let's first look at a sample <kbd>Subscriber</kbd> implementation:</p>
<pre>    import java.util.concurrent.Flow.*;<br/><br/>    public class packtSubscriber&lt;T&gt; implements Subscriber&lt;T&gt;<br/>    {<br/>      private Subscription theSubscription;<br/><br/>      // We will override the four Subscriber interface methods<br/><br/>      @Override<br/>      public void onComplete()<br/>      {<br/>        System.out.println("Data stream ended");<br/>      }<br/><br/><span>      @Override<br/></span>      public void onError(Throwable theError)<br/>      {<br/>        theError.printStackTrace();<br/>      }<br/><br/>      @Override<br/>      public void onNext(T theItem)<br/>      {<br/>        System.out.println("Next item received: " + theItem);<br/>        theSubscription.request(19);  // arbitrary number for<br/>         example purposes<br/>      }<br/><br/>      @Override<br/>      public void onSubscribe(Subscription theSubscription)<br/>      {<br/>        this.theSubscription = theSubscription;<br/>        theSubscription.request(19);<br/>      }<br/><br/>    } </pre>
<p>As you can see, implementing the <kbd>Subscriber</kbd> is not difficult. The heavy work is done with the processors in-between the <kbd>Subscriber</kbd> and <kbd>Publisher</kbd>. Let's look at a sample implementation where the <kbd>Publisher</kbd> publishes a data stream to subscribers:</p>
<pre>    import java.util.concurrent.SubsmissionPublisher;<br/><br/>    . . . <br/><br/>    // First, let's create a Publisher instance<br/>    SubmissionPublisher&lt;String&gt; packtPublisher = new <br/>     SubmissionPublisher&lt;&gt;();<br/><br/>    // Next, we will register a Subscriber<br/>    PacktSubscriber&lt;String&gt; currentSubscriber = new <br/>     PacktSubscriber&lt;&gt;();<br/>    packtPublisher.subscribe(currentSubscriber);<br/><br/>    // Finally, we will publish data to the Subscriber and <br/>       close the publishing effort<br/>    System.out.println("||---- Publishing Data Stream ----||");<br/>    . . . <br/>    packtPublisher.close();<br/>    System.out.println("||---- End of Data Stream Reached ----||");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional Concurrency Updates</h1>
                </header>
            
            <article>
                
<p>The <strong>More Concurrency Updates</strong> Java Enhancement Proposal, JEP 266, aimed to improve the use of concurrency in Java. In this section, we will briefly explore the concept of Java concurrency and look at related enhancements to the Java 9 platform:</p>
<ul>
<li>Java concurrency</li>
<li>Supporting Reactive Streams</li>
<li><kbd>CompletableFuture</kbd> API enhancements</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java concurrency</h1>
                </header>
            
            <article>
                
<p>In this section, we will start with a brief explanation of concurrency, then look at system configurations, cover Java threads, and then look at the concurrency improvements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrency explained</h1>
                </header>
            
            <article>
                
<p>Concurrent processing has been around since the 1960s. In those formative years, we already had systems that permitted multiple processes to share a single processor. These systems are more clearly defined as pseudo-parallel systems because it only appeared that multiple processes were being simultaneously executed. Our computers today still operate in this manner. The difference between the 1960s and current day is that our computers can have multiple CPUs, each with multiple cores, which better supports concurrency.</p>
<div class="packt_infobox">Concurrency and parallelism are often used as interchangeable terms. Concurrency is when multiple processes overlap, although the start and stop times could be different. Parallelism occurs when tasks start, run, and stop at the same time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">System configurations</h1>
                </header>
            
            <article>
                
<p>There are several different processor configurations that need to be considered. This section features two common configurations. The first configuration is that of shared memory and is illustrated here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="148" width="357" src="assets/16c7840b-fe24-479a-a6f1-e0524122b049.png"/></div>
<p>As you can see, the shared memory system configuration has multiple processors that all share a common system memory. The second featured system configuration is a distributed memory system:</p>
<div class="CDPAlignCenter CDPAlign"><img height="283" width="337" src="assets/2fd7c1a8-e2ff-44b8-96c8-35535ef9c6e1.png"/></div>
<p>With the distributed memory system, each processor has its own memory and each individual processor is fully linked with the other processors, making for a distributed system that is fully linked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java threads</h1>
                </header>
            
            <article>
                
<p>A thread in Java is a program execution and is built into the JVM. The <kbd>Thread</kbd> class is part of the <kbd>java.lang</kbd> package (<kbd>java.lang.Thread</kbd>). Threads have priorities that control in what order the JVM executes them. While the concept is simple, implementation is not. Let's start by taking a close look at the <kbd>Thread</kbd> class.</p>
<p>The <kbd>Thread</kbd> class has two nested classes:</p>
<ul>
<li><kbd>public static enum Thread.State</kbd></li>
<li><kbd>public static interface Thread.UncaughtExceptionHandler</kbd></li>
</ul>
<p>There are three instance variables for managing thread priorities:</p>
<ul>
<li><kbd>public static final int MAX_PRIORITY</kbd></li>
<li><kbd>public static final int MIN_PRIORITY</kbd></li>
<li><kbd>public static final int NORM_PRIORITY</kbd></li>
</ul>
<p>The <kbd>Thread</kbd> class has eight constructors, all of which allocate a new <kbd>Thread</kbd> object. Here are the constructor signatures:</p>
<ul>
<li><kbd>public Thread()</kbd></li>
<li><kbd>public Thread(Runnable target)</kbd></li>
<li><kbd>public Thread(Runnable target, String name)</kbd></li>
<li><kbd>public Thread(String name)</kbd></li>
<li><kbd>public Thread(ThreadGroup group, Runnable target)</kbd></li>
<li><kbd>public Thread(ThreadGroup group, Runnable target, String name)</kbd></li>
<li><kbd>public Thread(ThreadGroup group, Runnable target, String name, long stackSize)</kbd></li>
<li><kbd>public Thread(ThreadGroup group, String name)</kbd></li>
</ul>
<p>The <kbd>Thread</kbd> class also has 43 methods, six of which have been deprecated. The remaining methods are listed here, save for the accessors and mutators which are listed separately. You can consult the documentation for details about each of these methods:</p>
<ul>
<li><kbd>public static int activeCount()</kbd></li>
<li><kbd>public final void checkAccess()</kbd></li>
<li><kbd>protected Object clone() throws CloneNotSupportedException</kbd></li>
<li><kbd>public static Thread currentThread()</kbd></li>
<li><kbd>public static void dumpStack()</kbd></li>
<li><kbd>public static int enumerate(Thread[] array)</kbd></li>
<li><kbd>public static boolean holdsLock(Object obj)</kbd></li>
<li><kbd>public void interrupt()</kbd></li>
<li><kbd>public static boolean interrupted()</kbd></li>
<li><kbd>public final boolean isAlive()</kbd></li>
<li><kbd>public final boolean isDaemon()</kbd></li>
<li><kbd>public boolean isInterrupted()</kbd></li>
<li>join methods:
<ul>
<li><kbd>public final void join() throws InterruptedException</kbd></li>
<li><kbd>public final void join(long millis) throws InterruptedException</kbd></li>
<li><kbd>public final void join(long millis, int nano) throws InterruptedException</kbd></li>
</ul>
</li>
<li><kbd>public void run()</kbd></li>
<li>sleep methods:
<ul>
<li><kbd>public static void sleep(long mills) throws InterruptedException</kbd></li>
<li><kbd>public static void sleep(long mills, int nano) throws InterruptedException</kbd></li>
</ul>
</li>
<li><kbd>public void start()</kbd></li>
<li><kbd>public String toString()</kbd></li>
<li><kbd>public static void yield()</kbd></li>
</ul>
<p>Here is the list of accessors/getters and mutators/setters for the <kbd>Thread</kbd> class:</p>
<ul>
<li>accessors/getters:
<ul>
<li><kbd>public static Map&lt;Thread, StackTraceElement[]&gt; getAllStacktraces()</kbd></li>
<li><kbd>public ClassLoader getContextClassLoader()</kbd></li>
<li><kbd>public static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()</kbd></li>
<li><kbd>public long getId()</kbd></li>
<li><kbd>public final String getName()</kbd></li>
<li><kbd>public final int getPriority()</kbd></li>
<li><kbd>public StackTraceElement[] getStackTrace()</kbd></li>
<li><kbd>public Thread.State getState()</kbd></li>
<li><kbd>public final ThreadGroup getThreadGroup()</kbd></li>
<li><kbd>public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()</kbd></li>
</ul>
</li>
</ul>
<ul>
<li>mutators/setters:
<ul>
<li><kbd>public void setContextClassLoader(ClassLoader cl)</kbd></li>
<li><kbd>public final void setDaemon(boolean on)</kbd></li>
<li><kbd>public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</kbd></li>
<li><kbd>public final void setName(String name)</kbd></li>
<li><kbd>public final void setPriority(int newPriority)</kbd></li>
<li><kbd>public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</kbd></li>
</ul>
</li>
</ul>
<p><span>In Java, concurrency is commonly referred to as multithreading. As indicated earlier, managing threads, and especially multithreads, requires great fidelity in control. Java employs a couple of techniques including the use of locks. Code segments can be locked to ensure that only a single thread can execute that code at any given time. We can lock classes and method with the use of the <kbd>synchronized</kbd> keyword. Here is an example of how to lock an entire method:</span></p>
<pre>    public synchronized void protectedMethod()<br/>    {<br/>      . . . <br/>    }</pre>
<p>The next code snippet demonstrates how to use the synchronized keyword to lock blocks of code within a method:</p>
<pre>    . . . <br/>    public class unprotectedMethod()<br/>    {<br/>      . . . <br/>      public int doSomething(int tValue) <br/>      {<br/>        synchronized (this)<br/>        {<br/>          if (tValue != 0)<br/>          {<br/>            // do something to change tValue<br/>            return tValue;<br/>          }<br/>        }<br/>      } <br/>    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrency improvements</h1>
                </header>
            
            <article>
                
<p>The ability to employ multiple threads in our Java applications stands to greatly improve efficiency and leverage the increasing processing capabilities of modern computers. The use of threads in Java gives us great granularity in our concurrency controls.</p>
<p>Threads are at the core of Java's concurrency functionality. We can create a thread in Java by defining a <kbd>run</kbd> method and instantiating a <kbd>Thread</kbd> object. There are two methods of accomplishing this set of tasks. Our first option is to extend the <kbd>Thread</kbd> class and override the <kbd>Thread.run</kbd> method. Here is an example of that approach:</p>
<pre>    . . .<br/>    class PacktThread extends Thread<br/>    {<br/>      . . .<br/>      public void run()<br/>      {<br/>        . . . <br/>      }<br/>    }<br/><br/>    . . . <br/><br/>    Thread varT = new PacktThread();<br/><br/>    . . .<br/><br/>    // This next line is start the Thread by executing<br/>       the run() method.<br/>    varT.start();<br/><br/>    . . . </pre>
<p>A second approach is to create a class that implements the <kbd>Runnable</kbd> interface and passing an instance of the class to the constructor of the <kbd>Thread</kbd>. Here is an example:</p>
<pre>    . . . <br/>    class PacktRunner implements Runnable<br/>    {<br/>       . . .<br/>      public void run()<br/>      {<br/>        . . .<br/>      }<br/>    }<br/><br/>    . . . <br/><br/>    PacktRunner varR = new PacktRunner();<br/>    Thread varT = new Thread(varR);<br/><br/>    . . .<br/><br/>    // This next line is start the Thread by executing the <br/>       run() method.<br/>    varT.start();<br/><br/>    . . . </pre>
<p>Both of these methods work equally well, and which one you use is considered to be the developer's choice. Of course, if you are looking for additional flexibility, the second approach is probably a better one to use. You can experiment with both methods to help you make your determination.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CompletableFuture API enhancements</h1>
                </header>
            
            <article>
                
<p>The <kbd>CompleteableFuture&lt;T&gt;</kbd> class is part of the <kbd>java.util.concurrent</kbd> package. The class extends the <kbd>Object</kbd> class and implements the <kbd>Future&lt;T&gt;</kbd> and <kbd>CompletionStage&lt;T&gt;</kbd> interfaces. This class is used to annotate threads that can be completed. We can use the <kbd>CompletableFuture</kbd> class to represent a future result. When the complete method is used, that future result can be completed.</p>
<p>It is important to realize that if multiple threads attempt to simultaneously complete (finish or cancel), all but one will fail. Let's look at the class and then look at the enhancements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Class details</h1>
                </header>
            
            <article>
                
<p><span>The</span> <kbd>CompleteableFuture&lt;T&gt;</kbd> <span>class has one internal class that marks asynchronous tasks:</span></p>
<pre>    public static interface<br/>     CompletableFuture.AsynchronousCompletionTask</pre>
<p>The constructor for <span>the</span> <kbd>CompleteableFuture&lt;T&gt;</kbd> <span>class has to be in sync with the provided constructor signature, and it takes no arguments. The class has the following methods organized by what they return.</span></p>
<p>Returns a <kbd>CompletionStage</kbd>:</p>
<ul>
<li><kbd>public CompletableFuture&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn, Executor executor)</kbd></li>
<li><kbd>public static &lt;U&gt; CompletedStage&lt;U&gt; completedStage(U value)</kbd></li>
<li><kbd>public static &lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</kbd></li>
<li><kbd>public CompletionStage&lt;T&gt; minimalCompletionStage()</kbd></li>
<li><kbd><kbd>public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action)</kbd></kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor)</kbd></li>
</ul>
<p>These methods return a <kbd>CompletionStage</kbd>:</p>
<ul>
<li><kbd>public CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action, Executor executor)</kbd></li>
<li><kbd><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T, ? extends U&gt; fn)</kbd></kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T, ? extends U&gt; fn)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T, ? extends U&gt; fn, Executor executor)</kbd></li>
<li><kbd>public &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn)</kbd></li>
<li><kbd>public &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn)</kbd></li>
<li><kbd>public &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn, Executor executor)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt; thenRun(Runnable action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt;thenRunAsync(Runnable action)</kbd></li>
<li><kbd>public CompletableFuture&lt;Void&gt;thenRunAsync(Runnable action, Executor executor)</kbd></li>
</ul>
<p>These methods return a <kbd>CompleteableFuture</kbd>:</p>
<ul>
<li><kbd>public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;...cfs)</kbd></li>
<li><kbd>public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier)</kbd></li>
<li><kbd><kbd>public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)</kbd></kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; copy()</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn)</kbd></li>
<li><kbd>public static &lt;U&gt; CompletableFuture&lt;U&gt; failedFuture(Throwable ex)</kbd></li>
<li><kbd>public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompeteFuture()</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)</kbd></li>
<li><kbd>public static ComletableFuture&lt;Void&gt; runAsync(Runnable runnable)</kbd></li>
<li><kbd>public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</kbd></li>
<li><kbd>public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</kbd></li>
<li><kbd>public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U. supplier, Executor executor)</kbd></li>
<li><kbd>public CompletableFuture&lt;T&gt; toCompletableFuture()</kbd></li>
</ul>
<p>These methods return a <kbd>Executor</kbd>:</p>
<ul>
<li><kbd>public Executor defaultExecutor()</kbd></li>
<li><kbd>public static Executor delayedExecutor(long delay, Timeunit unit, Executor executor)</kbd></li>
<li><kbd>public static Executor delayedExecutor(long delay, Timeunit unit)</kbd></li>
</ul>
<p><span>These methods return a</span> <kbd>boolean</kbd>:</p>
<ul>
<li><kbd>public boolean cancel(boolean mayInterruptIfRunning)</kbd></li>
<li><kbd>public boolean complete(T value)</kbd></li>
<li><kbd>public boolean completeExceptionally(Throwable ex)</kbd></li>
<li><kbd>public boolean isCancelled()</kbd></li>
<li><kbd>public boolean isCompletedExceptionally()</kbd></li>
<li><kbd>public boolean isDone()</kbd></li>
</ul>
<p>No return type:</p>
<ul>
<li><kbd>public void obtrudeException(Throwable ex)</kbd></li>
<li><kbd>public void obtrudeValue(T value)</kbd></li>
</ul>
<p>Additional methods:</p>
<ul>
<li><kbd>public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</kbd></li>
<li><kbd>public T get() throws InterruptedException, ExecutionException</kbd></li>
<li><kbd>public T getNow(T valueIfAbsent)</kbd></li>
<li><kbd>public int getNumberOfDependents()</kbd></li>
<li><kbd>public T join()</kbd></li>
<li><kbd>public String toString()</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhancements</h1>
                </header>
            
            <article>
                
<p><span>The</span> <kbd>CompleteableFuture&lt;T&gt;</kbd> <span>class received the following enhancements as part of the Java 9 platform:</span></p>
<ul>
<li>Added time-based enhancements:
<ul>
<li>This enables completions based on lapsed time</li>
<li>Delayed executions are now also supported</li>
</ul>
</li>
<li>Significant enhancement to subclasses:
<ul>
<li>Extending <kbd>CompletableFuture</kbd> is easier</li>
<li>Subclasses support alternative default executors</li>
</ul>
</li>
</ul>
<p>Specifically, the following methods were added in Java 9:</p>
<ul>
<li><kbd>newIncompleteFuture()</kbd></li>
<li><kbd>defaultExecutor()</kbd></li>
<li><kbd>copy()</kbd></li>
<li><kbd>minimalCompletionStage()</kbd></li>
<li><kbd>completeAsync()</kbd></li>
<li><kbd>orTimeout()</kbd></li>
<li><kbd><kbd>completeOnTimeout()</kbd></kbd></li>
<li><kbd>delayedExecutor()</kbd></li>
<li><kbd>completedStage()</kbd></li>
<li><kbd>failedFuture()</kbd></li>
<li><kbd>failedStage()</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spin-Wait Hints</h1>
                </header>
            
            <article>
                
<p>With concurrency, we need to ensure that threads waiting to be executed actually get executed. The concept of spin-wait is a process that continually checks for a true condition. The aim of Java Enhancement Proposal 285 was to create an API that permits Java code to issue hints that a spin loop is currently being executed.</p>
<p>While this is not a feature that every Java developer will use, it can be useful for low-level programming. The hint system simply issues hints--indications, and performs no other actions. Justifications for adding these hints include the following assumptions:</p>
<ul>
<li>A spin loop's action time can be improved when using a spin hint</li>
<li>Use of spin hints will reduce thread-to-thread latency</li>
<li>CPU power consumption will be reduced</li>
<li>Hardware threads will execute faster</li>
</ul>
<p>This hint functionality will be contained in a new <kbd>onSpinWait()</kbd> method as part of the <kbd>java.lang.Thread</kbd> class. Here is an example of implementing the <kbd>onSpinWait()</kbd> method:</p>
<pre>    . . . <br/><br/>    volatile boolean notInReceiptOfEventNotification; <br/><br/>    . . . <br/><br/>    while ( notInReceiptOfEventNotification );<br/>    {<br/>      java.lang.Thread.onSpinWait();<br/>    }<br/><br/>    // Add functionality here to read and process the event<br/><br/>    . . . </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we <span>covered concurrency enhancements introduced with the Java 9 platform. We took a deep look at concurrency both as a core Java concept and with an eye to what Java 9 is delivering. We also explored the <kbd>Flow</kbd> class API that</span> <span>supports reactive programming, a new concept in Java 9. In addition, we explored concurrency enhancements and the new spin-wait hints introduced in Java 9.</span></p>
<p>In the next chapter, we will highlight the security enhancements introduced in Java 9 along with practical examples.</p>


            </article>

            
        </section>
    </body></html>