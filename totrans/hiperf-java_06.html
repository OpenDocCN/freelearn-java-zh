<html><head></head><body>
		<div id="_idContainer018">
			<h1 class="chapter-number" id="_idParaDest-106"><a id="_idTextAnchor105"/>6</h1>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>Strategic Object Creation and Immutability</h1>
			<p>This chapter continues our quest to find ways to get the most performance out of our Java applications. Creating objects is a core part of all Java applications, so the goal is not to eradicate that; rather, it is to take a strategic approach to <span class="No-Break">object creation.</span></p>
			<p>How and when we create objects can play a crucial role in application performance. Object creation impacts not only performance but also overall efficiency, garbage collection, and memory use. This chapter intends to provide you with the knowledge and skills you’ll need to implement an object <span class="No-Break">creation strategy.</span></p>
			<p>A core part of object creation strategies is the concept of object immutability. This chapter presents information and examples on how to make objects immutable and explains why you should <span class="No-Break">consider it.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Minimizing <span class="No-Break">object creation</span></li>
				<li><span class="No-Break">Object immutability</span></li>
				<li><span class="No-Break">Garbage collection</span></li>
				<li><span class="No-Break">Design patterns</span></li>
			</ul>
			<p>By the end of this chapter, you should have an understanding and appreciation for the importance of strategic object creation and the powerful concept of object immutability. This understanding will help you improve the performance of your <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need to be able to load, edit, and run Java code. If you haven’t set up your development environment, please refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Minimizing object creation</h1>
			<p>Minimizing object creation is a critical concern when we are striving for high-performance applications. Every time we create an object, we use memory and processing resources. Although<a id="_idIndexMarker262"/> modern systems have an impressive array of memory capacity and processing capabilities, they are <span class="No-Break">not limitless.</span></p>
			<p>To ensure we handle this concern correctly, we should seek to understand the life cycle of a Java object, how object creation impacts memory, and what object pooling is. We should also experiment with different object initialization approaches and ways to reduce system overhead. That is the aim of this section. Let’s start our exploration of minimizing object creation by looking at the life cycle of <span class="No-Break">Java objects.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Java object life cycle</h2>
			<p>The notion of an object in the Java programming language is nothing new. When considering high-performance Java <a id="_idIndexMarker263"/>applications, we need to consider the overall life cycle of our objects. The creation, use, and deletion of objects have a direct impact on the overall performance of our applications. The following figure depicts a typical object’s <span class="No-Break">life cycle:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 6.1 – Java object life cycle" src="image/B21942_06_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Java object life cycle</p>
			<p>As illustrated in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em>, the first step of an object’s life cycle is object creation. When a new object is created, it is <a id="_idIndexMarker264"/>said to be <strong class="bold">instantiated</strong>, meaning that we created an instance of the class. This is also referred to as <strong class="bold">instantiation</strong>. As you can see from the <a id="_idIndexMarker265"/>following code, we use<a id="_idIndexMarker266"/> Java’s <strong class="source-inline">new</strong> keyword to allocate memory on the heap so that we can store our <span class="No-Break">object’s data:</span></p>
			<pre class="source-code">
public class Corgi {
  // Instance variables
  private String name;
  private int age;
  private int weight;
  // Constructor
  public Corgi(String name, int age, int weight) {
    this.name = name;
    this.age = age;
    this.weight = weight;
  }
  // Getter methods
  // Setter methods
  // Methods
}</pre>			<p>The next phase of an object’s life cycle is its use and reference. This is where we execute the object’s methods and reference <span class="No-Break">its properties.</span></p>
			<p>The third phase is <a id="_idIndexMarker267"/>garbage collection. Once we stop using an object and it can no longer be referenced, the <strong class="bold">Java Virtual Machine’s</strong> (<strong class="bold">JVM’s</strong>) garbage collector will reclaim the memory the out-of-scope object <span class="No-Break">is using.</span></p>
			<p>The last phase of an object’s life cycle is when it is destroyed. The garbage collector takes care of this for us. Once the object is destroyed, it is no longer accessible to <span class="No-Break">the application.</span></p>
			<p>Understanding an<a id="_idIndexMarker268"/> object’s life cycle is a prerequisite to being able to create and adopt an object <span class="No-Break">creation strategy.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Memory</h2>
			<p>We implicitly understand that <a id="_idIndexMarker269"/>objects require memory to exist and that the more objects our applications use at one time, the more memory that is required. To support high performance, we should strive to understand how Java manages memory specific to object creation. To aid in our understanding, let’s look <span class="No-Break">at three.</span></p>
			<h3>Stack versus heap memory</h3>
			<p><strong class="bold">Stacks</strong> and <strong class="bold">heaps</strong> are both used for <a id="_idIndexMarker270"/>memory allocation, are used for different purposes, and<a id="_idIndexMarker271"/> behave differently. Let’s start by defining <span class="No-Break">a stack.</span></p>
			<p class="callout-heading">Stack</p>
			<p class="callout">A stack is the <a id="_idIndexMarker272"/>region of memory<a id="_idIndexMarker273"/> where a static collection of elements using a <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>) model <span class="No-Break">is stored.</span></p>
			<p>Next, let’s look at what a heap is so that we can compare it to a stack and determine how both of them <span class="No-Break">impact performance.</span></p>
			<p class="callout-heading">Heap</p>
			<p class="callout">A heap is an area of <a id="_idIndexMarker274"/>memory that’s used for dynamic memory allocation. Objects are allocated on the heap when we use the <strong class="source-inline">new</strong> keyword in <span class="No-Break">our applications.</span></p>
			<p>Java uses both stacks and heaps and, as you’ve learned, they are used differently. Let’s look more deeply at stacks. We typically use stacks to store our application’s local variables, as well as reference information for our methods. Stacks use <strong class="bold">LIFO</strong> for efficient access to local variables and method calls. Limiting factors of stacks include their limited lifespan and size. This makes the use of stacks for long-term object <span class="No-Break">storage impractical.</span></p>
			<p>We push objects onto the heap when we use Java’s <strong class="source-inline">new</strong> keyword. Heaps provide us with dynamic memory allocation. When we <a id="_idIndexMarker275"/>use a heap, our objects can exist outside the scope of the methods that <a id="_idIndexMarker276"/>created them. This necessitates the use of the JVM’s garbage collector to remove items from the heap that <span class="No-Break">are unreachable.</span></p>
			<p>The following table summarizes the differences between stacks and heaps <span class="No-Break">in Java:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Characteristic</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Stack</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Heap</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Storage</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Local variables</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Objects and their methods <span class="No-Break">and properties</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Memory management</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">LIFO order</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Managed by the JVM <span class="No-Break">garbage collector</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Size</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Limited</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Larger <span class="No-Break">than stacks</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Lifetime</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Variables exist until the declaring <span class="No-Break">method ends</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Objects exist until they are no <span class="No-Break">longer reachable</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Performance</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Fast allocation <span class="No-Break">and deallocation</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Slower <span class="No-Break">than stacks</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – Stack and heap comparison</p>
			<p>The key differences between stacks and heaps are their scope of use, how the memory is managed, access speed, and storage size. In addition, there are risks of errors at runtime. For example, a stack can run out of memory, which leads to a <strong class="source-inline">StackOverflowError</strong> error. If a heap runs out of memory, an <strong class="source-inline">OutOfMemoryError</strong> error can be thrown. We need to handle those errors. Let’s look at <span class="No-Break">an example:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
  // Catch StackOverflowError
  try {
    // your code goes here
  } catch (StackOverflowError e) {
    System.out.println("Caught StackOverflowError");
  }
  // Catch OutOfMemoryError
  try {
    // your code goes here
  } catch (OutOfMemoryError e) {
    System.out.println("Caught OutOfMemoryError");
  }
}</pre>			<p>As you can see, we <a id="_idIndexMarker277"/>used <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> blocks to trap the errors. Also, it is important to know that these errors <a id="_idIndexMarker278"/>are instances of <strong class="source-inline">Error</strong>, not <strong class="source-inline">Exception</strong>. So, these are indeed errors, <span class="No-Break">not exceptions.</span></p>
			<h3>Memory management with garbage collection</h3>
			<p>One of the most prized features<a id="_idIndexMarker279"/> of the Java<a id="_idIndexMarker280"/> programming language is its <strong class="bold">garbage collection</strong>. This automatic memory deallocation can take a lot of responsibility off the developer’s shoulders, but there are some disadvantages as well. Let’s take a deeper look at Java’s seemingly straightforward <span class="No-Break">garbage collection.</span></p>
			<p>Java’s garbage collector identifies objects that are no longer reachable in the application. Once identified, those objects are removed and the memory they used is deallocated, making it available to <span class="No-Break">the application.</span></p>
			<p>While we can applaud the garbage collector’s efforts and appreciate the memory it frees up for our applications, there can be an impact on performance. When we have frequent garbage collection cycles, pauses and reduced responsiveness can be introduced at runtime. Mitigation strategies include minimizing object creation and implementing timely object disposal. These strategies can reduce the frequency of <span class="No-Break">garbage collection.</span></p>
			<p>We will look at how to implement these strategies later in <span class="No-Break">this chapter.</span></p>
			<h3>Optimization techniques</h3>
			<p>There are several strategies that we <a id="_idIndexMarker281"/>can adopt to help optimize memory usage in our <span class="No-Break">Java applications:</span></p>
			<ul>
				<li>Limit object creation; only create them when <span class="No-Break">absolutely needed</span></li>
				<li>Avoid creating objects <span class="No-Break">within loops</span></li>
				<li>Use local variables and object pooling (covered in <a href="B21942_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">)</span></li>
				<li>Implement object immutability (covered later in the <em class="italic">Object immutability</em> section of <span class="No-Break">this chapter)</span></li>
				<li>Use profiling tools for memory usage (see <a href="B21942_14.xhtml#_idTextAnchor250"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><span class="No-Break">)</span></li>
			</ul>
			<p>It is important to take a purposeful and informed approach to memory management in our Java applications. To do this, we need to understand memory limitations and how memory is allocated <span class="No-Break">and deallocated.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Object pooling</h2>
			<p>As you may recall from <a href="B21942_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, object pooling is an important design pattern we can use to create a set of objects that can be kept in a <a id="_idIndexMarker282"/>pool, ready for use, instead of allocating them when we need them and deallocating them when they go out of scope. Object pooling helps us to efficiently manage system resources by reusing objects. The benefits are especially noticeable when our objects are large and take significant time <span class="No-Break">to create.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Initialization approaches</h2>
			<p>There is more than one way to<a id="_idIndexMarker283"/> create objects in Java and our initialization approach can significantly impact the overall performance of our Java applications and how our memory is used. Let’s look at four approaches: direct, lazy, pooling, <span class="No-Break">and builder.</span></p>
			<h3>Direct initialization</h3>
			<p>The most common method that’s used to create a new object is the <strong class="bold">direct initialization</strong> method. As shown<a id="_idIndexMarker284"/> in the following example, it’s straightforward. We use constructors or initializers with <span class="No-Break">this</span><span class="No-Break"><a id="_idIndexMarker285"/></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
Corgi myCorgi = new Corgi("Java", 3);</pre>			<p>The benefits of this method are that it is easy to understand and program. It can also be used in many scenarios where objects need to be created. The disadvantages of this method include that it can lead to unnecessary object creation, which is the opposite of our goal to minimize object creation. This is especially evident when the direct initialization method is used inside loops or in methods that are called frequently. Another disadvantage is that the objects that are created using this method cannot <span class="No-Break">be reused.</span></p>
			<h3>Lazy initialization</h3>
			<p>The strategy of delaying an object’s creation <a id="_idIndexMarker286"/>until it is needed by the application is referred to as <strong class="bold">lazy initialization</strong>. As illustrated in <a id="_idIndexMarker287"/>the following code snippet, the object isn’t created unless a specific <span class="No-Break">condition exists:</span></p>
			<pre class="source-code">
Corgi myCorgi = null; // Initialize to null
// ...
if (someCondition) {
    myCorgi = new Corgi("Java", 3); // Create the object when needed
}</pre>			<p>An advantage of this method is that object creation is minimized until it is required. Additionally, memory usage is reduced when we conditionally create several objects. However, this strategy results in increased code complexity and can introduce synchronization issues when dealing with <span class="No-Break">multi-threaded environments.</span></p>
			<h3>Object pooling</h3>
			<p>We can also use object pooling to create a pool of pre-initialized objects that can be used multiple times, taking them from and returning them to the pool as needed. The following code snippet shows <a id="_idIndexMarker288"/>how that code would <span class="No-Break">be</span><span class="No-Break"><a id="_idIndexMarker289"/></span><span class="No-Break"> structured:</span></p>
			<pre class="source-code">
ObjectPool&lt;Corgi&gt; corgiPool = new ObjectPool&lt;&gt;(Corgi::new, 10); // Create a pool of 10 Corgi objects
// ...
Corgi myCorgi = corgiPool.acquire(); // Get obj from pool
// ...
corgiPool.release(myCorgi); // Release obj to the pool</pre>			<p>You can revisit <a href="B21942_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> for greater detail on <span class="No-Break">object pooling.</span></p>
			<h3>Builder pattern</h3>
			<p>Another increasingly popular<a id="_idIndexMarker290"/> method of object creation is using the builder pattern. This is a design pattern that treats object construction and its <a id="_idIndexMarker291"/>representation separately. This method empowers us to create multi-attribute objects one step at a time. The following code snippet illustrates the build <span class="No-Break">pattern concept:</span></p>
			<pre class="source-code">
CorgiBuilder builder = new CorgiBuilder();
builder.setName("Java");
builder.setAge(3);
Corgi myCorgi = builder.build();</pre>			<p>One benefit of this method is that it introduces object construction flexibility. This can be very useful when you’re creating complex objects. Another benefit is that it permits us to set selected attributes by having a complex constructor. The primary disadvantage of the builder pattern method is that it requires us to define a separate builder class for each type of object that’s used in our applications. This can significantly increase our code’s complexity and decrease its readability <span class="No-Break">and maintainability.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Overhead reduction</h2>
			<p>When we consider the <a id="_idIndexMarker292"/>goal of minimizing object creation, we should consider object pooling, object cloning, and <a id="_idIndexMarker293"/>object serialization. We touched on object pooling earlier in this chapter and provided in-depth coverage in <a href="B21942_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>. We will save our discussion on object cloning until later in this chapter. For now, know that it can be associated with <span class="No-Break">overhead reduction.</span></p>
			<p>The third concept is object serialization. Fortunately, Java allows us to convert objects to and from binary form. We typically use this for object persistence and can also use it to create copies of objects with <span class="No-Break">reduced overhead.</span></p>
			<p>Here’s an example of how <a id="_idIndexMarker294"/>we can serialize (convert into binary) and deserialize (convert back to <span class="No-Break">an object):</span></p>
			<pre class="source-code">
// Serialize the object
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
objectOutputStream.writeObject(originalCorgi);
// Deserialize the object
ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
Corgi clonedCorgi = (Corgi) objectInputStream.readObject();</pre>			<p>Reducing overhead when creating objects should be a key consideration when our applications are expected to have <span class="No-Break">high performance.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Object immutability</h1>
			<p>Let’s continue learning how to minimize object <a id="_idIndexMarker295"/>creation to increase the performance of our Java applications. <strong class="bold">Object immutability</strong> refers to an object that cannot be modified once it has been instantiated. Immutability can be considered a property or characteristic of an object. The advantages of making objects <strong class="bold">immutable</strong> include system predictability <span class="No-Break">and performance.</span></p>
			<p>Let’s start with a brief overview <a id="_idIndexMarker296"/>of <span class="No-Break">object immutability.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Immutability overview</h2>
			<p>Object immutability is not a <a id="_idIndexMarker297"/>new concept, but it is an important one. The general premise is that we create an object with all the desired attributes and behaviors, and then prevent it from being <strong class="bold">mutated</strong> (changed) throughout the object’s <span class="No-Break">life cycle.</span></p>
			<p>Immutable objects and considered safe because they cannot be changed. This means that we can share these objects in multi-threaded environments without the requirement for synchronization. So, concurrent programming is simplified. You will learn more about concurrency in <a href="B21942_09.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<p>Immutable objects are known to have an immutable state, be safe for sharing, have predictable behavior, and align with functional <span class="No-Break">programming principles.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Best practices</h2>
			<p>Creating immutable objects requires more than simply setting an attribute; it requires adherence to certain best <a id="_idIndexMarker298"/>practices. We want our immutable objects to be robust, the code to be maintainable, and positively contribute to the application’s <span class="No-Break">overall performance.</span></p>
			<p>Understanding these best practices is key to <span class="No-Break">proper implementation.</span></p>
			<h3>Declare as final</h3>
			<p>The first best practice for creating immutable objects is to ensure all attributes are declared as <strong class="source-inline">final</strong>. The following code shows how to declare the class as <strong class="source-inline">final</strong>, as well as the <span class="No-Break">two variables:</span></p>
			<pre class="source-code">
public final class ImmutableExample1 {
    private final int value;
    private final String text;
    public ImmutableExample1(int value, String text) {
        this.value = value;
        this.text = text;
    }
    // Getter methods...
}</pre>			<p>Adhering to this best <a id="_idIndexMarker299"/>practice ensures the attributes cannot be changed once the object is created. This can also help us detect any attempts to change the object <span class="No-Break">at runtime.</span></p>
			<h3>Complete constructor</h3>
			<p>The second best practice is simply to ensure that all attributes of a class are initialized in the constructor. It is important to initialize all fields within the constructor. The goal is to ensure that the object is fully defined when it is created. Remember, we won’t be able to make changes to the <span class="No-Break">object later.</span></p>
			<h3>Avoid setters</h3>
			<p>When you’ve been a Java developer for a considerable time, you’ll likely create setters and getters in your classes automatically. We don’t use a checklist; it just becomes a habit. In the case of immutable objects, we don’t want to give our applications the ability to call a setter since no changes should be made to the object after it’s created. The following code snippet shows how to create a standard class with a constructor. There is a getter method, but <span class="No-Break">no setters:</span></p>
			<pre class="source-code">
public final class ImmutableExample2 {
    private final int value;
    private final String text;
    public ImmutableExample2(int value, String text) {
        this.value = value;
        this.text = text;
    }
    public int getValue() {
        return value;
    }
    public String getText() {
        return text;
    }
}</pre>			<p>Since we shouldn’t be calling any setters on immutable objects, it’s important not to include them in <span class="No-Break">our classes.</span></p>
			<h3>Defensive copies</h3>
			<p>When we return <a id="_idIndexMarker300"/>a reference from an immutable object to an internal mutable object, it’s important to return a <strong class="bold">defensive copy</strong>. This prevents any external modification. The <a id="_idIndexMarker301"/>following code snippet demonstrates how we should implement this <span class="No-Break">best practice:</span></p>
			<pre class="source-code">
public final class ImmutableExample3 {
    private final List&lt;String&gt; data;
    public ImmutableExample3(List&lt;String&gt; data) {
        // Create a defensive copy to ensure the list cannot be 
        // modified externally
        this.data = new ArrayList&lt;&gt;(data);
    }
    public List&lt;String&gt; getData() {
        // Return an unmodifiable view of the list to prevent 
        // modifications
        return Collections.unmodifiableList(data);
    }
}</pre>			<p>Using this approach helps<a id="_idIndexMarker302"/> ensure that the object’s state <span class="No-Break">remains immutable.</span></p>
			<h3>Annotation</h3>
			<p>Our last best practice when it comes to creating immutable objects is to use the <strong class="source-inline">@Immutable</strong> annotation. Here, we<a id="_idIndexMarker303"/> are using the <strong class="bold">Project </strong><span class="No-Break"><strong class="bold">Lombok</strong></span><span class="No-Break"> library:</span></p>
			<pre class="source-code">
import lombok.Immutable;
@Immutable
public final class ImmutableExample4 {
    private final int value;
    private final String text;
    public ImmutableExample4(int value, String text) {
        this.value = value;
        this.text = text;
    }
    // Getter methods...
}</pre>			<p>When we use this annotation, we can benefit from auto-generated code making us more efficient. Note that this annotation may not be available in later versions <span class="No-Break">of Lombok.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Performance advantages</h2>
			<p>As you have learned so far, object<a id="_idIndexMarker304"/> immutability offers several benefits to us and our applications. One category of benefits is performance. Here’s a list of <span class="No-Break">performance advantages:</span></p>
			<ul>
				<li><strong class="bold">Predicable state</strong>: When using immutable objects, we can rely on their state to remain constant throughout <span class="No-Break">their lifespan.</span></li>
				<li><strong class="bold">Garbage collection efficiency</strong>: Using immutable objects reduces how often object collection and disposal functions have <span class="No-Break">to run.</span></li>
				<li><strong class="bold">Safe caching</strong>: We can safely cache immutable objects and even share them among multiple threads without data <span class="No-Break">corruption concerns.</span></li>
				<li><strong class="bold">Reduced overhead</strong>: Because immutable objects are thread-safe, we don’t need to use synchronization mechanisms in <span class="No-Break">multi-thread environments.</span></li>
				<li><strong class="bold">Easier parallelization</strong>: We can simplify concurrent programming and parallel programming when we use <span class="No-Break">immutable objects.</span></li>
				<li><strong class="bold">Functional programming advantage</strong>: As mentioned previously, immutable objects align with functional programming. In that programming paradigm, functions produce predictable results without <span class="No-Break">side effects.</span></li>
			</ul>
			<p>Understanding the performance advantages of using object immutability can encourage us to adopt this approach, which can result in sufficiently more performant <span class="No-Break">Java applications.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Custom classes</h2>
			<p>We previously reviewed best <a id="_idIndexMarker305"/>practices for implementing immutable objects. In addition to those best practices, we should implement the <strong class="source-inline">equals</strong> and <strong class="source-inline">hashCode</strong> methods. Let’s look at that <span class="No-Break">in code:</span></p>
			<pre class="source-code">
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    CustomImmutable that = (CustomImmutable) o;
    return value == that.value &amp;&amp; Objects.equals(text, that.text);
}
@Override
public int hashCode() {
    return Objects.hash(value, text);
}</pre>			<p>As you can see, when <a id="_idIndexMarker306"/>we want to perform equality testing and ensure compatibility with certain data structures, we can override the <strong class="source-inline">equals</strong> and <strong class="source-inline">hashCode</strong> methods in our custom immutable classes. When we do this, we must ensure we consider all attributes that can contribute <span class="No-Break">to equality.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>String classes</h2>
			<p>As you likely know, strings are a<a id="_idIndexMarker307"/> commonly used data type and they are, by their very nature, immutable. Let’s look at how strings work as immutable objects so that we can better understand how to design <span class="No-Break">immutable objects.</span></p>
			<p>Strings are indeed immutable and even when we think we are modifying them, Java is creating a new object. As an example, consider the following lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
String original = "Java";
String modified = original.concat(", is the name of my Corgi");</pre>			<p>As you can see, when we call the <strong class="source-inline">concat</strong> method on the first string, a new string object <span class="No-Break">is created.</span></p>
			<p>String immutability provides us with several advantages, such as thread safety, predictable behavior, and efficiency with string manipulations. Under the hood, Java maintains a string pool, also referred to as an intern pool, to store unique string literals. This is another advantage of<a id="_idIndexMarker308"/> string immutability. Let’s look at this <span class="No-Break">in code:</span></p>
			<pre class="source-code">
String s1 = "Java"; // Stored in the string pool
String s2 = "Java"; // Reuses the same string from the pool</pre>			<p>A fifth advantage of string immutability is security. This means we can confidently use strings for sensitive data, such as banking information, passwords, and cryptographic keys, because unintentional modification <span class="No-Break">is prevented.</span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Garbage collection</h1>
			<p>We have already established that memory management is important when our goal is to have our Java applications perform at <a id="_idIndexMarker309"/>a high level. We also looked at how garbage completion works and what its <span class="No-Break">benefits are.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Garbage collection implications</h2>
			<p>The automatic nature of Java’s garbage collection <a id="_idIndexMarker310"/>results in many developers ignoring it. They take garbage collection for granted and do not implement any best practices. This is okay for small projects that are not data- or memory-intensive. Let’s look at two ways that garbage collection can impact our applications and <span class="No-Break">memory management:</span></p>
			<ul>
				<li><strong class="bold">Application pauses</strong>: Frequent garbage collection cycles can result in our application pausing. The type of garbage collection and heap size are key determiners for the length of <span class="No-Break">these pauses.</span></li>
				<li><strong class="bold">Memory overhead</strong>: Garbage collection increases memory overhead. CPU cycles and memory resources are impacted each time garbage <span class="No-Break">collection runs.</span></li>
			</ul>
			<p>There are several approaches we can take to help mitigate the impact garbage collection has on <span class="No-Break">our applications:</span></p>
			<ul>
				<li>Take a purposeful approach to managing the life cycle of <span class="No-Break">our objects</span></li>
				<li>Avoid unnecessary <span class="No-Break">object creation</span></li>
				<li><span class="No-Break">Reuse objects</span></li>
				<li>Implement <span class="No-Break">object pooling</span></li>
				<li>Use <span class="No-Break">immutable objects</span></li>
			</ul>
			<p>In the next section, we <a id="_idIndexMarker311"/>will look at how object cloning relates to <span class="No-Break">garbage collection.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Object cloning</h2>
			<p>As you might assume, <strong class="bold">object cloning</strong> is when we create a new object that is a duplicate of an existing <a id="_idIndexMarker312"/>one. Its relevance to garbage collection is due to its potential impact on how objects are managed and disposed of. The type of impact is influenced by the type of cloning used. Let’s look at two types of cloning: shallow <span class="No-Break">and deep.</span></p>
			<h3>Shallow cloning</h3>
			<p>The process of <strong class="bold">shallow cloning</strong> involves creating a new object by copying the contents of the original object. It’s important to note that if the original object contains any references to other objects, the <a id="_idIndexMarker313"/>clone will point to the same objects. This is an <a id="_idIndexMarker314"/>expected behavior; we are cloning all the objects so that they include references, but not the referenced objects. Let’s look at a brief example <span class="No-Break">in code:</span></p>
			<pre class="source-code">
class Corgi implements Cloneable {
    private String name;
    private String authenticityCertificate;
    // Constructor and getters ...
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</pre>			<p>As you can see, when we clone a <strong class="source-inline">Corgi</strong> object, the new Corgi will share the same <strong class="source-inline">authenticityCertificate</strong> as the original. If that field is mutable, then changes that are made to it through one <a id="_idIndexMarker315"/>reference will take effect in both the <a id="_idIndexMarker316"/>original and cloned <span class="No-Break">Corgi objects.</span></p>
			<h3>Deep cloning</h3>
			<p>When we create a <strong class="bold">deep clone</strong>, we still<a id="_idIndexMarker317"/> create a new object, but it also recursively copies all objects that are <a id="_idIndexMarker318"/>referenced by the original object. This method of cloning ensures that the new object and its sub-objects are independent of the original object. Let’s look at this <span class="No-Break">in code:</span></p>
			<pre class="source-code">
class Corgi implements Cloneable {
  private String name;
  private Address address;
  // Constructor and getters...
  @Override
  public Object clone() throws CloneNotSupportedException{
    Corgi clonedCorgi = (Corgi) super.clone();
    clonedCorgi.address = (Address) address.clone(); // Deep copy of the Address object
    return clonedCorgi;
  }
}</pre>			<p>As you can see, when we clone a <strong class="source-inline">Corgi</strong> object, it is a new <strong class="source-inline">Corgi</strong> object and a new <strong class="source-inline">Address</strong> object is created. With this method, we can make changes to one object without impacting <span class="No-Break">the other.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Design patterns</h1>
			<p>Design patterns are time-tested solutions to common software problems. They can be considered a set of best practices<a id="_idIndexMarker319"/> and are widely used for Java development. Concerning strategic object creation and immutability, two design patterns deserve <span class="No-Break">our attention:</span></p>
			<ul>
				<li><span class="No-Break">Singleton pattern</span></li>
				<li><span class="No-Break">Factory pattern</span></li>
			</ul>
			<p class="callout-heading">What a design pattern is not</p>
			<p class="callout">Design patterns are structured approaches to solving known problems. They are not algorithms, templates, libraries, or even code snippets. Instead, they offer high-level guidance that we <span class="No-Break">can follow.</span></p>
			<p>Let’s look at each of these patterns so that we understand how their use can help improve the performance of our <span class="No-Break">Java applications.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Singleton pattern</h2>
			<p>The <strong class="bold">singleton design pattern</strong> ensures that there is only one instance of a class and then provides global access to that <a id="_idIndexMarker320"/>instance. This pattern is often used when <a id="_idIndexMarker321"/>an application is managing database connections, resource management, logging, caching, or <span class="No-Break">configuration settings.</span></p>
			<p>Let’s look at a simple implementation approach for <span class="No-Break">this pattern:</span></p>
			<pre class="source-code">
public class Singleton {
    private static Singleton instance;
    private Singleton() {
        // Private constructor to prevent instantiation
    }
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</pre>			<p>The preceding code<a id="_idIndexMarker322"/> is a standard example. As you can see, this class prohibits more than one instance from being created. Additionally, the <strong class="source-inline">getInstance()</strong> method is <a id="_idIndexMarker323"/>how we provide global access to the instance of the <span class="No-Break"><strong class="source-inline">Singleton</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Factory pattern</h2>
			<p>The <strong class="bold">factory design pattern</strong> involves a superclass and an interface for creating objects in it. This pattern permits subclasses to alter <a id="_idIndexMarker324"/>what can be created. It promotes loose coupling between the superclass and<a id="_idIndexMarker325"/> the subclasses being created. The most common components of this pattern are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Abstract factory</strong>: This is an interface that declares the method that’s used to <span class="No-Break">create objects.</span></li>
				<li><strong class="bold">Concrete factory</strong>: This is a class that implements the abstract factory interface. It creates <span class="No-Break">concrete objects.</span></li>
				<li><strong class="bold">Product</strong>: This is the object that’s created by <span class="No-Break">the factory.</span></li>
				<li><strong class="bold">Concrete product</strong>: This is the class that implements the <span class="No-Break">product interface.</span></li>
			</ul>
			<p>The advantages of using this pattern include separation of concerns, code reusability, flexibility, and encapsulation. Next, we will look at several code snippets that illustrate simple <span class="No-Break">implementation examples.</span></p>
			<p>First, here is an example of an <span class="No-Break">abstract product:</span></p>
			<pre class="source-code">
interface Product {
    void create();
}</pre>			<p>Now, let’s look at an example of <span class="No-Break">concrete products:</span></p>
			<pre class="source-code">
class ConcreteProductA implements Product {
    @Override
    public void create() {
        System.out.println("Creating Concrete Product A");
    }
}
class ConcreteProductB implements Product {
    @Override
    public void create() {
        System.out.println("Creating Concrete Product B");
    }
}</pre>			<p>The following code snippet<a id="_idIndexMarker326"/> illustrates how to implement an <span class="No-Break">abstract</span><span class="No-Break"><a id="_idIndexMarker327"/></span><span class="No-Break"> factory:</span></p>
			<pre class="source-code">
interface Factory {
    Product createProduct();
}</pre>			<p>Lastly, the following code demonstrates how to implement <span class="No-Break">concrete factories:</span></p>
			<pre class="source-code">
class ConcreteFactoryA implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductA();
    }
}
 class ConcreteFactoryB implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductB();
    }
}</pre>			<p>The factory pattern <a id="_idIndexMarker328"/>can be a valuable tool when you need flexibility<a id="_idIndexMarker329"/> when it comes to creating objects based on specific requirements <span class="No-Break">or conditions.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Summary</h1>
			<p>This chapter focused on strategic object creation and immutability, two closely related and equally important topics. We looked at various aspects of these topics to help improve the performance of our Java applications. Specifically, we looked at minimizing object creation, object immutability, garbage collection, and design patterns. You should now have a better understanding and deep appreciation for the importance of strategic object creation, as well as its best practices and implementation strategies. You should also have a firm grasp of the concept of <span class="No-Break">object immutability.</span></p>
			<p>In the next chapter, <em class="italic">String Objects</em>, we will take a deeper look into string objects while covering topics such as proper string pooling, lazy initialization, and string <span class="No-Break">operation strategies.</span></p>
		</div>
	</body></html>