<html><head></head><body>
		<div id="_idContainer100">
			<h1 id="_idParaDest-246"><em class="italic"><a id="_idTextAnchor245"/>Chapter 13</em>: Exploiting SQL Functions</h1>
			<p>From mathematical and statistical computations to string and date-time manipulations, respectively, to different types of aggregations, rankings, and groupings, SQL built-in functions are quite handy in many scenarios. There are different categories of functions depending on their goal and usage and, as you'll see, jOOQ has accorded major attention to their support. Based on these categories, our agenda for this chapter follows these points:</p>
			<ul>
				<li>Regular functions</li>
				<li>Aggregate functions</li>
				<li>Window functions</li>
				<li>Aggregates as window functions</li>
				<li>Aggregate functions and <strong class="source-inline">ORDER BY</strong></li>
				<li>Ordered set aggregate functions (<strong class="source-inline">WITHIN GROUP</strong>)</li>
				<li>Grouping, filtering, distinctness, and functions</li>
				<li>Grouping sets</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13</a>.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor247"/>Regular functions</h1>
			<p>Being a SQL user, you've<a id="_idIndexMarker1254"/> probably worked with a lot of regular or common SQL functions such as functions for dealing with <strong class="source-inline">NULL</strong> values, numeric functions, string functions, date-time functions, and so on. While the jOOQ manual represents a comprehensive source of information structured as a nomenclature of all the supported SQL built-in functions, we are trying to complete a series of examples designed to get you familiar with the jOOQ syntax in different scenarios. Let's start by talking about SQL functions for dealing with <strong class="source-inline">NULL</strong> values.</p>
			<p>Just in case you need a quick overview about some simple and common <strong class="source-inline">NULL</strong> stuff, then quickly check out the <strong class="source-inline">someNullsStuffGoodToKnow()</strong> method available in the bundled code.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor248"/>SQL functions for dealing with NULLs</h2>
			<p>SQL provides several functions for handling <strong class="source-inline">NULL</strong> values in our queries. Next, let's cover <strong class="source-inline">COALESCE()</strong>, <strong class="source-inline">DECODE()</strong>, <strong class="source-inline">IIF()</strong>, <strong class="source-inline">NULLIF()</strong>, <strong class="source-inline">NVL()</strong>, and <strong class="source-inline">NVL2()</strong> functions. Let's start with <strong class="source-inline">COALESCE()</strong>.</p>
			<h3>COALESCE()</h3>
			<p>One of the most<a id="_idIndexMarker1255"/> popular functions for dealing with <strong class="source-inline">NULL</strong> values is <strong class="source-inline">COALESCE()</strong>. This function returns the first non-null value from its list of <em class="italic">n</em> arguments. </p>
			<p>For instance, let's assume that for each <strong class="source-inline">DEPARTMENT</strong>, we want to compute a deduction of 25% from <strong class="source-inline">CASH</strong>, <strong class="source-inline">ACCOUNTS_RECEIVABLE</strong>, or <strong class="source-inline">INVENTORIES</strong>, and a deduction of 25% from <strong class="source-inline">ACCRUED_LIABILITIES</strong>, <strong class="source-inline">ACCOUNTS_PAYABLE</strong>, or <strong class="source-inline">ST_BORROWING</strong>. Since this order is strict, if one of these is a <strong class="source-inline">NULL</strong> value, we go for the next one, and so on. If all are <strong class="source-inline">NULL</strong>, then we replace <strong class="source-inline">NULL</strong> with 0. Relying on the jOOQ <strong class="source-inline">coalesce()</strong> method, we can write the query as follows:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.NAME, DEPARTMENT.OFFICE_CODE,</pre>
			<pre class="source-code">      DEPARTMENT.CASH, ..., </pre>
			<pre class="source-code">     round(coalesce(DEPARTMENT.CASH,   </pre>
			<pre class="source-code">      DEPARTMENT.ACCOUNTS_RECEIVABLE, </pre>
			<pre class="source-code">          DEPARTMENT.INVENTORIES,inline(0)).mul(0.25), </pre>
			<pre class="source-code">              2).as("income_deduction"),</pre>
			<pre class="source-code">     round(coalesce(DEPARTMENT.ACCRUED_LIABILITIES, </pre>
			<pre class="source-code">      DEPARTMENT.ACCOUNTS_PAYABLE, DEPARTMENT.ST_BORROWING, </pre>
			<pre class="source-code">       inline(0)).mul(0.25), 2).as("expenses_deduction"))</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetch();</pre>
			<p>Notice the explicit usage of <strong class="source-inline">inline()</strong> for inlining the integer 0. As long as you know that this integer is a constant, there is no need to rely on <strong class="source-inline">val()</strong> for rendering a bind variable (placeholder). Using <strong class="source-inline">inline()</strong> fits pretty well for SQL functions, which typically rely on constant arguments or mathematical formulas having constant terms that can be easily inlined. If you need a quick reminder of <strong class="source-inline">inline()</strong> versus <strong class="source-inline">val()</strong>, then consider a quick revisit of <a href="B16833_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">jOOQ Core Concepts</em>.</p>
			<p>Besides <strong class="source-inline">coalesce(Field&lt;T&gt; field, Field&lt;?&gt;... fields)</strong> used here, jOOQ provides two other flavors: <strong class="source-inline">coalesce(Field&lt;T&gt; field, T value)</strong> and <strong class="source-inline">coalesce(T value, T... values)</strong>. </p>
			<p>Here is another example that relies on the <strong class="source-inline">coalesce()</strong> method to fill the gaps in the <strong class="source-inline">DEPARTMENT.FORECAST_PROFIT</strong> column. Each <strong class="source-inline">FORECAST_PROFIT</strong> value that is <strong class="source-inline">NULL</strong> is filled by the <a id="_idIndexMarker1256"/>following query:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.NAME, DEPARTMENT.OFFICE_CODE, …  </pre>
			<pre class="source-code"> coalesce(DEPARTMENT.FORECAST_PROFIT,</pre>
			<pre class="source-code">     select(</pre>
			<pre class="source-code">       avg(field(name("t", "forecast_profit"), Double.class)))</pre>
			<pre class="source-code">      .from(DEPARTMENT.as("t"))</pre>
			<pre class="source-code">      .where(coalesce(field(name("t", "profit")), 0)</pre>
			<pre class="source-code">      .gt(coalesce(DEPARTMENT.PROFIT, 0))</pre>
			<pre class="source-code">       .and(field(name("t", "forecast_profit")).isNotNull())))</pre>
			<pre class="source-code">        .as("fill_forecast_profit"))</pre>
			<pre class="source-code">   .from(DEPARTMENT)</pre>
			<pre class="source-code">   .orderBy(DEPARTMENT.DEPARTMENT_ID).fetch();</pre>
			<p>So, for each row <a id="_idIndexMarker1257"/>having <strong class="source-inline">FORECAST_PROFIT</strong> equal to <strong class="source-inline">NULL</strong>, we use a custom interpolation formula represented by the average of all the non-null <strong class="source-inline">FORECAST_PROFIT</strong> values where the profit (<strong class="source-inline">PROFIT</strong>) is greater than the profit of the current row. </p>
			<p>Next, let's talk about <strong class="source-inline">DECODE()</strong>.</p>
			<h3>DECODE()</h3>
			<p>In some <a id="_idIndexMarker1258"/>dialects (for instance, in Oracle), we have the <strong class="source-inline">DECODE()</strong> function that acts as an if-then-else logic in queries. Having <strong class="source-inline">DECODE(x, a, r</strong><span class="subscript">1</span><strong class="source-inline">, r</strong><span class="subscript">2</span><strong class="source-inline">)</strong> is equivalent to the following:</p>
			<pre class="source-code">IF x = a THEN</pre>
			<pre class="source-code">    RETURN r<span class="subscript">1</span>;</pre>
			<pre class="source-code">ELSE</pre>
			<pre class="source-code">    RETURN r<span class="subscript">2</span>;</pre>
			<pre class="source-code">END IF;</pre>
			<p>Or, since <strong class="source-inline">DECODE</strong> makes <strong class="source-inline">NULL</strong> safe comparisons, it's more like <strong class="source-inline">IF x IS NOT DISTINCT FROM a THEN …</strong>.</p>
			<p>Let's attempt to compute a financial index as ((<strong class="source-inline">DEPARTMENT.LOCAL_BUDGET</strong> * 0.25) * 2) / 100. Since <strong class="source-inline">DEPARTMENT.LOCAL_BUDGET</strong> can be <strong class="source-inline">NULL</strong>, we prefer to replace such occurrences with 0. Relying on the jOOQ <strong class="source-inline">decode()</strong> method, we have the following:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.NAME, DEPARTMENT.OFFICE_CODE, </pre>
			<pre class="source-code">   DEPARTMENT.LOCAL_BUDGET, decode(DEPARTMENT.LOCAL_BUDGET,</pre>
			<pre class="source-code">   castNull(Double.class), 0, DEPARTMENT.LOCAL_BUDGET.mul(0.25))</pre>
			<pre class="source-code">  .mul(2).divide(100).as("financial_index"))</pre>
			<pre class="source-code">  .from(DEPARTMENT)</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>The <strong class="source-inline">DECODE()</strong> part can be perceived like this:</p>
			<pre class="source-code">IF DEPARTMENT.LOCAL_BUDGET = NULL THEN</pre>
			<pre class="source-code">    RETURN 0;</pre>
			<pre class="source-code">ELSE</pre>
			<pre class="source-code">    RETURN DEPARTMENT.LOCAL_BUDGET * 0.25;</pre>
			<pre class="source-code">END IF;</pre>
			<p>But don't conclude from here that <strong class="source-inline">DECODE()</strong> accepts only this simple logic. Actually, the <strong class="source-inline">DECODE()</strong> syntax<a id="_idIndexMarker1259"/> is more complex and looks like this:</p>
			<pre class="source-code">DECODE (x, a<span class="subscript">1</span>, r<span class="subscript">1</span>[, a<span class="subscript">2</span>, r<span class="subscript">2</span>], ...,[, a<span class="subscript">n</span>, r<span class="subscript">n</span>] [, d]);</pre>
			<p>In this syntax, the following applies:</p>
			<ul>
				<li><strong class="source-inline">x</strong> is compared with the other argument, <strong class="source-inline">a</strong><span class="subscript">1</span><strong class="source-inline">, a</strong><span class="subscript">2</span><strong class="source-inline">, …, a</strong><span class="subscript">n</span>.</li>
				<li><strong class="source-inline">a</strong><span class="subscript">1</span><strong class="source-inline">, a</strong><span class="subscript">2</span><strong class="source-inline">, …,</strong> or <strong class="source-inline">a</strong><span class="subscript">n</span> is sequentially compared with the first argument; if any comparison <strong class="source-inline">x = a</strong><span class="subscript">1</span><strong class="source-inline">, x = a</strong><span class="subscript">2</span><strong class="source-inline">, …, x = a</strong><span class="subscript">n</span> returns <strong class="source-inline">true</strong>, then the <strong class="source-inline">DECODE()</strong> function terminates by returning the result.</li>
				<li><strong class="source-inline">r</strong><span class="subscript">1</span><strong class="source-inline">, r</strong><span class="subscript">2</span><strong class="source-inline">, …,</strong> or <strong class="source-inline">r</strong><span class="subscript">n</span> is the result corresponding to <strong class="source-inline">x</strong><span class="subscript">i</span><strong class="source-inline"> = a</strong><span class="subscript">i</span><strong class="source-inline">, i = (1…n)</strong>.</li>
				<li><strong class="source-inline">d</strong> is an expression that should be returned if no match for <strong class="source-inline">x</strong><span class="subscript">i</span><strong class="source-inline">=a</strong><span class="subscript">i</span><strong class="source-inline">, i = (1…n)</strong> was found.</li>
			</ul>
			<p>Since jOOQ emulates <strong class="source-inline">DECODE()</strong> using <strong class="source-inline">CASE</strong> expressions, you can safely use it in all dialects supported by jOOQ, so let's see another example here:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.NAME, DEPARTMENT.OFFICE_CODE,…, </pre>
			<pre class="source-code">    decode(DEPARTMENT.NAME,</pre>
			<pre class="source-code">           "Advertising", "Publicity and promotion",</pre>
			<pre class="source-code">           "Accounting", "Monetary and business",</pre>
			<pre class="source-code">           "Logistics", "Facilities and supplies",</pre>
			<pre class="source-code">           DEPARTMENT.NAME).concat("department")</pre>
			<pre class="source-code">              .as("description"))</pre>
			<pre class="source-code">   .from(DEPARTMENT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>So, in this case, if the department name is <em class="italic">Advertising</em>, <em class="italic">Accounting</em>, or <em class="italic">Logistics</em>, then it is replaced with a meaningful description; otherwise, we simply return the current name.</p>
			<p>Moreover, <strong class="source-inline">DECODE()</strong> can be used with <strong class="source-inline">ORDER BY</strong>, <strong class="source-inline">GROUP BY</strong>, or next to aggregate functions as well. While more <a id="_idIndexMarker1260"/>examples can be seen in the bundled code, here is another one of using <strong class="source-inline">DECODE()</strong> with <strong class="source-inline">GROUP BY</strong> for counting <strong class="source-inline">BUY_PRICE</strong> larger/equal/smaller than half of <strong class="source-inline">MSRP</strong>:</p>
			<pre class="source-code">ctx.select(field(name("t", "d")), count())</pre>
			<pre class="source-code">   .from(select(decode(sign(</pre>
			<pre class="source-code">     PRODUCT.BUY_PRICE.minus(PRODUCT.MSRP.divide(2))),</pre>
			<pre class="source-code">       1, "Buy price larger than half of MSRP",</pre>
			<pre class="source-code">       0, "Buy price equal to half of MSRP",</pre>
			<pre class="source-code">      -1, "Buy price smaller than half of MSRP").as("d"))</pre>
			<pre class="source-code">       .from(PRODUCT)</pre>
			<pre class="source-code">       .groupBy(PRODUCT.BUY_PRICE, PRODUCT.MSRP).asTable("t"))</pre>
			<pre class="source-code">   .groupBy(field(name("t", "d")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>And here is another example of using imbricated <strong class="source-inline">DECODE()</strong>:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.NAME, DEPARTMENT.OFFICE_CODE,</pre>
			<pre class="source-code">     DEPARTMENT.LOCAL_BUDGET, DEPARTMENT.PROFIT,</pre>
			<pre class="source-code">     decode(DEPARTMENT.LOCAL_BUDGET, </pre>
			<pre class="source-code">     castNull(Double.class), DEPARTMENT.PROFIT,</pre>
			<pre class="source-code">      decode(sign(DEPARTMENT.PROFIT.minus(</pre>
			<pre class="source-code">       DEPARTMENT.LOCAL_BUDGET)), </pre>
			<pre class="source-code">        1, DEPARTMENT.PROFIT.minus(DEPARTMENT.LOCAL_BUDGET),</pre>
			<pre class="source-code">        0, DEPARTMENT.LOCAL_BUDGET.divide(2).mul(-1),</pre>
			<pre class="source-code">       -1, DEPARTMENT.LOCAL_BUDGET.mul(-1)))</pre>
			<pre class="source-code">           .as("profit_balance"))</pre>
			<pre class="source-code">   .from(DEPARTMENT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>For given <strong class="source-inline">sign(a, b)</strong>, it returns 1 if <strong class="source-inline">a</strong> &gt; <strong class="source-inline">b</strong>, 0 if <strong class="source-inline">a</strong> = <strong class="source-inline">b</strong>, and -1 if <strong class="source-inline">a</strong> &lt; <strong class="source-inline">b</strong>. So, this code can be easily interpreted <a id="_idIndexMarker1261"/>based on the following output:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B16833_Figure_13.1.jpg" alt="Figure 13.1 – Output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Output</p>
			<p>More examples are available in the <em class="italic">Functions</em> bundled code. </p>
			<h3>IIF()</h3>
			<p>The <strong class="source-inline">IIF()</strong> function <a id="_idIndexMarker1262"/>implements the if-then-else logic via three arguments, as follows (this acts as the <strong class="source-inline">NVL2()</strong> function presented later):</p>
			<pre class="source-code">IIF(boolean_expr, value_for_true_case, value_for_false_case)</pre>
			<p>It evaluates the first argument (<strong class="source-inline">boolean_expr</strong>) and returns the second argument (<strong class="source-inline">value_for_true_case</strong>) and third one (<strong class="source-inline">value_for_false_case</strong>), respectively.</p>
			<p>For instance, the following usage of the jOOQ <strong class="source-inline">iif()</strong> function evaluates the <strong class="source-inline">DEPARTMENT.LOCAL_BUDGET.isNull()</strong> expression and outputs the text <em class="italic">NO BUDGET</em> or <em class="italic">HAS BUDGET</em>:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.DEPARTMENT_ID, DEPARTMENT.NAME,</pre>
			<pre class="source-code">      iif(DEPARTMENT.LOCAL_BUDGET.isNull(), </pre>
			<pre class="source-code">        "NO BUDGET", "HAS BUDGET").as("budget"))</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetch();</pre>
			<p>More examples, including <a id="_idIndexMarker1263"/>imbricated <strong class="source-inline">IIF()</strong> usage, are available in the bundled code. </p>
			<h3>NULLIF()</h3>
			<p>The <strong class="source-inline">NULLIF(expr1, expr2)</strong> function<a id="_idIndexMarker1264"/> returns <strong class="source-inline">NULL</strong> if the arguments are equal. Otherwise, it returns the first argument (<strong class="source-inline">expr1</strong>). </p>
			<p>For instance, in legacy databases, it is a common practice to have a mixture of <strong class="source-inline">NULL</strong> and empty strings for missing values. We have intentionally created such a case in the <strong class="source-inline">OFFICE</strong> table for <strong class="source-inline">OFFICE.COUNTRY</strong>.</p>
			<p>Since empty strings are not <strong class="source-inline">NULL</strong> values, using <strong class="source-inline">ISNULL()</strong> will not return them even if, for us, <strong class="source-inline">NULL</strong> values and empty strings may have the same mining. Using the jOOQ <strong class="source-inline">nullif()</strong> method is a handy approach for finding all missing data (<strong class="source-inline">NULL</strong> values and empty strings), as follows:</p>
			<pre class="source-code">ctx.select(OFFICE.OFFICE_CODE, nullif(OFFICE.COUNTRY, ""))</pre>
			<pre class="source-code">    .from(OFFICE).fetch();</pre>
			<pre class="source-code">       </pre>
			<pre class="source-code">ctx.selectFrom(OFFICE)</pre>
			<pre class="source-code">    .where(nullif(OFFICE.COUNTRY, "").isNull()).fetch();</pre>
			<p>These examples are available in the <em class="italic">Functions</em> bundled code.</p>
			<h3>IFNULL() and ISNULL()</h3>
			<p>The <strong class="source-inline">IFNULL(expr1, expr2)</strong> and <strong class="source-inline">ISNULL(expr1, expr2)</strong> functions take two arguments<a id="_idIndexMarker1265"/> and return the first one if it is not <strong class="source-inline">NULL</strong>. Otherwise, they return the second argument. The former is similar to Oracle's <strong class="source-inline">NVL()</strong> function presented later, while the latter is specific to SQL Server. Both of them are emulated by jOOQ via <strong class="source-inline">CASE</strong> expressions for all dialects that don't support them natively.</p>
			<p>For instance, the following snippet of code produces 0 for each <strong class="source-inline">NULL</strong> value of <strong class="source-inline">DEPARTMENT.LOCAL_BUDGET</strong> via both<a id="_idIndexMarker1266"/> jOOQ methods, <strong class="source-inline">ifnull()</strong> and <strong class="source-inline">isnull()</strong>:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.DEPARTMENT_ID, DEPARTMENT.NAME,</pre>
			<pre class="source-code">      ifnull(DEPARTMENT.LOCAL_BUDGET, 0).as("budget_if"),</pre>
			<pre class="source-code">      isnull(DEPARTMENT.LOCAL_BUDGET, 0).as("budget_is"))</pre>
			<pre class="source-code">   .from(DEPARTMENT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here is another example that fetches the customer's postal code or address:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code">     ifnull(CUSTOMERDETAIL.POSTAL_CODE,  </pre>
			<pre class="source-code">       CUSTOMERDETAIL.ADDRESS_LINE_FIRST).as("address_if"),</pre>
			<pre class="source-code">     isnull(CUSTOMERDETAIL.POSTAL_CODE, </pre>
			<pre class="source-code">       CUSTOMERDETAIL.ADDRESS_LINE_FIRST).as("address_is"))</pre>
			<pre class="source-code">  .from(CUSTOMERDETAIL).fetch();</pre>
			<p>More examples are available in the <em class="italic">Functions</em> bundled code.</p>
			<h3>NVL() and NVL2()</h3>
			<p>Some <a id="_idIndexMarker1267"/>dialects (for example, Oracle) support two functions <a id="_idIndexMarker1268"/>named <strong class="source-inline">NVL()</strong> and <strong class="source-inline">NVL2()</strong>. Both of them are emulated by jOOQ for all dialects that don't support them natively. The former acts like <strong class="source-inline">IFNULL()</strong>, while the latter acts like <strong class="source-inline">IIF()</strong>. So, <strong class="source-inline">NVL(expr1, expr2)</strong> produces the first argument if it is not <strong class="source-inline">NULL</strong>; otherwise, it produces the second argument.</p>
			<p>For instance, let's use the jOOQ <strong class="source-inline">nvl()</strong> method for applying the variance formula used in finance to calculate the difference between a forecast and an actual result for <strong class="source-inline">DEPARTMENT.FORECAST_PROFIT</strong> and <strong class="source-inline">DEPARTMENT.PROFIT</strong> as ((<strong class="source-inline">ACTUAL PROFIT</strong> ÷ <strong class="source-inline">FORECAST PROFIT</strong>) - 1) * 100, as follows:</p>
			<pre class="source-code">ctx.select(DEPARTMENT.NAME, ...,                </pre>
			<pre class="source-code">       round((nvl(DEPARTMENT.PROFIT, 0d).divide(</pre>
			<pre class="source-code">       nvl(DEPARTMENT.FORECAST_PROFIT, 10000d)))</pre>
			<pre class="source-code">       .minus(1d).mul(100), 2).concat("%").as("nvl"))</pre>
			<pre class="source-code">   .from(DEPARTMENT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>If <strong class="source-inline">PROFIT</strong> is <strong class="source-inline">NULL</strong>, then we replace it with 0, and if <strong class="source-inline">FORECAST_PROFIT</strong> is <strong class="source-inline">NULL</strong>, then we replace it with a default profit <a id="_idIndexMarker1269"/>of 10,000. Challenge yourself to write this<a id="_idIndexMarker1270"/> query via <strong class="source-inline">ISNULL()</strong> as well.</p>
			<p>On the other hand, <strong class="source-inline">NVL2(expr1, expr2, expr3)</strong> evaluates the first argument (<strong class="source-inline">expr1</strong>). If <strong class="source-inline">expr1</strong> is not <strong class="source-inline">NULL</strong>, then it returns the second argument (<strong class="source-inline">expr2</strong>); otherwise, it returns the third argument (<strong class="source-inline">expr3</strong>).</p>
			<p>For instance, each <strong class="source-inline">EMPLOYEE</strong> has a salary and an optional <strong class="source-inline">COMMISSION</strong> (a missing commission is <strong class="source-inline">NULL</strong>). Let's fetch salary + commission via jOOQ <strong class="source-inline">nvl2()</strong> and <strong class="source-inline">iif()</strong>, as follows:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME,</pre>
			<pre class="source-code"> iif(EMPLOYEE.COMMISSION.isNull(),EMPLOYEE.SALARY,  </pre>
			<pre class="source-code">  EMPLOYEE.SALARY.plus(EMPLOYEE.COMMISSION))</pre>
			<pre class="source-code">    .as("iif1"),</pre>
			<pre class="source-code"> iif(EMPLOYEE.COMMISSION.isNotNull(),</pre>
			<pre class="source-code">  EMPLOYEE.SALARY.plus(EMPLOYEE.COMMISSION), EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .as("iif2"),</pre>
			<pre class="source-code"> nvl2(EMPLOYEE.COMMISSION,</pre>
			<pre class="source-code">  EMPLOYEE.SALARY.plus(EMPLOYEE.COMMISSION), EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .as("nvl2"))</pre>
			<pre class="source-code"> .from(EMPLOYEE)</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>All three columns—<strong class="source-inline">iif1</strong>, <strong class="source-inline">iif2</strong>, and <strong class="source-inline">nvl2</strong>—should contain the same data. Regrettably, <strong class="source-inline">NVL</strong> can perform better than <strong class="source-inline">COALESCE</strong> in some Oracle cases. For more details, consider<a id="_idIndexMarker1271"/> reading this<a id="_idIndexMarker1272"/> article: <a href="https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/">https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/</a>. You can check out all the examples from this section in the <em class="italic">Functions</em> bundled code. Next, let's talk about numeric functions.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor249"/>Numeric functions</h2>
			<p>jOOQ <a id="_idIndexMarker1273"/>supports a comprehensive list of numeric functions, including <strong class="source-inline">ABS()</strong>, <strong class="source-inline">SIN()</strong>, <strong class="source-inline">COS()</strong>, <strong class="source-inline">EXP()</strong>, <strong class="source-inline">FLOOR()</strong>, <strong class="source-inline">GREATEST()</strong>, <strong class="source-inline">LEAST()</strong>, <strong class="source-inline">LN()</strong>, <strong class="source-inline">POWER()</strong>, <strong class="source-inline">SIGN()</strong>, <strong class="source-inline">SQRT()</strong>, and much more. Mainly, jOOQ exposes a set of methods that mirrors the names of these SQL functions and supports the proper number and type of arguments.</p>
			<p>Since you can find all these functions listed and exemplified in the jOOQ manual, let's try here two examples of combining several of them to accomplish a common goal. For instance, a famous formula for computing the Fibonacci number is the Binet formula (notice that no recursion is required!):</p>
			<pre class="source-code">Fib(n) = (1.6180339^n – (–0.6180339)^n) / 2.236067977</pre>
			<p>Writing this formula in jOOQ/SQL requires us to use the <strong class="source-inline">power()</strong> numeric function as follows (<strong class="source-inline">n</strong> is the number to compute):</p>
			<pre class="source-code">ctx.fetchValue(round((power(1.6180339, n).minus(</pre>
			<pre class="source-code">      power(-0.6180339, n))).divide(2.236067977), 0));</pre>
			<p>How about computing the distance between two points expressed as <strong class="source-inline">(latitude1, longitude1)</strong>, respectively <strong class="source-inline">(latitude2, longitude2)</strong>? Of course, exactly as in the case of the Fibonacci number, such computations are commonly done outside the database (directly in Java) or in a UDF or stored procedure, but trying to solve them in a <strong class="source-inline">SELECT</strong> statement is a good opportunity to quickly practice some numeric functions and get familiar with jOOQ syntax. So, here we go with the required math:</p>
			<pre class="source-code">a = POWER(SIN((latitude2 − latitude1) / 2.0)), 2)</pre>
			<pre class="source-code">  + COS(latitude1) * COS(latitude2) </pre>
			<pre class="source-code">      * POWER (SIN((longitude2 − longitude1) / 2.0), 2);</pre>
			<pre class="source-code">result = (6371.0 * (2.0 * ATN2(SQRT(a),SQRT(1.0 − a))));</pre>
			<p>This time, we<a id="_idIndexMarker1274"/> need the jOOQ <strong class="source-inline">power()</strong>, <strong class="source-inline">sin()</strong>, <strong class="source-inline">cos()</strong>, <strong class="source-inline">atn2()</strong>, and <strong class="source-inline">sqrt()</strong> numeric methods, as shown here:</p>
			<pre class="source-code">double pi180 = Math.PI / 180;</pre>
			<pre class="source-code">Field&lt;BigDecimal&gt; a = (power(sin(val((latitude2 - latitude1) </pre>
			<pre class="source-code"> * pi180).divide(2d)), 2d).plus(cos(latitude1 * pi180)</pre>
			<pre class="source-code">   .mul(cos(latitude2 * pi180)).mul(power(sin(val((</pre>
			<pre class="source-code">     longitude2 - longitude1) * pi180).divide(2d)), 2d))));</pre>
			<pre class="source-code">ctx.fetchValue(inline(6371d).mul(inline(2d)</pre>
			<pre class="source-code">   .mul(atan2(sqrt(a), sqrt(inline(1d).minus(a))))));</pre>
			<p>You can practice these examples in the <em class="italic">Functions</em> bundled code. </p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor250"/>String functions</h2>
			<p>Exactly as in case of SQL <a id="_idIndexMarker1275"/>numeric functions, jOOQ supports an impressive set of SQL string functions, including <strong class="source-inline">ASCII()</strong>, <strong class="source-inline">CONCAT()</strong>, <strong class="source-inline">OVERLAY()</strong>, <strong class="source-inline">LOWER()</strong>, <strong class="source-inline">UPPER()</strong>, <strong class="source-inline">LTRIM()</strong>, <strong class="source-inline">RTRIM()</strong>, and so on. You can find each of them exemplified in the jOOQ manual, so here, let's try to use several string functions to obtain an output, as in this screenshot:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B16833_Figure_13.2.jpg" alt="Figure 13.2 – Applying several SQL string functions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Applying several SQL string functions</p>
			<p>Transforming what we have in what we want can be expressed in jOOQ via several methods, including <strong class="source-inline">concat()</strong>, <strong class="source-inline">upper()</strong>, <strong class="source-inline">space()</strong>, <strong class="source-inline">substring()</strong>, <strong class="source-inline">lower()</strong>, and <strong class="source-inline">rpad()</strong>—of course, you<a id="_idIndexMarker1276"/> can optimize or write the following query in different ways:</p>
			<pre class="source-code">ctx.select(concat(upper(EMPLOYEE.FIRST_NAME), space(1),</pre>
			<pre class="source-code">         substring(EMPLOYEE.LAST_NAME, 1, 1).concat(". ("),</pre>
			<pre class="source-code">           lower(EMPLOYEE.JOB_TITLE),</pre>
			<pre class="source-code">              rpad(val(")"), 4, '.')).as("employee"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can check out this example next to several examples of splitting a string by a delimiter in the <em class="italic">Functions</em> bundled code.</p>
			<h3>Date-time functions</h3>
			<p>The last category of functions <a id="_idIndexMarker1277"/>covered in this section includes date-time functions. Mainly, jOOQ exposes a wide range of date-time functions that can be roughly categorized as functions that operate with <strong class="source-inline">java.sql.Date</strong>, <strong class="source-inline">java.sql.Time</strong>, and <strong class="source-inline">java.sql.Timestamp</strong>, and functions that operate with Java 8 date-time, <strong class="source-inline">java.time.LocalDate</strong>, <strong class="source-inline">java.time.LocalDateTime</strong>, and <strong class="source-inline">java.time.OffsetTime</strong>. jOOQ can't use the <strong class="source-inline">java.time.Duration</strong> or <strong class="source-inline">Period</strong> classes as they work differently from standard SQL intervals, though of course, converters and bindings can be applied.</p>
			<p>Moreover, jOOQ comes <a id="_idIndexMarker1278"/>with a substitute for JDBC missing <strong class="source-inline">java.sql.Interval</strong> data type, named <strong class="source-inline">org.jooq.types.Interval</strong>, having three implementations as <strong class="source-inline">DayToSecond</strong>, <strong class="source-inline">YearToMonth</strong>, and <strong class="source-inline">YearToSecond</strong>.</p>
			<p>Here are a few examples that are pretty simple and intuitive. This first example fetches the current date as <strong class="source-inline">java.sql.Date</strong> and <strong class="source-inline">java.time.LocalDate</strong>:</p>
			<pre class="source-code">Date r = ctx.fetchValue(currentDate());</pre>
			<pre class="source-code">LocalDate r = ctx.fetchValue(currentLocalDate());</pre>
			<p>This next example converts an ISO <em class="italic">8601</em> <strong class="source-inline">DATE</strong> string literal into a <strong class="source-inline">java.sql.Date</strong> data type:</p>
			<pre class="source-code">Date r = ctx.fetchValue(date("2024-01-29"));</pre>
			<p>Adding an interval of 10 days to a <strong class="source-inline">Date</strong> and a <strong class="source-inline">LocalDate</strong> can be done like this:</p>
			<pre class="source-code">var r = ctx.fetchValue(</pre>
			<pre class="source-code"> dateAdd(Date.valueOf("2022-02-03"), 10).as("after_10_days"));</pre>
			<pre class="source-code">var r = ctx.fetchValue(localDateAdd(</pre>
			<pre class="source-code"> LocalDate.parse("2022-02-03"), 10).as("after_10_days"));</pre>
			<p>Or, adding an interval of 3 months can be done like this:</p>
			<pre class="source-code">var r = ctx.fetchValue(dateAdd(Date.valueOf("2022-02-03"), </pre>
			<pre class="source-code">  new YearToMonth(0, 3)).as("after_3_month"));</pre>
			<p>Extracting the day of week (1 = Sunday, 2 = Monday, ..., 7 = Saturday) via the SQL <strong class="source-inline">EXTRACT()</strong> and <a id="_idIndexMarker1279"/>jOOQ <strong class="source-inline">dayOfWeek()</strong> functions can be done like this:</p>
			<pre class="source-code">int r = ctx.fetchValue(dayOfWeek(Date.valueOf("2021-05-06")));</pre>
			<pre class="source-code">int r = ctx.fetchValue(extract(</pre>
			<pre class="source-code">  Date.valueOf("2021-05-06"), DatePart.DAY_OF_WEEK));</pre>
			<p>You can check out more examples in the <em class="italic">Functions</em> bundled code. In the next section, let's tackle aggregate functions.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor251"/>Aggregate functions</h1>
			<p>The most<a id="_idIndexMarker1280"/> common aggregate functions (in an arbitrary order) are <strong class="source-inline">AVG()</strong>, <strong class="source-inline">COUNT()</strong>, <strong class="source-inline">MAX()</strong>, <strong class="source-inline">MIN()</strong>, and <strong class="source-inline">SUM()</strong>, including their <strong class="source-inline">DISTINCT</strong> variants. I'm pretty sure that you are very familiar with these aggregates and you've used them in many of your queries. For instance, here are two <strong class="source-inline">SELECT</strong> statements that compute the popular harmonic and geometric means for sales grouped by fiscal year. Here, we use the jOOQ <strong class="source-inline">sum()</strong> and <strong class="source-inline">avg()</strong> functions:</p>
			<pre class="source-code">// Harmonic mean: n / SUM(1/x<span class="subscript">i</span>), i=1…n</pre>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR, count().divide(</pre>
			<pre class="source-code">     sum(inline(1d).divide(SALE.SALE_))).as("harmonic_mean"))</pre>
			<pre class="source-code">   .from(SALE).groupBy(SALE.FISCAL_YEAR).fetch();</pre>
			<p>And here, we compute the geometric mean:</p>
			<pre class="source-code">// Geometric mean: EXP(AVG(LN(n)))</pre>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR, exp(avg(ln(SALE.SALE_)))</pre>
			<pre class="source-code">            .as("geometric_mean"))</pre>
			<pre class="source-code">   .from(SALE).groupBy(SALE.FISCAL_YEAR).fetch();</pre>
			<p>But as you know (or as you'll find out shortly), there are many other aggregates that have the same goal of performing some calculations across a set of rows and returning a single output row. Again, jOOQ exposes dedicated methods whose names mirror the aggregates' names or represent suggestive shortcuts.</p>
			<p>Next, let's see several <a id="_idIndexMarker1281"/>aggregate functions that are less popular and are commonly used in statistics, finance, science, and other fields. One of them is dedicated to computing Standard Deviation, (<a href="https://en.wikipedia.org/wiki/Standard_deviation">https://en.wikipedia.org/wiki/Standard_deviation</a>). In jOOQ, we have <strong class="source-inline">stddevSamp()</strong> for Sample and <strong class="source-inline">stddevPop()</strong> for Population. Here is an example of computing SSD, PSD, and emulation of PSD via population variance (introduced next) for sales grouped by fiscal year:</p>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR,</pre>
			<pre class="source-code">    stddevSamp(SALE.SALE_).as("samp"),   // SSD </pre>
			<pre class="source-code">    stddevPop(SALE.SALE_).as("pop1"),    // PSD</pre>
			<pre class="source-code">    sqrt(varPop(SALE.SALE_)).as("pop2")) // PSD emulation</pre>
			<pre class="source-code"> .from(SALE).groupBy(SALE.FISCAL_YEAR).fetch();</pre>
			<p>Both SSD and PSD are supported in MySQL, PostgreSQL, SQL Server, Oracle, and many other dialects and are useful in different kinds of problems, from finance, statistics, forecasting, and so on. For instance, in statistics, we have the standard score (or so-called z-score) that represents the number of SDs placed above or below the population mean for a certain observation and having the formula z = (x - µ) / σ (z is z-score, x is the observation, µ is the mean, and σ is the SD). You <a id="_idIndexMarker1282"/>can read further information on this here: <a href="https://en.wikipedia.org/wiki/Standard_score">https://en.wikipedia.org/wiki/Standard_score</a>.</p>
			<p>Now, considering that we store the number of sales (<strong class="source-inline">DAILY_ACTIVITY.SALES</strong>) and visitors (<strong class="source-inline">DAILY_ACTIVITY.VISITORS</strong>) in <strong class="source-inline">DAILY_ACTIVITY</strong> and we want to get some information about this data, since there is no direct comparison between sales and visitors, we have to come up with some meaningful representation, and this can be provided by z-scores. By relying<a id="_idIndexMarker1283"/> on Common Table Expressions (<strong class="bold">CTEs</strong>) and SD, we can express in jOOQ the following query (of course, in production, using a stored procedure may be a<a id="_idIndexMarker1284"/> better choice for such queries):</p>
			<pre class="source-code">ctx.with("sales_stats").as(</pre>
			<pre class="source-code">      select(avg(DAILY_ACTIVITY.SALES).as("mean"),</pre>
			<pre class="source-code">        stddevSamp(DAILY_ACTIVITY.SALES).as("sd"))</pre>
			<pre class="source-code">      .from(DAILY_ACTIVITY))</pre>
			<pre class="source-code">   .with("visitors_stats").as(</pre>
			<pre class="source-code">      select(avg(DAILY_ACTIVITY.VISITORS).as("mean"),</pre>
			<pre class="source-code">        stddevSamp(DAILY_ACTIVITY.VISITORS).as("sd"))</pre>
			<pre class="source-code">      .from(DAILY_ACTIVITY))</pre>
			<pre class="source-code">   .select(DAILY_ACTIVITY.DAY_DATE,</pre>
			<pre class="source-code">     abs(DAILY_ACTIVITY.SALES</pre>
			<pre class="source-code">     .minus(field(name("sales_stats", "mean"))))</pre>
			<pre class="source-code">     .divide(field(name("sales_stats", "sd"), Float.class))</pre>
			<pre class="source-code">     .as("z_score_sales"),</pre>
			<pre class="source-code">      abs(DAILY_ACTIVITY.VISITORS</pre>
			<pre class="source-code">     .minus(field(name("visitors_stats", "mean"))))</pre>
			<pre class="source-code">     .divide(field(name("visitors_stats", "sd"), Float.class))</pre>
			<pre class="source-code">        .as("z_score_visitors"))</pre>
			<pre class="source-code">   .from(table("sales_stats"), </pre>
			<pre class="source-code">     table("visitors_stats"), DAILY_ACTIVITY).fetch();</pre>
			<p>Among the results produced by this query, we remark the z-score of sales on <em class="italic">2004-01-06</em>, which is 2.00. In the context of z-score analysis, this output is definitely worth a deeper investigation (typically, z-scores &gt; 1.96 or &lt; -1.96 are considered outliers that should be further investigated). Of course, this is not our goal, so let's jump to another aggregate.</p>
			<p>Going further through<a id="_idIndexMarker1285"/> statistical aggregates, we have variance, which is defined as the average of the squared differences from the mean or the average squared deviations<a id="_idIndexMarker1286"/> from the mean (<a href="https://en.wikipedia.org/wiki/Variance">https://en.wikipedia.org/wiki/Variance</a>). In jOOQ, we have sample variance via <strong class="source-inline">varSamp()</strong> and population variance via <strong class="source-inline">varPop()</strong>, as illustrated in this code example:</p>
			<pre class="source-code">Field&lt;BigDecimal&gt; x = PRODUCT.BUY_PRICE;</pre>
			<pre class="source-code">ctx.select(varSamp(x)) // Sample Variance</pre>
			<pre class="source-code">    .from(PRODUCT).fetch();</pre>
			<pre class="source-code">ctx.select(varPop(x)) // Population Variance</pre>
			<pre class="source-code">    .from(PRODUCT).fetch();</pre>
			<p>Both of them are supported in MySQL, PostgreSQL, SQL Server, Oracle, and many other dialects, but just for fun, you can emulate sample variance via the <strong class="source-inline">COUNT()</strong> and <strong class="source-inline">SUM()</strong> aggregates as has been done in the following code snippet—just another opportunity to practice these aggregates:</p>
			<pre class="source-code">ctx.select((count().mul(sum(x.mul(x)))</pre>
			<pre class="source-code">      .minus(sum(x).mul(sum(x)))).divide(count()</pre>
			<pre class="source-code">      .mul(count().minus(1))).as("VAR_SAMP"))</pre>
			<pre class="source-code">   .from(PRODUCT).fetch();</pre>
			<p>Next, we have linear regression (or correlation) functions applied for determining regression<a id="_idIndexMarker1287"/> relationships between the dependent (denoted as Y) and independent (denoted as X) variable expressions (<a href="https://en.wikipedia.org/wiki/Regression_analysis">https://en.wikipedia.org/wiki/Regression_analysis</a>). In jOOQ, we have <strong class="source-inline">regrSXX()</strong>,<strong class="source-inline">regrSXY()</strong>, <strong class="source-inline">regrSYY()</strong>, <strong class="source-inline">regrAvgX</strong><strong class="source-inline">()</strong>, <strong class="source-inline">regrAvgXY()</strong>, <strong class="source-inline">regrCount()</strong>, <strong class="source-inline">regrIntercept()</strong>, <strong class="source-inline">regrR2()</strong>, and <strong class="source-inline">regrSlope()</strong>.</p>
			<p>For instance, in the case of <strong class="source-inline">regrSXY(y, x)</strong>, <strong class="source-inline">y</strong> is the dependent variable expression and <strong class="source-inline">x</strong> is the independent variable expression. If <strong class="source-inline">y</strong> is <strong class="source-inline">PRODUCT.BUY_PRICE</strong> and <strong class="source-inline">x</strong> is <strong class="source-inline">PRODUCT.MSRP</strong>, then the linear regression per <strong class="source-inline">PRODUCT_LINE</strong> looks like this:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE,</pre>
			<pre class="source-code">    (regrSXY(PRODUCT.BUY_PRICE, PRODUCT.MSRP)).as("regr_sxy"))</pre>
			<pre class="source-code">    .from(PRODUCT).groupBy(PRODUCT.PRODUCT_LINE).fetch();</pre>
			<p>The functions listed<a id="_idIndexMarker1288"/> earlier (including <strong class="source-inline">regrSXY()</strong>) are supported in all dialects, but they can be easily emulated as well. For instance, <strong class="source-inline">regrSXY()</strong> can be emulated as <strong class="source-inline">(SUM(X*Y)-SUM(X) * SUM(Y)/COUNT(*))</strong>, as illustrated here:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE,</pre>
			<pre class="source-code">     sum(PRODUCT.BUY_PRICE.mul(PRODUCT.MSRP))</pre>
			<pre class="source-code">      .minus(sum(PRODUCT.BUY_PRICE).mul(sum(PRODUCT.MSRP)</pre>
			<pre class="source-code">      .divide(count()))).as("regr_sxy"))</pre>
			<pre class="source-code">   .from(PRODUCT).groupBy(PRODUCT.PRODUCT_LINE).fetch();</pre>
			<p>In addition, <strong class="source-inline">regrSXY()</strong> can also be emulated as <strong class="source-inline">SUM(1) * COVAR_POP(expr1, expr2)</strong>, where <strong class="source-inline">COVAR_POP()</strong> represents the population covariance and <strong class="source-inline">SUM(1)</strong> is actually <strong class="source-inline">REGR_COUNT(expr1, expr2)</strong>. You can see this example in the bundled code next to many other emulations for <strong class="source-inline">REGR_FOO()</strong> functions and an example of calculating <strong class="source-inline">y = slope * x – intercept</strong> via <strong class="source-inline">regrSlope()</strong> and <strong class="source-inline">regrIntercept()</strong>, linear regression coefficients, but also via <strong class="source-inline">sum()</strong>, <strong class="source-inline">avg()</strong>, and <strong class="source-inline">max()</strong>. </p>
			<p>After <a id="_idIndexMarker1289"/>population <a id="_idIndexMarker1290"/>covariance (<a href="https://en.wikipedia.org/wiki/Covariance">https://en.wikipedia.org/wiki/Covariance</a>), <strong class="source-inline">COVAR_POP()</strong>, we have sample covariance, <strong class="source-inline">COVAR_SAMP()</strong>, which can be called like this:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE,</pre>
			<pre class="source-code">  covarSamp(PRODUCT.BUY_PRICE, PRODUCT.MSRP).as("covar_samp"),     </pre>
			<pre class="source-code">  covarPop(PRODUCT.BUY_PRICE, PRODUCT.MSRP).as("covar_pop")) </pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .groupBy(PRODUCT.PRODUCT_LINE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>If your database doesn't support the covariance functions (for instance, MySQL or SQL Server), then you can emulate them via common aggregates—<strong class="source-inline">COVAR_SAMP()</strong> as <strong class="source-inline">(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / (COUNT(*) - 1)</strong>, and <strong class="source-inline">COVAR_POP()</strong> as <strong class="source-inline">(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / COUNT(*)</strong>. You can find examples in the <em class="italic">AggregateFunctions</em> bundled code.</p>
			<p>An interesting function that is not supported by most databases (Exasol is one of the exceptions) but is provided by jOOQ is the synthetic <strong class="source-inline">product()</strong> function. This function represents multiplicative aggregation emulated via <strong class="source-inline">exp(sum(log(arg)))</strong> for positive numbers, and it performs some extra work for zero and negative numbers. For instance, in finance, there is an index named Compounded Month Growth Rate (CMGR) that is computed<a id="_idIndexMarker1291"/> based on monthly revenue growth, as we have in <strong class="source-inline">SALE.REVENUE_GROWTH</strong>. The formula is <strong class="source-inline">(PRODUCT (1 + SALE.REVENUE_GROWTH))) ^ (1 / COUNT())</strong>, and we've applied it for each year here:</p>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR,</pre>
			<pre class="source-code">      round((product(one().plus(</pre>
			<pre class="source-code">         SALE.REVENUE_GROWTH.divide(100)))</pre>
			<pre class="source-code">            .power(one().divide(count()))).mul(100) ,2)</pre>
			<pre class="source-code">               .concat("%").as("CMGR"))</pre>
			<pre class="source-code">   .from(SALE).groupBy(SALE.FISCAL_YEAR).fetch();</pre>
			<p>We also multiply <a id="_idIndexMarker1292"/>everything by 100 to obtain the result as a percent. You can find this example in the <em class="italic">AggregateFunctions</em> bundled code, next to other aggregation functions such as <strong class="source-inline">BOOL_AND()</strong>, <strong class="source-inline">EVERY()</strong>, <strong class="source-inline">BOOL_OR()</strong>, and functions for bitwise operations.</p>
			<p>When you have to use an aggregate function that is partially supported or not supported by jOOQ, you can rely on the <strong class="source-inline">aggregate()</strong>/ <strong class="source-inline">aggregateDistinct()</strong> methods. Of course, your database must support the called aggregate function. For instance, jOOQ doesn't support the Oracle <strong class="source-inline">APPROX_COUNT_DISTINCT()</strong> aggregation function, which represents an alternative to the <strong class="source-inline">COUNT (DISTINCT expr)</strong> function. This is useful for approximating the number of distinct values while processing large amounts of data significantly faster than the traditional <strong class="source-inline">COUNT</strong> function, with negligible deviation from the exact number. Here is a usage of the <strong class="source-inline">(String name, Class&lt;T&gt; type, Field&lt;?&gt;... arguments</strong>) aggregate, which is just one of the provided flavors (check out the documentation for more):</p>
			<pre class="source-code">ctx.select(ORDERDETAIL.PRODUCT_ID, </pre>
			<pre class="source-code">     aggregate("approx_count_distinct", Long.class,  </pre>
			<pre class="source-code">       ORDERDETAIL.ORDER_LINE_NUMBER).as("approx_count"))  </pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .groupBy(ORDERDETAIL.PRODUCT_ID)</pre>
			<pre class="source-code">   .fetch();   </pre>
			<p>You can find this example in the <em class="italic">AggregateFunctions</em> bundled code for Oracle.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/>Window functions</h1>
			<p>Window functions <a id="_idIndexMarker1293"/>are extremely useful and powerful; therefore, they represent a must-know topic for every developer that interacts with a database via SQL. In a nutshell, the best way to quickly overview window functions is to start from a famous diagram representing a comparison between an aggregation function and a window function that highlights the main difference between them, as represented here:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B16833_Figure_13.3.jpg" alt="Figure 13.3 – Aggregate functions versus window functions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Aggregate functions versus window functions</p>
			<p>As you can see, both the aggregate function and the window function calculate something on a set of rows, but a window function doesn't aggregate or group these rows into a single output row. A window function relies on the following syntax:</p>
			<pre class="source-code">window_function_name (expression) OVER (</pre>
			<pre class="source-code">    Partition Order Frame</pre>
			<pre class="source-code">)</pre>
			<p>This syntax can be explained as follows:</p>
			<p>Obviously, <strong class="source-inline">window_function_name</strong> represents the window function name, such as <strong class="source-inline">ROW_NUMBER()</strong>, <strong class="source-inline">RANK()</strong>, and so on. </p>
			<p><strong class="source-inline">expression</strong> identifies the column (or target expression) on which this window function will operate.</p>
			<p>The <strong class="source-inline">OVER</strong> clause signals that this is a window function, and it consists of three clauses: <strong class="source-inline">Partition</strong>, <strong class="source-inline">Order</strong>, and <strong class="source-inline">Frame</strong>. By adding the <strong class="source-inline">OVER</strong> clause to any aggregate function, you transform it into a window function.</p>
			<p>The <strong class="source-inline">Partition</strong> clause is optional, and its goal is to divide the rows into partitions. Next, the window function will operate on each partition. It has the following syntax: <strong class="source-inline">PARTITION BY expr1, expr2, ...</strong>. If <strong class="source-inline">PARTITION BY</strong> is omitted, then the entire result set represents a single partition. To be entirely accurate, if <strong class="source-inline">PARTITION BY</strong> is omitted, then all the data produced by <strong class="source-inline">FROM</strong>/<strong class="source-inline">WHERE</strong>/<strong class="source-inline">GROUP BY</strong>/<strong class="source-inline">HAVING</strong> represents a single partition.</p>
			<p>The <strong class="source-inline">Order</strong> clause is also optional, and it handles the order of rows in a partition. Its syntax is <strong class="source-inline">ORDER BY expression [ASC | DESC] [NULLS {FIRST| LAST}] ,...</strong>.</p>
			<p>The <strong class="source-inline">Frame</strong> clause demarcates a subset of the current partition. The common syntax is <strong class="source-inline">mode BETWEEN start_of_frame AND end_of_frame [frame_exclusion]</strong>.</p>
			<p><strong class="source-inline">mode</strong> instructs the<a id="_idIndexMarker1294"/> database about how to treat the input rows. Three possible values indicate the type of relationship between the frame rows and the current row: <strong class="source-inline">ROWS</strong>, <strong class="source-inline">GROUPS</strong>, and <strong class="source-inline">RANGE</strong>.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>ROWS </h2>
			<p>The <strong class="source-inline">ROWS</strong> mode<a id="_idIndexMarker1295"/> specifies that the offsets of the frame rows and the current row are <a id="_idIndexMarker1296"/>row numbers (the database sees each input row as an individual unit of work). In this context, <strong class="source-inline">start_of_frame</strong> and <strong class="source-inline">end_of_frame</strong> determine which rows the window frame starts and ends with. </p>
			<p>In this context, <strong class="source-inline">start_of_frame</strong> can be <strong class="source-inline">N PRECEDING</strong>, which means that the frame starts at n<span class="superscript">th</span> rows before the currently evaluated row (in jOOQ, <strong class="source-inline">rowsPreceding(n)</strong>), <strong class="source-inline">UNBOUNDED PRECEDING</strong>, which means that the frame starts at the first row of the current partition (in jOOQ, <strong class="source-inline">rowsUnboundedPreceding()</strong>), and <strong class="source-inline">CURRENT ROW</strong> (jOOQ  <strong class="source-inline">rowsCurrentRow()</strong>).</p>
			<p>The <strong class="source-inline">end_of_frame</strong> value can be <strong class="source-inline">CURRENT ROW</strong> (previously described), <strong class="source-inline">N FOLLOWING</strong>, which means that the frame ends at the n<span class="superscript">th</span> row after the currently evaluated row (in jOOQ, <strong class="source-inline">rowsFollowing(n)</strong>), and <strong class="source-inline">UNBOUNDED FOLLOWING</strong>, which means that the frame ends at the last row of the current partition (in jOOQ, <strong class="source-inline">rowsUnboundedFollowing()</strong>). </p>
			<p>Check out the following diagram containing some examples:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B16833_Figure_13.4.jpg" alt="Figure 13.4 – ROWS mode examples&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – ROWS mode examples</p>
			<p>What's in gray <a id="_idIndexMarker1297"/>represents the<a id="_idIndexMarker1298"/> included rows.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/>GROUPS</h2>
			<p>The <strong class="source-inline">GROUPS</strong> mode<a id="_idIndexMarker1299"/> instructs the database that the rows with duplicate sorting values<a id="_idIndexMarker1300"/> should be grouped together. So, <strong class="source-inline">GROUPS</strong> is useful when duplicate values are present.</p>
			<p>In this context, <strong class="source-inline">start_of_frame</strong> and <strong class="source-inline">end_of_frame</strong> accept the same values as <strong class="source-inline">ROWS</strong>. But, in the case of <strong class="source-inline">start_of_frame</strong>, <strong class="source-inline">CURRENT_ROW</strong> points to the first row in a group that contains the current row, while in the case of <strong class="source-inline">end_of_frame</strong>, it points to the last row in a group that contains the current row. Moreover, <strong class="source-inline">N PRECEDING</strong>/<strong class="source-inline">FOLLOWING</strong> refers to groups that should be considered as the number of groups before, respectively, after the current group. On the other hand, <strong class="source-inline">UNBOUNDED PRECEDING</strong>/<strong class="source-inline">FOLLOWING</strong> has the same meaning as in the case of <strong class="source-inline">ROWS</strong>.</p>
			<p>Check out the following diagram containing some examples:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B16833_Figure_13.5.jpg" alt="Figure 13.5 – GROUPS mode examples&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 – GROUPS mode examples</p>
			<p>There are three <a id="_idIndexMarker1301"/>groups (G1, G2, and G3) represented in different <a id="_idIndexMarker1302"/>shades of gray.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor255"/>RANGE</h2>
			<p>The <strong class="source-inline">RANGE</strong> mode<a id="_idIndexMarker1303"/> doesn't tie rows as <strong class="source-inline">ROWS</strong>/<strong class="source-inline">GROUPS</strong>. This mode works on a given <a id="_idIndexMarker1304"/>range of values of the sorting column. This time, for <strong class="source-inline">start_of_frame</strong> and <strong class="source-inline">end_of_frame</strong>, we don't specify the number of rows/groups; instead, we specify the maximum difference of values that the window frame should contain. Both values must be expressed in the same units (or, meaning) as the sorting column is.</p>
			<p>In this context, for <strong class="source-inline">start_of_frame</strong>,we have the following: (this time, <strong class="source-inline">N</strong> is a value in the same unit as the sorting column is) <strong class="source-inline">N PRECEDING</strong> (in jOOQ, <strong class="source-inline">rangePreceding(n)</strong>), <strong class="source-inline">UNBOUNDED PRECEDING</strong> (in jOOQ, <strong class="source-inline">rangeUnboundedPreceding()</strong>), and <strong class="source-inline">CURRENT ROW</strong> (in jOOQ, <strong class="source-inline">rangeCurrentRow()</strong>). For <strong class="source-inline">end_of_frame</strong>, we have <strong class="source-inline">CURRENT ROW</strong>, <strong class="source-inline">UNBOUNDED FOLLOWING</strong> (in jOOQ, <strong class="source-inline">rangeUnboundedFollowing()</strong>), <strong class="source-inline">N FOLLOWING</strong> (in jOOQ, <strong class="source-inline">rangeFollowing(n)</strong>). </p>
			<p>Check out the following diagram containing some examples:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B16833_Figure_13.6.jpg" alt="Figure 13.6 – RANGE mode examples&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6 – RANGE mode examples</p>
			<p>What's in<a id="_idIndexMarker1305"/> gray represents <a id="_idIndexMarker1306"/>the included rows.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor256"/>BETWEEN start_of_frame AND end_of_frame</h2>
			<p>Especially <a id="_idIndexMarker1307"/>for the <strong class="source-inline">BETWEEN start_of_frame AND end_of_frame</strong> construction, jOOQ <a id="_idIndexMarker1308"/>comes with <strong class="source-inline">fooBetweenCurrentRow()</strong>, <strong class="source-inline">fooBetweenFollowing(n)</strong>, <strong class="source-inline">fooBetweenPreceding(n)</strong>, <strong class="source-inline">fooBetweenUnboundedFollowing()</strong>, and <strong class="source-inline">fooBetweenUnboundedPreceding()</strong>. In all these methods, <strong class="source-inline">foo</strong> can be replaced with <strong class="source-inline">rows</strong>, <strong class="source-inline">groups</strong>, or <strong class="source-inline">range</strong>.</p>
			<p>In addition, for creating compound frames, jOOQ provides <strong class="source-inline">andCurrentRow()</strong>, <strong class="source-inline">andFollowing(n)</strong>, <strong class="source-inline">andPreceding(n)</strong>, <strong class="source-inline">andUnboundedFollowing()</strong>, and <strong class="source-inline">andUnboundedPreceding()</strong>.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor257"/>frame_exclusion</h2>
			<p>Via the <strong class="source-inline">frame_exclusion</strong> optional<a id="_idIndexMarker1309"/> part, we <a id="_idIndexMarker1310"/>can exclude certain rows from the window frame. <strong class="source-inline">frame_exclusion</strong> works exactly the same for all three modes. Possible values are listed here:</p>
			<ul>
				<li><strong class="source-inline">EXCLUDE CURRENT ROW</strong>—Exclude the current row (in jOOQ, <strong class="source-inline">excludeCurrentRow()</strong>).</li>
				<li><strong class="source-inline">EXCLUDE GROUP</strong>—Exclude the current row but also exclude all peer rows (for instance, exclude all rows having the same value in the sorting column). In jOOQ, we have the <strong class="source-inline">excludeGroup()</strong> method.</li>
				<li><strong class="source-inline">EXCLUDE TIES</strong>—Exclude all peer rows, but not the current row (in jOOQ, <strong class="source-inline">excludeTies()</strong>).</li>
				<li><strong class="source-inline">EXCLUDE NO OTHERS</strong>—This is the default, and it means to exclude nothing (in jOOQ, <strong class="source-inline">excludeNoOthers()</strong>).</li>
			</ul>
			<p>To better visualize these options, check out the following diagram:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B16833_Figure_13.7.jpg" alt="Figure 13.7 – Examples of excluding rows &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7 – Examples of excluding rows </p>
			<p>Speaking <a id="_idIndexMarker1311"/>about the logical order of operations in SQL, we notice here<a id="_idIndexMarker1312"/> that window functions are placed between <strong class="source-inline">HAVING</strong> and <strong class="source-inline">SELECT</strong>:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B16833_Figure_13.8.jpg" alt="Figure 13.8 – Logical order of operations in SQL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8 – Logical order of operations in SQL</p>
			<p>Also, I think is useful to explain that window functions can act upon data produced by all the previous steps <em class="italic">1-5</em>, and can be declared in all the following steps <em class="italic">7-12</em> (effectively only in 7 and 10). Before jumping into some window functions examples, let's quickly cover a less-known but quite useful SQL clause.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor258"/>The QUALIFY clause</h2>
			<p>Some<a id="_idIndexMarker1313"/> databases (for instance, Snowflake) support a clause named <strong class="source-inline">QUALIFY</strong>. Via this clause, we<a id="_idIndexMarker1314"/> can filter (apply a predicate) the results of window functions. Mainly, a <strong class="source-inline">SELECT … QUALIFY</strong> clause is evaluated after window functions are computed, so after <strong class="bold">Window Functions</strong> (<em class="italic">Step 6</em> in <em class="italic">Figure 13.8</em>) and before <strong class="bold">DISTINCT</strong> (<em class="italic">Step 8</em> in <em class="italic">Figure 13.8</em>). The syntax of <strong class="source-inline">QUALIFY</strong> is <strong class="source-inline">QUALIFY &lt;predicate&gt;</strong>, and in the following screenshot, you can see how it makes the difference (this query returns every 10<span class="superscript">th</span> product from the <strong class="source-inline">PRODUCT</strong> table via the <strong class="source-inline">ROW_NUMBER()</strong> window function):</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B16833_Figure_13.9.jpg" alt="Figure 13.9 – Logical order of operations in SQL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9 – Logical order of operations in SQL</p>
			<p>By using the <strong class="source-inline">QUALIFY</strong> clause, we eliminate the subquery and the code is less verbose. Even if this clause has poor native support among database vendors, jOOQ emulates it for all the supported dialects. Cool, right?! During this chapter, you'll see more examples of using the <strong class="source-inline">QUALIFY</strong> clause. </p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor259"/>Working with ROW_NUMBER()</h2>
			<p><strong class="source-inline">ROW_NUMBER()</strong> is a ranking<a id="_idIndexMarker1315"/> window function that assigns a<a id="_idIndexMarker1316"/> sequential number to each row (it starts from 1). A simple example is shown here:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B16833_Figure_13.10.jpg" alt="Figure 13.10 – Simple example of ROW_NUMBER()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10 – Simple example of ROW_NUMBER()</p>
			<p>You already saw an example of paginating database views via <strong class="source-inline">ROW_NUMBER()</strong> in <a href="B16833_12.xhtml#_idTextAnchor226"><em class="italic">Chapter 12</em></a>, <em class="italic">Pagination and Dynamic Queries</em>, so you should have no problem understanding the next two examples.</p>
			<p>Let's assume that we want to <a id="_idIndexMarker1317"/>compute the median (<a href="https://en.wikipedia.org/wiki/Median">https://en.wikipedia.org/wiki/Median</a>) of <strong class="source-inline">PRODUCT.QUANTITY_IN_STOCK</strong>. In Oracle and PostgreSQL, this can be done via the built-in <strong class="source-inline">median()</strong> aggregate function, but in MySQL and SQL <a id="_idIndexMarker1318"/>Server, we have to emulate it somehow, and a good <a id="_idIndexMarker1319"/>approach consists of using <strong class="source-inline">ROW_NUMBER()</strong>, as follows:</p>
			<pre class="source-code">Field&lt;Integer&gt; x = PRODUCT.QUANTITY_IN_STOCK.as("x");</pre>
			<pre class="source-code">Field&lt;Double&gt; y = inline(2.0d).mul(rowNumber().over()</pre>
			<pre class="source-code">   .orderBy(PRODUCT.QUANTITY_IN_STOCK))</pre>
			<pre class="source-code">   .minus(count().over()).as("y");</pre>
			<pre class="source-code">ctx.select(avg(x).as("median")).from(select(x, y)</pre>
			<pre class="source-code">   .from(PRODUCT))</pre>
			<pre class="source-code">   .where(y.between(0d, 2d))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>That was easy! Next, let's <a id="_idIndexMarker1320"/>try to solve a different kind of problem, and let's focus on the <strong class="source-inline">ORDER</strong> table. Each order has a <strong class="source-inline">REQUIRED_DATE</strong> and <strong class="source-inline">STATUS</strong> value as <strong class="source-inline">Shipped</strong>, <strong class="source-inline">Cancelled</strong>, and so on. Let's assume that we want to see the clusters (also known as islands) represented by continuous periods of time where the score (<strong class="source-inline">STATUS</strong>, in this case) stayed the same. An output sample can be seen here:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B16833_Figure_13.11.jpg" alt="Figure 13.11 – Clusters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.11 – Clusters</p>
			<p>If we have a<a id="_idIndexMarker1321"/> requirement to solve this problem via <strong class="source-inline">ROW_NUMBER()</strong> and to express it in jOOQ, then we may<a id="_idIndexMarker1322"/> come up with this query:</p>
			<pre class="source-code">Table&lt;?&gt; t = select(</pre>
			<pre class="source-code">  ORDER.REQUIRED_DATE.as("rdate"), ORDER.STATUS.as("status"),</pre>
			<pre class="source-code">  (rowNumber().over().orderBy(ORDER.REQUIRED_DATE)</pre>
			<pre class="source-code">    .minus(rowNumber().over().partitionBy(ORDER.STATUS)</pre>
			<pre class="source-code">  .orderBy(ORDER.REQUIRED_DATE))).as("cluster_nr"))</pre>
			<pre class="source-code">  .from(ORDER).asTable("t");</pre>
			<pre class="source-code">ctx.select(min(t.field("rdate")).as("cluster_start"),</pre>
			<pre class="source-code">           max(t.field("rdate")).as("cluster_end"),</pre>
			<pre class="source-code">           min(t.field("status")).as("cluster_score"))</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .groupBy(t.field("cluster_nr"))</pre>
			<pre class="source-code">   .orderBy(1)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can practice these examples in the <em class="italic">RowNumber</em> bundled code. </p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor260"/>Working with RANK()</h2>
			<p><strong class="source-inline">RANK()</strong> is a <a id="_idIndexMarker1323"/>ranking window function that assigns a rank to each row within the <a id="_idIndexMarker1324"/>partition of a result set. The rank of a row is computed as <em class="italic">1 + the number of ranks before it</em>. The columns having the same values get the same ranks; therefore, if multiple rows have the same rank, then the rank of the next row is not consecutive. Think of a competition where two athletes share the first place (or the gold medal) and there is no second place (so, no silver medal). A simple example is provided here:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B16833_Figure_13.12.jpg" alt="Figure 13.12 – Simple example of RANK()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.12 – Simple example of RANK()</p>
			<p>Here is another example that ranks <strong class="source-inline">ORDER</strong> by year and months of <strong class="source-inline">ORDER.ORDER_DATE</strong>:</p>
			<pre class="source-code">ctx.select(ORDER.ORDER_ID, ORDER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">      ORDER.ORDER_DATE, rank().over().orderBy(</pre>
			<pre class="source-code">        year(ORDER.ORDER_DATE), month(ORDER.ORDER_DATE))) </pre>
			<pre class="source-code">   .from(ORDER).fetch();</pre>
			<p>The <strong class="source-inline">year()</strong> and <strong class="source-inline">month()</strong> shortcuts are provided by jOOQ to avoid the usage of the SQL <strong class="source-inline">EXTRACT()</strong> function. For instance, <strong class="source-inline">year(ORDER.ORDER_DATE)</strong> can be written as <strong class="source-inline">extract(ORDER.ORDER_DATE, DatePart.YEAR)</strong> as well.</p>
			<p>How about ranking <strong class="source-inline">YEAR</strong> is the partition? This can be <a id="_idIndexMarker1325"/>expressed in jOOQ like this:</p>
			<pre class="source-code">ctx.select(SALE.EMPLOYEE_NUMBER, SALE.FISCAL_YEAR,  </pre>
			<pre class="source-code">  sum(SALE.SALE_), rank().over().partitionBy(SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">     .orderBy(sum(SALE.SALE_).desc()).as("sale_rank"))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER, SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Finally, let's see an example that <a id="_idIndexMarker1326"/>ranks the products. Since a partition can be defined via multiple columns, we can easily rank the products by <strong class="source-inline">PRODUCT_VENDOR</strong> and <strong class="source-inline">PRODUCT_SCALE</strong>, as <a id="_idIndexMarker1327"/>shown here:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, </pre>
			<pre class="source-code">    PRODUCT.PRODUCT_SCALE, rank().over().partitionBy(</pre>
			<pre class="source-code">      PRODUCT.PRODUCT_VENDOR, PRODUCT.PRODUCT_SCALE)</pre>
			<pre class="source-code">   .orderBy(PRODUCT.PRODUCT_NAME))</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can practice these examples and more in <em class="italic">Rank</em>.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor261"/>Working with DENSE_RANK()</h2>
			<p><strong class="source-inline">DENSE_RANK()</strong> is a <a id="_idIndexMarker1328"/>window function that assigns a rank to each row <a id="_idIndexMarker1329"/>within a partition or result set with no gaps in ranking values. A simple example is shown here:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B16833_Figure_13.13.jpg" alt="Figure 13.13 – Simple example of DENSE_RANK()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.13 – Simple example of DENSE_RANK()</p>
			<p>In <a href="B16833_12.xhtml#_idTextAnchor226"><em class="italic">Chapter 12</em></a>, <em class="italic">Pagination and Dynamic Queries</em>, you already saw an example of using <strong class="source-inline">DENSE_RANK()</strong> for paginating <strong class="source-inline">JOIN</strong> statements. Next, let's have another case of ranking employees (<strong class="source-inline">EMPLOYEE</strong>) in offices (<strong class="source-inline">OFFICE</strong>) by their salary (<strong class="source-inline">EMPLOYEE.SALARY</strong>), as follows:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">  EMPLOYEE.SALARY, OFFICE.CITY, OFFICE.COUNTRY,       </pre>
			<pre class="source-code">  OFFICE.OFFICE_CODE, denseRank().over().partitionBy(</pre>
			<pre class="source-code">    OFFICE.OFFICE_CODE).orderBy(EMPLOYEE.SALARY.desc())</pre>
			<pre class="source-code">      .as("salary_rank"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .innerJoin(OFFICE)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE)).fetch();</pre>
			<p>An output fragment looks like this (notice that the employees having the same salary get the same rank):</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B16833_Figure_13.14.jpg" alt="Figure 13.14 – Output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.14 – Output</p>
			<p>Finally, let's <a id="_idIndexMarker1330"/>use <strong class="source-inline">DENSE_RANK()</strong> for selecting the highest <a id="_idIndexMarker1331"/>salary from each office, including duplicates. This time, let's use the <strong class="source-inline">QUALIFY</strong> clause as well. The code is illustrated in the following snippet:</p>
			<pre class="source-code">select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">    EMPLOYEE.SALARY, OFFICE.CITY, OFFICE.COUNTRY,   </pre>
			<pre class="source-code">    OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code"> .from(EMPLOYEE)</pre>
			<pre class="source-code"> .innerJoin(OFFICE)</pre>
			<pre class="source-code">  .on(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE))</pre>
			<pre class="source-code"> .qualify(denseRank().over().partitionBy(OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.SALARY.desc()).eq(1))</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>Before going<a id="_idIndexMarker1332"/> further, here is a nice read: <a href="https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/">https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/</a>. You can check out<a id="_idIndexMarker1333"/> these examples in the <em class="italic">DenseRank</em> bundled code. </p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor262"/>Working with PERCENT_RANK()</h2>
			<p>The <strong class="source-inline">PERCENT_RANK()</strong> window function<a id="_idIndexMarker1334"/> calculates the percentile<a id="_idIndexMarker1335"/> rankings <strong class="source-inline">((rank - 1) / (total_rows - 1))</strong> of rows in a result set and returns a value between 0 exclusive and 1 inclusive. The first row in the result set always has the percent rank equal to 0. This function doesn't count <strong class="source-inline">NULL</strong> values and is nondeterministic.  Usually, the final result is multiplied by 100 to express as a percentage.</p>
			<p>The best way to understand this function is via an example. Let's assume that we want to compute the percentile rank for employees in each office by their salaries. The query expressed in jOOQ will look like this:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">   EMPLOYEE.SALARY, OFFICE.OFFICE_CODE, OFFICE.CITY,    </pre>
			<pre class="source-code">   OFFICE.COUNTRY, round(percentRank().over()</pre>
			<pre class="source-code">      .partitionBy(OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code">      .orderBy(EMPLOYEE.SALARY).mul(100), 2)</pre>
			<pre class="source-code">      .concat("%").as("PERCENTILE_RANK"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .innerJoin(OFFICE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.OFFICE_CODE.eq(OFFICE.OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The following screenshot represents a snippet of the result:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B16833_Figure_13.15.jpg" alt="Figure 13.15 – Percent rank output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.15 – Percent rank output</p>
			<p>So, how do we interpret this output? A percentile rank is commonly defined as the proportion of results (or scores) in a distribution that a certain result (or score) is greater than or equal to (sometimes only greater than counts). For example, if you get a result/score of 90 on a certain test and this result/score was greater than (or equal to) the results/scores of 75% of the participants taking the test, then your percentile rank is 75. You would be in the 75<span class="superscript">th</span> percentile.</p>
			<p>In other<a id="_idIndexMarker1336"/> words, in office 1, we can say that 40% of<a id="_idIndexMarker1337"/> employees have salaries lower than <em class="italic">Anthony Bow</em> (check the third row), so <em class="italic">Anthony Bow</em> is in the 40<span class="superscript">th</span> percentile. Also, in office 1, <em class="italic">Diane Murphy</em> has the highest salary since 100% of employees have salaries lower than her salary (check the sixth row). When the current row is the first in the partition then there is no previous data to consider, therefore the percentile rank is 0. An interesting case is <em class="italic">George Vanauf</em> (last row) having a percentile rank of 0%. Because his salary (<em class="italic">$55,000</em>) is equal to the salary of <em class="italic">Foon Yue Tseng</em>, we can say that nobody has a salary lower than his.</p>
			<p>A common use case for <strong class="source-inline">PERCENT_RANK()</strong> is to categorize data into custom groups (also known as custom binning). For example, let's consider that we want to count departments having a low (smaller than the 20<span class="superscript">th</span> percentile), medium (between the 20<span class="superscript">th</span> and 80<span class="superscript">th</span> percentile), and high (greater than 80<span class="superscript">th</span> percentile) profit. Here's the code we'd use to calculate this:</p>
			<pre class="source-code">ctx.select(count().filterWhere(field("p").lt(0.2))</pre>
			<pre class="source-code">     .as("low_profit"),</pre>
			<pre class="source-code">  count().filterWhere(field("p").between(0.2, 0.8))</pre>
			<pre class="source-code">     .as("good_profit"),</pre>
			<pre class="source-code">  count().filterWhere(field("p").gt(0.8))</pre>
			<pre class="source-code">     .as("high_profit"))</pre>
			<pre class="source-code"> .from(select(percentRank().over()</pre>
			<pre class="source-code">        .orderBy(DEPARTMENT.PROFIT).as("p"))</pre>
			<pre class="source-code">        .from(DEPARTMENT)</pre>
			<pre class="source-code">        .where(DEPARTMENT.PROFIT.isNotNull()))     </pre>
			<pre class="source-code"> .fetch();</pre>
			<p>You can <a id="_idIndexMarker1338"/>practice these examples—and more—in the <em class="italic">PercentRank</em> bundled <a id="_idIndexMarker1339"/>code.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor263"/>Working with CUME_DIST()</h2>
			<p><strong class="source-inline">CUME_DIST()</strong> is a <a id="_idIndexMarker1340"/>window function that computes the cumulative distribution<a id="_idIndexMarker1341"/> of a value within a set of values. In other words, <strong class="source-inline">CUME_DIST()</strong> divides the number of rows having values less than or equal to the current row's value by the total number of rows. The returned value is greater than zero and less than or equal to one (0 &lt; <strong class="source-inline">CUME_DIST()</strong> &lt;= 1). The columns having repeated values get the same <strong class="source-inline">CUME_DIST()</strong> value. A simple example is provided here:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B16833_Figure_13.16.jpg" alt="Figure 13.16 – Simple example of CUME_DIST()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.16 – Simple example of CUME_DIST()</p>
			<p>So, we have a result set of 23 rows. For the first row (denoted as A), <strong class="source-inline">CUME_DIST()</strong> finds the number of rows having a value less than or equal to <em class="italic">50000</em>. The result is 4. Then, the function divides 4 by the total number of rows, which is 23: 4/23. The result is 0.17 or 17%. The same logic is applied to the next rows.</p>
			<p>How about fetching<a id="_idIndexMarker1342"/> the top 25% of sales in <em class="italic">2003</em> and <em class="italic">2004</em>? This <a id="_idIndexMarker1343"/>can be solved via <strong class="source-inline">CUME_DIST()</strong> and the handy <strong class="source-inline">QUALIFY</strong> clause, as follows:</p>
			<pre class="source-code">ctx.select(concat(EMPLOYEE.FIRST_NAME, inline(" "), </pre>
			<pre class="source-code"> EMPLOYEE.LAST_NAME).as("name"), SALE.SALE_, SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .join(SALE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">    .and(SALE.FISCAL_YEAR.in(2003, 2004)))</pre>
			<pre class="source-code">   .qualify(cumeDist().over().partitionBy(SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">   .orderBy(SALE.SALE_.desc()).lt(BigDecimal.valueOf(0.25)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can practice <a id="_idIndexMarker1344"/>these examples <a id="_idIndexMarker1345"/>in the <em class="italic">CumeDist</em> bundled code.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor264"/>Working with LEAD()/LAG()</h2>
			<p><strong class="source-inline">LEAD()</strong> is a<a id="_idIndexMarker1346"/> window function that looks forward a specified number of rows (offset, by default 1) and accesses that row from the current row. <strong class="source-inline">LAG()</strong> works <a id="_idIndexMarker1347"/>the same as <strong class="source-inline">LEAD()</strong>, but it looks back. For both, we<a id="_idIndexMarker1348"/> can optionally specify a default value to be returned when there is no subsequent row (<strong class="source-inline">LEAD()</strong>) or there is no preceding row <strong class="source-inline">(LAG()</strong>) instead of returning <strong class="source-inline">NULL</strong>. A <a id="_idIndexMarker1349"/>simple example is provided here:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B16833_Figure_13.17.jpg" alt="Figure 13.17 – Simple example of LEAD() and LAG()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.17 – Simple example of LEAD() and LAG()</p>
			<p>Besides the <strong class="source-inline">lead</strong>/<strong class="source-inline">lag</strong><strong class="source-inline">(Field&lt;T&gt; field)</strong> syntax <a id="_idIndexMarker1350"/>used in this example, jOOQ also exposes <strong class="source-inline">lead</strong>/<strong class="source-inline">lag(Field&lt;T&gt; field, int offset)</strong>, <strong class="source-inline">lead</strong><strong class="source-inline">/lag(Field&lt;T&gt; field, int offset, Field&lt;T&gt; defaultValue)</strong>, and <strong class="source-inline">lead/lag</strong><strong class="source-inline">(Field&lt;T&gt; field, int offset, T defaultValue)</strong>. In this example, <strong class="source-inline">lead</strong>/<strong class="source-inline">lag(ORDER.ORDER_DATE)</strong> uses an offset of 1, so is the same thing as <strong class="source-inline">lead</strong>/<strong class="source-inline">lag(ORDER.ORDER_DATE, 1)</strong>.</p>
			<p>Here is an example that, for <a id="_idIndexMarker1351"/>each employee, displays the salary and next salary using the office as a partition of <strong class="source-inline">LEAD()</strong>. When <strong class="source-inline">LEAD()</strong> reaches the end of the partition, we use 0 instead of <strong class="source-inline">NULL</strong>:</p>
			<pre class="source-code">ctx.select(OFFICE.OFFICE_CODE, OFFICE.CITY, OFFICE.COUNTRY,</pre>
			<pre class="source-code"> EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, EMPLOYEE.SALARY,</pre>
			<pre class="source-code"> lead(EMPLOYEE.SALARY, 1, 0).over()</pre>
			<pre class="source-code">    .partitionBy(OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code">      .orderBy(EMPLOYEE.SALARY).as("next_salary"))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .innerJoin(EMPLOYEE)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Next, let's tackle an example of calculating the Month-Over-Month (MOM) growth rate. This financial indicator is useful for benchmarking the business, and we already have it in the <strong class="source-inline">SALE.REVENUE_GROWTH</strong> column. But here is the query that can calculate it via the <strong class="source-inline">LAG()</strong> function<a id="_idIndexMarker1352"/> for the year <em class="italic">2004</em>:</p>
			<pre class="source-code">ctx.select(SALE.FISCAL_MONTH,</pre>
			<pre class="source-code">  inline(100).mul((SALE.SALE_.minus(lag(SALE.SALE_, 1)</pre>
			<pre class="source-code">    .over().orderBy(SALE.FISCAL_MONTH)))</pre>
			<pre class="source-code">    .divide(lag(SALE.SALE_, 1).over()</pre>
			<pre class="source-code">     .orderBy(SALE.FISCAL_MONTH))).concat("%").as("MOM"))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .where(SALE.FISCAL_YEAR.eq(2004))</pre>
			<pre class="source-code">   .orderBy(SALE.FISCAL_MONTH)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>For more <a id="_idIndexMarker1353"/>examples, including <a id="_idIndexMarker1354"/>an example of funneling drop-off <a id="_idIndexMarker1355"/>metrics and one about <a id="_idIndexMarker1356"/>time-series analysis, please check out the <em class="italic">LeadLag</em> bundled code.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor265"/>Working with NTILE()</h2>
			<p><strong class="source-inline">NTILE(n)</strong> is a <a id="_idIndexMarker1357"/>window function commonly used for distributing the number of <a id="_idIndexMarker1358"/>rows in the specified <strong class="source-inline">n</strong> number of groups or buckets. Each bucket has a number (starting at 1) that indicates the bucket to which this row belongs. A simple example is provided here:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B16833_Figure_13.18.jpg" alt="Figure 13.18 – Simple example of NTILE()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.18 – Simple example of NTILE()</p>
			<p>So, in this example, we've distributed <strong class="source-inline">EMPLOYEE.SALARY</strong> in 10 buckets. <strong class="source-inline">NTILE()</strong> strives to determine how many rows should be in each bucket in order to provide the number of buckets and to keep them approximately equal.</p>
			<p>Among its use cases, <strong class="source-inline">NTILE()</strong> is useful<a id="_idIndexMarker1359"/> for calculating Recency, Frequency, and Monetary (RFM) indices (<a href="https://en.wikipedia.org/wiki/RFM_(market_research)">https://en.wikipedia.org/wiki/RFM_(market_research)</a>). In short, the RFM analysis is basically an indexing technique that relies on past purchase behavior to determine different segments of customers.</p>
			<p>In our case, the past purchase behavior of each customer (<strong class="source-inline">ORDER.CUSTOMER_NUMBER</strong>) is stored in the <strong class="source-inline">ORDER</strong> table, especially in <strong class="source-inline">ORDER.ORDER_ID</strong>, <strong class="source-inline">ORDER.ORDER_DATE</strong>, and <strong class="source-inline">ORDER.AMOUNT</strong>.</p>
			<p>Based on this information, we<a id="_idIndexMarker1360"/> attempt to divide customers into four equal groups <a id="_idIndexMarker1361"/>based on the distribution of values for R, F, and M. Four equal groups across RFM variables produce 4<span class="superscript">3</span>=64 potential segments. The result consists of a table having a score between 1 and 4 for each of the quantiles (R, F, and M). The query speaks for itself, as we can see here:</p>
			<pre class="source-code">ctx.select(field("customer_number"),</pre>
			<pre class="source-code">    ntile(4).over().orderBy(field("last_order_date"))</pre>
			<pre class="source-code">     .as("rfm_recency"),</pre>
			<pre class="source-code">    ntile(4).over().orderBy(field("count_order"))</pre>
			<pre class="source-code">     .as("rfm_frequency"),</pre>
			<pre class="source-code">    ntile(4).over().orderBy(field("avg_amount"))</pre>
			<pre class="source-code">     .as("rfm_monetary")).from(</pre>
			<pre class="source-code">     select(ORDER.CUSTOMER_NUMBER.as("customer_number"),</pre>
			<pre class="source-code">      max(ORDER.ORDER_DATE).as("last_order_date"),</pre>
			<pre class="source-code">      count().as("count_order"),</pre>
			<pre class="source-code">      avg(ORDER.AMOUNT).as("avg_amount"))</pre>
			<pre class="source-code">        .from(ORDER)</pre>
			<pre class="source-code">        .groupBy(ORDER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>A sample output is provided here:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B16833_Figure_13.19.jpg" alt="Figure 13.19 – RFM sample&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.19 – RFM sample</p>
			<p>By combining the <a id="_idIndexMarker1362"/>RFM result as R*100+F*10+M, we can obtain an aggregate<a id="_idIndexMarker1363"/> score. This is available next to more examples in the <em class="italic">Ntile</em> bundled code.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor266"/>Working with FIRST_VALUE() and LAST_VALUE()</h2>
			<p><strong class="source-inline">FIRST_VALUE(expr)</strong> returns <a id="_idIndexMarker1364"/>the value of the specified expression (<strong class="source-inline">expr</strong>) with <a id="_idIndexMarker1365"/>respect to the first row in the window frame.</p>
			<p><strong class="source-inline">NTH_VALUE(expr, offset)</strong> returns the value of the specified expression (<strong class="source-inline">expr</strong>) with respect to the offset row in the window frame.</p>
			<p><strong class="source-inline">LAST_VALUE(expr)</strong> returns <a id="_idIndexMarker1366"/>the value of the specified expression (<strong class="source-inline">expr</strong>) with<a id="_idIndexMarker1367"/> respect to the last row in the window frame.</p>
			<p>Let's assume that our goal is to obtain the cheapest and most expensive product per product line, as in the following screenshot:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B16833_Figure_13.20.jpg" alt="Figure 13.20 – Cheapest and most expensive product per product line&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.20 – Cheapest and most expensive product per product line</p>
			<p>Accomplishing<a id="_idIndexMarker1368"/> this task via <strong class="source-inline">FIRST_VALUE()</strong> and <strong class="source-inline">LAST_VALUE()</strong> can be <a id="_idIndexMarker1369"/>done like this:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, </pre>
			<pre class="source-code">  PRODUCT.PRODUCT_NAME, PRODUCT.BUY_PRICE,</pre>
			<pre class="source-code">  firstValue(PRODUCT.PRODUCT_NAME).over()</pre>
			<pre class="source-code">   .partitionBy(PRODUCT.PRODUCT_LINE)</pre>
			<pre class="source-code">     .orderBy(PRODUCT.BUY_PRICE).as("cheapest"),</pre>
			<pre class="source-code">  lastValue(PRODUCT.PRODUCT_NAME).over()</pre>
			<pre class="source-code">   .partitionBy(PRODUCT.PRODUCT_LINE)</pre>
			<pre class="source-code">     .orderBy(PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">       .rangeBetweenUnboundedPreceding()</pre>
			<pre class="source-code">       .andUnboundedFollowing().as("most_expensive"))</pre>
			<pre class="source-code">  .from(PRODUCT)</pre>
			<pre class="source-code">  .fetch(); </pre>
			<p>If the window frame is <a id="_idIndexMarker1370"/>not specified, then the default window frame <a id="_idIndexMarker1371"/>depends on the presence of <strong class="source-inline">ORDER BY</strong>. If <strong class="source-inline">ORDER BY</strong> is present, then the window frame is <strong class="source-inline">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</strong>. If <strong class="source-inline">ORDER BY</strong> is not present, then the window frame is <strong class="source-inline">RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</strong>.</p>
			<p>Having this in mind, in our case, <strong class="source-inline">FIRST_VALUE()</strong> can rely on the default window frame to return the first <a id="_idIndexMarker1372"/>row of the partition, which is the smallest price. On the other hand, <strong class="source-inline">LAST_VALUE()</strong> must <a id="_idIndexMarker1373"/>explicitly define the window frame as <strong class="source-inline">RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</strong> to <a id="_idIndexMarker1374"/>return <a id="_idIndexMarker1375"/>the highest price.</p>
			<p>Here is another example of fetching the second most expensive product by product line via <strong class="source-inline">NTH_VALUE()</strong>:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, </pre>
			<pre class="source-code">  PRODUCT.PRODUCT_NAME, PRODUCT.BUY_PRICE,</pre>
			<pre class="source-code">  nthValue(PRODUCT.PRODUCT_NAME, 2).over()</pre>
			<pre class="source-code">   .partitionBy(PRODUCT.PRODUCT_LINE)</pre>
			<pre class="source-code">    .orderBy(PRODUCT.BUY_PRICE.desc())</pre>
			<pre class="source-code">     .rangeBetweenUnboundedPreceding()</pre>
			<pre class="source-code">     .andUnboundedFollowing().as("second_most_expensive"))</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The preceding query orders <strong class="source-inline">BUY_PRICE</strong> in descending order for fetching the second most expensive product by product line. But this is mainly the second row from the bottom, therefore we can rely on the <strong class="source-inline">FROM LAST</strong> clause (in jOOQ, <strong class="source-inline">fromLast()</strong>) to express it, as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, </pre>
			<pre class="source-code">   PRODUCT.PRODUCT_NAME, PRODUCT.BUY_PRICE,</pre>
			<pre class="source-code">   nthValue(PRODUCT.PRODUCT_NAME, 2).fromLast().over()</pre>
			<pre class="source-code">   .partitionBy(PRODUCT.PRODUCT_LINE)</pre>
			<pre class="source-code">    .orderBy(PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">     .rangeBetweenUnboundedPreceding()</pre>
			<pre class="source-code">     .andUnboundedFollowing().as("second_most_expensive"))</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This <a id="_idIndexMarker1376"/>query <a id="_idIndexMarker1377"/>works <a id="_idIndexMarker1378"/>fine in Oracle, which<a id="_idIndexMarker1379"/> supports <strong class="source-inline">FROM FIRST</strong> (<strong class="source-inline">fromFirst()</strong>), <strong class="source-inline">FROM LAST</strong> (<strong class="source-inline">fromLast()</strong>), <strong class="source-inline">IGNORE NULLS</strong> (<strong class="source-inline">ignoreNulls()</strong>), and <strong class="source-inline">RESPECT NULLS</strong> (<strong class="source-inline">respectNulls()</strong>).</p>
			<p>You can practice these examples in the <em class="italic">FirstLastNth</em> bundled code.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor267"/>Working with RATIO_TO_REPORT()</h2>
			<p><strong class="source-inline">RATIO_TO_REPORT(expr)</strong> computes the <a id="_idIndexMarker1380"/>ratio of the specified value to the sum of values in the set. If the given <strong class="source-inline">expr</strong> value is evaluated as <strong class="source-inline">null</strong>, then <a id="_idIndexMarker1381"/>this function returns <strong class="source-inline">null</strong>. A simple example is provided here:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B16833_Figure_13.21.jpg" alt="Figure 13.21 – Simple example of RATIO_TO_REPORT()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.21 – Simple example of RATIO_TO_REPORT()</p>
			<p>For instance, for the first row, the ratio is computed as 51241.54 / 369418.38, where 369418.38 is the sum of all sales. After applying the <strong class="source-inline">round()</strong> function, the result is 0.14 or 14%, but if we want to compute the ratio of the current sale per fiscal year, we can do it via <strong class="source-inline">PARTITION BY</strong>, as shown here:</p>
			<pre class="source-code">ctx.select(SALE.EMPLOYEE_NUMBER, SALE.FISCAL_YEAR, SALE.SALE_,</pre>
			<pre class="source-code">  round(ratioToReport(SALE.SALE_).over()</pre>
			<pre class="source-code">          .partitionBy(SALE.FISCAL_YEAR), 2)</pre>
			<pre class="source-code">          .as("ratio_to_report_sale"))</pre>
			<pre class="source-code">  .from(SALE).fetch();</pre>
			<p>Let's compute the ratio of the current sum of salaries per employee and express it in percentages, like so:</p>
			<pre class="source-code">ctx.select(OFFICE.OFFICE_CODE, </pre>
			<pre class="source-code">     sum(EMPLOYEE.SALARY).as("salaries"),</pre>
			<pre class="source-code">       ratioToReport(sum(EMPLOYEE.SALARY)).over()</pre>
			<pre class="source-code">        .mul(100).concat("%").as("ratio_to_report"))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .join(EMPLOYEE)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE))</pre>
			<pre class="source-code">   .groupBy(OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code">   .orderBy(OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can<a id="_idIndexMarker1382"/> check out <a id="_idIndexMarker1383"/>these examples in the <em class="italic">RatioToReport</em> bundled code.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor268"/>Aggregates as window functions</h1>
			<p>Aggregate functions <a id="_idIndexMarker1384"/>can be used as window functions as <a id="_idIndexMarker1385"/>well. For instance, let's use the <strong class="source-inline">SUM()</strong> aggregate function as a window function for computing the sum of the successfully transferred amount per customer until each caching date, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B16833_Figure_13.22.jpg" alt="Figure 13.22 – Sum of the transferred amount until each caching date&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.22 – Sum of the transferred amount until each caching date</p>
			<p>The jOOQ query can be expressed like this:</p>
			<pre class="source-code">ctx.select(BANK_TRANSACTION.CUSTOMER_NUMBER,   </pre>
			<pre class="source-code">  BANK_TRANSACTION.CACHING_DATE,</pre>
			<pre class="source-code">  BANK_TRANSACTION.TRANSFER_AMOUNT, BANK_TRANSACTION.STATUS,</pre>
			<pre class="source-code">  sum(BANK_TRANSACTION.TRANSFER_AMOUNT).over()</pre>
			<pre class="source-code">   .partitionBy(BANK_TRANSACTION.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">   .orderBy(BANK_TRANSACTION.CACHING_DATE)</pre>
			<pre class="source-code">   .rowsBetweenUnboundedPreceding().andCurrentRow().as("result"))</pre>
			<pre class="source-code">  .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">  .where(BANK_TRANSACTION.STATUS.eq("SUCCESS")).fetch();</pre>
			<p>Or, let's use<a id="_idIndexMarker1386"/> the <strong class="source-inline">AVG()</strong> aggregate function<a id="_idIndexMarker1387"/> as a window function for computing the average of prices for the preceding three ordered products on each order, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B16833_Figure_13.23.jpg" alt="Figure 13.23 – Average of prices for the preceding three ordered products on each order&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.23 – Average of prices for the preceding three ordered products on each order</p>
			<p>The<a id="_idIndexMarker1388"/> query<a id="_idIndexMarker1389"/> looks like this:</p>
			<pre class="source-code">ctx.select(ORDERDETAIL.ORDER_ID, ORDERDETAIL.PRODUCT_ID, ...,</pre>
			<pre class="source-code">       avg(ORDERDETAIL.PRICE_EACH).over()</pre>
			<pre class="source-code">        .partitionBy(ORDERDETAIL.ORDER_ID)</pre>
			<pre class="source-code">        .orderBy(ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">        .rowsPreceding(2).as("avg_prec_3_prices"))</pre>
			<pre class="source-code">   .from(ORDERDETAIL).fetch();</pre>
			<p>How about calculating a running average flavor—in other words, create a report that shows every transaction in <em class="italic">March 2005</em> for <em class="italic">Visa Electron</em> cards? Additionally, this report shows the daily average transaction amount relying on a 3-day moving average. The code to accomplish this is shown in the following snippet:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code">  BANK_TRANSACTION.CACHING_DATE, BANK_TRANSACTION.CARD_TYPE,</pre>
			<pre class="source-code">  sum(BANK_TRANSACTION.TRANSFER_AMOUNT).as("daily_sum"),</pre>
			<pre class="source-code">  avg(sum(BANK_TRANSACTION.TRANSFER_AMOUNT)).over()</pre>
			<pre class="source-code">    .orderBy(BANK_TRANSACTION.CACHING_DATE)</pre>
			<pre class="source-code">      .rowsBetweenPreceding(2).andCurrentRow()</pre>
			<pre class="source-code">         .as("transaction_running_average"))</pre>
			<pre class="source-code">   .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .where(BANK_TRANSACTION.CACHING_DATE</pre>
			<pre class="source-code">   .between(LocalDateTime.of(2005, 3, 1, 0, 0, 0),</pre>
			<pre class="source-code">            LocalDateTime.of(2005, 3, 31, 0, 0, 0))</pre>
			<pre class="source-code">   .and(BANK_TRANSACTION.CARD_TYPE.eq("VisaElectron")))   </pre>
			<pre class="source-code">   .groupBy(BANK_TRANSACTION.CACHING_DATE, </pre>
			<pre class="source-code">            BANK_TRANSACTION.CARD_TYPE)</pre>
			<pre class="source-code">   .orderBy(BANK_TRANSACTION.CACHING_DATE).fetch();</pre>
			<p>As Lukas Eder mentioned: "<em class="italic">What's most mind-blowing about aggregate window functions is that even user-defined aggregate functions can be used as window functions!</em>"</p>
			<p>You can check<a id="_idIndexMarker1390"/> out more examples (for instance, in the <em class="italic">PostgreSQL</em> bundled code, you <a id="_idIndexMarker1391"/>can find queries for <em class="italic">How many other employees have the same salary as me?</em> and <em class="italic">How many sales are better by 5,000 or less?</em>) in the <em class="italic">AggregateWindowFunctions</em> bundled code.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor269"/>Aggregate functions and ORDER BY</h1>
			<p>Certain aggregate functions output significantly different results depending on their input order. By default, this ordering is not specified, but it can be controlled via an optional <strong class="source-inline">ORDER BY</strong> clause <a id="_idIndexMarker1392"/>as an argument. So, in the presence of <strong class="source-inline">ORDER BY</strong> on these aggregate function calls, we can fetch ordered aggregated results. Let's see how we can use such functions in jOOQ and start with a category of functions having their names suffixed with <strong class="source-inline">AGG</strong>, such as <strong class="source-inline">ARRAY_AGG()</strong>, <strong class="source-inline">JSON_ARRAYAGG()</strong>, <strong class="source-inline">XML_AGG()</strong>, <strong class="source-inline">MULTISET_AGG()</strong> (covered in <a href="B16833_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>, <em class="italic">Fetching and Mapping</em>), and so on.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor270"/>FOO_AGG()</h2>
			<p>For instance, <strong class="source-inline">ARRAY_AGG()</strong> is a <a id="_idIndexMarker1393"/>function that aggregates data into an array and, in the presence of <strong class="source-inline">ORDER BY</strong>, it aggregates data into an array conforming to the specified order. Here is an example of using <strong class="source-inline">ARRAY_AGG()</strong> to aggregate <strong class="source-inline">EMPLOYEE.FIRST_NAME</strong> in descending order by <strong class="source-inline">EMPLOYEE.FIRST_NAME</strong> and <strong class="source-inline">LAST_NAME</strong>:</p>
			<pre class="source-code">ctx.select(arrayAgg(EMPLOYEE.FIRST_NAME).orderBy(</pre>
			<pre class="source-code">      EMPLOYEE.FIRST_NAME.desc(),               EMPLOYEE.LAST_NAME.desc()))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<p>For PostgreSQL, jOOQ renders this SQL:</p>
			<pre class="source-code">SELECT ARRAY_AGG(</pre>
			<pre class="source-code">    "public"."employee"."first_name" </pre>
			<pre class="source-code">    ORDER BY</pre>
			<pre class="source-code">      "public"."employee"."first_name" DESC, </pre>
			<pre class="source-code">      "public"."employee"."last_name" DESC</pre>
			<pre class="source-code">  ) FROM "public"."employee"</pre>
			<p>The result is an array as [<em class="italic">Yoshimi</em>, <em class="italic">William</em>, <em class="italic">Tom</em>, <em class="italic">Steve</em>, <em class="italic">Peter</em>,…], wrapped as <strong class="source-inline">Result&lt;Record1&lt;String[]&gt;&gt; </strong>(extract <strong class="source-inline">String[]</strong> via <strong class="source-inline">get(0).value1()</strong>). Do not confuse <strong class="source-inline">ARRAY_AGG()</strong> with jOOQ's <strong class="source-inline">fetchArray()</strong>. In the case of <strong class="source-inline">ARRAY_AGG()</strong>, the array is built by the database, while in the case of <strong class="source-inline">fetchArray()</strong>, the array is built by jOOQ after fetching the result set.</p>
			<p>Another two aggregation functions that accept <strong class="source-inline">ORDER BY</strong> are <strong class="source-inline">JSON_ARRAYAGG()</strong> and <strong class="source-inline">XML_AGG()</strong>. You should be familiar with these functions from <a href="B16833_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>, <em class="italic">Fetching and Mapping</em>, but you can also see several simple examples in the code bundled with this section.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor271"/>COLLECT()</h2>
			<p>An interesting method<a id="_idIndexMarker1394"/> that accepts <strong class="source-inline">ORDER BY</strong> is Oracle's <strong class="source-inline">COLLECT()</strong> method. While <strong class="source-inline">ARRAY_AGG()</strong> represents the standard SQL function for aggregating data into an array, the <strong class="source-inline">COLLECT()</strong> function is specific to Oracle and produces a structurally typed array. Let's assume the following Oracle user-defined type:</p>
			<pre class="source-code">CREATE TYPE "SALARY_ARR" AS TABLE OF NUMBER(7); </pre>
			<p>The jOOQ Code Generator will produce for this user-defined type the <strong class="source-inline">SalaryArrRecord</strong> class in <strong class="source-inline">jooq.generated.udt.records</strong>. Via this UDT record, we can collect in descending order by salary and ascending order by job title the employees' salaries, as follows:</p>
			<pre class="source-code">var result = ctx.select(</pre>
			<pre class="source-code">      collect(EMPLOYEE.SALARY, SalaryArrRecord.class)</pre>
			<pre class="source-code">  .orderBy(EMPLOYEE.SALARY.asc(),            EMPLOYEE.JOB_TITLE.desc()))</pre>
			<pre class="source-code">  .from(EMPLOYEE).fetch();</pre>
			<p>jOOQ fetches <strong class="source-inline">Result&lt;Record1&lt;SalaryArrRecord&gt;&gt;</strong> via the following SQL:</p>
			<pre class="source-code">SELECT CAST(COLLECT(</pre>
			<pre class="source-code">    "CLASSICMODELS"."EMPLOYEE"."SALARY" </pre>
			<pre class="source-code">ORDER BY </pre>
			<pre class="source-code">    "CLASSICMODELS"."EMPLOYEE"."SALARY" ASC, </pre>
			<pre class="source-code">    "CLASSICMODELS"."EMPLOYEE"."JOB_TITLE" DESC) </pre>
			<pre class="source-code">     AS "CLASSICMODELS"."SALARY_ARR") </pre>
			<pre class="source-code">FROM "CLASSICMODELS"."EMPLOYEE"</pre>
			<p>By calling <strong class="source-inline">get(0).value1().toArray(Integer[]::new)</strong>, you can access the array of salaries. Or, by calling <strong class="source-inline">get(0).value1().get(5)</strong>, you can access the fifth salary. Relying on <strong class="source-inline">fetchOneInto()</strong>/<strong class="source-inline">fetchSingleInto()</strong> is also an option, as illustrated here:</p>
			<pre class="source-code">SalaryArrRecord result = ctx.select(</pre>
			<pre class="source-code">  collect(EMPLOYEE.SALARY, SalaryArrRecord.class)</pre>
			<pre class="source-code">  .orderBy(EMPLOYEE.SALARY.asc(), EMPLOYEE.JOB_TITLE.desc()))</pre>
			<pre class="source-code">  .from(EMPLOYEE)</pre>
			<pre class="source-code">  .fetchOneInto(SalaryArrRecord.class);</pre>
			<p>Now, you can access the<a id="_idIndexMarker1395"/> array of salaries as <strong class="source-inline">result.toArray(Integer[]::new)</strong>, and via <strong class="source-inline">result.get(5)</strong>, you can access the fifth salary.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor272"/>GROUP_CONCAT()</h2>
			<p>Another<a id="_idIndexMarker1396"/> cool aggregate function that accepts an <strong class="source-inline">ORDER BY</strong> clause is the <strong class="source-inline">GROUP_CONCAT()</strong> function (very popular in MySQL), useful to get the aggregated concatenation for a field. jOOQ emulates this function in Oracle, PostgreSQL, SQL Server, and other dialects that don't support it natively.   </p>
			<p>For instance, let's use <strong class="source-inline">GROUP_CONCAT()</strong> to fetch a string containing  employees' names in descending order by salary, as follows:</p>
			<pre class="source-code">ctx.select(groupConcat(concat(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">      inline(" "), EMPLOYEE.LAST_NAME))</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.SALARY.desc()).separator(";")</pre>
			<pre class="source-code">     .as("names_of_employees"))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<p>The output will be something like this: <em class="italic">Diane Murphy</em>; <em class="italic">Mary Patterson</em>; <em class="italic">Jeff Firrelli</em>; …. </p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor273"/>Oracle's KEEP() clause</h2>
			<p>Here's a quick one—have<a id="_idIndexMarker1397"/> you seen in a query an aggregate function like this: <strong class="source-inline">SUM(some_value) KEEP (DENSE_RANK FIRST ORDER BY some_date)</strong>? Or this analytic variant: <strong class="source-inline">SUM(some_value) KEEP (DENSE_RANK LAST ORDER BY some_date) OVER (PARTITION BY some_partition)</strong>?</p>
			<p>If you did, then you know that what you saw is Oracle's <strong class="source-inline">KEEP()</strong> clause at work, or—in other words—the SQL <strong class="source-inline">FIRST()</strong> and <strong class="source-inline">LAST()</strong> functions prefixed by the <strong class="source-inline">KEEP()</strong> clause for semantic clarity, and <strong class="source-inline">DENSE_RANK()</strong> for indicating that Oracle should aggregate only on Olympic rank (those rows with the maximum (<strong class="source-inline">LAST()</strong>) or minimum (<strong class="source-inline">FIRST()</strong>) dense rank with respect to a given sorting), respectively suffixed by <strong class="source-inline">ORDER BY()</strong> and, optionally, by <strong class="source-inline">OVER(PARTITION BY())</strong>. Both <strong class="source-inline">LAST()</strong> and <strong class="source-inline">FIRST()</strong> can be treated as aggregates (if you omit the <strong class="source-inline">OVER()</strong> clause) or as analytic functions. </p>
			<p>But let's have a scenario based on <strong class="source-inline">CUSTOMER</strong> and <strong class="source-inline">ORDER</strong> tables. Each customer (<strong class="source-inline">CUSTOMER.CUSTOMER_NUMBER</strong>) has one or more order, and let's assume that we want to fetch the <strong class="source-inline">ORDER.ORDER_DATE</strong> value closest to 2004-June-06 (or any other date, including the current date) for each <strong class="source-inline">CUSTOMER</strong> type. This can be easily accomplished in a query, as here:</p>
			<pre class="source-code">ctx.select(ORDER.CUSTOMER_NUMBER, max(ORDER.ORDER_DATE))</pre>
			<pre class="source-code">   .from(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_DATE.lt(LocalDate.of(2004, 6, 6)))</pre>
			<pre class="source-code">   .groupBy(ORDER.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>How about <a id="_idIndexMarker1398"/>selecting <strong class="source-inline">ORDER.SHIPPED_DATE</strong> and <strong class="source-inline">ORDER.STATUS</strong> as well? One approach could be to rely on the <strong class="source-inline">ROW_NUMBER()</strong> window function and the <strong class="source-inline">QUALIFY()</strong> clause, as shown here:</p>
			<pre class="source-code">ctx.select(ORDER.CUSTOMER_NUMBER, ORDER.ORDER_DATE, </pre>
			<pre class="source-code">      ORDER.SHIPPED_DATE, ORDER.STATUS)</pre>
			<pre class="source-code">   .from(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_DATE.lt(LocalDate.of(2004, 6, 6)))</pre>
			<pre class="source-code">   .qualify(rowNumber().over()</pre>
			<pre class="source-code">     .partitionBy(ORDER.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">       .orderBy(ORDER.ORDER_DATE.desc()).eq(1))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>As you can see in the bundled code, another approach could be to rely on <strong class="source-inline">SELECT DISTINCT ON</strong> (as <em class="italic">@dmitrygusev</em> suggested on Twitter) or on an anti-join, but if we write our query for Oracle, then most probably you'll go for the <strong class="source-inline">KEEP()</strong> clause, as follows:</p>
			<pre class="source-code">ctx.select(ORDER.CUSTOMER_NUMBER,</pre>
			<pre class="source-code">           max(ORDER.ORDER_DATE).as("ORDER_DATE"),</pre>
			<pre class="source-code">           max(ORDER.SHIPPED_DATE).keepDenseRankLastOrderBy(</pre>
			<pre class="source-code">               ORDER.SHIPPED_DATE).as("SHIPPED_DATE"),</pre>
			<pre class="source-code">           max(ORDER.STATUS).keepDenseRankLastOrderBy(</pre>
			<pre class="source-code">               ORDER.SHIPPED_DATE).as("STATUS"))</pre>
			<pre class="source-code">   .from(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_DATE.lt(LocalDate.of(2004, 6, 6)))</pre>
			<pre class="source-code">   .groupBy(ORDER.CUSTOMER_NUMBER).fetch();</pre>
			<p>Or, you could do <a id="_idIndexMarker1399"/>this by exploiting the Oracle's <strong class="source-inline">ROWID</strong> pseudo-column, as follows:  </p>
			<pre class="source-code">ctx.select(ORDER.CUSTOMER_NUMBER, ORDER.ORDER_DATE, </pre>
			<pre class="source-code">      ORDER.SHIPPED_DATE, ORDER.STATUS)</pre>
			<pre class="source-code">   .from(ORDER)</pre>
			<pre class="source-code">   .where((rowid().in(select(max((rowid()))</pre>
			<pre class="source-code">      .keepDenseRankLastOrderBy(ORDER.SHIPPED_DATE))</pre>
			<pre class="source-code">      .from(ORDER)</pre>
			<pre class="source-code">      .where(ORDER.ORDER_DATE.lt(LocalDate.of(2004, 6, 6)))</pre>
			<pre class="source-code">      .groupBy(ORDER.CUSTOMER_NUMBER)))).fetch();</pre>
			<p>You can practice these examples in the <em class="italic">AggregateFunctionsOrderBy</em> bundled code.</p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor274"/>Ordered set aggregate functions (WITHIN GROUP)</h1>
			<p><em class="italic">Ordered set aggregate functions</em> allow <a id="_idIndexMarker1400"/>operations on a set of rows sorted with <strong class="source-inline">ORDER BY</strong> via the <strong class="bold">mandatory</strong> <strong class="source-inline">WITHIN GROUP</strong> clause. Commonly, such <a id="_idIndexMarker1401"/>functions are used for performing computations that depend on a certain row ordering. Here, we can quickly mention <em class="italic">hypothetical set</em> functions such as <strong class="source-inline">RANK()</strong>, <strong class="source-inline">DENSE_RANK()</strong>, <strong class="source-inline">PERCENT_RANK()</strong>, or <strong class="source-inline">CUME_DIST()</strong>, and <em class="italic">inverse distribution functions</em> such as <strong class="source-inline">PERCENTILE_CONT()</strong>, <strong class="source-inline">PERCENTILE_DISC()</strong>, or <strong class="source-inline">MODE()</strong>.  A particular case is represented by <strong class="source-inline">LISTAGG()</strong>, which is covered at the end of this section.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor275"/>Hypothetical set functions</h2>
			<p>A hypothetical set function<a id="_idIndexMarker1402"/> calculates something for a hypothetical value (let's denote it as <strong class="source-inline">hv</strong>). In this context, <strong class="source-inline">DENSE_RANK()</strong> computes the rank of <strong class="source-inline">hv</strong> without gaps, while <strong class="source-inline">RANK()</strong> does the same thing but with gaps. <strong class="source-inline">CUME_DIST()</strong> computes the cumulative distribution of <strong class="source-inline">hv</strong> (the relative rank of a row from 1/n to 1), while <strong class="source-inline">PERCENT_RANK()</strong> computes the percent rank of <strong class="source-inline">hv</strong> (the relative rank of a row from 0 to 1).</p>
			<p>For instance, let's assume that we want to compute the rank without gaps for the hypothetical value (<em class="italic">2004</em>, <em class="italic">10000</em>), where <em class="italic">2004</em> is <strong class="source-inline">SALE.FISCAL_YEAR</strong> and <em class="italic">10000</em> is <strong class="source-inline">SALE.SALE_</strong>. Next, for the existing data, we want to obtain all ranks without gaps less than the rank of this hypothetical value. For the first part of the problem, we rely on the <strong class="source-inline">DENSE_RANK()</strong> hypothetical set function, while for the second part, on the <strong class="source-inline">DENSE_RANK()</strong> window function, as follows:</p>
			<pre class="source-code">ctx.select(SALE.EMPLOYEE_NUMBER, SALE.FISCAL_YEAR, SALE.SALE_)</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .qualify(denseRank().over()</pre>
			<pre class="source-code">    .orderBy(SALE.FISCAL_YEAR.desc(), SALE.SALE_)</pre>
			<pre class="source-code">    .le(select(denseRank(val(2004), val(10000))</pre>
			<pre class="source-code">     .withinGroupOrderBy(SALE.FISCAL_YEAR.desc(), SALE.SALE_))</pre>
			<pre class="source-code">    .from(SALE))).fetch();   </pre>
			<p>Now, let's consider another example that uses the <strong class="source-inline">PERCENT_RANK()</strong> hypothetical set function. This time, let's assume that we plan to have a salary of <em class="italic">$61,000</em> for new sales reps, but before doing that, we want to know the percentage of current sales reps having salaries higher than <em class="italic">$61,000</em>. This can be done like so:</p>
			<pre class="source-code">ctx.select(count().as("nr_of_salaries"),</pre>
			<pre class="source-code">   percentRank(val(61000d)).withinGroupOrderBy(</pre>
			<pre class="source-code">        EMPLOYEE.SALARY.desc()).mul(100).concat("%")</pre>
			<pre class="source-code">           .as("salary_percentile_rank"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.JOB_TITLE.eq("Sales Rep")).fetch();</pre>
			<p>Moreover, we want to<a id="_idIndexMarker1403"/> know the percentage of sales reps' salaries that are higher than <em class="italic">$61,000</em>. For this, we need the distinct salaries, as shown here:</p>
			<pre class="source-code">ctx.select(count().as("nr_of_salaries"),</pre>
			<pre class="source-code">    percentRank(val(61000d)).withinGroupOrderBy(</pre>
			<pre class="source-code">    field(name("t", "salary")).desc()).mul(100).concat("%")</pre>
			<pre class="source-code">          .as("salary_percentile_rank"))</pre>
			<pre class="source-code">   .from(selectDistinct(EMPLOYEE.SALARY.as("salary"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.JOB_TITLE.eq("Sales Rep"))     </pre>
			<pre class="source-code">   .asTable("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can practice these examples next to other <strong class="source-inline">RANK()</strong> and <strong class="source-inline">CUME_DIST()</strong> hypothetical set functions in the <em class="italic">OrderedSetAggregateFunctions</em> bundled code.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor276"/>Inverse distribution functions</h2>
			<p>Briefly, the inverse distribution functions<a id="_idIndexMarker1404"/> compute <em class="italic">percentiles</em>. There are two distribution models: a discrete model (computed via <strong class="source-inline">PERCENTILE_DISC()</strong>) and a continuous model (computed via <strong class="source-inline">PERCENTILE_CONT()</strong>).</p>
			<h3>PERCENTILE_DISC() and PERCENTILE_CONT()</h3>
			<p>But what does it actually mean to compute <em class="italic">percentiles</em>? Loosely speaking, consider a certain percent, <strong class="source-inline">P</strong> (this percent is a float value between 0 inclusive and 1 inclusive), and an ordering field, <strong class="source-inline">F</strong>. In <a id="_idIndexMarker1405"/>this context, the percentile computation represents the<a id="_idIndexMarker1406"/> value below which <strong class="source-inline">P</strong> percent of the <strong class="source-inline">F</strong> values fall.</p>
			<p>For instance, let's consider the <strong class="source-inline">SALES</strong> table, and we want to find the 25<span class="superscript">th</span> percentile sale. In this case, <strong class="source-inline">P</strong> = 0.25, and the ordering field is <strong class="source-inline">SALE.SALE_</strong>. Applying <strong class="source-inline">PERCENTILE_DISC()</strong> and <strong class="source-inline">PERCENTILE_CONT()</strong> results in this query:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code">    percentileDisc(0.25)</pre>
			<pre class="source-code">      .withinGroupOrderBy(SALE.SALE_).as("pd - 0.25"),</pre>
			<pre class="source-code">    percentileCont(0.25)</pre>
			<pre class="source-code">      .withinGroupOrderBy(SALE.SALE_).as("pc - 0.25"))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In the bundled code, you can see this query extended for the 50<span class="superscript">th</span>, 75<span class="superscript">th</span>, and 100<span class="superscript">th</span> percentile. The resulting value (for instance, 2974.43) represents the sale below which 25% of the sales fall. In this case, <strong class="source-inline">PERCENTILE_DISC()</strong> and <strong class="source-inline">PERCENTILE_CONT()</strong> return the same value (2974.43), but this is not always the case. Remember that <strong class="source-inline">PERCENTILE_DISC()</strong> works on a discrete model, while <strong class="source-inline">PERCENTILE_CONT()</strong> works on a continuous model. In other words, if there is no value (sale) in the sales (also referred to as population) that fall exactly in the specified percentile, <strong class="source-inline">PERCENTILE_CONT()</strong> must interpolate it assuming continuous distribution. Basically, <strong class="source-inline">PERCENTILE_CONT()</strong> interpolates the value (sale) from the two values (sales) that are immediately after and before the needed one. For instance, if we repeat the previous example for the 11<span class="superscript">th</span> percentile, then <strong class="source-inline">PERCENTILE_DISC()</strong> returns 1676.14, which is an existent sale, while <strong class="source-inline">PERCENTILE_CONT()</strong> returns 1843.88, which is an interpolated value that doesn't exist in the database.</p>
			<p>While Oracle supports <strong class="source-inline">PERCENTILE_DISC()</strong> and <strong class="source-inline">PERCENTILE_CONT()</strong> as ordered set aggregate<a id="_idIndexMarker1407"/> functions and<a id="_idIndexMarker1408"/> window function variants, PostgreSQL supports them only as ordered set aggregate functions, SQL Server supports only the window function variants, and MySQL doesn't support them at all. Emulating them is not quite simple, but this great article by Lukas Eder is a must-read in this direction: <a href="https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/">https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/</a>.</p>
			<p>Now, let's see an example of using <strong class="source-inline">PERCENTILE_DISC()</strong> as the window function variant and <strong class="source-inline">PERCENTILE_CONT()</strong> as the ordered set aggregate function. This time, the focus is on <strong class="source-inline">EMPLOYEE.SALARY</strong>. First, we want to compute the 50<span class="superscript">th</span> percentile of salaries per office via <strong class="source-inline">PERCENTILE_DISC()</strong>. Second, we want to keep only those 50<span class="superscript">th</span> percentiles less than the general 50<span class="superscript">th</span> percentile calculated via <strong class="source-inline">PERCENTILE_CONT()</strong>. The code is illustrated in the following snippet:</p>
			<pre class="source-code">ctx.select().from(</pre>
			<pre class="source-code">  select(OFFICE.OFFICE_CODE, OFFICE.CITY, OFFICE.COUNTRY,</pre>
			<pre class="source-code">    EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, EMPLOYEE.SALARY,</pre>
			<pre class="source-code">    percentileDisc(0.5).withinGroupOrderBy(EMPLOYEE.SALARY)</pre>
			<pre class="source-code">    .over().partitionBy(OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code">    .as("percentile_disc"))</pre>
			<pre class="source-code">  .from(OFFICE)</pre>
			<pre class="source-code">  .join(EMPLOYEE)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE)).asTable("t"))</pre>
			<pre class="source-code">   .where(field(name("t", "percentile_disc"))</pre>
			<pre class="source-code">     .le(select(percentileCont(0.5)</pre>
			<pre class="source-code">       .withinGroupOrderBy(EMPLOYEE.SALARY))</pre>
			<pre class="source-code">       .from(EMPLOYEE))).fetch();</pre>
			<p>You can practice these examples in the <em class="italic">OrderedSetAggregateFunctions</em> bundled code.</p>
			<h3>The MODE() function</h3>
			<p>Mainly, the <strong class="source-inline">MODE()</strong> function<a id="_idIndexMarker1409"/> works on a set of values to produce a result (referred to as the <em class="italic">mode</em>) representing the value that appears with the greatest frequency. The <strong class="source-inline">MODE()</strong> function comes in two flavors, as outlined here:</p>
			<ul>
				<li><strong class="source-inline">MODE(field)</strong> aggregate function</li>
				<li><strong class="source-inline">MODE WITHIN GROUP (ORDER BY [order clause])</strong> ordered set aggregate function</li>
			</ul>
			<p>If multiple results (modes) are available, then <strong class="source-inline">MODE()</strong> returns only one value. If there is a given ordering, then the first value will be chosen. </p>
			<p>The <strong class="source-inline">MODE()</strong> aggregate function is emulated by jOOQ in PostgreSQL and Oracle and is not supported in MySQL and SQL Server. For instance, let's assume that we want to find out in which month of the year we have the most sales, and for this, we may come up with the following query (notice that an explicit <strong class="source-inline">ORDER BY</strong> clause for <strong class="source-inline">MODE()</strong> is not allowed):</p>
			<pre class="source-code">ctx.select(mode(SALE.FISCAL_MONTH).as("fiscal_month"))</pre>
			<pre class="source-code">   .from(SALE).fetch();</pre>
			<p>Running this query in PostgreSQL reveals that jOOQ emulates the <strong class="source-inline">MODE()</strong> aggregate function via the ordered set aggregate function, which is supported by PostgreSQL:</p>
			<pre class="source-code">SELECT MODE() WITHIN GROUP (ORDER BY </pre>
			<pre class="source-code"> "public"."sale"."fiscal_month") AS "fiscal_month" </pre>
			<pre class="source-code">FROM "public"."sale"</pre>
			<p>In this case, if multiple modes are available, then the first one is returned with respect to the ascending ordering. On the other hand, for the Oracle case, jOOQ uses the <strong class="source-inline">STATS_MODE()</strong> function, as follows:</p>
			<pre class="source-code">SELECT </pre>
			<pre class="source-code">  STATS_MODE("CLASSICMODELS"."SALE"."FISCAL_MONTH")   </pre>
			<pre class="source-code">        "fiscal_month" FROM "CLASSICMODELS"."SALE"</pre>
			<p>In the following case, there is no ordering in the generated SQL, and if multiple modes are available, then only one is returned. On the other hand, the <strong class="source-inline">MODE()</strong> ordered set aggregate function is supported only by PostgreSQL:</p>
			<pre class="source-code">ctx.select(mode().withinGroupOrderBy(</pre>
			<pre class="source-code">       SALE.FISCAL_MONTH.desc()).as("fiscal_month"))</pre>
			<pre class="source-code">   .from(SALE).fetch();</pre>
			<p>If multiple results (modes) are available, then <strong class="source-inline">MODE()</strong> returns only one value representing the highest value (in this particular case, the month closest to December inclusive) since we have used a descending order.</p>
			<p>Nevertheless, how to return all modes (if more are available)? Commonly, statisticians refer to a bimodal distribution if two modes are available, to a trimodal distribution if three modes are <a id="_idIndexMarker1410"/>available, and so on. Emulating <strong class="source-inline">MODE()</strong> to return all modes can be done in several ways. Here is one way (in the bundled code, you can see one more):</p>
			<pre class="source-code">ctx.select(SALE.FISCAL_MONTH)</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.FISCAL_MONTH)</pre>
			<pre class="source-code">   .having(count().ge(all(select(count())</pre>
			<pre class="source-code">     .from(SALE)</pre>
			<pre class="source-code">     .groupBy(SALE.FISCAL_MONTH))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But having 1,000 cases where the value of <strong class="source-inline">X</strong> is <strong class="source-inline">'foo'</strong> and 999 cases where the value is <strong class="source-inline">'buzz'</strong>, <strong class="source-inline">MODE()</strong> is <strong class="source-inline">'foo'</strong>. By adding two more instances of <strong class="source-inline">'buzz'</strong>, <strong class="source-inline">MODE()</strong> switches to <strong class="source-inline">'buzz'</strong>. Maybe a good idea would be to allow for some variation in the values via a percent. In other words, the emulation of <strong class="source-inline">MODE()</strong> using a percentage of the total number of<a id="_idIndexMarker1411"/> occurrences can be done like so (here, 75%):</p>
			<pre class="source-code">ctx.select(avg(ORDERDETAIL.QUANTITY_ORDERED))</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .groupBy(ORDERDETAIL.QUANTITY_ORDERED)</pre>
			<pre class="source-code">   .having(count().ge(all(select(count().mul(0.75))</pre>
			<pre class="source-code">      .from(ORDERDETAIL)</pre>
			<pre class="source-code">      .groupBy(ORDERDETAIL.QUANTITY_ORDERED))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can practice these examples in the <em class="italic">OrderedSetAggregateFunctions</em> bundled code.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor277"/>LISTAGG()</h2>
			<p>The last <a id="_idIndexMarker1412"/>ordered set aggregate function discussed in this section is <strong class="source-inline">LISTAGG()</strong>. This function is used for aggregating a given list of values into a string delimited via a separator (for instance, it is useful for producing CSV files). The SQL standard imposes the presence of the separator and <strong class="source-inline">WITHIN GROUP</strong> clause. Nevertheless, some databases treat these standards as being optional and apply certain defaults or expose an undefined behavior if the <strong class="source-inline">WITHIN GROUP</strong> clause is omitted. jOOQ provides <strong class="source-inline">listAgg(Field&lt;?&gt; field)</strong> having no explicit separator, and <strong class="source-inline">listAgg(Field&lt;?&gt; field, String separator)</strong>. The <strong class="source-inline">WITHIN GROUP</strong> clause cannot be omitted. jOOQ emulates this function for dialects that don't support it, such as MySQL (emulates it via <strong class="source-inline">GROUP_CONCAT()</strong>, so a comma is a default separator), PostgreSQL (emulates it via <strong class="source-inline">STRING_AGG()</strong>, so no default separator), and SQL Server (same as in PostgreSQL) via proprietary syntax that offers similar functionality. Oracle supports <strong class="source-inline">LISTAGG()</strong> and there is no default separator.</p>
			<p>Here are two simple examples with and without an explicit separator that produces a list of employees names' in ascending order by salary as <strong class="source-inline">Result&lt;Record1&lt;String&gt;&gt;</strong>:</p>
			<pre class="source-code">ctx.select(listAgg(EMPLOYEE.FIRST_NAME)</pre>
			<pre class="source-code">   .withinGroupOrderBy(EMPLOYEE.SALARY).as("listagg"))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<pre class="source-code">         </pre>
			<pre class="source-code">ctx.select(listAgg(EMPLOYEE.FIRST_NAME, ";")</pre>
			<pre class="source-code">   .withinGroupOrderBy(EMPLOYEE.SALARY).as("listagg"))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<p>Fetching directly, the <strong class="source-inline">String</strong> can be achieved via <strong class="source-inline">fetchOneInto(String.class)</strong>.</p>
			<p><strong class="source-inline">LISTAGG()</strong> can be used in combination with <strong class="source-inline">GROUP BY</strong> and <strong class="source-inline">ORDER BY</strong>, as in the following example <a id="_idIndexMarker1413"/>that fetches a list of employees per job title:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.JOB_TITLE, </pre>
			<pre class="source-code">      listAgg(EMPLOYEE.FIRST_NAME, ",")</pre>
			<pre class="source-code">   .withinGroupOrderBy(EMPLOYEE.FIRST_NAME).as("employees"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .groupBy(EMPLOYEE.JOB_TITLE)</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.JOB_TITLE).fetch();</pre>
			<p>Moreover, <strong class="source-inline">LISTAGG()</strong> supports a window function variant as well, as shown here:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.JOB_TITLE,       listAgg(EMPLOYEE.SALARY, ",")</pre>
			<pre class="source-code">   .withinGroupOrderBy(EMPLOYEE.SALARY)</pre>
			<pre class="source-code">      .over().partitionBy(EMPLOYEE.JOB_TITLE))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<p>And here is a fun fact from Lukas Eder: "<strong class="source-inline">LISTAGG()</strong> <em class="italic">is not a true ordered set aggregate function. It should use the same </em><strong class="source-inline">ORDER BY</strong> <em class="italic">syntax as</em> <strong class="source-inline">ARRAY_AGG</strong>." See the discussion here: <a href="https://twitter.com/lukaseder/status/1237662156553883648">https://twitter.com/lukaseder/status/1237662156553883648</a>.</p>
			<p>You can practice these examples and more in <em class="italic">OrderedSetAggregateFunctions</em>.</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor278"/>Grouping, filtering, distinctness, and functions</h1>
			<p>In this section, <em class="italic">grouping</em> refers to the usage of <strong class="source-inline">GROUP BY</strong> with functions, <em class="italic">filtering</em> refers to the usage of the <strong class="source-inline">FILTER</strong> clause with functions, and <em class="italic">distinctness</em> refers to aggregate functions on distinct values.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor279"/>Grouping</h2>
			<p>As you already know, <strong class="source-inline">GROUP BY</strong> is a SQL <a id="_idIndexMarker1414"/>clause useful for arranging rows in <a id="_idIndexMarker1415"/>groups via one (or more) column given as an argument. Rows that land in a group have matching values in the given columns/expressions. Typical use cases apply aggregate functions on groups of data produced by <strong class="source-inline">GROUP BY</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Especially when dealing with multiple dialects, it is correct to list all non-aggregated columns from the <strong class="source-inline">SELECT</strong> clause in the <strong class="source-inline">GROUP BY</strong> clause. This way, you avoid potentially indeterminate/random behavior and errors across dialects (some of them will not ask you to do this (for example, MySQL), while others will (for example, Oracle)).</p>
			<p>jOOQ supports <strong class="source-inline">GROUP BY</strong> in all dialects, therefore here is an example of fetching offices (<strong class="source-inline">OFFICE</strong>) having fewer than three employees:</p>
			<pre class="source-code">ctx.select(OFFICE.OFFICE_CODE, OFFICE.CITY, </pre>
			<pre class="source-code">      nvl(groupConcat(EMPLOYEE.FIRST_NAME), "N/A").as("name"))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .leftJoin(EMPLOYEE)</pre>
			<pre class="source-code">      .on(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE))</pre>
			<pre class="source-code">   .groupBy(OFFICE.OFFICE_CODE, OFFICE.CITY)</pre>
			<pre class="source-code">   .having(count().lt(3)).fetch();</pre>
			<p>Here is another example that <a id="_idIndexMarker1416"/>computes the sum of sales per employee per year, and after that, it computes the average of these sums per employee:</p>
			<pre class="source-code">ctx.select(field(name("t", "en")), </pre>
			<pre class="source-code">       avg(field(name("t", "ss"), Double.class))</pre>
			<pre class="source-code">         .as("sale_avg"))</pre>
			<pre class="source-code">   .from(ctx.select(SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">      SALE.FISCAL_YEAR, sum(SALE.SALE_))</pre>
			<pre class="source-code">       .from(SALE)</pre>
			<pre class="source-code">       .groupBy(SALE.EMPLOYEE_NUMBER, SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">       .asTable("t", "en", "fy", "ss"))</pre>
			<pre class="source-code">    .groupBy(field(name("t", "en"))).fetch();</pre>
			<p>You can find more<a id="_idIndexMarker1417"/> examples of using <strong class="source-inline">GROUP BY</strong> in <em class="italic">GroupByDistinctFilter</em>.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor280"/>Filtering</h2>
			<p>If we want to refine a query <a id="_idIndexMarker1418"/>by applying aggregations against a limited set of the values in a column, then we can use <strong class="source-inline">CASE</strong> expressions, as in this example, which sum the salaries of sales reps and the rest of the employees:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.SALARY,</pre>
			<pre class="source-code"> (sum(case_().when(EMPLOYEE.JOB_TITLE.eq("Sales Rep"), 1)</pre>
			<pre class="source-code">    .else_(0))).as("Sales Rep"),</pre>
			<pre class="source-code"> (sum(case_().when(EMPLOYEE.JOB_TITLE.ne("Sales Rep"), 1)</pre>
			<pre class="source-code">    .else_(0))).as("Others"))</pre>
			<pre class="source-code">   .from(EMPLOYEE).groupBy(EMPLOYEE.SALARY).fetch();</pre>
			<p>As you can see, <strong class="source-inline">CASE</strong> is flexible but it's a bit tedious. A more straightforward solution is represented by the <strong class="source-inline">FILTER</strong> clause, exposed <a id="_idIndexMarker1419"/>by jOOQ via the <strong class="source-inline">filterWhere()</strong> method, and emulated for every dialect that doesn't support it (usually via <strong class="source-inline">CASE</strong> expressions). The <a id="_idIndexMarker1420"/>previous query can be expressed via <strong class="source-inline">FILTER</strong>, as follows:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.SALARY,</pre>
			<pre class="source-code"> (count().filterWhere(EMPLOYEE.JOB_TITLE</pre>
			<pre class="source-code">     .eq("Sales Rep"))).as("Sales Rep"),</pre>
			<pre class="source-code"> (count().filterWhere(EMPLOYEE.JOB_TITLE</pre>
			<pre class="source-code">     .ne("Sales Rep"))).as("Others"))</pre>
			<pre class="source-code">  .from(EMPLOYEE)</pre>
			<pre class="source-code">  .groupBy(EMPLOYEE.SALARY).fetch();</pre>
			<p>Or, here is an example of removing <strong class="source-inline">NULL</strong> values for <strong class="source-inline">ARRAY_AGG()</strong>:</p>
			<pre class="source-code">ctx.select(arrayAgg(DEPARTMENT.ACCOUNTS_RECEIVABLE)</pre>
			<pre class="source-code">   .filterWhere(DEPARTMENT.ACCOUNTS_RECEIVABLE.isNotNull()))</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetch();</pre>
			<p>Another use case for <strong class="source-inline">FILTER</strong> is related to pivoting rows to columns. For instance, check out this query, which produces the sales per month and per year:</p>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR, SALE.FISCAL_MONTH,   </pre>
			<pre class="source-code">      sum(SALE.SALE_))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.FISCAL_YEAR, SALE.FISCAL_MONTH).fetch();</pre>
			<p>The query returns the correct result but in an unexpected form. Its vertical form having one value per row is not quite readable for users. Most probably, a user will be more familiar with a form having one row per year and a dedicated column per month. So, turning the rows of a year into columns should solve the problem, and this can be accomplished in several ways, including the <strong class="source-inline">FILTER</strong> clause, as shown here:</p>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR,</pre>
			<pre class="source-code">     sum(SALE.SALE_).filterWhere(SALE.FISCAL_MONTH.eq(1))</pre>
			<pre class="source-code">          .as("Jan_sales"),</pre>
			<pre class="source-code">     sum(SALE.SALE_).filterWhere(SALE.FISCAL_MONTH.eq(2))</pre>
			<pre class="source-code">          .as("Feb_sales"),</pre>
			<pre class="source-code">     ...</pre>
			<pre class="source-code">     sum(SALE.SALE_).filterWhere(SALE.FISCAL_MONTH.eq(12))</pre>
			<pre class="source-code">          .as("Dec_sales"))</pre>
			<pre class="source-code">   .from(SALE).groupBy(SALE.FISCAL_YEAR).fetch();        </pre>
			<p>The <strong class="source-inline">FILTER</strong> clause can be<a id="_idIndexMarker1421"/> considered with aggregate functions used as window functions as<a id="_idIndexMarker1422"/> well. In such cases, <strong class="source-inline">filterWhere()</strong> comes between the aggregate function and the <strong class="source-inline">OVER()</strong> clause. For instance, the following query sums the salaries of employees per office only for employees that don't get a commission:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">       EMPLOYEE.SALARY, OFFICE.OFFICE_CODE, OFFICE.CITY,   </pre>
			<pre class="source-code">       OFFICE.COUNTRY, sum(EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .filterWhere(EMPLOYEE.COMMISSION.isNull())</pre>
			<pre class="source-code">    .over().partitionBy(OFFICE.OFFICE_CODE))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .join(OFFICE)</pre>
			<pre class="source-code">    .on(EMPLOYEE.OFFICE_CODE.eq(OFFICE.OFFICE_CODE)).fetch();</pre>
			<p>Moreover, the <strong class="source-inline">FILTER</strong> clause can be used with ordered set aggregate functions. This way, we can remove rows that don't pass the filter before the aggregation takes place. Here is an example of filtering employees having salaries higher than <em class="italic">$80,000</em> and collecting the result via <strong class="source-inline">LISTAGG()</strong>:</p>
			<pre class="source-code">ctx.select(listAgg(EMPLOYEE.FIRST_NAME)</pre>
			<pre class="source-code">   .withinGroupOrderBy(EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .filterWhere(EMPLOYEE.SALARY.gt(80000)).as("listagg"))</pre>
			<pre class="source-code">   .from(EMPLOYEE).fetch();</pre>
			<p>Since you are here, I am sure that you'll love this article by Lukas Eder about calculating multiple aggregate functions in a single query: <a href="https://blog.jooq.org/2017/04/20/how-to-calculate-multiple-aggregate-functions-in-a-single-query/">https://blog.jooq.org/2017/04/20/how-to-calculate-multiple-aggregate-functions-in-a-single-query/</a>.</p>
			<p>You can practice the examples and more in the <em class="italic">GroupByDistinctFilter</em> bundled code.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor281"/>Distinctness</h2>
			<p>Most aggregate functions come with a <a id="_idIndexMarker1423"/>variant for applying them to a distinct set of values. While you can find all of them in the jOOQ documentation, let's quickly list here <strong class="source-inline">countDistinct()</strong>, <strong class="source-inline">sumDistinct()</strong>, <strong class="source-inline">avgDistinct()</strong>, <strong class="source-inline">productDistinct()</strong>, <strong class="source-inline">groupConcatDistinct</strong><strong class="source-inline">()</strong>, <strong class="source-inline">arrayAggDistinct()</strong>, and <strong class="source-inline">collectDistinct()</strong>. For completeness' sake, we also have <strong class="source-inline">minDistinct()</strong> and <strong class="source-inline">maxDistinct()</strong>. When a function is not supported by jOOQ, we can still call it via the general <strong class="source-inline">aggregateDistinct()</strong> function.</p>
			<p>Here is an example of using <strong class="source-inline">countDistinct()</strong> for fetching employees having sales in at least 3 distinct years:</p>
			<pre class="source-code">ctx.select(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .having(countDistinct(SALE.FISCAL_YEAR).gt(3)).fetch();</pre>
			<p>More examples are available in the <em class="italic">GroupByDistinctFilter</em> bundled code.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor282"/>Grouping sets</h1>
			<p>For those not<a id="_idIndexMarker1424"/> familiar with <em class="italic">grouping sets</em>, let's briefly follow a scenario meant to quickly introduce and cover this notion. Consider the following screenshot:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B16833_Figure_13.24.jpg" alt="Figure 13.24 – Two queries using a grouping set each&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.24 – Two queries using a grouping set each</p>
			<p>The <strong class="source-inline">groupBy(SALE.EMPLOYEE_NUMBER)</strong> construction from the left-hand side (respectively, <strong class="source-inline">groupBy(SALE.FISCAL_YEAR)</strong> from the right-hand side) is referred to as a <em class="italic">grouping set</em>. A<a id="_idIndexMarker1425"/> grouping set can contain none (empty grouping set), one, or more columns. In our case, both grouping sets contain one column.</p>
			<p>Getting a unified result set of these two result sets containing the aggregated data of both grouping sets can be done via the <strong class="source-inline">UNION ALL</strong> operator, as illustrated here:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B16833_Figure_13.25.jpg" alt="Figure 13.25 – Union grouping sets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.25 – Union grouping sets</p>
			<p>But, as you can see, even<a id="_idIndexMarker1426"/> for only two grouping sets, this query is quite lengthy. Moreover, it needs to resolve two <strong class="source-inline">SELECT</strong> statements before combining their results into a single result set. Here is where the <strong class="source-inline">GROUPING SETS(column_list)</strong> clause of <strong class="source-inline">GROUP BY</strong> enters the scene. This clause represents a handy shorthand for a series of <strong class="source-inline">UNION</strong>-ed queries, and it can be used in the following example of rewriting the previous query:</p>
			<pre class="source-code">ctx.select(SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">           SALE.FISCAL_YEAR, sum(SALE.SALE_))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(groupingSets(</pre>
			<pre class="source-code">            SALE.EMPLOYEE_NUMBER, SALE.FISCAL_YEAR))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Cool, right?! Nevertheless, there is an issue that should be considered. <strong class="source-inline">GROUPING SETS()</strong> will generate <strong class="source-inline">NULL</strong> values for each dimension at the subtotal levels. In other words, it is quite hard to distinguish between a real <strong class="source-inline">NULL</strong> value (present in the original data) and a generated <strong class="source-inline">NULL</strong> value. But this job is the responsibility of the <strong class="source-inline">GROUPING()</strong> function, which returns 0 for <strong class="source-inline">NULL</strong> values in the original data and, respectively, 1 for generated <strong class="source-inline">NULL</strong> values that indicate a subtotal.</p>
			<p>For instance, if we write a<a id="_idIndexMarker1427"/> query in the <strong class="source-inline">groupBy(groupingSets(OFFICE.CITY, OFFICE.COUNTRY))</strong> clause, then we will need to distinguish between generated <strong class="source-inline">NULL</strong> values and <strong class="source-inline">NULL</strong> values of <strong class="source-inline">OFFICE.CITY</strong> and, respectively, <strong class="source-inline">OFFICE.COUNTRY</strong>. By using <strong class="source-inline">GROUPING()</strong> to form a condition of a <strong class="source-inline">CASE</strong> expression, we can achieve this, like so:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code">  case_().when(grouping(OFFICE.CITY).eq(1), "{generated}")</pre>
			<pre class="source-code">    .else_(OFFICE.CITY).as("city"),</pre>
			<pre class="source-code">  case_().when(grouping(OFFICE.COUNTRY).eq(1), "{generated}")</pre>
			<pre class="source-code">    .else_(OFFICE.COUNTRY).as("country"),</pre>
			<pre class="source-code">  sum(OFFICE.INTERNAL_BUDGET))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .groupBy(groupingSets(OFFICE.CITY, OFFICE.COUNTRY))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In this query, we replaced every generated <strong class="source-inline">NULL</strong> value with the text <strong class="source-inline">{generated}</strong>, while the <strong class="source-inline">NULL</strong> values on the original data will be fetched as <strong class="source-inline">NULL</strong> values. So, we now have a clear picture of <strong class="source-inline">NULL</strong> values' provenience, as illustrated here:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B16833_Figure_13.26.jpg" alt="Figure 13.26 – No grouping (left-hand side) versus grouping (right-hand side)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.26 – No grouping (left-hand side) versus grouping (right-hand side)</p>
			<p>Most probably, <strong class="source-inline">{null}</strong> and <strong class="source-inline">{generated}</strong> will not be very attractive for our clients, so we can tune this query a little bit to be more friendly by replacing <strong class="source-inline">{null}</strong> with <strong class="source-inline">"Unspecified"</strong> and <strong class="source-inline">{generated}</strong> with  <strong class="source-inline">"-"</strong>, like so:</p>
			<pre class="source-code">ctx.select(case_().when(grouping(OFFICE.CITY).eq(1), "-")</pre>
			<pre class="source-code">  .else_(isnull(OFFICE.CITY, "Unspecified")).as("city"),</pre>
			<pre class="source-code"> case_().when(grouping(OFFICE.COUNTRY).eq(1), "-")</pre>
			<pre class="source-code">  .else_(isnull(OFFICE.COUNTRY, "Unspecified")).as("country"),</pre>
			<pre class="source-code">  sum(OFFICE.INTERNAL_BUDGET))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .groupBy(groupingSets(OFFICE.CITY, OFFICE.COUNTRY))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>Next to <strong class="source-inline">GROUPING SETS()</strong>, we have <strong class="source-inline">ROLLUP</strong> and <strong class="source-inline">CUBE</strong>. These two extensions of the <strong class="source-inline">GROUP BY</strong> clause are syntactic sugar of <strong class="source-inline">GROUPING SETS()</strong>. </p>
			<p>The <strong class="source-inline">ROLLUP</strong> group is a series of grouping sets. For instance, <strong class="source-inline">GROUP BY ROLLUP (x, y, z)</strong> is equivalent to <strong class="source-inline">GROUP BY GROUPING SETS ((x, y, z), (x, y), (x), ())</strong>. <strong class="source-inline">ROLLUP</strong> is typically applied for aggregates of hierarchical data such as sales by year &gt; quarter &gt; month &gt; week, or offices internal budget per territory &gt; state &gt; country &gt; city, as<a id="_idIndexMarker1428"/> shown here:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code">   case_().when(grouping(OFFICE.TERRITORY).eq(1), "{generated}")</pre>
			<pre class="source-code">     .else_(OFFICE.TERRITORY).as("territory"),</pre>
			<pre class="source-code">   case_().when(grouping(OFFICE.STATE).eq(1), "{generated}")</pre>
			<pre class="source-code">     .else_(OFFICE.STATE).as("state"),</pre>
			<pre class="source-code">   case_().when(grouping(OFFICE.COUNTRY).eq(1), "{generated}")</pre>
			<pre class="source-code">     .else_(OFFICE.COUNTRY).as("country"),</pre>
			<pre class="source-code">   case_().when(grouping(OFFICE.CITY).eq(1), "{generated}")</pre>
			<pre class="source-code">     .else_(OFFICE.CITY).as("city"),</pre>
			<pre class="source-code">   sum(OFFICE.INTERNAL_BUDGET))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .where(OFFICE.COUNTRY.eq("USA"))</pre>
			<pre class="source-code">   .groupBy(rollup(OFFICE.TERRITORY, OFFICE.STATE, </pre>
			<pre class="source-code">                   OFFICE.COUNTRY, OFFICE.CITY)).fetch();</pre>
			<p>And the output is shown here:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B16833_Figure_13.27.jpg" alt="Figure 13.27 – ROLLUP output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.27 – ROLLUP output</p>
			<p>As with <strong class="source-inline">ROLLUP</strong>, a <strong class="source-inline">CUBE</strong> group<a id="_idIndexMarker1429"/> can also be perceived as a series of grouping sets. However, <strong class="source-inline">CUBE</strong> calculates all permutations of the cubed grouping expression along with the grand total. So, for <em class="italic">n</em> elements, <strong class="source-inline">CUBE</strong> produces 2<span class="superscript">n</span> grouping sets. For instance <strong class="source-inline">GROUP BY CUBE (x, y, x)</strong> is equivalent to <strong class="source-inline">GROUP BY GROUPING SETS ((x, y, z), (x, y), (x, z), (y, z), (x), (y), (z), ())</strong>.</p>
			<p>Let's apply <strong class="source-inline">CUBE</strong> for computing the sum of the internal budget for offices by state, country, and city. The query is shown here:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code"> case_().when(grouping(OFFICE.STATE).eq(1), "{generated}")</pre>
			<pre class="source-code">  .else_(OFFICE.STATE).as("state"),</pre>
			<pre class="source-code"> case_().when(grouping(OFFICE.COUNTRY).eq(1), "{generated}")</pre>
			<pre class="source-code">  .else_(OFFICE.COUNTRY).as("country"),</pre>
			<pre class="source-code"> case_().when(grouping(OFFICE.CITY).eq(1), "{generated}")</pre>
			<pre class="source-code">  .else_(OFFICE.CITY).as("city"),</pre>
			<pre class="source-code"> sum(OFFICE.INTERNAL_BUDGET))</pre>
			<pre class="source-code">  .from(OFFICE)</pre>
			<pre class="source-code">  .where(OFFICE.COUNTRY.eq("USA"))</pre>
			<pre class="source-code">  .groupBy(cube(OFFICE.STATE, OFFICE.COUNTRY, OFFICE.CITY))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>Finally, let's talk about the <strong class="source-inline">GROUPING_ID()</strong> function. This function computes the decimal equivalent of the binary value obtained by concatenating the values returned by the <strong class="source-inline">GROUPING()</strong> functions<a id="_idIndexMarker1430"/> applied to all the columns of the <strong class="source-inline">GROUP BY</strong> clause. Here is an example of using <strong class="source-inline">GROUPING_ID()</strong> via jOOQ <strong class="source-inline">groupingId()</strong>:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code"> case_().when(grouping(OFFICE.TERRITORY).eq(1), "{generated}")</pre>
			<pre class="source-code">  .else_(OFFICE.TERRITORY).as("territory"),</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> case_().when(grouping(OFFICE.CITY).eq(1), "{generated}")</pre>
			<pre class="source-code">  .else_(OFFICE.CITY).as("city"),</pre>
			<pre class="source-code"> groupingId(OFFICE.TERRITORY, OFFICE.STATE, OFFICE.COUNTRY, </pre>
			<pre class="source-code">            OFFICE.CITY).as("grouping_id"),</pre>
			<pre class="source-code"> sum(OFFICE.INTERNAL_BUDGET))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .where(OFFICE.COUNTRY.eq("USA"))</pre>
			<pre class="source-code">   .groupBy(rollup(OFFICE.TERRITORY, OFFICE.STATE, </pre>
			<pre class="source-code">                   OFFICE.COUNTRY, OFFICE.CITY))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The following screenshot shows a sample output:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B16833_Figure_13.28.jpg" alt="Figure 13.28 – GROUPING_ID() output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.28 – GROUPING_ID() output</p>
			<p><strong class="source-inline">GROUPING_ID()</strong> can <a id="_idIndexMarker1431"/>also be used in <strong class="source-inline">HAVING</strong> for creating conditions, as follows:</p>
			<pre class="source-code">… .having(groupingId(OFFICE.TERRITORY, </pre>
			<pre class="source-code">    OFFICE.STATE, OFFICE.COUNTRY, OFFICE.CITY).eq(3))…</pre>
			<p>The complete query is available in the <em class="italic">GroupingRollupCube</em> bundled code.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor283"/>Summary</h1>
			<p>Working with SQL functions is such fun! They truly boost the SQL world and allow us to solve so many problems during data manipulation. As you saw in this chapter, jOOQ provides comprehensive support to SQL functions, covering regular and aggregate functions to the mighty window functions, ordered set aggregate functions (<strong class="source-inline">WITHIN GROUP</strong>), and so on. While we're on this topic, allow me to recommend the following article as a great read: <a href="https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/">https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/</a>. In the next chapter, we tackle virtual tables (vtables).</p>
		</div>
	</body></html>