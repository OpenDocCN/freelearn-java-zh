- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Optimizing Your Database and SQL Queries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的数据库和SQL查询
- en: Databases are a key component of large software systems. These systems constantly
    retrieve and update data using database connections and queries. The scale of
    data in modern systems is extremely large, resulting in more data to query, update,
    and display. This increased scale can result in negative performance issues for
    our Java application, underscoring the significance of ensuring our databases
    and queries are optimized.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是大型软件系统的一个关键组件。这些系统不断使用数据库连接和查询检索和更新数据。现代系统中的数据规模极其庞大，导致需要查询、更新和显示的数据更多。这种增加的规模可能导致我们的Java应用程序出现性能问题，强调了确保我们的数据库和查询得到优化的重要性。
- en: This chapter examines critical database design concepts, including database
    schemas, indexing strategies, and data partitioning techniques. Database queries
    are also examined, with a specific focus on **Structured Query Language** (**SQL**)
    queries. Our coverage of query optimizations includes best practices for writing
    efficient queries, query execution planning, and advanced SQL techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了关键的数据库设计概念，包括数据库模式、索引策略和数据分区技术。数据库查询也被检查，特别关注**结构化查询语言**（**SQL**）查询。我们对查询优化的覆盖包括编写高效查询的最佳实践、查询执行计划和高级SQL技术。
- en: The chapter also covers advanced SQL techniques such as database configuration,
    performance monitoring, and database maintenance. The chapter ends with several
    real-world case studies that help demonstrate how to identify and resolve database-related
    performance issues in existing systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了高级SQL技术，如数据库配置、性能监控和数据库维护。本章以几个现实世界的案例研究结束，这些案例研究有助于展示如何识别和解决现有系统中的数据库相关性能问题。
- en: By the end of this chapter, you should have a foundational understanding of
    strategies to optimize your databases and database queries. Armed with this understanding,
    and leveraging your experience gained from hands-on exercises, you should be able
    to improve the performance of your Java applications that incorporate databases
    and database queries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对优化数据库和数据库查询的策略有基础的了解。有了这种理解，并利用从实际练习中获得的经验，你应该能够提高包含数据库和数据库查询的Java应用程序的性能。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Database design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设计
- en: SQL query optimizations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL查询优化
- en: Additional strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的策略
- en: Case studies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究
- en: Database design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计
- en: For new systems, we have the luxury of designing our databases with performance
    in mind. Our database’s design can have a significant impact on the efficiency
    of our SQL queries. In this section, we will examine key principles of database
    design, including schema, indexing, partitioning, and sharding.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新系统，我们有在设计数据库时考虑性能的便利。我们的数据库设计可以显著影响SQL查询的效率。在本节中，我们将检查数据库设计的关键原则，包括模式、索引、分区和分片。
- en: Schema principles
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式原则
- en: Database schema
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式
- en: A database schema is the design of the database, serving as a blueprint to create
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式是数据库的设计，作为创建它的蓝图。
- en: Before we create our database, we should create a **schema** to document how
    our data will be organized and to indicate how it is interrelated. Our goal is
    to design a schema that makes querying the database more efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建数据库之前，我们应该创建一个**模式**来记录我们的数据如何组织以及它们是如何相互关联的。我们的目标是设计一个使查询数据库更高效的模式。
- en: An early decision to make is whether our database will be **normalized** or
    **denormalized**. A denormalized database involves reducing the number of tables
    to decrease the complexity of queries. Conversely, normalization involves creating
    separate tables to eliminate duplicative data. Let’s look at an example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的早期决定之一是确定我们的数据库将是**规范化**还是**非规范化**。非规范化数据库涉及减少表的数量以降低查询的复杂性。相反，规范化涉及创建单独的表以消除重复数据。让我们来看一个例子。
- en: The following table shows duplicative data for both the author and publisher
    fields.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了作者和出版社字段中的重复数据。
- en: '| **BookID** | **Author** | **Title** | **Publisher** | **Price ($)** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **BookID** | **Author** | **Title** | **Publisher** | **Price ($)** |'
- en: '| 1 | N. Anderson | *Introduction* *to Zion* | Packt | 65.99 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1 | N. Anderson | *Zion的介绍* | Packt | 65.99 |'
- en: '| 2 | N. Anderson | *Illustrated History* *of Zion* | Packt | 123.99 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 2 | N. Anderson | *Zion的插图历史* | Packt | 123.99 |'
- en: '| 3 | W. Rabbit | *Astro Mechanics* | Packt | 89.99 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 3 | W. Rabbit | *天体力学* | Packt | 89.99 |'
- en: '| 4 | W. Rabbit | *Gyro Machinery* | Forest Press | 79.99 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: Table 15.1 – A Denormalized table
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding table, there are two entries for two different
    authors, and one publisher is listed more than once. This is an unnormalized table.
    To normalize the table, we will create three tables, one each for the books, authors,
    and publishers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '| **BookID** | **Title** | **AuthorID** | **PublisherID** | **Price ($)** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| 1 | *Introduction* *to Zion* | 1 | 1 | 65.99 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| 2 | *Illustrated History* *of Zion* | 1 | 1 | 123.99 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| 3 | *Astro Mechanics* | 2 | 1 | 89.99 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| 4 | *Gyro Machinery* | 2 | 2 | 79.99 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: Table 15.2 – The Books table
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Books` table references the `AuthorID` and `PublisherID` fields. Those
    are established in the following tables. Here is the `Authors` table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '| **AuthorID** | **Author** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| 1 | N. Anderson |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| 2 | W. Rabbit |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: Table 15.3 – The Authors table
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final table is for the **Publishers**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '| **PublisherID** | **Publisher** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| 1 | Packt |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| 2 | Forest Press |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: Table 15.4 – The Publishers table
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The decision to implement a normalized or denormalized database involves considering
    the complexity of queries, the size of your database, and the read-write load
    on your database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important database design consideration is the data type for each of
    your columns. For example, it is appropriate to use an `Authors` table with appropriate
    data types using SQL:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After we have designed our database tables and decided on data types, we need
    to implement indexing. Let’s look at that in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We index our databases so that data can be found quickly. Our indexing strategy
    has a direct impact on our query performance, so due diligence is required. There
    are two types of indexing. The first type is **balanced tree** (**B-tree**), which
    is what is implemented in most databases. This type of index keeps data sorted
    and permits sequential access, insertions, and deletions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The second type of database indexing is **hash indexes**. This type of indexing
    is ideal when equality comparisons are needed but is not adequate for range queries.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Index creation is simple and demonstrated by the following SQL statement:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you have an existing database and frequently use `WHERE`, `JOIN`, `ORDER
    BY`, or `GROUP BY`, you can likely benefit from indexing. Let’s look at an example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the following SQL statement when we do not have an index:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following SQL statement searches for the same author but uses an index:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the second example will provide results a bit faster than the non-indexed
    approach. Note that indexes do take up additional storage space and add additional
    processing overhead when using the `INSERT`, `DELETE`, and `UPDATE` operations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine partitioning and sharding as approaches
    to improve the efficiency of our database and database queries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning and sharding
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partitioning and sharding are strategies used to improve the performance of
    large databases and their queries by dividing large datasets into smaller components.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分区和分片是用于通过将大型数据集划分为更小的组件来提高大型数据库及其查询性能的策略。
- en: Partitioning
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区
- en: 'There are two types of partitioning, **horizontal partitioning** and **vertical
    partitioning**. Horizontal partitioning is accomplished by splitting tables into
    rows, and each horizontal partition contains a subset of those rows. A typical
    use case for this is creating a partition based on date ranges. The following
    example creates three tables, each with a specific year’s worth of order information:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种分区类型，**水平分区**和**垂直分区**。水平分区是通过将表拆分为行来实现的，每个水平分区包含这些行的一个子集。这种方法的典型用例是基于日期范围创建分区。以下示例创建了三个表，每个表包含特定年份的订单信息：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Vertical partitioning splits the database table into columns, each partition
    containing a subset of columns. To demonstrate vertical partitioning, let’s look
    at a `Books` table that has not been partitioned:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直分区将数据库表拆分为列，每个分区包含列的子集。为了演示垂直分区，让我们看看一个尚未分区的`Books`表：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, using vertical partitioning, let’s create two tables, each with a subset
    of columns:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用垂直分区，让我们创建两个表，每个表包含列的子集：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By splitting our table into two partitions, we can search more efficiently,
    since we do not need to process any unrelated data (i.e., when searching the catalog
    data, we are not concerned with sales data).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的表拆分为两个分区，我们可以更有效地搜索，因为我们不需要处理任何无关数据（即，在搜索目录数据时，我们不关心销售数据）。
- en: Let’s now look at another strategy to increase the efficiency of our databases,
    called sharding.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一种提高数据库效率的策略，称为**分片**。
- en: Sharding
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分片
- en: '**Sharding** is the process of distributing our data over multiple servers,
    moving the data closer to users. This strategy has two primary benefits – moving
    the data to servers closer to users reduces network latency and the load on individual
    servers. A common use case is to shard based on geographic region. Here is an
    example of how we can accomplish that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**分片**是将我们的数据分布到多个服务器上的过程，将数据移动到用户附近。这种策略有两个主要好处——将数据移动到靠近用户的服务器可以减少网络延迟和单个服务器的负载。一个常见的用例是基于地理位置进行分片。以下是一个示例，说明我们如何实现这一点：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example creates two tables. The next step would be to store each
    table on different servers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了两个表。下一步是将每个表存储在不同的服务器上。
- en: A purposeful approach to partitioning and sharding can result in a performance-ready
    database design. It can make your SQL queries more efficient, thereby improving
    the overall performance of your Java application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有目的的分区和分片方法可以导致一个性能就绪的数据库设计。它可以提高你的SQL查询效率，从而提高Java应用程序的整体性能。
- en: Query optimizations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询优化
- en: Now that we have a basic understanding of how to design our databases with performance
    in mind, we are ready to look at best practices for writing efficient queries.
    We will also look at query execution plans and some advanced SQL techniques. To
    make our example SQL statements relatable, we will use a book inventory and order
    processing database throughout this section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何以性能为导向设计数据库有了基本的了解，我们可以开始探讨编写高效查询的最佳实践。我们还将探讨查询执行计划和一些高级SQL技术。为了使本节中的示例SQL语句更具相关性，我们将使用一个图书库存和订单处理数据库。
- en: Query execution
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询执行
- en: Understanding how queries are handled by our database is key to being able to
    optimize them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们的数据库如何处理查询是能够对其进行优化的关键。
- en: A query execution plan
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查询执行计划
- en: A query execution plan provides details on how a database engine executes queries
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查询执行计划提供了数据库引擎执行查询的详细信息
- en: 'A query execution plan includes details on database query operations, such
    as joins and sorts. Let’s look at a simple query that gives us a specific book’s
    total sales:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查询执行计划包括数据库查询操作（如连接和排序）的详细信息。让我们看看一个简单的查询，它给出了特定书籍的总销售额：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s add an `EXPLAIN` command to the same query to reveal the steps the
    database engine follows to execute our query:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向相同的查询添加一个`EXPLAIN`命令，以揭示数据库引擎执行我们的查询的步骤：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By viewing the query execution plan, we can identify potential bottlenecks,
    providing us with an opportunity to further optimize our database and queries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看查询执行计划，我们可以识别潜在的瓶颈，这为我们进一步优化数据库和查询提供了机会。
- en: Next, let’s look at some best practices for writing efficient queries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看编写高效查询的一些最佳实践。
- en: Best practices
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goals when writing SQL queries are to minimize resource use and reduce execution
    time. To achieve these goals, we should follow best practices, including the ones
    detailed as follows for the `SELECT` statement, `JOIN` operations, **subqueries**,
    and **common table** **expressions** (**CTEs**).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: SELECT statement
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three best practices involved with using the `SELECT` statement. First,
    we should avoid using `SELECT *` and only specify the columns we need. For example,
    instead of using `SELECT * FROM Books;`, use `SELECT Title, AuthorID, Genre` `FROM
    Books;`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Another best practice is to use the `WHERE` clause to narrow down our results
    to the maximum extent possible. Here is an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A third best practice for using the `SELECT` statement is to limit the number
    of rows returned by our query. We can use the `LIMIT` clause, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The three best practices for working with the `SELECT` statement are key to
    improving the efficiency of our queries. Next, let’s look at best practices for
    using `JOIN` operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: JOIN operations
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two best practices for using `JOIN` operations. First, we should ensure
    that all columns used in `JOIN` conditions are indexed. This will improve the
    efficiency of these operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Another best practice is to use the appropriate `JOIN` type, as indicated in
    the following table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Purpose** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `INNER JOIN` | Used to match rows |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `LEFT JOIN` | To include all rows from the left table |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `RIGHT JOIN` | To include all rows from the right table |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: 'Table 15.5: JOIN type and its purpose'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the concept of subqueries and their related best practices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Subqueries
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the title suggests, **subqueries** are used to break a complex query into
    multiple, simpler queries. Here is an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let’s look at CTEs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: CTEs
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CTEs can be used to make complex queries more readable. This increases their
    reusability and eases their maintainability. Here is an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have reviewed several best practices for writing queries, let’s
    look at some advanced SQL techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Advanced SQL techniques
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section demonstrates three advanced SQL techniques – window functions,
    recursive queries, and temporary tables and views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Window functions
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **window function** is used to calculate across a set of rows related to
    a current row. Here is an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Recursive queries
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recursive queries are complicated and can be useful when you have hierarchical
    data, such as book categories and subcategories. Here is an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Temporary tables and views
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another advanced technique is to use temporary tables and views to achieve
    better performance and help manage complex queries. Here is an example of a temporary
    table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following SQL statement is an example of a temporary view:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Experimenting with the advanced techniques presented in this section can improve
    your ability to write efficient queries, contributing to the overall performance
    of your Java application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Additional strategies
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, this chapter has covered designing a database schema for efficiency
    and how to write efficient SQL queries. There are several additional strategies
    we can employ, including fine-tuning, monitoring, and maintenance. Each of these
    strategies is explored in this section and uses the same book inventory and ordering
    example from the previous section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can fine-tune our database server’s configuration parameters to ensure that
    our queries make efficient use of resources. This fine-tuning can be categorized
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Database** **server parameters**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`innodb_buffer_pool_size` parameter in MySQL with the `SET shared_buffers =
    ''3GB'';` SQL statement.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection pooling**: As detailed in [*Chapter 10*](B21942_10.xhtml#_idTextAnchor172),
    *Connection Pooling*, we can pool our database connections to reduce overhead
    and improve overall application performance.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET query_cache_size = 256MB'';` will enable query caching.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory management**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database caching**: We can cache databases to speed up read operations for
    frequently accessed data. Tools such as **Redis** can be used to aid in this technique.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s explore how we can monitor and profile our database’s performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Database performance monitoring
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once our database is up and running and all our queries are established, we
    are ready to monitor our database’s performance. Monitoring can help us identify
    potential bottlenecks and allow us to make refinements to improve overall performance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'A proven approach to identify bottlenecks is to enable **slow query logging**.
    This can help us identify which queries take longer than we desire to execute.
    Here is how this can be enabled:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The use of query profiling tools can help us analyze and optimize slow queries.
    There are various tools available, depending on your database type and service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and profiling can help identify opportunities for refinement. In
    the next section, we will explore database maintenance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Database maintenance
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Databases are dynamic and need to be maintained with regularly scheduled maintenance.
    This is a proactive, vice reactive approach to maintaining your databases. Here
    are some tips:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Regularly run `VACUUM` to reclaim storage.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After each run of `VACUUM`, run `ANALYZE` so that the query planner has updated
    statistics.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `REINDEX` to periodically reindex your database. This will improve query
    performance.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archive old data that is no longer needed. You can partition this data into
    a historical database.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purge data that is not needed. This will free up storage and should improve
    query performance.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategies presented in this section can help you further enhance your query
    performance, the database performance, and the overall performance of your Java
    application. These strategies are especially important for large databases and
    those with high transaction rates.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review several real-world case studies to help
    you contextualize the concepts presented in this chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Case studies
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: This section presents three real-world case studies using the book inventory
    and order processing database featured throughout this chapter. A review of the
    case studies will demonstrate how the strategies and techniques presented in this
    chapter can be used to solve common database performance problems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了三个使用本章中提到的书籍库存和订单处理数据库的真实案例研究。对案例研究的回顾将展示本章中提出的策略和技术如何用于解决常见的数据库性能问题。
- en: 'Each case study is presented in the following format:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个案例研究都按照以下格式展示：
- en: The scenario
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景
- en: The initial SQL query
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始 SQL 查询
- en: The problem
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题
- en: The optimization steps
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化步骤
- en: The result
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果
- en: Case study 1
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 1
- en: '**Scenario**: Every time the bookstore’s administrator runs the sales report,
    it takes several minutes – much longer than it should. The report simply summarizes
    total sales by title. The database schema is the same as the one presented earlier
    in this chapter.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：每次书店管理员运行销售报告时，都需要几分钟时间——比应有的时间要长得多。报告只是简单地按标题总结总销售额。数据库模式与本章前面展示的相同。'
- en: '**Initial** **SQL query**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始** **SQL 查询**：'
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Books` and `Orders` tables. This results in slow performance.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Books` 和 `Orders` 表。这导致性能缓慢。'
- en: '**Optimization steps**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化步骤**：'
- en: 'The database administrator added indexes to the `BookID` columns in both the
    `Books` and `Orders` tables:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库管理员在 `Books` 和 `Orders` 表的 `BookID` 列上添加了索引：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The query was refined to only include columns that were needed to retrieve
    the desired data:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询被优化，仅包括检索所需数据所需的列：
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`EXPLAIN ANALYZE` command, showed a significant query time reduction. The sales
    report now runs in less than one minute.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN ANALYZE` 命令显示查询时间显著减少。销售报告现在在一分钟内完成。'
- en: Case study 2
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 2
- en: '`Orders` table now contains millions of records. Running queries for specific
    years is extremely slow.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Orders` 表现在包含数百万条记录。对特定年份的查询运行速度极慢。'
- en: '**Initial** **SQL query**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始** **SQL 查询**：'
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Problem**: The query performs a full table scan, which results in slow performance.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：查询执行了全表扫描，导致性能缓慢。'
- en: '**Optimization steps**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化步骤**：'
- en: 'The database administrator performed horizontal partitioning, creating tables
    for each year:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库管理员执行了水平分区，为每年的数据创建表：
- en: '[PRE23]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After partitioning the data, the administrator updated the queries to target
    the specific partitions:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据分区后，管理员更新了查询以针对特定的分区：
- en: '[PRE24]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Result**: The query performance significantly improved, running at a fraction
    of the previous time.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：查询性能显著提高，运行时间仅为之前的一小部分。'
- en: Case study 3
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 3
- en: '`Books` table resulted in a significant and unnecessary load on the database.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Books` 表导致数据库产生显著且不必要的负载。'
- en: '**Initial** **SQL query**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始** **SQL 查询**：'
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Problem**: Identical queries were repeatedly sent to the database, creating
    a high load and slow response time.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：数据库被反复发送相同的查询，导致高负载和缓慢的响应时间。'
- en: '**Optimization step**: The database administrator used **Redis** to cache book
    details.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化步骤**：数据库管理员使用 **Redis** 缓存书籍详情。'
- en: '**Result**: The database load was significantly reduced, and the response times
    were drastically shorter.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：数据库负载显著减少，响应时间大幅缩短。'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explored essential strategies and techniques to optimize databases
    and SQL queries. The chapter’s overall aim was to introduce database-related enhancements
    and best practices to improve the performance of your data-driven applications.
    We began with the fundamentals of database design, including schema normalization,
    appropriate indexing, and partitioning strategies. We then explored how to write
    efficient SQL queries. Our coverage also included query execution plans and leveraging
    advanced SQL techniques, such as window functions and recursive queries. Additional
    strategies, including database configuration, monitoring, profiling, and regular
    maintenance, were also discussed. The chapter ended with real-world case studies
    to demonstrate the practical application of the strategies and techniques covered
    in the chapter. You should now be confident in implementing these best practices
    and ensuring your database systems can handle large datasets and complex queries
    with ease.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了优化数据库和SQL查询的必要策略和技术。本章的总体目标是介绍与数据库相关的增强和最佳实践，以提高您数据驱动应用程序的性能。我们从数据库设计的根本原则开始，包括模式规范化、适当的索引和分区策略。然后我们探讨了如何编写高效的SQL查询。我们的覆盖范围还包括查询执行计划和利用高级SQL技术，如窗口函数和递归查询。本章还讨论了包括数据库配置、监控、分析和定期维护在内的其他策略。本章以实际案例研究结束，以展示本章中涵盖的策略和技术的实际应用。现在，您应该有信心实施这些最佳实践，并确保您的数据库系统可以轻松处理大型数据集和复杂查询。
- en: In the next chapter, we will examine the concepts of code monitoring and code
    maintenance, with an ever-vigilant eye on the high performance of our Java applications.
    Our approaches to code monitoring and maintenance will include conducting code
    reviews to identify potential performance issues before they become problematic.
    Specifically, we will look at **application performance management** (**APM**)
    tools, code reviews, log analysis, and continuous improvement.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨代码监控和代码维护的概念，始终保持对我们的Java应用程序高性能的警觉。我们的代码监控和维护方法将包括在问题出现之前进行代码审查，以识别潜在的性能问题。具体来说，我们将探讨**应用性能管理**（**APM**）工具、代码审查、日志分析和持续改进。
