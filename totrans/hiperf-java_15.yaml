- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Your Database and SQL Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases are a key component of large software systems. These systems constantly
    retrieve and update data using database connections and queries. The scale of
    data in modern systems is extremely large, resulting in more data to query, update,
    and display. This increased scale can result in negative performance issues for
    our Java application, underscoring the significance of ensuring our databases
    and queries are optimized.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter examines critical database design concepts, including database
    schemas, indexing strategies, and data partitioning techniques. Database queries
    are also examined, with a specific focus on **Structured Query Language** (**SQL**)
    queries. Our coverage of query optimizations includes best practices for writing
    efficient queries, query execution planning, and advanced SQL techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also covers advanced SQL techniques such as database configuration,
    performance monitoring, and database maintenance. The chapter ends with several
    real-world case studies that help demonstrate how to identify and resolve database-related
    performance issues in existing systems.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a foundational understanding of
    strategies to optimize your databases and database queries. Armed with this understanding,
    and leveraging your experience gained from hands-on exercises, you should be able
    to improve the performance of your Java applications that incorporate databases
    and database queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Database design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL query optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For new systems, we have the luxury of designing our databases with performance
    in mind. Our database’s design can have a significant impact on the efficiency
    of our SQL queries. In this section, we will examine key principles of database
    design, including schema, indexing, partitioning, and sharding.
  prefs: []
  type: TYPE_NORMAL
- en: Schema principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database schema
  prefs: []
  type: TYPE_NORMAL
- en: A database schema is the design of the database, serving as a blueprint to create
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create our database, we should create a **schema** to document how
    our data will be organized and to indicate how it is interrelated. Our goal is
    to design a schema that makes querying the database more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: An early decision to make is whether our database will be **normalized** or
    **denormalized**. A denormalized database involves reducing the number of tables
    to decrease the complexity of queries. Conversely, normalization involves creating
    separate tables to eliminate duplicative data. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows duplicative data for both the author and publisher
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: '| **BookID** | **Author** | **Title** | **Publisher** | **Price ($)** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | N. Anderson | *Introduction* *to Zion* | Packt | 65.99 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | N. Anderson | *Illustrated History* *of Zion* | Packt | 123.99 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | W. Rabbit | *Astro Mechanics* | Packt | 89.99 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | W. Rabbit | *Gyro Machinery* | Forest Press | 79.99 |'
  prefs: []
  type: TYPE_TB
- en: Table 15.1 – A Denormalized table
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding table, there are two entries for two different
    authors, and one publisher is listed more than once. This is an unnormalized table.
    To normalize the table, we will create three tables, one each for the books, authors,
    and publishers.
  prefs: []
  type: TYPE_NORMAL
- en: '| **BookID** | **Title** | **AuthorID** | **PublisherID** | **Price ($)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | *Introduction* *to Zion* | 1 | 1 | 65.99 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *Illustrated History* *of Zion* | 1 | 1 | 123.99 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *Astro Mechanics* | 2 | 1 | 89.99 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *Gyro Machinery* | 2 | 2 | 79.99 |'
  prefs: []
  type: TYPE_TB
- en: Table 15.2 – The Books table
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Books` table references the `AuthorID` and `PublisherID` fields. Those
    are established in the following tables. Here is the `Authors` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **AuthorID** | **Author** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | N. Anderson |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | W. Rabbit |'
  prefs: []
  type: TYPE_TB
- en: Table 15.3 – The Authors table
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final table is for the **Publishers**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **PublisherID** | **Publisher** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Packt |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Forest Press |'
  prefs: []
  type: TYPE_TB
- en: Table 15.4 – The Publishers table
  prefs: []
  type: TYPE_NORMAL
- en: The decision to implement a normalized or denormalized database involves considering
    the complexity of queries, the size of your database, and the read-write load
    on your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important database design consideration is the data type for each of
    your columns. For example, it is appropriate to use an `Authors` table with appropriate
    data types using SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After we have designed our database tables and decided on data types, we need
    to implement indexing. Let’s look at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We index our databases so that data can be found quickly. Our indexing strategy
    has a direct impact on our query performance, so due diligence is required. There
    are two types of indexing. The first type is **balanced tree** (**B-tree**), which
    is what is implemented in most databases. This type of index keeps data sorted
    and permits sequential access, insertions, and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of database indexing is **hash indexes**. This type of indexing
    is ideal when equality comparisons are needed but is not adequate for range queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Index creation is simple and demonstrated by the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you have an existing database and frequently use `WHERE`, `JOIN`, `ORDER
    BY`, or `GROUP BY`, you can likely benefit from indexing. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the following SQL statement when we do not have an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following SQL statement searches for the same author but uses an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the second example will provide results a bit faster than the non-indexed
    approach. Note that indexes do take up additional storage space and add additional
    processing overhead when using the `INSERT`, `DELETE`, and `UPDATE` operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine partitioning and sharding as approaches
    to improve the efficiency of our database and database queries.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning and sharding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partitioning and sharding are strategies used to improve the performance of
    large databases and their queries by dividing large datasets into smaller components.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of partitioning, **horizontal partitioning** and **vertical
    partitioning**. Horizontal partitioning is accomplished by splitting tables into
    rows, and each horizontal partition contains a subset of those rows. A typical
    use case for this is creating a partition based on date ranges. The following
    example creates three tables, each with a specific year’s worth of order information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Vertical partitioning splits the database table into columns, each partition
    containing a subset of columns. To demonstrate vertical partitioning, let’s look
    at a `Books` table that has not been partitioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using vertical partitioning, let’s create two tables, each with a subset
    of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By splitting our table into two partitions, we can search more efficiently,
    since we do not need to process any unrelated data (i.e., when searching the catalog
    data, we are not concerned with sales data).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at another strategy to increase the efficiency of our databases,
    called sharding.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sharding** is the process of distributing our data over multiple servers,
    moving the data closer to users. This strategy has two primary benefits – moving
    the data to servers closer to users reduces network latency and the load on individual
    servers. A common use case is to shard based on geographic region. Here is an
    example of how we can accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates two tables. The next step would be to store each
    table on different servers.
  prefs: []
  type: TYPE_NORMAL
- en: A purposeful approach to partitioning and sharding can result in a performance-ready
    database design. It can make your SQL queries more efficient, thereby improving
    the overall performance of your Java application.
  prefs: []
  type: TYPE_NORMAL
- en: Query optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how to design our databases with performance
    in mind, we are ready to look at best practices for writing efficient queries.
    We will also look at query execution plans and some advanced SQL techniques. To
    make our example SQL statements relatable, we will use a book inventory and order
    processing database throughout this section.
  prefs: []
  type: TYPE_NORMAL
- en: Query execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding how queries are handled by our database is key to being able to
    optimize them.
  prefs: []
  type: TYPE_NORMAL
- en: A query execution plan
  prefs: []
  type: TYPE_NORMAL
- en: A query execution plan provides details on how a database engine executes queries
  prefs: []
  type: TYPE_NORMAL
- en: 'A query execution plan includes details on database query operations, such
    as joins and sorts. Let’s look at a simple query that gives us a specific book’s
    total sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add an `EXPLAIN` command to the same query to reveal the steps the
    database engine follows to execute our query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By viewing the query execution plan, we can identify potential bottlenecks,
    providing us with an opportunity to further optimize our database and queries.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at some best practices for writing efficient queries.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goals when writing SQL queries are to minimize resource use and reduce execution
    time. To achieve these goals, we should follow best practices, including the ones
    detailed as follows for the `SELECT` statement, `JOIN` operations, **subqueries**,
    and **common table** **expressions** (**CTEs**).
  prefs: []
  type: TYPE_NORMAL
- en: SELECT statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three best practices involved with using the `SELECT` statement. First,
    we should avoid using `SELECT *` and only specify the columns we need. For example,
    instead of using `SELECT * FROM Books;`, use `SELECT Title, AuthorID, Genre` `FROM
    Books;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another best practice is to use the `WHERE` clause to narrow down our results
    to the maximum extent possible. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A third best practice for using the `SELECT` statement is to limit the number
    of rows returned by our query. We can use the `LIMIT` clause, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The three best practices for working with the `SELECT` statement are key to
    improving the efficiency of our queries. Next, let’s look at best practices for
    using `JOIN` operations.
  prefs: []
  type: TYPE_NORMAL
- en: JOIN operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two best practices for using `JOIN` operations. First, we should ensure
    that all columns used in `JOIN` conditions are indexed. This will improve the
    efficiency of these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another best practice is to use the appropriate `JOIN` type, as indicated in
    the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `INNER JOIN` | Used to match rows |'
  prefs: []
  type: TYPE_TB
- en: '| `LEFT JOIN` | To include all rows from the left table |'
  prefs: []
  type: TYPE_TB
- en: '| `RIGHT JOIN` | To include all rows from the right table |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.5: JOIN type and its purpose'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the concept of subqueries and their related best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Subqueries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the title suggests, **subqueries** are used to break a complex query into
    multiple, simpler queries. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look at CTEs.
  prefs: []
  type: TYPE_NORMAL
- en: CTEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CTEs can be used to make complex queries more readable. This increases their
    reusability and eases their maintainability. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have reviewed several best practices for writing queries, let’s
    look at some advanced SQL techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced SQL techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section demonstrates three advanced SQL techniques – window functions,
    recursive queries, and temporary tables and views.
  prefs: []
  type: TYPE_NORMAL
- en: Window functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **window function** is used to calculate across a set of rows related to
    a current row. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Recursive queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recursive queries are complicated and can be useful when you have hierarchical
    data, such as book categories and subcategories. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Temporary tables and views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another advanced technique is to use temporary tables and views to achieve
    better performance and help manage complex queries. Here is an example of a temporary
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following SQL statement is an example of a temporary view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Experimenting with the advanced techniques presented in this section can improve
    your ability to write efficient queries, contributing to the overall performance
    of your Java application.
  prefs: []
  type: TYPE_NORMAL
- en: Additional strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, this chapter has covered designing a database schema for efficiency
    and how to write efficient SQL queries. There are several additional strategies
    we can employ, including fine-tuning, monitoring, and maintenance. Each of these
    strategies is explored in this section and uses the same book inventory and ordering
    example from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can fine-tune our database server’s configuration parameters to ensure that
    our queries make efficient use of resources. This fine-tuning can be categorized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database** **server parameters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`innodb_buffer_pool_size` parameter in MySQL with the `SET shared_buffers =
    ''3GB'';` SQL statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection pooling**: As detailed in [*Chapter 10*](B21942_10.xhtml#_idTextAnchor172),
    *Connection Pooling*, we can pool our database connections to reduce overhead
    and improve overall application performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET query_cache_size = 256MB'';` will enable query caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory management**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database caching**: We can cache databases to speed up read operations for
    frequently accessed data. Tools such as **Redis** can be used to aid in this technique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s explore how we can monitor and profile our database’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: Database performance monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once our database is up and running and all our queries are established, we
    are ready to monitor our database’s performance. Monitoring can help us identify
    potential bottlenecks and allow us to make refinements to improve overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proven approach to identify bottlenecks is to enable **slow query logging**.
    This can help us identify which queries take longer than we desire to execute.
    Here is how this can be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The use of query profiling tools can help us analyze and optimize slow queries.
    There are various tools available, depending on your database type and service.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and profiling can help identify opportunities for refinement. In
    the next section, we will explore database maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Database maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Databases are dynamic and need to be maintained with regularly scheduled maintenance.
    This is a proactive, vice reactive approach to maintaining your databases. Here
    are some tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Regularly run `VACUUM` to reclaim storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After each run of `VACUUM`, run `ANALYZE` so that the query planner has updated
    statistics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `REINDEX` to periodically reindex your database. This will improve query
    performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archive old data that is no longer needed. You can partition this data into
    a historical database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purge data that is not needed. This will free up storage and should improve
    query performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategies presented in this section can help you further enhance your query
    performance, the database performance, and the overall performance of your Java
    application. These strategies are especially important for large databases and
    those with high transaction rates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review several real-world case studies to help
    you contextualize the concepts presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents three real-world case studies using the book inventory
    and order processing database featured throughout this chapter. A review of the
    case studies will demonstrate how the strategies and techniques presented in this
    chapter can be used to solve common database performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each case study is presented in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: The scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial SQL query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimization steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scenario**: Every time the bookstore’s administrator runs the sales report,
    it takes several minutes – much longer than it should. The report simply summarizes
    total sales by title. The database schema is the same as the one presented earlier
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial** **SQL query**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Books` and `Orders` tables. This results in slow performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimization steps**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The database administrator added indexes to the `BookID` columns in both the
    `Books` and `Orders` tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The query was refined to only include columns that were needed to retrieve
    the desired data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`EXPLAIN ANALYZE` command, showed a significant query time reduction. The sales
    report now runs in less than one minute.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Orders` table now contains millions of records. Running queries for specific
    years is extremely slow.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial** **SQL query**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Problem**: The query performs a full table scan, which results in slow performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimization steps**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The database administrator performed horizontal partitioning, creating tables
    for each year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After partitioning the data, the administrator updated the queries to target
    the specific partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Result**: The query performance significantly improved, running at a fraction
    of the previous time.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Books` table resulted in a significant and unnecessary load on the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial** **SQL query**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Problem**: Identical queries were repeatedly sent to the database, creating
    a high load and slow response time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimization step**: The database administrator used **Redis** to cache book
    details.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: The database load was significantly reduced, and the response times
    were drastically shorter.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored essential strategies and techniques to optimize databases
    and SQL queries. The chapter’s overall aim was to introduce database-related enhancements
    and best practices to improve the performance of your data-driven applications.
    We began with the fundamentals of database design, including schema normalization,
    appropriate indexing, and partitioning strategies. We then explored how to write
    efficient SQL queries. Our coverage also included query execution plans and leveraging
    advanced SQL techniques, such as window functions and recursive queries. Additional
    strategies, including database configuration, monitoring, profiling, and regular
    maintenance, were also discussed. The chapter ended with real-world case studies
    to demonstrate the practical application of the strategies and techniques covered
    in the chapter. You should now be confident in implementing these best practices
    and ensuring your database systems can handle large datasets and complex queries
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the concepts of code monitoring and code
    maintenance, with an ever-vigilant eye on the high performance of our Java applications.
    Our approaches to code monitoring and maintenance will include conducting code
    reviews to identify potential performance issues before they become problematic.
    Specifically, we will look at **application performance management** (**APM**)
    tools, code reviews, log analysis, and continuous improvement.
  prefs: []
  type: TYPE_NORMAL
