- en: Implementing Reactive Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore one of the most important features of the
    Spring 5 Framework, which is reactive pattern programming. The Spring 5 Framework
    introduced this new feature with the Spring web reactive module. We will discuss
    this module in this chapter. Before that, let''s have a look at reactive patterns.
    What is the reactive pattern, and why is it growing more popular nowadays? I will
    start my discussion on reactive pattern with the following statement made by **Satya
    Nadella**, CEO, Microsoft Corporation:'
  prefs: []
  type: TYPE_NORMAL
- en: Every business out there now is a software company, is a digital company.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Why reactive pattern?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reactive pattern principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back-pressure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the reactive pattern using the Spring Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring web reactive module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding application requirement over the years
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go back 10 to 15 years, there were very few internet users, and far less
    online portals for end users compared to what we have today. Nowadays, we cannot
    think of a life without a computer or without any online system. In short, we
    have become extremely dependent on computers and online computing for personal
    as well as business use. Every business model is moving towards digitalization.
    The Prime Minister of India, Mr. Narendra Damodardas Modi has launched a Digital
    India campaign to ensure that the Government's services are made available to
    citizens electronically by improved online infrastructure, increasing internet
    connectivity, and by making the country digitally empowered in the field of technology.
  prefs: []
  type: TYPE_NORMAL
- en: All this implies that the number of internet users is increasing dramatically.
    According to the Ericsson Mobility Report,
  prefs: []
  type: TYPE_NORMAL
- en: The Internet of Things (IoT) is expected to surpass mobile phones as the largest
    category of connected devices in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: 'There has been a tremendous growth of mobile internet users, and there is no
    sign of that slowing down anytime soon. In these sectors, by definition, the server
    side has to handle millions of connected devices concurrently. The following table
    compares the infrastructure and application requirements today with the requirement
    from 10 years back:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Requirements** | **Now** | **Ten years ago** |'
  prefs: []
  type: TYPE_TB
- en: '| **Server nodes** | More than 1000 nodes required. | Ten nodes were enough.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Response times** | Takes milliseconds to serve requests, and send back
    responses. | Took seconds to response. |'
  prefs: []
  type: TYPE_TB
- en: '| **Maintenance downtimes** | Currently, there is no or zero maintenance downtime
    required. | Took hours of maintenance downtime. |'
  prefs: []
  type: TYPE_TB
- en: '| **Data volume** | Data for the current application that increased to TBs
    from PBs. | Data was in GBs. |'
  prefs: []
  type: TYPE_TB
- en: 'You can see the differences in the requirement of resources in the preceding
    table. These requirements have increased, because we now expect responses immediately,
    within the second. At the same time, the complexity of tasks given to computers
    have also increased. These tasks are not just pure computation in a mathematical
    sense, but also in requesting the responses to be distilled from enormous amounts
    of data. So, now we have to focus the performance of such systems by designing
    a single computer in the form of multi-core CPUs, possibly, combined in multi-socket
    servers. The first thing on our minds is to make the system responsive. It is
    the first of the reactive traits-responsiveness. We will explore more of this
    in this chapter, along with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why reactive pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive pattern principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back-pressure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing reactive pattern using the Spring Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Web reactive module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing reactive at server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing reactive at client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request and response body type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will teach you how to make a system responsive in the face of any
    variable load, partial outages, program failure, and more. Nowadays, systems are
    distributed across different nodes to efficiently serve requests.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the aforementioned topics in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the reactive pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, the modern applications must be more robust, more resilient, more flexible,
    and better positioned to meet the requirements of the organizations, because,
    in the recent couple of years, the requirements for applications have changed
    dramatically. As we have seen in the last table, 10 to 15 years ago, a large application
    had 10 server nodes, the response time taken to serve a request was in seconds,
    we required a couple of hours of downtime for maintenance and deployment, and
    the data was in gigabytes. But today, an application requires thousands of server
    nodes, because it is accessed by multiple channels such as mobile devices. The
    server responses are expected within milliseconds, and the downtime for deployment
    and maintenance is near to 0%. Data has been increased from terabytes to petabytes.
  prefs: []
  type: TYPE_NORMAL
- en: Ten-year old systems cannot fulfill the requirements of today's applications;
    we need a system that can fulfill all user's requirements either at the application
    level or the system level, which means we need a responsive system. Responsiveness
    is one of the properties of the reactive pattern. We want a system that must be
    responsive, resilient, elastic, and message-driven. We know these systems as reactive
    systems. These systems are more flexible, loosely-coupled, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: A system must react to failure and stay available, that is, it should be resilient,
    and the system must react to variable load conditions, and not be overloaded.
    The system should react to events--event-driven or message-driven. If all these
    properties are associated with a system, then it will be responsive, that is,
    if a system reacts to its users, it is responsive. To create a reactive system,
    we must focus on the system level and application level. Let's see first the all
    reactive traits.
  prefs: []
  type: TYPE_NORMAL
- en: The reactive pattern traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the principles of the Reactive pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: This is the goal of each application today.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: This is required to make an application responsive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable**: This is also required to make an application responsive; without
    resilience and scalability, it is impossible to achieve responsiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven**: A message-driven architecture is the base of a scalable
    and resilient application, and ultimately, it makes a system responsive. Message-driven
    either based on the event-driven or actor-based programming model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding points mentioned are core principles of the reactive pattern.
    Let''s explore each principle of the reactive pattern in detail, and understand
    why all of them must be applied together in order to make a reactive system with
    quality software for a modern context application, which is able to handle millions
    of parallel requests in milliseconds without any failure. Let''s first understand
    these principles with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b916152-d20b-4250-a1a2-b7ee0e54c418.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, to make a system reactive, we need
    scalability and resilience. To make a system scalable and resilient, we need an
    event-driven or message-driven architecture of the application. Ultimately, these
    principles, scalability, resilience, and event-driven architecture make a system
    responsive to the client. Let's see these properties in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say that a system or an application is responsive, it means that the
    application or system responds quickly to all users in a given time in all conditions,
    and that is in good condition as well as bad. It ensures a consistent positive
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsiveness is required for a system for usability and utility. A responsive
    system means that up on system failure, either because of an external system or
    a spike in traffic, the failures are detected quickly, and dealt with effectively
    in a short time without the users knowing of the failure. An end user must be
    able to interact with the system by providing rapid and consistent response times.
    A user must not face any failure during interaction with the system, and it must
    deliver a consistent quality of service to the user. That consistent behavior
    solves the failures and builds end-user confidence in the system. Quickness and
    a positive user experience under various conditions make a system responsive.
    It depends on the two other traits of a reactive application or system, that is,
    resilience and scalability. Another trait, that is, event-driven or message-driven
    architecture, provides the overall foundation for a responsive system. The following
    diagram illustrates a responsive system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76c032b0-0a17-4b9f-ab4f-38870c843f2f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, a responsive system depends on resilient
    and scalability of the system, and these depend on its event-driven architecture.
    Let's look at the other traits of a reactive application.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we design and develop a system, we have consider all conditions--good and
    bad. If we consider only the good conditions, then we tend to implement a system
    that may fail after just a few days. A major application failure results in downtime
    and data loss and damages your application's reputation in the market.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have to focus on every condition to ensure the responsiveness of the
    application under all conditions. Such a system or application is known as a resilient
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every system must be resilient to ensure responsiveness. If a system is not
    resilient, it will be unresponsive after a failure. So, a system must be responsive
    in the face of failure as well. In the whole system, failure can exist in any
    component of the application or system. So, each component in the system must
    be isolated from each other so that at the time of failure of a component, we
    can recover it without compromising the system as a whole. Recovery of an individual
    component is achieved by replication. If a system is resilient, then it must have
    replication, containment, isolation, and delegation. Take a look at the following
    diagram, which illustrates the resilient traits of a reactive application or system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b591206b-d282-49de-a9e3-00e5a213624e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, resilience is achieved by replication,
    containment, isolation, and delegation. Let''s discuss these points in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Replication**: This ensures high-availability, where necessary, at the time
    of component failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: This means that the failure of each component must be isolated,
    which is achieved by decoupling the components as much as possible. Isolation
    is needed for a system to self-heal. If your system has isolation in place, then
    you can easily measure the performance of each component, and check the memory
    and CPU usage. Moreover, the failure of one component won''t impact the responsiveness
    of the overall system or application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containment**: The result of decoupling is containment of the failure. It
    helps avoid failure in the system as a whole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegation**: After failure, the recovery of each component is delegated
    to another component. It is possible only when our system is composable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern applications not only depend on the internal infrastructure but are also
    integrated with other web services via network protocols. So, our applications
    must be resilient at their core in order to stay responsive under a variety of
    real-world in the opposite conditions. Our applications must not only be resilient
    at the application level but also at the system level.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see another principle of the reactive pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resiliency and scalability together make a system consistently responsive. A
    scalable system or an elastic system can easily be upgraded under a varying workload.
    A reactive system can be made scalable on demand by increasing and decreasing
    the resources allocated to service these inputs. It supports multiple scaling
    algorithms by providing relevant live performance for the scalability of the application.
    We can achieve scalability by using cost-effective software and cheap commodity
    hardware (for example, the Cloud).
  prefs: []
  type: TYPE_NORMAL
- en: 'An application is scalable if it can be extended according to its usage, in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**scale-up**: It makes use of parallelism in multi-core systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scale-out**: It makes use of multi-server nodes. Location transparency and
    resilience are important for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing the shared mutable state is very important for scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticity and Scalability are both the same! Scalability is all about the efficient
    use of resources already available, while elasticity is all about adding new resources
    to your application on demand when the needs of the system changed. So, eventually,
    the system can be made responsive anyway--by either using the existing resources
    of the system or by adding new resources to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the final foundation of the resilient and scalability of the reactive
    pattern, that is, message-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Message-driven architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A message-driven architecture is the base of a responsive application. A message-driven
    application can be an event-driven and actor-based application. It can also be
    a combination of both architectures--event-driven and actor-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In event-driven architecture, events and event observers play the main role.
    Events happen, but are not directed to a specific address; event listeners listen
    to these events, and take actions. But in message-driven architecture, the messages
    have a proper direction to the destination. Let''s look at the following diagram
    that illustrates message-driven and event-driven architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e69c809d-c56b-4a96-a15e-7904e66edfeb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, in event-driven architecture, if an
    event happens, then listeners listen to it. But in the message-driven one, one
    generated message communication has an addressable recipient and a single purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous message-driven architecture acts as the foundation for a reactive
    system by establishing limitations between the components. It ensures loose coupling,
    isolation, and location transparency. Isolation between components fully depends
    on the loose coupling between them. And isolations and loose coupling develop
    the base of resilience and elasticity.
  prefs: []
  type: TYPE_NORMAL
- en: A large system has multiple components. These components either have smaller
    applications, or they may have reactive properties. This means that the reactive
    design principles have to apply at all levels of the scale to make a large system
    composable.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, large systems are composed of multiple threads which communicate
    with a shared synchronized state. It tends to have strong coupling and is hard
    to compose, and it also tends to block stage. But, for now, all large systems
    are composed of loosely coupled event handlers. And events can be handled asynchronously
    without blocking.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the blocking and non-blocking programming models.
  prefs: []
  type: TYPE_NORMAL
- en: In very simple terms, reactive programming is all about non-blocking applications
    that are asynchronous and event-driven, and require a small number of threads
    to scale vertically rather than horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a system, a call may be holding the resources while other calls wait for
    the same resources. These resources are released when the other one finishes using
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s come to the technical words--actually, blocking a call means some operations
    in the application or system that take a longer time to complete, such as file
    I/O operations and database access using blocking drives. The following is a diagram
    of blocking calls for the JDBC operation in a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4aa2b1f-c8de-47a7-b760-c385e8b9a639.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, the blocking operations, shown here
    in red, are the ones where the user calls the servlet to fetch data, then that
    moves to the JDBC and DB connection with the DB server. Until that time, the current
    thread waits for the result set from the DB server. If the DB server has latency,
    then this wait time can increase. That means that thread execution depends on
    the DB server latency.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to make this a non-blocking execution.
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-blocking execution of a program means that a thread competes for a resource
    without waiting for it. A non-blocking API for the resources allows calling the
    resources without waiting for the blocked call such as database access and network
    calls. If the resources are not available at the time of calling, then it moves
    to other work rather than waiting for the blocked resources. The system is notified
    when the blocked resources are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram that shows the JDBC connection to access
    data without the blocking thread execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1398578c-a083-4e21-add1-7a9c3ef15c01.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, thread execution does not wait for
    the result set from the DB server. The thread makes the DB connection and SQL
    statement for the DB server. If the DB server has latency in the response, then
    the thread moves on to do other work rather than be blocked waiting for the resource
    to become available.
  prefs: []
  type: TYPE_NORMAL
- en: Back-pressure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reactive application is never given up in overload conditions. Back-pressure
    is a key aspect of a reactive application. It is a mechanism to ensure that the
    reactive application doesn't overwhelm the consumers. It tests aspects for the
    reactive application. It tests the system response gracefully under any load.
  prefs: []
  type: TYPE_NORMAL
- en: The back-pressure mechanism ensures that the system is resilient under load.
    In a back-pressure condition, the system makes itself scalable by applying other
    resources to help distribute the load.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have seen the reactive pattern principles; these are mandatory
    to make a system responsive in the blue sky or grey sky. Let's see, in the upcoming
    section how Spring 5 implements reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reactive with the Spring 5 Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most highlighted feature of the latest version of the Spring Framework is
    the new reactive stack web framework. Reactive is the update that takes us to
    the future. This area of technology is gaining popularity with every passing day,
    which is the reason why Spring Framework 5.0 has been launched with the capability
    of reactive programming. This addition makes the latest version of the Spring
    Framework convenient for event-loop style processing, which enables scaling with
    a small number of threads.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring 5 Framework implements the reactive programming pattern by using
    the reactor internally for its own reactive support. A reactor is a Reactive Stream
    implementation that extends the basic Reactive Streams. Twitter has been implemented
    as a reactive passed by using Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Streams provide a protocol or rule for asynchronous stream processing
    with non-blocking back-pressure. This standard is also adopted by Java 9 in the
    form of `java.util.concurrent.Flow`. Reactive Streams is composed of four simple
    Java interfaces. These interfaces are `Publisher`, `Subscriber`, `Subscription`,
    and `Processor`. But the main goal of the Reactive Streams is handling the backpressure.
    As discussed earlier, backpressure is a process that allows a receiver to ask
    about a data quantity from the emitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following Maven dependency for adding Reactive Streams in your
    application development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding Maven dependency code adds the required libraries for the Reactive
    Streams in your application. In the upcoming section, we'll see how Spring implements
    Reactive Streams in the web module of Spring and the Spring MVC Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Web reactive module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Spring 5.0 Framework, Spring has introduced a new module for reactive
    programming--the spring-web-reactive module. It is based on Reactive Streams.
    Basically, this module uses the Spring MVC module with reactive programming, so,
    you can still use the Spring MVC module for your web application either separately
    or with the spring-web-reactive module.
  prefs: []
  type: TYPE_NORMAL
- en: This new module in the Spring 5.0 Framework contains support for the Reactive-web-functional-
    based programming model. It also supports the Annotation-based programming model.
    The Spring-web-reactive module contains support for reactive HTTP and WebSocket
    clients to call the reactive server application. It also enables the reactive
    web client to make a connection with a reactive HTTP connection with a reactive
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a Spring-web-reactive module with its components
    that give reactive behavior to the Spring web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bde56a1-73df-42c1-af5a-374403e55064.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, there are two parallel modules--one
    for the traditional Spring MVC framework, and the other for the Spring-reactive
    web modules. On the left side in the diagram are the Spring-MVC-related components
    such as the @MVC controllers, **spring-web-mvc module**, **Servlet API module**,
    and **Servlet Container.** On the right side in the diagram are the spring-web-reactive
    related components such as the Router Functions, spring-web-reactive module, HTTP/Reactive
    Streams, Reactive version of Tomcat, and so on. **Spring-web-reactive** related
    components such as the **Router Functions**, **spring-web-reactive module**, **HTTP/Reactive
    Streams**, Reactive version of Tomcat, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, you must focus on the placement of the modules. Each
    module on the same level has comparisons between the traditional Spring MVC and
    Spring-web-reactive modules. These comparisons are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Spring web reactive modules, the Router functions are similar to the
    @MVC controllers in the Spring MVC modules such as the `@Controller`, `@RestController`,
    and `@RequestMapping` annotations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring-web-reactive module is parallel to the Spring-web-MVC modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the traditional Spring MVC Framework, we use the Servlet API for the `HttpServletRequest`
    and `HttpServletResponse` in the servlet container. But in the Spring-web-reactive
    framework, we use HTTP/Reactive Streams, which creates `HttpServerRequest` and
    `HttpServerResponse` under the reactive support of the tomcat server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can user Servlet Container for the traditional Spring MVC Framework, but
    a reactive-supported server is required for the Spring-web-reactive application.
    Spring provides support for Tomcat, Jetty, Netty, and Undertow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 10](ef5eac66-9b41-4959-8155-96f002137409.xhtml), *Implementing MVC
    Pattern in a Web Application using Spring*, you learned how to implement a web
    application using the Spring MVC module. Let's now see how to implement a reactive
    web application by using the Spring web reactive module.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a reactive web application at the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring reactive web modules support both programming models--Annotation-based
    or the Functional-based programming model. Let''s see how these models work on
    the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotations-based programming model**: It is based on MVC annotations such
    as `@Controller`, `@RestController`, `@RequestMapping`, and many more. Annotations
    are supported by the Spring MVC framework for server-side programming for a web
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional programming model:** It is a new paradigm of programming supported
    by the Spring 5 Framework. It is based on the Java 8 Lambda style routing and
    handling. Scala also provides the functional programming paradigm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the Maven dependencies that we have to add for a reactive
    web application based on Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding Maven configuration file for dependencies, we
    have added the `spring-boot-starter-webflux` and `reactor-test` dependencies to
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a reactive web application based on the Annotation-based programming
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The Annotation-based programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the same annotations that you have used in [Chapter 10](ef5eac66-9b41-4959-8155-96f002137409.xhtml),
    *Implementing MVC pattern in a Web Application with Spring*. Annotations such
    as `@Controller` and `@RestController` of Spring MVC are also supported on the
    reactive side. There is no difference till now between the traditional Spring
    MVC and Spring web with reactive module. The actual difference starts after the
    `@Controller` annotation configuration declaration, that is, when we go to the
    internal working of the Spring MVC, starting with `HandlerMapping` and `HandlerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the traditional Spring MVC and Spring web reactive
    comes into play in the request-handling mechanism. Spring MVC without reactive
    handles the requests using the blocking `HttpServletRequest` and the `HttpServletResponse`
    interfaces of the Servlet API, but the Spring web reactive framework is non-blocking,
    and operates on the reactive `ServerHttpRequest` and `ServerHttpResponse` rather
    than on `HttpServletRequest` and `HttpServletResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following example with a reactive controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding Controller code of `AccountController.java`,
    I have used the same Spring MVC annotations such as `@RestController` to declare
    a controller class, and `@GetMapping` and `@PostMapping` are used to create the
    request handler methods for the `GET` and `POST` request methods respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on the return types of the handler methods. These methods return
    values as **Mono** and **Flux** types. These are types of the reactive steams
    provided by the reactor framework. Also, the handler method takes the request
    body using the Publisher type.
  prefs: []
  type: TYPE_NORMAL
- en: Reactor is a Java Framework from the Pivotal open-source team. It builds directly
    on Reactive Streams, so there is no need for a bridge. The Reactor IO project
    provides wrappers around low-level network runtimes like Netty and Aeron. Reactor
    is a "4th Generation" library according to David Karnok's Generations of Reactive
    classification.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the same controller class using the functional programming model
    to handle requests.
  prefs: []
  type: TYPE_NORMAL
- en: The functional programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functional programming model uses the API that has functional interfaces
    such as `RouterFunction` and `HandlerFunction`. It uses Java 8 Lambda style programming
    with routing and request handling instead of the Spring MVC annotations. They
    are simple, but powerful, building blocks for creating web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of functional request handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the class file, `AccountHandler.java`, is based on the
    functional reactive programming model. Here, I have used the reactor framework
    to handle the request. Two functional interfaces, `ServerRequest` and `ServerResponse`,
    are used to handle requests and to generate responses.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the Repositories classes of this application. The following `AccountRepository`
    and `AccountRepositoryImpl` classes are the same for both type of applications-Annotation-based
    and the functional-based programming model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an interface `AccountRepository.java` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is an interface, let''s implements this interface with the
    `AccountRepositoryImpl.java` class as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we created the `AccountRepository` class.
    This class has only three methods: `findById()`, `findAll()`, and `save()`. We
    implemented these methods according to the business requirements. In this repository
    class, I have, especially, used the Flux and Mono react types to make it a reactive-based
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the server for the functional-based programming model. In Annotation-based
    programming, we use the simple tomcat container to deploy the web application.
    But for this functional-based programming, we have to create a Server class to
    start the Tomcat server or Reactor server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding `Server.java` class file, I have added both,
    the Tomcat and Reactor servers. The Tomcat server uses port 8080, but the Reactor
    server uses the port `8181`.
  prefs: []
  type: TYPE_NORMAL
- en: This `Server.java` class has three methods. The first method, `routingFunction()`,
    is responsible for handling client requests by using the `AccountHandler` class.
    It depends on the `AccountRepository` class. The second method, `startReactorServer()`,
    is responsible for starting the Reactor server by using the `ReactorHttpHandlerAdapter`
    class of the reactor server. This class takes an object of the `HttpHandler` class
    as a constructor argument to create the request handler mapping. Similarly, the
    third method, `startTomcatServer()`, is responsible for starting the Tomcat server.
    And it is bound to the `HttpHandler` object through a reactor adapter class, `ServletHttpHandlerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run this server class file as a Java application, and see the output
    on the browser by typing the URL, `http://localhost:8080/account/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c22f603b-fde7-4b27-9c36-9dc25d66e213.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also type the same URL with port `8181` for the Reactor server, as
    follows, and you will get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8181/account/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you learned how to create a reactive web application using
    the Spring-web-reactive module. We created the web application by using both the
    programming paradigms: Annotation-based and Functional-based.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll discuss client-side code, and how a client accesses
    the reactive web application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Reactive Client-Side application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring 5 Framework introduces a functional and reactive WebClient. It is
    a fully non-blocking and reactive web client, and an alternative to `RestTemplate`.
    It creates the network input and output in the form of reactive `ClientHttpRequest`
    and `ClientHttpRespones`. It creates the body of the request and response in the
    form of `Flux<DataBuffer>` instead of `InputStream` and `OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code for the web client, which creates a `Client.java` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class, `Client.java`, is a web client class for `Server.java`.
    It has two methods. The first method is `findAllAccounts()`. It fetches all accounts
    from the account repository. It uses the `org.springframework.web.reactive.function.client`.
    The `ClientRequest` interface to create a request to the `http://localhost:8080/account/`
    URI with the `GET` http method. By using the `org.springframework.web.reactive.function.client`.
    The `ExchangeFunction` interface, it calls the server, and fetches the result
    as the JSON format. Similarly, the other method, `createAccount()`, creates a
    new account in the server by using the URI with the `POST` method `http://localhost:8080/account/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the Client class as a Java application and see the output on the
    console, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/39fecf73-9041-45a8-b8ba-1a881bacf7a7.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a new record and fetch all five record in the form of JSON list.
  prefs: []
  type: TYPE_NORMAL
- en: The `AsyncRestTemplate` also supports non-blocking interactions. The main difference
    is that it can't support non-blocking streaming, for example, Twitter one, because,
    fundamentally, it's still based and relies on `InputStream` and `OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll talk about the request and response body parameters
    in a reactive web application.
  prefs: []
  type: TYPE_NORMAL
- en: Request and response body conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](ef5eac66-9b41-4959-8155-96f002137409.xhtml), *Implementing MVC
    Pattern in a Web Application with Spring*, we discussed message conversion for
    the request body and response body either from Java to JSON, or from JSON to Java
    object, and many more. Similarly, conversion is also required in the case of a
    Reactive web application, . The spring core module provides reactive Encoder and
    Decoder to enable the serialization of a Flux of bytes to and from the typed objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following example for request body type conversions. Developers
    do not need to forcefully do type conversion--the Spring Framework automatically
    converts it for you in both types of approaches: Annotation-based programming,
    and functional-based programming.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Account account**: This means that the account object is deserialized before
    the controller is called without blocking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mono<Account> account**: This means that `AccountController` can use the
    Mono to declare logic. The account object is first deserialized, and then this
    logic is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux<Account> accounts**: This means that `AccountController` can use Flux
    in case of the input streaming scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single<Account> account**: This is very similar to the Mono, but here the
    Controller uses RxJava.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observable<Account> accounts**: This is also very similar to Flux, but in
    this case, the Controller uses input streaming with RxJava.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding list, you saw the Spring Framework for type conversion in
    the reactive programing model. Let''s see the following return types in the example
    for the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Account**: This serializes without blocking the given Account; implies a
    synchronous, non-blocking controller method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void**: This is specific to the annotation-based programming model. Request
    handling completes when the method returns; this implies a synchronous, non-blocking
    controller method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mono<Account>**: This serializes without blocking the given Account when
    the Mono completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mono<Void>**: This implies that request handling completes when the Mono
    completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux<Account>**: This is used in the streaming scenario, possibly, the SSE
    depends on the requested content type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux<ServerSentEvent>**: This enables SSE streaming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single<Account>**: The same, but uses RxJava.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observable<Account>**: The same, but uses the RxJava Observable type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flowable<Account>**: The same, but uses the RxJava 2 Flowable type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding list, you have seen the return types of the handler methods.
    The Spring Framework does type conversions in the reactive programing model.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the Reactive pattern and its principles.
    It is not a new innovation in programming--it is a very old concept, but it very
    fits in very well with the demands of modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive programming has four principles: responsiveness, resilience, elasticity,
    and message-driven architecture. Responsiveness means a system must be responsive
    in all conditions: odd conditions and even conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring 5 Framework provides support for the reactive programming model by
    using the Reactor framework and reactive stream. Spring has introduced new a reactive
    web module, that is, spring-web-reactive. It provides the reactive programming
    approach to a web application by either using Spring MVC's annotations, such as
    `@Controller`, `@RestController`, and `@RequestMapping`, or by using the functional
    programming approach using the Java 8 Lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we created a web application by using the spring web reactive
    modules. The code for this application is available on GitHub. In the next chapter,
    you will learn about implementation of concurrency patterns.
  prefs: []
  type: TYPE_NORMAL
