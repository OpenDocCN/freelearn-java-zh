<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Explanation of ImageJ Constructs"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Explanation of ImageJ Constructs</h1></div></div></div><p>In the previous chapter, we developed macros to ease our processing and measurements. We used some techniques and constructs that are particular for the macro language in ImageJ. In this chapter, we will look at the following topics, in preparation to develop our own plugins:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Frameworks for macros and plugins</li><li class="listitem" style="list-style-type: disc">Special classes in ImageJ</li><li class="listitem" style="list-style-type: disc">Built-in functions for macros</li><li class="listitem" style="list-style-type: disc">API functions</li><li class="listitem" style="list-style-type: disc">Setting up the NetBeans IDE for development</li><li class="listitem" style="list-style-type: disc">Setting up for development using Maven</li></ul></div><div class="section" title="Frameworks for macros and plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Frameworks for macros and plugins</h1></div></div></div><p>We will look at <a id="id328" class="indexterm"/>some tools that ImageJ offers developers to deal with images <a id="id329" class="indexterm"/>and their processing. In the previous chapter, we looked at macros to perform common image-processing steps. This was already an improvement over the processing of time series one frame at a time, but ImageJ supports more tools and constructs that allow you to expand these basic tools further. In this chapter, we will look at some of these constructs as a preparation for the upcoming chapters, where we will look at plugins and their implementation.</p><p>ImageJ has two ways to process in a more automated fashion: macros and plugins. Besides the macros described in the previous chapter, ImageJ also supports other Java-based scripting languages such as Beanshell and JavaScript, as well as the scripting languages Python and Ruby, among others. The plugins can be split into two groups as well: plugins based on the original ImageJ (that is, ImageJ1.x plugins) and those based on the next development of <a id="id330" class="indexterm"/>ImageJ called <span class="strong"><strong>ImageJ2</strong></span> (ImageJ2 plugins). The ImageJ2 <a id="id331" class="indexterm"/>development is designed to be backward compatible <a id="id332" class="indexterm"/>with ImageJ1.x, although this may change in the future. In this chapter, we will look at some of the constructs available when creating scripts and plugins. We will start by looking at the scripting languages supported by ImageJ.</p><div class="section" title="Macros and scripting languages"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>Macros and scripting languages</h2></div></div></div><p>As we saw in the <a id="id333" class="indexterm"/>previous chapter, we can easily create an ImageJ macro by starting the macro recorder and performing different steps for image processing and measurements. We set the type to Macro in the recorder. We can do the same thing for two other scripting languages that ImageJ supports: <span class="strong"><strong>BeanShell</strong></span> and <span class="strong"><strong>JavaScript</strong></span>. BeanShell <a id="id334" class="indexterm"/>scripts are a type of macros, but have access to the full ImageJ and Java API. This <a id="id335" class="indexterm"/>means, besides the commands available in macros, you can also use classes and interfaces from Java, providing much more options in processing. The advantage of the BeanShell scripting language is that it is an interpreted language (it does not have to be compiled before it can be run) and requires only an interpreter that has a small footprint. This makes it easy to create fast solutions and prototyping for plugins. In the following sections, I will examine some of the concepts in the BeanShell scripting language. Note that similar results can be achieved in the JavaScript language within ImageJ, where the only difference is small changes in syntax.</p><div class="section" title="BeanShell scripting"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec25"/>BeanShell scripting</h3></div></div></div><p>BeanShell scripting <a id="id336" class="indexterm"/>allows you to create a script with all the advantages of a macro, but with the added benefit of having access to the Java API. You can use Java code almost directly as is. However, there are a few small differences. BeanShell scripts have weak typing. This means, you do not need to declare the variable type, and you can change the type of a variable on-the-fly. In all other ways, it is comparable to developing Java code. If you wish to use a class or interface from the Java API, you need to import it first using the following line of code:</p><div class="informalexample"><pre class="programlisting">import java.awt.event.KeyListener;</pre></div><p>This import statement tells the script interpreter that it needs to load the <code class="literal">KeyListener</code> class from the <code class="literal">java.awt.event</code> package. This will allow you to monitor key presses. The <code class="literal">KeyListener</code> class is an interface that can be attached to an instance of a script. The class will generate an event when a key is pressed, resulting in a call to the <code class="literal">keyPressed()</code> method, which has to be overwritten by the script. Using the <code class="literal">keyPressed()</code> method, you can perform a specific task when a certain key is pressed.</p><p>The BeanShell scripting language also supports importing existing scripts into a new script. This way, you can daisy-chain multiple scripts. Daisy-chaining scripts means you use one script's output as input for the next script and so on. The advantage of this type of processing is that each script becomes a module that can be reused and combined in different ways to achieve different results. To import an existing script into your script, use the following syntax:</p><div class="informalexample"><pre class="programlisting">this.interpreter.source("some_script.bsh");</pre></div><p>This will load the BeanShell script called <code class="literal">some_script.bsh</code> and give you access to its methods. A simple BeanShell script may consist of a series of basic ImageJ commands, but can also contain classes, functions, and even graphical user interfaces. We will now look at a few constructs <a id="id337" class="indexterm"/>used in the BeanShell scripting language that deal with ImageJ, images, and selections.</p><div class="section" title="ImageJ main class"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec02"/>ImageJ main class</h4></div></div></div><p>To access the main <a id="id338" class="indexterm"/>ImageJ window, we can use the <code class="literal">IJ</code> class to get the current instance of ImageJ. We can use this instance to gain access to some parameters that are provided by the ImageJ class:</p><div class="informalexample"><pre class="programlisting">protected ImageJ ij;
ij = IJ.getInstance();
Label status = ij.statusLine;
status.setText("Now we modified the status line text!");</pre></div><p>In this short example, we created a variable of type <code class="literal">ImageJ</code> and stored a reference to the current instance of the <code class="literal">ImageJ</code> window in this variable, called <code class="literal">ij</code>. Next, we extracted the content of the ImageJ status line and stored it in a variable called <code class="literal">status</code>. Finally, we set the text of the status line to <code class="literal">Now we modified the status line text!</code>. Of course, this example is neither directly useful nor complete, but it shows you how to get access to the main <code class="literal">ImageJ</code> interface and modify a component of the interface.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>I used two different ways of declaring and instantiating a variable: the <code class="literal">ij</code> variable was first declared and then instantiated, while the <code class="literal">status </code>variable was declared and instantiated in one line. The former would be required if your variable requires an extended scope (that is, across a loop or an entire class).</p></div></div><p>It is also possible to use the <code class="literal">IJ</code> class to execute commands that are part of the ImageJ menu structure using the <code class="literal">run()</code> method or methods such as <code class="literal">openImage()</code> to load images:</p><div class="informalexample"><pre class="programlisting">import ij.IJ;
IJ.run("In [+]", "");
imp = IJ.openImage("http://imagej.nih.gov/ij/images/blobs.gif");</pre></div><p>The second line shows you how to zoom in once using the <code class="literal">run()</code> method from the <code class="literal">IJ</code> class. The third line shows you how to open an image using the <code class="literal">openImage()</code> method, which stores a reference to the image in a variable named <code class="literal">imp</code> in this example. To gain access to an image from within a BeanShell script, we can use the <code class="literal">openImage()</code>, as described earlier, to open an image. Alternatively, we could use the current active image (if there is an opened image):</p><div class="informalexample"><pre class="programlisting">imp = IJ.getImage();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Note that in Fiji, which uses the ImageJ2 release candidate, it is required that you add the import statement before using the <code class="literal">IJ</code> class' methods. In ImageJ1.x, these packages are <a id="id339" class="indexterm"/>auto-loaded and the import statement is optional. To make sure your scripts are future proof, it is best practice to include the import statements.</p></div></div></div><div class="section" title="Functions to process images"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec03"/>Functions to process images</h4></div></div></div><p>Using the ImageJ <a id="id340" class="indexterm"/>class, you have access to the currently active image as well as to the methods to open images. There are also methods that allow you to process images on a pixel level using the <code class="literal">ImageProcessor</code> class. This class provides methods that can modify the image at the pixel level: either a single pixel or a group of pixels. The following snippet shows you how to use the <code class="literal">ImageProcessor</code> class to change the value of a specific pixel:</p><div class="informalexample"><pre class="programlisting">import ij.IJ;
import ij.process.ImageProcessor;

imp = IJ.openImage("http://imagej.nih.gov/ij/images/blobs.gif");
ip = imp.getProcessor();
ip.invertLut();
imp.setProcessor(ip);
ip.putPixel(64,128, 255);</pre></div><p>In this example, we opened the <span class="strong"><strong>Blobs</strong></span> sample image and got <code class="literal">ImageProcessor</code>. We then inverted the LUT (the <span class="strong"><strong>Blobs</strong></span> image uses an inverted LUT when opened) and put the inverted image back in the <code class="literal">imp</code> object. Finally, we set the value for the pixel at the coordinates (x = <code class="literal">64</code>, y = <code class="literal">128</code>) to a value of <code class="literal">255</code>. In this example, you will see a white pixel in one of the blobs at the location (<code class="literal">64,128</code>).</p><p>If the active image is an 8-bit image (as is the case for the <span class="strong"><strong>Blobs</strong></span> image), this would result in a white pixel. In a 16-bit image this operation would result in a dark-gray pixel. If you want to know if the current image is a gray scale image and how many bits per pixel (8, 16, 24, or 32) it has, you could include the following commands:</p><div class="informalexample"><pre class="programlisting">bGray = ip.isGrayscale();
bitDepth = ip.getBitDepth();</pre></div><p>This will allow you to determine exactly what kind of image you are dealing with. If <code class="literal">bGray</code> is <code class="literal">true</code>, the image is an 8,16, or 32 float grayscale image or a 24-bit image with identical values for the pixels in the red, green, and blue channels. The <code class="literal">bitDepth</code> value will tell you which level it is. The distinction is small, but significant. A 24-bit image that contains color information is not the same as a 24-bit image that is gray. The latter can be converted to an 8-bit image without loss of information, while the former cannot be converted to an <a id="id341" class="indexterm"/>8-bit image without losing the color information.</p></div><div class="section" title="Functions for selections"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec04"/>Functions for selections</h4></div></div></div><p>To gain access to <a id="id342" class="indexterm"/>selections in the ROI Manager, BeanShell scripts allow you to get an instance of the ROI Manager, which can then be used to extract the ROIs and use them for processing. The following code snippet takes the ROIs from the ROI Manager and enlarges them by <code class="literal">2</code> pixels:</p><div class="informalexample"><pre class="programlisting">import ij.IJ;
import ij.plugin.frame.RoiManager;

imp = IJ.getImage();
RoiManager rm = RoiManager.getInstance();
int numRois = rm.getCount();

for(i=0;i&lt;numRois;i++) {
  rm.select(i);
  IJ.run(imp, "Enlarge...", "enlarge=2");
  rm.addRoi(imp.getRoi());
}</pre></div><p>This snippet shows you some basic scripting to deal with ROIs. We first retrieved an instance of the ROI Manager, which allows us to get the ROIs as an array for processing. In the loop, we selected each ROI and used the enlarge command to increase the size of the ROI by <code class="literal">2</code> pixels in the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> directions. Finally, we added the enlarged ROIs to the ROI Manager so that we could use them later on if we would like to. This code can be used almost verbatim as Java code. The first error you would receive if you tried to compile it is contained in the following line:</p><div class="informalexample"><pre class="programlisting">imp = IJ.getImage();</pre></div><p>This works perfectly fine in a BeanShell script, but in an ImageJ plugin, it will generate an error as the type of the <code class="literal">imp</code> variable is not declared. Also, the for loop does not declare the type for the index <code class="literal">i</code> iterator, which will also generate a compiler error.</p></div></div><div class="section" title="Saving and running your scripts"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Saving and running your scripts</h3></div></div></div><p>Once we have <a id="id343" class="indexterm"/>created a testable version, we can save it and try running it. Macros <a id="id344" class="indexterm"/>are stored with either the <code class="literal">.ijm</code> or the <code class="literal">.txt</code> extension. The <code class="literal">.ijm</code> extension is preferable, as it allows the distinction between regular (non-script) text files and macro files. Script files have their own extensions: <code class="literal">.bsh</code> for BeanShell and <code class="literal">.js</code> for JavaScript.</p><p>When saving the script, the naming has to adhere to the limitations of the filesystem. Otherwise, there are no specific restrictions for the name. The location to store the scripts by default is the <code class="literal">scripts</code> or <code class="literal">macros</code> folder in the ImageJ installation folder, which I will refer to as <code class="literal">$IJ_HOME</code>. If you wish to run scripts from the command line, it is best to avoid using spaces in the filename to avoid unexpected behavior (that is, if you forget to escape the space character).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>For Fiji, the <code class="literal">$IJ_HOME</code> folder is called <code class="literal">Fiji.app</code> and can be placed at any location in the filesystem. It is recommended that you store this folder in your user account's folder, where you have read and write access. On OSX systems, the default location for Fiji is <code class="literal">/Applications/Fiji.app</code> when using the package installer.</p></div></div><p>As described about ImageJ <a id="id345" class="indexterm"/>macros in the previous chapter, BeanShell and <a id="id346" class="indexterm"/>JavaScript scripts can be installed and executed in similar ways. When using Fiji, you can open the scripts in the code editor to run them.</p></div></div><div class="section" title="Plugins for ImageJ"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>Plugins for ImageJ</h2></div></div></div><p>As we saw in the <a id="id347" class="indexterm"/>previous sections on the BeanShell scripting language, ImageJ provides an easy interface that has access to the full Java API. This also holds true for plugins. Besides the core ImageJ API, plugins can also access the full Java API by importing classes or interfaces in their source files. With the current developments within the ImageJ community, there is a new implementation of the ImageJ core code being developed, called ImageJ2. In the following sections, I will briefly give an overview of some of the changes that will influence the development of plugins. This involves introducing some constructs that are used commonly in larger projects, specifically Git and Maven. Note that knowledge of these constructs is not essential to create plugins, but they will help in creating more consistent and reproducible code. These constructs are also not specific for ImageJ2, but the ImageJ2 project was built up around those concepts. However, I will start by introducing some classes that are specific for ImageJ and deal with handling images and selections.</p><div class="section" title="ImageJ main class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec27"/>ImageJ main class</h3></div></div></div><p>The main ImageJ class <a id="id348" class="indexterm"/>refers to the class that gives access to the ImageJ application. We already saw this class in the BeanShell sections earlier. The class is called IJ, which is a static utility class. As shown earlier, this class allows access to the current image as well as other functions. The use of this class is the same as shown earlier, except when writing plugins, you need to explicitly declare the variable type. For instance, when we wish to create a new hyperstack with two 16-bit channels and 10 frames and a size of 512 X 512 pixels, we could use the following code snippet:</p><div class="informalexample"><pre class="programlisting">import ij.IJ;
import ij.ImagePlus;

ImagePlus imp = IJ.createHyperStack("New Stack",512,512,2,1,10,16);</pre></div><p>Note that we need to specify that the <code class="literal">imp</code> variable is of type <code class="literal">ImagePlus</code>, which differs from the scripting languages that we saw earlier. Another useful method of the <code class="literal">IJ</code> class is the <code class="literal">log()</code> logging method. This method prints a string to a log window, and displays the log window if it is not open yet. This function is useful for presenting intermediate results or status updates when processing large datasets. To use it, we can just call the method and supply the string we wish to print:</p><div class="informalexample"><pre class="programlisting">IJ.log("We finished processing "+nFiles+" file(s)!");</pre></div><p>This assumes there is a variable called <code class="literal">nFiles</code>, which stores the number of files that need to be processed. The log message will tell us how many files were processed, depending on the number of files selected when the plugin was executed. There are also methods to open images or get the <a id="id349" class="indexterm"/>active image, which are identical to the examples used in the scripting section (with the only difference that the type needs to be declared explicitly in a plugin).</p></div><div class="section" title="WindowManager"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec28"/>WindowManager</h3></div></div></div><p>The <code class="literal">WindowManager</code> <a id="id350" class="indexterm"/>class is a utility class in ImageJ that keeps track of all the windows (including images, results, and log windows), and provides methods <a id="id351" class="indexterm"/>that allow the selection of specific windows. Some of the most useful methods are <code class="literal">getImageTitles()</code>, <code class="literal">getImage()</code>, and <code class="literal">getCurrentImage()</code>. The <code class="literal">getImageTitles</code> method returns a <code class="literal">String</code> array with all the titles of open images. This function is useful to populate a list of files to allow the user to select a specific image for processing. The following example code will show this functionality and how it can be used within a program:</p><div class="informalexample"><pre class="programlisting">String[] imageList = WindowManager.getImageTitles();

JComboBox jcbImages = new JComboBox(imageList);</pre></div><p>This is a very user-friendly way of allowing the user to select the image for processing. Normally, ImageJ uses the last open images (the active image) by default. When the user has selected an image based on the title of the image, we can use the <code class="literal">getImage</code> method to activate that image for further processing:</p><div class="informalexample"><pre class="programlisting">ImagePlus imp;
imp = WindowManager.getImage(imageList[idx]);</pre></div><p>This allows the rest of the program to use the specified image for processing. This code will be revisited in the <a id="id352" class="indexterm"/>chapter on plugins with user interfaces.</p></div><div class="section" title="ImagePlus"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec29"/>ImagePlus</h3></div></div></div><p>The main class for <a id="id353" class="indexterm"/>images is the <code class="literal">ImagePlus</code> class, which is the main class to deal with images in ImageJ. We already briefly saw the call in the code section <a id="id354" class="indexterm"/>earlier. When invoking the <code class="literal">ImagePlus</code> class, we gain access to several get methods that help with extracting information from the image. We also apply changes to the image using set methods:</p><div class="informalexample"><pre class="programlisting">ImageProcessor ip = imp.getProcessor();
int[] pxVal = imp.getPixel(256,256);
imp.setRoi(256,256,32,32);</pre></div><p>This snippet shows a few methods that allow you to retrieve aspects of the image as well as set a region in the current image. Another important method that can be accessed using the <code class="literal">ImagePlus</code> class is the <code class="literal">ImageProcessor</code> class, as shown in the first line of the code snippet. The next section will deal with this class.</p></div><div class="section" title="ImageProcessor"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec30"/>ImageProcessor</h3></div></div></div><p>The <code class="literal">ImageProcessor</code> <a id="id355" class="indexterm"/>class is a class that allows you to work with the pixel array of an image. There are four different subclasses of the <code class="literal">ImageProcessor</code> <a id="id356" class="indexterm"/>class, which are linked to the different image types: <code class="literal">ByteProcessor</code> for 8-bit and binary images, <code class="literal">ShortProcessor</code> for 16-bit images, <code class="literal">FloatProcessor</code> for 32-bit float images, and <code class="literal">ColorProcessor</code> for RGBα images. Some of the methods that are accessible from an <code class="literal">ImageProcessor</code> instance include <code class="literal">autoThreshold()</code>, <code class="literal">crop()</code>, <code class="literal">getPixel()</code>, and <code class="literal">getIntArray()</code>. These functions allow you to set a threshold on an image, crop the image, retrieve the pixel value at a specified location or get all the pixel values as an array, respectively.</p></div><div class="section" title="RoiManager"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec31"/>RoiManager</h3></div></div></div><p>The <code class="literal">RoiManager</code> class <a id="id357" class="indexterm"/>gives the user access to the ROI Manager and all its functions. This class is essential to retrieve and manipulate the regions that were set either manually or programmatically. The <code class="literal">getRoisAsArray()</code> method allows the user to retrieve all the regions in the ROI Manager as an array, which enables the user to loop <a id="id358" class="indexterm"/>over all the regions for measurements or modifications to the regions. The following code is an example:</p><div class="informalexample"><pre class="programlisting">RoiManager rm = RoiManager.getInstance();
if (rm == null) {rm = new RoiManager();}

Roi[] regions;
regions = rm.getRoisAsArray();

for (int r=0; r&lt;regions.length; r++) {
  Roi region;
  region = regions[r];
  //do something...
}</pre></div><p>It is recommended that you use the <code class="literal">getInstance()</code> method to get a reference to the ROI Manager. If it returns a null value, you could use the constructor to create a new instance. After using the <code class="literal">getRoisAsArray()</code> method, you get an array of type <code class="literal">Roi</code>, which contains a list of <a id="id359" class="indexterm"/>regions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>You can also merge <a id="id360" class="indexterm"/>the declaration and instantiating of the <code class="literal">regions</code> variable to a single statement. I prefer to declare my variables at the beginning of a method or class and instantiate them when I have the data available. Declaring a variable before instantiating it would be essential if you need the scope of the variable to extend beyond the point where it is instantiated or assigned. When a variable is used inside and outside of a loop, but the value is only assigned within the loop, the declaration needs to be placed outside of the loop and the assignment within the loop.</p></div></div></div><div class="section" title="The Roi class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec32"/>The Roi class</h3></div></div></div><p>The <code class="literal">Roi</code> class is a generic <a id="id361" class="indexterm"/>class that encompasses all the region types that ImageJ supports. You can use this class to retrieve relevant properties of a region, such as the bounding <a id="id362" class="indexterm"/>box of the region using the <code class="literal">getBounds()</code> method. It is also possible to change the size using the <code class="literal">grow()</code> method. The <code class="literal">Roi</code> class has several subclasses that are linked to the different region types available in ImageJ. Some of these subclasses have additional methods that are specific for area regions. For instance, the <code class="literal">PolygonRoi</code> subclass has methods to retrieve the coordinates of the polygon, <code class="literal">getXCoordinates()</code> and <code class="literal">getYCoordinates()</code>, which return an <code class="literal">int</code> array of coordinates.</p></div></div></div></div>
<div class="section" title="The Application Programming Interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>The Application Programming Interface</h1></div></div></div><p>As with <a id="id363" class="indexterm"/>many programming languages, ImageJ has a well-documented <span class="strong"><strong>Application Programming Interface</strong></span> (<span class="strong"><strong>API</strong></span>). It describes <a id="id364" class="indexterm"/>all of the classes, methods, and fields that are accessible for programming. The API reference can be found on the ImageJ website at <a class="ulink" href="http://javadoc.imagej.net/ImageJ1">http://javadoc.imagej.net/ImageJ1</a> (ImageJ1.x), <a class="ulink" href="http://javadoc.imagej.net/ImageJ">http://javadoc.imagej.net/ImageJ</a> (ImageJ2), and <a class="ulink" href="http://javadoc.imagej.net/Fiji">http://javadoc.imagej.net/Fiji</a> (Fiji). The API documentation is an efficient way to find classes and methods that can be used to extract relevant information. The classes mentioned in the previous sections can be found using the API page. You can also find a complete list of methods and fields that are available, including the return types of the methods. In the section on setting up an IDE to develop plugins, I will also briefly explain how to set up the generation of Javadoc. Javadoc is a method that parses your source code and extracts specially formatted comments to build up a documentation manual. This can be done for the ImageJ source code, which results in an API that can be accessed offline. I will also show you how to write your own Javadoc documentation and then generate an API for your own code in the chapter on plugin development. This is not essential for <a id="id365" class="indexterm"/>small projects, but can be very helpful for large projects with complex code that uses many classes and methods.</p></div>
<div class="section" title="Setting up NetBeans IDE"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Setting up NetBeans IDE</h1></div></div></div><p>We will now <a id="id366" class="indexterm"/>look at how to set up an <span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>) that can be used to develop ImageJ as well as plugins for ImageJ. There are many IDEs available for Java. While this section will show you how to set up a specific IDE called NetBeans, many of these settings and configurations can be replicated in your preferred IDE.</p><p>The setup I will describe is for the NetBeans IDE, which is developed by the same company that manages the Java language. It can be downloaded in different variants, including a variant for Java development, webpage development, and C++ development. If you only wish to develop plugins for ImageJ, the Java SE (Standard Edition) or Java EE (Enterprise Edition) downloads should be fine. The enterprise edition is similar to the standard edition, but it has additional APIs for multilevel and scalable applications as well as secure network applications. It is possible to extend the basic Java edition and add modules for web development or C++ coding later on using the <span class="strong"><strong>Plugins Manager</strong></span> (<span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Plugins</strong></span>).</p><p>For the upcoming sections, I will assume that the Java SE was installed. However, to set up the environment, it <a id="id367" class="indexterm"/>should not make a difference. It can be downloaded from <a class="ulink" href="https://netbeans.org/downloads/">https://netbeans.org/downloads/</a>. After downloading, it can be installed using the standard method for your platform. For Windows systems, there is an installer that can be run by double-clicking. For OS X, there is DMG with a package file that can be used for installation. For Linux systems, there is a shell script installer, and some distributions may supply it from their repositories. It is recommended that you use the version from the NetBeans website, as it is more recent than the version in many of the repositories.</p><p>The following sections will describe how to develop ImageJ1.x plugins without using project tools. This method only requires a single download and functions as a standalone development platform. If you wish to develop plugins using the Maven platform for ImageJ1.x and ImageJ2, the following sections can be skipped, and you can continue to the <span class="emphasis"><em>Developing plugins using Maven</em></span> section.</p><div class="section" title="Gathering all components"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>Gathering all components</h2></div></div></div><p>After the <a id="id368" class="indexterm"/>installation has completed, you should be able to launch the NetBeans application. When you launch it for the first time, there will be a start page that allows you to take a tour of the software and watch a quick tutorial project. You can examine the settings and adjust them to your liking.</p><p>Next, we need to download the source code for ImageJ. The source code can be downloaded from the ImageJ website at <a class="ulink" href="http://imagej.nih.gov/ij/download/src/">http://imagej.nih.gov/ij/download/src/</a>, where you will find a list of different versions, from version 1.20 up to the most recent version (1.50a). Which version you download is not <a id="id369" class="indexterm"/>critical. However, it is best to use the most recent version with the recent bug fixes and functionality added. After the download has finished, the archive can be extracted, resulting in a folder named <code class="literal">source</code>. For the following sections, I will assume that the content of the <code class="literal">source</code> folder was extracted to the <code class="literal">ij/src</code> folder within the Documents folder <a id="id370" class="indexterm"/>of your user profile. This folder location will be referred to as the <code class="literal">source</code> folder in the next sections.</p></div><div class="section" title="Setting up a project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Setting up a project</h2></div></div></div><p>The setup of the <a id="id371" class="indexterm"/>project described here follows the description given at <a class="ulink" href="http://rsb.info.nih.gov/ij/developer/NBTutorial.html">http://rsb.info.nih.gov/ij/developer/NBTutorial.html</a>, but with a few adjustments. First, the <a id="id372" class="indexterm"/>method to create a project does not work properly when using NetBeans version 8.0. The steps described here will accomplish the same result but with a few key changes.</p><p>The first step is to set up a new project for ImageJ in NetBeans.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To do so, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Project…</strong></span>, which will open the following dialog:<div class="mediaobject"><img src="graphics/Insert_image_4909_07_01.jpg" alt="Setting up a project"/></div></li><li class="listitem">In the dialog, select the <span class="strong"><strong>Java</strong></span> category and select <span class="strong"><strong>Java Free-Form Project</strong></span>, as shown <a id="id373" class="indexterm"/>in the figure. Then, click on <span class="strong"><strong>Next &gt;</strong></span>.</li><li class="listitem">In the next step, we have to select the folder that contains the source. <span class="strong"><strong>Click on Browse…</strong></span> and select the <code class="literal">src</code> folder that contains the extracted source code. If the copying was done properly, the remaining fields will be completed automatically with the correct information:<div class="mediaobject"><img src="graphics/Insert_image_4909_07_02.jpg" alt="Setting up a project"/></div></li><li class="listitem">We can now click on <span class="strong"><strong>Next &gt;</strong></span> to proceed to <span class="strong"><strong>Build and Run Actions</strong></span> and then click on <span class="strong"><strong>Next</strong></span> again without modifying the fields.</li><li class="listitem">In the next step, we have to set the locations that will contain our source code for ImageJ and for our plugins.</li><li class="listitem">To do so, add <a id="id374" class="indexterm"/>the <code class="literal">ij/src/ij</code> and <code class="literal">ij/src/plugins</code> folders in the <span class="strong"><strong>Source Package Folders</strong></span> field. You can remove the first entry marked with a period from the source package folders. I have set the source level to JDK 1.7, which forces NetBeans to use a newer version of Java compared to the definition in the build instructions of the ImageJ source code:<div class="mediaobject"><img src="graphics/Insert_image_4909_07_03.jpg" alt="Setting up a project"/></div></li><li class="listitem">Click on <span class="strong"><strong>Finish</strong></span> to complete the setup process:</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>The last two steps can be kept to default settings.</p></div></div><p>The project will now be created, and the main window of NetBeans will show the new project in the <a id="id375" class="indexterm"/>
<span class="strong"><strong>Projects</strong></span> tab on the left-hand side. The project name (<code class="literal">ImageJ</code>) has two package sources below it: one for ImageJ source code (<code class="literal">ij</code>) and one for the plugin source code (<code class="literal">plugins</code>).</p><p>The <span class="strong"><strong>Files</strong></span> tab will show an overview of the files associated with the project:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_04.jpg" alt="Setting up a project"/></div><p>The next section will <a id="id376" class="indexterm"/>look at the configuration required building build ImageJ.</p></div><div class="section" title="Building ImageJ"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Building ImageJ</h2></div></div></div><p>We will now set up the <a id="id377" class="indexterm"/>environment to build ImageJ. This will allow us to create a functional ImageJ program from which we will be able to execute our plugins and macros. The first step is to modify the build instructions that will be used when building the ImageJ project. To do so, select the <span class="strong"><strong>Projects</strong></span> tab and double-click on the <code class="literal">build.xml</code> file at the bottom of the ImageJ project to open the build file. This is a standard XML file that can be edited using the XML syntax. To disable sections of code, you can use either a comment tag (<code class="literal">&lt;!-- --&gt;</code>) around that section or delete it completely. The comment method is advised if you wish to restore the file to the original state. The first line that needs to be disabled is line 12 (I'm using comments to disable it):</p><div class="informalexample"><pre class="programlisting">&lt;!-- &lt;exclude name="plugins/**"/&gt; --&gt;</pre></div><p>Save the file after making the change. Next, we will remove the two <code class="literal">.source</code> files from the <code class="literal">plugins</code> folder, but not the <code class="literal">.class</code> files. We can now start building ImageJ, by clicking on <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Build Project (ImageJ)</strong></span> or pressing <span class="emphasis"><em>F11</em></span>. There may be a few red warnings in the <span class="strong"><strong>Build output</strong></span> window, but these can be ignored for now. At the end of the output, it should say <span class="strong"><strong>BUILD SUCCESSFUL</strong></span>. We will now add the newly created ImageJ build to the project. To do so, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Project Properties (ImageJ) </strong></span>and then to the <span class="strong"><strong>Java Sources Classpath</strong></span> category. First, select <span class="strong"><strong>ij[ij]</strong></span> as the source package folder and click on the <span class="strong"><strong>Add JAR/Folder</strong></span> button. Browse to the <code class="literal">src</code> folder, select the <code class="literal">ij.jar</code> file, and press the <span class="strong"><strong>Choose</strong></span> button. Repeat this for the <code class="literal">plugins [plugins]</code> source package folder, and then press <span class="strong"><strong>OK</strong></span> to finish. We are now ready to set up the configuration to develop plugins.</p></div><div class="section" title="Creating a plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Creating a plugin</h2></div></div></div><p>We will now create <a id="id378" class="indexterm"/>a very basic plugin to prepare everything to compile and debug plugins using NetBeans. First, switch to the <span class="strong"><strong>Files</strong></span> tab and right-click on the plugins folder. Then, go to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Java Class</strong></span> from the context menu. In the dialog that opens, set the <span class="strong"><strong>Class Name</strong></span> to <code class="literal">Plugin_Frame</code> (or something else, but always include an underscore in the name!). It is advised that you create a package for the new class instead of the default package (I'm using <span class="strong"><strong>Template</strong></span> as an example). Click on <span class="strong"><strong>Finish</strong></span> to create the new Java source file:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_05.jpg" alt="Creating a plugin"/></div><p>Next, we will place <a id="id379" class="indexterm"/>the following code in the newly created source file:</p><div class="informalexample"><pre class="programlisting">import ij.ImagePlus;
import ij.plugin.filter.PlugInFilter;
import ij.process.ImageProcessor;


public class Plugin_Frame implements PlugInFilter {
  protected ImagePlus imp;
  
  public int setup(String arg, ImagePlus imp) {
    this.imp = imp;
    return DOES_8G | DOES_16 | DOES_32;
  }
  
  public void run(ImageProcessor ip) {
    ip.invert();
  }
}</pre></div><p>This will create a plugin that inverts the LUT of the currently active image. Next, save the source file, and we will compile the code that we just added to our source file. To compile the source code, go to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Compile File</strong></span> or press <span class="emphasis"><em>F9</em></span>.</p><p>A window will pop up to ask whether you wish to generate an ide-file-targets.xml file, so click on <span class="strong"><strong>Generate</strong></span>. A new <a id="id380" class="indexterm"/>file will open that contains the build instructions for your plugin:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_06.jpg" alt="Creating a plugin"/></div><p>In the <code class="literal">ide-file-targets.xml</code> file, we will modify two lines. First, we will change line 9 to the following:</p><div class="informalexample"><pre class="programlisting">&lt;javac destdir="plugins" includes="${files}" source="1.7" srcdir="plugins"&gt;</pre></div><p>We will replace <code class="literal">${build.classes.dir}</code> with <code class="literal">plugins</code>. Next, we will comment line 8 (or delete it):</p><div class="informalexample"><pre class="programlisting">&lt;!-- &lt;mkdirdir="${build.classes.dir}"/&gt; --&gt;</pre></div><p>Now, save the modified file and select your plugin file again. We will compile the file again by going to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Compile File</strong></span> or by pressing <span class="emphasis"><em>F9</em></span>. In the output view, it should show that the build was successful. Next, we are going to set up the debugging for plugins. Select <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Debug Project (ImageJ)</strong></span> at which point a dialog will pop up asking for the output to be set. Click on <span class="strong"><strong>Set Output</strong></span> and then on <span class="strong"><strong>OK</strong></span> to accept the default values. Go to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Debug Project (ImageJ) </strong></span>again, and NetBeans will ask to generate an <code class="literal">ide-targets.xml</code> file. Click on <span class="strong"><strong>Generate</strong></span> to create the file and leave the file unaltered. For the final time, go to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Debug Project (ImageJ)</strong></span>. This time, ImageJ will launch, and your plugin can be found in the <span class="strong"><strong>Plugins</strong></span> menu. To start your plugin, select <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Template</strong></span> | <span class="strong"><strong>Plugin Frame Plugin</strong></span>, and your plugin should become visible.</p><p>Whenever you want to test or change your code, remember to close the ImageJ instance that was created when you select debug. Every time you select <span class="strong"><strong>Debug Project (ImageJ)</strong></span>, a new ImageJ window will open. This will make it very difficult to keep track of which code you are actually <a id="id381" class="indexterm"/>debugging.</p></div><div class="section" title="Creating documentation"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec52"/>Creating documentation</h2></div></div></div><p>The Java <a id="id382" class="indexterm"/>language has a nicely integrated way of creating documentation using specially formatted comments within the source files. When applied consistently in your source files, it can be very easy to create an API document. In the next section, we will look at how to set up the basics for documentation.</p><div class="section" title="ImageJ Javadoc"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec33"/>ImageJ Javadoc</h3></div></div></div><p>We will first generate the <a id="id383" class="indexterm"/>Javadoc for the ImageJ project. To do so, we will select the ImageJ project and go to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Generate Javadoc (ImageJ)</strong></span>. The Javadoc will be generated for the ImageJ project in a folder named <code class="literal">api</code>, which can be found in the <code class="literal">/ij</code> folder. It contains a list of HTML files and style files. To view the documentation, just view the <code class="literal">index.html</code> file in a web browser, and you will see the ImageJ API <a id="id384" class="indexterm"/>documentation. This view is very similar to the API that we saw online in the section on the API, and the information is identical. It is usually not necessary to generate Javadoc for the ImageJ project multiple times, unless you modify the documentation. In the next section, we will look at creating some Javadoc comments for your own plugins.</p></div><div class="section" title="Plugin Javadoc"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec34"/>Plugin Javadoc</h3></div></div></div><p>To generate Javadoc for <a id="id385" class="indexterm"/>your plugins, you need to add some specially formatted comments to your code. There is a lot of documentation about Javadoc online, so the information presented here will be very basic, but should provide a useful starting <a id="id386" class="indexterm"/>point. To start with, you first need to decide how much documentation is required. You can make well-crafted documents with a lot of detail, but if your code is very simple, it would cost much more time to write the documentation than to develop the code. That being said, it will be helpful to have some documentation to be able to identify the function that a method serves after some time has passed.</p><p>Let's look at an example of documentation for a simple method that has input parameters and an output parameter.</p><div class="informalexample"><pre class="programlisting">private double[] measureParticles(Roi[] r, ImagePlus imp) {}</pre></div><p>This is the basic method definition of a function to measure some properties of a collection of regions within an image, and it returns an array of measurements. To include the documentation, we will precede the function definition with the following section:</p><div class="informalexample"><pre class="programlisting">/**
 * Take regions within an image and measure the fractal 
 * dimension of the provided regions.
 * 
 * @param r Roi array containing the particles
 * @param imp reference to image containing the particles
 * @return array with the same dimensions as r containing 
 * the values for the fractal dimension.
 */</pre></div><p>A Javadoc section needs to start with a forward slice followed by two asterisks. When you press enter after the Javadoc opening tag, NetBeans will generate the code for the input parameters (<code class="literal">@param</code>) and the return value (<code class="literal">@return</code>) automatically. The only thing you have to add is the actual meaning of the parameters.</p><p>Once your code has <a id="id387" class="indexterm"/>been documented, you will have to instruct NetBeans to build the Javadoc code. To do this, make the following adjustments to the <code class="literal">build.xml</code> file by replacing the existing <code class="literal">javadoc</code> section (it should be at the end of the file) with the following instructions:</p><div class="informalexample"><pre class="programlisting">&lt;target name="javadocs" description="Build the JavaDocs."&gt;
&lt;delete dir="../plugins_api" /&gt;
&lt;mkdir dir="../plugins_api" /&gt;
&lt;javadoc
destdir="../plugins_api"
           author="true"
           version="true"
           use="true"
windowtitle="ImageJ plugins API"&gt;
&lt;fileset dir="." includes="**/*.java" /&gt;
&lt;/javadoc&gt;
&lt;/target&gt;</pre></div><p>This will build the ImageJ and your plugins documentation in a folder named <code class="literal">plugins_api</code>, located one level above your source data. If you created a package for your plugins, you also need to create a <code class="literal">package-info.java</code> file that contains the information about the package. To create this info file, right-click on your package in the <span class="strong"><strong>Projects</strong></span> view and go to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Java Package Info…</strong></span> from the context menu. Alternatively, you can also go to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Other…</strong></span> in the menu. In the dialog that opens, just click on <span class="strong"><strong>OK</strong></span> to accept the default values. The file will be generated, and you can add your package documentation right above the package line in the usual way. You need to create this info file for every package that you create.</p><p>After the documentation is compiled, you can view it by opening the <code class="literal">plugins_api/index.html</code> file in a browser. The ImageJ documentation will be shown first in the overview panel in the top-left corner. At the bottom will be your package(s). By clicking on them, you will see all the classes that are defined within the package. When you click on a <a id="id388" class="indexterm"/>class, the documentation that you supplied will be shown and can be browsed.</p></div></div><div class="section" title="Developing plugins using Maven"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec53"/>Developing plugins using Maven</h2></div></div></div><p>In the <a id="id389" class="indexterm"/>previous sections, I discussed how to set up NetBeans for the development of ImageJ and plugins in a standalone configuration. However, as the design of ImageJ is being expanded, there was a need to create a more modular approach. This approach involves a more project-based building of different modules into a single program. The advantage of such a modular approach makes for a very flexible application that can be expanded in the future. The disadvantage is that it requires a little more overhead to make sure that all dependencies are met for a fully functional program. This is where Apache Maven comes in. Maven is a toolset to describe how to build a project into a finished program and which dependencies are required.</p><p>It does this using a special file called the <span class="strong"><strong>Project Object Model</strong></span> (<span class="strong"><strong>POM</strong></span>), which is an XML file. This file is stored in the root of your project and is called <code class="literal">pom.xml</code>. The content of the file describes some aspects of the project, such as a unique set of identifiers, and a list of dependencies that are required by the project. When you tell Maven to parse the POM file, it will collect all the required resources and compile the source code, run specified tests, and finally package the program in a JAR file. Maven is aimed at taking a clear project description and performing all the required tasks necessary to create the final package automatically without the developer needing to specify each step manually. This is what the previous sections described using the Ant mechanism to build code. First, let's look at how the POM is constructed in Maven, and how it's used to build a project.</p><div class="section" title="Construction of the POM"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec35"/>Construction of the POM</h3></div></div></div><p>The POM file <a id="id390" class="indexterm"/>describes the structure of a project. It describes the location of the source code (by default, this is <code class="literal">/src/main/java</code>) and the build directory where the compiled program is stored (by default, this is <code class="literal">/target</code>). The minimal <a id="id391" class="indexterm"/>POM file contains the following structure:</p><div class="informalexample"><pre class="programlisting">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;some.packaged.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app-name&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/project&gt;</pre></div><p>This minimal POM file will inherit all the defaults from the <code class="literal">Super POM</code> file. This means, everything that is not explicitly named in the POM; the default values will be used. This includes values such as the location of the source files, the <code class="literal">build</code> directory, the build file type (<code class="literal">.jar</code> by default), and other options such as the repositories used to download sources. For an <a id="id392" class="indexterm"/>ImageJ1.x plugin, the following POM is the <a id="id393" class="indexterm"/>minimal description:</p><div class="informalexample"><pre class="programlisting">&lt;project&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;parent&gt;
  &lt;groupId&gt;net.imagej&lt;/groupId&gt;
  &lt;artifactId&gt;pom-imagej&lt;/artifactId&gt;
  &lt;version&gt;13.2.0&lt;/version&gt;
  &lt;relativePath /&gt;
&lt;/parent&gt;

&lt;groupId&gt;sc.fiji&lt;/groupId&gt;
&lt;artifactId&gt;Plugin_Name&lt;/artifactId&gt;
&lt;version&gt;1.0.0&lt;/version&gt;

&lt;name&gt;plugins/Plugin_Name.jar&lt;/name&gt;
&lt;description&gt;A Maven project implementing an ImageJ1.x plugin&lt;/description&gt;

&lt;properties&gt;
  &lt;main-class&gt;Plugin_Name&lt;/main-class&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;net.imagej&lt;/groupId&gt;
    &lt;artifactId&gt;ij&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
      &lt;configuration&gt;
        &lt;archive&gt;
          &lt;manifest&gt;
            &lt;mainClass&gt;${main-class}&lt;/mainClass&gt;
          &lt;/manifest&gt;
        &lt;/archive&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;

&lt;/project&gt;</pre></div><p>This describes the project using ImageJ as the parent project. This is necessary because the plugin we want to develop requires the ImageJ to be built. Next, we specified the <code class="literal">artifactId</code> using the name of our plugin; in this case, I used the generic name <code class="literal">Plugin_Name</code>. In the <a id="id394" class="indexterm"/>
<code class="literal">properties</code> field, we stated the main class of <a id="id395" class="indexterm"/>the project, which is the name of the plugin.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Note that the <code class="literal">&lt;version&gt;</code> tag within the <code class="literal">&lt;parent&gt;</code> tag will control which version of ImageJ1.x will be retrieved. Using version 7.0.0 will retrieve version 1.49q, while 13.2.0 will retrieve version 1.50a.</p></div></div><p>Next, we described the dependencies that are required for the plugin, which is ImageJ for a plugin. Finally, we described the build process, stating that we want a JAR file. The manifest should include the <code class="literal">main</code> class described by the main-class field in the properties object. This method does not require any downloading of source code. The next section will explain how to set up a plugin for ImageJ1.x using a POM in NetBeans.</p></div><div class="section" title="Creating a Maven plugin project"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec36"/>Creating a Maven plugin project</h3></div></div></div><p>Using a Maven <a id="id396" class="indexterm"/>project to develop a plugin is very <a id="id397" class="indexterm"/>simple and only requires a few basic steps. In many cases, you can use the default values from the POM model, and you will only need to specify the name of your plugin(s), a version number, and an artifact name. We will start by creating a new Maven project using NetBeans by going to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Project</strong></span> from the menu. From the categories list, we will select <span class="strong"><strong>Maven</strong></span>, and from the <span class="strong"><strong>Projects</strong></span> list, we will select <span class="strong"><strong>POM Project</strong></span> and click on <span class="strong"><strong>Next &gt;</strong></span>:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_07.jpg" alt="Creating a Maven plugin project"/></div><p>In the next window, we <a id="id398" class="indexterm"/>can set the main properties of our <a id="id399" class="indexterm"/>plugin. For this example, I will create a dummy plugin that I will call <code class="literal">Awesome_Plugin</code>. I will place it in the NetBeans workspace folder, which is the default folder that is created when you install NetBeans:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_08.jpg" alt="Creating a Maven plugin project"/></div><p>I added <span class="strong"><strong>Group ID</strong></span> and a version number, but these can be changed later on quite easily. After pressing <span class="strong"><strong>Finish</strong></span>, the project will be created and added to your project view (if you cannot see your project view, select <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Projects</strong></span> from the menu). If you expand the project, you will notice that there are three folders, with the most important one, at the moment, being <span class="strong"><strong>Project Files</strong></span>. This folder contains the <code class="literal">pom.xml</code> file that we will edit next. You can open the POM file for editing by expanding the project files folder in the project or by right-clicking on <a id="id400" class="indexterm"/>the project root and selecting <a id="id401" class="indexterm"/>
<span class="strong"><strong>Open POM</strong></span> from the context menu. The POM file will now look as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

&lt;groupId&gt;tools&lt;/groupId&gt;
&lt;artifactId&gt;Awesome_Plugin&lt;/artifactId&gt;
&lt;version&gt;0.1.0-SNAPSHOT&lt;/version&gt;

&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;properties&gt;
&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;/properties&gt;

&lt;name&gt;Awesome_Plugin&lt;/name&gt;
&lt;/project&gt;</pre></div><p>As you can see, NetBeans added a few more properties to the <code class="literal">&lt;project&gt;</code> tag, identifying the XML schema that was used for this POM file. It also set the <code class="literal">&lt;properties&gt;</code> tag with a tag stating the source file encoding that will be used (UTF-8). It also states which packaging will be used. For plugins, we need to change this to JAR. There are two ways to change a parameter in the POM file. The first one is to modify the <code class="literal">pom.xml</code> file directly by adding or modifying tags. The other option is to select <span class="strong"><strong>Properties</strong></span> from the context menu by right-clicking on the project. This will provide a form that contains many of the fields that <a id="id402" class="indexterm"/>are placed in the <code class="literal">pom.xml</code> file. For <a id="id403" class="indexterm"/>the remainder of this section, I will assume we edit the <code class="literal">pom.xml</code> file directly, as this allows for more flexibility and gives access to more tags than the properties dialog provides.</p><p>In order to state that we require ImageJ to be present for our plugin, we will include the <code class="literal">&lt;parent&gt;</code> tag and its contents, as shown earlier. Next, we will take the <code class="literal">&lt;dependencies&gt;</code> tag and its contents and add them to the <code class="literal">pom.xml</code> file. When we now save the <code class="literal">pom.xml</code> file, you may notice that the folder structure in the project view changes. There are now only two folders called <code class="literal">Dependencies</code> and <code class="literal">Project Files</code>. You may also notice that the <span class="strong"><strong>Dependencies</strong></span> folder contains two files: <code class="literal">ij-1.50a.jar</code> and <code class="literal">tools.jar</code>. These files are <code class="literal">required</code> to launch ImageJ. The former file is the actual ImageJ program, while the latter is a jar file that ImageJ requires to run.</p><p>If we try to build or run our project at this stage, we will get an error from NetBeans. It is complaining that the project is missing a file to build. This is not surprising as we haven't stated which file we want to build. Also, we haven't defined a main class yet to run, so we first need to fix this issue. To state where our main class will be, we will add the <code class="literal">&lt;main-class&gt;</code> tag to the <code class="literal">&lt;properties&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;main-class&gt;Awesome_Plugin&lt;/main-class&gt;</pre></div><p>Now that we have stated where our main class will be found, we need to specify how to build the project. We will do this using the <code class="literal">&lt;build&gt;</code> tag, as shown in the minimal <code class="literal">ImageJ POM</code> earlier. The line within the <code class="literal">&lt;manifest&gt;</code> tag describes that we wish to use the main class defined in the properties described by the <code class="literal">&lt;main-class&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;mainClass&gt;${main-class}&lt;/mainClass&gt;</pre></div><p>After saving the POM file, we can try to build the plugin again, but we will still get an error. This is because we are still missing the actual source code. We have created a project description, but we haven't created a source file yet. We will now add a source file to our project, which must have the same name as the value of the <code class="literal">&lt;artifactId&gt;</code> tag. To add the source file, right-click on the project in the project view and select <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Java Class</strong></span>. This will open the <a id="id404" class="indexterm"/>
<span class="strong"><strong>New Java Class</strong></span> <a id="id405" class="indexterm"/>dialog:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_09.jpg" alt="Creating a Maven plugin project"/></div><p>The filename needs to be set to <code class="literal">Awesome_Plugin</code> for this example, as this is the <code class="literal">artifactId</code> that we used up to now. The folder where we wish to place the file needs to be specified as <code class="literal">/src/main/java</code>, as this is the default location used in POM projects. Since I did not change this value, we need to specify it here as well. If you change the location of the source folder, you need to specify it in the new Java class and POM files. After clicking on <span class="strong"><strong>Finish</strong></span>, the file will be created and displayed in your project inside a new folder. The <code class="literal">Source Packages</code> folder has been added and contains a package called <code class="literal">&lt;default package&gt;</code>, which contains your source file called <code class="literal">Awesome_Plugin.java</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>If you wish to place the plugin in a specified package, you can add a package declaration to your source file and ask NetBeans to move the file to the correct folder. The latter can be done after we add the package statement. We can then press <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span> while the cursor is on the package statement and select <span class="strong"><strong>Move class to correct folder</strong></span> from the context menu. This example assumes that we kept the default package.</p></div></div><p>When we now build the <a id="id406" class="indexterm"/>project, we will see that the build is successful, meaning that everything is set up correctly for building. However, when <a id="id407" class="indexterm"/>we try to run the project, we will need to supply the main class:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_10.jpg" alt="Creating a Maven plugin project"/></div><p>The problem now is that we don't have a main class at this stage. The source code only has a class declaration, but we haven't added any code or a main method. To fix this, we need to add a main method to the source file:</p><div class="informalexample"><pre class="programlisting">public static void main(String[] args) {
  //set the plugins.dir property to make the plugin appear in the Plugins menu
  Class&lt;?&gt;clazz = Awesome_Plugin.class;
  String url = clazz.getResource("/" + clazz.getName().replace('.', '/') + ".class").toString();
  int lastIdx = url.lastIndexOf('/');
  String pluginsDir = url.substring(5, lastIdx);
  System.setProperty("plugins.dir", pluginsDir);

  // start ImageJ
  new ImageJ();
}</pre></div><p>This is a standard main method that is common to Java programs. This method is not required for ImageJ plugins. The standard entry point for plugins is usually the run method (<code class="literal">Plugin</code> and <code class="literal">PlugInFilter</code>) or the constructor (<code class="literal">PlugInFrame</code>). This main method is only for the purpose of the Maven build process and to make sure that ImageJ is started by instantiating a new ImageJ object.</p><p>The first line gets a reference to the plugin class that we created. In the next line, we extracted the full path, including the class file. This URL will have the following format: <code class="literal">file:/path/to/Awesome_Plugin.class</code>. In the next line, we removed the <code class="literal">file:</code> and the <code class="literal">Awesome_Plugin</code> parts <a id="id408" class="indexterm"/>from the beginning and end of the URL, respectively, using the <code class="literal">lastIndexOf()</code> method. The <code class="literal">clazz.getName()</code> call will return a string that will have the following format:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">class Awesome_Plugin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">class package.name.Awesome_Plugin</code></li></ul></div><p>The second format would be used if you used a package for your plugin, while the first format is used when you omit the package statement from your plugin. Using the <code class="literal">lastIndexOf()</code> method, we <a id="id409" class="indexterm"/>can include the package folders in the path as well, resulting in an error-free compilation and the correct placement of the plugin in the <span class="strong"><strong>Plugins</strong></span> menu. We will then add the folder that contains the class to the <code class="literal">plugins.dir</code> property. Finally, we will start ImageJ by invoking a new instance using the <code class="literal">new</code> keyword.</p><p>At this stage, we have the minimal code to run and debug our plugin. When we run the project now, ImageJ should open, and the plugin should be visible in the <span class="strong"><strong>Plugins</strong></span> menu. We can select it, but it may generate an error when we select the plugin from the menu:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_07_11.jpg" alt="Creating a Maven plugin project"/></div><p>This would occur if you used a package definition in your class file (in my example, I used the <code class="literal">analysis.tools</code> package). You can solve this by adding the following line to the end of your main method:</p><div class="informalexample"><pre class="programlisting">// run the plugin
IJ.runPlugIn(clazz.getName(), "");</pre></div><p>This will run the plugin immediately after ImageJ has started. If you defined the class without a package statement, you would not encounter this problem. It is, therefore, easier to start by developing <a id="id410" class="indexterm"/>plugins using the source files <a id="id411" class="indexterm"/>without a package statement. In the upcoming chapters, we will look at what we need to do to make a functional plugin.</p></div><div class="section" title="Creating an ImageJ2 plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec37"/>Creating an ImageJ2 plugin</h3></div></div></div><p>The steps to create a <a id="id412" class="indexterm"/>Maven project for an ImageJ2 plugin is <a id="id413" class="indexterm"/>very similar to the steps taken in the previous section. Only a small change is required in the POM file within the <code class="literal">&lt;dependencies&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;net.imagej&lt;/groupId&gt;
    &lt;artifactId&gt;imagej&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><p>By changing the value of the <code class="literal">&lt;artifactId&gt;</code> tag from <code class="literal">ij</code> to <code class="literal">imagej</code>, we specify that we wish to implement an ImageJ2 instance. When we <span class="strong"><strong>Save and Build</strong></span> the project, we will see that the <code class="literal">imagej-2.0.0-rc-41.jar</code> file has replaced the earlier <code class="literal">ij-1.50a.jar</code> file. We would also need the repository for the ImageJ2 project:</p><div class="informalexample"><pre class="programlisting">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;imagej.public&lt;/id&gt;
    &lt;url&gt;http://maven.imagej.net/content/groups/public&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;</pre></div><p>The final change that is required is within the plugin source code. We need to use different import statements and change the way ImageJ is launched:</p><div class="informalexample"><pre class="programlisting">import net.imagej.ImageJ;
[...]
public static void main(String[] args) {
  [...]
  // start ImageJ
  final ImageJ ij = net.imagej.Main.launch(args);
}</pre></div><p>The syntax of ImageJ2 <a id="id414" class="indexterm"/>used in plugins is also different compared <a id="id415" class="indexterm"/>to ImageJ1.x, which is a topic we will discuss in the following chapters.</p></div></div><div class="section" title="Pros and cons of using an IDE"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Pros and cons of using an IDE</h2></div></div></div><p>Using an IDE such as <a id="id416" class="indexterm"/>NetBeans has some benefits to help you write code. There are <a id="id417" class="indexterm"/>options to autocorrect coding errors and the possibility to automatically import dependencies. The disadvantages are not very big, but working with an IDE has a lot of overhead in terms of preparations and setting up. No matter how complete the IDE is, it can still not tell you how to solve a problem. Also, in some cases, it can be faster to just type the code directly using the script editor supplied with Fiji. The IDE is also not well suited to develop ImageJ macros, because macros in ImageJ are not compiled and are, therefore, not easy to integrate in the workflow of the IDE.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we looked at the framework of macros and plugins that are available in ImageJ. We looked at some of the constructs that the ImageJ API exposes for use in scripting and plugins. Finally, we described how to set up an IDE to develop ImageJ and plugins using it as standalone project or as a Maven-based project. You also saw how to generate documentation using the Javadoc utility.</p><p>In the next chapter, we will look at some plugins that are available and how they provide a solution to image-processing problems.</p></div></body></html>