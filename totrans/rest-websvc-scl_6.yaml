- en: Chapter 6. Creating REST Services with the Play 2 Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 使用 Play 2 框架创建 REST 服务
- en: For the last REST framework in this book, we will look at Play 2\. Play 2 is
    a modern web framework that can be used to create complete applications. Part
    of the tools this framework provides allows you to quickly and easily create REST
    services. In this chapter, we'll focus on that part.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的最后一个 REST 框架，我们将探讨 Play 2。Play 2 是一个现代 Web 框架，可以用来创建完整的应用程序。该框架提供的部分工具允许你快速轻松地创建
    REST 服务。在本章中，我们将专注于这部分。
- en: 'In this chapter, we''ll discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Route matching with the route file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由文件进行路由匹配
- en: Working with the incoming HTTP request and customizing the response
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理传入的 HTTP 请求并自定义响应
- en: Adding JSON support, custom validations, and error handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 JSON 支持、自定义验证和错误处理
- en: First, let's get a bit more information about what the Play 2 framework is,
    and where you can find additional information about it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下 Play 2 框架是什么，以及你可以在哪里找到有关它的更多信息。
- en: An introduction to the Play 2 framework
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Play 2 框架简介
- en: 'The Play 2 framework is one of the best-known and most used web frameworks
    in the Scala ecosystem. It provides a very developer-friendly way of creating
    web applications and REST services. Some of the most interesting features of Play
    2 are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Play 2 框架是 Scala 生态系统中最知名和最广泛使用的 Web 框架之一。它提供了一个非常友好的开发方式来创建 Web 应用程序和 REST
    服务。Play 2 的一些最有趣的功能包括：
- en: '**Automatically reload changes**: When creating Play 2 applications, you don''t
    have to restart the application after a change in the code. Just resend a request,
    and Play 2 will automatically reload the changes.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重新加载更改**：在创建 Play 2 应用程序时，你不需要在代码更改后重新启动应用程序。只需重新发送请求，Play 2 将自动重新加载更改。'
- en: '**Scalable**: Play 2 is based on Akka. Through the Akka framework, it provides
    an easy way to scale up and scale out.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Play 2 基于 Akka。通过 Akka 框架，它提供了一个简单的方式来向上和向外扩展。'
- en: '**Great tool support**: Play 2 is based on SBT, the standard build tool for
    Scala. Through an SBT plugin, you can easily start, reload, and distribute your
    Play 2 applications.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大的工具支持**：Play 2 基于 SBT，这是 Scala 的标准构建工具。通过一个 SBT 插件，你可以轻松启动、重新加载和分发你的 Play
    2 应用程序。'
- en: Even though Play 2 isn't specifically build as a REST framework, we can use
    parts of it to easily create REST applications, and still take advantage of the
    features of Play 2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Play 2 并非专门构建为 REST 框架，但我们可以使用其部分功能轻松创建 REST 应用程序，同时还能利用 Play 2 的特性。
- en: Hello World with Play 2
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Play 2 的 Hello World
- en: 'To create a simple Hello World REST service in Play 2, we first need to set
    up the SBT project correctly. Play 2 uses an SBT plugin to run an HTTP server
    that you can use to access your REST service. The first thing we need to do is
    add this plugin to the `plugins.sbt` file (which you can find in the `project`
    directory):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Play 2 中创建一个简单的 Hello World REST 服务，我们首先需要正确设置 SBT 项目。Play 2 使用一个 SBT 插件来运行一个
    HTTP 服务器，你可以使用它来访问你的 REST 服务。我们需要做的第一件事是将此插件添加到 `plugins.sbt` 文件中（该文件位于 `project`
    目录中）：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define the dependencies so that we can create a Play 2-based REST
    service. For Play 2, we use the following dependencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义依赖关系，以便我们可以创建一个基于 Play 2 的 REST 服务。对于 Play 2，我们使用以下依赖项：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is one more step we need to add to the SBT configuration (`build.sbt`)
    to be able to run the samples in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 SBT 配置（`build.sbt`）中添加一个步骤，以便能够运行本章中的示例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The important parts here are the `addCommandAlias` and `enablePlugins` functions.
    With the `addCommandAlias` function, we define on which port Play 2 should listen
    and which route configuration it should use (more on that in the *Working with
    the routes files* section). The first `addCommandAlias` function defines that
    we'll use the `hello.Routes` file and listen on port `8080`. To be able to run
    Play 2 during development, we also need to add the plugin we defined earlier to
    this project. We do this through the `enablePlugins(PlayScala)` call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要部分是 `addCommandAlias` 和 `enablePlugins` 函数。通过 `addCommandAlias` 函数，我们定义
    Play 2 应该监听哪个端口以及应该使用哪种路由配置（更多内容请参阅 *使用路由文件* 部分）。第一个 `addCommandAlias` 函数定义我们将使用
    `hello.Routes` 文件并在端口 `8080` 上监听。为了能够在开发期间运行 Play 2，我们还需要将之前定义的插件添加到这个项目中。我们通过
    `enablePlugins(PlayScala)` 调用来实现这一点。
- en: 'Now let''s look a bit closer at the `hello.routes` file that we use to define
    the routes for this Hello World example. You can find this file in the `routes`
    directory. The content of the `hello.routes` file looks similar to this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看我们用来定义这个Hello World示例路由的`hello.routes`文件。您可以在`routes`目录中找到此文件。`hello.routes`文件的内容看起来类似于以下内容：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This means that a `GET` request that matches the `/hello` path will invoke
    the action defined by `controllers.Hello.helloWorld`. This action is defined in
    the `Hello.scala` file, which Play 2, by default, stores in the `app` directory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个匹配`/hello`路径的`GET`请求将调用由`controllers.Hello.helloWorld`定义的操作。这个操作定义在`Hello.scala`文件中，Play
    2默认将其存储在`app`目录下：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now start the project by calling `sbt runCH06-HelloPlay`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过调用`sbt runCH06-HelloPlay`启动项目：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, Play 2 starts and we can access our REST service on port `8080`.
    Note that this time, we did not create our own custom launcher, but used the one
    provided by Play 2\. To stop this server, you can hit *Ctrl* + *D*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Play 2已经开始，我们可以在端口`8080`上访问我们的REST服务。请注意，这次我们没有创建自己的自定义启动器，而是使用了Play 2提供的。要停止此服务器，您可以按*Ctrl*
    + *D*。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you start Play 2 the way we do in this chapter, we start Play 2 in development
    mode. In development mode, Play 2 will automatically reload server changes and
    provide detailed error messages when problems occur. However, you shouldn't run
    a production Play 2 application in development mode. The performance in development
    mode is worse than production mode, and through the detailed error messages, much
    of the internal state is exposed to the clients, which isn't something you want
    to do in production.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像本章中这样做来启动Play 2时，我们是在开发模式下启动Play 2。在开发模式下，Play 2将自动重新加载服务器更改，并在出现问题时提供详细的错误消息。然而，您不应该在开发模式下运行生产Play
    2应用程序。开发模式下的性能比生产模式差，并且通过详细的错误消息，大量内部状态被暴露给客户端，这在生产环境中是不希望看到的。
- en: Therefore, when you are done with development, and start performance testing
    or deploying your application to production, you should start Play 2 in production
    mode. An explanation on how to do this can be found on the Play 2 website at [https://www.playframework.com/documentation/2.4.x/Production](https://www.playframework.com/documentation/2.4.x/Production).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您完成开发，并开始性能测试或部署应用程序到生产环境时，您应该以生产模式启动Play 2。有关如何操作的说明可以在Play 2网站上找到，网址为[https://www.playframework.com/documentation/2.4.x/Production](https://www.playframework.com/documentation/2.4.x/Production)。
- en: 'To test whether everything works correctly, open Postman and execute the **Hello
    Play** request from the request in the `Chapter 6` folder:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试是否一切正常工作，打开Postman并执行`Chapter 6`文件夹中的**Hello Play**请求：
- en: '![Hello World with Play 2](img/00047.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![使用Play 2的Hello World](img/00047.jpeg)'
- en: 'The response is as you probably expect. A `GET` request made to `/hello` just
    returns the `Hello Play` value. One of the great things about Play 2 is that you
    can change your code, without having to restart the server. As an example, change
    the response message in the `Hello` controller to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 响应正如您可能预期的那样。对`/hello`发出的`GET`请求仅返回`Hello Play`值。Play 2的一个非常好的特点是您可以在不重新启动服务器的情况下更改代码。作为一个例子，将`Hello`控制器中的响应消息更改为以下内容：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save the file, don''t stop or restart the Play 2 server; instead open up Postman
    and execute the same request again:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，不要停止或重新启动Play 2服务器；相反，打开Postman并再次执行相同的请求：
- en: '![Hello World with Play 2](img/00048.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![使用Play 2的Hello World](img/00048.jpeg)'
- en: As you can see, the server now returns the updated string value, without requiring
    you to restart the server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务器现在返回了更新的字符串值，而无需您重新启动服务器。
- en: In the following section, we will explore the routes file a bit more.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探索路由文件。
- en: Working with the routes file
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与路由文件一起工作
- en: 'In the previous section, we saw a very small routes file; it only contained
    a single line which handled a `GET` request to the `/hello` path. For this example,
    we''ll use the following routes file (`step01.routes` in the `routes` folder):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一个非常小的路由文件；它只包含一行，处理了到`/hello`路径的`GET`请求。对于这个例子，我们将使用以下路由文件（`routes`文件夹中的`step01.routes`）：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this route file, we define a number of different HTTP verbs, paths, and
    actions to execute. If we look at each line, we first see the HTTP verb, which
    we want to match. You can use this set of HTTP verbs with Play 2: `GET`, `POST`,
    `PUT`, `PATCH`, `DELETE`, `HEAD`, and `OPTIONS`. Next, we see the path that we
    want to match. Play 2 provides a number of different constructs you can use in
    that position:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个路由文件中，我们定义了多个不同的HTTP动词、路径和要执行的操作。如果我们查看每一行，我们首先看到我们想要匹配的HTTP动词。你可以使用Play
    2的这组HTTP动词：`GET`、`POST`、`PUT`、`PATCH`、`DELETE`、`HEAD`和`OPTIONS`。接下来，我们看到我们想要匹配的路径。Play
    2在该位置提供了一些不同的构造可以使用：
- en: '| Path constructs | Description |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 路径构造 | 描述 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/tasks` | This matches the path, but doesn''t extract any information. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `/tasks` | 这与路径匹配，但不提取任何信息。|'
- en: '| `/tasks/:id` | This matches the path and extracts a segment, which is passed
    into the action with the provided name (`id` in this case). |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `/tasks/:id` | 这与路径匹配并提取一个段，该段以提供的名称（在这种情况下为`id`）传递给操作。|'
- en: '| `/*path` | Play 2 also supports wildcards. With `*`, you can match a path,
    which is extracted, assigned to the provided name (`path` in this case), and passed
    into the action. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `/*path` | Play 2也支持通配符。使用`*`，你可以匹配一个路径，该路径被提取，分配给提供的名称（在这种情况下为`path`），并传递给操作。|'
- en: '| `/$id<[0-9]+>` | If you start a path with `$`, Play 2 interprets this as
    a regular expression. The match is extracted, assigned to the name (`id`), and
    passed into the action. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `/$id<[0-9]+>` | 如果你以`$`开始路径，Play 2将其解释为正则表达式。匹配项被提取，分配给名称（在这种情况下为`id`），并传递给操作。|'
- en: 'The last part of each line in the routes file is the name of the action to
    invoke (see the next code fragment). When we extract a value, we can also specify
    the type we expect (we will see more on this in the next section), for instance,
    `controllers.Step1.getTask(id: Long)` converts the extracted `id` to a `Long`,
    and if we don''t specify anything, it is passed into the action as a `String`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，响应代码是**404 Not Found**，这是由于我们控制器中的`NotFound("…")`函数的结果。
- en: 'In the following code fragment, we show the controller that provides the actions
    referring from the routes file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们展示了提供从路由文件引用操作的控制器：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the actions we defined in this `Controller`, we don't do anything special.
    We just specify the HTTP status, which is in the form of `Ok`, `NotFound`, or
    `BadRequest`, and set the body to send back to the client. Play 2 provides standard
    results for all the defined HTTP codes. Look in the `play.api.mvc.Results` object
    for all the possibilities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在这个`Controller`中定义的操作中，我们没有做任何特别的事情。我们只是指定HTTP状态，它以`Ok`、`NotFound`或`BadRequest`的形式存在，并将体设置为发送回客户端。Play
    2为所有定义的HTTP代码提供标准结果。查看`play.api.mvc.Results`对象以获取所有可能性。
- en: 'Now open up Postman, and we''ll test some of the routes we just implemented.
    Start up the Play 2 service with the `sbt runCH06-runCH06Step1` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Postman，我们将测试我们刚刚实现的一些路由。使用`sbt runCH06-runCH06Step1`命令启动Play 2服务：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Postman, from the `Chapter 06` folder, execute the **Step 01 – Get Task
    with Id** request:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，从`第06章`文件夹中执行**步骤01 – 通过ID获取任务**请求：
- en: '![Working with the routes file](img/00049.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![处理路由文件](img/00049.jpeg)'
- en: 'In the response you can see that the ID is extracted from the URL path. If
    you specify a value that can''t be converted to a long, the route won''t match,
    and the action won''t be executed. In the response code of this request, you can
    see **200 OK**, which reflects the `Ok("…")` function we used in the controller.
    Next, let''s execute a request which is matched by one of the wildcard matchers,
    that is, **Step 01 - Invalid** request:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中，你可以看到ID是从URL路径中提取出来的。如果你指定了一个无法转换为长整型的值，则路由不会匹配，操作也不会执行。在这个请求的响应代码中，你可以看到**200
    OK**，这反映了我们在控制器中使用的`Ok("…")`函数。接下来，让我们执行一个与通配符匹配器匹配的请求，即**步骤01 - 无效**请求：
- en: '![Working with the routes file](img/00050.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![处理路由文件](img/00050.jpeg)'
- en: This time, you can see that the response code is **404 Not Found**, which is
    a result of the `NotFound("…")` function in our controller.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '路由文件中每一行的最后一部分是要调用的操作名称（参见下一代码片段）。当我们提取一个值时，我们也可以指定我们期望的类型（我们将在下一节中看到更多关于这一点），例如，`controllers.Step1.getTask(id:
    Long)`将提取的`id`转换为`Long`，如果我们没有指定任何内容，它将以`String`的形式传递给操作。'
- en: In the next section, we'll expand on this example and add support for `Future`.
    We will also look at more details of the incoming request and the ways you can
    customize the response.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将扩展这个示例并添加对`Future`的支持。我们还将查看传入请求的更多细节以及你可以自定义响应的方式。
- en: Adding the Future support and output writers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Future 支持和输出编写器
- en: 'In this section, we add more functionality to the very simple service we created
    in the previous section. We''re going to add the functionality to create tasks
    using request parameters and also connect our generic `TaskService`. First, we
    look at the route file (`step02.routes`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在上一节中创建的非常简单的服务中添加更多功能。我们将添加使用请求参数创建任务的功能，并连接我们的通用 `TaskService`。首先，我们查看路由文件（`step02.routes`）：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not that much has changed here, except that we now pass in more arguments to
    the actions defined in the `Controller` class. If you look a bit closer at the
    first line, you can see that we pass in a number of parameters. So far, we've
    only seen parameters that were extracted from the URL path. If Play 2 encounters
    a parameter in the signature of the `Action` method that it doesn't know, it assumes
    it is passed in as a request parameter. So in the case of the first route, we
    expect a `title`, an optional `person`, and a `status` parameter. The `title`
    parameter is required, the `person` parameter is optional, and for the `status`
    parameter, we set a default value using the `?=` syntax. In the following paragraphs,
    we'll look at how these routes map to the actions defined in the `Step2` controller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里没有太多变化，除了我们现在向 `Controller` 类中定义的操作传递更多的参数。如果你仔细看看第一行，你可以看到我们传递了多个参数。到目前为止，我们只看到了从
    URL 路径中提取的参数。如果 Play 2 在 `Action` 方法的签名中遇到它不知道的参数，它假设这个参数是以请求参数的形式传入的。所以在这个第一个路由的情况下，我们期望有一个
    `title` 参数，一个可选的 `person` 参数和一个 `status` 参数。`title` 参数是必需的，`person` 参数是可选的，对于
    `status` 参数，我们使用 `?=` 语法设置了一个默认值。在接下来的段落中，我们将看看这些路由是如何映射到 `Step2` 控制器中定义的操作的。
- en: 'Before we look at the actions, we''ll have a quick look at a couple of `Writeable`
    implicit values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看操作之前，我们先快速看一下几个 `Writeable` 隐式值：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Play 2 uses a `Writeable` object to determine how to convert some types to
    an HTTP response. In the previous sample, we just converted each task to a string
    and returned that. We needed to do this in each of the actions. By defining a
    `Writeable[Task]` object (and a `Writeable[List[Task]]` for a list of `Tasks`),
    we can just return an `Ok(task)` , and Play 2 will check whether an implicit `Writeable`
    of that type is available in scope, and use that to convert the `Task` to an output
    (an `Array[Byte]` instance) it understands. In the following code fragment, we
    see that we just return a `Task`, instead of converting it in the `Action` block:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Play 2 使用一个 `Writeable` 对象来确定如何将某些类型转换为 HTTP 响应。在上一个示例中，我们只是将每个任务转换为字符串并返回。我们需要在每个操作中这样做。通过定义一个
    `Writeable[Task]` 对象（以及一个 `Writeable[List[Task]]` 用于 `Tasks` 的列表），我们只需返回一个 `Ok(task)`，Play
    2 将检查作用域内是否有该类型的隐式 `Writeable`，并使用它将 `Task` 转换为它理解的输出（一个 `Array[Byte]` 实例）。在下面的代码片段中，我们可以看到我们只是返回一个
    `Task`，而不是在 `Action` 块中将其转换：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `createTask` action is called when we make a `POST` with the required parameters.
    In this function, we just use the provided information and the request's body
    to create and store a new `Task` instance. If you look at the signature of the
    `TaskService.insert`, you can see that this function returns a `Future[Task]`
    instance. If you use the `Action {...}` function, you'll get a compile message
    since we want to return a `Result[Future[Task]]` instance, which Play 2 doesn't
    understand. This is very easy to fix. All we need to do is use `Action.async {…}`
    instead of `Action {…}`. Now we can just return a `Future[T]`, and Play 2 will
    know what to do (as long as there is an implicit `Writeable[T]` in scope).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用所需的参数进行 `POST` 请求时，会调用 `createTask` 操作。在这个函数中，我们只是使用提供的信息和请求的主体来创建和存储一个新的
    `Task` 实例。如果你查看 `TaskService.insert` 的签名，你可以看到这个函数返回一个 `Future[Task]` 实例。如果你使用
    `Action {...}` 函数，你会得到一个编译错误信息，因为我们想返回一个 `Result[Future[Task]]` 实例，而 Play 2 不理解这个实例。这个问题很容易解决。我们只需要使用
    `Action.async {…}` 而不是 `Action {…}`。现在我们只需返回一个 `Future[T]`，Play 2 就会知道该怎么做（只要作用域内有隐式
    `Writeable[T]`）。
- en: 'Before we move on to the next action, we''ll look a bit closer at the request
    object used in this example. If you add `request =>` to your action block, you
    can access the incoming request. In this action, we use it to access the body,
    but this object allows access to more request information. The most important
    ones are listed here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行下一个操作之前，我们将更仔细地查看在这个示例中使用的请求对象。如果你在你的操作块中添加 `request =>`，你可以访问传入的请求。在这个操作中，我们使用它来访问主体，但这个对象允许访问更多的请求信息。最重要的信息列在这里：
- en: '| Property | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `id` | This is the ID of the request. This starts at 1 for the first request
    when the application is started and increments with each request. The type of
    this object is a long. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `id` | 这是请求的 ID。当应用程序启动时，第一个请求的 ID 从 1 开始，并且随着每个请求的增加而递增。此对象类型为长整型。|'
- en: '| `tags` | This property contains information about the route and returns a
    `Map[String, String]`. This information looks similar to this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '| `tags` | 此属性包含有关路由的信息，并返回一个 `Map[String, String]`。此信息看起来类似于以下内容：'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `uri` | This contains the full URI of the request. This is the path and query
    string together. This is of type, string. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `uri` | 这包含请求的完整 URI。这是路径和查询字符串的组合。此类型为字符串。|'
- en: '| `path` | This is the path part of the URI. This returns a string |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `path` | 这是 URI 的路径部分。这返回一个字符串 |'
- en: '| `method` | This is the method part (the verb) used to make the request. This
    is a string. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `method` | 这是用于发出请求的方法部分（动词）。这是一个字符串。|'
- en: '| `version` | This is the HTTP versions of this request. This is also returned
    as a string. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `version` | 这是此请求的 HTTP 版本。这也以字符串形式返回。|'
- en: '| `queryString` | This is the parsed query string in the form of a `Map[String,
    Seq[String]]` object, which contains the query parameters. If you want to access
    the raw query string, you can use the `rawQueryString` property. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `queryString` | 这是以 `Map[String, Seq[String]]` 对象形式解析的查询字符串，其中包含查询参数。如果您想访问原始查询字符串，可以使用
    `rawQueryString` 属性。|'
- en: '| `headers` | This accesses all the provided headers from the request. This
    object is of type, `Headers`. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `headers` | 这访问请求中提供的所有头信息。此对象类型为 `Headers`。|'
- en: '| `remoteAddress` | This returns the clients address as a string. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `remoteAddress` | 这返回客户端地址作为字符串。|'
- en: '| `secure` | This property is true if the client used HTTPS; it is false otherwise.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `secure` | 如果客户端使用了 HTTPS，则此属性为 true；否则为 false。|'
- en: '| `host` | This is the host part of the URI as a string. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `host` | 这是 URI 的主机部分，作为字符串。|'
- en: '| `domain` | The domain part of the URI as a string. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `domain` | URI 的域名部分，作为字符串。|'
- en: '| `cookies` | The cookies send along the request. This object is of type, `Cookies`.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `cookies` | 请求中发送的 cookie。此对象类型为 `Cookies`。|'
- en: 'Besides these, the `request` object also provides some additional properties
    to access specific headers: `acceptLanguages`, `acceptedTypes`, `mediaType`, `contentType`,
    and `charSet`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些之外，`request` 对象还提供了一些额外的属性来访问特定的头信息：`acceptLanguages`、`acceptedTypes`、`mediaType`、`contentType`
    和 `charSet`。
- en: 'Now that we''ve seen what we can do with the incoming request, in the following
    code fragment, we''ll look at how we can customize the response that gets sent
    back to the client:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们可以对传入的请求做什么，在接下来的代码片段中，我们将看看我们如何可以自定义发送回客户端的响应：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this fragment, we make a call to the `TaskService.all` function, which returns
    a `Future[List[Task]]` object. Since we''ve defined a `Writeable` for `List[Task]`,
    all we need to do is transform the `Future[List[Task]]` to a `Future[Result]`,
    which we do by calling map and returning `Ok(_)`. When we return the result, we
    use a couple of additional functions to customize the result. We use as to set
    the content-type of the result, and with `withCookies` and `withHeaders`, we add
    a custom cookie and header. Play 2 provides the following functions for this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中，我们调用 `TaskService.all` 函数，该函数返回一个 `Future[List[Task]]` 对象。由于我们已为 `List[Task]`
    定义了 `Writeable`，我们所需做的只是将 `Future[List[Task]]` 转换为 `Future[Result]`，我们通过调用 `map`
    并返回 `Ok(_)` 来实现这一点。当我们返回结果时，我们使用一些额外的函数来自定义结果。我们使用 `as` 来设置结果的 `content-type`，并通过
    `withCookies` 和 `withHeaders` 添加自定义的 cookie 和头信息。Play 2 为此提供了以下函数：
- en: '| Function | Description |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `withHeaders` | This adds the provided `(String, String)` tuples as a header
    to the response. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `withHeaders` | 这会将提供的 `(String, String)` 元组作为头信息添加到响应中。|'
- en: '| `withCookies` | This adds the provided `Cookies` instance to the response.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `withCookies` | 这会将提供的 `Cookies` 实例添加到响应中。|'
- en: '| `discardingCookies` | It is also possible to remove specific cookies from
    the response with this function. All the cookies, which match the provided `DiscardingCookies`,
    will be removed. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `discardingCookies` | 使用此函数也可以从响应中删除特定的 cookie。所有与提供的 `DiscardingCookies`
    匹配的 cookie 都将被删除。|'
- en: '| `as` | This sets the resulting content-type to the provided string value.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `as` | 这会将结果的 `content-type` 设置为提供的字符串值。|'
- en: 'The following code fragment shows the last couple of actions we implemented
    for this step:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们在这一步实现的最后几个操作：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, these last two actions are much the same as we've already seen.
    We just map over the `Future` and use pattern matching on the containing option
    to return either `Ok` (200) or `NotFound` (404).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个最后的动作与我们之前看到的非常相似。我们只是映射 `Future` 并在包含的选项上使用模式匹配来返回 `Ok`（200）或 `NotFound`（404）。
- en: 'Now that we''ve explored the complete example, we''ll check how it looks in
    Postman. First start up the example for this step by running `sbt runCH06-runCH06Step2`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了完整的示例，我们将检查它在 Postman 中的样子。首先通过运行 `sbt runCH06-runCH06Step2` 启动此步骤的示例：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once started, first execute the **Step 02 - Create Task** request a couple
    of times:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，首先执行 **步骤 02 - 创建任务** 请求几次：
- en: '![Adding the Future support and output writers](img/00051.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![添加 Future 支持和输出写入器](img/00051.jpeg)'
- en: 'As you can see, the `Task` is created asynchronously and the created `Task`
    is returned. Now when we run the **Step 02 – Get all tasks** request, you should
    see a list of all the requests, separated by line breaks:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Task` 是异步创建的，并且创建的 `Task` 被返回。现在当我们运行 **步骤 02 – 获取所有任务** 请求时，您应该看到所有请求的列表，通过换行符分隔：
- en: '![Adding the Future support and output writers](img/00052.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![添加 Future 支持和输出写入器](img/00052.jpeg)'
- en: In the next section, we'll show you how you can add JSON marshalling and error
    handling.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示如何添加 JSON 序列化和错误处理。
- en: Adding JSON marshalling, validations, and error handling
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 JSON 序列化、验证和错误处理
- en: 'As we''ve seen with the other frameworks, an important feature of a REST framework
    is the support for JSON. With Play 2, adding JSON is very easy. All it takes is
    defining the following implicits:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们看到的其他框架一样，REST 框架的一个重要特性是对 JSON 的支持。在 Play 2 中，添加 JSON 非常简单。只需定义以下隐式参数即可：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With these implicits in scope, we can convert the relevant case classes to
    and from JSON by using the following two functions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域内使用这些隐式参数，我们可以通过以下两个函数将相关的 case 类转换为和从 JSON：
- en: '`Json.toJson(obj)`: This converts the provided `obj` instance to JSON. This
    works if we''ve defined a `Format` object for that case class as we''ve done earlier.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Json.toJson(obj)`：这会将提供的 `obj` 实例转换为 JSON。如果我们已经为该 case 类定义了 `Format` 对象，就像我们之前做的那样，这将起作用。'
- en: '`request.body.asJson.map(_.as[Task])`: Converting from JSON to a case class
    is just as easy. Use `asJson` to convert the incoming body to a `JsValue` and
    then use as to convert it to a supported case class.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request.body.asJson.map(_.as[Task])`：从 JSON 转换为 case 类与直接转换一样简单。使用 `asJson`
    将传入的体转换为 `JsValue`，然后使用 `as` 将其转换为支持的 case 类。'
- en: While this approach works great for simple scenarios, it doesn't allow you to
    validate the input values before you create your case objects. If you want to
    add validations when parsing the incoming JSON, you have to explicitly write out
    how a specific JSON field is mapped to a property of the case class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法对于简单场景效果很好，但它不允许你在创建 case 对象之前验证输入值。如果你想在解析传入的 JSON 时添加验证，你必须明确写出特定的 JSON
    字段是如何映射到 case 类的属性的。
- en: 'To convert from and to JSON, we need to define a `Reads[T]` and a `Writes[T]`
    object for each class. A `Reads` object defines how we convert from the incoming
    JSON to a case class, and a `Writes` defines the other way around. If the `to`
    and `from` are symmetrical, you can also use a single `Format` implicit instead
    of defining the `Reads` and `Writes` separately (note that this doesn''t work
    with case classes with only one parameter). If we look at the mapping of the `Note`
    case class, we can use a `Format` approach:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从和到 JSON 转换，我们需要为每个类定义一个 `Reads[T]` 和一个 `Writes[T]` 对象。`Reads` 对象定义了我们将如何从传入的
    JSON 转换为 case 类，而 `Writes` 定义了相反的过程。如果 `to` 和 `from` 是对称的，你也可以使用单个 `Format` 隐式参数而不是分别定义
    `Reads` 和 `Writes`（注意，这不能用于只有一个参数的 case 类）。如果我们查看 `Note` case 类的映射，我们可以使用 `Format`
    方法：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this code fragment, we map the first parameter of the case class to the
    `id` JSON field as a long and the second parameter to a string with name content.
    For the `Status` case class, we define a separate `Writes` and `Reads` and add
    validation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们将 case 类的第一个参数映射到 `id` JSON 字段作为长整型，第二个参数映射到具有名称内容的字符串。对于 `Status`
    case 类，我们定义了单独的 `Writes` 和 `Reads` 并添加了验证：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that in the import, we've aliased our `Status` case class to `MStatus`
    to avoid naming conflicts with the `Status` provided by Play 2\. In the `statusReads`
    definition, you can see that we map the incoming status JSON field to our case
    class. We've also added two validation checks to this property. It needs to have
    a minimum length of `3` (`minLength`), and we check with a custom filter whether
    the value of `status` is one of `New`, `In` `Progress`, or `Closed`. For writing
    out JSON, we create a simple `Writes[MStatus]` instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在导入时，我们将我们的`Status`案例类别别名为`MStatus`，以避免与Play 2提供的`Status`发生命名冲突。在`statusReads`定义中，你可以看到我们将传入的状态JSON字段映射到我们的案例类。我们还为此属性添加了两个验证检查。它需要至少有`3`个字符的长度（`minLength`），并且我们使用自定义过滤器检查`status`的值是否为`New`、`In
    Progress`或`Closed`之一。对于写入JSON，我们创建了一个简单的`Writes[MStatus]`实例。
- en: 'In the `Reads` of `Task`, we also add some simple validations:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Task`的`Reads`中，我们还添加了一些简单的验证：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We want the title to be at least three characters and have a max of 10\. Note
    that we''ve used `readNullable` in this `Reads` definition. With `readNullable`,
    we get an `Option[T]` object, which implies that the JSON field is also optional.
    The following table shows the different validation checks you can make:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望标题至少有三个字符，最大长度为10。注意，我们在这个`Reads`定义中使用了`readNullable`。使用`readNullable`，我们得到一个`Option[T]`对象，这意味着JSON字段也是可选的。以下表格显示了你可以进行的不同验证检查：
- en: '| Validation | Description |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 验证 | 描述 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `max` | This checks for the maximum value of a numeric JSON property. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 这检查一个数字JSON属性的值是否超过最大值。|'
- en: '| `min` | This checks for the minimum value of a numeric JSON property. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 这检查数字JSON属性的最小值。|'
- en: '| `filterNot` | This checks against a custom predicate. If the predicate returns
    true, a validation error will be created. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `filterNot` | 这检查是否满足自定义谓词。如果谓词返回true，将创建一个验证错误。|'
- en: '| `filter` | This checks against a custom predicate. If the predicate returns
    false, a validation error will be created. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 这检查是否满足自定义谓词。如果谓词返回false，将创建一个验证错误。|'
- en: '| `maxLength` | This checks for the maximum length of a string JSON property.
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `maxLength` | 这检查字符串JSON属性的最大长度。|'
- en: '| `minLength` | This checks for the minimum length of a string JSON property.
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `minLength` | 这检查字符串JSON属性的最小长度。|'
- en: '| `pattern` | This checks whether the JSON property matches the provided regular
    expression. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `pattern` | 这检查JSON属性是否与提供的正则表达式匹配。|'
- en: '| `email` | This checks whether the JSON property is an e-mail address. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `email` | 这检查JSON属性是否是电子邮件地址。|'
- en: You can also add multiple checks to a single JSON property. With `andKeep` and
    `keepAnd` (there is a small difference in semantics of these two functions, but
    when used with validations, they work in exactly the same manner), both checks
    need to succeed, and with `or`, at least one of the checks must succeed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将多个检查添加到单个JSON属性中。使用`andKeep`和`keepAnd`（这两个函数在语义上略有不同，但与验证一起使用时，它们以完全相同的方式工作），两个检查都必须成功，而使用`or`，至少有一个检查必须成功。
- en: 'Now that we''ve defined how to convert to and from JSON, let''s look at how
    to use this in our actions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了如何将数据转换为JSON以及从JSON转换回来，让我们看看如何在我们的操作中使用它：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code fragment, we first convert the body of the incoming request to
    JSON with the `asJson` function. This returns an `Option[JsValue]` object, which
    we map to an `Option[JsResult[Task]]]` instance using the `validate` function.
    If our option is `None`, it means we couldn't parse the incoming JSON, and we'll
    return a `BadRequest` result. If we've got validation errors we get a `JsError`
    and respond with a `BadRequest` showing the errors; if the validation went well,
    we get a `JsSuccess` and add the `Task` to the `TaskService`, which responds with
    `Ok`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先使用`asJson`函数将传入请求的主体转换为JSON。这返回一个`Option[JsValue]`对象，我们使用`validate`函数将其映射到`Option[JsResult[Task]]]`实例。如果我们的选项是`None`，这意味着我们无法解析传入的JSON，我们将返回一个`BadRequest`结果。如果我们有验证错误，我们得到一个`JsError`并响应一个显示错误的`BadRequest`；如果验证顺利，我们得到一个`JsSuccess`并将`Task`添加到`TaskService`，它响应`Ok`。
- en: 'Now open Postman and check what the resulting JSON looks like. First add a
    couple of `Tasks` with the **Step 03 – Create Task** request:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Postman检查生成的JSON看起来像什么。首先添加几个`Tasks`，使用**步骤03 – 创建任务**请求：
- en: '![Adding JSON marshalling, validations, and error handling](img/00053.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![添加JSON序列化、验证和错误处理](img/00053.jpeg)'
- en: 'The JSON used in this request complies with the validations we added, so the
    request is processed without errors. If you execute the **Step 03 – Create Task
    Invalid** request, you''ll see that the validations are triggered and a bad request
    is returned:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此请求中使用的JSON符合我们添加的验证，因此请求处理时没有错误。如果你执行**步骤 03 – 创建无效任务**请求，你会看到验证被触发并返回一个错误请求：
- en: '![Adding JSON marshalling, validations, and error handling](img/00054.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![添加JSON序列化、验证和错误处理](img/00054.jpeg)'
- en: So far in this chapter, we've only handled functional errors. Incorrect data
    resulted in a `BadRequest` and a `Task` which couldn't be found returned a `Not
    Found` response. Play 2 also provides a generic way of handling unexpected errors.
    In the next section, we'll show you how you can add a custom error handler to
    your Play 2 service to process unhandled exceptions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们只处理了功能错误。数据错误导致返回`BadRequest`，而找不到`Task`则返回`Not Found`响应。Play 2还提供了一种处理意外错误的方法。在下一节中，我们将向您展示如何向您的Play
    2服务添加自定义错误处理器以处理未处理的异常。
- en: 'First, let''s see what the default behavior of Play 2 is when an exception
    occurs. For this, we''ve changed the `Delete` action to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看当发生异常时Play 2的默认行为是什么。为此，我们将`Delete`操作更改为以下内容：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result, when we call this action, is the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用此操作时，结果如下：
- en: '![Adding JSON marshalling, validations, and error handling](img/00055.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![添加JSON序列化、验证和错误处理](img/00055.jpeg)'
- en: 'Play 2 responds with a `500 Internal Server` error and a lot of HTML explaining
    the error (note that when you run in production mode, you see a slightly different
    error, but still in HTML form). While this is great when developing web applications,
    it isn''t that useful when creating a REST service. To customize the error handling,
    we have to provide Play 2 with an implementation of `HttpErrorHandler`. We could
    implement this interface from scratch, but an easier approach is to extend the
    default error handler (`DefaultErrorHandler`) provided by Play 2\. The handler
    we''ll use is shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Play 2响应一个`500 内部服务器`错误以及大量解释错误的HTML（注意：在生产模式下运行时，你会看到一个略有不同的错误，但仍然是HTML格式）。虽然这对于开发Web应用程序来说很好，但在创建REST服务时并不那么有用。为了自定义错误处理，我们必须向Play
    2提供一个`HttpErrorHandler`的实现。我们可以从头开始实现此接口，但一个更简单的方法是扩展Play 2提供的默认错误处理器（`DefaultErrorHandler`）。我们将使用的处理器如下所示：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following functions can be overridden to define custom error handling:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重写以下函数来定义自定义的错误处理：
- en: '| Function | Description |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onClientError` | This is called when an error occurs in the 4xx range. Depending
    on the error, the default handler delegates to any of the following three functions.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `onClientError` | 当4xx范围内的错误发生时调用此函数。根据错误的类型，默认处理器会委托给以下三个函数之一。|'
- en: '| `onBadRequest` | This is called when a bad request (400) is made. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `onBadRequest` | 当发起一个错误请求（400）时调用此函数。|'
- en: '| `onForbidden` | This is called when a request is made to a forbidden resource
    (403). |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `onForbidden` | 当请求一个禁止访问的资源（403）时调用此函数。|'
- en: '| `onNotFound` | This is called when a resource isn''t found (404). |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `onNotFound` | 当找不到资源（404）时调用此函数。|'
- en: '| `onServerError` | This is called when a server error occurs. This function
    delegates to one of the following two functions. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `onServerError` | 当发生服务器错误时调用此函数。此函数将委托给以下两个函数之一。|'
- en: '| `onDevServerError` | When in development mode, this function is called when
    a server error occurs. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `onDevServerError` | 在开发模式下，当发生服务器错误时调用此函数。|'
- en: '| `onProdServerError` | When in production mode, this function is called when
    a server error occurs. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `onProdServerError` | 在生产模式下，当发生服务器错误时调用此函数。|'
- en: 'Now we''ll get a much simpler error message when we make a request that causes
    an internal server error:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在发起导致内部服务器错误的请求时获得一个更简单的错误消息：
- en: '![Adding JSON marshalling, validations, and error handling](img/00056.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![添加JSON序列化、验证和错误处理](img/00056.jpeg)'
- en: At this point, we've discussed the most important features of the Play 2 framework.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Play 2框架最重要的功能。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked you through the main features of Play 2 (at least
    those relating to the REST part). We started with a simple service where we introduced
    the route file, the controller and the actions. After that, we looked at how to
    retrieve information from the request, parse path segments, and access query parameters.
    Play 2 also makes it simple to customize the response to an action. It provides
    standard case classes for all possible HTTP response code, and provides additional
    functionality to add headers and cookies to the response. Working with futures
    is supported by Play 2 through the `async` function. This way we can work with
    futures, just like we do with normal objects. Finally, we looked at JSON support
    and validations. Play 2 has standard functionality to convert incoming JSON to
    case classes and convert case classes back to JSON. When converting JSON to a
    case class, you can also add validations that check whether the supplied values
    are valid, before the case class is created.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了 Play 2 的主要功能（至少是那些与 REST 部分相关的）。我们从一个简单的服务开始，介绍了路由文件、控制器和动作。之后，我们探讨了如何从请求中检索信息、解析路径段以及访问查询参数。Play
    2 还使得对动作的响应进行自定义变得简单。它为所有可能的 HTTP 响应代码提供了标准的情况类，并提供了添加头和cookie到响应的附加功能。Play 2
    通过 `async` 函数支持与未来的协同工作。这样我们就可以像处理普通对象一样处理未来。最后，我们探讨了 JSON 支持和验证。当将 JSON 转换为情况类时，您还可以添加验证，以检查提供的值在创建情况类之前是否有效。
- en: With this chapter on Play 2, we finished the discussion of the different REST
    frameworks featured in this book. In the last chapter of this book, we'll look
    at some advanced REST framework features, such as HATEOAS, authentication, and
    client support.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章关于 Play 2 的讨论，我们完成了本书中介绍的不同 REST 框架的讨论。在本书的最后一章中，我们将探讨一些高级 REST 框架功能，例如
    HATEOAS、身份验证和客户端支持。
