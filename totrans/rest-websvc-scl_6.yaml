- en: Chapter 6. Creating REST Services with the Play 2 Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last REST framework in this book, we will look at Play 2\. Play 2 is
    a modern web framework that can be used to create complete applications. Part
    of the tools this framework provides allows you to quickly and easily create REST
    services. In this chapter, we'll focus on that part.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Route matching with the route file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the incoming HTTP request and customizing the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding JSON support, custom validations, and error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's get a bit more information about what the Play 2 framework is,
    and where you can find additional information about it.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Play 2 framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Play 2 framework is one of the best-known and most used web frameworks
    in the Scala ecosystem. It provides a very developer-friendly way of creating
    web applications and REST services. Some of the most interesting features of Play
    2 are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatically reload changes**: When creating Play 2 applications, you don''t
    have to restart the application after a change in the code. Just resend a request,
    and Play 2 will automatically reload the changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable**: Play 2 is based on Akka. Through the Akka framework, it provides
    an easy way to scale up and scale out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Great tool support**: Play 2 is based on SBT, the standard build tool for
    Scala. Through an SBT plugin, you can easily start, reload, and distribute your
    Play 2 applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though Play 2 isn't specifically build as a REST framework, we can use
    parts of it to easily create REST applications, and still take advantage of the
    features of Play 2.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World with Play 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a simple Hello World REST service in Play 2, we first need to set
    up the SBT project correctly. Play 2 uses an SBT plugin to run an HTTP server
    that you can use to access your REST service. The first thing we need to do is
    add this plugin to the `plugins.sbt` file (which you can find in the `project`
    directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the dependencies so that we can create a Play 2-based REST
    service. For Play 2, we use the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more step we need to add to the SBT configuration (`build.sbt`)
    to be able to run the samples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The important parts here are the `addCommandAlias` and `enablePlugins` functions.
    With the `addCommandAlias` function, we define on which port Play 2 should listen
    and which route configuration it should use (more on that in the *Working with
    the routes files* section). The first `addCommandAlias` function defines that
    we'll use the `hello.Routes` file and listen on port `8080`. To be able to run
    Play 2 during development, we also need to add the plugin we defined earlier to
    this project. We do this through the `enablePlugins(PlayScala)` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look a bit closer at the `hello.routes` file that we use to define
    the routes for this Hello World example. You can find this file in the `routes`
    directory. The content of the `hello.routes` file looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that a `GET` request that matches the `/hello` path will invoke
    the action defined by `controllers.Hello.helloWorld`. This action is defined in
    the `Hello.scala` file, which Play 2, by default, stores in the `app` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start the project by calling `sbt runCH06-HelloPlay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At this point, Play 2 starts and we can access our REST service on port `8080`.
    Note that this time, we did not create our own custom launcher, but used the one
    provided by Play 2\. To stop this server, you can hit *Ctrl* + *D*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you start Play 2 the way we do in this chapter, we start Play 2 in development
    mode. In development mode, Play 2 will automatically reload server changes and
    provide detailed error messages when problems occur. However, you shouldn't run
    a production Play 2 application in development mode. The performance in development
    mode is worse than production mode, and through the detailed error messages, much
    of the internal state is exposed to the clients, which isn't something you want
    to do in production.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when you are done with development, and start performance testing
    or deploying your application to production, you should start Play 2 in production
    mode. An explanation on how to do this can be found on the Play 2 website at [https://www.playframework.com/documentation/2.4.x/Production](https://www.playframework.com/documentation/2.4.x/Production).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether everything works correctly, open Postman and execute the **Hello
    Play** request from the request in the `Chapter 6` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello World with Play 2](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The response is as you probably expect. A `GET` request made to `/hello` just
    returns the `Hello Play` value. One of the great things about Play 2 is that you
    can change your code, without having to restart the server. As an example, change
    the response message in the `Hello` controller to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file, don''t stop or restart the Play 2 server; instead open up Postman
    and execute the same request again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello World with Play 2](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the server now returns the updated string value, without requiring
    you to restart the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explore the routes file a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the routes file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw a very small routes file; it only contained
    a single line which handled a `GET` request to the `/hello` path. For this example,
    we''ll use the following routes file (`step01.routes` in the `routes` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this route file, we define a number of different HTTP verbs, paths, and
    actions to execute. If we look at each line, we first see the HTTP verb, which
    we want to match. You can use this set of HTTP verbs with Play 2: `GET`, `POST`,
    `PUT`, `PATCH`, `DELETE`, `HEAD`, and `OPTIONS`. Next, we see the path that we
    want to match. Play 2 provides a number of different constructs you can use in
    that position:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Path constructs | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/tasks` | This matches the path, but doesn''t extract any information. |'
  prefs: []
  type: TYPE_TB
- en: '| `/tasks/:id` | This matches the path and extracts a segment, which is passed
    into the action with the provided name (`id` in this case). |'
  prefs: []
  type: TYPE_TB
- en: '| `/*path` | Play 2 also supports wildcards. With `*`, you can match a path,
    which is extracted, assigned to the provided name (`path` in this case), and passed
    into the action. |'
  prefs: []
  type: TYPE_TB
- en: '| `/$id<[0-9]+>` | If you start a path with `$`, Play 2 interprets this as
    a regular expression. The match is extracted, assigned to the name (`id`), and
    passed into the action. |'
  prefs: []
  type: TYPE_TB
- en: 'The last part of each line in the routes file is the name of the action to
    invoke (see the next code fragment). When we extract a value, we can also specify
    the type we expect (we will see more on this in the next section), for instance,
    `controllers.Step1.getTask(id: Long)` converts the extracted `id` to a `Long`,
    and if we don''t specify anything, it is passed into the action as a `String`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code fragment, we show the controller that provides the actions
    referring from the routes file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the actions we defined in this `Controller`, we don't do anything special.
    We just specify the HTTP status, which is in the form of `Ok`, `NotFound`, or
    `BadRequest`, and set the body to send back to the client. Play 2 provides standard
    results for all the defined HTTP codes. Look in the `play.api.mvc.Results` object
    for all the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open up Postman, and we''ll test some of the routes we just implemented.
    Start up the Play 2 service with the `sbt runCH06-runCH06Step1` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Postman, from the `Chapter 06` folder, execute the **Step 01 – Get Task
    with Id** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with the routes file](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the response you can see that the ID is extracted from the URL path. If
    you specify a value that can''t be converted to a long, the route won''t match,
    and the action won''t be executed. In the response code of this request, you can
    see **200 OK**, which reflects the `Ok("…")` function we used in the controller.
    Next, let''s execute a request which is matched by one of the wildcard matchers,
    that is, **Step 01 - Invalid** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with the routes file](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This time, you can see that the response code is **404 Not Found**, which is
    a result of the `NotFound("…")` function in our controller.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll expand on this example and add support for `Future`.
    We will also look at more details of the incoming request and the ways you can
    customize the response.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Future support and output writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we add more functionality to the very simple service we created
    in the previous section. We''re going to add the functionality to create tasks
    using request parameters and also connect our generic `TaskService`. First, we
    look at the route file (`step02.routes`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not that much has changed here, except that we now pass in more arguments to
    the actions defined in the `Controller` class. If you look a bit closer at the
    first line, you can see that we pass in a number of parameters. So far, we've
    only seen parameters that were extracted from the URL path. If Play 2 encounters
    a parameter in the signature of the `Action` method that it doesn't know, it assumes
    it is passed in as a request parameter. So in the case of the first route, we
    expect a `title`, an optional `person`, and a `status` parameter. The `title`
    parameter is required, the `person` parameter is optional, and for the `status`
    parameter, we set a default value using the `?=` syntax. In the following paragraphs,
    we'll look at how these routes map to the actions defined in the `Step2` controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the actions, we''ll have a quick look at a couple of `Writeable`
    implicit values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Play 2 uses a `Writeable` object to determine how to convert some types to
    an HTTP response. In the previous sample, we just converted each task to a string
    and returned that. We needed to do this in each of the actions. By defining a
    `Writeable[Task]` object (and a `Writeable[List[Task]]` for a list of `Tasks`),
    we can just return an `Ok(task)` , and Play 2 will check whether an implicit `Writeable`
    of that type is available in scope, and use that to convert the `Task` to an output
    (an `Array[Byte]` instance) it understands. In the following code fragment, we
    see that we just return a `Task`, instead of converting it in the `Action` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `createTask` action is called when we make a `POST` with the required parameters.
    In this function, we just use the provided information and the request's body
    to create and store a new `Task` instance. If you look at the signature of the
    `TaskService.insert`, you can see that this function returns a `Future[Task]`
    instance. If you use the `Action {...}` function, you'll get a compile message
    since we want to return a `Result[Future[Task]]` instance, which Play 2 doesn't
    understand. This is very easy to fix. All we need to do is use `Action.async {…}`
    instead of `Action {…}`. Now we can just return a `Future[T]`, and Play 2 will
    know what to do (as long as there is an implicit `Writeable[T]` in scope).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next action, we''ll look a bit closer at the request
    object used in this example. If you add `request =>` to your action block, you
    can access the incoming request. In this action, we use it to access the body,
    but this object allows access to more request information. The most important
    ones are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | This is the ID of the request. This starts at 1 for the first request
    when the application is started and increments with each request. The type of
    this object is a long. |'
  prefs: []
  type: TYPE_TB
- en: '| `tags` | This property contains information about the route and returns a
    `Map[String, String]`. This information looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `uri` | This contains the full URI of the request. This is the path and query
    string together. This is of type, string. |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | This is the path part of the URI. This returns a string |'
  prefs: []
  type: TYPE_TB
- en: '| `method` | This is the method part (the verb) used to make the request. This
    is a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | This is the HTTP versions of this request. This is also returned
    as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `queryString` | This is the parsed query string in the form of a `Map[String,
    Seq[String]]` object, which contains the query parameters. If you want to access
    the raw query string, you can use the `rawQueryString` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `headers` | This accesses all the provided headers from the request. This
    object is of type, `Headers`. |'
  prefs: []
  type: TYPE_TB
- en: '| `remoteAddress` | This returns the clients address as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `secure` | This property is true if the client used HTTPS; it is false otherwise.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `host` | This is the host part of the URI as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `domain` | The domain part of the URI as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `cookies` | The cookies send along the request. This object is of type, `Cookies`.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Besides these, the `request` object also provides some additional properties
    to access specific headers: `acceptLanguages`, `acceptedTypes`, `mediaType`, `contentType`,
    and `charSet`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen what we can do with the incoming request, in the following
    code fragment, we''ll look at how we can customize the response that gets sent
    back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this fragment, we make a call to the `TaskService.all` function, which returns
    a `Future[List[Task]]` object. Since we''ve defined a `Writeable` for `List[Task]`,
    all we need to do is transform the `Future[List[Task]]` to a `Future[Result]`,
    which we do by calling map and returning `Ok(_)`. When we return the result, we
    use a couple of additional functions to customize the result. We use as to set
    the content-type of the result, and with `withCookies` and `withHeaders`, we add
    a custom cookie and header. Play 2 provides the following functions for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `withHeaders` | This adds the provided `(String, String)` tuples as a header
    to the response. |'
  prefs: []
  type: TYPE_TB
- en: '| `withCookies` | This adds the provided `Cookies` instance to the response.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `discardingCookies` | It is also possible to remove specific cookies from
    the response with this function. All the cookies, which match the provided `DiscardingCookies`,
    will be removed. |'
  prefs: []
  type: TYPE_TB
- en: '| `as` | This sets the resulting content-type to the provided string value.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following code fragment shows the last couple of actions we implemented
    for this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these last two actions are much the same as we've already seen.
    We just map over the `Future` and use pattern matching on the containing option
    to return either `Ok` (200) or `NotFound` (404).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve explored the complete example, we''ll check how it looks in
    Postman. First start up the example for this step by running `sbt runCH06-runCH06Step2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once started, first execute the **Step 02 - Create Task** request a couple
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Future support and output writers](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `Task` is created asynchronously and the created `Task`
    is returned. Now when we run the **Step 02 – Get all tasks** request, you should
    see a list of all the requests, separated by line breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Future support and output writers](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll show you how you can add JSON marshalling and error
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JSON marshalling, validations, and error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen with the other frameworks, an important feature of a REST framework
    is the support for JSON. With Play 2, adding JSON is very easy. All it takes is
    defining the following implicits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With these implicits in scope, we can convert the relevant case classes to
    and from JSON by using the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Json.toJson(obj)`: This converts the provided `obj` instance to JSON. This
    works if we''ve defined a `Format` object for that case class as we''ve done earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request.body.asJson.map(_.as[Task])`: Converting from JSON to a case class
    is just as easy. Use `asJson` to convert the incoming body to a `JsValue` and
    then use as to convert it to a supported case class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this approach works great for simple scenarios, it doesn't allow you to
    validate the input values before you create your case objects. If you want to
    add validations when parsing the incoming JSON, you have to explicitly write out
    how a specific JSON field is mapped to a property of the case class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert from and to JSON, we need to define a `Reads[T]` and a `Writes[T]`
    object for each class. A `Reads` object defines how we convert from the incoming
    JSON to a case class, and a `Writes` defines the other way around. If the `to`
    and `from` are symmetrical, you can also use a single `Format` implicit instead
    of defining the `Reads` and `Writes` separately (note that this doesn''t work
    with case classes with only one parameter). If we look at the mapping of the `Note`
    case class, we can use a `Format` approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code fragment, we map the first parameter of the case class to the
    `id` JSON field as a long and the second parameter to a string with name content.
    For the `Status` case class, we define a separate `Writes` and `Reads` and add
    validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the import, we've aliased our `Status` case class to `MStatus`
    to avoid naming conflicts with the `Status` provided by Play 2\. In the `statusReads`
    definition, you can see that we map the incoming status JSON field to our case
    class. We've also added two validation checks to this property. It needs to have
    a minimum length of `3` (`minLength`), and we check with a custom filter whether
    the value of `status` is one of `New`, `In` `Progress`, or `Closed`. For writing
    out JSON, we create a simple `Writes[MStatus]` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Reads` of `Task`, we also add some simple validations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the title to be at least three characters and have a max of 10\. Note
    that we''ve used `readNullable` in this `Reads` definition. With `readNullable`,
    we get an `Option[T]` object, which implies that the JSON field is also optional.
    The following table shows the different validation checks you can make:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Validation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | This checks for the maximum value of a numeric JSON property. |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | This checks for the minimum value of a numeric JSON property. |'
  prefs: []
  type: TYPE_TB
- en: '| `filterNot` | This checks against a custom predicate. If the predicate returns
    true, a validation error will be created. |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | This checks against a custom predicate. If the predicate returns
    false, a validation error will be created. |'
  prefs: []
  type: TYPE_TB
- en: '| `maxLength` | This checks for the maximum length of a string JSON property.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `minLength` | This checks for the minimum length of a string JSON property.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pattern` | This checks whether the JSON property matches the provided regular
    expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `email` | This checks whether the JSON property is an e-mail address. |'
  prefs: []
  type: TYPE_TB
- en: You can also add multiple checks to a single JSON property. With `andKeep` and
    `keepAnd` (there is a small difference in semantics of these two functions, but
    when used with validations, they work in exactly the same manner), both checks
    need to succeed, and with `or`, at least one of the checks must succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve defined how to convert to and from JSON, let''s look at how
    to use this in our actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this code fragment, we first convert the body of the incoming request to
    JSON with the `asJson` function. This returns an `Option[JsValue]` object, which
    we map to an `Option[JsResult[Task]]]` instance using the `validate` function.
    If our option is `None`, it means we couldn't parse the incoming JSON, and we'll
    return a `BadRequest` result. If we've got validation errors we get a `JsError`
    and respond with a `BadRequest` showing the errors; if the validation went well,
    we get a `JsSuccess` and add the `Task` to the `TaskService`, which responds with
    `Ok`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open Postman and check what the resulting JSON looks like. First add a
    couple of `Tasks` with the **Step 03 – Create Task** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding JSON marshalling, validations, and error handling](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The JSON used in this request complies with the validations we added, so the
    request is processed without errors. If you execute the **Step 03 – Create Task
    Invalid** request, you''ll see that the validations are triggered and a bad request
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding JSON marshalling, validations, and error handling](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So far in this chapter, we've only handled functional errors. Incorrect data
    resulted in a `BadRequest` and a `Task` which couldn't be found returned a `Not
    Found` response. Play 2 also provides a generic way of handling unexpected errors.
    In the next section, we'll show you how you can add a custom error handler to
    your Play 2 service to process unhandled exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see what the default behavior of Play 2 is when an exception
    occurs. For this, we''ve changed the `Delete` action to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, when we call this action, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding JSON marshalling, validations, and error handling](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Play 2 responds with a `500 Internal Server` error and a lot of HTML explaining
    the error (note that when you run in production mode, you see a slightly different
    error, but still in HTML form). While this is great when developing web applications,
    it isn''t that useful when creating a REST service. To customize the error handling,
    we have to provide Play 2 with an implementation of `HttpErrorHandler`. We could
    implement this interface from scratch, but an easier approach is to extend the
    default error handler (`DefaultErrorHandler`) provided by Play 2\. The handler
    we''ll use is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following functions can be overridden to define custom error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `onClientError` | This is called when an error occurs in the 4xx range. Depending
    on the error, the default handler delegates to any of the following three functions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `onBadRequest` | This is called when a bad request (400) is made. |'
  prefs: []
  type: TYPE_TB
- en: '| `onForbidden` | This is called when a request is made to a forbidden resource
    (403). |'
  prefs: []
  type: TYPE_TB
- en: '| `onNotFound` | This is called when a resource isn''t found (404). |'
  prefs: []
  type: TYPE_TB
- en: '| `onServerError` | This is called when a server error occurs. This function
    delegates to one of the following two functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `onDevServerError` | When in development mode, this function is called when
    a server error occurs. |'
  prefs: []
  type: TYPE_TB
- en: '| `onProdServerError` | When in production mode, this function is called when
    a server error occurs. |'
  prefs: []
  type: TYPE_TB
- en: 'Now we''ll get a much simpler error message when we make a request that causes
    an internal server error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding JSON marshalling, validations, and error handling](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we've discussed the most important features of the Play 2 framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked you through the main features of Play 2 (at least
    those relating to the REST part). We started with a simple service where we introduced
    the route file, the controller and the actions. After that, we looked at how to
    retrieve information from the request, parse path segments, and access query parameters.
    Play 2 also makes it simple to customize the response to an action. It provides
    standard case classes for all possible HTTP response code, and provides additional
    functionality to add headers and cookies to the response. Working with futures
    is supported by Play 2 through the `async` function. This way we can work with
    futures, just like we do with normal objects. Finally, we looked at JSON support
    and validations. Play 2 has standard functionality to convert incoming JSON to
    case classes and convert case classes back to JSON. When converting JSON to a
    case class, you can also add validations that check whether the supplied values
    are valid, before the case class is created.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter on Play 2, we finished the discussion of the different REST
    frameworks featured in this book. In the last chapter of this book, we'll look
    at some advanced REST framework features, such as HATEOAS, authentication, and
    client support.
  prefs: []
  type: TYPE_NORMAL
