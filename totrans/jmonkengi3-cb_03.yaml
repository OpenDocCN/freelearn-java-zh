- en: Chapter 3. World Building
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 世界构建
- en: In this chapter, we'll go through some of the fundamentals behind generating
    a code-based world and its lighting before we go beyond the basics and discuss
    more advanced techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，在我们超越基础知识并讨论更高级的技术之前，我们将探讨生成基于代码的世界及其光照的一些基本原理。
- en: 'This chapter contains the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下配方：
- en: Using noise to generate a terrain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用噪声生成地形
- en: Lighting your world and providing it with dynamic lights
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点亮你的世界并提供动态灯光
- en: Deforming a terrain in real time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时变形地形
- en: Automating trees' distribution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化树木的分布
- en: Endless worlds and infinite space
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无尽的世界和无限的空间
- en: Flowing water with cellular automata
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用细胞自动机流动的水
- en: The essentials of a cube-based world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于立方体的世界的要素
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 1](ch01.html "Chapter 1. SDK Game Development Hub"), *SDK Game Development
    Hub*, we used Terrain Editor to manually create a heightmap and Scene Composer
    to put things together into scenes. Those were the two ways of creating worlds
    in jMonkeyEngine. In this chapter, we'll look into creating worlds using code
    or procedural generation. This can often be very quickly set up, but getting it
    right (and performant) can be tricky. To achieve this, we will make use of techniques
    such as custom meshes and batching. Batching is a method of taking several geometries
    using the same `Material` instance and creating one mesh out of all their meshes.
    This can significantly improve the performance of the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 SDK游戏开发中心")中，*SDK游戏开发中心*，我们使用了地形编辑器手动创建高度图，并使用场景组合器将事物组合成场景。这些是jMonkeyEngine中创建世界的两种方式。在本章中，我们将探讨使用代码或过程生成来创建世界。这通常可以非常快速地设置，但要正确（并且高效）地设置可能很棘手。为了实现这一点，我们将利用自定义网格和批处理等技术。批处理是一种使用相同的
    `Material` 实例获取多个几何形状的方法，并将所有这些几何形状创建成一个网格。这可以显著提高应用程序的性能。
- en: Using noise to generate a terrain
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用噪声生成地形
- en: While noise is unwanted in many occasions, it is a great tool for procedural
    generation and has many uses. In this recipe, we'll explore jMonkeyEngine's `FractalSum`
    class and generate an image based on the output. This can be used as a heightmap
    for a terrain, but we are not limited by that. With some tweaking, we could get
    a basis to cover a forest or city.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然噪声在许多情况下是不受欢迎的，但它是一种很好的过程生成工具，并且有许多用途。在本配方中，我们将探索jMonkeyEngine的 `FractalSum`
    类，并基于输出生成一个图像。这可以用作地形的_heightmap_，但我们并不局限于这一点。通过一些调整，我们可以得到一个覆盖森林或城市的基线。
- en: '![Using noise to generate a terrain](img/6478OS_03_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![使用噪声生成地形](img/6478OS_03_01.jpg)'
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe relies on a way to output an image. Either use your own method to
    do this or refer to the *The ImageGenerator class* section in [Appendix](apa.html
    "Appendix A. Information Fragments"), *Information Fragments*, which provides
    an example of how to do it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方依赖于一种输出图像的方法。或者使用你自己的方法来完成此操作，或者参考[附录](apa.html "附录A.信息片段")中的*ImageGenerator类*部分，*信息片段*，它提供了一个如何做到这一点的示例。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To generate a heightmap, perform the following steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个高度图，请执行以下步骤：
- en: We will start by creating a class called `NoiseMapGenerator`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为 `NoiseMapGenerator` 的类。
- en: In its constructor, define a new `FractalSum` instance and store it in a field
    called `fractalSum`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其构造函数中，定义一个新的 `FractalSum` 实例，并将其存储在名为 `fractalSum` 的字段中。
- en: Next, create a public method called `generateNoiseMap` that takes an integer
    parameter called `size`, a float parameter called `frequency`, and an integer
    parameter called `octaves` as inputs.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `generateNoiseMap` 的公共方法，该方法接受一个名为 `size` 的整数参数，一个名为 `frequency`
    的浮点参数，以及一个名为 `octaves` 的整数参数作为输入。
- en: 'Inside the method, configure `fractalSum` with some of the values and set the
    amplitude to `0.5f` as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部，使用一些值配置 `fractalSum`，并将振幅设置为 `0.5f`，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, define a 2D float array called `terrain`. Its dimension should be [size]
    x [size].
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个名为 `terrain` 的2D浮点数组。其维度应为 [size] x [size]。
- en: 'Now, create a double `for` loop statement and parse through the size of both
    dimensions. Inside the loop, we get the value from `fractalSum`, which is based
    on your *x* and *y* coordinates; add `0.5f` to the value. Clamp it to get a value
    between `0f` and `1f` and set the value in the terrain array as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个双重 `for` 循环语句，遍历两个维度的尺寸。在循环内部，我们从 `fractalSum` 获取值，该值基于你的 *x* 和 *y* 坐标；将
    `0.5f` 添加到值中。将其夹在 `0f` 和 `1f` 之间，并将值按以下方式设置在地形数组中：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you''re done, call the `ImageGenerator` class to create the PNG image
    for us as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成时，调用`ImageGenerator`类为我们创建PNG图像，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With this simple implementation, and by using the supplied `ImageGenerator`
    class, we have the basics for a heightmap. We can see the result in our `Projects`
    folder under `assets/Textures/heightmap.png`. It's an image that shifts smoothly
    between bright and dark areas; here, bright areas represent a high terrain and
    dark areas, a low terrain. Bright pixels have values that are close to 1, whereas
    dark pixels have values close to 0\. Normally, noise outputs values between -1
    and 1\. This is why we change the amplitude to 0.5f so that it yields a range
    between -0.5 and 0.5, and then we add 0.5 to the result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的实现，并使用提供的`ImageGenerator`类，我们有了高度图的基础。我们可以在`Projects`文件夹下的`assets/Textures/heightmap.png`中看到结果。这是一张在亮区和暗区之间平滑过渡的图像；在这里，亮区代表高地，暗区代表低地。亮像素的值接近1，而暗像素的值接近0。通常，噪声输出值在-1和1之间。这就是我们为什么将振幅改为0.5f，以便得到-0.5和0.5的范围，然后我们将0.5加到结果上。
- en: A noticeable problem is that no matter how much we change the speed and frequency
    of the noise, the same kind of rolling hills landscape will appear, only in different
    scales. By changing the octaves' value, we will generate noise in several iterations
    with decreasing amplitude. The value of each pixel for each iteration is multiplied
    with the previous one. The result is called fractal noise. Using octaves is a
    way of adding detail by iterating over the result with different frequencies.
    For each iteration, the frequency is doubled and the amplitude is halved.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的问题是，无论我们如何改变噪声的速度和频率，都会出现相同类型的起伏地形，只是规模不同。通过改变八度音的值，我们将以递减振幅的方式生成多个迭代的噪声。每个迭代的每个像素值都乘以前一个迭代。结果被称为分形噪声。使用八度音是一种通过迭代结果并使用不同频率来增加细节的方法。对于每个迭代，频率翻倍，振幅减半。
- en: Frequency can be thought of as a scale value where a higher frequency will generate
    more and smaller features. Having a higher frequency on its own will make peaks
    and valleys occur more frequently.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 频率可以被视为一个尺度值，其中较高的频率会产生更多更小的特征。仅仅拥有较高的频率本身会使峰值和谷值出现得更频繁。
- en: A normalization process is not strictly needed for a heightmap, unless we want
    to save it as an image. Also, if we were generating a large number of heightmaps
    (for example, during the runtime for a game), we would not want to normalize the
    terrain based on a particular heightmap's minimum and maximum values or we would
    end up with very similar and hilly landscapes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高度图来说，归一化过程不是必需的，除非我们想将其保存为图像。此外，如果我们正在生成大量高度图（例如，在游戏的运行时），我们不想根据特定高度图的最小和最大值来归一化地形，否则我们最终会得到非常相似和多山的地形。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now that we have generated a heightmap and exported it to an image, we can actually
    use it as a base in Terrain Editor. The process is similar to the one where we
    created a terrain for our scene in [Chapter 1](ch01.html "Chapter 1. SDK Game
    Development Hub"), *SDK Game Development Hub*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了高度图并将其导出为图像，我们实际上可以在地形编辑器中使用它作为基础。这个过程与我们创建场景中的地形的过程相似，在[第1章](ch01.html
    "第1章。SDK游戏开发中心")，*SDK游戏开发中心*。
- en: After creating a new scene (by all means, we can use an existing scene as well)
    and opening it, we can right-click on the main node in the **SceneExplorer** window
    and select **Add Spatial..** and then select **Terrain..**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的场景（无论如何，我们也可以使用现有的场景）并打开它后，我们可以在**场景资源管理器**窗口中的主节点上右键单击，并选择**添加空间..**然后选择**地形..**。
- en: It's important that we select the same total size as that of the pixels of our
    image. Then, in the **Heightmap** screen, we choose **Image Based** from the **HeightMap**
    drop-down menu and select our image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择与我们的图像像素相同的总大小是很重要的。然后，在**高度图**屏幕上，我们从**高度图**下拉菜单中选择**基于图像**，并选择我们的图像。
- en: The **Roughness** slider will define how much the heightmap will be smoothed
    out before it is added. A higher smoothness will remove finer details, and this
    is a must if we want to have characters that will run or drive on top of it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**粗糙度**滑块将定义在将其添加之前高度图将被平滑到什么程度。更高的平滑度会去除更细的细节，如果我们想要在上面奔跑或驾驶的角色，这是必须的。'
- en: The **Height Scale** option will define the maximum altitude that the heightmap
    can have and scale it accordingly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**高度比例**选项将定义高度图可以拥有的最大海拔，并相应地进行缩放。'
- en: Lighting your world and providing it with dynamic lights
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照亮你的世界并为它提供动态灯光
- en: This recipe will mostly be theories on different lighting types, but we'll also
    explore a way to easily control the movement of lights.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将主要涉及不同照明类型的理论，但我们也会探讨一种轻松控制灯光移动的方法。
- en: 'The four main types of lights that we can use to light up our world are as
    follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下四种主要类型的光照亮我们的世界：
- en: '**Ambient Light**: This lights up everything in the scene evenly. It''s good
    for avoiding anything to be in a pitch-black state, but it doesn''t create any
    shadows or nuances. Adding a too bright ambient light will give the world a bland
    look, while giving it a touch of color can set the mood.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境光**：它均匀照亮场景中的所有物体。它有助于避免任何物体处于漆黑的状态，但它不会创建任何阴影或细微差别。添加过于明亮的环境光会使世界看起来平淡无奇，而给它一点颜色可以设定氛围。'
- en: '**Directional Light**: This shines from a particular direction with perfectly
    parallel rays and without any falloff. This is usually used to simulate a sun,
    a bright source of light located far away.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光**：它从特定方向以完美平行的光线照射，没有任何减弱。这通常用来模拟远处的明亮光源，如太阳。'
- en: '**Point Light**: This shines equally in every direction but with a falloff,
    meaning this will eventually stop illuminating the surroundings. Usually, this
    forms most of the light sources in a game scene.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**：它在所有方向上均匀发光，但会减弱，这意味着它最终会停止照亮周围环境。通常，这构成了游戏场景中大部分的光源。'
- en: '**Spot Light**: This is exactly as it sounds. This produces a cone-shaped light
    in a specific direction from a specific location, and its light will eventually
    fall off. It has more settings than its sibling light types. Technically, it is
    more advanced than point lights and requires additional calculations in the shader
    to see what it illuminates.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**：正如其名，它从特定位置沿特定方向产生锥形光，其光线最终会减弱。它比其兄弟光类型有更多设置。技术上，它比点光源更先进，需要在着色器中进行额外的计算以确定它照亮了什么。'
- en: 'A spotlight with the same `spotInnerAngle` and `spotOuterAngle` parameters
    will have a light cone that looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同`spotInnerAngle`和`spotOuterAngle`参数的聚光灯将产生如下形状的光锥：
- en: '![Lighting your world and providing it with dynamic lights](img/6478OS_03_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![照亮你的世界并提供动态灯光](img/6478OS_03_03.jpg)'
- en: 'The `spotInnerAngle` and `spotOuterAngle` parameters define the size of the
    light cone that spotlight produces and both are set in radians. The `spotInnerAngle`
    parameter defines how far out the cone will shine at its maximum radiance. The
    `spotOuterAngle` parameter then defines how far the total extent of the radiance
    should be before it''s been completely extinguished. Having a greater value for
    the `spotOuterAngle` parameter will produce a softer edge on the spotlight. A
    spotlight with a small `spotInnerAngle` parameter and a high `spotOuterAngle`
    parameter will have softer edges, as shown in the following image:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`spotInnerAngle`和`spotOuterAngle`参数定义了聚光灯产生的光锥的大小，并且两者都是以弧度为单位设置的。`spotInnerAngle`参数定义了锥形在其最大辐射强度处会照射多远。`spotOuterAngle`参数然后定义了辐射完全熄灭之前辐射的总范围应该有多远。`spotOuterAngle`参数的值越大，聚光灯的边缘就会越柔和。具有较小的`spotInnerAngle`参数和较高的`spotOuterAngle`参数的聚光灯将具有更柔和的边缘，如下面的图像所示：'
- en: '![Lighting your world and providing it with dynamic lights](img/6478OS_03_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![照亮你的世界并提供动态灯光](img/6478OS_03_02.jpg)'
- en: To ensure an object is affected by the lights in a scene, it must have a `Material`
    class that supports it. For most game objects, the default choice is the **Lighting**
    material. It supports a variety of lighting types from per pixel to lightmaps
    and vertex lighting. The latter two are optional but have their uses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一个物体受到场景中灯光的影响，它必须有一个支持它的`Material`类。对于大多数游戏对象，默认选择是**照明**材质。它支持从逐像素到光照贴图和顶点照明的各种照明类型。后两种是可选的，但有其用途。
- en: A lightmap is essentially an extra texture where lighting has been pre-rendered.
    Its resolution can rarely match real-time lighting, but from another perspective,
    it is very fast since lighting doesn't have to be calculated at runtime; also,
    it can be used for static scenes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 光照贴图本质上是一个额外的纹理，其中已经预先渲染了光照。其分辨率很少能与实时光照相匹配，但从另一个角度来看，它非常快，因为不需要在运行时计算光照；此外，它可以用于静态场景。
- en: Normally, lighting is calculated on a per-pixel basis. This means that for each
    pixel visible on the screen, the processor has to calculate how it is affected
    by the available light sources. It is fairly expensive and even more so with many
    light sources, but it produces a more realistic result. Vertex lighting instead
    means that lighting is calculated for each vertex on a model. For low poly models,
    this is much faster although not as detailed. The quality will suffer noticeably
    when it is near the object, but it can give good enough results for objects some
    distance away.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，光照是按像素计算的。这意味着对于屏幕上每个可见的像素，处理器都必须计算它如何受到可用光源的影响。这相当昂贵，尤其是在许多光源的情况下，但它会产生更逼真的结果。顶点光照则意味着光照是按模型上的每个顶点计算的。对于低多边形模型，这要快得多，尽管细节不够丰富。当它靠近物体时，质量会明显下降，但它可以为远离物体的物体提供足够好的结果。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now that we have the basics covered, let''s explore a pattern that allows us
    to move lights using objects in the scene graph:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，让我们探索一种允许我们使用场景图中的对象移动灯光的模式：
- en: First, create a new `PointLight` class called `pointLight` and set `radius`
    to `40`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的`PointLight`类，命名为`pointLight`，并将`radius`设置为`40`。
- en: Then, call `rootNode.addLight(pointLight)` to add it to the scene graph.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`rootNode.addLight(pointLight)`将其添加到场景图中。
- en: Now, create a new `CameraNode` called `camNode` and then call `camNode.setControlDir(CameraControl.ControlDirection.CameraToSpatial);`
    before attaching it to the `rootNode`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的`CameraNode`，命名为`camNode`，然后在将其附加到`rootNode`之前调用`camNode.setControlDir(CameraControl.ControlDirection.CameraToSpatial);`。
- en: 'Next, create a new `LightControl` called `lightControl`, supplying `pointLight`
    to it to indicate that this is the light to control, as shown in the following
    code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的`LightControl`，命名为`lightControl`，向其中提供`pointLight`以指示这是要控制的灯光，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We set `controlDir` to be `LightControl.ControlDirection.SpatialToLight`. This
    means that the Spatial `camNode` will control the light''s position:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`controlDir`设置为`LightControl.ControlDirection.SpatialToLight`。这意味着空间`camNode`将控制光的位置：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we add `lightControl` to `camNode`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`lightControl`添加到`camNode`。
- en: To test this out, we can load **Sponza** (Models/Sponza/Sponza.j3o) from the
    jMonkeyEngine's `test-data` library and apply the **Lighting** material to it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我们可以从jMonkeyEngine的`test-data`库中加载**Sponza**（Models/Sponza/Sponza.j3o），并将其**照明**材质应用到它上面。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Lights are not `Spatials` in the scene graph, and it can be tricky to move them
    around. It can be added to nodes but then it will only illuminate the node (and
    its children) that it is added to. The `LightControl` class bridges the gap since
    it can be added as a control to `Spatial`, and it controls the position (and direction
    of a light). In this recipe, we used it so that the light will follow the camera
    around using a `CamNode`, but it works just as well for any other `spatial`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景图中，灯光不是`Spatials`，移动它们可能会很棘手。它可以添加到节点上，但这样它就只能照亮它所添加的节点（及其子节点）。`LightControl`类填补了这一空白，因为它可以作为控制添加到`Spatial`，并控制光的位置（以及方向）。在这个菜谱中，我们使用它让灯光跟随`CamNode`移动，但这同样适用于任何其他`spatial`。
- en: There's more…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We touched on **Ambient Light** and **Directional Light** in the *Adding a sky
    box and lighting* recipe from [Chapter 1](ch01.html "Chapter 1. SDK Game Development
    Hub"), *SDK Game Development Hub*. In the *Creating a dynamic sky box with a moving
    sun* recipe from [Chapter 9](ch09.html "Chapter 9. Taking Our Game to the Next
    Level"), *Taking Our Game to the Next Level*, we create **Directional Light**
    to simulate a day and night cycle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。SDK游戏开发中心")的*添加天空盒和照明*菜谱中，我们提到了**环境光**和**方向光**，在*SDK游戏开发中心*。在[第9章](ch09.html
    "第9章。将我们的游戏提升到下一个层次")的*创建带有移动太阳的动态天空盒*菜谱中，*将我们的游戏提升到下一个层次*，我们创建**方向光**来模拟昼夜循环。
- en: Deforming a terrain in real time
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时变形地形
- en: A deformable terrain is something that can have a serious effect on the gameplay,
    or it can simply be a cosmetic bonus. It can be used for impact craters or games
    that require excavation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可变形地形可能会对游戏玩法产生严重影响，或者它可能仅仅是一个外观上的加分项。它可以用于撞击坑或需要挖掘的游戏。
- en: We'll base the deformation around the `Control` class pattern as this allows
    us to offset the code in a manageable and reusable way. The recipe will trigger
    the deformation based on a mouse click, and it will use a ray to detect the collision
    point.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`Control`类模式为基础进行变形，因为这允许我们以可管理和可重用的方式偏移代码。这个菜谱将根据鼠标点击触发变形，并使用射线检测碰撞点。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get up and running quickly, unless there already is an application to apply
    this to, `TestTerrain.java` from the jMonkeyEngine's test cases will provide a
    good start for what we need. This example will expand on the code provided in
    that application, but it should work perfectly well with any terrain-based application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速启动，除非已经有应用程序应用这个功能，否则 jMonkeyEngine 的测试用例中的 `TestTerrain.java` 将为我们提供良好的起点。这个示例将扩展该应用程序中提供的代码，但它应该与任何基于地形的程序完美兼容。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'With a base application already set up, we can get straight to the creation
    of the Control pattern:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在已经设置好基础应用程序的情况下，我们可以直接进入创建控制模式：
- en: Create a new class called `DeformableControl` that extends `AbstractControl`.
    It needs one private terrain field called `terrain`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DeformableControl` 的新类，它扩展了 `AbstractControl`。它需要一个名为 `terrain` 的私有地形字段。
- en: Override the `setSpatial` method and cast `Spatial` to fit your terrain field;
    use `terrain = (Terrain) spatial;` to do this.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `setSpatial` 方法并将 `Spatial` 强制转换为适合你的地形字段；使用 `terrain = (Terrain) spatial;`
    来实现这一点。
- en: 'Create a method called `deform` that takes the 2D location, the radius of the
    deformation, and the force as an input. Also, declare two lists that we''ll use
    in the `heightPoints` and `heightValues` methods, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `deform` 的方法，它接受2D位置、变形半径和力作为输入。同时，声明两个列表，我们将在 `heightPoints` 和 `heightValues`
    方法中使用，如下所示：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we should create a nested `for` loop statement where we can iterate from
    `-radius` to `+radius` in both `x` and `y` (`z` to be correct). See how far from
    the center the point is and calculate the height to change at that location. The
    decrease of the force of the impact will be proportional to how far out it is
    from the center. Then, save the point in the `heightPoints` list and the new height
    in the `heightValues` list as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该创建一个嵌套的 `for` 循环语句，我们可以从 `-radius` 迭代到 `+radius`，在 `x` 和 `y` 方向上（`z`
    应该是正确的）。看看点离中心的距离，并计算在该位置改变的高度。冲击力的减少将与它离中心的距离成正比。然后，按照以下方式将点保存到 `heightPoints`
    列表和新高度保存到 `heightValues` 列表中：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To wrap up the method, we need to apply the new heights. First, unlock the
    terrain and then lock it again as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了总结这个方法，我们需要应用新的高度。首先，解锁地形，然后按照以下方式重新锁定：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we normally work with 3D vectors rather than 2D vectors, it can be a
    good idea to also create a convenience method called `deform`, which takes `Vector3f`
    as the input. It converts this input to `Vector2f` and in turn calls the other
    deform method as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们通常使用3D向量而不是2D向量，创建一个名为 `deform` 的便利方法可能是个好主意，它接受 `Vector3f` 作为输入。它将这个输入转换为
    `Vector2f`，然后调用其他变形方法，如下所示：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, trigger the deformation from a method in our application. Firstly, it
    should create a new `ray` instance that originates from the camera, as shown in
    the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从我们应用程序中的方法触发变形。首先，它应该创建一个新的 `ray` 实例，该实例从相机开始，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, create a new `CollisionsResults` object and check whether the ray intersects
    the terrain. If there is a collision, call `deform` on the terrain''s `DeformableControl`
    object by supplying the `contactPoint` parameter of the collision as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的 `CollisionsResults` 对象并检查射线是否与地形相交。如果有碰撞，通过提供碰撞的 `contactPoint` 参数在地形的
    `DeformableControl` 对象上调用 `deform`，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When deforming the terrain, we collect all the points we want to modify and
    the new heights in lists; then, we collectively update the terrain based on them.
    There is an `adjustHeight` method to update a single point as well, but it is
    assumed that it's faster using a list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在变形地形时，我们收集我们想要修改的所有点和新的高度到列表中；然后，根据它们集体更新地形。还有一个 `adjustHeight` 方法可以更新单个点，但假设使用列表更快。
- en: Locking the terrain means faster rendering. Whether to lock the terrain or not
    depends on the implementation. If it is a terrain that is changed with every frame,
    it probably doesn't need to be locked. On the other hand, if it changes only occasionally,
    it should probably be locked.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定地形意味着渲染更快。是否锁定地形取决于实现方式。如果地形是每帧都变化的，可能不需要锁定。另一方面，如果它只是偶尔变化，可能需要锁定。
- en: The formula that is used to calculate the change in height is *deltaHeight =
    force * (1 - distance / radius)*. This means that the change in height will be
    highest when it is closest to the center; it will then fall off linearly as the
    distance increases and we get closer to the edge of the radius. A variation worth
    exploring is to use the root with *deltaHeight = force * FastMath.sqrt(1 - distance
    / radius)* instead. This will provide a rounder shape to the terrain.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算高度变化的公式是 *deltaHeight = force * (1 - distance / radius)*。这意味着当它最接近中心时，高度变化将最大；随着距离的增加，它将线性下降，直到接近半径的边缘。一个值得探索的变体是使用
    *deltaHeight = force * FastMath.sqrt(1 - distance / radius)* 的根。这将给地形提供一个更圆滑的形状。
- en: Automating trees' distribution
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化树木分布
- en: Placing trees and bushes in an editor is fine for many types of games. There
    are many cases where you need objects to be in a very specific spot. When it comes
    to large-scale outdoor games, you might want to have a way of placing common objects
    in an automatic way, at least as a base. An artist or designer might then move
    items around to suit the needs of the game.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中放置树木和灌木对于许多类型的游戏来说是可以的。有许多情况下需要对象位于非常特定的位置。当涉及到大规模户外游戏时，你可能想要有一种方法以自动方式放置常见对象，至少作为一个基础。然后，艺术家或设计师可能会根据游戏的需求移动项目。
- en: In this recipe, we'll create one such way that places trees using noise. Once
    the base is in, we'll take a look at how the pattern can be varied with different
    settings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一种使用噪声放置树木的方法。一旦基础设置完成，我们将看看如何通过不同的设置来改变模式。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To produce automatic trees'' distribution, perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要产生自动树木分布，执行以下步骤：
- en: We get right to the center of the things. Create a new class called `TreeControl`
    that extends `AbstractControl`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们直接到达事物的中心。创建一个新的类，命名为 `TreeControl`，它扩展了 `AbstractControl`。
- en: Add a `TerrainQuad` field called `terrain`, a `FractalSum` field called `fractalSum`,
    a `Spatial` field called `treeModel`, and a `BatchNode` field called `treeNode`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `terrain` 的 `TerrainQuad` 字段，一个名为 `fractalSum` 的 `FractalSum` 字段，一个名为
    `treeModel` 的 `Spatial` 字段，以及一个名为 `treeNode` 的 `BatchNode` 字段。
- en: Override the `setSpatial` method. Here, we declare `treeNode`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `setSpatial` 方法。在这里，我们声明 `treeNode`。
- en: 'Then, assuming that the supplied `Spatial` is a `Node` class, parse its children
    looking for a `Spatial` that is an instance of `TerrainQuad`. Once found, set
    it to `terrain` as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，假设提供的 `Spatial` 是一个 `Node` 类，解析其子项以查找一个 `Spatial`，它是 `TerrainQuad` 的实例。一旦找到，按照以下方式将其设置为
    `terrain`：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using terrain's `terrainSize`, create a nested `for` loop statement that parses
    from its negative height and width to its positive.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用地形的 `terrainSize` 创建一个嵌套的 `for` 循环语句，从其负高度和宽度解析到其正高度和宽度。
- en: 'Inside this loop, grab a value from the `fractalSum` class based on the *x*
    and *y* coordinates. Then, look for the corresponding terrain height at that location
    as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个循环中，根据 *x* 和 *y* 坐标从 `fractalSum` 类中获取一个值。然后，按照以下方式查找该位置的相应地形高度：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we need to decide how many trees we want. The `FractalSum` class generates
    a value between -1 and 1\. Start by saying that any value above 0.5 should generate
    a tree and create an `if` statement accordingly.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要决定我们想要多少棵树。`FractalSum` 类生成介于 -1 和 1 之间的值。首先，可以说任何大于 0.5 的值都应该生成一棵树，并相应地创建一个
    `if` 语句。
- en: 'If this is fulfilled, start by cloning `treeModel`. Set its `localTranslation`
    to the *x* and *y* coordinates and the current `terrainHeight` field before attaching
    it to the `treeNode` field:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果满足条件，首先克隆 `treeModel`。将其 `localTranslation` 设置为 *x* 和 *y* 坐标以及当前的 `terrainHeight`
    字段，然后将其附加到 `treeNode` 字段：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After parsing the whole terrain, tell the `treeNode` field to batch its contents
    to optimize the performance and then attach it to the supplied `Spatial`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析完整个地形后，告诉 `treeNode` 字段批量处理其内容以优化性能，然后将其附加到提供的 `Spatial`。
- en: Now, create an application class to test this. It's recommended that you use
    a test case such as `TestTerrainAdvanced` to get a start.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个应用程序类来测试这个功能。建议使用 `TestTerrainAdvanced` 这样的测试用例来开始。
- en: Create a new `Node` class called `worldNode`, which we attach to `rootNode`
    and then attach the terrain to.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Node` 类，命名为 `worldNode`，将其附加到 `rootNode` 上，然后将地形附加到它。
- en: Then, create a new `TreeControl` class and load and set a suitable model that
    we can use as `treeModel`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的 `TreeControl` 类，并加载并设置一个合适的模型，我们可以将其用作 `treeModel`。
- en: Finally, add the `TreeControl` class to `worldNode`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `TreeControl` 类添加到 `worldNode` 中。
- en: After running the application, we will see trees spread out across the terrain—in
    valleys as well as on top of the mountains. Depending on the environment, trees
    might not grow on mountains. If we don't want this, we can add a simple check
    in the `TreeControl` class. By adding a field called `treeLimit`, we can clamp
    the growth of the tree above a certain height; also, make sure the `terrainHeight`
    field is lower than the value supplied from `fractalSum`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序后，我们将看到树木在地面上的分布——在山谷以及山顶上。根据环境，树木可能不会在山上生长。如果我们不希望这样，我们可以在`TreeControl`类中添加一个简单的检查。通过添加一个名为`treeLimit`的字段，我们可以限制树木在特定高度以上的生长；同时，确保`terrainHeight`字段低于从`fractalSum`提供的值。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we let the noise do most of the work for us. All we did was
    parse through the terrain, and at regular intervals, check whether the noise value
    at that point indicated whether a tree should be placed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们让噪声为我们做大部分工作。我们所做的只是解析地形，并在固定间隔检查该点的噪声值是否表示应该放置树木。
- en: The noise provides an almost endless amount of variation to our distribution
    of vegetation and an equally endless amount of tweaking possibilities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 噪声为我们植被的分布提供了几乎无限的变化，以及同样无限的可调整可能性。
- en: The drawback of using these automatic generation techniques is that we don't
    have proper control over them, and changing a value ever so slightly might have
    a large impact on the terrain. Also, even if the generation process is cheap and
    can be repeated deterministically, we will have to start storing the data as soon
    as we want to modify it in any way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些自动生成技术的缺点是我们无法对它们进行适当的控制，即使改变一个值非常微小，也可能对地形产生重大影响。此外，即使生成过程成本低廉且可以重复确定，我们一旦想要以任何方式修改数据，就必须立即开始存储它。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With the current settings, the example distributes trees across a landscape
    in a seemingly random pattern. At first glance, it might look natural but trees
    rarely are so evenly distributed as this. Outside of a forest, you will usually
    find trees clumped together. We can easily achieve this with noise by changing
    the frequency. The following examples show how changing the frequency can change
    the pattern:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前设置下，示例将树木以看似随机的模式分布在整个景观中。乍一看，这可能看起来很自然，但树木很少分布得如此均匀。在森林之外，你通常会找到树木聚集在一起。我们可以通过改变频率轻松地通过噪声实现这一点。以下示例显示了如何通过改变频率来改变模式：
- en: A frequency of 0.5 produces a very noisy and fairly uniform pattern, as shown
    in the following screenshot:![There's more...](img/6478OS_03_04.jpg)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率为0.5产生一个非常嘈杂且相当均匀的模式，如下面的截图所示：![还有更多...](img/6478OS_03_04.jpg)
- en: With a frequency of 0.1, we can distinguish different patterns as follows:![There's
    more...](img/6478OS_03_05.jpg)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率为0.1时，我们可以区分不同的模式如下：![还有更多...](img/6478OS_03_05.jpg)
- en: A frequency of 0.02 yields even less but larger clumps of vegetation as follows:![There's
    more...](img/6478OS_03_06.jpg)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率为0.02产生更少但更大的植被簇，如下所示：![还有更多...](img/6478OS_03_06.jpg)
- en: Endless worlds and infinite space
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无尽的世界和无尽的空间
- en: There's really no such thing as endless or infinite in computer-generated worlds.
    Sooner or later, you're going to hit one limit or the other. However, there are
    some techniques that will get you further than others. The normal approach when
    creating a game is to move the player around the game world. Those who have tried
    to, for example, make a space exploration game in this way have noticed that pretty
    soon problems with regards to float numbers appear. This is because float values
    are not evenly spaced. As their values increase, their precision decreases. Using
    doubles rather than floats will only delay what's inevitable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机生成的世界中，实际上并没有无尽或无限的东西。迟早你会遇到一个或另一个限制。然而，有一些技术可以使你走得更远。创建游戏时的常规方法是在游戏世界中移动玩家。那些尝试过，例如，以这种方式制作太空探索游戏的人会发现，很快就会出现与浮点数相关的问题。这是因为浮点值不是均匀分布的。随着它们的值增加，它们的精度会降低。使用双精度浮点数而不是单精度浮点数只会推迟不可避免的事情。
- en: If you can't even have a solar system as a human-scaled game world, how can
    you then have a whole galaxy? As an old saying goes, "If Mohammed won't come to
    the mountain, the mountain must come to Mohammed." That is exactly the solution
    to our first problem! By making the game world move around the player, we ensure
    that the precision remains high. This is great for large-scale game worlds. The
    drawback is that it requires a different architecture. Switching how the game
    world is generated or loaded during the mid-development stage can be a huge task.
    It's better to decide this during the design phase.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连一个按人类尺度游戏世界的太阳系都无法拥有，那么如何拥有整个星系呢？正如一句古老的谚语所说：“如果穆罕默德不去山，山就必须到穆罕默德那里。”这正是我们第一个问题的解决方案！通过让游戏世界围绕玩家移动，我们确保了精度保持很高。这对于大规模游戏世界来说非常好。缺点是它需要一个不同的架构。在开发中期切换游戏世界的生成或加载方式可能是一项巨大的任务。最好在设计阶段就决定这一点。
- en: Another problem is the sheer size of the worlds. You can't simply store all
    the terrain-based game world of a decent size in the memory at once. We can solve
    this problem by loading world data on demand and throwing it away when we don't
    need it any more. This recipe will use a simple method to generate the world on
    demand, but the principle can be applied to other methods, such as generating
    a heightmap or loading the world from a storage device.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是世界的大小。您不能一次性将一个相当大的基于地形的游戏世界存储在内存中。我们可以通过按需加载世界数据并在不再需要时丢弃它来解决此问题。这个配方将使用一种简单的方法按需生成世界，但这个原理也可以应用于其他方法，例如生成高度图或从存储设备加载世界。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Dynamic world loading can be created with the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤创建动态世界加载：
- en: Create a new class called `EndlessWorldControl`. It should extend `AbstractControl`
    and implement `ActionListener`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EndlessWorldControl`的新类。它应该扩展`AbstractControl`并实现`ActionListener`接口。
- en: We need to add a couple of fields to it as well. First of all, we need to keep
    track of the application's camera and store it in a parameter called `cam`. The
    class also requires a `Geometry` parameter called `currentTile` to represent the
    currently centered game area. A `Material` parameter called `material` will be
    used on the geometries and a `HashMap<Vector2f, Geometry>` parameter called `cachedTiled`
    will store the entire currently active game world.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加一些字段。首先，我们需要跟踪应用程序的摄像机并将其存储在一个名为`cam`的参数中。该类还需要一个名为`currentTile`的`Geometry`参数来表示当前中心的游戏区域。一个名为`material`的`Material`参数将用于几何形状，一个名为`cachedTiled`的`HashMap<Vector2f,
    Geometry>`参数将存储整个当前活动的游戏世界。
- en: 'The class implements `ActionListener` and will handle movements based on user
    input. To do this, add four Booleans as well: `moveForward`, `moveBackward`, `moveLeft`,
    and `moveRight`.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类实现了`ActionListener`接口，并将根据用户输入处理移动。为此，还需要添加四个布尔值：`moveForward`、`moveBackward`、`moveLeft`和`moveRight`。
- en: 'In the `onAction` method, add the following code to set the Booleans based
    on the input:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onAction`方法中，添加以下代码来根据输入设置布尔值：
- en: '[PRE14]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `controlUpdate` method, move the tiles based on the direction of the
    camera and the Booleans you just created. First, get the current forward direction
    of the camera and the direction which is to the left of it. Then, multiply it
    by `tpf` to get an even movement and an arbitrary value to increase the speed
    of the movement as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，根据摄像机的方向和您刚刚创建的布尔值移动瓦片。首先，获取摄像机的当前前进方向和它左侧的方向。然后，将其乘以`tpf`以获得均匀的运动和任意值来增加运动速度，如下所示：
- en: '[PRE15]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using this, call a method called `moveTiles` if any movement should occur as
    follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个，如果应该发生任何移动，就调用一个名为`moveTiles`的方法，如下所示：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, add the `moveTiles` method that takes a `Vector3f` object called `amount`
    as the input. First, parse through the values of the `cachedTiles` map and apply
    the amount value as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`moveTiles`的方法，它接受一个名为`amount`的`Vector3f`对象作为输入。首先，遍历`cachedTiles`映射的值，并按以下方式应用数量值：
- en: '[PRE17]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, create an `Iterator` object and iterate through `cachedTiles` again;
    stop if any of the tiles contain `Vector3f.ZERO`, which is the location of the
    camera. This is our new `currentTile` object. This can be implemented as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`Iterator`对象，再次遍历`cachedTiles`；如果任何瓦片包含`Vector3f.ZERO`，即摄像机的位置，则停止迭代。这就是我们的新`currentTile`对象。这可以按以下方式实现：
- en: '[PRE18]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The location of this tile will be used to decide which other tiles should be
    loaded. Pass this to two new methods: `updateTiles` and `deleteTiles`.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个瓦片的位置将用于决定应该加载哪些其他瓦片。将其传递给两个新方法：`updateTiles`和`deleteTiles`。
- en: First, we take a look at the `updateTiles` method. It takes a `Vector2f` parameter
    called `newLocation` as the input. Create a nested `for` loop that goes from `x-1`
    and `y-1` to `x+1` and `y+1`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们来看看 `updateTiles` 方法。它接受一个名为 `newLocation` 的 `Vector2f` 参数作为输入。创建一个嵌套的
    `for` 循环，从 `x-1` 和 `y-1` 到 `x+1` 和 `y+1`。
- en: 'Check whether `cachedTiles` already has the tile with `newLocation` and `x`
    and `y` combined. If it doesn''t, we create a new tile and apply `BoundingBox`
    of the same size as the tile:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `cachedTiles` 是否已经具有 `newLocation` 和 `x` 和 `y` 组合的瓷砖。如果没有，我们创建一个新的瓷砖并应用与瓷砖大小相同的
    `BoundingBox`：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We set location to be the delta distance from `newLocation`. If `currentTile`
    is not null, we add its `localTranslation` too:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将位置设置为从 `newLocation` 的增量距离。如果 `currentTile` 不为空，我们还要添加其 `localTranslation`：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, attach `g` to the control's spatial and put `g` in the `cachedTiles`
    map with `wantedLocation` as the key.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `g` 附接到控制器的空间，并将 `g` 放入以 `wantedLocation` 为键的 `cachedTiles` 映射中。
- en: Now, for the `deleteTiles` method, it also takes a `Vector2f` parameter called
    `newLocation` as the input.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于 `deleteTiles` 方法，它也接受一个名为 `newLocation` 的 `Vector2f` 参数作为输入。
- en: 'Like the `updateTiles` method, iterate through the `cachedTiles` map. Look
    for those tiles that are now more than two tiles away in either direction and
    add their location to a list called `tilesToDelete`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 `updateTiles` 方法类似，遍历 `cachedTiles` 映射。寻找现在在任一方向上超过两个瓷砖距离的瓷砖，并将它们的地址添加到名为
    `tilesToDelete` 的列表中：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you're done, simply parse through the `tilesToDelete` list, remove the
    tile from `cachedTiles`, and detach it from `Spatial`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成时，只需遍历 `tilesToDelete` 列表，从 `cachedTiles` 中删除瓷砖，并将其从 `Spatial` 中分离。
- en: There is one more thing we need to do before leaving the class. In the `setSpatial`
    method, we should add a call to `updateTiles`, supplying `Vector2f.ZERO` to it
    to initialize the generation of the tile.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在离开类之前，我们还需要做一件事。在 `setSpatial` 方法中，我们应该调用 `updateTiles`，并给它提供 `Vector2f.ZERO`
    以初始化瓷砖的生成。
- en: For a larger implementation, we might want to introduce an `AppState` instance
    to handle this, but here we will manage it with a test application.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于更大的实现，我们可能希望引入一个 `AppState` 实例来处理这个问题，但在这里我们将使用测试应用程序来管理它。
- en: First of all, we need to disable `flyCam` with `flyCam.setEnabled(false)` and
    possibly move the camera to some distance from the ground.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `flyCam.setEnabled(false)` 禁用 `flyCam`，并可能将相机移动到离地面一定距离的位置。
- en: Then, create a `Node` class called `worldNode` and an `EndlessWorldControl`
    instance called `worldControl`. Attach `worldNode` to `rootNode` and supply the
    `worldControl` object with a material before adding it to `worldNode` and setting
    the camera.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 `worldNode` 的 `Node` 类和一个名为 `worldControl` 的 `EndlessWorldControl`
    实例。将 `worldNode` 附接到 `rootNode` 上，在将其添加到 `worldNode` 并设置相机之前，向 `worldControl`
    对象提供一个材质。
- en: 'Finally, set up some keys to control the movement and add the `worldControl`
    object as a listener; refer to the following code on how to do this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置一些键来控制移动，并将 `worldControl` 对象作为监听器添加；有关如何操作的代码，请参考以下内容：
- en: '[PRE22]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The process that we follow is that if a movement occurs, the `moveTiles` method
    will first move all the tiles to `cachedTiles`. It then checks to see whether
    there's a new tile that should be the center or whether it should be `currentTile`.
    If this happens, other tiles must be checked to see which ones should be kept
    and which ones need to be generated. This happens in the `updateTiles` method.
    Last in the chain is the `deleteTiles` method that checks which tiles should be
    removed because they are too far away.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循的过程是，如果发生移动，`moveTiles` 方法将首先将所有瓷砖移动到 `cachedTiles`。然后检查是否有一个新的瓷砖应该是中心或是否应该是
    `currentTile`。如果发生这种情况，必须检查其他瓷砖，以确定哪些应该保留，哪些需要生成。这发生在 `updateTiles` 方法中。链的最后一部分是
    `deleteTiles` 方法，它检查哪些瓷砖应该被移除，因为它们离得太远。
- en: If we print out the translation of the tiles, we can see that they are never
    very far from the center of their parent node. This happens because when we generate
    the tiles, we place them relative to `currentTile`. Since `currentTile` is also
    based on a relative position, things never move very far. It's almost like a conveyor
    belt.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印出瓷砖的平移，我们可以看到它们永远不会离其父节点的中心太远。这是因为当我们生成瓷砖时，我们是相对于 `currentTile` 来放置它们的。由于
    `currentTile` 也是基于相对位置，所以事物永远不会移动得太远。这几乎就像一个传送带。
- en: Flowing water with cellular automata
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用细胞自动机流动的水
- en: Cellular automata is an n-dimensional set of cells that interact together with
    a given set of rules. Over time, these interactions have given way to patterns,
    and modifying the rules will modify the pattern. The most famous example is probably
    Conway's Game of Life where cells based on an extremely simple rule set create
    the most amazing, evolving patterns. In games, cellular automata is usually found
    simulating liquids in a tile– or block–based game worlds.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 细胞自动机是一个由细胞组成的n维集合，这些细胞根据一组给定的规则相互交互。随着时间的推移，这些交互产生了模式，修改规则将修改模式。最著名的例子可能是康威的生命游戏，其中基于极其简单的规则集的细胞创造了最令人惊叹、不断演变的模式。在游戏中，细胞自动机通常用于模拟基于瓦片或块的游戏世界中的液体。
- en: In this recipe, we'll explore such a liquid system based on a 2D grid. Since
    it's 2D, there can be no true waterfalls, but it can still be applied to a heightmap
    (which we'll show) to create natural-looking rivers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探索一个基于2D网格的液体系统。由于它是2D的，所以不可能有真正的瀑布，但它仍然可以应用于高度图（我们将展示），以创建看起来自然的河流。
- en: 'Performance becomes an issue with large cellular automata, which will become
    evident as they''re scaled up. To counter this, we''ll also look at a couple of
    different techniques to keep the resource consumption down. The following image
    shows water running down the slope of a mountain:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当细胞自动机规模较大时，性能会成为一个问题，这一点在它们放大时会变得明显。为了解决这个问题，我们还将探讨几种不同的技术来降低资源消耗。以下图片显示了水沿着山坡流下：
- en: '![Flowing water with cellular automata](img/6478OS_03_07.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用细胞自动机的流动水](img/6478OS_03_07.jpg)'
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires height differences to make it interesting. A heightmap
    will work very well.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要高度差异来使其变得有趣。一个高度图将非常有效。
- en: 'The model we''ll develop will evolve around cells that are defined by two parameters:
    the height of the ground it resides on and the amount of water in it. If the height
    and amount of water combined are higher than a neighboring cell, water will pour
    out of it and into its neighbor. To make sure the cells are updated simultaneously,
    all of the water pouring into a cell will be stored in a separate field and applied
    at the end of the update cycle. This ensures that water can only move one tile
    through the field in one update. Otherwise, the same unit of water might travel
    across the whole grid in one update as we loop through the tiles.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发的模型将围绕由两个参数定义的细胞展开：它所在地面的高度和其中的水量。如果高度和水量之和高于相邻的细胞，水将从这个细胞流出并流入其邻居。为了确保细胞同时更新，所有流入一个细胞的水都将存储在一个单独的字段中，并在更新周期结束时应用。这确保了水只能在一次更新中通过一个瓦片移动。否则，同一个单位的水可能会在我们遍历瓦片时在一个更新周期内穿越整个网格。
- en: The example mentions a `CellUtil` class. The code for this can be found in the
    *The CellUtil class* section in [Appendix](apa.html "Appendix A. Information Fragments"),
    Information Fragments.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中提到了一个`CellUtil`类。这个类的代码可以在[附录](apa.html "附录 A. 信息片段")中的*`The CellUtil class`部分找到，信息片段。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following steps will produce flowing water:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将产生流动的水：
- en: First of all, let us create a class that contains the cell logic. We can call
    it `WaterCell`. It needs a float field called `amount`, another float field called
    `terrainHeight`, and one integer field for the current direction of the flow.
    It should also store any incoming water in a float field called `incomingAmount`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含细胞逻辑的类。我们可以称它为`WaterCell`。它需要一个名为`amount`的浮点字段，另一个名为`terrainHeight`的浮点字段，以及一个表示当前流向方向的整数字段。它还应该在名为`incomingAmount`的浮点字段中存储任何进入的水。
- en: In addition to the normal getter and setter for `amount`, add a method called
    `adjustAmount` that takes a float variable called `delta` as the input. The `delta`
    variable should be added to `amount`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`amount`的正常获取和设置方法外，添加一个名为`adjustAmount`的方法，该方法接受一个名为`delta`的浮点变量作为输入。`delta`变量应添加到`amount`中。
- en: Create a method called `compareCells` that will move the water between cells.
    It takes another cell (where the water is coming from) as the input.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`compareCells`的方法，该方法将在细胞之间移动水。它接受另一个细胞（水来自该细胞）作为输入。
- en: 'The first thing the method does is checks the difference in height between
    the two cells as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法首先检查两个细胞之间的高度差，如下所示：
- en: '[PRE23]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The method will only move the water in one way: from the supplied cell to this
    cell so it will only act if the difference is positive (and higher than an arbitrary
    small amount).'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法只会以单向移动水：从提供的细胞到这个细胞，因此它只有在差异为正（并且高于一个任意的小量）时才会起作用。
- en: 'If so, it takes half of the difference since this would even out the amount
    between the two cells. Before applying it, make sure we don''t move more water
    than there already is in the originating cell:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，它取两个单元格之间差值的一半，因为这会使两个单元格之间的数量相等。在应用之前，确保我们不会移动比原始单元格中已有的水更多的水：
- en: '[PRE24]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Add the calculated result to the `incomingAmount` field (we don't update the
    amount for this until everything has been calculated).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计算出的结果添加到 `incomingAmount` 字段（我们不会更新这个数量，直到一切都已计算完毕）。
- en: 'However, we must deduct the same amount from the originating cell or there
    would be a never-ending supply of water. It''s done like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们必须从原始单元格中扣除相同的数量，否则就会有一个永无止境的水源。操作如下所示：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, return the deducted amount from this method.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从这个方法中返回扣除的数量。
- en: We can leave this class for now and focus on creating a control that will use
    this class. Create a new class called `WaterFieldControl` that extends `AbstractControl`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以暂时放下这个类，专注于创建一个将使用这个类的控件。创建一个名为 `WaterFieldControl` 的新类，它扩展了 `AbstractControl`。
- en: It needs two integer fields to control the width and height of the field as
    well as a 2D array of `WaterCell` called `waterField`. To display it, we'll add
    a `Node` class called `water` and a `Material` class called `material`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要两个整数字段来控制字段的宽度和高度，以及一个名为 `waterField` 的 2D `WaterCell` 数组。为了显示它，我们将添加一个名为
    `water` 的 `Node` 类和一个名为 `material` 的 `Material` 类。
- en: 'The `setSpatial` method should be overridden and the `spatial` variable passed
    has to be an instance of `Node`. Look for a terrain among its children; once found,
    populate `waterField` with `WaterCells`, applying the height of the terrain for
    each tile as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该重写 `setSpatial` 方法，并且传递给 `spatial` 变量的实例必须是 `Node` 类型。在其子节点中查找地形；一旦找到，用 `WaterCells`
    填充 `waterField`，并为每个瓦片应用地形的以下高度：
- en: '[PRE26]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, create a new method called `updateCells`. For this example, define a source
    of water that will never run out right from the beginning by setting the amount
    of water in one of the middle tiles as 1.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `updateCells` 的新方法。在这个例子中，定义一个永远不会耗尽的水源，通过将中间瓦片之一的水量设置为 1。
- en: Then, parse through each cell in the `waterField` array in a nested `for` loop.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过嵌套的 `for` 循环遍历 `waterField` 数组中的每个单元格。
- en: 'If the cell has an amount that is larger than 0, we can go on and check where
    we should start moving the water. Start with the cell''s direction, and if there
    is water left after checking one direction, continue to look through the other
    seven directions. This is what the implementation might look like:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单元格的数量大于 0，我们可以继续检查我们应该从哪里开始移动水。从单元格的方向开始，如果检查一个方向后还有水剩余，继续检查其他七个方向。实现可能如下所示：
- en: '[PRE27]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For each of these directions, we must first check that it is a valid location
    within the field. Then, retrieve the neighboring cell and call `compareCells`
    to try to dump water in it. If this try is successful, set the direction of the
    `neighborCell` object to the tested direction to represent the flow of water,
    as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些方向中的每一个，我们首先必须检查它是否在字段内的有效位置。然后，检索相邻的单元格并调用 `compareCells` 尝试向其中倾倒水。如果这个尝试成功，将
    `neighborCell` 对象的方向设置为测试的方向以表示水的流动，如下所示：
- en: '[PRE28]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before you exit the method, parse through the `waterField` array once again.
    This time add `incomingWater` to the current amount of the cell and then set `incomingWater`
    to `0`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出方法之前，再次遍历 `waterField` 数组。这次将 `incomingWater` 添加到单元格的当前数量中，然后将 `incomingWater`
    设置为 `0`。
- en: To handle the display of the result, create a new method called `createGeometry`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理结果的显示，创建一个名为 `createGeometry` 的新方法。
- en: The first thing we need to do is check whether the `Spatial` of the control
    has a child called **Water**. If it does, detach it.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是检查控制器的 `Spatial` 是否有一个名为 **Water** 的子节点。如果有，将其断开连接。
- en: 'Next, define a new `Node` class called `water`. Its name should be `Water`
    as this is an identifier in this example:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个新的名为 `water` 的 `Node` 类。它的名字应该是 `Water`，因为在这个例子中这是一个标识符：
- en: '[PRE29]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, parse the `waterField` array. If any cell's amount is more than 0, you
    should add a `Geometry` object that represents it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次解析 `waterField` 数组。如果任何单元格的数量超过 0，你应该添加一个表示它的 `Geometry` 对象。
- en: We're going to add some logic to the `getGeometry` method to avoid recreating
    the `Geometry` field unnecessarily. First of all, set `geometry` to `null` if
    the `amount` value is 0.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向 `getGeometry` 方法添加一些逻辑，以避免不必要地重新创建 `Geometry` 字段。首先，如果 `amount` 值为 0，将
    `geometry` 设置为 `null`。
- en: 'Otherwise, if `geometry` is null, create a new `geometry` instance with a box-like
    shape as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果`geometry`为null，创建一个新的具有类似盒子形状的`geometry`实例，如下所示：
- en: '[PRE30]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To adapt it to the amount of water we have, scale the resulting cube by typing
    the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了适应我们拥有的水量，通过输入以下代码来缩放生成的立方体：
- en: '[PRE31]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After this, return the `geometry` field, which might be null.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，返回`geometry`字段，它可能为null。
- en: 'Coming back to the `WaterFieldControl` class, if the returned `geometry` variable
    is not null, set its location and attach it to the `water` node as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`WaterFieldControl`类，如果返回的`geometry`变量不为null，设置其位置并将其附加到`water`节点，如下所示：
- en: '[PRE32]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Apply the material to the `water` node and then batch it to increase the performance
    before attaching it to the control''s `spatial`, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质应用到`water`节点，然后批量处理以提高性能，在将其附加到控制器的`spatial`之前，如下所示：
- en: '[PRE33]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To finish things off, update the `controlUpdate` method to call `updateCells`
    and `createGeometry`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个任务，更新`controlUpdate`方法以调用`updateCells`和`createGeometry`。
- en: Now this can be used with a few lines in the application class. First of all,
    create a new `WaterFieldControl` class that we'll add to a `Node` class that contains
    a `Terrain` instance.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这可以通过在应用程序类中几行代码来实现。首先，创建一个新的`WaterFieldControl`类，我们将将其添加到一个包含`Terrain`实例的`Node`类中。
- en: Next, we need to create the material for the water. This can be as simple as
    creating a `Material` instance with `Unshaded` `MaterialDefinition` and applying
    a blueish color to it or an advanced custom shader. It is then applied to the
    `WaterFieldControl` class via the `setMaterial` method.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建水的材质。这可以像创建一个带有`Unshaded` `MaterialDefinition`的`Material`实例并将蓝色色调应用到它上，或者使用高级自定义着色器。然后，通过`setMaterial`方法将其应用到`WaterFieldControl`类。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The beauty of cellular automata is the simplicity with which they work. Each
    cell has a very basic set of rules. In this example, each cell wants to even out
    the water level with a neighboring cell. As we go through iteration, the water
    moves downhill.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 细胞自动机的美丽之处在于它们工作的简单性。每个细胞都有一组非常基本的规则。在这个例子中，每个细胞都希望与相邻的细胞平衡水位。随着迭代的进行，水会流向低处。
- en: It's usually fairly easy to get the automation up and running, but it can take
    a while to get everything right. For example, even if each cell's amount is updated
    correctly, we will get weird oscillating water effects if the flow's direction
    doesn't work correctly. The reason is that there would be a preferred direction
    the water will take in a new cell. This direction might be the opposite of where
    it came from, making it want to move back to the cell it came from. Picking a
    random direction might work in that case, but it makes it more difficult to predict
    the behavior. This is why we use the direction of the water in the cell it came
    from. Naturally, the water will have some momentum and will continue to flow until
    it is stopped.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使自动化运行起来相对容易，但要确保一切正确可能需要一些时间。例如，即使每个单元格的数量更新正确，如果流动的方向不正确，我们仍然会得到奇怪的水波效果。原因是水在新单元格中会倾向于一个特定的方向。这个方向可能与它来的方向相反，使其想要回到原来的单元格。在这种情况下，随机选择一个方向可能有效，但它会使预测行为变得更加困难。这就是为什么我们使用水来自单元格的方向。自然地，水会有一些动量，并且会继续流动，直到它被阻止。
- en: One thing that can be tricky to grasp at first is the reason why we don't update
    the water amount directly. The reason is that if water moves from cell x to cell
    x+1, that water would instantly become available for x+1 once the `update` method
    reaches there; also, it could be moved to x+2 and so on. We can't think of the
    water as real time, and that's why we first perform an outgoing operation on all
    the cells before we apply the incoming water. We also don't change the amount
    in the cell we're currently checking for the same reason. Instead, we move any
    water left in a cell to the `incomingWater` field.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最初可能难以理解的一点是，我们为什么不直接更新水量。原因是如果水从单元格x移动到单元格x+1，一旦`update`方法到达那里，那水就会立即对x+1可用；它也可能被移动到x+2等等。我们不能将水视为实时，这就是为什么我们在应用流入的水之前，首先对所有的单元格执行出行的操作。同样，我们也不改变我们当前检查的单元格中的数量，原因相同。相反，我们将单元格中剩余的水移动到`incomingWater`字段。
- en: The main challenge with the method is usually related to performance. Calculating
    can be expensive and rendering even more so. With a system like this, it's ever-changing
    and we might be forced to recreate the mesh in every frame. Rendering each cell
    on its own quickly becomes impossible, and we must use batching to create a single
    mesh. Even this is not enough, and in this example, we store the cell's `geometry`
    field so we don't have to recreate it unless the water level is 0 in a cell. We
    also scale the cell's `geometry` field if the water level changes as this is much
    quicker than creating a new `Mesh` class for it. The drawback is the additional
    memory that is used by storing it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要挑战通常与性能相关。计算可能很昂贵，渲染则更加昂贵。在这种系统中，它不断变化，我们可能被迫在每一帧中重新创建网格。单独渲染每个单元格很快就会变得不可能，我们必须使用批处理来创建单个网格。即使这样也不够，在这个例子中，我们存储了单元格的`geometry`字段，这样我们就不必在单元格中的水位为0时重新创建它。如果水位发生变化，我们还会缩放单元格的`geometry`字段，因为这比为它创建一个新的`Mesh`类要快得多。缺点是存储它所使用的额外内存。
- en: We also made it optional to update the water in every frame. By lowering it
    to a set amount of updates every second (in practice, its own frame rate), we
    could severely lessen the impact of the performance. This could also be taken
    further by only updating parts of the water field with every update, but efforts
    must be taken to conserve the amount of the water. We could also separate the
    field into smaller batches and check whether any of these need to be reconstructed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使更新每一帧中的水成为可选操作。通过将其降低到每秒一定数量的更新（实际上，就是其自身的帧率），我们可以极大地减轻性能的影响。还可以进一步通过每次只更新水场的部分区域来做到这一点，但必须采取措施来保存水的数量。我们还可以将场分成更小的批次，并检查是否需要重建其中的任何部分。
- en: There are ways to take this example further for those who wish. One could play
    around with the amount of water that each cell shares. This will make it more
    expensive to calculate but might give a smoother result. It's also possible to
    add pressure as a parameter, making it possible for water to move up the slopes.
    Evaporation might be a way to remove water from the system and clean up any puddles
    left by the main flow.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望进一步探索的人来说，有一些方法。可以玩弄每个单元格共享的水量。这将使计算更加昂贵，但可能得到更平滑的结果。还可以添加压力作为参数，使水能够沿着斜坡向上移动。蒸发可能是一种从系统中移除水并清理主流动留下的任何积水的方法。
- en: The essentials of a cube-based world
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于立方体的世界的要点
- en: In this recipe, we'll build a small framework to generate optimized cube meshes,
    which can be used to create large-scale worlds. This framework will consist of
    an `AppState` object to handle user actions, a class called `CubeWorld` that will
    store the terrain data, and a class called `CubeCell` that will store the data
    for individual cells. In addition, there is a `CubeUtil` class that will help
    us to generate meshes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将构建一个小的框架来生成优化的立方体网格，这可以用来创建大规模的世界。这个框架将包括一个用于处理用户操作的`AppState`对象，一个名为`CubeWorld`的类，它将存储地形数据，以及一个名为`CubeCell`的类，它将存储单个单元格的数据。此外，还有一个名为`CubeUtil`的类，它将帮助我们生成网格。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This is an advanced recipe that requires an understanding the generation of
    a basic terrain, which can be found earlier in the chapter, and the building blocks
    of meshes and how to create custom meshes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高级配方，需要理解基本地形生成，这可以在本章前面的部分找到，以及网格的构建块以及如何创建自定义网格。
- en: Before we begin, we will create a class called `CubeUtil` and populate it with
    some shaped data that we will need later. Since each of the cells is of a box
    shape, we can borrow some fields from the `Box` and `AbstractBox` classes and
    save some time in setting it up. Just copy the `GEOMETRY_INDICES_DATA`, `GEOMETRY_NORMALS_DATA`,
    and `GEOMETRY_TEXTURE_DATA` fields to the `CubeUtil` class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将创建一个名为`CubeUtil`的类，并填充一些我们稍后需要的数据。由于每个单元格都是箱形，我们可以从`Box`和`AbstractBox`类中借用一些字段，从而节省一些设置时间。只需将`GEOMETRY_INDICES_DATA`、`GEOMETRY_NORMALS_DATA`和`GEOMETRY_TEXTURE_DATA`字段复制到`CubeUtil`类中即可。
- en: At the bottom of the class, there is a method called `doUpdateGeometryVertices`
    that contains a float array. Copy this float array too and call its vertices.
    This array contains data for the 24 vertices needed to create a cube with normal.
    It in turn relies on references to eight original vertex positions. We can get
    these from the `AbstractBox` class and the `computeVertices` method. The `Vector3f`
    center referenced here can be replaced with `Vector3f.ZERO`. The `xExtent`, `yExtent`
    , and `zExtent` parameters can be replaced with `0.5f` to get a square box with
    `1f` sides.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的底部，有一个名为 `doUpdateGeometryVertices` 的方法，其中包含一个浮点数组。也要复制这个浮点数组并调用其顶点。这个数组包含创建具有法线的立方体所需的24个顶点的数据。它反过来依赖于对八个原始顶点位置的引用。我们可以从
    `AbstractBox` 类和 `computeVertices` 方法中获取这些信息。这里引用的 `Vector3f` 中心可以用 `Vector3f.ZERO`
    替换。`xExtent`、`yExtent` 和 `zExtent` 参数可以用 `0.5f` 替换以获得边长为 `1f` 的正方形盒子。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We start by creating the object that contains the cell data. This will have
    the following seven steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建包含单元格数据的对象。这将包括以下七个步骤：
- en: First, create a new class called `CubeCell`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `CubeCell` 的新类。
- en: It contains a `Mesh` field call `mesh`, an array of six Booleans called `neighbors`,
    and another Boolean called `refresh`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它包含一个名为 `mesh` 的 `Mesh` 字段，一个包含六个布尔值的数组 `neighbors`，以及一个名为 `refresh` 的布尔值。
- en: In addition, there is enum called `Type` where we can put names such as `Rock`,
    `Sand`, and `Grass`. Then, add a `Type` field called `type`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还有一个名为 `Type` 的枚举，我们可以在其中放置如 `Rock`、`Sand` 和 `Grass` 这样的名称。然后，添加一个名为 `type`
    的 `Type` 字段。
- en: Create a method called `hasNeighbor` that takes an integer parameter as an input
    and return the corresponding Boolean from the array.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `hasNeighbor` 的方法，它接受一个整数参数作为输入，并从数组中返回相应的布尔值。
- en: Then, add a method called `setNeighbor` that takes both an integer parameter
    called `direction` and a Boolean parameter called `neighbor` as the input. If
    the current Boolean at the position of the direction is not the same as that of
    the neighbor, store the neighbor at that location and set `refresh` to `true`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个名为 `setNeighbor` 的方法，它接受一个名为 `direction` 的整数参数和一个名为 `neighbor` 的布尔参数作为输入。如果当前位置的当前布尔值与邻居的布尔值不同，则在那个位置存储邻居并设置
    `refresh` 为 `true`。
- en: Add a method called `requestRefresh` that sets `refresh` to `true`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `requestRefresh` 的方法，将 `refresh` 设置为 `true`。
- en: 'For a mesh, add a `getMesh` method, and inside this, call a method called `CubeUtil.createMesh`
    if the mesh is null or refresh it if it is `true`. This will also set `refresh`
    to `false` as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于网格，添加一个 `getMesh` 方法，并在其中，如果网格为空，则调用 `CubeUtil.createMesh` 方法，如果它为 `true`，则刷新它。这将也将
    `refresh` 设置为 `false`，如下所示：
- en: '[PRE34]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s return to the `CubeUtil` class where we add some helper methods
    to generate the world. This section has the following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `CubeUtil` 类，在那里我们添加一些辅助方法来生成世界。本节有以下步骤：
- en: First, add a `createMesh` method that takes a `CubeCell` parameter as the input.
    This method will create a mesh for the cell, and here you'll use the data we set
    up in the *Getting Ready* section of this recipe.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个名为 `createMesh` 的方法，它接受一个 `CubeCell` 参数作为输入。这个方法将为单元格创建一个网格，在这里你将使用我们在本菜谱的
    *准备就绪* 部分中设置的数据。
- en: 'First of all, place the vertex data in the mesh with the following line of
    code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下代码行将顶点数据放置在网格中：
- en: '[PRE35]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add indices to the sides of the mesh that are exposed and check the neighbors
    to see which ones these are. Then, add six indices (for two triangles) for each
    mesh to a list using `GEOMETRY_INDICES_DATA`, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向网格暴露的边添加索引，并检查邻居以查看它们是哪些。然后，使用 `GEOMETRY_INDICES_DATA` 将每个网格的六个索引（对于两个三角形）添加到一个列表中，如下所示：
- en: '[PRE36]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To add these to the mesh, first convert them into an array. Then, set the array
    as the index buffer, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这些添加到网格中，首先将它们转换成一个数组。然后，将数组设置为索引缓冲区，如下所示：
- en: '[PRE37]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For texture coords and vertex normals, simply use the data we have already
    set up as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于纹理坐标和顶点法线，只需简单地使用我们已设置的数据，如下所示：
- en: '[PRE38]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, return the mesh to the calling method.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将网格返回到调用方法。
- en: 'Add one more method called `generateBlock` to the `CubeUtil` class and create
    a 3D array of `CubeCell` and return it. The principle for it is the same as the
    heightmap we created in the *Using noise to generate a terrain* recipe, except
    here we use three dimensions instead of two. The following code with generate
    a `CubeCell` class in a 3D pattern:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `CubeUtil` 类添加一个名为 `generateBlock` 的方法，并创建一个 `CubeCell` 的三维数组并返回它。它的原理与我们在
    *使用噪声生成地形* 菜谱中创建的高度图相同，只是这里我们使用三个维度而不是两个。以下代码将按三维模式生成 `CubeCell` 类：
- en: '[PRE39]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now look at how to tie these two classes together and start generating
    some cubes. This will be performed in the following steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看看如何将这些两个类结合起来并开始生成一些立方体。这将在以下步骤中执行：
- en: We turn our attention to the `CubeWorld` class that will hold the information
    about all our cubes. It has a `Node` field called `world`, an integer file called
    `batchSize`, and array of `Material` called `materials` and, for this example,
    a single `CubeCell[][][]` array called `terrainBlock`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将注意力转向将包含我们所有立方体信息的`CubeWorld`类。它有一个名为`world`的`Node`字段，一个名为`batchSize`的整数，一个名为`materials`的`Material`数组，以及在这个例子中，一个名为`terrainBlock`的单个`CubeCell[][][]`数组。
- en: After initializing the `worldNode` class in the constructor, create a public
    method called `generate`. Inside this, call `CubeUtil.generateBlock(4, batchSize)`
    and store it in `terrainBlock`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化`worldNode`类后，创建一个名为`generate`的公共方法。在这个方法内部，调用`CubeUtil.generateBlock(4,
    batchSize)`并将其存储在`terrainBlock`中。
- en: Then, call and create another method called `generateGeometry` that will put
    all the `CubeCell` classes together into a `Node` class.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用并创建另一个名为`generateGeometry`的方法，它将所有`CubeCell`类组合到一个`Node`类中。
- en: First, check whether the `worldNode` class already has a node with a given name.
    If it does, detach it. In either case, create a new `BatchNode` field with the
    same name we checked for.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查`worldNode`类是否已经有一个具有给定名称的节点。如果有，将其断开连接。在任何情况下，创建一个新的具有我们检查的相同名称的`BatchNode`字段。
- en: 'Now, parse through the whole of the `terrainBlock` array and all the locations
    where there is a `CubeCell` class; we will check 6 directions (either side of
    it). For each side, check whether there is a neighbor there; there will be one
    if the position is not null. In that case, call `setNeighbor` on the cell you''re
    checking for and supply the direction of the current as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，解析整个`terrainBlock`数组以及所有有`CubeCell`类的位置；我们将检查6个方向（它的每一侧）。对于每一侧，检查那里是否有邻居；如果位置不为null，将有一个邻居。在这种情况下，在您正在检查的单元格上调用`setNeighbor`并供应当前的方向如下：
- en: '[PRE40]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next step is to create geometries for the `CubeCell` instances. Do this
    by again parsing through the `terrainBlock` field, and where the corresponding
    `CubeCell` is not null, create a new `Geometry` class by calling the `CubeCell''sgetMesh''`
    method. Then, move it to the right position using `x`, `y`, and `z` that we''re
    iterating over, and apply a material and attach it to the batch node as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为`CubeCell`实例创建几何形状。通过再次解析`terrainBlock`字段来完成此操作，并在相应的`CubeCell`不为null的地方，通过调用`CubeCell'sgetMesh'`方法创建一个新的`Geometry`类。然后，使用我们正在迭代的`x`、`y`和`z`将其移动到正确的位置，并应用材质并将其附加到批处理节点，如下所示：
- en: '[PRE41]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, in the `generateGeometry` method, call `node.updateModelBound()` and
    `node.batch()` to optimize it before attaching it to `worldNode`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`generateGeometry`方法中，调用`node.updateModelBound()`和`node.batch()`来优化它，在将其附加到`worldNode`之前。
- en: The basic of the generation process is now in place, and you can create a new
    class called `CubeWorldAppState` that extends `AbstractAppState`. In this case,
    add a `CubeWorld` field called `cubeWorld`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成过程的基本现在已经到位，你可以创建一个新的类，称为`CubeWorldAppState`，它扩展了`AbstractAppState`。在这种情况下，添加一个名为`cubeWorld`的`CubeWorld`字段。
- en: Override the `initialize` method and declare a new `cubeWorld` instance.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`initialize`方法并声明一个新的`cubeWorld`实例。
- en: Then, load a new material based on the **Lighting** material's definition and
    supply it to `cubeWorld`. After this, call `cubeWorld` and generate and attach
    `worldNode` through its getter method.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据**照明**材质的定义加载一个新的材质并将其提供给`cubeWorld`。在此之后，通过其getter方法调用`cubeWorld`并生成和附加`worldNode`。
- en: Also, add a light to see anything since we're using the **Lighting** material.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加一个光源以便看到任何东西，因为我们正在使用**照明**材质。
- en: Now, create an application where we attach this `Appstate` instance and we should
    see our block of `CubeCell` in the world. It's static, however, and it's very
    common to want to change the world.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个应用程序，我们将附加这个`Appstate`实例，我们应该能在世界中看到我们的`CubeCell`块。然而，它是静态的，而且通常我们希望改变世界。
- en: 'Let''s see how we can add the functionality to pick up and place blocks. The
    following figure is of a resulting terrain block:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何添加拾取和放置块的功能。以下图是结果地形块：
- en: '![How to do it...](img/6478OS_03_08.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/6478OS_03_08.jpg)'
- en: Begin in `CubeWorldAppState` by implementing `ActionListener` to handle user
    input. Add a `CubeCell` field called `takenCube` to store a `CubeCell` field that
    has been picked up.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CubeWorldAppState`中开始实现`ActionListener`以处理用户输入。添加一个名为`takenCube`的`CubeCell`字段来存储已被拾取的`CubeCell`字段。
- en: 'Add mappings to `inputManager` to pick up and place a `CubeCell` field. Use
    the left and right mouse button as shown in the following lines of code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`inputManager`添加映射以拾取和放置`CubeCell`字段。使用如下代码所示的手势的左键和右键：
- en: '[PRE42]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Then, create a method called `modifyTerrain` that takes a Boolean called `pickupCube`
    as the input.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`modifyTerrain`的方法，该方法接受一个名为`pickupCube`的布尔值作为输入。
- en: To control what is picked up or aimed at, use a pattern that we have established
    in the *Firing in FPS* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and
    Game Controls"), *Cameras and Game Controls*. Use a ray that originates from the
    camera and moves toward the camera's direction.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要控制拾取或瞄准的内容，请使用我们在[第2章](ch02.html "第2章。相机和游戏控制")的*FPS中的射击*食谱中建立的图案，*相机和游戏控制*。使用从相机出发并朝向相机方向移动的射线。
- en: 'Now, collide it with the `worldnode` class of `cubeWorld`. If it collides with
    something and the distance is lower than two (or some other arbitrary number)
    and `pickupCube` is true, we will pick up a cube. Get the `worldTranslation` vector
    of the geometry that the ray has collided with. Then, call a method called `changeTerrain`
    in `cubeWorld`. We''ll create the method in a short while. Now, supply it with
    the coordinates of the geometry it collides with and the currently empty `takenCube`
    field as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将其与`cubeWorld`类的`worldnode`类相碰撞。如果它碰撞到了某个物体，并且距离小于两个（或某个其他任意数字），且`pickupCube`为真，我们将拾取一个立方体。获取射线碰撞到的几何体的`worldTranslation`向量。然后，在`cubeWorld`中调用一个名为`changeTerrain`的方法。我们将在稍后创建这个方法。现在，提供它碰撞到的几何体的坐标以及当前为空的`takenCube`字段，如下所示：
- en: '[PRE43]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If instead, there is no collision or the collision is too far away, and at
    the same time `pickupCube` is `false` and `takenCube` is not null, try to place
    `takenCube` in the world. Since we don''t have a collision point, move some way
    along the direction of the camera and round it off to the nearest integer. Then,
    call `cubeWorld.changeTerrain` again with the coordinates along with `takenCube`,
    as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有碰撞或碰撞太远，同时`pickupCube`为`false`且`takenCube`不为空，尝试在世界中放置`takenCube`。由于我们没有碰撞点，沿着相机方向移动一段距离，并将其四舍五入到最接近的整数。然后，再次调用`cubeWorld.changeTerrain`，并提供坐标以及`takenCube`，如下所示：
- en: '[PRE44]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the `onAction` method, add the logic for the corresponding key press and
    call `modifyTerrain`, supplying either `true` if we're picking up or `false` if
    we're instead trying to place a `CubeCell` field.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onAction`方法中，添加对应按键的逻辑并调用`modifyTerrain`，如果我们在拾取，则提供`true`；如果我们在尝试放置`CubeCell`字段，则提供`false`。
- en: In the `CubeWorld` class, create this `changeTerrain` method that takes a `Vector3f`
    parameter called `coords` and a `CubeCell` parameter called `blockToPlace` as
    the input. The `Coords` parameters represent the location of a `CubeCell` instance.
    The `changeTerrain` method returns a `CubeCell` instance.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CubeWorld`类中，创建这个`changeTerrain`方法，该方法接受一个名为`coords`的`Vector3f`参数和一个名为`blockToPlace`的`CubeCell`参数作为输入。`Coords`参数代表`CubeCell`实例的位置。`changeTerrain`方法返回一个`CubeCell`实例。
- en: The first thing we will do is define a `CubeCell` field called `changedBlock`
    where we store the incoming `blockToPlace`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将定义一个名为`changedBlock`的`CubeCell`字段，用于存储传入的`blockToPlace`。
- en: 'Then, do a check to make sure the supplied coordinate is within the bounds
    of the `terrainBlock` array and then check whether `changedBlock` is null. If
    it is, pick up the `CubeCell` instance from this location and populate `changedBlock`
    with the `CubeCell` instance. Then, set the location''s `CubeCell` to null as
    follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，检查提供的坐标是否在`terrainBlock`数组范围内，然后检查`changedBlock`是否为空。如果是，则从该位置拾取`CubeCell`实例，并将`changedBlock`用`CubeCell`实例填充。然后，将位置的`CubeCell`设置为空，如下所示：
- en: '[PRE45]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If instead the `CubeCell` instance at this location is null (we already know
    that `changedBlock` is not null), set the `CubeCell` instance over here to `changedBlock`
    and `changedBlock` to null. Also, call `requestRefresh` on the `CubeCell` instance
    to force it to update the mesh, as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在此位置的`CubeCell`实例为空（我们已知`changedBlock`不为空），则将此处的`CubeCell`实例设置为`changedBlock`并将`changedBlock`设置为空。同时，在`CubeCell`实例上调用`requestRefresh`以强制其更新网格，如下所示：
- en: '[PRE46]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, if there has been a change made, call `generateGeometry` and return
    `changedBlock` to the calling method.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果已经进行了更改，则调用`generateGeometry`并将`changedBlock`返回给调用方法。
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is mostly about creating meshes that are as optimized as possible.
    Cubes are great building blocks, but each has 12 triangles, and rendering them
    all for hundreds or thousands will quickly slow down most systems. In the first
    part of the recipe, we implemented functionalities to create meshes that only
    had the exposed sides of the cube's generated triangles. We found this out by
    checking which of the positions next to the cube were occupied by other cubes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱主要关于创建尽可能优化的网格。立方体是很好的构建块，但每个立方体有12个三角形，渲染数百或数千个立方体将迅速减慢大多数系统的速度。在菜谱的第一部分，我们实现了创建只包含立方体生成三角形暴露边的网格的功能。我们通过检查立方体旁边的哪些位置被其他立方体占据来发现这一点。
- en: Once all the cubes were generated, we added them to `BatchNode` and batched
    it to create one mesh for all the cubes. Even if the polygon count is the same,
    decreasing the number of objects greatly enhances the performance.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有立方体都生成，我们就将它们添加到`BatchNode`中，并将它们批量处理以创建一个包含所有立方体的网格。即使多边形数量相同，减少对象数量也会大大提高性能。
- en: Having a single mesh means we can't change a single object in the mesh without
    regenerating the whole batch. If we plan to scale this up and generate a whole
    world, we need to keep the size of the batch to a size where we can regenerate
    it without creating slowdowns. Exploring a way to generate it on a separate thread
    might be a good next step.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个网格，所以我们不能在不重新生成整个批次的情况下更改网格中的单个对象。如果我们计划将其扩展并生成整个世界，我们需要保持批次的大小，以便我们可以重新生成它而不会造成减速。探索在单独的线程上生成它的方法可能是一个好的下一步。
