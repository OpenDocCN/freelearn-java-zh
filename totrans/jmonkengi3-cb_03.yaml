- en: Chapter 3. World Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll go through some of the fundamentals behind generating
    a code-based world and its lighting before we go beyond the basics and discuss
    more advanced techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using noise to generate a terrain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting your world and providing it with dynamic lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deforming a terrain in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating trees' distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endless worlds and infinite space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flowing water with cellular automata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essentials of a cube-based world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. SDK Game Development Hub"), *SDK Game Development
    Hub*, we used Terrain Editor to manually create a heightmap and Scene Composer
    to put things together into scenes. Those were the two ways of creating worlds
    in jMonkeyEngine. In this chapter, we'll look into creating worlds using code
    or procedural generation. This can often be very quickly set up, but getting it
    right (and performant) can be tricky. To achieve this, we will make use of techniques
    such as custom meshes and batching. Batching is a method of taking several geometries
    using the same `Material` instance and creating one mesh out of all their meshes.
    This can significantly improve the performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using noise to generate a terrain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While noise is unwanted in many occasions, it is a great tool for procedural
    generation and has many uses. In this recipe, we'll explore jMonkeyEngine's `FractalSum`
    class and generate an image based on the output. This can be used as a heightmap
    for a terrain, but we are not limited by that. With some tweaking, we could get
    a basis to cover a forest or city.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using noise to generate a terrain](img/6478OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe relies on a way to output an image. Either use your own method to
    do this or refer to the *The ImageGenerator class* section in [Appendix](apa.html
    "Appendix A. Information Fragments"), *Information Fragments*, which provides
    an example of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate a heightmap, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a class called `NoiseMapGenerator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its constructor, define a new `FractalSum` instance and store it in a field
    called `fractalSum`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a public method called `generateNoiseMap` that takes an integer
    parameter called `size`, a float parameter called `frequency`, and an integer
    parameter called `octaves` as inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the method, configure `fractalSum` with some of the values and set the
    amplitude to `0.5f` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, define a 2D float array called `terrain`. Its dimension should be [size]
    x [size].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a double `for` loop statement and parse through the size of both
    dimensions. Inside the loop, we get the value from `fractalSum`, which is based
    on your *x* and *y* coordinates; add `0.5f` to the value. Clamp it to get a value
    between `0f` and `1f` and set the value in the terrain array as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you''re done, call the `ImageGenerator` class to create the PNG image
    for us as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this simple implementation, and by using the supplied `ImageGenerator`
    class, we have the basics for a heightmap. We can see the result in our `Projects`
    folder under `assets/Textures/heightmap.png`. It's an image that shifts smoothly
    between bright and dark areas; here, bright areas represent a high terrain and
    dark areas, a low terrain. Bright pixels have values that are close to 1, whereas
    dark pixels have values close to 0\. Normally, noise outputs values between -1
    and 1\. This is why we change the amplitude to 0.5f so that it yields a range
    between -0.5 and 0.5, and then we add 0.5 to the result.
  prefs: []
  type: TYPE_NORMAL
- en: A noticeable problem is that no matter how much we change the speed and frequency
    of the noise, the same kind of rolling hills landscape will appear, only in different
    scales. By changing the octaves' value, we will generate noise in several iterations
    with decreasing amplitude. The value of each pixel for each iteration is multiplied
    with the previous one. The result is called fractal noise. Using octaves is a
    way of adding detail by iterating over the result with different frequencies.
    For each iteration, the frequency is doubled and the amplitude is halved.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency can be thought of as a scale value where a higher frequency will generate
    more and smaller features. Having a higher frequency on its own will make peaks
    and valleys occur more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: A normalization process is not strictly needed for a heightmap, unless we want
    to save it as an image. Also, if we were generating a large number of heightmaps
    (for example, during the runtime for a game), we would not want to normalize the
    terrain based on a particular heightmap's minimum and maximum values or we would
    end up with very similar and hilly landscapes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have generated a heightmap and exported it to an image, we can actually
    use it as a base in Terrain Editor. The process is similar to the one where we
    created a terrain for our scene in [Chapter 1](ch01.html "Chapter 1. SDK Game
    Development Hub"), *SDK Game Development Hub*.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a new scene (by all means, we can use an existing scene as well)
    and opening it, we can right-click on the main node in the **SceneExplorer** window
    and select **Add Spatial..** and then select **Terrain..**.
  prefs: []
  type: TYPE_NORMAL
- en: It's important that we select the same total size as that of the pixels of our
    image. Then, in the **Heightmap** screen, we choose **Image Based** from the **HeightMap**
    drop-down menu and select our image.
  prefs: []
  type: TYPE_NORMAL
- en: The **Roughness** slider will define how much the heightmap will be smoothed
    out before it is added. A higher smoothness will remove finer details, and this
    is a must if we want to have characters that will run or drive on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: The **Height Scale** option will define the maximum altitude that the heightmap
    can have and scale it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting your world and providing it with dynamic lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will mostly be theories on different lighting types, but we'll also
    explore a way to easily control the movement of lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four main types of lights that we can use to light up our world are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ambient Light**: This lights up everything in the scene evenly. It''s good
    for avoiding anything to be in a pitch-black state, but it doesn''t create any
    shadows or nuances. Adding a too bright ambient light will give the world a bland
    look, while giving it a touch of color can set the mood.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directional Light**: This shines from a particular direction with perfectly
    parallel rays and without any falloff. This is usually used to simulate a sun,
    a bright source of light located far away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point Light**: This shines equally in every direction but with a falloff,
    meaning this will eventually stop illuminating the surroundings. Usually, this
    forms most of the light sources in a game scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spot Light**: This is exactly as it sounds. This produces a cone-shaped light
    in a specific direction from a specific location, and its light will eventually
    fall off. It has more settings than its sibling light types. Technically, it is
    more advanced than point lights and requires additional calculations in the shader
    to see what it illuminates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A spotlight with the same `spotInnerAngle` and `spotOuterAngle` parameters
    will have a light cone that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting your world and providing it with dynamic lights](img/6478OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `spotInnerAngle` and `spotOuterAngle` parameters define the size of the
    light cone that spotlight produces and both are set in radians. The `spotInnerAngle`
    parameter defines how far out the cone will shine at its maximum radiance. The
    `spotOuterAngle` parameter then defines how far the total extent of the radiance
    should be before it''s been completely extinguished. Having a greater value for
    the `spotOuterAngle` parameter will produce a softer edge on the spotlight. A
    spotlight with a small `spotInnerAngle` parameter and a high `spotOuterAngle`
    parameter will have softer edges, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting your world and providing it with dynamic lights](img/6478OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To ensure an object is affected by the lights in a scene, it must have a `Material`
    class that supports it. For most game objects, the default choice is the **Lighting**
    material. It supports a variety of lighting types from per pixel to lightmaps
    and vertex lighting. The latter two are optional but have their uses.
  prefs: []
  type: TYPE_NORMAL
- en: A lightmap is essentially an extra texture where lighting has been pre-rendered.
    Its resolution can rarely match real-time lighting, but from another perspective,
    it is very fast since lighting doesn't have to be calculated at runtime; also,
    it can be used for static scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, lighting is calculated on a per-pixel basis. This means that for each
    pixel visible on the screen, the processor has to calculate how it is affected
    by the available light sources. It is fairly expensive and even more so with many
    light sources, but it produces a more realistic result. Vertex lighting instead
    means that lighting is calculated for each vertex on a model. For low poly models,
    this is much faster although not as detailed. The quality will suffer noticeably
    when it is near the object, but it can give good enough results for objects some
    distance away.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the basics covered, let''s explore a pattern that allows us
    to move lights using objects in the scene graph:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new `PointLight` class called `pointLight` and set `radius`
    to `40`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, call `rootNode.addLight(pointLight)` to add it to the scene graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a new `CameraNode` called `camNode` and then call `camNode.setControlDir(CameraControl.ControlDirection.CameraToSpatial);`
    before attaching it to the `rootNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a new `LightControl` called `lightControl`, supplying `pointLight`
    to it to indicate that this is the light to control, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set `controlDir` to be `LightControl.ControlDirection.SpatialToLight`. This
    means that the Spatial `camNode` will control the light''s position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we add `lightControl` to `camNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test this out, we can load **Sponza** (Models/Sponza/Sponza.j3o) from the
    jMonkeyEngine's `test-data` library and apply the **Lighting** material to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lights are not `Spatials` in the scene graph, and it can be tricky to move them
    around. It can be added to nodes but then it will only illuminate the node (and
    its children) that it is added to. The `LightControl` class bridges the gap since
    it can be added as a control to `Spatial`, and it controls the position (and direction
    of a light). In this recipe, we used it so that the light will follow the camera
    around using a `CamNode`, but it works just as well for any other `spatial`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We touched on **Ambient Light** and **Directional Light** in the *Adding a sky
    box and lighting* recipe from [Chapter 1](ch01.html "Chapter 1. SDK Game Development
    Hub"), *SDK Game Development Hub*. In the *Creating a dynamic sky box with a moving
    sun* recipe from [Chapter 9](ch09.html "Chapter 9. Taking Our Game to the Next
    Level"), *Taking Our Game to the Next Level*, we create **Directional Light**
    to simulate a day and night cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Deforming a terrain in real time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A deformable terrain is something that can have a serious effect on the gameplay,
    or it can simply be a cosmetic bonus. It can be used for impact craters or games
    that require excavation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll base the deformation around the `Control` class pattern as this allows
    us to offset the code in a manageable and reusable way. The recipe will trigger
    the deformation based on a mouse click, and it will use a ray to detect the collision
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get up and running quickly, unless there already is an application to apply
    this to, `TestTerrain.java` from the jMonkeyEngine's test cases will provide a
    good start for what we need. This example will expand on the code provided in
    that application, but it should work perfectly well with any terrain-based application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a base application already set up, we can get straight to the creation
    of the Control pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `DeformableControl` that extends `AbstractControl`.
    It needs one private terrain field called `terrain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `setSpatial` method and cast `Spatial` to fit your terrain field;
    use `terrain = (Terrain) spatial;` to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method called `deform` that takes the 2D location, the radius of the
    deformation, and the force as an input. Also, declare two lists that we''ll use
    in the `heightPoints` and `heightValues` methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we should create a nested `for` loop statement where we can iterate from
    `-radius` to `+radius` in both `x` and `y` (`z` to be correct). See how far from
    the center the point is and calculate the height to change at that location. The
    decrease of the force of the impact will be proportional to how far out it is
    from the center. Then, save the point in the `heightPoints` list and the new height
    in the `heightValues` list as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To wrap up the method, we need to apply the new heights. First, unlock the
    terrain and then lock it again as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we normally work with 3D vectors rather than 2D vectors, it can be a
    good idea to also create a convenience method called `deform`, which takes `Vector3f`
    as the input. It converts this input to `Vector2f` and in turn calls the other
    deform method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, trigger the deformation from a method in our application. Firstly, it
    should create a new `ray` instance that originates from the camera, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new `CollisionsResults` object and check whether the ray intersects
    the terrain. If there is a collision, call `deform` on the terrain''s `DeformableControl`
    object by supplying the `contactPoint` parameter of the collision as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When deforming the terrain, we collect all the points we want to modify and
    the new heights in lists; then, we collectively update the terrain based on them.
    There is an `adjustHeight` method to update a single point as well, but it is
    assumed that it's faster using a list.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the terrain means faster rendering. Whether to lock the terrain or not
    depends on the implementation. If it is a terrain that is changed with every frame,
    it probably doesn't need to be locked. On the other hand, if it changes only occasionally,
    it should probably be locked.
  prefs: []
  type: TYPE_NORMAL
- en: The formula that is used to calculate the change in height is *deltaHeight =
    force * (1 - distance / radius)*. This means that the change in height will be
    highest when it is closest to the center; it will then fall off linearly as the
    distance increases and we get closer to the edge of the radius. A variation worth
    exploring is to use the root with *deltaHeight = force * FastMath.sqrt(1 - distance
    / radius)* instead. This will provide a rounder shape to the terrain.
  prefs: []
  type: TYPE_NORMAL
- en: Automating trees' distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Placing trees and bushes in an editor is fine for many types of games. There
    are many cases where you need objects to be in a very specific spot. When it comes
    to large-scale outdoor games, you might want to have a way of placing common objects
    in an automatic way, at least as a base. An artist or designer might then move
    items around to suit the needs of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create one such way that places trees using noise. Once
    the base is in, we'll take a look at how the pattern can be varied with different
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To produce automatic trees'' distribution, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We get right to the center of the things. Create a new class called `TreeControl`
    that extends `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `TerrainQuad` field called `terrain`, a `FractalSum` field called `fractalSum`,
    a `Spatial` field called `treeModel`, and a `BatchNode` field called `treeNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `setSpatial` method. Here, we declare `treeNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, assuming that the supplied `Spatial` is a `Node` class, parse its children
    looking for a `Spatial` that is an instance of `TerrainQuad`. Once found, set
    it to `terrain` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using terrain's `terrainSize`, create a nested `for` loop statement that parses
    from its negative height and width to its positive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this loop, grab a value from the `fractalSum` class based on the *x*
    and *y* coordinates. Then, look for the corresponding terrain height at that location
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to decide how many trees we want. The `FractalSum` class generates
    a value between -1 and 1\. Start by saying that any value above 0.5 should generate
    a tree and create an `if` statement accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If this is fulfilled, start by cloning `treeModel`. Set its `localTranslation`
    to the *x* and *y* coordinates and the current `terrainHeight` field before attaching
    it to the `treeNode` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After parsing the whole terrain, tell the `treeNode` field to batch its contents
    to optimize the performance and then attach it to the supplied `Spatial`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create an application class to test this. It's recommended that you use
    a test case such as `TestTerrainAdvanced` to get a start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Node` class called `worldNode`, which we attach to `rootNode`
    and then attach the terrain to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a new `TreeControl` class and load and set a suitable model that
    we can use as `treeModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add the `TreeControl` class to `worldNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After running the application, we will see trees spread out across the terrain—in
    valleys as well as on top of the mountains. Depending on the environment, trees
    might not grow on mountains. If we don't want this, we can add a simple check
    in the `TreeControl` class. By adding a field called `treeLimit`, we can clamp
    the growth of the tree above a certain height; also, make sure the `terrainHeight`
    field is lower than the value supplied from `fractalSum`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we let the noise do most of the work for us. All we did was
    parse through the terrain, and at regular intervals, check whether the noise value
    at that point indicated whether a tree should be placed.
  prefs: []
  type: TYPE_NORMAL
- en: The noise provides an almost endless amount of variation to our distribution
    of vegetation and an equally endless amount of tweaking possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of using these automatic generation techniques is that we don't
    have proper control over them, and changing a value ever so slightly might have
    a large impact on the terrain. Also, even if the generation process is cheap and
    can be repeated deterministically, we will have to start storing the data as soon
    as we want to modify it in any way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the current settings, the example distributes trees across a landscape
    in a seemingly random pattern. At first glance, it might look natural but trees
    rarely are so evenly distributed as this. Outside of a forest, you will usually
    find trees clumped together. We can easily achieve this with noise by changing
    the frequency. The following examples show how changing the frequency can change
    the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: A frequency of 0.5 produces a very noisy and fairly uniform pattern, as shown
    in the following screenshot:![There's more...](img/6478OS_03_04.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a frequency of 0.1, we can distinguish different patterns as follows:![There's
    more...](img/6478OS_03_05.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A frequency of 0.02 yields even less but larger clumps of vegetation as follows:![There's
    more...](img/6478OS_03_06.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endless worlds and infinite space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's really no such thing as endless or infinite in computer-generated worlds.
    Sooner or later, you're going to hit one limit or the other. However, there are
    some techniques that will get you further than others. The normal approach when
    creating a game is to move the player around the game world. Those who have tried
    to, for example, make a space exploration game in this way have noticed that pretty
    soon problems with regards to float numbers appear. This is because float values
    are not evenly spaced. As their values increase, their precision decreases. Using
    doubles rather than floats will only delay what's inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: If you can't even have a solar system as a human-scaled game world, how can
    you then have a whole galaxy? As an old saying goes, "If Mohammed won't come to
    the mountain, the mountain must come to Mohammed." That is exactly the solution
    to our first problem! By making the game world move around the player, we ensure
    that the precision remains high. This is great for large-scale game worlds. The
    drawback is that it requires a different architecture. Switching how the game
    world is generated or loaded during the mid-development stage can be a huge task.
    It's better to decide this during the design phase.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is the sheer size of the worlds. You can't simply store all
    the terrain-based game world of a decent size in the memory at once. We can solve
    this problem by loading world data on demand and throwing it away when we don't
    need it any more. This recipe will use a simple method to generate the world on
    demand, but the principle can be applied to other methods, such as generating
    a heightmap or loading the world from a storage device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dynamic world loading can be created with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `EndlessWorldControl`. It should extend `AbstractControl`
    and implement `ActionListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add a couple of fields to it as well. First of all, we need to keep
    track of the application's camera and store it in a parameter called `cam`. The
    class also requires a `Geometry` parameter called `currentTile` to represent the
    currently centered game area. A `Material` parameter called `material` will be
    used on the geometries and a `HashMap<Vector2f, Geometry>` parameter called `cachedTiled`
    will store the entire currently active game world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class implements `ActionListener` and will handle movements based on user
    input. To do this, add four Booleans as well: `moveForward`, `moveBackward`, `moveLeft`,
    and `moveRight`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onAction` method, add the following code to set the Booleans based
    on the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `controlUpdate` method, move the tiles based on the direction of the
    camera and the Booleans you just created. First, get the current forward direction
    of the camera and the direction which is to the left of it. Then, multiply it
    by `tpf` to get an even movement and an arbitrary value to increase the speed
    of the movement as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using this, call a method called `moveTiles` if any movement should occur as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `moveTiles` method that takes a `Vector3f` object called `amount`
    as the input. First, parse through the values of the `cachedTiles` map and apply
    the amount value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create an `Iterator` object and iterate through `cachedTiles` again;
    stop if any of the tiles contain `Vector3f.ZERO`, which is the location of the
    camera. This is our new `currentTile` object. This can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The location of this tile will be used to decide which other tiles should be
    loaded. Pass this to two new methods: `updateTiles` and `deleteTiles`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we take a look at the `updateTiles` method. It takes a `Vector2f` parameter
    called `newLocation` as the input. Create a nested `for` loop that goes from `x-1`
    and `y-1` to `x+1` and `y+1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check whether `cachedTiles` already has the tile with `newLocation` and `x`
    and `y` combined. If it doesn''t, we create a new tile and apply `BoundingBox`
    of the same size as the tile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set location to be the delta distance from `newLocation`. If `currentTile`
    is not null, we add its `localTranslation` too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, attach `g` to the control's spatial and put `g` in the `cachedTiles`
    map with `wantedLocation` as the key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, for the `deleteTiles` method, it also takes a `Vector2f` parameter called
    `newLocation` as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Like the `updateTiles` method, iterate through the `cachedTiles` map. Look
    for those tiles that are now more than two tiles away in either direction and
    add their location to a list called `tilesToDelete`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you're done, simply parse through the `tilesToDelete` list, remove the
    tile from `cachedTiles`, and detach it from `Spatial`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one more thing we need to do before leaving the class. In the `setSpatial`
    method, we should add a call to `updateTiles`, supplying `Vector2f.ZERO` to it
    to initialize the generation of the tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a larger implementation, we might want to introduce an `AppState` instance
    to handle this, but here we will manage it with a test application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First of all, we need to disable `flyCam` with `flyCam.setEnabled(false)` and
    possibly move the camera to some distance from the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a `Node` class called `worldNode` and an `EndlessWorldControl`
    instance called `worldControl`. Attach `worldNode` to `rootNode` and supply the
    `worldControl` object with a material before adding it to `worldNode` and setting
    the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, set up some keys to control the movement and add the `worldControl`
    object as a listener; refer to the following code on how to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process that we follow is that if a movement occurs, the `moveTiles` method
    will first move all the tiles to `cachedTiles`. It then checks to see whether
    there's a new tile that should be the center or whether it should be `currentTile`.
    If this happens, other tiles must be checked to see which ones should be kept
    and which ones need to be generated. This happens in the `updateTiles` method.
    Last in the chain is the `deleteTiles` method that checks which tiles should be
    removed because they are too far away.
  prefs: []
  type: TYPE_NORMAL
- en: If we print out the translation of the tiles, we can see that they are never
    very far from the center of their parent node. This happens because when we generate
    the tiles, we place them relative to `currentTile`. Since `currentTile` is also
    based on a relative position, things never move very far. It's almost like a conveyor
    belt.
  prefs: []
  type: TYPE_NORMAL
- en: Flowing water with cellular automata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cellular automata is an n-dimensional set of cells that interact together with
    a given set of rules. Over time, these interactions have given way to patterns,
    and modifying the rules will modify the pattern. The most famous example is probably
    Conway's Game of Life where cells based on an extremely simple rule set create
    the most amazing, evolving patterns. In games, cellular automata is usually found
    simulating liquids in a tile– or block–based game worlds.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll explore such a liquid system based on a 2D grid. Since
    it's 2D, there can be no true waterfalls, but it can still be applied to a heightmap
    (which we'll show) to create natural-looking rivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance becomes an issue with large cellular automata, which will become
    evident as they''re scaled up. To counter this, we''ll also look at a couple of
    different techniques to keep the resource consumption down. The following image
    shows water running down the slope of a mountain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flowing water with cellular automata](img/6478OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires height differences to make it interesting. A heightmap
    will work very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model we''ll develop will evolve around cells that are defined by two parameters:
    the height of the ground it resides on and the amount of water in it. If the height
    and amount of water combined are higher than a neighboring cell, water will pour
    out of it and into its neighbor. To make sure the cells are updated simultaneously,
    all of the water pouring into a cell will be stored in a separate field and applied
    at the end of the update cycle. This ensures that water can only move one tile
    through the field in one update. Otherwise, the same unit of water might travel
    across the whole grid in one update as we loop through the tiles.'
  prefs: []
  type: TYPE_NORMAL
- en: The example mentions a `CellUtil` class. The code for this can be found in the
    *The CellUtil class* section in [Appendix](apa.html "Appendix A. Information Fragments"),
    Information Fragments.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will produce flowing water:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let us create a class that contains the cell logic. We can call
    it `WaterCell`. It needs a float field called `amount`, another float field called
    `terrainHeight`, and one integer field for the current direction of the flow.
    It should also store any incoming water in a float field called `incomingAmount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to the normal getter and setter for `amount`, add a method called
    `adjustAmount` that takes a float variable called `delta` as the input. The `delta`
    variable should be added to `amount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `compareCells` that will move the water between cells.
    It takes another cell (where the water is coming from) as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing the method does is checks the difference in height between
    the two cells as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method will only move the water in one way: from the supplied cell to this
    cell so it will only act if the difference is positive (and higher than an arbitrary
    small amount).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If so, it takes half of the difference since this would even out the amount
    between the two cells. Before applying it, make sure we don''t move more water
    than there already is in the originating cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the calculated result to the `incomingAmount` field (we don't update the
    amount for this until everything has been calculated).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, we must deduct the same amount from the originating cell or there
    would be a never-ending supply of water. It''s done like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, return the deducted amount from this method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can leave this class for now and focus on creating a control that will use
    this class. Create a new class called `WaterFieldControl` that extends `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It needs two integer fields to control the width and height of the field as
    well as a 2D array of `WaterCell` called `waterField`. To display it, we'll add
    a `Node` class called `water` and a `Material` class called `material`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `setSpatial` method should be overridden and the `spatial` variable passed
    has to be an instance of `Node`. Look for a terrain among its children; once found,
    populate `waterField` with `WaterCells`, applying the height of the terrain for
    each tile as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create a new method called `updateCells`. For this example, define a source
    of water that will never run out right from the beginning by setting the amount
    of water in one of the middle tiles as 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, parse through each cell in the `waterField` array in a nested `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the cell has an amount that is larger than 0, we can go on and check where
    we should start moving the water. Start with the cell''s direction, and if there
    is water left after checking one direction, continue to look through the other
    seven directions. This is what the implementation might look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each of these directions, we must first check that it is a valid location
    within the field. Then, retrieve the neighboring cell and call `compareCells`
    to try to dump water in it. If this try is successful, set the direction of the
    `neighborCell` object to the tested direction to represent the flow of water,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before you exit the method, parse through the `waterField` array once again.
    This time add `incomingWater` to the current amount of the cell and then set `incomingWater`
    to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To handle the display of the result, create a new method called `createGeometry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we need to do is check whether the `Spatial` of the control
    has a child called **Water**. If it does, detach it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, define a new `Node` class called `water`. Its name should be `Water`
    as this is an identifier in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, parse the `waterField` array. If any cell's amount is more than 0, you
    should add a `Geometry` object that represents it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to add some logic to the `getGeometry` method to avoid recreating
    the `Geometry` field unnecessarily. First of all, set `geometry` to `null` if
    the `amount` value is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, if `geometry` is null, create a new `geometry` instance with a box-like
    shape as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To adapt it to the amount of water we have, scale the resulting cube by typing
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, return the `geometry` field, which might be null.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Coming back to the `WaterFieldControl` class, if the returned `geometry` variable
    is not null, set its location and attach it to the `water` node as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the material to the `water` node and then batch it to increase the performance
    before attaching it to the control''s `spatial`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To finish things off, update the `controlUpdate` method to call `updateCells`
    and `createGeometry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now this can be used with a few lines in the application class. First of all,
    create a new `WaterFieldControl` class that we'll add to a `Node` class that contains
    a `Terrain` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create the material for the water. This can be as simple as
    creating a `Material` instance with `Unshaded` `MaterialDefinition` and applying
    a blueish color to it or an advanced custom shader. It is then applied to the
    `WaterFieldControl` class via the `setMaterial` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of cellular automata is the simplicity with which they work. Each
    cell has a very basic set of rules. In this example, each cell wants to even out
    the water level with a neighboring cell. As we go through iteration, the water
    moves downhill.
  prefs: []
  type: TYPE_NORMAL
- en: It's usually fairly easy to get the automation up and running, but it can take
    a while to get everything right. For example, even if each cell's amount is updated
    correctly, we will get weird oscillating water effects if the flow's direction
    doesn't work correctly. The reason is that there would be a preferred direction
    the water will take in a new cell. This direction might be the opposite of where
    it came from, making it want to move back to the cell it came from. Picking a
    random direction might work in that case, but it makes it more difficult to predict
    the behavior. This is why we use the direction of the water in the cell it came
    from. Naturally, the water will have some momentum and will continue to flow until
    it is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that can be tricky to grasp at first is the reason why we don't update
    the water amount directly. The reason is that if water moves from cell x to cell
    x+1, that water would instantly become available for x+1 once the `update` method
    reaches there; also, it could be moved to x+2 and so on. We can't think of the
    water as real time, and that's why we first perform an outgoing operation on all
    the cells before we apply the incoming water. We also don't change the amount
    in the cell we're currently checking for the same reason. Instead, we move any
    water left in a cell to the `incomingWater` field.
  prefs: []
  type: TYPE_NORMAL
- en: The main challenge with the method is usually related to performance. Calculating
    can be expensive and rendering even more so. With a system like this, it's ever-changing
    and we might be forced to recreate the mesh in every frame. Rendering each cell
    on its own quickly becomes impossible, and we must use batching to create a single
    mesh. Even this is not enough, and in this example, we store the cell's `geometry`
    field so we don't have to recreate it unless the water level is 0 in a cell. We
    also scale the cell's `geometry` field if the water level changes as this is much
    quicker than creating a new `Mesh` class for it. The drawback is the additional
    memory that is used by storing it.
  prefs: []
  type: TYPE_NORMAL
- en: We also made it optional to update the water in every frame. By lowering it
    to a set amount of updates every second (in practice, its own frame rate), we
    could severely lessen the impact of the performance. This could also be taken
    further by only updating parts of the water field with every update, but efforts
    must be taken to conserve the amount of the water. We could also separate the
    field into smaller batches and check whether any of these need to be reconstructed.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to take this example further for those who wish. One could play
    around with the amount of water that each cell shares. This will make it more
    expensive to calculate but might give a smoother result. It's also possible to
    add pressure as a parameter, making it possible for water to move up the slopes.
    Evaporation might be a way to remove water from the system and clean up any puddles
    left by the main flow.
  prefs: []
  type: TYPE_NORMAL
- en: The essentials of a cube-based world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll build a small framework to generate optimized cube meshes,
    which can be used to create large-scale worlds. This framework will consist of
    an `AppState` object to handle user actions, a class called `CubeWorld` that will
    store the terrain data, and a class called `CubeCell` that will store the data
    for individual cells. In addition, there is a `CubeUtil` class that will help
    us to generate meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an advanced recipe that requires an understanding the generation of
    a basic terrain, which can be found earlier in the chapter, and the building blocks
    of meshes and how to create custom meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, we will create a class called `CubeUtil` and populate it with
    some shaped data that we will need later. Since each of the cells is of a box
    shape, we can borrow some fields from the `Box` and `AbstractBox` classes and
    save some time in setting it up. Just copy the `GEOMETRY_INDICES_DATA`, `GEOMETRY_NORMALS_DATA`,
    and `GEOMETRY_TEXTURE_DATA` fields to the `CubeUtil` class.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the class, there is a method called `doUpdateGeometryVertices`
    that contains a float array. Copy this float array too and call its vertices.
    This array contains data for the 24 vertices needed to create a cube with normal.
    It in turn relies on references to eight original vertex positions. We can get
    these from the `AbstractBox` class and the `computeVertices` method. The `Vector3f`
    center referenced here can be replaced with `Vector3f.ZERO`. The `xExtent`, `yExtent`
    , and `zExtent` parameters can be replaced with `0.5f` to get a square box with
    `1f` sides.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating the object that contains the cell data. This will have
    the following seven steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new class called `CubeCell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It contains a `Mesh` field call `mesh`, an array of six Booleans called `neighbors`,
    and another Boolean called `refresh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, there is enum called `Type` where we can put names such as `Rock`,
    `Sand`, and `Grass`. Then, add a `Type` field called `type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `hasNeighbor` that takes an integer parameter as an input
    and return the corresponding Boolean from the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, add a method called `setNeighbor` that takes both an integer parameter
    called `direction` and a Boolean parameter called `neighbor` as the input. If
    the current Boolean at the position of the direction is not the same as that of
    the neighbor, store the neighbor at that location and set `refresh` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method called `requestRefresh` that sets `refresh` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a mesh, add a `getMesh` method, and inside this, call a method called `CubeUtil.createMesh`
    if the mesh is null or refresh it if it is `true`. This will also set `refresh`
    to `false` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s return to the `CubeUtil` class where we add some helper methods
    to generate the world. This section has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, add a `createMesh` method that takes a `CubeCell` parameter as the input.
    This method will create a mesh for the cell, and here you'll use the data we set
    up in the *Getting Ready* section of this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First of all, place the vertex data in the mesh with the following line of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add indices to the sides of the mesh that are exposed and check the neighbors
    to see which ones these are. Then, add six indices (for two triangles) for each
    mesh to a list using `GEOMETRY_INDICES_DATA`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add these to the mesh, first convert them into an array. Then, set the array
    as the index buffer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For texture coords and vertex normals, simply use the data we have already
    set up as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, return the mesh to the calling method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add one more method called `generateBlock` to the `CubeUtil` class and create
    a 3D array of `CubeCell` and return it. The principle for it is the same as the
    heightmap we created in the *Using noise to generate a terrain* recipe, except
    here we use three dimensions instead of two. The following code with generate
    a `CubeCell` class in a 3D pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now look at how to tie these two classes together and start generating
    some cubes. This will be performed in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We turn our attention to the `CubeWorld` class that will hold the information
    about all our cubes. It has a `Node` field called `world`, an integer file called
    `batchSize`, and array of `Material` called `materials` and, for this example,
    a single `CubeCell[][][]` array called `terrainBlock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After initializing the `worldNode` class in the constructor, create a public
    method called `generate`. Inside this, call `CubeUtil.generateBlock(4, batchSize)`
    and store it in `terrainBlock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, call and create another method called `generateGeometry` that will put
    all the `CubeCell` classes together into a `Node` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, check whether the `worldNode` class already has a node with a given name.
    If it does, detach it. In either case, create a new `BatchNode` field with the
    same name we checked for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, parse through the whole of the `terrainBlock` array and all the locations
    where there is a `CubeCell` class; we will check 6 directions (either side of
    it). For each side, check whether there is a neighbor there; there will be one
    if the position is not null. In that case, call `setNeighbor` on the cell you''re
    checking for and supply the direction of the current as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create geometries for the `CubeCell` instances. Do this
    by again parsing through the `terrainBlock` field, and where the corresponding
    `CubeCell` is not null, create a new `Geometry` class by calling the `CubeCell''sgetMesh''`
    method. Then, move it to the right position using `x`, `y`, and `z` that we''re
    iterating over, and apply a material and attach it to the batch node as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, in the `generateGeometry` method, call `node.updateModelBound()` and
    `node.batch()` to optimize it before attaching it to `worldNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The basic of the generation process is now in place, and you can create a new
    class called `CubeWorldAppState` that extends `AbstractAppState`. In this case,
    add a `CubeWorld` field called `cubeWorld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `initialize` method and declare a new `cubeWorld` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, load a new material based on the **Lighting** material's definition and
    supply it to `cubeWorld`. After this, call `cubeWorld` and generate and attach
    `worldNode` through its getter method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, add a light to see anything since we're using the **Lighting** material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create an application where we attach this `Appstate` instance and we should
    see our block of `CubeCell` in the world. It's static, however, and it's very
    common to want to change the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how we can add the functionality to pick up and place blocks. The
    following figure is of a resulting terrain block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Begin in `CubeWorldAppState` by implementing `ActionListener` to handle user
    input. Add a `CubeCell` field called `takenCube` to store a `CubeCell` field that
    has been picked up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add mappings to `inputManager` to pick up and place a `CubeCell` field. Use
    the left and right mouse button as shown in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, create a method called `modifyTerrain` that takes a Boolean called `pickupCube`
    as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To control what is picked up or aimed at, use a pattern that we have established
    in the *Firing in FPS* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and
    Game Controls"), *Cameras and Game Controls*. Use a ray that originates from the
    camera and moves toward the camera's direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, collide it with the `worldnode` class of `cubeWorld`. If it collides with
    something and the distance is lower than two (or some other arbitrary number)
    and `pickupCube` is true, we will pick up a cube. Get the `worldTranslation` vector
    of the geometry that the ray has collided with. Then, call a method called `changeTerrain`
    in `cubeWorld`. We''ll create the method in a short while. Now, supply it with
    the coordinates of the geometry it collides with and the currently empty `takenCube`
    field as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If instead, there is no collision or the collision is too far away, and at
    the same time `pickupCube` is `false` and `takenCube` is not null, try to place
    `takenCube` in the world. Since we don''t have a collision point, move some way
    along the direction of the camera and round it off to the nearest integer. Then,
    call `cubeWorld.changeTerrain` again with the coordinates along with `takenCube`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `onAction` method, add the logic for the corresponding key press and
    call `modifyTerrain`, supplying either `true` if we're picking up or `false` if
    we're instead trying to place a `CubeCell` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `CubeWorld` class, create this `changeTerrain` method that takes a `Vector3f`
    parameter called `coords` and a `CubeCell` parameter called `blockToPlace` as
    the input. The `Coords` parameters represent the location of a `CubeCell` instance.
    The `changeTerrain` method returns a `CubeCell` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we will do is define a `CubeCell` field called `changedBlock`
    where we store the incoming `blockToPlace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, do a check to make sure the supplied coordinate is within the bounds
    of the `terrainBlock` array and then check whether `changedBlock` is null. If
    it is, pick up the `CubeCell` instance from this location and populate `changedBlock`
    with the `CubeCell` instance. Then, set the location''s `CubeCell` to null as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If instead the `CubeCell` instance at this location is null (we already know
    that `changedBlock` is not null), set the `CubeCell` instance over here to `changedBlock`
    and `changedBlock` to null. Also, call `requestRefresh` on the `CubeCell` instance
    to force it to update the mesh, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, if there has been a change made, call `generateGeometry` and return
    `changedBlock` to the calling method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is mostly about creating meshes that are as optimized as possible.
    Cubes are great building blocks, but each has 12 triangles, and rendering them
    all for hundreds or thousands will quickly slow down most systems. In the first
    part of the recipe, we implemented functionalities to create meshes that only
    had the exposed sides of the cube's generated triangles. We found this out by
    checking which of the positions next to the cube were occupied by other cubes.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the cubes were generated, we added them to `BatchNode` and batched
    it to create one mesh for all the cubes. Even if the polygon count is the same,
    decreasing the number of objects greatly enhances the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Having a single mesh means we can't change a single object in the mesh without
    regenerating the whole batch. If we plan to scale this up and generate a whole
    world, we need to keep the size of the batch to a size where we can regenerate
    it without creating slowdowns. Exploring a way to generate it on a separate thread
    might be a good next step.
  prefs: []
  type: TYPE_NORMAL
