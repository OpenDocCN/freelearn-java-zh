- en: Functions and Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The paradigm of functional programming has a lot of common features with the
    paradigm of declarative programming. One of the defining features of functional
    languages and declarative programming is the extensive use of functions. This
    chapter will discuss in more detail what functions are and their meaning in different
    paradigms. We will have a look at how we can use functions and what their role
    is in modern programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions in functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of functions in different programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what are functions? We can define them as **parameterized**, named chunks
    of code. This means that they are chunks of code that can be called from any other
    part of the program by their name. Parameterized means that you can call them
    with certain arguments. Different calls executed with different parameters usually
    lead to different results.
  prefs: []
  type: TYPE_NORMAL
- en: What is the motivation behind functions? The answer is the basic principle of
    engineering – abstract away that which repeats itself. In [Chapter 1](485603d0-9f5e-4644-bd73-c46a8a317448.xhtml),
    The *Declarative Programming Style*, we saw something similar in the case of loops.
    However, loops are built-in control structures. This means they are defined at
    the language level. When we need to define some logic on the language-user level,
    and this logic repeats itself across different parts of the project, functions
    come into play.
  prefs: []
  type: TYPE_NORMAL
- en: We can trace functions across paradigms to as early as procedural programming.
    In procedural programming, functions are one of the units of abstraction. This
    means that functions encapsulate the logic that repeats. In object-oriented programming,
    we have an evolution of the understanding of functions. Functions are usually
    viewed in the context of an object or a class. In this context, they play the
    role of the behavior of an object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have an object called a soda machine, this object may have
    certain behaviors associated with it, such as inserting a coin into the machine,
    or pressing the button to get a can of soda from the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In imperative programming, functions are used to represent the behavior of an
    object. In object-oriented programming, the behavior usually implies side effects.
    For the purposes of this book, we can understand side effects as follows—a function
    is side-effecting when it modifies the environment outside its own body. For example,
    it can have a global variable of its parent object modified, it can write a file
    into the filesystem, or the function can perform some web API calls over the network.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, the understanding of functions is quite different.
    In functional programming, we prise purity and referential transparency. Purity
    means the absence of side effects. Referential transparency means that the result
    value the function has computed can be substituted in place of the function call,
    while the semantics of the program execution will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. You have an application that simulates a soda
    machine. Its behavior is that of the insertion of the coin into the soda machine
    and getting a soda can back from it. A soda machine consists of the data: the
    amount of money and soda cans present in the machine. Whenever a coin is inserted,
    a soda can will be sold.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we express this behavior in an imperative style? We can create a separate
    object called a soda machine and, in that object, a method to dispatch cans. Whenever
    this method is called, the number of coins present in it is increased by one and
    the number of soda cans decreases by one. Also, we want to return an object called
    `SodaCan` from the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the spirit of object-oriented programming, we can represent the soda machine
    as an object with some internal state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define some behavior on this machine: the behavior of what needs
    to happen upon inserting a coin and getting a soda can back. If there are soda
    cans left in the machine, we decrease the number of soda cans by one, increase
    the number of coins by one, and return a `soda can` object to the user. If there
    are no cans left, we throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `SodaCan` object is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The cans and the amount of money present in the soda machine are the variables
    of the soda machine. They don't belong to the function's body. This is why the
    function that changes variables that are outside its own scope constitutes a side-effecting
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'While imperative methods are conceptualized as side-effecting behaviors, functions
    in the functional style are conceptualized as computations that compute some value.
    In the functional world, side effects are not welcome. Let''s express the preceding
    program in a purely functional way. We would have a soda machine with no behavior
    because the behavior is side-effecting. Side effects are generally bad in the
    functional world, as we will learn in subsequent chapters. Instead of that behavior,
    you would have a function that computes a new state of the soda machine. That
    is a new soda machine object from the old soda machine object. Such a soda machine
    object is an immutable object, which means that it only contains values that cannot
    be modified. This helps to eliminate side effects, since now, functions defined
    on the soda machine cannot modify its variables that are outside the scope of
    the functions. Whenever we want to get a new soda can, we would also need to compute
    the new state of the soda machine after the can is dispatched, and then return
    a soda can from this machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Expressed this way, the computation does not affect the environment outside
    its own scope. We no longer have the modification of some external variables,
    nor do we interact with the world outside the scope of the function. We just compute
    the result values based on the inputs to the function. This is the understanding
    of a function in the world of functional programming. Later on in this book, we
    will cover how this understanding is more beneficial than the original understanding
    of a method in terms of the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The absence of side effects is not the only feature of the functional style.
    The next feature we are going to look at is higher-order functions—functions that
    accept other functions as their inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important concept that appears in functional programming is that of
    higher-order functions. A higher-order function is a function that accepts a function
    as an argument. A very trivial example of where this may be useful is control
    structures. For example, a `while` loop can be expressed in a functional way as
    a higher-order function that accepts the body of the loop and a predicate as an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the loop can be expressed as a function that does not accept any
    arguments, but computes some side effects. The way it works is that we have a
    function accept a `0-argument` function and a predicate, and we call the same
    `loop` function recursively while the predicate is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the new control structure `whileDiy`, and it can be defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `whileDiy` construct accepts a predicate and a body. The predicate will
    be evaluated on each function call and, if it is true, we will run the body and
    recursively invoke the `whileDiy` construct again. Notice also that in the `@annotation.tailrec` annotation
    on top of the method, it indicates that the method will be called in a tail-recursive
    manner, which means there's no chance it will result in a `StackOverflowError`,
    even though it is recursive. This is because it will reuse the frame of its initial
    call for all subsequent recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the new construction as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this to how the built-in `while` loop is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The usage is almost identical. This illustrates how higher-order functions can
    be used to define control structures very close to the ones built in to the language.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most functional languages have a concept of a lambda function. It is an anonymous
    function defined inline. It can be assigned to a variable if needed. For example,
    consider that we need a function that accepts a cookie with user session data,
    in the context of a web application. Its job is to print a greeting to the user
    to the standard output. However, before printing, we need to decorate the user''s
    name in a certain way. To complicate matters further, we also have a database
    of users who hold PhDs and, if they do, we need to refer to them as Dr. Here is
    how it can be done in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the dummy `Cookie` class for our example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We define the `greeting` method. The job of the method is to extract the data
    from the `cookie` object, and apply the modifier to the user's name based on their
    gender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, greet the user. This method does not know how exactly to modify
    the name. The `modifier` logic is abstracted away and we rely on the caller to
    specify how to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this is how we can call this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `greeting` function accepts a string and also a function that modifies this
    string. Notice how, when calling this function, we specify the function that modifies
    the string inline. We do not define the function prior to passing it to the `greeting`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: This is the idea behind a lambda function. You don't need to define a function
    before you can use it in some other higher-order function. Instead, you can define
    functions like that inline, using lambda syntax. Obviously, this kind of approach
    is especially useful in the context of higher-order functions. It allows you to
    use higher-order functions without first defining their arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of the lambda function is present in the majority of functional
    languages, including Scala, Haskell, and Python.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of functions in different programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are present in many programming languages. Some of the languages have
    better support for purely functional styles, while others favor declarative styles.
    This is why, for example, using Scala over Java can give you tremendous leverage,
    because you can declare functions inside other functions, you can declare functions
    that accept other functions (higher-order functions) more easily, and you can
    declare anonymous lambda functions (functionality also available in Java, starting
    from Java 8). This greatly increases your capacity for abstraction, creating control
    structures, and thereby enabling your application to be expressed in a more **DRY**
    (**Don't Repeat Yourself**) way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen what functions are and how they have evolved from
    the early days of programming to today. We have seen how functions were initially
    treated as abstractions of common logic. After that, in object-oriented programming,
    they represented the behavior of certain objects. Object-oriented programmers
    attempted to represent everything as an object. So it is only natural that functions
    started to be viewed in the context of a world that consists of objects. In this
    context, functions are best viewed as behaviors of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, functions can be viewed in a different context. Now,
    the best way to view functions is as mathematical computations. They compute some
    value out of its inputs, in a pure way, which means without any side effects.
    The idea is to view them as mathematical functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is close to declarative programming, so its functions
    are also often tailored to the needs of that style. This way, in functional languages,
    there is a concept of higher-order functions, anonymous lambda functions, and
    partial functions. From an engineering perspective, this is useful because it
    greatly enhances your capability for abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, data structures are ubiquitous. When adopting functional style,
    sooner or later you will encounter a problem of working with data structures in
    a functional way. In the next chapter, we will see how this problem is addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are functions interpreted in the context of object-oriented programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are functions interpreted in the context of pure functional programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are higher-order functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are higher-order functions useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
