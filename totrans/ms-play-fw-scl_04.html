<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Exploring Views"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Exploring Views</h1></div></div></div><p>
<span class="strong"><strong>Views</strong></span> are an <a id="id116" class="indexterm"/>essential part of an application, or, in cases where interaction is minimal, they are the means to show what an application is capable of. They have the power to increase the number of end users or discourage them completely. Views that enhance the user experience are always preferred over those that are as complicated as a maze, through which the user struggles to perform a simple task. They act as a deciding factor in an application's success.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building views using Twirl</li><li class="listitem" style="list-style-type: disc">Generating Form</li><li class="listitem" style="list-style-type: disc">Internationalization</li><li class="listitem" style="list-style-type: disc">Templating Internals (covers basics of how Twirl works)</li></ul></div><div class="section" title="Diving into Scala templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Diving into Scala templates</h1></div></div></div><p>A <span class="strong"><strong>Twirl</strong></span> template<a id="id117" class="indexterm"/> is composed of<a id="id118" class="indexterm"/> parameters and<a id="id119" class="indexterm"/> content. The following figure shows the components of a login page template called <code class="literal">login.scala.html</code>:</p><div class="mediaobject"><img src="graphics/3803OS_04_02.jpg" alt="Diving into Scala templates"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The parameters must be declared first since they are used as the parameters of the <code class="literal">apply</code> method of the generated template object. For example, for the <code class="literal">main.scala.html</code> template, shown in the preceding code, the <code class="literal">apply</code> method will be:</p><div class="informalexample"><pre class="programlisting">def apply/*1.2*/(title: String)(content:play.api.twirl.Html):play.api.templates.HtmlFormat.Appendable = {...}</pre></div></div></div><p>The template <a id="id120" class="indexterm"/>content can be HTML as well as Scala code.</p><p>For example, let's look at some <code class="literal">defaultpages</code> (accessible through the object <code class="literal">views.html.defaultpages</code>) bundled along with Play. The default view for this action is not implemented; <code class="literal">todo.scala.html</code> has no template parameters and has plain HTML for its content. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;TODO&lt;/title&gt;
    &lt;link rel="shortcut icon" href="data:image/png;base64,iVBORw.."&gt;
    &lt;style&gt;
    ...
    &lt;/style&gt;
        
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;TODO&lt;/h1&gt;

    &lt;p id="detail"&gt;
      Action not implemented yet.
    &lt;/p&gt;

  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Similarly, the default view for unauthorized, <code class="literal">unauthorized.scala.html</code>, is also a static page.</p><p>Now, let's check<a id="id121" class="indexterm"/> how the view for action not found in development mode, <code class="literal">devNotFound.scala.html</code> is defined:</p><div class="informalexample"><pre class="programlisting">@(request:play.api.mvc.RequestHeader, router:Option[play.core.Router.Routes])

&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Action not found&lt;/title&gt;
    &lt;link rel="shortcut icon" href="data:image/png;base64,iVBORw.."&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Action not found&lt;/h1&gt;

    &lt;p id="detail"&gt;
      For request '@request'
    &lt;/p&gt;

    @router match {

      case Some(routes) =&gt; {
    
        &lt;h2&gt;
          These routes have been tried, in this order:
        &lt;/h2&gt;

                &lt;div&gt;
<span class="strong"><strong>    @routes.documentation.zipWithIndex.map { r =&gt;</strong></span>
<span class="strong"><strong>      &lt;pre&gt;&lt;span class="line"&gt;@(r._2 + 1)&lt;/span&gt;&lt;span class="route"&gt;&lt;span class="verb"&gt;@r._1._1&lt;/span&gt;&lt;span class="path"&gt;@r._1._2&lt;/span&gt;&lt;span class="call"&gt;@r._1._3&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;</strong></span>
<span class="strong"><strong>    }</strong></span>
	             &lt;/div&gt;

      }

      case None =&gt; {
        &lt;h2&gt;
          No router defined.
        &lt;/h2&gt;
      }

        }

  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>In the template snippets, the style component has been excluded to focus on the Scala code used.</p><p>If there is a route file defined, then it lists all the available routes in a preformatted block. The methods<a id="id122" class="indexterm"/> defined for the type of the template parameter can be called even within the template. For example, if <code class="literal">books: Seq[String]</code> is one of the parameters, we can call <code class="literal">@books.length</code> or <code class="literal">@books.map{...}</code>, and so on, within the template.</p><p>Additionally, a Twirl template can be used within another template. This allows us to have reusable chunks of views. For example, supposing we have a main template, which is used by all other views, the application's theme (which includes the header, footer, basic layout, and so on) can be updated by tweaking the main template. Consider a template <code class="literal">main.scala.html</code>, defined as follows:</p><div class="informalexample"><pre class="programlisting">@(title: String)(content: play.twirl.api.Html)

&lt;!DOCTYPE html&gt;

&lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;@title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;header&gt;brand name&lt;/header&gt;
    @content
    &lt;footer&gt;Copyright 2013&lt;/footer&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Reusing this template will be as simple as the following:</p><div class="informalexample"><pre class="programlisting">@main("locate us"){
  &lt;div&gt;
    company address
  &lt;/div&gt;
}</pre></div><p>Another example is defining <span class="emphasis"><em>widgets</em></span> as templates. These widget templates can then be used in multiple<a id="id123" class="indexterm"/> views of the application. Similarly, we can also define code blocks within our templates.</p><div class="section" title="Building a view"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Building a view</h2></div></div></div><p>Let's build a view, which is commonly found in today's web applications. A view where the user is asked to <a id="id124" class="indexterm"/>select the account they want to log in with, such as Google, Facebook, and so on, is given a list of providers with the condition that, by default, the first provider should be selected.</p><p>Consider that in the list of supported third-party authentications, <code class="literal">otherAuth</code> is passed as a template parameter. The type of <code class="literal">otherAuth</code> is <code class="literal">Seq[ThirdPartyAuth]</code>, where <code class="literal">ThirdyPartyAuth</code> is a case class defined to represent any third-party authentication API.</p><p>So, this is completed as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;
    &lt;p&gt;
      Please select the account you wish to use

      @for(auth &lt;- otherAuth) {
        &lt;input type="radio" name="account" value="@auth.id"&gt; @auth.name
    &lt;br/&gt;
        }
    &lt;/p&gt;
&lt;/div&gt;</pre></div><p>In this snippet, we used <code class="literal">for</code> to iterate through all the supported third-party authentications. In the templates, we can use two Scala functions, <code class="literal">for</code> and <code class="literal">if</code>, in addition to those defined within the template and the ones defined on the basis of the type of template parameters.</p><p>Now, the only important part remaining is to set the default value. We can achieve this by using one of the utility methods provided by Twirl the <code class="literal">defining</code> method. Let's create a variable to check whether the provider is the first one or not. We can then have different markups for the two possibilities. If we modify our code to accommodate this, we will get this<a id="id125" class="indexterm"/> code:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;
    &lt;p&gt;
        Please select the account you wish to use

        @for(auth &lt;- otherAuth) {
            @defining(auth.id == otherAuth.head.id) { isChecked =&gt;
                @if(isChecked) {
                    &lt;input type="radio" name="account" value="@auth.id" checked="checked"&gt; @auth.name
                    } else {
                    &lt;input type="radio" name="account" value="@auth.id"&gt; @auth.name
                    }
            }
        &lt;br/&gt;
        }
    &lt;/p&gt;
&lt;/div&gt;</pre></div></div></div></div>
<div class="section" title="Generating forms"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Generating forms</h1></div></div></div><p>Forms are important in situations where the application requires input from users, for example, in the case<a id="id126" class="indexterm"/> of registration, login, search, and so on.</p><p>Play provides helpers to generate a form and wrapper classes to translate the form data into a Scala object.</p><p>Now, we'll build a user registration form using the form helper provided by Play:</p><div class="informalexample"><pre class="programlisting">@helper.form(action = routes.Application.newUser) {
  &lt;label&gt;Email Id
  &lt;input type="email" name="email" tabindex="1" required="required"&gt;
        &lt;/label&gt;

        &lt;label&gt;Password
          &lt;input type="password" name="password" tabindex="2" required="required"&gt;
        &lt;/label&gt;

        &lt;input type="submit" value="Register" type="button"&gt;
    }</pre></div><p>Here, <code class="literal">@helper.form</code> is a template provided by Play, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">@(action: play.api.mvc.Call, args: (Symbol,String)*)(body: =&gt; Html)

&lt;form action="@action.url" method="@action.method" @toHtmlArgs(args.toMap)&gt;
  @body
&lt;/form&gt;</pre></div><p>We can also provide other parameters for the <code class="literal">form</code> element as a tuple of <code class="literal">Symbol</code> and <code class="literal">String</code>. The <code class="literal">Symbol</code> component will become the parameter and its corresponding <code class="literal">String</code> component <a id="id127" class="indexterm"/>will be set as its value in the following way:</p><div class="informalexample"><pre class="programlisting">@helper.form(action = routes.Application.newUser, 'enctype -&gt; "multipart/form-data")</pre></div><p>The resulting HTML will now be as follows:</p><div class="informalexample"><pre class="programlisting">&lt;form action="/register" method="POST" enctype="multipart/form-data"&gt;...&lt;/form&gt;</pre></div><p>This is possible due to the <code class="literal">toHtmlArgs</code> helper method, defined as follows:</p><div class="informalexample"><pre class="programlisting">def toHtmlArgs(args: Map[Symbol, Any]) = play.twirl.api.Html(args.map({
  case (s, None) =&gt; s.name
  case (s, v) =&gt; s.name + "=\"" + play.twirl.api.HtmlFormat.escape(v.toString).body + "\""
}).mkString(" "))</pre></div><p>Now, when we try to register a user, the request body within the action will be:</p><div class="informalexample"><pre class="programlisting">AnyContentAsFormUrlEncoded(Map(email -&gt; ArrayBuffer(testUser@app.com), password -&gt; ArrayBuffer(password)))</pre></div><p>If the <code class="literal">enctype</code> parameter is specified, and the request is parsed as <code class="literal">multipartformdata</code>, the request body will be as follows:</p><div class="informalexample"><pre class="programlisting">MultipartFormData(Map(password -&gt; List(password), email -&gt; List(testUser@app.com)),List(),List(),List())</pre></div><p>Instead of defining custom methods to take a map so that it results in a corresponding model, we can use the <code class="literal">play.api.data.Form</code> form data helper object.</p><p>The form object aids in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mapping form data to user-defined models (such as case classes) or tuples</li><li class="listitem" style="list-style-type: disc">Validating the data entered to see if it meets the required constraints. This can be done for the all of the fields collectively, independently for each field, or both.</li><li class="listitem" style="list-style-type: disc">Filling in default values.</li></ul></div><p>We might need to have the form data translated into credentials; in this case, the class is defined as follows:</p><div class="informalexample"><pre class="programlisting">case class Credentials(loginId: String, password: String)</pre></div><p>We can update the<a id="id128" class="indexterm"/> registration view to use the form object in the following way:</p><div class="informalexample"><pre class="programlisting">@import models.Credentials

@(registerForm: Form[Credentials])(implicit flash: Flash)

@main("Register") {
    &lt;div id="signup" class="form"&gt;
    @helper.form(action = routes.Application.newUser, 'enctype -&gt; "multipart/form-data") {
        &lt;hr/&gt;
        &lt;div&gt;
            
            &lt;label&gt;Email Id
              &lt;input type="email" name="loginId" tabindex="1" required="required"&gt;
            &lt;/label&gt;

            &lt;label&gt;Password
              &lt;input type="password" name="password" tabindex="2" required="required"&gt;
            &lt;/label&gt;

        &lt;/div&gt;
        &lt;input type="submit" value="Register"&gt;
        &lt;hr/&gt;
          Existing User?&lt;a href="@routes.Application.login()"&gt;Login&lt;/a&gt;
        &lt;hr/&gt;
    }
    &lt;/div&gt;
}</pre></div><p>Now we define a form that creates a credentials object from a form with the <code class="literal">loginId</code> and <code class="literal">password</code> field:</p><div class="informalexample"><pre class="programlisting">val signupForm = Form(
    mapping(
      "loginId" -&gt; email,
      "password" -&gt; nonEmptyText
    )(Credentials.apply)(Credentials.unapply)</pre></div><p>We now define the following actions:</p><div class="informalexample"><pre class="programlisting">  def register = Action {
    implicit request =&gt;
      Ok(views.html.register(signupForm)).withNewSession
  }

  def newUser = Action(parse.multipartFormData) {
    implicit request =&gt;
      signupForm.bindFromRequest().fold(
        formWithErrors =&gt; BadRequest(views.html.register(formWithErrors)),
        credentials =&gt; Ok
      )
  }</pre></div><p>The <code class="literal">register</code> and <code class="literal">newUser</code> methods are mapped to <code class="literal">GET /register</code> and <code class="literal">POST /register</code>, respectively. We pass the form in the view so that when there are errors in form validation, they are shown in the view along with the form fields. We will see this in detail in the following<a id="id129" class="indexterm"/> section.</p><p>Let us now see how this works. When we fill the form and submit, the call goes to the <code class="literal">newUser</code> action. The <code class="literal">signupForm</code> is a form and is defined as follows:</p><div class="informalexample"><pre class="programlisting">case class Form[T](mapping: Mapping[T], data: Map[String, String], errors: Seq[FormError], value: Option[T]) { … }</pre></div><p>We used the constructor, which is defined in its companion object:</p><div class="informalexample"><pre class="programlisting">def apply[T](mapping: Mapping[T]): Form[T] = Form(mapping, Map.empty, Nil, None)</pre></div><p>The <code class="literal">mapping</code> method can accept a maximum of 18 arguments. Forms can also be defined using the <code class="literal">tuple</code> method, which will in turn call the <code class="literal">mapping</code> method:</p><div class="informalexample"><pre class="programlisting">def tuple[A1, A2](a1: (String, Mapping[A1]), a2: (String, Mapping[A2])): Mapping[(A1, A2)] = mapping(a1, a2)((a1: A1, a2: A2) =&gt; (a1, a2))((t: (A1, A2)) =&gt; Some(t))</pre></div><p>Using this, instead of mapping for <code class="literal">signupForm</code>, you will get this code:</p><div class="informalexample"><pre class="programlisting">val signupForm = Form(
    tuple(
      "loginId" -&gt; email,
      "password" -&gt; nonEmptyText
    ) 
  )</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>The terms <code class="literal">email</code> and <code class="literal">nonEmptyText</code>, which we used while defining the form using mapping as well as the tuple, are predefined constraints and are also defined in the <code class="literal">Form</code> object. The following section discusses them in detail.</p></div></div><p>When defining forms that have a single field, we can use the <code class="literal">single</code> method since the tuple is not defined for a single field, as shown here:</p><div class="informalexample"><pre class="programlisting">def single[A1](a1: (String, Mapping[A1])): Mapping[(A1)] = mapping(a1)((a1: A1) =&gt; (a1))((t: (A1)) =&gt; Some(t))</pre></div><p>The method called in our action is <code class="literal">signupForm.bindRequestFrom</code>. The <code class="literal">bindRequestFrom</code> method<a id="id130" class="indexterm"/> takes an implicit request and fills the form with the form data in the request.</p><p>Once we have filled the form, we need to check if it has any errors or not. This is where the <code class="literal">fold</code> method comes in handy, as defined here:</p><div class="informalexample"><pre class="programlisting">def fold[R](hasErrors: Form[T] =&gt; R, success: T =&gt; R): R = value match {
  case Some(v) if errors.isEmpty =&gt; success(v)
  case _ =&gt; hasErrors(this)
}</pre></div><p>The variable errors and value are from the form constructor. The type of error is <code class="literal">Seq[FormError]</code>, whereas that of the value is <code class="literal">Option[T]</code>.</p><p>We then map the result from <code class="literal">fold</code> to <code class="literal">BadRequest(formWithErrors)</code> if the form has errors. If it doesn't, we can continue with the handled data submitted through the form.</p><div class="section" title="Adding constraints on data"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Adding constraints on data</h2></div></div></div><p>It is a common requirement to restrict the form data entered by users with one rule or another. For example, checking<a id="id131" class="indexterm"/> to ensure that the name field data does not contain digits, the age is less than 18 years, if an expired card is being used to complete the transaction, and so on. Play provides default constraints, which can be used to validate the field data. Using these constraints, we can define a form easily as well as restrict the field data in some ways, as shown here:</p><div class="informalexample"><pre class="programlisting">mapping(
    "userName" -&gt; nonEmptyText,
    "emailId" -&gt; email,
    "password" -&gt; nonEmptyText(minLength=8,maxLength=15)
    )</pre></div><p>The default constraints can be broadly classified into two categories: the ones that define a simple <code class="literal">Mapping[T]</code>, and the ones that consume <code class="literal">Mapping[T]</code> and result in <code class="literal">Mapping[KT]</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">mapping(
    "userName" -&gt; nonEmptyText,
    "interests" -&gt; list(nonEmptyText)
    )</pre></div><p>In this example, <code class="literal">Mapping[String]</code> is transformed into <code class="literal">Mapping[List[String]]</code>.</p><p>There are two other constraints that do not fall into either category. They are <code class="literal">ignored</code> and <code class="literal">checked</code>.</p><p>The <code class="literal">ignored</code> constraint can be used when we do need mapping from the user data for that field. For example, fields such as login time or logout time should be filled in by an application and <a id="id132" class="indexterm"/>not the user. We could use <code class="literal">mapping</code> in this way:</p><div class="informalexample"><pre class="programlisting">mapping(
    "loginId" -&gt; email,
    "password" -&gt; nonEmptyText,
    "loginTime" -&gt; ignored(System.currentTimeMillis())
    )</pre></div><p>The <code class="literal">checked</code> constraint can be used when we need to ensure that a particular checkbox has been selected by the user. For example, accepting terms and conditions of the organization, and so on, in <code class="literal">signupForm</code>:</p><div class="informalexample"><pre class="programlisting">mapping(
    "loginId" -&gt; email,
    "password" -&gt; nonEmptyText,
    "agree" -&gt; checked("agreeTerms")
    )</pre></div><p>The constraints of the first category are listed in this table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Constraint</p>
</th><th style="text-align: left" valign="bottom">
<p>Results in</p>
</th><th style="text-align: left" valign="bottom">
<p>Additional properties and their default values (if any)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">text</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[String]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">minLength</code>: 0,</p>
<p>
<code class="literal">maxLength</code>: <code class="literal">Int.MaxValue</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">nonEmptyText</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[String]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">minLength</code>: 0,</p>
<p>
<code class="literal">maxLength</code>: <code class="literal">Int.MaxValue</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">number</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[Int]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">min</code>: <code class="literal">Int.MinValue</code>,</p>
<p>
<code class="literal">max</code>: <code class="literal">Int.MaxValue</code>,</p>
<p>
<code class="literal">strict</code>: <code class="literal">false</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">longNumber</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[Long]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">min</code>: <code class="literal">Long.MinValue</code>,</p>
<p>
<code class="literal">max</code>: <code class="literal">Long.MaxValue</code>, strict: <code class="literal">false</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bigDecimal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[BigDecimal]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>precision,</p>
<p>scale</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">date</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[java.util.Date]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>pattern,</p>
<p>
<code class="literal">timeZone</code>: <code class="literal">java.util.TimeZone.getDefault</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sqlDate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[java.sql.Date]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>pattern,</p>
<p>
<code class="literal">timeZone</code>: <code class="literal">java.util.TimeZone.getDefault</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">jodaDate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[org.joda.time.DateTime]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>pattern,</p>
<p>
<code class="literal">timeZone</code>: <code class="literal">org.joda.time.DateTimeZone.getDefault</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">jodaLocalDate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[org.joda.time.LocalDate]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>pattern</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">email</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[String]</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">boolean</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[Boolean]</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>This table lists the<a id="id133" class="indexterm"/> constraints included in the second category:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Constraint</p>
</th><th style="text-align: left" valign="bottom">
<p>Results in</p>
</th><th style="text-align: left" valign="bottom">
<p>Required parameters and their type</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">optional</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[Option[A]]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">mapping</code>: <code class="literal">Mapping[A]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">default</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[A]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">mapping</code>: <code class="literal">Mapping[A]</code>, value: <code class="literal">A</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">list</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[List[A]]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">mapping</code>: <code class="literal">Mapping[A]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">seq</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[Seq[A]]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">mapping</code>: <code class="literal">Mapping[A]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">set</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Mapping[Seq[A]]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">mapping</code>: <code class="literal">Mapping[A]</code>
</p>
</td></tr></tbody></table></div><p>In addition to these field constraints, we can also define ad hoc and/or custom constraints on a field using the <code class="literal">verifying</code> method.</p><p>An instance might arise where an application lets users choose their <code class="literal">userName</code>, which can only consist of numbers and alphabet. To ensure that this rule is not broken, we can define an ad hoc constraint:</p><div class="informalexample"><pre class="programlisting">mapping(
"userName" -&gt;  nonEmptyText(minLength=5) verifying pattern("""[A-Za-z0-9]*""".r, error = "only digits and alphabet are allowed in userName"
)</pre></div><p>Or, we can define a custom constraint using the <code class="literal">Constraint</code> case class:</p><div class="informalexample"><pre class="programlisting">val validUserName = """[A-Za-z0-9]*""".r
val userNameCheckConstraint: Constraint[String] = Constraint("contraints.userName")({
    text =&gt;
      val error = text match {
        case validUserName() =&gt; Nil
        case _ =&gt; Seq(ValidationError("only digits and alphabet are allowed in userName"))
      }
      if (error.isEmpty) Valid else Invalid(error)
  })

val userNameCheck: Mapping[String] = nonEmptyText(minLength = 5).verifying(passwordCheckConstraint)</pre></div><p>We can use this in a form definition:</p><div class="informalexample"><pre class="programlisting">mapping(
"userName" -&gt;  userNameCheck
)</pre></div><p>Note that <code class="literal">nonEmpty</code>, <code class="literal">minLength</code>, <code class="literal">maxLength</code>, <code class="literal">min</code>, <code class="literal">max</code>, <code class="literal">pattern</code>, and <code class="literal">email</code> are predefined constraints. They <a id="id134" class="indexterm"/>are defined in the <code class="literal">play.api.data.validation</code> trait. The available constraints can be used as references when defining custom constraints.</p></div><div class="section" title="Handling errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Handling errors</h2></div></div></div><p>What happens<a id="id135" class="indexterm"/> when one or more constraints has been broken in the form that has been submitted? The <code class="literal">bindFromRequest</code> method creates a form with errors, which we earlier referred to as <code class="literal">formWithErrors</code>.</p><p>For each violated constraint, an error is saved. An error is represented by <code class="literal">FormError</code>, defined as follows:</p><div class="informalexample"><pre class="programlisting">case class FormError(key: String, messages: Seq[String], args: Seq[Any] = Nil)</pre></div><p>The <code class="literal">key</code> is the name of the field where a constraint was broken, <code class="literal">message</code> is its corresponding error message and <code class="literal">args</code> are the arguments, if any, used in the message. In the case of constraints defined in multiple fields, the key is an empty string and such errors are termed <code class="literal">globalErrors</code>.</p><p>The errors in a form for a specific field can be accessed through the <code class="literal">errors</code> method, defined as:</p><div class="informalexample"><pre class="programlisting">def errors(key: String): Seq[FormError] = errors.filter(_.key == key)</pre></div><p>For example:</p><div class="informalexample"><pre class="programlisting">registerForm.errors("userName")</pre></div><p>Alternatively, to access only the first error, we can use the <code class="literal">error</code> method instead. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">def error(key: String): Option[FormError] = errors.find(_.key == key)</pre></div><p>Now, how do we access <code class="literal">globalErrors</code> (that is, an error from a constraint defined in multiple fields together)?</p><p>We can use the form's <code class="literal">globalErrors</code> method, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">def globalErrors: Seq[FormError] = errors.filter(_.key.isEmpty)</pre></div><p>If we want just the first <code class="literal">globalError</code> method, we can use the <code class="literal">globalError</code> method. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">def globalError: Option[FormError] = globalErrors.headOption</pre></div><p>When we use the <a id="id136" class="indexterm"/>form-field helpers, field-specific errors are mapped to the field and displayed if they're present. However, if we are not using the form helpers, we will need to display the errors, as shown here:</p><div class="informalexample"><pre class="programlisting">&lt;label&gt;Password
  &lt;input type="password" name="password" tabindex="2" required="required"&gt;
&lt;/label&gt;
@registerForm.errors("password").map{ er =&gt; &lt;p&gt;@er.message&lt;/p&gt;}</pre></div><p>The <code class="literal">globalErrors</code> method needs to be added to the view explicitly, as shown here:</p><div class="informalexample"><pre class="programlisting">@registerForm.globalErrors.map{ er =&gt; &lt;p&gt;@er.message&lt;/p&gt;}</pre></div></div><div class="section" title="Form-field helpers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Form-field helpers</h2></div></div></div><p>In the previous <a id="id137" class="indexterm"/>example, we used the HTML code for the <code class="literal">form</code> fields, but we can also do this using the <code class="literal">form</code> field helpers provided by Play. We can update our <code class="literal">view,@import models.Credentials</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">@(registerForm: Form[Credentials])(implicit flash: Flash) 
 
@main("Register") { 
  @helper.form(action = routes.Application.newUser, 'enctype -&gt; "multipart/form-data") { 
    @registerForm.globalErrors.map { error =&gt; 
      &lt;p class="error"&gt; 
        @error.message 
      &lt;/p&gt; 
    } 
        
    @helper.inputText(registerForm("loginId"), 'tabindex -&gt; "1", '_label -&gt; "Email ID", 
    'type -&gt; "email", 'required -&gt; "required", '_help -&gt; "A valid email Id") 

    @helper.inputPassword(registerForm("password"), 'tabindex -&gt; "2", 
    'required -&gt; "required", '_help -&gt; "preferable min.length=8") 

    &lt;input type="submit" value="Register"&gt; 
    &lt;hr/&gt; 
    Existing User?&lt;a href="@routes.Application.login()"&gt;Login&lt;/a&gt; 
    } 
}</pre></div><p>Let's see how this<a id="id138" class="indexterm"/> works. The helper <code class="literal">inputText</code> is a view defined as follows:</p><div class="informalexample"><pre class="programlisting">@(field: play.api.data.Field, args: (Symbol,Any)*)(implicit handler: FieldConstructor, lang: play.api.i18n.Lang)

@inputType = @{ args.toMap.get('type).map(_.toString).getOrElse("text") }

@input(field, args.filter(_._1 != 'type):_*) { (id, name, value, htmlArgs) =&gt;
    &lt;input type="@inputType" id="@id" name="@name" value="@value" @toHtmlArgs(htmlArgs)/&gt;
}</pre></div><p>It uses the input helper internally, which is also a view and can be defined as follows:</p><div class="informalexample"><pre class="programlisting">@(field: play.api.data.Field, args: (Symbol, Any)* )(inputDef: (String, String, Option[String], Map[Symbol,Any]) =&gt; Html)(implicit handler: FieldConstructor, lang: play.api.i18n.Lang)

@id = @{ args.toMap.get('id).map(_.toString).getOrElse(field.id) }

@handler(
    FieldElements(
        id,
        field,
        inputDef(id, field.name, field.value, args.filter(arg =&gt; !arg._1.name.startsWith("_") &amp;&amp; arg._1 != 'id).toMap),
        args.toMap,
        lang
    )
)</pre></div><p>Both the <code class="literal">form</code> field helpers use an implicit <code class="literal">FieldConstructor</code>. This field constructor is responsible for the HTML rendered. By default, <code class="literal">defaultFieldConstructor</code> is forwarded. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">@(elements: FieldElements)

&lt;dl class="@elements.args.get('_class) @if(elements.hasErrors) {error}" id="@elements.args.get('_id).getOrElse(elements.id + "_field")"&gt;
    @if(elements.hasName) {
    &lt;dt&gt;@elements.name(elements.lang)&lt;/dt&gt;
    } else {
    &lt;dt&gt;&lt;label for="@elements.id"&gt;@elements.label(elements.lang)&lt;/label&gt;&lt;/dt&gt;
    }
    &lt;dd&gt;@elements.input&lt;/dd&gt;
    @elements.errors(elements.lang).map { error =&gt;
        &lt;dd class="error"&gt;@error&lt;/dd&gt;
    }
    @elements.infos(elements.lang).map { info =&gt;
        &lt;dd class="info"&gt;@info&lt;/dd&gt;
    }
&lt;/dl&gt;</pre></div><p>So, if we wish to change the layouts for our <code class="literal">form</code> fields, we can define a custom <code class="literal">FieldConstructor</code> and<a id="id139" class="indexterm"/> pass it to the <code class="literal">form</code> field helpers, as shown here:</p><div class="informalexample"><pre class="programlisting">@input(contactForm("name"), '_label -&gt; "Name", '_class -&gt; "form-group", '_size -&gt; "100") { (id, name, value, htmlArgs) =&gt;
  &lt;input class="form-control" type="text" id="@id" name="@name" value="@value" @toHtmlArgs(htmlArgs)/&gt;
}</pre></div><p>This section attempts to explain how the form helper works; for more examples, refer to the Play<a id="id140" class="indexterm"/> Framework documentation at <a class="ulink" href="http://www.playframework.com/documentation/2.3.x/ScalaForms">http://www.playframework.com/documentation/2.3.x/ScalaForms</a>.</p></div></div>
<div class="section" title="Internationalization"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Internationalization</h1></div></div></div><p>Due to the wide reach of the Internet, it is now possible to communicate and interact with people from diverse locations. An application that communicates with users in one specific language<a id="id141" class="indexterm"/> restricts its user base through the use of only that language. Internationalization and localization can be used to cater to user groups from various regions by removing barriers that arise due to the use of a particular language only.</p><p>Now, let's build a simple view, which allows us to ask a question. The <code class="literal">views/index.scala.html</code> view file will be similar to the following:</p><div class="informalexample"><pre class="programlisting">@(enquiryForm: Form[(String, Option[String], String)]) 

@import helper._ 

@main("Enquiry") { 

    &lt;div&gt; 
        &lt;h2&gt;Have a question? Ask Us&lt;/h2&gt; 

        @form(routes.AppController.enquire) { 

            @enquiryForm.globalError.map { error =&gt; 
                &lt;p&gt; 
                    @error.message 
                &lt;/p&gt; 
            } 

            &lt;label for="emailId"&gt;Your email address 
                &lt;input type="email" id="emailId" name="emailId" required&gt; 
            &lt;/label&gt; 

            &lt;label for="userName"&gt;Your name 
                &lt;input type="text" class="form-control" id="userName" name="userName"&gt; 
            &lt;/label&gt; 

            &lt;label for="question"&gt;Your question 
                &lt;textarea rows="4" id="question" name="question"&gt;&lt;/textarea&gt; 
            &lt;/label&gt; 

            &lt;br/&gt; 
            &lt;button type="submit"&gt;Ask&lt;/button&gt; 
        } 
    &lt;/div&gt; 
}</pre></div><p>Here, <code class="literal">AppController</code> is a<a id="id142" class="indexterm"/> controller and is defined as follows:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api.mvc._
import play.api.data.Form
import play.api.data.Forms._


object AppController extends Controller {

  val enquiryForm = Form(
    tuple(
      "emailId" -&gt; email,
      "userName" -&gt; optional(text),
      "question" -&gt; nonEmptyText)
  )

  def index = Action {
    implicit request =&gt;
      Redirect(routes.AppController.askUs)
  }

  def askUs = Action {
    implicit request =&gt;
      Ok(views.html.index(enquiryForm))
  }

  def enquire = Action {
    implicit request =&gt;
      enquiryForm.bindFromRequest.fold(
        errors =&gt; BadRequest(views.html.index(errors)),
        query =&gt; {
          println(query.toString)
          Redirect(routes.AppController.askUs)
        }
      )
  }

}</pre></div><p>The main template <a id="id143" class="indexterm"/>
<code class="literal">views/main.scala.html</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">@(title: String)(content: Html) 
&lt;!DOCTYPE html&gt; 

&lt;html&gt; 
    &lt;head&gt; 
        &lt;title&gt;@title&lt;/title&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
    @content 
    &lt;/body&gt; 
&lt;/html&gt; </pre></div><p>The routes for the application are defined as follows:</p><div class="informalexample"><pre class="programlisting"># Home page
GET         /                    controllers.AppController.index

# Other
GET         /ask                 controllers.AppController.askUs
POST        /enquire             controllers.AppController.enquire</pre></div><p>Now when we<a id="id144" class="indexterm"/> start the application, with the help of a little bit of styling (CSS styles), our view looks similar to this:</p><div class="mediaobject"><img src="graphics/3803OS_04_03.jpg" alt="Internationalization"/></div><div class="section" title="Supporting views in multiple languages"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Supporting views in multiple languages</h2></div></div></div><p>We might <a id="id145" class="indexterm"/>want our application to be available in both English and French. Therefore, having different views for different languages is a bad idea. This would mean that every time the support for a language is included, we would need to define all the views in our application in this particular language as well. Using Play's <span class="emphasis"><em>i18n</em></span> support, supporting another language can be as simple as adding a file that contains translations.</p><p>Firstly, we will need to specify the languages supported by our application in <code class="literal">conf/application.conf</code>. Notice that this is commented code in the default <code class="literal">conf/application.conf</code>, which indicates the following:</p><div class="informalexample"><pre class="programlisting"># The application languages
# ~~~~~
# application.langs="en"</pre></div><p>The format in which the language should be specified is its ISO 639-2 code, optionally followed by an ISO 3166-1 alpha-2 country code. You can include French as well, as shown here:</p><div class="informalexample"><pre class="programlisting">application.langs="en,fr"</pre></div><p>In Play, the translations required for content to be rendered in a particular language are called messages. For each language, we need to provide a <code class="literal">conf/messages.lang-code</code> file. If we wish to have common content, we should define it in <code class="literal">conf/messages</code>; this can be quite useful for names, branding, and so on.</p><p>Let's create a <a id="id146" class="indexterm"/>
<code class="literal">messages</code> file for English called <code class="literal">conf/messages.en</code>:</p><div class="informalexample"><pre class="programlisting">enquiry.title = Enquiry
enquiry.askUs=Have A Question? Ask Us!
enquiry.user.email=Your email address
enquiry.user.name=Your name
enquiry.question=Your question
enquiry.submit=Ask</pre></div><p>Now we need to update our view to use these messages, in the form of <code class="literal">@(enquiryForm: Form[(String, Option[String], String)])(implicit lang: Lang)</code>:</p><div class="informalexample"><pre class="programlisting">@import helper._ 

@main(Messages("enquiry.title")) { 

    &lt;div&gt; 
        &lt;h2&gt;@Messages("enquiry.askUs")&lt;/h2&gt; 

        @form(routes.AppController.enquire) { 

            @enquiryForm.globalError.map { error =&gt; 
                &lt;p&gt; 
                    @error.message 
                &lt;/p&gt; 
            } 

            &lt;label for="emailId"&gt;@Messages("enquiry.user.email") 
                &lt;input type="email" id="emailId" name="emailId" required&gt; 
            &lt;/label&gt; 

            &lt;label for="userName"&gt;@Messages("enquiry.user.name") 
                &lt;input type="text" class="form-control" id="userName" name="userName"&gt; 
            &lt;/label&gt; 

            &lt;label for="question"&gt;@Messages("enquiry.question") 
                &lt;textarea rows="4" id="question" name="question"&gt;&lt;/textarea&gt; 
            &lt;/label&gt; 

            &lt;br/&gt; 
            &lt;button type="submit"&gt;@Messages("enquiry.submit")&lt;/button&gt; 
        } 
    &lt;/div&gt;
}</pre></div><p>Now, let's add the French <code class="literal">messages</code> file, <code class="literal">conf/messages.fr</code>:</p><div class="informalexample"><pre class="programlisting">enquiry.title = Demande de renseignements
enquiry.askUs = Vous avez une question? Demandez-nous!
enquiry.user.email = Votre adresse e-mail
enquiry.user.name = Votre nom
enquiry.question = Votre question
enquiry.submit = Demandez</pre></div><p>Change your<a id="id147" class="indexterm"/> browser settings so that you have French (fr) enabled as the primary language and run the application. You should be able to see the enquiry view in French:</p><div class="mediaobject"><img src="graphics/3803OS_04_04.jpg" alt="Supporting views in multiple languages"/></div><p>We can also use the messages within the Scala code after importing <code class="literal">play.api.i18n</code>:</p><div class="informalexample"><pre class="programlisting">val title = Messages("enquiry.title")</pre></div></div><div class="section" title="Understanding internationalization"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Understanding internationalization</h2></div></div></div><p>When we use<a id="id148" class="indexterm"/> <code class="literal">Messages</code> (word) in our code, it calls the <code class="literal">apply</code> method of the <code class="literal">play.api.i18n.Messages</code> object. The <code class="literal">apply</code> method is defined as follows:</p><div class="informalexample"><pre class="programlisting">def apply(key: String, args: Any*)(implicit lang: Lang): String = {
    Play.maybeApplication.flatMap { app =&gt;
      app.plugin[MessagesPlugin].map(_.api.translate(key, args)).getOrElse(throw new Exception("this plugin was not registered or disabled"))
    }.getOrElse(noMatch(key, args))
  }</pre></div><p>Play has an internal plugin called the <code class="literal">MessagesPlugin</code>, defined as follows:</p><div class="informalexample"><pre class="programlisting">class MessagesPlugin(app: Application) extends Plugin {

  import scala.collection.JavaConverters._

  import scalax.file._
  import scalax.io.JavaConverters._

  private def loadMessages(file: String): Map[String, String] = {
    app.classloader.getResources(file).asScala.toList.reverse.map { messageFile =&gt;
      new Messages.MessagesParser(messageFile.asInput, messageFile.toString).parse.map { message =&gt;
        message.key -&gt; message.pattern
      }.toMap
    }.foldLeft(Map.empty[String, String]) { _ ++ _ }
  }

  private lazy val messages = {
    MessagesApi {
      Lang.availables(app).map(_.code).map { lang =&gt;
        (lang, loadMessages("messages." + lang))
      }.toMap + ("default" -&gt; loadMessages("messages"))
    }
  }

  //The underlying internationalization API.
  def api = messages

  //Loads all configuration and message files defined in the classpath.
  override def onStart() {
    messages
  }

}</pre></div><p>This plugin is responsible for loading all the messages and generating a <code class="literal">MessagesApi</code> object, which is later used to fetch the value of a message. So, when we refer to a message, it's<a id="id149" class="indexterm"/> fetched from this instance of <code class="literal">MessagesApi</code>. <code class="literal">MessagesApi</code> and is defined as follows:</p><div class="informalexample"><pre class="programlisting">case class MessagesApi(messages: Map[String, Map[String, String]]) {

  import java.text._

  //Translates a message.
  def translate(key: String, args: Seq[Any])(implicit lang: Lang): Option[String] = {
    val langsToTry: List[Lang] =
      List(lang, Lang(lang.language, ""), Lang("default", ""), Lang("default.play", ""))
    val pattern: Option[String] =
      langsToTry.foldLeft[Option[String]](None)((res, lang) =&gt;
        res.orElse(messages.get(lang.code).flatMap(_.get(key))))
    pattern.map(pattern =&gt;
      new MessageFormat(pattern, lang.toLocale).format(args.map(_.asInstanceOf[java.lang.Object]).toArray))
  }
 
  //Check if a message key is defined.
  def isDefinedAt(key: String)(implicit lang: Lang): Boolean = {
    val langsToTry: List[Lang] = List(lang, Lang(lang.language, ""), Lang("default", ""), Lang("default.play", ""))

    langsToTry.foldLeft[Boolean](false)({ (acc, lang) =&gt;
      acc || messages.get(lang.code).map(_.isDefinedAt(key)).getOrElse(false)
    })
  }

}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The implicit <code class="literal">lang</code> parameter is the key to get messages in the accepted language.</p></div></div></div></div>
<div class="section" title="Scala templating in Play"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Scala templating in Play</h1></div></div></div><p>Play supports the use of Scala code within views and also provides a couple of helper methods to ease<a id="id150" class="indexterm"/> the process of defining a view.</p><p>We've created <a id="id151" class="indexterm"/>different views till now. Let's see how they are actually rendered. Consider the view for the Task Tracker app we saw in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Play">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Play</em></span>.</p><div class="informalexample"><pre class="programlisting">@(tasks: List[Task], taskForm: Form[String])

@import helper._

@main("Task Tracker") {
 
    &lt;h2&gt;Task Tracker&lt;/h2&gt;

    &lt;div&gt;
    @form(routes.TaskController.newTask) {

        @taskForm.globalError.map { error =&gt;
            &lt;p class="error"&gt;
                @error.message
            &lt;/p&gt;
        }
        &lt;form&gt;
            &lt;input type="text" name="taskName" placeholder="Add a new Task" required&gt;

            &lt;input type="submit" value="Add"&gt;
        &lt;/form&gt;
    }
    &lt;/div&gt;
    &lt;div&gt;
        &lt;ul&gt;
        @tasks.map { task =&gt;
            &lt;li&gt;
                @form(routes.TaskController.deleteTask(task.id)) {
                  @task.name &lt;input type="submit" value="Remove"&gt;
                }
            &lt;/li&gt;
        }
        &lt;/ul&gt;
    &lt;/div&gt;

}</pre></div><p>The view has Scala code along with HTML, so how is it rendered correctly?</p><p>Open the Task Tracker view in a browser without running the Play application. The browser renders the<a id="id152" class="indexterm"/> page as follows:</p><div class="mediaobject"><img src="graphics/3803OS_04_01.jpg" alt="Scala templating in Play"/></div><p>Now have a look at how differently it is rendered when you run the Play application!</p><p>When a Play <a id="id153" class="indexterm"/>application is compiled, the route-related files (<code class="literal">routes_reverseRouting.scala</code> and <code class="literal">routes_routing.scala</code>, <code class="literal">controllers/routes.java</code>) and Scala views are generated. The routes-related files are generated through the<a id="id154" class="indexterm"/> <span class="strong"><strong>routes compiler</strong></span>, while the Scala views are generated by the <a id="id155" class="indexterm"/>
<span class="strong"><strong>template compiler</strong></span>. The Scala template engine of Play has been extracted to facilitate its use in projects independent of Play. The Play Scala template engine is now available <a id="id156" class="indexterm"/>as Twirl. According to <a class="ulink" href="https://github.com/spray/twirl">https://github.com/spray/twirl</a>, the reason for choosing Twirl as the name is:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>As a replacement for the rather unwieldy name "Play framework Scala template engine" we were looking for something shorter with a bit of "punch" and liked Twirl as a reference to the template languages "magic" character @, which is sometimes also called "twirl".</em></span></p></blockquote></div><div class="section" title="Understanding the working of Twirl"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Understanding the working of Twirl</h2></div></div></div><p>Play's plugin is defined with<a id="id157" class="indexterm"/> a dependency on <span class="strong"><strong>SbtTwirl</strong></span>; we can see this in the plugin definition:</p><div class="informalexample"><pre class="programlisting">object Play
  extends AutoPlugin
  with PlayExceptions
  with PlayReloader
  with PlayCommands
  with PlayRun
  with play.PlaySettings
  with PlayPositionMapper
  with PlaySourceGenerators {

  override def requires = SbtTwirl &amp;&amp; SbtJsTask &amp;&amp; SbtWebDriver

  val autoImport = play.PlayImport


  override def projectSettings =
    packageArchetype.java_server ++
      defaultSettings ++
      intellijCommandSettings ++
      Seq(testListeners += testListener) ++
      Seq(
        scalacOptions ++= Seq("-deprecation", "-unchecked", "-encoding", "utf8"),
        javacOptions in Compile ++= Seq("-encoding", "utf8", "-g")
      )
}</pre></div><p>In addition to this, there are some SBT keys defined in <code class="literal">defaultSettings</code> using <span class="strong"><strong>TwirlKeys</strong></span>. TwirlKeys<a id="id158" class="indexterm"/> exposes some keys, which can be used to customize Twirl as per our requirement. The keys that are exposed using TwirlKeys are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">twirlVersion</code>: This is the Twirl <a id="id159" class="indexterm"/>version used for twirl-api dependency (<code class="literal">SettingKey[String]</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">templateFormats</code>: This defines<a id="id160" class="indexterm"/> Twirl template formats (<code class="literal">SettingKey[Map[String, String]]</code>). The default formats available are <code class="literal">html</code>, <code class="literal">txt</code>, <code class="literal">xml</code>, and <code class="literal">js</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">templateImports</code>: This<a id="id161" class="indexterm"/> includes the extra imports used for twirl templates (<code class="literal">SettingKey[Seq[String]]</code>). By default, its value is an empty sequence.</li><li class="listitem" style="list-style-type: disc"><code class="literal">useOldParser</code>: This uses<a id="id162" class="indexterm"/> the original Play template parser (<code class="literal">SettingKey[Boolean]</code>); the value is false by default.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sourceEncoding</code>: This<a id="id163" class="indexterm"/> includes the source encoding for template files and generated Scala files (<code class="literal">TaskKey[String]</code>). If no encoding is specified in Scala compiler options, it uses the UTF-8 encoding.</li><li class="listitem" style="list-style-type: disc"><code class="literal">compileTemplates</code>: This<a id="id164" class="indexterm"/> compiles twirl templates into Scala source files (<code class="literal">TaskKey[Seq[File]]</code>).</li></ul></div><p>To understand this task, let's see how <code class="literal">twirlSettings</code> are defined in the Twirl plugin:</p><div class="informalexample"><pre class="programlisting">  def twirlSettings: Seq[Setting[_]] = Seq(
    includeFilter in compileTemplates := "*.scala.*",
    excludeFilter in compileTemplates := HiddenFileFilter,
    sourceDirectories in compileTemplates := Seq(sourceDirectory.value / "twirl"),

    sources in compileTemplates &lt;&lt;= Defaults.collectFiles(
      sourceDirectories in compileTemplates,
      includeFilter in compileTemplates,
      excludeFilter in compileTemplates
    ),

    watchSources in Defaults.ConfigGlobal &lt;++= sources in compileTemplates,

    target in compileTemplates := crossTarget.value / "twirl" / Defaults.nameForSrc(configuration.value.name),

    compileTemplates := compileTemplatesTask.value,

    sourceGenerators &lt;+= compileTemplates,
    managedSourceDirectories &lt;+= target in compileTemplates
  )</pre></div><p>The <code class="literal">compileTemplates</code> setting gets its value from <code class="literal">compileTemplatesTask.value</code>. The <code class="literal">compileTemplatesTask</code> in<a id="id165" class="indexterm"/> turn returns the result from the <code class="literal">TemplateCompiler.compile</code> method, as shown here:</p><div class="informalexample"><pre class="programlisting">  def compileTemplatesTask = Def.task {
    TemplateCompiler.compile(
      (sourceDirectories in compileTemplates).value,
      (target in compileTemplates).value,
      templateFormats.value,
      templateImports.value,
      (includeFilter in compileTemplates).value,
      (excludeFilter in compileTemplates).value,
      Codec(sourceEncoding.value),
      useOldParser.value,
      streams.value.log
    )
  }

...
}</pre></div><p>
<code class="literal">TemplateCompiler.compile</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">  def compile(
    sourceDirectories: Seq[File],
    targetDirectory: File,
    templateFormats: Map[String, String],
    templateImports: Seq[String],
    includeFilter: FileFilter,
    excludeFilter: FileFilter,
    codec: Codec,
    useOldParser: Boolean,
    log: Logger) = {

    try {
      syncGenerated(targetDirectory, codec)
      val templates = collectTemplates(sourceDirectories, templateFormats, includeFilter, excludeFilter)
      for ((template, sourceDirectory, extension, format) &lt;- templates) {
        val imports = formatImports(templateImports, extension)
        TwirlCompiler.compile(template, sourceDirectory, targetDirectory, format, imports, codec, inclusiveDot = false, useOldParser = useOldParser)
      }
      generatedFiles(targetDirectory).map(_.getAbsoluteFile)
    } catch handleError(log, codec)
  }</pre></div><p>The <code class="literal">compile</code> method creates the <code class="literal">target/scala-scalaVersion/src_managed</code> directory within the<a id="id166" class="indexterm"/> project if it does not already exist. If it exists, then it deletes all the files that match the <code class="literal">"*.template.scala"</code> pattern through the <code class="literal">cleanUp</code> method. After this, the <code class="literal">collectTemplates</code> method gets <code class="literal">Seq[(File, String, TemplateType)]</code> by searching for files whose names match the <code class="literal">"*.scala.*"</code> pattern and end with a supported extension.</p><p>Each object from the result of <code class="literal">collectTemplates</code> is then passed as an argument for <code class="literal">TwirlCompiler.compile</code>.</p><p>
<code class="literal">TwirlCompiler.compile</code> is responsible for parsing and generating Scala templates and is defined as follows:</p><div class="informalexample"><pre class="programlisting">def compile(source: File, sourceDirectory: File, generatedDirectory: File,
formatterType: String, additionalImports: String = "", logRecompilation: (File, File) =&gt; Unit = (_, _) =&gt; ()) = {
    val resultType = formatterType + ".Appendable"
    val (templateName, generatedSource) = generatedFile(source, sourceDirectory, generatedDirectory)
    if (generatedSource.needRecompilation(additionalImports)) {
      logRecompilation(source, generatedSource.file)
      val generated = parseAndGenerateCode(templateName, Path(source).byteArray, source.getAbsolutePath, resultType, formatterType, additionalImports)

      Path(generatedSource.file).write(generated.toString)

      Some(generatedSource.file)
    } else {
      None
    }
  }</pre></div><p>The <code class="literal">parseAndGenerateCode</code> method gets the parser and parses the file. The resulting parsed <code class="literal">Template</code> (internal object) is passed on to the <code class="literal">generateFinalCode</code> method. The <code class="literal">generateFinalCode</code> method<a id="id167" class="indexterm"/> is responsible for generating the code. Internally, it uses the <code class="literal">generateCode</code> method, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">def generateCode(packageName: String, name: String, root: Template, resultType: String, formatterType: String, additionalImports: String) = {
  val extra = TemplateAsFunctionCompiler.getFunctionMapping(
    root.params.str,
    resultType)

    val generated = {
      Nil :+ """
package """ :+ packageName :+ """

import twirl.api._
import TemplateMagic._

  """ :+ additionalImports :+ """
/*""" :+ root.comment.map(_.msg).getOrElse("") :+ """*/
object """ :+ name :+ """ extends BaseScalaTemplate[""" :+ resultType :+ """,Format[""" :+ resultType :+ """]](""" :+ formatterType :+ """) with """ :+ extra._3 :+ """ {

    /*""" :+ root.comment.map(_.msg).getOrElse("") :+ """*/
    def apply""" :+ Source(root.params.str, root.params.pos) :+ """:""" :+ resultType :+ """ = {
        _display_ {""" :+ templateCode(root, resultType) :+ """}
    }

  """ :+ extra._1 :+ """

  """ :+ extra._2 :+ """

    def ref: this.type = this

}"""
    }
    generated
  }</pre></div><p>The result from <code class="literal">parseAndGenerateCode</code> is written into its corresponding file.</p><p>Let's check out where we are going to use the file we generated!</p><p>Consider the view <a id="id168" class="indexterm"/>defined in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Play">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Play</em></span>; the generated Scala template is similar to the following:</p><div class="informalexample"><pre class="programlisting">package views.html

import play.templates._
import play.templates.TemplateMagic._

import play.api.templates._
import play.api.templates.PlayMagic._
import models._
import controllers._
import play.api.i18n._
import play.api.mvc._
import play.api.data._
import views.html._
/**/
object index extends BaseScalaTemplate[play.api.templates.HtmlFormat.Appendable,Format[play.api.templates.HtmlFormat.Appendable]](play.api.templates.HtmlFormat) with play.api.templates.Template2[List[Task],Form[String],play.api.templates.HtmlFormat.Appendable] {

    /**/
    def apply/*1.2*/(tasks: List[Task], taskForm: Form[String]):play.api.templates.HtmlFormat.Appendable = {
      _display_ {import helper._


Seq[Any](format.raw/*1.45*/("""

"""),format.raw/*4.1*/("""
"""),_display_(Seq[Any](/*5.2*/main("Task Tracker")/*5.22*/ {_display_(Seq[Any](format.raw/*5.24*/("""

    &lt;h2&gt;Task Tracker&lt;/h2&gt;

    &lt;div&gt;
    """),_display_(Seq[Any](/*10.6*/form(routes.TaskController.newTask)/*10.41*/ {_display_(Seq[Any](format.raw/*10.43*/("""

        """),_display_(Seq[Any](/*12.10*/taskForm/*12.18*/.globalError.map/*12.34*/ { error =&gt;_display_(Seq[Any](format.raw/*12.45*/("""
            &lt;p class="error"&gt;
          """),_display_(Seq[Any](/*14.18*/error/*14.23*/.message)),format.raw/*14.31*/("""
            &lt;/p&gt;
        """)))})),format.raw/*16.10*/("""
        &lt;form&gt;
            &lt;input type="text" name="taskName" placeholder="Add a new Task" required&gt;

            &lt;input type="submit" value="Add"&gt;
        &lt;/form&gt;
        """)))})),format.raw/*22.6*/("""
    &lt;/div&gt;
    &lt;div&gt;
        &lt;ul&gt;
        """),_display_(Seq[Any](/*26.10*/tasks/*26.15*/.map/*26.19*/ { task =&gt;_display_(Seq[Any](format.raw/*26.29*/("""
            &lt;li&gt;
        """),_display_(Seq[Any](/*28.18*/form(routes.TaskController.deleteTask(task.id))/*28.65*/ {_display_(Seq[Any](format.raw/*28.67*/("""
        """),_display_(Seq[Any](/*29.22*/task/*29.26*/.name)),format.raw/*29.31*/(""" &lt;input type="submit" value="Remove"&gt;
                """)))})),format.raw/*30.18*/("""
            &lt;/li&gt;
        """)))})),format.raw/*32.10*/("""
        &lt;/ul&gt;
    &lt;/div&gt;

""")))})))}
    }
    
    def render(tasks:List[Task],taskForm:Form[String]): play.api.templates.HtmlFormat.Appendable = apply(tasks,taskForm)
    
    def f:((List[Task],Form[String]) =&gt; play.api.templates.HtmlFormat.Appendable) = (tasks,taskForm) =&gt; apply(tasks,taskForm)
    
    def ref: this.type = this

}
                /*
                    -- GENERATED --
                    DATE: Timestamp
                    SOURCE: /TaskTracker/app/views/index.scala.html
                    HASH: ff7c2a525ebc63755f098d4ef80a8c0147eb7778
                    MATRIX: 573-&gt;1|726-&gt;44|754-&gt;63|790-&gt;65|818-&gt;85|857-&gt;87|936-&gt;131|980-&gt;166|1020-&gt;168|1067-&gt;179|1084-&gt;187|1109-&gt;203|1158-&gt;214|1242-&gt;262|1256-&gt;267|1286-&gt;275|1345-&gt;302|1546-&gt;472|1626-&gt;516|1640-&gt;521|1653-&gt;525|1701-&gt;535|1772-&gt;570|1828-&gt;617|1868-&gt;619|1926-&gt;641|1939-&gt;645|1966-&gt;650|2053-&gt;705|2113-&gt;733
                    LINES: 19-&gt;1|23-&gt;1|25-&gt;4|26-&gt;5|26-&gt;5|26-&gt;5|31-&gt;10|31-&gt;10|31-&gt;10|33-&gt;12|33-&gt;12|33-&gt;12|33-&gt;12|35-&gt;14|35-&gt;14|35-&gt;14|37-&gt;16|43-&gt;22|47-&gt;26|47-&gt;26|47-&gt;26|47-&gt;26|49-&gt;28|49-&gt;28|49-&gt;28|50-&gt;29|50-&gt;29|50-&gt;29|51-&gt;30|53-&gt;32
                    -- GENERATED --
*/</pre></div><p>So, when we refer<a id="id169" class="indexterm"/> to this view in a controller as <code class="literal">views.html.index(Task.all, taskForm)</code>, we are calling the <code class="literal">apply</code> method of the generated template object index.</p></div></div>
<div class="section" title="Troubleshooting"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Troubleshooting</h1></div></div></div><p>Here are a few<a id="id170" class="indexterm"/> issues we can come across while using a Play view:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The form is not submitted when you click on <span class="strong"><strong>Submit</strong></span> and no errors are displayed using <code class="literal">globalErrors</code>.<p>There may be a situation where a particular required field is missing or there is a typo in the name of the field. It will not be shown in <code class="literal">globalErrors</code> but if you attempt to display the error for an individual field, <code class="literal">error.required</code> will show up for the missing field.</p></li><li class="listitem" style="list-style-type: disc">Do we need to use Twirl templates for the application's views?<p>No, Play does not force developers to use Twirl templates for the views. They are free to design the views in whichever way they find easy or comfortable. For example, this can be done by using Handlebars, Google Closure templates, and so on.</p></li><li class="listitem" style="list-style-type: disc">Does this affect the performance of the application in any way?<p>No, unless there are no performance flaws in your view definitions, plugging it in a Play application will not affect the performance. There are projects that use the Play server for their native Android and iOS apps.</p></li><li class="listitem" style="list-style-type: disc">Are there any other templating libraries supported by Play?<p>No, but there some Play plugins which aid in using other templating mechanisms or libraries that are available. Since they are developed by individuals or other organizations, check the licensing before using them.</p></li><li class="listitem" style="list-style-type: disc">Although application<a id="id171" class="indexterm"/> language configurations have been updated and messages added in various languages, the views are only rendered in English. There are no errors thrown at runtime and yet it doesn't work as expected.<p>For Play to determine the language used from a request, it is required that the request should be an implicit one. Ensure that all the defined actions within the application make use of implicit requests.</p><p>Another possibility can be that the Accept-Language header could be missing. This will be added by updating the browser settings.</p></li><li class="listitem" style="list-style-type: disc">Will a compilation error occur when a message that doesn't have a mapping in the language resources is accessed?<p>No, a compilation error occurs if an undefined message is being accessed. You can implement this mechanism if required or use something from the open source plugins if they're available and meet your requirements.</p></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we saw how to create views using Twirl and the various helper methods provided by Play. We have built different kinds of views: reusable templates or widgets and forms. We also saw how to support multiple languages in our Play application using the built-in i18n API.</p><p>In the next chapter, we will cover how to handle data transactions available in Play, and also gain insights into how to effectively design your models.</p></div></body></html>