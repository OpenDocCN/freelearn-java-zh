- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication with Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered how to leverage Spring Security’s built-in
    **Java DataBase Connectivity** (**JDBC**) support. In this chapter, we will look
    at the Spring Data project and how to leverage **Jakarta Persistence API** (**JPA**)
    to perform authentication against a relational database. We will also explore
    how to perform authentication against a document database using **MongoDB**. This
    chapter’s sample code is based on the Spring Security setup from [*Chapter 4*](B21757_04.xhtml#_idTextAnchor106),
    *JDBC-based Authentication*, and it has been updated to refactor the need for
    SQL and to use ORM for all database interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the basic concepts related to the Spring Data project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Spring Data JPA to authenticate against a relational database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Spring Data MongoDB to authenticate against a document database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to customize Spring Security for more flexibility when dealing with Spring
    Data integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Spring Data project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring Data project’s mission is to provide a familiar and consistent Spring-based
    programming model for data access, while still retaining the special traits of
    the underlying data provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are just a few of the powerful features of this Spring Data project:'
  prefs: []
  type: TYPE_NORMAL
- en: Powerful repository and custom object-mapping abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic query derivation from repository method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of domain base classes, providing basic properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for transparent auditing (created and last changed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to integrate custom repository code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy Spring integration via Java-based configuration and custom XML namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced integration with Spring MVC controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimental support for cross-store persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This project simplifies the use of data access technologies, relational and
    non-relational databases, `MapReduce` frameworks, and cloud-based data services.
    This umbrella project contains many subprojects that are specific to a given database.
    These projects were developed by working together with many of the companies and
    developers that are behind these exciting technologies. There are also many community-maintained
    modules and other related modules, including *JDBC support* and *Apache Hadoop*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the main modules that make up the Spring Data
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Commons | Applies core Spring concepts to all Spring Data projects
    |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Gemfire | Provides easy configuration and access to Gemfire from
    Spring applications |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data JPA | Makes it easy to implement JPA-based repositories |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Key Value | Map-based repositories and SPIs, which can easily
    build a Spring Data module for key-value stores |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data LDAP | Provides Spring Data repository support for Spring LDAP
    |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data MongoDB | Spring-based, object-document support and repositories
    for MongoDB |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data REST | Exports Spring Data repositories as hypermedia-driven
    RESTful resources |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Redis | Provides easy configuration and access to Redis from
    Spring applications |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data for Apache Cassandra | A Spring Data module for Apache Cassandra
    |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data for Apache Solr | A Spring Data module for Apache Solr |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Main modules of the Spring Data project
  prefs: []
  type: TYPE_NORMAL
- en: After exploring the core modules of the Spring Data project, let’s now delve
    into the primary features of Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/omOQK](https://packt.link/omOQK).'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data JPA project aims to significantly improve the ORM implementation
    of data access layers by reducing the effort to the amount that’s actually needed.
    A developer only needs to write repository interfaces, including custom finder
    methods, and Spring will provide the implementation automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are just a few of the powerful features specific to the Spring
    Data JPA Project:'
  prefs: []
  type: TYPE_NORMAL
- en: Sophisticated support for building repositories based on Spring and JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for `QueryDSL` predicates and, thus, type-safe JPA queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparent auditing of domain classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination support, dynamic query execution, and the ability to integrate custom
    data access code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation of `@Query`-annotated queries at bootstrap time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for XML based entity mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `JavaConfig` based repository configuration by introducing `@EnableJpaRepositories`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating our dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already included all the dependencies you need for this chapter, so
    you will not need to make any updates to your `build.gradle` file. However, if
    you are just adding Spring Data JPA support to your application, you need to add
    `spring-boot- starter-data-jpa` as a dependency in the `build.gradle` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice haven’t removed the `spring-boot-starter-jdbc` dependency.
  prefs: []
  type: TYPE_NORMAL
- en: The `spring-boot-starter-data-jpa` dependency will contain all the dependencies
    needed to wire our domain objects to our embedded database with JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Reconfiguring the database configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we will convert the current JBCP calendar project. Let’s begin by reconfiguring
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: We can begin by removing the `DataSourceConfig.java` file, as we will be leveraging
    Spring Boot’s built-in support for an embedded H2 database.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now remove the `src/main/resources/database` directory and all contents
    in that directory. This directory contains several `.``sql` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a `data.sql` file that will contain our seed data, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following SQL statement, depicting the password for **user1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the following SQL statement, depicting the password for **admin1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the following SQL statement, depicting the password for **user2**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the following SQL statement, depicting the user roles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, **user1** has one role:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, **admin1** has two roles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the following SQL statement, depicting events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can update the application properties to define our embedded database
    properties in the `src/main/resources/application.yml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have removed the old database configuration and added the
    new configuration. The application will not work at this point, but this can still
    be considered a marker point before we continue to the next steps of conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar05.01-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring from SQL to ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring from an SQL to an ORM implementation is simpler than you might think.
    Most of the refactoring involves the removal of excess code in the form of an
    SQL. In this next section, we will refactor our SQL implementation to a JPA implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For JPA to map our domain objects to our database, we need to perform some mapping
    on our domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping domain objects using JPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to learn about mapping the domain objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by mapping our `Event.java` file so that all the domain objects
    will use JPA, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to create a `Role.java` file with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Role` object will be used to map authorities to our `CalendarUser` table.
    Let’s map our `CalendarUser.java` file, now that we have a `Role.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we have mapped our domain objects with the required JPA annotation,
    including `@Entity` and `@Table` to define the **Relational Database Management
    System** (**RDBMS**) location, as well as structural, reference, and association
    mapping annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, you can also **remove** the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The application will not work at this point, but this can still be considered
    a marker point before we continue to the next steps of conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar05.02-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now add the required interfaces for Spring Data to map our required
    **Create, Read, Update, and Delete** (**CRUD**) operations to our embedded database,
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by adding a new interface to a new package, which will be `com.packtpub.springsecurity.repository`.
    The new file will be called `CalendarUserRepository.java`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now continue by adding a new interface to the same repository package,
    which will be `com.packtpub.springsecurity.repository`, and the new file will
    be called `EventRepository.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow for standard CRUD operations such as `find()`, `save()`, and
    `delete()` on our `Event` objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we will add a new interface to the same repository package, which
    will be `com.packtpub.springsecurity.repository`, and the new file will be called
    `RoleRepository.java`. This `CrudRepository` interface will be used to manage
    the `Role` object for our security roles associated with a given `CalendarUser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will allow for standard CRUD operations such as `find()`, `save()`, and
    `delete()` on our `Role` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Data access objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to refactor the `JdbcEventDao.java` file with a new name, `JpaEventDao.java`,
    so that we can replace the JDBC SQL code with our new Spring Data code. Let’s
    take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we need to add the new `EventRepository` interface and replace
    the SQL code with the new ORM repository, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we need to refactor the DAO classes to support the new `CrudRepository`
    interfaces we have created. Let’s begin by refactoring the `JdbcCalendarUserDao.java`
    file. First, we can rename the file `JpaCalendarUserDao.java` to indicate that
    this uses JPA, not standard JDBC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, the update fragments to leverage the JPA repositories
    have been placed in bold, so now the `Event` and `CalendarUser` objects are mapped
    to our underlying RDBMS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application will not work at this point, but this can still be considered
    a marker point before we continue to the next steps of conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your source code should look the same as `chapter05.03- calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Application services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only thing left to do is configure Spring Security to use the new artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to edit the `DefaultCalendarService.java` file and only remove the
    remaining code that was used to add `USER_ROLE` to any new `User` object that
    was created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The UserDetailsService object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps to add the `UserDetailsService` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a new implementation of the `UserDetailsService` object;
    we will use our `CalendarUserRepository` interface to authenticate and authorize
    users again, with the same underlying RDBMS, but using our new JPA implementation,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have to configure Spring Security to use our custom `UserDetailsService`
    object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the application and try logging in to the application. Any of the configured
    users can now log in and create new events. You can also create a new user and
    will be able to log in as this new user immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `calendar05.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring from an RDBMS to a document database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Luckily, with the Spring Data project, once we have a Spring Data implementation,
    we have most of the difficult work completed. Now, there are only a few implementation-specific
    changes that need to be refactored.
  prefs: []
  type: TYPE_NORMAL
- en: Document database implementation with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to work on refactoring our RDBMS implementation—with JPA as
    our ORM provider—to a document database implementation, using MongoDB as our underlying
    database provider. MongoDB is a free and open-source cross-platform document-oriented
    database program. Classified as a NoSQL database program, MongoDB uses JSON-like
    documents with schemas. MongoDB is developed by MongoDB Inc. and is located at
    [https://github.com/mongodb/mongo](https://github.com/mongodb/mongo).
  prefs: []
  type: TYPE_NORMAL
- en: Updating our dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already included all of the dependencies you need for this chapter,
    so you will not need to make any updates to your `build.gradle` file. However,
    if you are just adding Spring Data JPA support to your own application, you will
    need to add `spring-boot-starter-data-jpa` as a dependency to the `build.gradle`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we removed the `spring-boot-starter-jpa` dependency. The `spring-boot-
    starter-data-mongodb` dependency will contain all the dependencies needed to wire
    our domain objects to our embedded MongoDB database, with a mix of Spring and
    MongoDB annotations.
  prefs: []
  type: TYPE_NORMAL
- en: We also added the `Flapdoodle`-embedded MongoDB database, but this is only meant
    for testing and demonstration purposes. Embedded MongoDB will provide a platform-neutral
    way to run MongoDB in unit tests. This embedded database is located at [https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo](https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo).
  prefs: []
  type: TYPE_NORMAL
- en: Reconfiguring the database configuration in MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will begin to convert the current JBCP calendar project. Let’s begin
    by reconfiguring the database to use the Flapdoodle-embedded MongoDB database.
    Previously, when we updated the dependencies for this project, we added a Flapdoodle
    dependency that gave the project an embedded MongoDB database, which we could
    automatically use instead of installing a full version of MongoDB installation.
    To stay consistent with the JBCP application, we need to change the name of our
    database. With Spring Data, we can change the MongoDB configuration using the
    YAML configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The most important configuration for our current requirements is changing the
    database name to `dataSource`, which is the same name we used throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the MongoDB database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the JPA implementation, we used the `data.sql` file to initialize the
    data in our database. For MongoDB implementation, we can remove the `data.sql`
    file and replace it with a Java configuration file, which we will call `MongoDataInitializer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will be executed at load time and will seed the same data into our MongoDB
    as we did with our H2 database.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping domain objects with MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by mapping our `Event.java` file so that each of the domain objects
    is saved as a document in our MongoDB database. This can be done by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a document database, domain object mapping is a little different, but
    the same ORM concepts hold true. Let’s begin with the `Event` JPA implementation,
    and then we can transform our `Entity` to document mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In entity-based JPA mapping, we needed to use six different annotations to
    create the required mapping. Now, with document-based MongoDB mapping, we need
    to change all the previous mapping annotations. Here is a fully refactored example
    of our `Event.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we can see the following notable changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we declare the class to be of type `@o.s.d.mongodb.core.mapping.Document`
    and provide a collection name for these documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the `Event` class must implement the `o.s.d.domain.Persistable` interface,
    providing the primary key type (`Integer`) for our document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we change the annotation for our domain ID to `@o.s.d.annotation.Id`, to
    define the domain primary key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Previously, we had to map our owner and attendee `CalendarUser` object to two
    different mapping annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we only have to define the two types to be of type `@o.s.d.mongodb.core.mapping.DBRef`
    and allow Spring Data to take care of the underlying references.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final annotation we have to add defines a specific constructor to be used
    for new documents to be added to our document, by using the `@``o.s.d.annotation.PersistenceConstructor`
    annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have reviewed the changes needed to refactor from JPA to MongoDB,
    let’s refactor the other domain object, starting with the `Role.java` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final domain object that we need to refactor is our `CalendarUser.java`
    file. After all, this is the most complex domain object we have in this application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the effort to refactor our domain objects from JPA to MongoDB
    is fairly simple, requiring less annotation configuration than the JPA configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data repositories of MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have only a few changes to make to refactor from a JPA implementation
    to a MongoDB implementation. We will begin by refactoring our `CalendarUserRepository.java`
    file by changing the interface that our repository extends, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: sw `RoleRepository.java` files accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you need help with any of these changes, remember the source for `chapter05.05`
    will have the completed code available for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: Data access objects in MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `EventDao` interface, we are required to create a new `Event` object.
    With JPA, we can automatically generate our object ID. With MongoDB, there are
    several ways to assign primary key identifiers, but for the sake of this demonstration,
    we are just going to use an atomic counter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There was technically no change to our `CalendarUserDao` object, but for consistency
    in this book, we renamed the implementation file to denote the use of `Mongo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There are no other **Data Access Object** (**DAO**) changes required for this
    refactoring example.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and start the application, and it will behave just as before.
  prefs: []
  type: TYPE_NORMAL
- en: Try to log in as **user1** and **admin1**. Then test the application to ensure
    that both users can add new events to the system, ensuring the mapping is correct
    for the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the source from `chapter05.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at the power and flexibility of the Spring Data project and explored
    several aspects related to application development, as well as its integration
    with Spring Security. In this chapter, we covered the Spring Data project and
    a few of its capabilities. We also saw the refactoring process to convert from
    legacy JDBC code using SQL to ORM with JPA, and from a JPA implementation with
    Spring Data to a MongoDB implementation using Spring Data. We also covered configuring
    Spring Security to leverage an `ORM Entity` in a relational database and a document
    database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Spring Security’s built-in support for
    *LDAP-based authentication*.
  prefs: []
  type: TYPE_NORMAL
