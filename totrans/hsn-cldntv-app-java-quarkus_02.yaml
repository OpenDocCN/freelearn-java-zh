- en: Introduction to Quarkus Core Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java was introduced to the open source community over 20 years ago. Since then,
    we cannot think of a single large IT company or organization that doesn''t use
    Java. For this reason, Java is often regarded as a **corporate** language, which
    is not a bad thing *per se*: Java is the enterprise standard, and it''s an extremely
    mature language with a huge ecosystem of tools and libraries around it and still
    the most used language by developers in the world.'
  prefs: []
  type: TYPE_NORMAL
- en: 20 years in the IT industry is, however, a considerable amount of time. Since
    the beginning, Java has gone through a long list of optimizations with the burden
    of keeping backward compatibility with earlier releases. Today, however, the IT
    landscape has significantly changed with the rise of new standards such as the
    cloud, containers, microservices, and Reactive Programming. Do we still need to
    use Java to address the latest application architectures and reach a higher level
    of productivity and efficiency? Yes! This book promises to do this while teaching
    you about **Quarkus**, a Kubernetes-native framework that will take supersonic,
    subatomic Java to new heights!
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this book, we will learn how to create Quarkus applications
    with simple tools while using a development environment to code, execute, and
    debug them. After completing all the green bars, we will concentrate on advanced
    topics to show you how to combine multiple Quarkus extensions to produce a serverless
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as this chapter is concerned, we will have a quick tour of the Quarkus
    technology by covering these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the IT landscape, showing the benefits of cloud-native applications
    and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of the Quarkus architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the required software (GraalVM to compile code natively and a development
    environment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: From the big data hype to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About 10 years ago, the biggest buzz in the IT industry was the term *big data*.
    Every major enterprise was racing to harness the mystical powers of massive, yet
    supposedly manageable, silos of data. Equipped with big data, no problem would
    prove insurmountable, and all forecasts would be met.
  prefs: []
  type: TYPE_NORMAL
- en: But lately, these forecasts appear to have faded, and the worst-kept secret
    in the IT industry is that big data is dead – at least as we knew it. This doesn't
    mean that the volume or growth of data has broken down – or the opposite. It's
    just the underlying technology that has changed, which means that the architectures
    of applications that use big data have too.
  prefs: []
  type: TYPE_NORMAL
- en: Take Hadoop as an example, which has been the icon of the big data hype. It
    was designed based on a set of assumptions that dramatically changed in a short
    time. One of these assumptions was that, in order to process a large batch of
    data, network latency was the evil and cloud-native storage simply wasn't an option.
    At that time, most of the IT industry data was on-premise, so the focus was on
    avoiding moving around big sets of information. This meant that data was to be
    co-located in order to compute it efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, this scenario has changed quite a bit: most applications still use large
    amounts of data, but data is now processed on the fly. That is to say, we now
    stream data instead of processing the whole dataset multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, the network latency barrier has become less of an issue for cloud
    providers and there are even multiple cloud sources to choose from. Also, companies
    now have the option to deploy their own private cloud on-premise, leading to new
    scenarios such as **hybrid clouds**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the focus is what really changed: today, big data does not merely
    mean a **big** quantity of datasets but flexible storage options for a big quantity
    of data.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where containers and, specifically, Kubernetes fits in. In a nutshell,
    you can think of a container as a packaged application that contains just the
    libraries that are needed to run it, and Kubernetes is like an orchestrating system
    that makes sure all the containers have the appropriate resources while managing
    their life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes runs images and manages containers using **Docker**. However, Kubernetes
    can use other engines too (for example, `rkt`). Since we will be building our
    applications on top of Kubernetes, we will provide a short overview of its architecture
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes architecture in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The architecture of Kubernetes is focused around the concept of a loosely coupled,
    flexible mechanism for service discovery. Like most other distributed middleware
    platforms, a Kubernetes cluster is composed of one or more master nodes and multiple
    compute nodes. The following diagram depicts a high-level view of a Kubernetes
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c429d97-786f-47cd-b488-d902f5897574.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Kubernetes Master nodes** essentially make up the brain of the cluster. They
    are responsible for managing the overall cluster, exposing APIs, and scheduling
    deployments. **Kubernetes nodes** (right-hand side of the preceding diagram) contain
    the services that are needed to run applications in components called Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each **master node** contains the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API Server**: This synchronizes and validates the information running in
    Pods and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd**: This provides consistent and highly available storage for the cluster
    data. You can think of `etcd` as the brain''s shared memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller Manager server**: This checks for changes in the `etcd` service
    and uses its API to enforce the desired state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HAProxy**: This can be added when we''re configuring HA masters to balance
    loads between several master endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes nodes** (simply called **nodes**) can be considered workhorses
    of a Kubernetes cluster. Each node exposes a set of resources (such as computing,
    networking, and storage) to your applications. The node also ships with additional
    components for service discovery, monitoring, logging, and optional add-ons. In
    terms of infrastructure, you can run a node as a **virtual machine** (**VM**)
    in your cloud environment or on top of bare-metal servers running in the data
    center.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each node contains the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pod**: This allows us to logically group containers and pieces of our application
    stacks together. A Pod acts as the logical boundary for such containers with shared
    resources and contexts. Pods can be scaled at runtime by creating Replica sets.
    This, in turn, ensures that the required number of Pods is always run by the deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubelet**: This is an agent that runs on each node in the Kubernetes cluster.
    It makes sure that the containers are running in a Pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kube-Proxy**: This maintains network rules on nodes to allow network communication
    between Pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Runtime**: This is the software that is responsible for running
    containers. Kubernetes supports multiple container runtimes (such as Docker, `containerd`,
    `cri-o`, and `rktlet`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've covered the basics of the Kubernetes architecture, let's look
    at the top advantages that it can bring to your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advantages that Kubernetes can bring to your organization are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes greatly simplifies container management. As you have learned, when
    using Kubernetes, there's no need to manage containers directly. Instead, you
    just to have manage Pods. In order to have your applications available in your
    Pods, Kubernetes introduced an abstraction called a **service**. It defines a
    logical set of Pods with their IP address. This level of abstraction enhances
    fault tolerance and reduces downtime by launching containers on different machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes speeds up the process of building, testing, and releasing software
    by supporting a wide range of programming languages (Java, Go, Python, and so
    on) and offering advanced deployment features (automated rollouts and rollbacks,
    canary deployments, and more). This makes it a lot easier to configure effective
    **Continuous Integration/Continuous Delivery** (**CI/CD**) pipelines for your
    software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes provides the fastest and least costly horizontal scalability for
    your pods, so when the number of users for your application increases, you can
    configure the replication service to fire new Pods and balance the load across
    them to avoid downtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worth mentioning that Kubernetes is able to manage both stateless and stateful
    applications, because it allows ephemeral storage and persistent volumes. It also
    supports a number of storage types, such as NFS, GlusterFS, and cloud storage
    systems. Furthermore, a **persistent volume** (**PV**) life cycle doesn't depend
    on any pod using it, so you can keep the data as long as you need it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of using Kubernetes as a service orchestrator in your industry
    are clearly evident, but the next question is, how do we write our services to
    get the most out of this architecture? Can we still write our applications using
    the same standards we have learned about in the last few years? The next section
    will address this dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: From Java EE to MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Enterprise Edition** (**EE**) has reached an outstanding level of maturity
    and has a huge adoption in the IT Enterprise. A Java EE application is typically
    packaged as a monolithic application and deployed in an application server, which
    can host multiples of them.'
  prefs: []
  type: TYPE_NORMAL
- en: A monolithic application can be thought of as a self-contained application that
    includes both the user interface and the business components that are required
    to run the applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach has been widely used for years. The reason is simple: monolithic
    applications are conceptually simple to develop and package because everything
    is contained in a bundle and can be edited with a single IDE. Also, scaling monolithic
    applications is simple: all you need to do is scale a single component.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the traditional way of coding enterprise applications produced
    an extremely large set of applications that were supposed to be available as long-running
    processes and needed an application server to manage their **High Availability**
    (**HA**). In turn, some other tooling was needed to manage server restarts in
    the case of failures and to check the overall health of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As server-based monolithic applications continued growing, several disadvantages
    became evident, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Difficult to maintain**: This is due to the size of the applications, which
    makes it complex to create a patch for them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited scalability**: You can scale the whole application, not the single
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Longer release cycles**: Any changes that are made to the code require that
    we deploy the whole application, which complicates things when multiple teams
    are working on the same application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less isolation**: Deploying multiple applications in an application server
    can potentially lead to a whole system failure from a single application misbehaving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slower startup**: The startup time of a full monolithic stack is ill-famed
    to be slow, especially if multiple applications are deployed at the same time
    and potentially competing for the same resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex monitoring**: It is harder to monitor and tune the activity of a
    single monolithic application which delivers a myriad of metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More complex CI/CD**: Configuring a CI/CD pipeline for multiple monolithic
    applications is equally as hard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this scenario, a new paradigm called **microservices** emerged around a simple
    yet not new idea. The main theme behind microservices is that, for certain types
    of applications, once they are split into smaller and composable pieces, it's
    easier to build and maintain them. In a service-based architecture, we don't need
    to measure the uptime of our applications in weeks or months anymore since we
    can activate our services when they are needed. Therefore, the timing factor can
    be as little as minutes or seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In such an architecture, each component has its own life cycle spanning from
    development to testing, and the resulting application is simply the combination
    of all these single components. This approach marks a sensible departure from
    **monolithic** applications, where everything is built and tested as a single
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications that are built as a set of smaller modular components are simpler
    to understand, easier to test/debug, and easier to maintain over the application
    life cycle. A microservice architecture leverages the agility of your company
    by reducing the time it takes to deploy improvements to production. This approach
    has been tried and tested and is superior for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased resilience**: The microservice architecture increases the system''s
    overall capability to withstand any kind of unexpected failures or faults of components
    or networks by spinning up another component, even as the remaining application
    continues to function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer independence**: By working in smaller teams in parallel, you can
    speed up the work that''s being done, especially for large enterprise applications
    that are composed of teams that are geographically and culturally diverse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Fewer resources are demanded by smaller components. This means
    we can easily scale them to meet the increasing demand of only that specific component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD life cycle automation**: Single components fit smoothly into CD pipelines
    and scenarios that have complex deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simpler mapping with the business**: Microservice architectures are easier
    to map with the business domain logic since they have increasing independence
    and transparency across the organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To obtain the best results from our **Software as a Service** (**SaaS**), a
    methodology is required. In the next section, we will discuss the Twelve-Factor
    App methodology, which is recommended by developers for smoothly working and delivering
    applications with a focus on microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The Twelve-Factor App methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 2011, the Heroku founder Adam Wiggins published **the Twelve-Factor App**
    methodology, which soon became a key reference for building **Software as a Service**
    (**SaaS**) based on their own experiences. This methodology is not exclusive to
    any programming language but is compatible with a microservices architecture and
    is based on containers and CI/CD pipelines. Let''s take a look at the 12 factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code base**: You should build your application on top of one code base, tracked
    by a **Version Control System** (**VCS**). You should rely on a base repository
    for an individual application to ease CI/CD pipelines. It follows that deployments
    should be automatic so that everything can run in different environments without
    anything needing to be done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: Don''t push any dependencies to your project code base. Instead,
    use a package manager so that you will have all the dependencies synced across
    your environments to make sure you reproduce the same behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Config**: Store your configuration in environment variables. The configuration
    should be well parted from the code so that the configuration varies in terms
    of where the application has been deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backing services**: Services should be easily interchangeable so that you
    can manage your backing services as attached resources. You must be able to easily
    exchange the backing services from one provider to another without changing your
    code. This maximizes portability and helps maintain your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build, run, release**: There should be a clear and strict separation between
    the build, release, and run stages. You can achieve this by assigning a unique
    release ID and allowing releases to roll back. The automation between these stages
    should be as easy as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless processes**: This factor lies at the core of the microservices
    architecture. You should not be introducing state into your services. Any data
    that needs to be persisted must be stored in a backing service, typically a database
    or another storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port binding**: By this factor, your application should be completely self-contained.
    It should not depend on the runtime startup of a web server into the execution
    environment to create a frontend service. The web app should make HTTP applications
    as a service available by binding the service to a port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: You should break down your application into much smaller pieces.
    Smaller, well-defined apps allow you to scale out as needed to handle varying
    loads. You should be able to individually scale the single component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disposability**: You should aim to maximize the robustness of your systems
    by coding applications with a fast startup and graceful shutdown. This means you
    should be able to handle unexpected failures. A recommended approach consists
    of using a robust async backend that returns notifications when failures occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dev/prod Parity**: You should aim to keep the development, staging, and production
    phases similar and homogeneous to limit deviation and errors. This also implicitly
    encourages a DevOps culture where software development and operations are unified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logs**: Logging is a key factor for debugging and monitoring your application''s
    general health. The place where logs are stored shouldn''t be a concern for developers.
    Instead, these logs should be treated as a continuous stream that''s being separately
    captured and stored by a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin Processes**: In many cases, developers perform one-off administrative
    or maintenance tasks, such as database migrations, application patching, or one-time
    script execution for the app. It is essential to run one-off admin processes in
    an environment that is similar to the regular long-running processes of the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although some of the preceding patterns may seem trivial at first glance, they
    become essential building blocks as your services start to grow. Therefore, when
    designing your microservices applications, keep in mind that most challenges are
    not related just to coding, but rather to getting the basics wrong. As a matter
    of fact, even good teams fail at microservices when they don't have a culture
    that embraces DevOps and key building blocks such as the Twelve-Factor App methodology.
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile initiative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having discussed the methodology of microservices, we will now cover some aspects
    related to the specific API that can be used to develop microservices.
  prefs: []
  type: TYPE_NORMAL
- en: While, at first glance, it appears that Java and microservices don't really
    match, it would be a bad idea to discard the entire Java EE ecosystem (rebranded
    as **Jakarta EE** and transferred to the Eclipse Foundation) that has been created.
    A lot of effort has already gone into reusing Java EE for coding microservices.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, many major vendors, including IBM, Red Hat, and Payara,
    have already provided a lightweight and extensible runtime to power microservices
    and cloud deployments. Their individual efforts were naturally followed by an
    open collaboration within the **MicroProfile.io** initiative.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile components are built upon the model of Java EE, thereby making
    the transition to microservices development natural. This means you will be able
    to reuse the valuable knowledge of Java EE you have accumulated over the years
    to flexibly use multiple vendor specs to define application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In its initial release, the MicroProfile initiative included just a small cutdown
    of the Java EE API (JAX-RS 2.0, CDI 1.2, and JSON-P 1.0).
  prefs: []
  type: TYPE_NORMAL
- en: In a short time, however, new MicroProfile projects have been added. In 2018
    alone, we saw the advent of MicroProfile 1.3, 1.4, 2.0, and 2.1, and the projects
    contained in them. The current release of the MicroProfile initiative extends
    the standards with functionality that isn't part of Java EE, such as configuration,
    resiliency, monitoring, health checking, and distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the building blocks of MicroProfile projects
    according to the latest specification (at the time of writing this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66256e0f-6b46-4b99-8103-988b1f0ce0cf.png)'
  prefs: []
  type: TYPE_IMG
- en: MicroProfile alone, however, is mostly insufficient when it comes to developing
    a complex enterprise application. For example, it does not include an API for
    persistence, transaction, or **Security Socket Layer** (**SSL**) management out
    of the box. For this reason, we need a framework that leverages the MicroProfile
    API with extensible functionalities and can be orchestrated by Kubernetes, which
    is going to be the new application server, from the management point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus – a Kubernetes-native Java framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main challenges of a microservices architecture is that the proliferation
    of services can increase the complexity of your systems unless you have a valid
    framework to orchestrate them from. Also, without a centralized function for authentication,
    data management, and an API gateway, the advantages of a microservices architecture
    are invalidated by these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In this sense, the arrival of Kubernetes is a real revolution in IT patterns.
    With the help of Kubernetes-based orchestration, you can enhance efficiency and
    resource utilization by managing and scheduling your microservices in a dynamic
    manner. This also adds an advanced resiliency level. You can continue to operate
    as demand varies, without worrying about container failure. To close the circle
    and unify all the components, we need a framework that has been specifically thought
    of to work in this kind of architecture. Let's meet **Quarkus**.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus emerges as a first-class citizen when it comes to managing cloud-native
    enterprise applications and has lots of amazing features that can enable scenarios
    that haven't been possible before. As you will see in the upcoming sections, Quarkus
    is able to build thin native code from Java classes and create container images
    out of it that you can run on top of Kubernetes or OpenShift. Quarkus also leverages
    the best of the breed of Java libraries you have been working with for years,
    such as RESTEasy, Hibernate, Apache Kafka, Vert.x, and much more. Let's look at
    the highlights of this framework in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Native code execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Native code execution has been attempted several times during the long history
    of Java, but it never got much adoption by developers. First of all, it required
    some external tooling as this isn't provided out of the box by the platform's
    vendor. For monolithic applications, the advantage of native execution is minor
    because, in the long run, due to the advancement in the Hot Spot technology, the
    speed of Java can become closer to native execution (provided that you are willing
    to pay for a slower application bootstrap).
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, in a microservice scenario, spinning up a bunch of native services
    plays a crucial role, and even optimizing seconds or a fraction of a second can
    play a huge difference. In much the same way, if you aim to reach the highest
    memory density requirements, the maximum requests' throughput, along with a consistent
    CPU performance, Quarkus' native execution fits neatly in the picture.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you can smoothly transition to Quarkus using plain Java bytecode,
    still delivering applications with high memory density requirements, excellent
    CPU raw performance, advanced garbage collections tactics, a large set of libraries
    or monitoring tools that require the standard JDK, and the ubiquitous *compile
    once and run everywhere*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes some typical use cases for choosing between
    native applications and Java applications when developing with Quarkus:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Quarkus Native applications** | **Quarkus Java** **applications** |'
  prefs: []
  type: TYPE_TB
- en: '| Highest memory density requirements | High memory density requirements |'
  prefs: []
  type: TYPE_TB
- en: '| More consistent CPU performance | Best raw performance (CPU) |'
  prefs: []
  type: TYPE_TB
- en: '| Fastest startup time | Fast startup time |'
  prefs: []
  type: TYPE_TB
- en: '| Simpler garbage collection | Advanced garbage collection |'
  prefs: []
  type: TYPE_TB
- en: '| Highest throughput | A large set of libraries and tools that only work with
    JDK |'
  prefs: []
  type: TYPE_TB
- en: '| No JIT spikes | Compile once, run anywhere |'
  prefs: []
  type: TYPE_TB
- en: As resulting from this picture, Quarkus is a breakthrough as it leverages native
    code execution while preserving the capability for you to run your services with
    OpenJDK and use Hot Spot's rich dynamic code execution capabilities when required.
  prefs: []
  type: TYPE_NORMAL
- en: Container first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As anticipated, one of the most promising features of Quarkus is the capability
    to automatically generate container images out of your applications. The minimal
    footprint of native applications is optimized to be run inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: Generating container images of your native applications also defeats one common
    pitfall related to native execution, which is potential conflicts or errors when
    the build was done with a different OS. Since the container wraps the OS of your
    choice, you can provide container-safe native builds of your applications without
    hitting the risk of crash dumps or the infamous blue screen scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Unifying the imperative and Reactive Programming models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Java developers are familiar with the imperative programming model, which
    translates into a sequence of instructions that are used to modify an object's
    state. On the other hand, asynchronous programming has always been a challenge
    for Java developers due to its inherent complexity and the lack of a solid pattern
    for propagating asynchronous changes. In this context, a paradigm called **Reactive
    Programming** has gained popularity due to its ability to conjugate the asynchronous
    programming pattern with data streams and the propagation of change.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus has been designed from the ground up to unify the two models in the
    same platform so that you can take the benefits of both programming models and
    use them in your IT organization.
  prefs: []
  type: TYPE_NORMAL
- en: Coding that sparks joy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even the most powerful framework available wouldn't gain widespread adoption
    if it were overly complex to use and required lots of coding and configuration
    to accomplish even minor functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have learned from Spring Boot''s success, developers are more productive
    with a framework that doesn''t require you to spend lots of time on its setup
    or configuration. Out of the box, Quarkus provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A unified configuration that can be easily maintained in a single property file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large set of defaults so that you can actually write applications, even with
    no configuration at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides this, you can have extraordinary features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Live reload of applications, without any third-party plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Straight to container generation with native executables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified testing by adding testing extensions built specifically for Quarkus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best-of-breed Java libraries and standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The criterion that makes a development stack a successful one is a combination
    of various things, such as an active number of contributors, a high degree of
    recognition and use by top industrial actors, compliance to well-known standards,
    and strong and active criteria validators.
  prefs: []
  type: TYPE_NORMAL
- en: On this matter, Quarkus brings a cohesive, full-stack framework by leveraging
    the best-of-breed libraries you are already familiar with, which are automatically
    wired together to produce the final artifact. Quarkus extensions include the full
    Eclipse MicroProfile Stack, a persistence API (JPA), a transaction manager (Narayana),
    a reactive framework (Vert.x), an asynchronous event-driven network application
    framework (Netty), and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus also includes an extension framework that third-party component authors
    can leverage to extend the framework. The Quarkus extension framework greatly
    reduces the complexity of making third-party frameworks run on Quarkus and compile
    to a native binary.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know about some of the highlights of Quarkus, let's have a more
    in-depth look at the architecture of this framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of Quarkus, there is the **core** component that does the hard
    work of rewriting our application in the build phase so that super-optimized native
    executable and Java-runnable applications can be generated. To do that, Quarkus
    **core** requires the cooperation of a set of tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jandex**: This is a space-efficient Java annotation indexer and offline reflection
    library that''s able to index all runtime visible Java annotations and class hierarchies
    for a set of classes into a memory-efficient representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gizmo**: This is a bytecode generation library used by Quarkus to produce
    Java bytecode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraalVM**: This is a set of components. Every component has a specific function,
    such as a compiler, an SDK API for the integration of Graal languages and the
    configuration of native images, and a runtime environment for JVM-based languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SubstrateVM**: This is a subcomponent of GraalVM that allows for the **ahead-of-time**
    (**AOT**) compilation of Java applications of Java programs into self-contained
    executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving on to the list of available Quarkus extensions, first and foremost, Quarkus
    fully implements the MicroProfile specifications. Quarkus also includes a set
    of extensions for Hibernate ORM for handling persistence, a transaction manager
    (Narayana), a connection pool manager (Agroal), plus several more, such as an
    API for Apache Kafka, Camel Routes, and the ability to run reactive applications
    (Vert.X).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the core components of the Quarkus architecture,
    although the list of available extensions cannot be exhaustive for the sake of
    brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a630408-ce48-4a88-b1a5-108025088b33.png)'
  prefs: []
  type: TYPE_IMG
- en: Having covered the basics of the Quarkus architecture, without further ado,
    we will now shift our attention to the installation of the tools that we'll need
    in order to build and run Quarkus applications. Our to-do list isn't that long
    and will be addressed shortly. In the next section, we will be installing GraalVM
    and a development environment for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with GraalVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile Java code into native executables, you will need an extension of
    the virtual machine called **GraalVM**. To be precise, GraalVM is a universal
    virtual machine that facilitates the compilation of the bytecode of various languages
    (such as Python, JavaScript, Ruby, and so on). In addition to this, it allows
    for the integration of those languages in the same project. It has a few other
    features as well, among which is one that offers **Substrate VM**, a framework
    that allows AOT compilation for applications written in various languages. It
    also allows us to compile JVM bytecode into a native executable.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM is similar to any other JDK available from other vendors, except that
    it has **Java-based JVM Compiler Interface** (**JVMCI**) support, and it uses
    Graal as its default JIT compiler. Therefore, it can't *just* execute Java code
    but also languages such as JS, Python, and Ruby. This can be done through a language
    abstract syntax tree interpreter called **Truffle**, which was developed by Oracle
    in association with GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts a high-level view of the GraalVM stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9293c0d5-0ca0-4101-8f3d-1579a89bc838.png)'
  prefs: []
  type: TYPE_IMG
- en: All of this sounds great, but GraalVM comes with a price as well. The dynamic
    nature of Java is severely constrained; for example, there's the default reflection
    mechanism, which will not work unless a class/member has been explicitly registered
    for reflection. Also, class loading at runtime, dynamic proxies, and static initializers
    require, at best, some changes/workarounds in order to work.
  prefs: []
  type: TYPE_NORMAL
- en: How does Quarkus overcome these limitations? The trick is to move as much framework
    initialization at build time. During this phase, Quarkus is able to discover which
    classes need reflection at runtime through metadata discovery (such as annotations).
    Quarkus uses a set of tools such as Jandex to optimize annotation processing and
    bytecode generation. Also, to overcome other limitations of GraalVM, Quarkus uses
    a single-pass, single class loader and programmatically provides compiler hints
    to enable extensive dead code elimination, thereby substantially cutting down
    the size of the executable file.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we will install GraalVM from [https://www.graalvm.org/](https://www.graalvm.org/).
    As you will see from the Downloads page, the Community and Enterprise GraalVM
    editions are available. In this book, we will be using the Community Edition,
    so proceed by downloading the community version that fits with your OS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GraalVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to get started with GraalVM. You can either download
    the zipped binary for your operating system or build it from the source. For the
    purpose of this book, we will choose the former option. The installation steps
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Downloads page and choose **Community Edition**. You will be
    redirected to the GitHub project where the project is hosted. Download the archive
    that matches with operating system. **Please note that the recommended version
    of GraalVM to use with Quarkus 1.0.0.final is the version 19.2.1**. As a matter
    of fact, the newer 19.3.0 version does not meet the requirements of Quarkus 1.0.0.final.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the archive to your filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have the following top-level structure in the folder where GraalVM
    has been extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the top-level structure of GraalVM is quite similar to the
    JDK. In the `bin` folder, you will find many utilities and replacements for JDK
    tools. Notably, when you use the `java` command in GraalVM, it runs the JVM and
    the default compiler, which is Graal. `javac` can be used to compile your code.
    Apart from this, the following commands are essentials when it comes to leveraging
    the native and polyglot functionalities of GraalVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '`js`: This command can be executed to run plain JavaScript code if we pass
    a set of options and the JavaScript filename as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node`: This command can be used to run Node.js-based applications. It relies
    on the `npm` command to install Node.js modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native-image`**:** This command takes your Java class(es) and builds an AOT
    compiled executable or a shared library. It is not included by default in most
    recent GraalVM installations and you need the `gu` tools to install it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm`: This is the package manager for Node.js. It puts modules in place so
    that `node` can find them and manages dependency conflicts intelligently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lli`**:** This is an LLVM bitcode interpreter that can execute LLVM bitcode
    in a managed environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gu`**:** This tool can be used to install language packs for Python, R, and
    Ruby, as well as the native-image tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is export the path where GraalVM has been
    installed into our environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, it is recommended to complete the installation adding the `bin`
    folder of GraalVM to your OS''s `PATH`. For example, on Linux, we would do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can resolve to the GraalVM installation directory by setting
    the `JAVA_HOME` environment variable like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding environment settings should be added to the script that initializes
    your shell. For most Linux distributions, this means putting them in the `.bashrc`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have set the `PATH` environment variable, it''s pretty simple to
    check language versions with GraalVM''s launchers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The executables belonging to all the language runtimes in GraalVM emulate the
    behavior of the languages' default runtimes. It should be enough to include GraalVM
    at the beginning of your `PATH` environment variable in order to run your applications
    with GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Java application with GraalVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test whether your GraalVM environment works correctly, we will be adding
    a minimal Java class and running it. Open an editor and create the following `Main`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile this class into bytecode and then run it on GraalVM using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Building native images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have tested the compilation and execution of Java bytecode, we
    will convert the bytecode into native executables to achieve faster startup and
    a smaller footprint for our applications. In order to do that, we need the `native-image`
    tool, which allows us to AOT compile Java code into a standalone executable. We
    can install the `native-image` tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful installation, we can use the `native-image` tool against the
    same `HelloWorld` Java class we have created. Run the following command to build
    a native image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This builds an executable file, just 2 MB in size, named `main` in the current
    working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking it executes the natively compiled code of the `Main` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once that we have verified that our installation of GraalVM works, we can install
    a development environment, which will be needed to run the examples contained
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing a development environment becomes less significant as we move away
    from monolithic development, where a large set of plugins is often required to
    build the complex interaction between the application layers. Therefore, we can
    choose any IDE that is capable of importing/exporting Maven or Gradle projects
    natively, as well as a decent set of features for speeding up our code or refactoring
    it. We will be using **IntelliJ IDEA**, which we can download from [https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see from the download page ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)),
    both the Ultimate and Community versions are available. We will be using the latter,
    which can be freely downloaded. Choose to download the latest binary for your
    operating system. Then, unzip it into a folder of your preference (for example,
    in your `Home` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, move into the `bin` folder of the installation and execute it with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's have a minimal overview of the development environment's visual elements.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of IntelliJ IDEA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we won''t be focusing on a specific development environment to learn
    about Quarkus, we will provide a short overview of the visual elements that comprise
    IntelliJ IDEA to understand what actions you can do in a quicker and easier manner.
    As shown in the following screenshot, these are the main elements of the IntelliJ
    IDEA interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f35f8a8-6947-42f4-a30f-0e5c7f406e9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the various highlighted sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Menu bar**: The menu bar includes options we can use to create or import
    projects and other key actions related to projects, such as code refactoring,
    builds, run, debug, version-control options, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Toolbar**: The toolbar contains some shortcuts for common execution actions,
    such as compile, debug, and run. You can also customize it according to your requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Navigation bar**: The navigation bar enables navigation between sources within
    a project. This feature will come in handy as your code base grows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tools tab**: The tools tab, which can show up on either side of the main
    window, lets you access key tools such as Maven/Ant builds, databases, and so
    on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project perspective**: The project perspective window contains all the elements
    of your project, such as packages, modules, classes, external libraries, and so
    on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Editor window**: This is where you edit your code in IntelliJ IDEA using
    advanced features such as syntax highlighting, smart completion, quick-fix suggestions,
    and other useful features.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! In the next chapter, we will be creating a simple application with Quarkus
    that we will import into IntelliJ IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: Installing IntelliJ Plugin for Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before closing this chapter, it is worth mentioning that IntelliJ IDEA includes
    in its plugin marketplace a plugin to bootstrap Quarkus applications. You can
    install it through the **File | Settings | Plugin** top menu option. Once you
    have selected the Plugin option, search for "quarkus" in the marketplace text
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once found it, click on the Install button as depicted by the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2eb04dfe-e1be-4074-9dd3-5d0863477320.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Restart the IDE for the changes to take effect. Once that the Plugin has been
    installed, you can add new Quarkus projects directly from the IDE. Here is a snapshot
    of the updated list of Projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/355a7971-dccb-441e-95d1-300b7edde452.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The project wizard will guide you through the selection of the Maven coordinates
    of your project and the extensions you want to have included in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8c10044-3faa-40a5-b4d7-eddc0fe65a33.png)'
  prefs: []
  type: TYPE_IMG
- en: Before sailing into unknown waters, we will pause for a while to briefly recap
    what we have learned in this chapter. Then, grab a cup of tea and get ready for
    departure!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got an overview of the current landscape of the IT industry.
    As we have learned, Kubernetes adds a completely new dimension to traditional
    language-based building blocks by offering a new set of distributed services and
    a runtime environment for creating distributed systems that spread across multiple
    nodes. Although the core principles of creating containerized applications don't
    strictly require that you decompose your monolithic applications in single services,
    there are evident advantages in doing so in terms of isolation, scalability, team
    independence, monitoring, resilience, and life cycle automation.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we discussed the actual applications that can run natively by introducing
    Quarkus, an amazing framework where we can create serverless, native applications
    without losing the skills we learned as Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've installed the required tools to get started with Quarkus, in
    the next chapter, we will code our first example application.
  prefs: []
  type: TYPE_NORMAL
