<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing the Modular JDK</h1>
                
            
            <article>
                
<p class="calibre2">In the previous two chapters, you've learnt about the modular API in Java 9 and how to create your own custom modules. There's much more to Java 9 modules than that! The introduction of modularity in Java is not just a new <em class="calibre22">feature</em> for developers to use; it has resulted in major changes to the Java platform itself. In fact, Java 9 also has had perhaps the biggest overhaul of the internal Java codebase ever. Java 9 not only comes with the ability for developers to create their own modules, the whole Java platform itself has been modularized. In this chapter, let's examine these important changes, both to learn what the changes are, and to understand <em class="calibre22">why</em> they came about. Now that you have warmed up to Java modules by writing modules yourself, it's time to put our thinking caps on and really understand the problems and the requirements that resulted in this major change in the Java language. Not only will it help us appreciate the changes better, learning how and why the JDK was modularized will help us apply these lessons when we learn how to migrate our own Java code to Java 9 in <a target="_blank" href="part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 11</a>, <em class="calibre22"><span>Migrating Your Code to Java 9</span></em>.</p>
<p class="calibre2">Here are the topics that we'll cover in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">We'll start by examining two aspects of the JDK as they were before Java 9 and some problems with them. It's important for us to know the way things were, so that we can fully understand the effect of the new changes.</li>
<li class="calibre15">You'll learn how modularity has transformed the Java platform and be introduced to the built-in modules.</li>
<li class="calibre15">You'll learn how to browse built-in modules and get information about their module definitions.</li>
<li class="calibre15">You'll learn how to understand module relationships in a module graph.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Examining the legacy JDK</h1>
                
            
            <article>
                
<p class="calibre2">Java has been around for over two decades now. For the most part of its lifetime, there have been a few things that haven't changed. Let's focus our attention on two aspects of the JDK the way they were in Java 8 or earlier:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">The JRE structure</strong>: The file and directory structure that <strong class="calibre1">Java Runtime Environment</strong> (<strong class="calibre1">JRE</strong>) is installed as when it is set up on a computer</li>
<li class="calibre15"><strong class="calibre1">The state of API encapsulation</strong>: The differences between the <em class="calibre22">public</em> Java APIs and the internal platform classes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The JRE structure</h1>
                
            
            <article>
                
<p class="calibre2">When you install the Java 8 Runtime Environment on any machine and examine the installed directory, you'll see, among other files and folders, the following two important directories:</p>
<ul class="calibre14">
<li class="calibre15">A <kbd class="calibre12">bin</kbd> directory with executable files, an important one of which is the Java executable that lets you run Java programs</li>
<li class="calibre15">The <kbd class="calibre12">lib</kbd> directory with some key <kbd class="calibre12">.jar</kbd> files including the all-important <kbd class="calibre12">rt.jar</kbd></li>
</ul>
<p class="calibre2">You may not have had to deal with the <kbd class="calibre12">rt.jar</kbd> directly when coding in Java, but you should know that it's the single most important <kbd class="calibre12">jar</kbd> file in the runtime. Can you guess what it's for?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding rt.jar</h1>
                
            
            <article>
                
<p class="calibre2">Let's say you build a Java application that uses some core library classes such as collections and threads. When you compile and distribute your application to be run on another machine with Java installed, you can get away with packaging just the classes you've written in your application, and <em class="calibre22">not</em> include the compiled <kbd class="calibre12">Collection</kbd> and <kbd class="calibre12">Thread</kbd> classes. That's because every runtime comes with all the compiled platform classes out-of-the-box, so that every developer doesn't have to distribute them with their applications. The way these classes are bundled into the JRE is through a single file--<kbd class="calibre12">rt.jar</kbd>. You'd place your application classes in the classpath for the runtime to find, but for any of the platform classes, it just finds them in <kbd class="calibre12">rt.jar</kbd>. The name <kbd class="calibre12">rt</kbd> stands for <strong class="calibre1">Run Time</strong>, and this single jar file holds the entire Java runtime. Yes, you read that right! <kbd class="calibre12">rt.jar</kbd> essentially contains all the compiled classes in the Java platform, all bundled into one JAR file. Every. Single. One. Of. Them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The problem with this model</h1>
                
            
            <article>
                
<p class="calibre2">This has been the state of affairs for multiple Java releases now. The decision to bundle all the platform classes into a single JAR file was made quite early in Java's life and it might have been a good idea at the time. But considering how much the platform has grown and how many new classes have been added to the platform over the years, it's clearly not a good idea anymore. With Java 8, the <kbd class="calibre12">rt.jar</kbd> measures close to 60 MB in size. And even if you might find it bearable now, imagine how it would scale, if say, Java continues to grow at a good pace for the next 10 years and ends up having a few thousands more classes added. Would we still be fine with bundling them all into a single jar file then?</p>
<p class="calibre2">In addition to the platform developers having to deal with the monolithic JAR file, here's another logistical challenge that this model brings up. A common practice for application developers to distribute their application is to bundle their app installers with the Java Runtime Environment. Any Java app requires the runtime anyway, but there's no knowing if the users of the Java application have the runtime installed on their machines beforehand. So, bundling the app with the runtime is a great way to make sure anyone who installs the app has the necessary runtime and can execute the app successfully. This is true not just for classic desktop application installers, but also for the newer practice of creating self-contained micro-services. Developers building micro-services create distributables that contain both the compiled micro-services as well as the Java runtime so that a micro-service instance can be kicked off on any virtual machine on the cloud by a single command.</p>
<p class="calibre2">The size of the runtime is clearly a problem here. No matter the complexity of your micro-service or application, irrespective of how many classes in the platform you use, you have to bundle in the complete Java runtime with the <kbd class="calibre12">rt.jar</kbd> that contains every Java platform class that's known to exist. So, no matter how small your actual application is, bundled with it is at least 60 MB of <kbd class="calibre12">rt.jar</kbd> goodness! Also affected are Java applications that run on smaller devices with resource constraints such as IOT and mobile devices. We briefly discussed in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity</em>, the CORBA classes in the Java platform and how it exists in all Java runtimes since a very long time, although hardly anyone seems to use it anymore. As someone creating a self-contained Java executable, it's very fair to ask the question--why do I need to include all these classes in the runtime when I don't need them?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The attempted solution - Compact profiles</h1>
                
            
            <article>
                
<p class="calibre2">With Java 8, there was an introduction of a new concept called <strong class="calibre1">compact profiles</strong> to attempt to solve this very problem. Compact profiles are essentially smaller versions of the Java runtime that does not have to include the entirety of the contents of <kbd class="calibre12">rt.jar</kbd>. The runtime was broken down at package level to identify a closed set of core packages and classes that only depend on themselves so that the rest can be broken off and removed. There were three different profiles introduced, varying on how much was stripped off. The smallest and the most minimum profile is called <kbd class="calibre12">compact1</kbd>. This version of the runtime contains the very basic language features such as IO, collections, util, security, and concurrency. If your needs aren't met with <kbd class="calibre12">compact1</kbd>, you could also choose between <kbd class="calibre12">compact2</kbd> and <kbd class="calibre12">compact3</kbd>, and if none of the three work for you, you would go with the full runtime:</p>
<div class="packt_figure"><img class="image-border37" src="../images/00043.jpeg"/></div>
<p class="calibre2">The smallest profile, <kbd class="calibre12">compact1</kbd>, measures just about 11 MB in size, and is a significant improvement from the 60 MB of the full <kbd class="calibre12">rt.jar</kbd>. But it's obvious that we still haven't eliminated the problem of bundling in runtime classes that aren't needed. We've just minimized them, and there are still going to be classes in whatever profile you choose that your application never uses, but you have to include anyway. Additionally, if you have an application that mostly uses classes from the <kbd class="calibre12">compact1</kbd> profile, but needs just a couple of classes from <kbd class="calibre12">compact2</kbd>, well, you have no choice but to bundle the bigger <kbd class="calibre12">compact2</kbd> profile instead.</p>
<p class="calibre2">I would, however, hesitate to call this a failed attempt at solving this problem. In fact, runtime profiles are actually the first steps in the Java platform's journey to modularizing of the runtime. However, it is important to note that this is the best we could do pre-Java 9 to address the issue of a bulky monolithic runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The state of API encapsulation</h1>
                
            
            <article>
                
<p class="calibre2">To best explain the situation (and associated problems) with API encapsulation, all we need to do is recall from <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity,</em> Jack's trouble with his sorting library. He had an internal <kbd class="calibre12">public</kbd> class in his library that wasn't meant for external use, but it did end up getting used. If such a small library with the meagerly count of two classes could run into this problem, imagine the situation with the Java runtime with thousands of classes! The Java language provides documented APIs for developers to use. But it also has many supporting classes to facilitate the inner workings of those APIs that shouldn't be used by developers. However, surely enough, they are all a part of the sole <kbd class="calibre12">rt.jar</kbd>, so there's nothing stopping developers from using those classes either.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding internal APIs</h1>
                
            
            <article>
                
<p class="calibre2">There are several internal classes in the Java runtime that developers aren't supposed to use. They aren't documented as part of the language specification, but are necessary for the internal functioning of the runtime, perhaps for other classes that <em class="calibre22">are</em> documented. A great example that's much discussed among Java developers in online communities is a class called <kbd class="calibre12">sun.misc.Unsafe</kbd>, which we briefly mentioned in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity</em>.</p>
<p class="calibre2">The class <kbd class="calibre12">sun.misc.Unsafe</kbd> was never meant for public consumption. It was always supposed to be an internal class meant for use by the Java runtime only. It is not documented. It has no public constructors. The source code of the class is filled with warnings about the dangers of using the class. It's funny that even the fact that the class having the ominous sounding name <kbd class="calibre12">Unsafe</kbd> hasn't deterred some developers from using it. Of course, <kbd class="calibre12">sun.misc.Unsafe</kbd> is one of a handful of internal classes that have been misused by Java developers. But if it's just a handful of classes, you might ask, what's the big deal?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The problem with this model</h1>
                
            
            <article>
                
<p class="calibre2">Java is commonly known to be a very <strong class="calibre1">backwards compatible</strong> language. While the language itself has seen major changes over the years, almost all the changes have been additions to the language, while still retaining the functionality of the older versions. Let's say you picked up a Java codebase written with Java 1.3 and you compiled and ran it with Java 8. Would you be surprised if it ran without issues? Probably not! That's precisely because of the reputation Java has of being backward compatible. And it's a great thing in my opinion, because it gives adopters the confidence that there's not a lot of effort and rewrites required for every major upgrade. This is an aspect where Java has an edge over a few other development platforms.</p>
<p class="calibre2">This backward compatibility comes with a cost, especially when you consider the lack of encapsulation of internal APIs. What if there is an internal API that developers have inadvertently used because of the lack of encapsulation? To maintain backward compatibility, the language team is compelled to not make breaking changes to those internal APIs even though they are, by definition, internal. So, the burden of backward compatibility gets worse for the language--not only do public APIs have to be backward compatible, even the internal runtime classes need to be as well!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The attempted solution - Deprecation, warnings, and documentation</h1>
                
            
            <article>
                
<p class="calibre2">We routinely import classes from packages such as <kbd class="calibre12">java.*</kbd> and <kbd class="calibre12">javax.*</kbd> in our code because the classes in those packages house most of the public APIs in the Java language that are meant for public consumption. There are, however, classes in other packages such as <kbd class="calibre12">sun.*</kbd> that are JDK-internal and you wouldn't find in any API documentation. Many of these classes have been a part of Java since 1.0.</p>
<p class="calibre2">Since the language had no facility to prevent usage of these internal APIs, several other attempts have been made to discourage usage. There was an article on the Sun website titled <em class="calibre22">Why developers should not write programs that call 'sun' packages</em>. The Sun website isn't up anymore, but the article's original webpage is still preserved for posterity, thanks to WayBack Machine, and is available here: <a href="http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html" class="calibre4"><span>http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html</span></a><span>:</span></p>
<div class="packt_figure"><img class="image-border38" src="../images/00044.jpeg"/></div>
<p class="calibre2">Notice the year mentioned on the article! Yes, it's been around as a part of the official documentation since back in 1996 (then on <span>java.sun.com</span>)! The warning is still around on the Oracle documentation website, by the way. Clearly, 20 years of asking developers not to use certain classes hasn't solved the problem! You might very well ask, what good is such a warning in documentation if nobody pays attention to it? Well, in addition to warnings in documentation, since JDK 6, the compiler has been throwing out warnings if your application uses any APIs from the <kbd class="calibre12">sun.*</kbd> packages. However, this is also something that developers could easily ignore.</p>
<p class="calibre2">These approaches are clearly not good enough. We need to be able to enforce these rules and provide guardrails to <em class="calibre22">prevent</em> developers from using internal APIs. There was no such feature available in the language so far. The language just had to evolve.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enter Project Jigsaw</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre22">Project Jigsaw</em> was the effort to apply the concepts and features of modularity to the Java platform itself. The modularization of the platform essentially solves both the problems described previously. We'll look at how later in this chapter, but let's begin looking at the work that was done for <em class="calibre22">Project Jigsaw</em> and how it affects developers interacting with the Java platform.</p>
<p class="calibre2">The project itself was a huge effort that involved the following high-level steps:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Re-organizing the platform source code to make it more conducive for modularization.</li>
<li value="2" class="calibre15">Defining and building modules with predefined input and output interfaces and with a clear dependency map.</li>
<li value="3" class="calibre15">Encapsulating <em class="calibre22">internal</em> classes and allowing usage for only <em class="calibre22">public</em> APIs.</li>
<li value="4" class="calibre15">Providing tools for generating smaller and modular runtime images as an alternative to the monolithic <kbd class="calibre12">rt.jar</kbd>.</li>
</ol>
<p class="calibre2">Let's deep-dive into the changes now and see how it affects us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Platform modularity</h1>
                
            
            <article>
                
<p class="calibre2">With Java 9, the entire Java platform, with every class in it, has been segregated and grouped into modules. Yes, all of the platform Java classes from <kbd class="calibre12">Collections</kbd> and <kbd class="calibre12">Thread</kbd> to <kbd class="calibre12">Connection</kbd> and <kbd class="calibre12">Logger</kbd>! It doesn't really matter which one; every platform class is now housed in newly created Java modules that come out-of-the-box with the runtime and the JDK. The platform team achieved this by going through both the public APIs and internal classes, grouping them based on the types that usually go well together and are self-contained, and bundling such related classes into modules.</p>
<p class="calibre2">Take Java logging for example. The native logging functionality in Java comprised of a group of classes in the package <kbd class="calibre12">java.util.logging</kbd>. These classes have now been grouped into a newly created module called <kbd class="calibre12">java.logging</kbd>. The JDBC and SQL related classes have all gone into a new module called <kbd class="calibre12">java.sql</kbd>. XML related classes have gone into the module <kbd class="calibre12">java.xml</kbd>. Here are a few more examples of modules that come out-of-the-box with Java 9:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">java.scripting</kbd>: Provides the scripting APIs for the Java scripting engine</li>
<li class="calibre15"><kbd class="calibre12">java.desktop</kbd>: Provides the Java desktop APIs, <kbd class="calibre12">awt</kbd>, and <kbd class="calibre12">swing</kbd> packages</li>
<li class="calibre15"><kbd class="calibre12">java.transaction</kbd>: Provides transaction related APIs in package <kbd class="calibre12">javax.transaction</kbd></li>
</ul>
<p class="calibre2">There is also a special module named <kbd class="calibre12">java.base</kbd>. The module <kbd class="calibre12">java.base</kbd> contains APIs and classes that are fundamental to the Java platform and without which one could not possibly write any Java code. The <kbd class="calibre12">java.base</kbd> module contains APIs from packages such as <kbd class="calibre12">java.lang</kbd>, <kbd class="calibre12">java.io</kbd>, <kbd class="calibre12">java.util</kbd> and so on. As you can see, it covers a lot of basic Java APIs that most of our Java applications use. Now, why do I call this module special? Hold that thought! We'll get back to it in a bit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The impact of platform modularity</h1>
                
            
            <article>
                
<p class="calibre2">As you can imagine, the impact of this change is indeed significant, and it pretty much affects the way we write all Java code from now on. In Java 8 and earlier, you didn't have to think twice about using any Java API. All you had to do is import the types you need into your code. Since the JVM knew where to find <kbd class="calibre12">rt.jar</kbd>, the necessary classes were always found by the runtime. That's no longer the case with Java 9. Remember in <a target="_blank" href="part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 3</span></a>, <span><em class="calibre22">Handling Inter-Module Dependencies</em> ﻿</span>, when you needed a class in the <kbd class="calibre12">packt.addressbook</kbd> module from the <kbd class="calibre12">packt.sortutil</kbd> module? You couldn't just import the class in your code and use it. You had to go to the module definition of <kbd class="calibre12">packt.addressbook</kbd> and specify the dependency on the module using the <kbd class="calibre12">requires</kbd> clause. That's exactly what you'll need to do for native Java platform types too!</p>
<p class="calibre2">Need to use Java SQL APIs? They are in the module <kbd class="calibre12">java.sql</kbd>, so in the module where you need them, you need to specify this in the module descriptor:</p>
<pre class="calibre23">    module mymodule { 
      requires java.sql; 
    } </pre>
<p class="calibre2">Once you have required the necessary platform module, its APIs are then ready for use in your module. Since the <kbd class="calibre12">java.sql</kbd> module is built on the same Java module system that you use to write your code, you can bet that there's code in the <kbd class="calibre12">module-info</kbd> file of the <kbd class="calibre12">java.sql</kbd> module that exports the <kbd class="calibre12">java.sql</kbd> and <kbd class="calibre12">javax.sql</kbd> packages that contain the Java SQL API.</p>
<p class="calibre2">This necessity to <em class="calibre22">require</em> modules before using them applies not just to our own modules; it applies to the Java modules too. For example, the <kbd class="calibre12">java.sql</kbd> module requires logging functionality (for obvious reasons). And the logging APIs are in the <kbd class="calibre12">java.logging</kbd> module. So, there's a <kbd class="calibre12">requires</kbd> declaration in <kbd class="calibre12">java.sql</kbd> module's <kbd class="calibre12">module-info.java</kbd> file specifying this requirement. That's the only way code in the <kbd class="calibre12">java.sql</kbd> module can import and use the logging APIs.</p>
<p class="calibre2">This is how the <kbd class="calibre12">module-info.java</kbd> of <kbd class="calibre12">java.sql</kbd> module should look to enable the configuration we've discussed so far:</p>
<pre class="calibre23">    module java.sql { 
      ... 
      requires java.logging; 
      exports java.sql; 
      exports javax.sql; 
      ... 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module graph</h1>
                
            
            <article>
                
<p class="calibre2">The result of these individual Java modules depending on one another is that we can now draw a complete graph of dependencies with the modules as nodes and the relationships between nodes as module dependencies. This kind of picture is called a <strong class="calibre1">module graph</strong> and is your new best friend to help you track and manage module dependencies in your Java 9 modular applications. We looked at a simple module graph of the address book application in the previous chapter. Here's a simple module graph that specifies the dependencies between a handful of Java platform modules:</p>
<div class="packt_figure"><img class="image-border39" src="../images/00045.jpeg"/></div>
<p class="calibre2">A line drawn from module <em class="calibre22">A</em> to module <em class="calibre22">B</em> indicates that module <em class="calibre22">A</em> <kbd class="calibre12">requires</kbd> module <em class="calibre22">B</em>. So, as this diagram indicates, module <kbd class="calibre12">java.transaction</kbd> requires <kbd class="calibre12">java.rmi</kbd>, which in turn requires <kbd class="calibre12">java.base</kbd>. As mentioned before, since <kbd class="calibre12">java.base</kbd> contains APIs that are fundamental to the language, it is one module that every other module is sure to need. Which is why, this one module is treated a bit differently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The java.base module</h1>
                
            
            <article>
                
<p class="calibre2">In <a target="_blank" href="part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 2</a>, <em class="calibre22">Creating Your First Java Module</em>, and <a target="_blank" href="part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 3</a>, <em class="calibre22">Handling Inter-Module Dependencies</em>, you wrote a few Java 9 modules that used some Java APIs such as <kbd class="calibre12">Collection</kbd> and <kbd class="calibre12">System.out</kbd>. These APIs happen to come from the <kbd class="calibre12">java.base</kbd> module. You might have noticed something wrong with the picture here. Since these core Java APIs are in its own module, shouldn't we have had to add the <kbd class="calibre12">requires java.base;</kbd> line in all our module descriptors before we used them? How did the compilation succeed without it? Well, let me assure you that there's no trickery involved here. The reason it worked is due to the special nature of the <kbd class="calibre12">java.base</kbd> module.</p>
<p class="calibre2">When was the last time you had to write the line <kbd class="calibre12">import java.lang.*</kbd> in your Java class? Never, I hope! You don't need to import classes from the package <kbd class="calibre12">java.lang</kbd> because it is imported and available to your Java code by default. That's because the classes in that package are so commonly used that it's a sensible default to always have the types in the package imported.</p>
<p class="calibre2">Java 9 has a similar shortcut for requiring the <kbd class="calibre12">java.base</kbd> module. This module contains the <kbd class="calibre12">java.lang</kbd> package among other fundamental Java APIs that almost no Java module can be written without. So, rather than every Java module in existence having to <em class="calibre22">require</em> the <kbd class="calibre12">java.base</kbd> module, it is just required by default, so you don't have to explicitly specify it. Now, since the <kbd class="calibre12">java.lang</kbd> packages are in the <kbd class="calibre12">java.base</kbd> module, the default behavior is seamless in both cases! See how that works?</p>
<p class="calibre2">Remember, though, that this is the only module that has this behavior. Every other Java module in existence, platform or otherwise, will have to be explicitly <em class="calibre22">required</em>, if the module is needed as a dependency.</p>
<p class="calibre2">Since there is always an implicit dependency on <kbd class="calibre12">java.base</kbd>, a common practice when writing module graphs is to skip the dependency on this base module in order to make things more legible. The idea is to show a module depending on <kbd class="calibre12">java.base</kbd> only if the given module's <em class="calibre22">only</em> dependency is <kbd class="calibre12">java.base</kbd>. If a module depends on other modules, we show only that and skip the <kbd class="calibre12">java.base</kbd> dependency. Here's how the module graph from earlier looks with this approach:</p>
<div class="packt_figure"><img class="image-border40" src="../images/00046.jpeg"/></div>
<p class="calibre2">I hope you'll agree this graph looks a bit cleaner. This is a practice that people seem to be increasingly following, so when you come across such module graphs, don't forget the implicit <kbd class="calibre12">java.base</kbd> dependency. It's always there!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Browsing modules</h1>
                
            
            <article>
                
<p class="calibre2">Now that you've looked at some of the modules that come with Java, you might be wondering how you can get more information about them. How can you find out what the list of modules are that come with the platform? Given an API, how can you know which platform module contains it? And given a module, how can you know what are the packages it exports?</p>
<p class="calibre2">The answer is a couple of new arguments to the <kbd class="calibre12">java</kbd> command. First is an option called <kbd class="calibre12">--list-modules</kbd>. This command lets you examine the modules that are available for you from the platform.</p>
<p class="calibre2">When you run the following command from the <span>Command Prompt</span>, this is what you'll see:</p>
<pre class="calibre23"><strong class="calibre1">$ java --list-modules</strong>
<strong class="calibre1">  java.activation@9</strong>
<strong class="calibre1">  java.annotations.common@9</strong>
<strong class="calibre1">  java.base@9</strong>
  <strong class="calibre1">java.compiler@9</strong>
  <strong class="calibre1">java.corba@9</strong>
  <strong class="calibre1">java.datatransfer@9</strong>
  <strong class="calibre1">java.desktop@9</strong>
  <strong class="calibre1">...</strong>  </pre>
<p class="calibre2">The list you see there is the list of all the Java platform modules! As you scroll the list, notice that the modules we discussed previously are all there! This is a great way to browse through and get a good idea of what's available.</p>
<p class="calibre2">There's another new option <kbd class="calibre12">-d</kbd>, which helps in examining the details of a single module. The syntax is:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d &lt;module-name&gt;</strong>  </pre>
<p class="calibre2">You can also use the longer form  <kbd class="calibre12">--describe-module</kbd> to do the same:</p>
<pre class="calibre23"><strong class="calibre1">$ java --describe-module &lt;module-name&gt;</strong>  </pre>
<p class="calibre2">For example, if you want to look at more details about the <kbd class="calibre12">java.base</kbd> module, run the following command:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d java.base</strong>
  <strong class="calibre1">module java.base@9</strong>
 <strong class="calibre1"> exports java.io</strong>
 <strong class="calibre1"> exports java.lang</strong>
<strong class="calibre1">  exports java.lang.annotation</strong>
 <strong class="calibre1"> ... </strong>  </pre>
<p class="calibre2">The output has been truncated for brevity, but as you scroll down the result of the command, you'll notice various details about the module listed.</p>
<p class="calibre2">Here's the output of the command run on the module <kbd class="calibre12">java.sql</kbd>:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d java.sql</strong>
 <strong class="calibre1">java.sql@9</strong><br class="title-page-name"/><strong class="calibre1"> exports java.sql</strong><br class="title-page-name"/><strong class="calibre1"> exports javax.sql</strong><br class="title-page-name"/><strong class="calibre1"> exports javax.transaction.xa</strong><br class="title-page-name"/><strong class="calibre1"> requires java.base mandated</strong><br class="title-page-name"/><strong class="calibre1"> requires java.logging transitive</strong><br class="title-page-name"/><strong class="calibre1"> requires java.xml transitive</strong><br class="title-page-name"/><strong class="calibre1"> uses java.sql.Driver</strong> </pre>
<p class="calibre2">In these module-level outputs, you'll notice the following categories of information displayed:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Exports</strong>: This is the list of all the packages exported by the module. In the <kbd class="calibre12">java.base</kbd> module, you'll see familiar packages such as <kbd class="calibre12">java.io</kbd> and <kbd class="calibre12">java.lang</kbd> here. The <kbd class="calibre12">java.sql</kbd> module exports packages <kbd class="calibre12">java.sql</kbd> and <kbd class="calibre12">javax.sql</kbd>. These packages marked with <kbd class="calibre12">exports</kbd> are all the packages that the module exports. Thereby, when you <kbd class="calibre12">require</kbd> the module, (which you do by default with <kbd class="calibre12">java.base</kbd>), your module gets access to the types in the <em class="calibre22">required</em> module that also belong to those <em class="calibre22">exported</em> packages. In the output, you'll notice some statements in the form  <kbd class="calibre12">exports &lt;package-name&gt; to &lt;module-name&gt;</kbd> . These are called qualified exports. We'll be covering qualified exports in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 6</a>, <em class="calibre22">Module Resolution, Readability, and Accessibility</em>.</li>
<li class="calibre15"><strong class="calibre1">Contains</strong>: This is the list of internal packages that the module <em class="calibre22">contains</em> but does not export. These packages are, by definition, not visible outside the module. It is still handy for us developers to know what the packages are that belong to the <em class="calibre22">internal</em> module API because a lot of these had been APIs that existed in Java 8 and thus, used to be available publicly earlier. For example, look at the packages <kbd class="calibre12">jdk.internal.*</kbd> and <kbd class="calibre12">sun.util.*</kbd> in the <kbd class="calibre12">java.base</kbd> module. They are not in the <kbd class="calibre12">exports</kbd> list so they are now effectively encapsulated in the module.</li>
<li class="calibre15"><strong class="calibre1">Requires</strong>: This is the list of modules that a given module requires. The <kbd class="calibre12">java.sql</kbd> module requires three other modules--<kbd class="calibre12">java.base</kbd>, <kbd class="calibre12">java.logging</kbd>, and <kbd class="calibre12">java.xml</kbd>. The requirement of <kbd class="calibre12">java.base</kbd> is by default, and so it is qualified with a <kbd class="calibre12">requires mandated</kbd> clause. Note that you <em class="calibre22">do not</em> have to do this in your own modules, since that's default behavior. Ignore the <kbd class="calibre12">requires transitive</kbd> clause for now. That's related to making modules available to dependent modules, a concept we'll explore in detail in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 6</span></a>, <em class="calibre22">Module Resolution, Accessibility, and Readability</em>. Also, as is obvious, <kbd class="calibre12">java.base</kbd> does not <kbd class="calibre12">require</kbd> any other module.</li>
<li class="calibre15"><strong class="calibre1">Uses and</strong> <strong class="calibre1">provides</strong>: These are related to the concept of Services, which we'll be exploring in <a target="_blank" href="part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 7</span></a>, <em class="calibre22">Introducing Services</em>.</li>
</ul>
<p class="calibre2">I recommend using the <kbd class="calibre12">java --list-modules</kbd> and <kbd class="calibre12">java -d &lt;module-name&gt;</kbd> commands to explore other modules in the platform. As you start writing modular code in Java 9, you'll often need to import platform classes, and that requires the identification of modules that export them. Initially, you'll need to use these commands to get to the right module, but when you do this a few times, you'll be committing to your memory the common packages and the modules that have them available, and so you don't need to do this anymore. What also helps is the intuitive names for the modules. Need to use SQL classes? You just <em class="calibre22">know</em> they are in <kbd class="calibre12">java.sql</kbd>! Granted, some packages may not be all that intuitive, but still, the naming convention followed goes a long way in helping developers get to the right modules quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module types</h1>
                
            
            <article>
                
<p class="calibre2">Speaking of naming conventions, you might have noticed the different prefixes to the module names when you ran the <kbd class="calibre12">java --list-modules</kbd> command. The three prefixes to the platform modules are--<kbd class="calibre12">java.</kbd>, <kbd class="calibre12">javafx.</kbd>, and <kbd class="calibre12">jdk.</kbd>. The prefix indicates the nature of the module:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">java</kbd>: Indicates the core Java platform module. These are what's referred to in the official documentation as <em class="calibre22">standard modules</em>.</li>
<li class="calibre15"><kbd class="calibre12">javafx</kbd>: Indicates modules of Java FX, the platform for building desktop applications in Java.</li>
<li class="calibre15"><kbd class="calibre12">jdk</kbd>: Indicates core JDK modules. These are not part of the language specification, but contain valuable APIs and tools for the Java developer, including the <kbd class="calibre12">jdk.compiler</kbd> and <kbd class="calibre12">jdk.javadoc</kbd>, as well as debugging and serviceability tools and APIs such as <kbd class="calibre12">jdk.jdi</kbd> and <kbd class="calibre12">jdk.jconsole</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">oracle</kbd>: If you've downloaded the Oracle Open JDK, you might see a couple of modules beginning with this prefix. Remember that these are non-standard modules that are specific to this flavor of the JDK implementation and they will not be available in other implementations. For this reason, it's a good idea to completely ignore these modules.</li>
</ul>
<p class="calibre2">The <kbd class="calibre12">java.</kbd> prefixed modules themselves can be classified into three categories:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Core Java modules</strong>: These are necessary for the Core Java functionality. Modules such as <kbd class="calibre12">java.base</kbd>, <kbd class="calibre12">java.xml</kbd>, and so on, which are APIs usually referred to as Core Java SE APIs. This is in contrast to Enterprise APIs, the next category.</li>
</ul>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Enterprise modules</strong>: This category contains modules such as <kbd class="calibre12">java.corba</kbd> that contains APIs leveraging CORBA technology and <kbd class="calibre12">java.transaction</kbd>, which provide database transaction APIs usually required in an Enterprise application context. Note that this is different from Java EE, which is the completely different spec. However, there has always been a small overlap between what got bundled with the Java SE and Java EE SDKs. To avoid this overlap, as of Java 9, these Enterprise modules have been marked as deprecated and might be removed in a future Java version.</li>
<li class="calibre15"><strong class="calibre1">Aggregator modules</strong>: These are modules that do not contain any APIs by themselves, but instead act as a convenient way to bundle multiple modules together. Specifying a <kbd class="calibre12">requires</kbd> dependency on the aggregator module is equivalent to individually specifying the <kbd class="calibre12">requires</kbd> dependency on all the individual modules that the aggregator module aggregates. You'll learn how to build your own custom aggregator modules in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 6</span></a>, <em class="calibre22">Module Resolution, Accessibility, and Readability</em>. For now, note that there are a couple of aggregator modules that come bundled with the platform. They are:
<ul class="calibre30">
<li class="calibre15"><kbd class="calibre12">java.se</kbd>: This is a convenient aggregator module that gathers all the <em class="calibre22">standard</em> Java SE modules together.</li>
<li class="calibre15"><kbd class="calibre12">java.se.ee</kbd>: This aggregator module gathers all the <kbd class="calibre12">java.se</kbd> modules and adds in the APIs that overlap with the Java EE specification.</li>
</ul>
</li>
</ul>
<p class="calibre2">While aggregator modules provide a level of convenience, I'd recommend using them with care. When writing a Java application, it can be tempting to just <kbd class="calibre12">require</kbd> the <kbd class="calibre12">java.se</kbd> module, for instance, to pull down the entire Java SE platform. That way, you don't have to bother with identifying which platform modules contain the APIs you want and thus need to import. With just one line--<kbd class="calibre12">requires java.se</kbd>, you have the whole platform at your disposal. But then, you are losing several advantages of the modularization of the platform. You then end up with a bulky Java platform with unnecessary classes, no different from Java 8 and earlier. The aggregator modules are provided for convenience to be used only when necessary. So, make sure you use them right.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Examining platform file structure</h1>
                
            
            <article>
                
<p class="calibre2">Let's now examine how these changes to the platform manifest in the file structure of the installation. Historically, the Java platform has come in two flavors--The <strong class="calibre1">Java Runtime environment</strong> (<strong class="calibre1">JRE</strong>) and the <strong class="calibre1">Java Development Kit</strong> (<strong class="calibre1">JDK</strong>). The JDK is the superset, in that it contains the JRE. Here's a high-level structure of the classic JDK with only a few important files shown for the sake of simplicity:</p>
<div class="packt_figure"><img class="image-border41" src="../images/00047.jpeg"/></div>
<p class="calibre2">The Java 9 JDK looks very different. You can navigate to the directory using the <kbd class="calibre12">cd $JAVA_HOME</kbd> command. Here's what the new JDK looks like, again with only a few important files displayed:</p>
<div class="packt_figure"><img class="image-border42" src="../images/00048.jpeg"/></div>
<p class="calibre2">There are a couple of important differences that should be noted:</p>
<ul class="calibre14">
<li class="calibre15">There is no JRE folder within the main folder anymore. The structure is now collapsed into one common folder. JDK 9 moves away from the distinction between JRE and JDK to create a common runtime binary file structure. This structure contains the <kbd class="calibre12">bin</kbd>, <kbd class="calibre12">lib</kbd>, and <kbd class="calibre12">conf</kbd> folders at the top level, with no nested folders for the runtime. This change was implemented to provide the ability to create custom runtime images that are now supported in Java 9. You'll learn more about generating such images in <a target="_blank" href="part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 8</a>, <em class="calibre22">Understanding Linking and Using jlink</em>.</li>
<li class="calibre15">There's a new folder called <kbd class="calibre12">jmods</kbd> that contains all the packaged platform modules that we've learnt about so far. With Java 9, it's time to say goodbye to <kbd class="calibre12">rt.jar</kbd>. There is no single monolithic jar file that houses the entire platform. Each platform module has a corresponding file in the <kbd class="calibre12">jmods</kbd> folder. So, what would have formerly been a single <kbd class="calibre12">rt.jar</kbd> file is now split into separate module files, one for each platform module.</li>
<li class="calibre15">Notice the <kbd class="calibre12">.jmod</kbd> file extension of the module files. Shouldn't those be <kbd class="calibre12">.jar</kbd> files? With Java 9, a new format called JMOD has been introduced as a new way of bundling libraries specifically for development time, and not for runtime. The traditional jar format is great for bundling classes for runtime use, but since they are just a ZIP file of compiled classes, they aren't very useful when using them during development time. The new JMOD format goes beyond the JAR format by including the ability to bundle in things such as native code and configuration files, which makes it useful for distributing libraries for development use. This is the format used by the JDK to bundle all built-in platform modules. The details of the format are beyond the scope of what we are covering here. Just think of it as the new dev-time-only alternative to the JAR format.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Observable modules</h1>
                
            
            <article>
                
<p class="calibre2">There are two module path values we pass to the <kbd class="calibre12">javac</kbd> and <kbd class="calibre12">java</kbd> commands--the module source path (passed to <kbd class="calibre12">javac</kbd>) containing the uncompiled Java source modules and the module path (passed to <kbd class="calibre12">javac</kbd> and  <kbd class="calibre12">java</kbd>) containing the compiled Java modules. These options point to the locations of all the modules that are available for the compiler and the runtime to look up and use when necessary. Notice that we didn't have to add the path to the Java platform modules. That's because the Java runtime modules are included by default in the module path for compiling with <kbd class="calibre12">javac</kbd> and executing with <kbd class="calibre12">java</kbd>. You have to add the path only to the modules that are not a part of the platform, but you intend to include for compilation or execution.</p>
<p class="calibre2">This complete set of modules including modules in the module path that you supply to the platform <em class="calibre22">and</em> the out-of-the-box platform modules that are automatically available are together referred to as <em class="calibre22">observable modules</em>. As the name indicates, these are the modules that the platform <em class="calibre22">observes</em> in order to satisfy module dependencies. If a required module is not among the set of observable modules, the platform complains that the module is missing.</p>
<p class="calibre2">How do you know what the observable modules are? When we've used the <kbd class="calibre12">java --list-modules</kbd> command to list the platform modules, what we are actually doing is listing all observable modules. And, by default, only the platform modules are observable. You can also find out what are the observable modules for a given module path. You do that by specifying the <kbd class="calibre12">--module-path</kbd> option to the same command. You can specify as value a set of directory locations that form the module path. In that case, the command would display the list of observable modules <em class="calibre22">for that module path</em>, which would include all the platform modules along with any compiled modules in that module path.</p>
<p class="calibre2">For example, if you were to run the command with the module path being the compiled modules in the <kbd class="calibre12">out</kbd> folder from the previous chapter (<kbd class="calibre12">03-two-modules</kbd>), here's what you'll see:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out --list-modules</strong>
<strong class="calibre1"> java.activation@9</strong><br class="title-page-name"/><strong class="calibre1"> java.base@9</strong><br class="title-page-name"/><strong class="calibre1"> java.compiler@9</strong><br class="title-page-name"/><strong class="calibre1"> ...</strong><br class="title-page-name"/><strong class="calibre1"> addressbook file:///Users/koushik/code/java9/03-two-<br class="title-page-name"/>  modules/out/addressbook/</strong><br class="title-page-name"/><strong class="calibre1"> sortutil file:///Users/koushik/code/java9/03-two-modules/out/sortutil/</strong></pre>
<p class="calibre2">Notice that in addition to the platform modules, there are two of our own modules showing up in the list. This is because they are in the module path we've passed as a parameter to the command, thus adding them to the list of observable modules for that module path. For non-platform modules, the output also includes the path of the module. This makes it handy to locate modules when there are multiple directories passed to the  <kbd class="calibre12">--module-path</kbd> option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Revisiting the two problems</h1>
                
            
            <article>
                
<p class="calibre2">We started this chapter looking at two issues with the Java platform:</p>
<ul class="calibre14">
<li class="calibre15">The monolithic runtime</li>
<li class="calibre15">The lack of API encapsulation features</li>
</ul>
<p class="calibre2">Interestingly, the modularization of the Java platform provides solutions to both these problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Solving the monolithic runtime</h1>
                
            
            <article>
                
<p class="calibre2">There is a distinct advantage of knowing which platform modules your application belongs to. It is a clear indication of which platform modules it doesn't need--which is anything the modules in the application doesn't use! So, for example, if your application contains modules that only <kbd class="calibre12">require</kbd> the platform modules <kbd class="calibre12">java.base</kbd> and <kbd class="calibre12">java.logging</kbd>, you can essentially create a small subset of the Java platform consisting of just those two modules. That slice of the platform is all that your application needs to function. If you are bundling the runtime with your application, you now know the exact portion of the runtime you need to bundle, no more no less!</p>
<p class="calibre2">Java 9 comes with a brand-new <em class="calibre22">static linking</em> step that lets you create custom runtime images with only the modules that your applications need. This results in smaller and leaner application distributable, micro-service executables, and so on. You'll learn more about the linking phase and how to create your own runtimes in <a target="_blank" href="part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 8</span></a>, <em class="calibre22">Understanding Linking and Using jlink</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Solving the API encapsulation problem</h1>
                
            
            <article>
                
<p class="calibre2">Thanks to Java platform modules leveraging the encapsulation concepts of modularity, the platform now has the means to effectively protect internal classes from external usage. The platform can evolve to modify or even completely remove and replace the internal APIs, and still ensure backward compatibility as long as the <em class="calibre22">public</em> exported APIs remain the same. I believe this enables better and faster evolution of the Java platform, and we all get to benefit from it.</p>
<p class="calibre2">On the other hand, remember that there are some classes that were publicly accessible in earlier Java versions that are now encapsulated in Java platform modules. This implies that there are possibly some backward incompatibilities with applications that were formerly depending on those internal APIs (even though they really shouldn't)! This is a problem many of us will have to tackle when we migrate code written in Java 8 or earlier into Java 9. We'll learn more about that, as well as strategies to handle such situations in <a target="_blank" href="part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 10</a>, <em class="calibre22"><span>Preparing Your Code for Java 9</span></em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">We've covered a lot of ground in this chapter. We started looking at a couple of problems with the earlier versions of the Java platform and how the language didn't really provide sufficient features to solve them. We then learned how the Java platform has been modularized, what the modules are, and how to browse and get information about them. We then wrapped up with how the new modular Java platform has effectively solved the two major problems we began the chapter with.</p>
<p class="calibre2">In the next chapter, you'll put these concepts into practice by wiring in the Java platform modules into the address book application and getting familiar with the process of using platform modules and APIs in your custom Java code.</p>


            </article>

            
        </section>
    </body></html>