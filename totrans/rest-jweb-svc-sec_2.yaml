- en: Chapter 2. The Importance of Securing Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at you; you have made it to Chapter 2; congratulations! This chapter is
    quite important because it is related to a concept that is implicit in software,
    which is **security**. This is very important because software is used by companies
    and people like us. Sometimes, we share very important and confidential information
    through software, and that is why this topic becomes so important for everybody.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take you through the basic aspects related to the management
    of security in computer systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore and implement each of the different security mechanisms and
    scenarios in which they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you'll learn how to use a protocol analyzer. This will allow us to demonstrate
    how an attack can be performed and determine the impact of this attack when it
    achieves its target, in this case, our information. Also, you will be able to
    imagine more options to implement security in web services.
  prefs: []
  type: TYPE_NORMAL
- en: As everything needs practice, you will go through a simple example of code to
    learn the differences between authentication and authorization. Get ready for
    an interesting and useful topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of security management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring and implementing the different available mechanisms of security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a protocol analyzer to intercept requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The management of security is one of the main aspects to consider when designing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what, neither the functionality nor the information of organizations
    can be exposed to all users without any kind of restriction. Consider the case
    of a human resource management application that allows you to consult the wages
    of employees, for example: if the company manager needs to know the salary of
    one of their employees, it is not something of great importance. However, in the
    same context, imagine that one of the employees wants to know the salary of their
    colleagues; if access to this information is completely open, it can generate
    problems among employees with varied salaries.'
  prefs: []
  type: TYPE_NORMAL
- en: An even more critical example can be the case where the bank XYZ increases a
    bank balance every time a customer or a third party makes a deposit into one of
    their accounts using an ATM. The IT manager envisions that this functionality
    could be common, and decides to implement it as a web service. Right now, this
    functionality is limited to bank users logged in to the application that uses
    this web service. Suppose that the visions of the future of the IT manager come
    true, and this functionality is now required from an ATM; raising this requirement
    quickly indicates that such functionality is implemented and can be used by invoking
    the web service. So far, there may be no security loopholes since ATMs are likely
    to have a security system that controls access, and thus operating system access
    to the functionality of the web service is also indirectly controlled.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that the company ABC wants a similar functionality to increase
    the balance in one of its employee's bank account by an *x* amount in recognition
    of some kind of contribution to the company. What happens to the functionality
    of the web service? Do you think you can again trust the application that handles
    its own security scheme to control access to its functionality? Even if we do
    trust this mechanism, what if the request is intercepted by a sniffer? Then, anyone
    who knows how to perform the request may increase the balance. These questions,
    when answered, throw in the response in quite a logical way. Exposed, these scenarios
    now sound quite logical so that whoever authenticates the user to have access
    to this functionality is the web service, and as such, should be entrusted with
    the management scheme security systems under all circumstances. It doesn't matter
    if invocations are from the organization itself or from an external institution;
    security control must be present in order to expose a sensitive functionality
    such as the one we just outlined.
  prefs: []
  type: TYPE_NORMAL
- en: When sharing existing information or functionality through web services, it
    is well known that we don't depend on programming languages, architectures, or
    system platforms to interact with. This gives us flexibility and saves us from
    having to rewrite the existing functionality. Going further, we should understand
    that these features have an impact on data confidentiality, as we are going to
    share information and/or functionality with entities or systems. This way, we
    can accomplish the business objectives and definitely prevent intruders from reading
    our information; or even worse, a third party not authorized has access to functionalities
    exposed by our services. Hence, access to them must be rigorously analyzed and
    our exposed services must be correctly ensured.
  prefs: []
  type: TYPE_NORMAL
- en: Security management options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides some options for security management. Right now, we will explain
    some of them and demonstrate how to implement them. All authentication methods
    are practically based on credential delivery from the client to the server. There
    are several methods to perform this, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: BASIC authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DIGEST authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CLIENT CERT authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using API keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security management in applications built with Java, including the ones with
    RESTful web services, always rely on JAAS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Authentication and Authorization Service** (**JAAS**) is a framework
    that is part of Java Platform Enterprise Edition. Hence, it is the default standard
    to handle an application''s security in Java; it allows you to implement authorization,
    and it allows authentication controls over applications with the purpose of protecting
    resources that belong to the application. If you want to know more about JAAS,
    you can check out the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html)'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to use JAAS, of course it is always possible to create our
    own implementation to handle securities, but it would be hard. So, why don't we
    save ourselves some time, effort, and peace by implementing this useful technology?
    It is recommended to use standard implementations whenever possible. In our development
    exercise, we will use JAAS for the first three methods of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization and authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you these terms, it is very easy to get confused, but they have different
    meanings when you have a security system approach. In order to clarify these terms,
    we will explain them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a nutshell, this term refers to *who you are*. It is the process to identify
    a user, usually through their *username* and *password*. When we use this concept,
    we are trying to ensure the identity of the user and we verify the identity the
    user claims to be. Also, it doesn't have anything to do with the access rights
    the user has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Security research has specified a list of factors that should be verified in
    order to achieve positive authentication. This list contains three elements, where
    it is very common to use two of them, but preferably we should use all of them.
    These elements are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowledge factors**: This element implies something the user **knows**, for
    example, a password, pass phrase, or personal identification number (PIN). Another
    example is challenge response, where the user must answer a question, software
    token, or phone serving as a software token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ownership factors**: This is something the user *has*, for example, a wrist
    band (in case of physical authentication), ID card, security token, or cell phone
    with a built-in hardware token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inherence factors**: This is something the user *is* or *does*, for example,
    fingerprint or retinal pattern, DNA sequence, signature, face, voice, unique bio-electric
    signals, or other biometric identifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a few words, this term refers to *what you can do*. It is the process of
    giving a user permission to do or have something. When we talk about software,
    we have a system administrator that is in charge of defining the system which
    users are allowed to access and what the privileges of use are (such as access
    to which file directories, access period, amount of allocated storage space, and
    so forth).
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is often seen as both the introductory setting up of permissions
    by a system administrator and the checking of the permission values that have
    already been set up when a user is getting access.
  prefs: []
  type: TYPE_NORMAL
- en: Access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very common use of authentication and authorization is access control. A
    computer system that is supposed to be used only by authorized users must attempt
    to detect and reject unauthorized users. Access is controlled by persisting on
    an authentication process to establish the user''s identity with a certain level
    of confidence, also conferring privileges specified for that identity. Let''s
    name some examples of access control involving authentication in different scenarios,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling for photo ID when a contractor first arrives at a house to do some work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing captcha as a way of verification that a user is a human being and
    not a computer program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a **One Time Password** (**OTP**) obtained on telenetwork-enabled
    devices such as mobile phones as an authentication password/PIN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer program that uses a blind credential in order to authenticate to
    another program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you enter a country with a passport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you log in to a computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a service uses a confirmation e-mail to verify ownership of an e-mail address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an Internet banking system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you withdraw cash from an ATM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, the ease of access is adjusted against the strictness of access checks.
    For example, a small transaction usually doesn't require a signature of the authenticated
    person as proof of the transaction's authorization.
  prefs: []
  type: TYPE_NORMAL
- en: However, security experts argue that it is impossible to prove the user's identity
    with absolute certainty. It is only possible to apply a set of tests which, if
    passed, have been previously declared as a minimum to confirm the identity. The
    problem lies in how to determine which tests are enough; it depends on the company
    to determine this set.
  prefs: []
  type: TYPE_NORMAL
- en: Transport layer security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we highlight some of the main features of TLS:'
  prefs: []
  type: TYPE_NORMAL
- en: Its predecessor is **Secure Sockets Layer** (**SSL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a cryptographic protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides security communication over the Internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It authenticates the counterpart through X.509 certificates (asymmetric cryptography)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows client-server applications to communicate over the network and prevents
    eavesdropping and tampering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS is often implemented on top of the Transport layer protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It encapsulates application-specific protocols such as HTTP, FTP, SMTP, NNTP,
    and XMPP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of TLS should be delegated, especially when credentials, updates, deletions,
    and any kind of value transactions are performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overhead of TLS is very low on modern hardware, with a little increase of
    latency, but this represents more safety for the end user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic authentication by providing user credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Possibly, basic authentication is one of the most used techniques in all types
    of applications. The user, before gaining functionality over the application,
    is requested to enter a username and password. Both are validated in order to
    verify whether the credentials are correct (they belong to an application user).
    We are 99 percent sure you have performed this technique at least once, maybe
    through a customized mechanism, or if you have used the JEE platform, probably
    through JAAS. This kind of control is known as **basic authentication**.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with this security implementation is that credentials are propagated
    in a plain way from the client to the server. This way, any sniffer could read
    the sent packages over the network. We will consider an example using a tool named
    Wireshark; it is a protocol analyzer that will show this problem. For installation,
    we can go to the link [http://www.wireshark.org/download.html](http://www.wireshark.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: The installation is pretty basic (click on **Next** all the way). For this reason,
    we will not show screenshots of these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to modify the project from [Chapter 1](ch01.html "Chapter 1. Setting
    Up the Environment"), *Setting Up the Environment*, where the user tries to invoke
    any of the functions of the web service. The user will be requested to enter a
    username and password; once these are verified, the user will have access to the
    web service functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have a working example, let''s start our application server JBoss
    AS 7; then, go to the `bin` directory and execute the file `add-user.bat` (the
    `.sh` file for UNIX users). Finally, we will create a new user as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication by providing user credentials](img/0109OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The most important thing here is that you should select `Application User` in
    the first question and assign it an `admin` role. This will match with the information
    defined in the `web.xml` file, which will be explained later when we implement
    securities inside our application. As a result, we will have a new user in the
    `JBOSS_HOME/standalone/configuration/application - users.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'JBoss is already set with a default security domain called `other`; this domain
    uses the information stored in the file we mentioned earlier in order to authenticate.
    Right now, we will configure the application to use this security domain inside
    the folder `WEB-INF` from the `resteasy-examples` project. Let''s create a file
    named `jboss-web.xml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, let''s configure the file `web.xml` in order to aggregate the security
    constraints. In the following block of code, you will see in bold what you should
    add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From a terminal, let''s go to the home folder of the `resteasy-examples` project
    and execute `mvn jboss-as:redeploy`. Now, we will test our web service as we did
    in [Chapter 1](ch01.html "Chapter 1. Setting Up the Environment"), *Setting Up
    the Environment*, using SOAP UI. We will perform a request using the `POST` method
    to the URL `http://localhost:8080/resteasy-examples/services/person/` with the
    following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication by providing user credentials](img/0109OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'SOAP UI shows us the HTTP 401 error, which means that the request wasn''t authorized.
    This is because we performed the request without delivering the credentials to
    the server. In order to do this, we have to click on the (**…**) button that is
    located in the left-bottom spot of SOAP UI and enter the user''s credentials we
    just created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication by providing user credentials](img/0109OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now is the time to enable our traffic analyzer. Let's start Wireshark and set
    it to analyze the traffic inside the loopback address. From the **Main** menu,
    navigate to **Capture** | **Interfaces**.
  prefs: []
  type: TYPE_NORMAL
- en: Check the option **lo0**, as shown in the following screenshot, and then click
    on the **Start** button. This way, all traffic that goes through the address 127.0.0.1
    or its equivalent localhost will be intercepted for our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the field `Filter`, we will type `http` just to intercept the HTTP
    request and response, as shown in the screenshot that follows later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication by providing user credentials](img/0109OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication by providing user credentials](img/0109OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have done this, we will perform the request operation from SOAP UI.
    Once again, SOAP UI shows us a HTTP 201 message; this time, the request is successfully
    processed. You can see the following columns of information in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No**: This column identifies the request or response in a unique way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time**: This column identifies the time to execute the operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source**: This column identifies the address where requests/responses are
    originated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination**: This column identifies the target IP address to perform a
    HTTP request/response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol**: This column identifies the protocol where requests/responses
    are performed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Length**: This column identifies the request/response length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Info**: This column identifies information related to the request/response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it is time to watch the information traffic on Wireshark, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication by providing user credentials](img/0109OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how Wireshark shows us we are performing a POST (info) operation using
    the protocol HTTP with an XML string (protocol) to the target address `127.0.0.1`
    (destination). Also, you can read the username and password. Hence, this method
    is not very safe for security implementation because anyone can access this information
    and perform a phishing attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication)'
  prefs: []
  type: TYPE_NORMAL
- en: Digest access authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This authentication method makes use of a hash function to encrypt the password
    entered by the user before sending it to the server. This, obviously, makes it
    much safer than the basic authentication method, in which the user's password
    travels in plain text that can be easily read by whoever intercepts it. To overcome
    such drawbacks, digest md5 authentication applies a function on the combination
    of the values of the username, realm of application security, and password. As
    a result, we obtain an encrypted string that can hardly be interpreted by an intruder.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this process, we will show you a simple explanation extracted
    from Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: An example with explanation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The following example was originally given in RFC 2617 and is expanded here
    to show the full text expected for each request and response. Note that only the
    `auth` (authentication) quality of protection code is covered—at the time of writing,
    only the Opera and Konqueror web browsers are known to support `auth-int` (authentication
    with integrity protection). Although the specification mentions HTTP Version 1.1,
    the scheme can be successfully added to the Version 1.0 server, as shown here.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This typical transaction consists of the following steps:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The client asks for a page that requires authentication but does not provide
    a username and password. Typically, this is because the user simply entered the
    address or followed a link to the page.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The server responds with the 401 "Unauthorized" response code, providing the
    authentication realm and a randomly generated, single-use value called `nonce`.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*At this point, the browser will present the authentication realm (typically,
    a description of the computer or system being accessed) to the user and prompt
    for a username and password. The user may decide to cancel at this point.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Once a username and password have been supplied, the client resends the same
    request but adds an authentication header that includes the response code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this example, the server accepts the authentication and the page is returned.
    If the username is invalid and/or the password is incorrect, the server might
    return the *401* response code and the client will prompt the user again.*'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A client may already have the required username and password without needing
    to prompt the user, for example, if they have previously been stored by a web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know more about this mechanism, you can visit Wikipedia for the
    complete article following the link [http://en.wikipedia.org/wiki/Digest_access_authentication](http://en.wikipedia.org/wiki/Digest_access_authentication).
  prefs: []
  type: TYPE_NORMAL
- en: You can also read the specification RFC 2617, which is available at [https://www.ietf.org/rfc/rfc2617.txt](https://www.ietf.org/rfc/rfc2617.txt).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test this mechanism in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to start, we must ensure that the environment variable `JAVA_HOME`
    is already set and added to the `PATH` variable. So, you can ascertain this by
    typing the following command in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the information shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example with explanation](img/0109OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This command shows us the Java version installed on our PC. In case you obtain
    an error instead of the previous output, you should create the environment variable
    `JAVA_HOME`, add it to the `PATH` variable, and repeat the verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to perform what we explained before, we need to generate a password
    for our example user. We have to generate the password using the parameters we
    talked about earlier—username, realm, and password. Let''s go to the directory
    of `JBOSS_HOME/modules/org/picketbox/main/` from a terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java -cp picketbox-4.0.7.Final.jar org.jboss.security.auth.callback.RFC2617Digest
    username MyRealmName password`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Through this process, we obtain the encrypted password and use it in our password
    storage file (the `JBOSS_HOME/standalone/configuration/application-users.properties`
    file). We must replace the password in the file, and it will be used for the user
    `username`. We have to replace it because the old password doesn't contain the
    realm name information of the application. As an alternative, you can create a
    new user using the file `add-user.sh`; you just have to deliver the realm information
    when you are requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make our application work, we just need to make a little change
    in the `web.xml` file. We have to modify the `auth-method` tag, change the value
    `FORM` to `DIGEST`, and set the application realm name in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a new security domain in JBoss so that we can manage the
    authentication mechanism `DIGEST`. On the `<security-domains>` section of the
    `JBOSS_HOME/standalone/configuration/standalone.xml` file, let''s add the following
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the application, change the security domain name in the file `jboss-web.xml`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will change the authentication method from `BASIC` to `DIGEST` in the `web.xml`
    file. Also, we will enter the name of the security realm. All these changes must
    be applied in the tag `login-config` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, restart the application server and redeploy the application on JBoss.
    For this, execute the following command in the terminal command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s enable the catching of traffic through Wireshark and test the web service
    again using SOAP UI. First, we should change the field `Authentication Type` from
    Global HTTP Settings to **SPNEGO/Kerberos**. A very useful trick is to tell SOAP
    UI not to use the basic authentication method. Once we execute the request, Wireshark
    will tell us the message shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example with explanation](img/0109OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the screenshot, let''s first confirm that all the steps described
    earlier are performed in this authentication method. Let''s keep track using the
    **No** field in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, the request is performed.
  prefs: []
  type: TYPE_NORMAL
- en: In step 7, the server returns an error message code HTTP 401 with the generated
    `nonce` value. The `nonce` value helps to avoid replay attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, the request is performed again. This time, the information required
    for authentication is included and all this information is encrypted in the same
    way we described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in step 11, we obtain the response that tells us the request has been
    successfully executed.
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice, this is a more secure authentication method, mainly used
    if you don't want the overhead of full transport security through TLS/SSL encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication)'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication through certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a mechanism in which a trust agreement is established between the server
    and the client through certificates. They must be signed by an agency established
    to ensure that the certificate presented for authentication is legitimate, which
    is known as CA.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine an application that uses this mechanism of security. When the
    client attempts to access a protected resource, instead of providing a username
    or password, it presents the certificate to the server. This is the certificate
    that contains the user information for authentication; in other words, the credentials,
    besides a unique private-public key pair. The server determines if the user is
    legitimate through the CA. Then, it verifies whether the user has access to the
    resource. Also, you should know that this authentication mechanism must use HTTPS
    as the communication protocol as we don't have a secure channel and anyone could
    steal the client's identity.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will show how to do this in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we turn ourselves into the CA; they are usually companies such
    as VERISIGN or others. However, as we want to save you money, we will do it this
    way. The first thing we need is a key for the CA (which is ourselves), and we
    will sign the certificates for the application server and users. As the purpose
    of this book is to explain how this method works and not how to generate certificates,
    we will not include all steps required to generate them, but we include them on
    GitHub at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s start. First, copy the `server.keystore` and `server.trutstore`
    files to the folder directory `JBOSS_HOME/standalone/configuration/`. You can
    download these files from GitHub using the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we mentioned before, this security mechanism requires our application
    server to use HTTPS as the communication protocol. So, we must enable HTTPS. Let''s
    add a connector in the `standalone.xml` file; look for the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the security domain, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we need two files: `my-users.properties` and `my-roles.properties`;
    both are empty and located in the `JBOSS_HOME/standalone/configuration` path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the `<user-data-constraint>` tag in the `web.xml` file in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the authentication method to `CLIENT-CERT`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the security domain in the `jboss-web.xml` file in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, restart the application server and redeploy the application with Maven
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test this authentication method, we will have to first perform
    some configurations in SOAP UI. First, let''s go to the installation directory,
    find the file `vmoptions.txt`, and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will change the SSL settings of SOAP UI. For this, you have to navigate
    to **File** | **Preferences** from the principal menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the pop-up window, select the **SSL Settings** tab and enter the values
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication through certificates](img/0109OS_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**KeyStore** is the place where you should have copied the `.pfx` file. Note
    that **KeyStore Password** is `changeit` and check the option **requires client
    authentication**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will test the modifications we just did; so, let''s enable the traffic
    analyzer and execute the request using SOAP UI again. Wireshark will show the
    information shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication through certificates](img/0109OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all information is encrypted and it can't be interpreted. So,
    if the packages are transmitted and they are intercepted in the network, the information
    is not vulnerable to attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code of this section on GitHub at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples)'
  prefs: []
  type: TYPE_NORMAL
- en: API keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advent of cloud computing, it is not difficult to think of applications
    that integrate with many others available in the cloud. Right now, it's easy to
    see how applications interact with Flickr, Facebook, Twitter, Tumblr, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To enable these integrations, a new authentication mechanism has been developed
    using API keys. This authentication method is used primarily when we need to authenticate
    from another application but we do not want to access the private user data hosted
    in another application. On the contrary, if you want to access this information,
    you must use OAuth. If you are interested in this, don't worry, we will study
    this wonderful technology later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We want to understand how the API keys work, so let's take the case of Flickr.
    The important thing here is to understand how the API keys work because the same
    concept can be applied to companies like Google, Facebook, and so on. For those
    unfamiliar with Flickr, it is an application in the cloud in which we can store
    our photos, images, screenshots, or similar files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start working with this authentication model, we first obtain an API key;
    in our example with Flickr, you can do this using the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.flickr.com/services/developer/api/](https://www.flickr.com/services/developer/api/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we ask for our API key, we are asked to enter the name of the application
    that we will create and with which we use the API key. Once we enter the information
    requested and submit it, Flickr will deliver us a couple of values; they are a
    secret and a key. Both are displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![API keys](img/0109OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each application we create is part of Flickr App Garden. App Garden is nothing
    but the set of all applications created by all Flickr members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that when creating an API key, we consciously accept certain terms
    of use of the provider. These terms clearly detail what we can and can''t do;
    for example, Flickr says:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a. You shall:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Comply with the Flickr Community Guidelines at [www.flickr.com/guidelines.gne](http://www.flickr.com/guidelines.gne),
    the Flickr Terms of Use at [http://www.flickr.com/terms.gne](http://www.flickr.com/terms.gne),
    and the Yahoo! Terms of Service at [http://docs.yahoo.com/info/terms/](http://docs.yahoo.com/info/terms/).*'
  prefs: []
  type: TYPE_NORMAL
- en: '*…*'
  prefs: []
  type: TYPE_NORMAL
- en: '*b. You shall not:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use Flickr APIs for any application that replicates or attempts to replace
    the essential user experience of Flickr.com*'
  prefs: []
  type: TYPE_NORMAL
- en: '*…*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, by requiring that users accept the terms of use, API key providers prevent
    the abusive use of its APIs. So, if someone starts disrespecting agreements, the
    provider withdraws the API key. Flickr has a large set of methods that we can
    use in our applications; we will try one of them to show how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flickr.photos.getRecent` method lists all recent photos that have been
    posted in Flickr, and we can invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.flickr.com/services/rest?method=flickr.photos.getRecent&;&api+key=[your_api_key_from_flicker]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the key we just generated earlier, and let''s perform the request
    using the browser as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![API keys](img/0109OS_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First notice how information travels through a secure channel (HTTPS). Then,
    when receiving the request, Flickr authenticates the user by reading the information
    from the API key with the secret key that belongs to the user. Once these validations
    are successful, the server delivers the response to the client. Thus, we obtain
    a response with all the photos that have been recently posted within Flickr. As
    you'll notice, this way, you can easily create applications using the provider's
    API. Also, the provider will allow you to authenticate, access public information,
    and be responsible to keep track of volume or the number of API calls you've made
    using the API key, in order to validate that the use complies with the agreements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through all possible models of authentication. We will
    use all of them in the next chapter, and we will apply them to the web service
    functionality we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you had trouble with any of the examples, you can continue to the next
    chapter. As for your better understanding, we will go step-by-step and more in-depth
    into how we can leverage each available authentication model.
  prefs: []
  type: TYPE_NORMAL
- en: As you realize, it is important to choose the correct security management, otherwise
    information is exposed and can easily be intercepted and used by third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in this chapter, we reviewed the differences between authentication
    and authorization. Both concepts are very important and definitely impossible
    to put aside in the context of security terms.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will ask you to join us to go ahead and secure our web service.
  prefs: []
  type: TYPE_NORMAL
