- en: Chapter 2. The Importance of Securing Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 保护网络服务的重要性
- en: Look at you; you have made it to Chapter 2; congratulations! This chapter is
    quite important because it is related to a concept that is implicit in software,
    which is **security**. This is very important because software is used by companies
    and people like us. Sometimes, we share very important and confidential information
    through software, and that is why this topic becomes so important for everybody.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 看你；你已经到达了第二章；恭喜！这一章非常重要，因为它与软件中隐含的一个概念有关，那就是**安全**。这一点非常重要，因为软件被公司和像我们这样的人使用。有时，我们通过软件分享非常重要的机密信息，这就是为什么这个话题对每个人来说都如此重要。
- en: In this chapter, we will take you through the basic aspects related to the management
    of security in computer systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍与计算机系统安全管理相关的基本方面。
- en: We will explore and implement each of the different security mechanisms and
    scenarios in which they can be used.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索和实施不同的安全机制及其可用场景。
- en: Also, you'll learn how to use a protocol analyzer. This will allow us to demonstrate
    how an attack can be performed and determine the impact of this attack when it
    achieves its target, in this case, our information. Also, you will be able to
    imagine more options to implement security in web services.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将学习如何使用协议分析器。这将使我们能够展示攻击是如何进行的，并确定当攻击达到目标时，即在我们的信息中，这种攻击的影响。你还将能够想象出更多在Web服务中实施安全性的选项。
- en: As everything needs practice, you will go through a simple example of code to
    learn the differences between authentication and authorization. Get ready for
    an interesting and useful topic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一切都需要实践，你将通过一个简单的代码示例来学习身份验证和授权之间的区别。准备好一个有趣且实用的主题。
- en: 'In this chapter, we will cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Understanding the importance of security management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解安全管理的重要性
- en: Exploring and implementing the different available mechanisms of security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和实施不同的安全机制
- en: Using a protocol analyzer to intercept requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议分析器截获请求
- en: Understanding the difference between authentication and authorization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解身份验证和授权之间的区别
- en: The importance of security
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的重要性
- en: The management of security is one of the main aspects to consider when designing
    applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安全管理是设计应用程序时需要考虑的主要方面之一。
- en: 'No matter what, neither the functionality nor the information of organizations
    can be exposed to all users without any kind of restriction. Consider the case
    of a human resource management application that allows you to consult the wages
    of employees, for example: if the company manager needs to know the salary of
    one of their employees, it is not something of great importance. However, in the
    same context, imagine that one of the employees wants to know the salary of their
    colleagues; if access to this information is completely open, it can generate
    problems among employees with varied salaries.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论怎样，组织的功能和信息都不能没有任何限制地暴露给所有用户。考虑一下人力资源管理系统的情况，它可以让你查询员工的工资，例如：如果公司经理需要知道他们员工之一的工资，这并不是什么重要的事情。然而，在同样的背景下，想象一下，如果其中一名员工想知道他们同事的工资；如果对这个信息的访问是完全开放的，这可能会在薪酬不同的员工之间产生问题。
- en: An even more critical example can be the case where the bank XYZ increases a
    bank balance every time a customer or a third party makes a deposit into one of
    their accounts using an ATM. The IT manager envisions that this functionality
    could be common, and decides to implement it as a web service. Right now, this
    functionality is limited to bank users logged in to the application that uses
    this web service. Suppose that the visions of the future of the IT manager come
    true, and this functionality is now required from an ATM; raising this requirement
    quickly indicates that such functionality is implemented and can be used by invoking
    the web service. So far, there may be no security loopholes since ATMs are likely
    to have a security system that controls access, and thus operating system access
    to the functionality of the web service is also indirectly controlled.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更加关键的例子可能是银行XYZ在客户或第三方通过ATM向其账户存款时，增加银行余额的情况。IT经理设想这种功能可能会很常见，并决定将其作为一项网络服务来实现。目前，这项功能仅限于使用该网络服务的应用程序登录的银行用户。假设IT经理对未来的愿景成真，现在这项功能需要从ATM实现；迅速提出这一需求表明这种功能已经实现，并且可以通过调用网络服务来使用。到目前为止，可能没有安全漏洞，因为ATM很可能有一个控制系统来控制访问，因此操作系统对网络服务功能的访问也是间接控制的。
- en: Now, imagine that the company ABC wants a similar functionality to increase
    the balance in one of its employee's bank account by an *x* amount in recognition
    of some kind of contribution to the company. What happens to the functionality
    of the web service? Do you think you can again trust the application that handles
    its own security scheme to control access to its functionality? Even if we do
    trust this mechanism, what if the request is intercepted by a sniffer? Then, anyone
    who knows how to perform the request may increase the balance. These questions,
    when answered, throw in the response in quite a logical way. Exposed, these scenarios
    now sound quite logical so that whoever authenticates the user to have access
    to this functionality is the web service, and as such, should be entrusted with
    the management scheme security systems under all circumstances. It doesn't matter
    if invocations are from the organization itself or from an external institution;
    security control must be present in order to expose a sensitive functionality
    such as the one we just outlined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设公司ABC希望有一种类似的功能，通过向其员工的银行账户增加一个*x*金额来认可他们对公司的某种贡献。网络服务的功能会发生什么变化？你认为你还能再次信任处理其自身安全方案的应用程序来控制对其功能的访问吗？即使我们信任这个机制，如果请求被嗅探器截获怎么办？那么，任何知道如何执行请求的人都可以增加余额。当这些问题得到回答时，它们以一种相当逻辑的方式抛出。公开这些场景现在听起来相当合理，因此验证用户有权访问此功能的网络服务应该是可以信赖的，并且在这种情况下，应该被委托管理安全系统。无论是来自组织本身还是来自外部机构，都必须存在安全控制，以便公开像我们刚才概述的敏感功能。
- en: When sharing existing information or functionality through web services, it
    is well known that we don't depend on programming languages, architectures, or
    system platforms to interact with. This gives us flexibility and saves us from
    having to rewrite the existing functionality. Going further, we should understand
    that these features have an impact on data confidentiality, as we are going to
    share information and/or functionality with entities or systems. This way, we
    can accomplish the business objectives and definitely prevent intruders from reading
    our information; or even worse, a third party not authorized has access to functionalities
    exposed by our services. Hence, access to them must be rigorously analyzed and
    our exposed services must be correctly ensured.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过网络服务共享现有信息或功能时，众所周知，我们并不依赖于编程语言、架构或系统平台来交互。这给了我们灵活性，并使我们免于重写现有功能。进一步来说，我们应该理解这些特性对数据机密性有影响，因为我们将要与实体或系统共享信息和/或功能。这样，我们可以实现业务目标，并肯定防止入侵者读取我们的信息；或者更糟糕的是，未经授权的第三方能够访问我们服务公开的功能。因此，对这些功能的访问必须严格分析，并且我们公开的服务必须得到正确保障。
- en: Security management options
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全管理选项
- en: 'Java provides some options for security management. Right now, we will explain
    some of them and demonstrate how to implement them. All authentication methods
    are practically based on credential delivery from the client to the server. There
    are several methods to perform this, which are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一些安全管理选项。目前，我们将解释其中的一些，并演示如何实现它们。所有认证方法实际上都是基于从客户端到服务器的凭证传递。有几种方法可以执行此操作，它们包括：
- en: BASIC authentication
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: DIGEST authentication
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要认证
- en: CLIENT CERT authentication
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端证书认证
- en: Using API keys
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API密钥
- en: Security management in applications built with Java, including the ones with
    RESTful web services, always rely on JAAS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java构建的应用程序中的安全管理，包括具有RESTful Web服务的应用程序，始终依赖于JAAS。
- en: '**Java Authentication and Authorization Service** (**JAAS**) is a framework
    that is part of Java Platform Enterprise Edition. Hence, it is the default standard
    to handle an application''s security in Java; it allows you to implement authorization,
    and it allows authentication controls over applications with the purpose of protecting
    resources that belong to the application. If you want to know more about JAAS,
    you can check out the following link:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java认证和授权服务**（**JAAS**）是Java平台企业版的一部分的框架。因此，它是处理Java应用程序安全性的默认标准；它允许你实现授权，并允许对应用程序进行认证控制，以保护属于应用程序的资源。如果你想了解更多关于JAAS的信息，你可以查看以下链接：'
- en: '[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html)'
- en: If you don't want to use JAAS, of course it is always possible to create our
    own implementation to handle securities, but it would be hard. So, why don't we
    save ourselves some time, effort, and peace by implementing this useful technology?
    It is recommended to use standard implementations whenever possible. In our development
    exercise, we will use JAAS for the first three methods of authentication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用JAAS，当然始终可以创建自己的实现来处理安全，但这会很困难。所以，我们为什么不节省一些时间，精力和平静，通过实现这项有用的技术呢？建议尽可能使用标准实现。在我们的开发练习中，我们将使用JAAS进行前三种认证方法。
- en: Authorization and authentication
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权和认证
- en: When you these terms, it is very easy to get confused, but they have different
    meanings when you have a security system approach. In order to clarify these terms,
    we will explain them in this section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这些术语时，很容易混淆，但在有安全系统方法的情况下，它们有不同的含义。为了澄清这些术语，我们将在本节中解释它们。
- en: Authentication
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: In a nutshell, this term refers to *who you are*. It is the process to identify
    a user, usually through their *username* and *password*. When we use this concept,
    we are trying to ensure the identity of the user and we verify the identity the
    user claims to be. Also, it doesn't have anything to do with the access rights
    the user has.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个术语指的是*你是谁*。这是通过用户的*用户名*和*密码*来识别用户的过程。当我们使用这个概念时，我们试图确保用户的身份，并验证用户声称的身份。此外，它与用户拥有的访问权限无关。
- en: 'Security research has specified a list of factors that should be verified in
    order to achieve positive authentication. This list contains three elements, where
    it is very common to use two of them, but preferably we should use all of them.
    These elements are the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安全研究已经指定了一个应该验证的因素列表，以实现积极的认证。这个列表包含三个元素，其中使用其中两个是非常常见的，但最好我们使用所有这些。以下元素如下：
- en: '**Knowledge factors**: This element implies something the user **knows**, for
    example, a password, pass phrase, or personal identification number (PIN). Another
    example is challenge response, where the user must answer a question, software
    token, or phone serving as a software token.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识因素**：这个元素意味着用户*知道*的东西，例如，密码，通行短语或个人识别码（PIN）。另一个例子是挑战响应，用户必须回答一个问题，软件令牌或作为软件令牌的手机的电话。'
- en: '**Ownership factors**: This is something the user *has*, for example, a wrist
    band (in case of physical authentication), ID card, security token, or cell phone
    with a built-in hardware token.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥有因素**：这是用户*拥有*的东西，例如，一个手环（在物理认证的情况下），身份证，安全令牌，或者内置硬件令牌的手机。'
- en: '**Inherence factors**: This is something the user *is* or *does*, for example,
    fingerprint or retinal pattern, DNA sequence, signature, face, voice, unique bio-electric
    signals, or other biometric identifiers.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内在因素**：这是用户*是*或*做*的某事，例如指纹或视网膜图案、DNA序列、签名、面部、声音、独特的生物电信号或其他生物识别标识符。'
- en: Authorization
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权
- en: In a few words, this term refers to *what you can do*. It is the process of
    giving a user permission to do or have something. When we talk about software,
    we have a system administrator that is in charge of defining the system which
    users are allowed to access and what the privileges of use are (such as access
    to which file directories, access period, amount of allocated storage space, and
    so forth).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个术语指的是*你能做什么*。它是指授予用户执行或拥有某物的权限的过程。当我们谈论软件时，我们有一个系统管理员负责定义用户可以访问的系统以及使用权限（例如访问哪些文件目录、访问期限、分配的存储空间数量等等）。
- en: Authorization is often seen as both the introductory setting up of permissions
    by a system administrator and the checking of the permission values that have
    already been set up when a user is getting access.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 授权通常被视为系统管理员设置权限的初始设置以及当用户获取访问权限时检查已设置的权限值。
- en: Access control
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制
- en: 'A very common use of authentication and authorization is access control. A
    computer system that is supposed to be used only by authorized users must attempt
    to detect and reject unauthorized users. Access is controlled by persisting on
    an authentication process to establish the user''s identity with a certain level
    of confidence, also conferring privileges specified for that identity. Let''s
    name some examples of access control involving authentication in different scenarios,
    such as the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权的一个非常常见的用途是访问控制。一个仅应由授权用户使用的计算机系统必须尝试检测并拒绝未经授权的用户。通过持续进行认证过程以建立用户身份并具有一定程度的信心，同时授予该身份指定的权限来控制访问。让我们举一些在不同场景中涉及认证的访问控制示例，如下所示：
- en: Calling for photo ID when a contractor first arrives at a house to do some work
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当承包商首次到达房屋进行工作时要求出示照片ID
- en: Implementing captcha as a way of verification that a user is a human being and
    not a computer program
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施验证码作为验证用户是人类而不是计算机程序的一种方式
- en: When using a **One Time Password** (**OTP**) obtained on telenetwork-enabled
    devices such as mobile phones as an authentication password/PIN
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用在手机等网络设备上获得的**一次性密码**（**OTP**）作为认证密码/PIN
- en: A computer program that uses a blind credential in order to authenticate to
    another program
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用盲凭证以认证到另一个程序的计算机程序
- en: When you enter a country with a passport
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你用护照进入一个国家
- en: When you log in to a computer
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你登录到计算机
- en: When a service uses a confirmation e-mail to verify ownership of an e-mail address
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一项服务使用确认电子邮件来验证电子邮件地址的所有权
- en: Using an Internet banking system
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互联网银行系统
- en: When you withdraw cash from an ATM
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你从ATM机取款
- en: Sometimes, the ease of access is adjusted against the strictness of access checks.
    For example, a small transaction usually doesn't require a signature of the authenticated
    person as proof of the transaction's authorization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，访问的便利性会与访问检查的严格性相权衡。例如，一笔小额交易通常不需要经过认证的人的签名作为交易授权的证明。
- en: However, security experts argue that it is impossible to prove the user's identity
    with absolute certainty. It is only possible to apply a set of tests which, if
    passed, have been previously declared as a minimum to confirm the identity. The
    problem lies in how to determine which tests are enough; it depends on the company
    to determine this set.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安全专家认为，不可能绝对确定用户的身份。只能应用一套测试，如果通过，则已事先宣布为确认身份的最低标准。问题在于如何确定哪些测试足够；这取决于公司来确定这一套。
- en: Transport layer security
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层安全性
- en: 'In this section, we highlight some of the main features of TLS:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们强调TLS的一些主要特性：
- en: Its predecessor is **Secure Sockets Layer** (**SSL**)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的前身是**安全套接字层**（**SSL**）
- en: It is a cryptographic protocol
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个加密协议
- en: It provides security communication over the Internet
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供互联网上的安全通信
- en: It authenticates the counterpart through X.509 certificates (asymmetric cryptography)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过X.509证书（非对称加密）验证对方
- en: It allows client-server applications to communicate over the network and prevents
    eavesdropping and tampering
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许客户端-服务器应用程序通过网络进行通信，并防止窃听和篡改
- en: TLS is often implemented on top of the Transport layer protocols
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS 通常在传输层协议之上实现。
- en: It encapsulates application-specific protocols such as HTTP, FTP, SMTP, NNTP,
    and XMPP
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它封装了特定于应用程序的协议，如 HTTP、FTP、SMTP、NNTP 和 XMPP。
- en: The use of TLS should be delegated, especially when credentials, updates, deletions,
    and any kind of value transactions are performed
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS 的使用应委托给其他部门，尤其是在执行凭证、更新、删除以及任何类型的价值交易时。
- en: The overhead of TLS is very low on modern hardware, with a little increase of
    latency, but this represents more safety for the end user
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代硬件上，TLS 的开销非常低，只是略微增加了延迟，但这为最终用户提供了更多的安全性。
- en: Basic authentication by providing user credentials
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过提供用户凭证进行基本身份验证
- en: Possibly, basic authentication is one of the most used techniques in all types
    of applications. The user, before gaining functionality over the application,
    is requested to enter a username and password. Both are validated in order to
    verify whether the credentials are correct (they belong to an application user).
    We are 99 percent sure you have performed this technique at least once, maybe
    through a customized mechanism, or if you have used the JEE platform, probably
    through JAAS. This kind of control is known as **basic authentication**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，基本身份验证是所有类型应用程序中最常用的技术之一。在用户获得应用程序功能之前，会被要求输入用户名和密码。这两个信息都会被验证，以确认凭证是否正确（它们属于应用程序用户）。我们
    99% 确定您至少执行过这种技术一次，可能是通过定制机制，或者如果您使用过 JEE 平台，可能通过 JAAS。这种控制被称为 **基本身份验证**。
- en: The main problem with this security implementation is that credentials are propagated
    in a plain way from the client to the server. This way, any sniffer could read
    the sent packages over the network. We will consider an example using a tool named
    Wireshark; it is a protocol analyzer that will show this problem. For installation,
    we can go to the link [http://www.wireshark.org/download.html](http://www.wireshark.org/download.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全实现的 主要问题是凭证以明文方式从客户端传播到服务器。这种方式下，任何嗅探器都可以读取通过网络发送的数据包。我们将通过一个名为 Wireshark
    的工具来考虑一个示例；它是一个协议分析器，将展示这个问题。对于安装，我们可以访问链接 [http://www.wireshark.org/download.html](http://www.wireshark.org/download.html)。
- en: The installation is pretty basic (click on **Next** all the way). For this reason,
    we will not show screenshots of these steps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装相当简单（一路点击 **下一步**）。因此，我们不会展示这些步骤的截图。
- en: Now, we are going to modify the project from [Chapter 1](ch01.html "Chapter 1. Setting
    Up the Environment"), *Setting Up the Environment*, where the user tries to invoke
    any of the functions of the web service. The user will be requested to enter a
    username and password; once these are verified, the user will have access to the
    web service functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改来自 [第 1 章](ch01.html "第 1 章。设置环境")，*设置环境* 的项目，其中用户尝试调用 Web 服务的任何功能。用户将被要求输入用户名和密码；一旦这些信息得到验证，用户将能够访问
    Web 服务的功能。
- en: 'In order to have a working example, let''s start our application server JBoss
    AS 7; then, go to the `bin` directory and execute the file `add-user.bat` (the
    `.sh` file for UNIX users). Finally, we will create a new user as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个可工作的示例，让我们启动我们的应用程序服务器 JBoss AS 7；然后，转到 `bin` 目录并执行文件 `add-user.bat`（UNIX
    用户的 `.sh` 文件）。最后，我们将创建一个新用户，如下所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭证进行基本身份验证](img/0109OS_02_01.jpg)'
- en: The most important thing here is that you should select `Application User` in
    the first question and assign it an `admin` role. This will match with the information
    defined in the `web.xml` file, which will be explained later when we implement
    securities inside our application. As a result, we will have a new user in the
    `JBOSS_HOME/standalone/configuration/application - users.properties` file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的是，您应该在第一个问题中选择 `应用程序用户` 并为其分配一个 `管理员` 角色。这将与 `web.xml` 文件中定义的信息相匹配，这将在我们实现应用程序内的安全措施时进行解释。结果，我们将在
    `JBOSS_HOME/standalone/configuration/application - users.properties` 文件中有一个新用户。
- en: 'JBoss is already set with a default security domain called `other`; this domain
    uses the information stored in the file we mentioned earlier in order to authenticate.
    Right now, we will configure the application to use this security domain inside
    the folder `WEB-INF` from the `resteasy-examples` project. Let''s create a file
    named `jboss-web.xml` with the following content:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss已经设置了一个默认的安全域，称为`other`；此域使用我们之前提到的文件中存储的信息进行身份验证。现在，我们将配置应用程序在`resteasy-examples`项目的`WEB-INF`文件夹内使用此安全域。让我们创建一个名为`jboss-web.xml`的文件，其内容如下：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alright, let''s configure the file `web.xml` in order to aggregate the security
    constraints. In the following block of code, you will see in bold what you should
    add:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们配置`web.xml`文件以聚合安全约束。在下面的代码块中，您将看到需要加粗的内容：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From a terminal, let''s go to the home folder of the `resteasy-examples` project
    and execute `mvn jboss-as:redeploy`. Now, we will test our web service as we did
    in [Chapter 1](ch01.html "Chapter 1. Setting Up the Environment"), *Setting Up
    the Environment*, using SOAP UI. We will perform a request using the `POST` method
    to the URL `http://localhost:8080/resteasy-examples/services/person/` with the
    following XML:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端，让我们转到`resteasy-examples`项目的家目录并执行`mvn jboss-as:redeploy`。现在，我们将像在[第1章](ch01.html
    "第1章。设置环境")中那样测试我们的Web服务，使用SOAP UI。我们将使用`POST`方法向URL`http://localhost:8080/resteasy-examples/services/person/`发送以下XML：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We obtain the following response:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下响应：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭证进行基本身份验证](img/0109OS_02_02.jpg)'
- en: 'SOAP UI shows us the HTTP 401 error, which means that the request wasn''t authorized.
    This is because we performed the request without delivering the credentials to
    the server. In order to do this, we have to click on the (**…**) button that is
    located in the left-bottom spot of SOAP UI and enter the user''s credentials we
    just created, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP UI显示我们HTTP 401错误，这意味着请求未被授权。这是因为我们没有向服务器提供凭证就执行了请求。为了做到这一点，我们必须点击位于SOAP
    UI左下角的(**…**)按钮，并输入我们刚刚创建的用户凭证，如下面的截图所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭证进行基本身份验证](img/0109OS_02_03.jpg)'
- en: Now is the time to enable our traffic analyzer. Let's start Wireshark and set
    it to analyze the traffic inside the loopback address. From the **Main** menu,
    navigate to **Capture** | **Interfaces**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候启用我们的流量分析器了。让我们启动Wireshark并将其设置为分析环回地址内的流量。从**主**菜单导航到**捕获** | **接口**。
- en: Check the option **lo0**, as shown in the following screenshot, and then click
    on the **Start** button. This way, all traffic that goes through the address 127.0.0.1
    or its equivalent localhost will be intercepted for our analysis.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**lo0**选项，如下面的截图所示，然后点击**开始**按钮。这样，所有通过地址127.0.0.1或其等效的localhost的流量都将被拦截以供我们分析。
- en: 'Also, in the field `Filter`, we will type `http` just to intercept the HTTP
    request and response, as shown in the screenshot that follows later:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`Filter`字段中，我们只需输入`http`以拦截HTTP请求和响应，如下面的截图所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_04.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭证进行基本身份验证](img/0109OS_02_04.jpg)'
- en: 'Have a look at the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭证进行基本身份验证](img/0109OS_02_05.jpg)'
- en: 'Once we have done this, we will perform the request operation from SOAP UI.
    Once again, SOAP UI shows us a HTTP 201 message; this time, the request is successfully
    processed. You can see the following columns of information in Wireshark:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们将从SOAP UI执行请求操作。再次，SOAP UI显示HTTP 201消息；这次，请求被成功处理。您可以在Wireshark中看到以下信息列：
- en: '**No**: This column identifies the request or response in a unique way'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**否**：此列以独特的方式标识请求或响应'
- en: '**Time**: This column identifies the time to execute the operation'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：此列标识执行操作的时间'
- en: '**Source**: This column identifies the address where requests/responses are
    originated'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：此列标识请求/响应的起始地址'
- en: '**Destination**: This column identifies the target IP address to perform a
    HTTP request/response'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：此列标识执行HTTP请求/响应的目标IP地址'
- en: '**Protocol**: This column identifies the protocol where requests/responses
    are performed'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：此列标识执行请求/响应的协议'
- en: '**Length**: This column identifies the request/response length'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**：此列标识请求/响应的长度'
- en: '**Info**: This column identifies information related to the request/response'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：此列标识与请求/响应相关的信息'
- en: 'Now, it is time to watch the information traffic on Wireshark, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在Wireshark上观察信息流量了，如下所示：
- en: '![Basic authentication by providing user credentials](img/0109OS_02_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![通过提供用户凭据进行基本认证](img/0109OS_02_06.jpg)'
- en: Notice how Wireshark shows us we are performing a POST (info) operation using
    the protocol HTTP with an XML string (protocol) to the target address `127.0.0.1`
    (destination). Also, you can read the username and password. Hence, this method
    is not very safe for security implementation because anyone can access this information
    and perform a phishing attack.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Wireshark如何显示我们正在使用HTTP协议和XML字符串（协议）对目标地址`127.0.0.1`（目的地）执行POST（信息）操作。此外，您还可以读取用户名和密码。因此，这种方法对于安全实现来说并不非常安全，因为任何人都可以访问这些信息并执行钓鱼攻击。
- en: 'You can find the source code for this chapter at the following URL:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此URL找到本章的源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication)'
- en: Digest access authentication
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要访问认证
- en: This authentication method makes use of a hash function to encrypt the password
    entered by the user before sending it to the server. This, obviously, makes it
    much safer than the basic authentication method, in which the user's password
    travels in plain text that can be easily read by whoever intercepts it. To overcome
    such drawbacks, digest md5 authentication applies a function on the combination
    of the values of the username, realm of application security, and password. As
    a result, we obtain an encrypted string that can hardly be interpreted by an intruder.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种认证方法使用散列函数在将密码发送到服务器之前加密用户输入的密码。这显然比基本认证方法更安全，在基本认证方法中，用户的密码以明文形式传输，容易被拦截者读取。为了克服这些缺点，摘要MD5认证对用户名、应用安全域和密码的值组合应用一个函数。结果，我们得到一个几乎无法被入侵者解读的加密字符串。
- en: To better understand this process, we will show you a simple explanation extracted
    from Wikipedia.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个过程，我们将向您展示一个从维基百科提取的简单解释。
- en: An example with explanation
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有解释的示例
- en: '*The following example was originally given in RFC 2617 and is expanded here
    to show the full text expected for each request and response. Note that only the
    `auth` (authentication) quality of protection code is covered—at the time of writing,
    only the Opera and Konqueror web browsers are known to support `auth-int` (authentication
    with integrity protection). Although the specification mentions HTTP Version 1.1,
    the scheme can be successfully added to the Version 1.0 server, as shown here.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下示例最初在RFC 2617中给出，此处扩展以显示每个请求和响应预期的完整文本。请注意，此处仅涵盖`auth`（认证）保护代码的质量——在撰写本文时，只有Opera和Konqueror网络浏览器已知支持`auth-int`（具有完整性保护的认证）。尽管规范提到了HTTP版本1.1，但该方案可以成功添加到版本1.0服务器，如下所示。*'
- en: '*This typical transaction consists of the following steps:*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种典型的事务包括以下步骤：*'
- en: '*The client asks for a page that requires authentication but does not provide
    a username and password. Typically, this is because the user simply entered the
    address or followed a link to the page.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户端请求需要认证的页面，但没有提供用户名和密码。通常，这是因为用户只是输入了地址或跟随了一个链接到该页面。*'
- en: '*The server responds with the 401 "Unauthorized" response code, providing the
    authentication realm and a randomly generated, single-use value called `nonce`.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器以401“未经授权”的响应代码响应，提供认证域和一个随机生成的、一次性使用的值，称为`nonce`。*'
- en: '*At this point, the browser will present the authentication realm (typically,
    a description of the computer or system being accessed) to the user and prompt
    for a username and password. The user may decide to cancel at this point.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*在此阶段，浏览器将向用户展示认证域（通常是正在访问的计算机或系统的描述）并提示输入用户名和密码。用户可能会选择在此处取消。*'
- en: '*Once a username and password have been supplied, the client resends the same
    request but adds an authentication header that includes the response code.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦提供了用户名和密码，客户端将重新发送相同的请求，但添加一个包含响应代码的认证头。*'
- en: '*In this example, the server accepts the authentication and the page is returned.
    If the username is invalid and/or the password is incorrect, the server might
    return the *401* response code and the client will prompt the user again.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*在此示例中，服务器接受认证并返回页面。如果用户名无效和/或密码不正确，服务器可能会返回 *401* 响应代码，客户端将再次提示用户。*'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A client may already have the required username and password without needing
    to prompt the user, for example, if they have previously been stored by a web
    browser.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可能已经拥有所需的用户名和密码，无需再次提示用户，例如，如果它们之前已被网络浏览器存储。
- en: If you want to know more about this mechanism, you can visit Wikipedia for the
    complete article following the link [http://en.wikipedia.org/wiki/Digest_access_authentication](http://en.wikipedia.org/wiki/Digest_access_authentication).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于此机制的信息，你可以通过以下链接访问维基百科上的完整文章 [http://en.wikipedia.org/wiki/Digest_access_authentication](http://en.wikipedia.org/wiki/Digest_access_authentication)。
- en: You can also read the specification RFC 2617, which is available at [https://www.ietf.org/rfc/rfc2617.txt](https://www.ietf.org/rfc/rfc2617.txt).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以阅读规范 RFC 2617，它可在 [https://www.ietf.org/rfc/rfc2617.txt](https://www.ietf.org/rfc/rfc2617.txt)
    找到。
- en: Now, let's test this mechanism in our example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的示例中测试此机制。
- en: 'In order to start, we must ensure that the environment variable `JAVA_HOME`
    is already set and added to the `PATH` variable. So, you can ascertain this by
    typing the following command in a terminal:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动，我们必须确保环境变量 `JAVA_HOME` 已经设置并添加到 `PATH` 变量中。因此，你可以在终端中键入以下命令来确认：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will display the information shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下截图中的信息：
- en: '![An example with explanation](img/0109OS_02_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![带有解释的示例](img/0109OS_02_07.jpg)'
- en: This command shows us the Java version installed on our PC. In case you obtain
    an error instead of the previous output, you should create the environment variable
    `JAVA_HOME`, add it to the `PATH` variable, and repeat the verification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示了我们的电脑上安装的 Java 版本。如果你获得的是错误信息而不是之前的输出，你应该创建环境变量 `JAVA_HOME`，将其添加到 `PATH`
    变量中，并重复验证。
- en: 'Now, in order to perform what we explained before, we need to generate a password
    for our example user. We have to generate the password using the parameters we
    talked about earlier—username, realm, and password. Let''s go to the directory
    of `JBOSS_HOME/modules/org/picketbox/main/` from a terminal and type the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了执行我们之前解释的内容，我们需要为我们的示例用户生成一个密码。我们必须使用我们之前讨论的参数——用户名、域和密码来生成密码。让我们从终端进入
    `JBOSS_HOME/modules/org/picketbox/main/` 目录，并键入以下命令：
- en: '`java -cp picketbox-4.0.7.Final.jar org.jboss.security.auth.callback.RFC2617Digest
    username MyRealmName password`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`java -cp picketbox-4.0.7.Final.jar org.jboss.security.auth.callback.RFC2617Digest
    username MyRealmName password`'
- en: 'We will obtain the following result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下结果：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Through this process, we obtain the encrypted password and use it in our password
    storage file (the `JBOSS_HOME/standalone/configuration/application-users.properties`
    file). We must replace the password in the file, and it will be used for the user
    `username`. We have to replace it because the old password doesn't contain the
    realm name information of the application. As an alternative, you can create a
    new user using the file `add-user.sh`; you just have to deliver the realm information
    when you are requested.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个过程，我们获得加密的密码，并将其用于我们的密码存储文件（`JBOSS_HOME/standalone/configuration/application-users.properties`
    文件）。我们必须替换文件中的密码，它将被用于用户 `username`。我们必须替换它，因为旧密码不包含应用程序的域名称信息。作为替代，你可以使用 `add-user.sh`
    文件创建新用户；你只需在请求时提供域信息即可。
- en: 'In order to make our application work, we just need to make a little change
    in the `web.xml` file. We have to modify the `auth-method` tag, change the value
    `FORM` to `DIGEST`, and set the application realm name in the following way:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用工作，我们只需要在 `web.xml` 文件中做一点修改。我们必须修改 `auth-method` 标签，将值 `FORM` 更改为 `DIGEST`，并按以下方式设置应用程序域名称：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s create a new security domain in JBoss so that we can manage the
    authentication mechanism `DIGEST`. On the `<security-domains>` section of the
    `JBOSS_HOME/standalone/configuration/standalone.xml` file, let''s add the following
    entry:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 JBoss 中创建一个新的安全域，以便我们可以管理 `DIGEST` 认证机制。在 `JBOSS_HOME/standalone/configuration/standalone.xml`
    文件的 `<security-domains>` 部分，让我们添加以下条目：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, in the application, change the security domain name in the file `jboss-web.xml`,
    as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在应用中，请将文件 `jboss-web.xml` 中的安全域名进行更改，如下所示：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will change the authentication method from `BASIC` to `DIGEST` in the `web.xml`
    file. Also, we will enter the name of the security realm. All these changes must
    be applied in the tag `login-config` in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, restart the application server and redeploy the application on JBoss.
    For this, execute the following command in the terminal command line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s enable the catching of traffic through Wireshark and test the web service
    again using SOAP UI. First, we should change the field `Authentication Type` from
    Global HTTP Settings to **SPNEGO/Kerberos**. A very useful trick is to tell SOAP
    UI not to use the basic authentication method. Once we execute the request, Wireshark
    will tell us the message shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![An example with explanation](img/0109OS_02_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the screenshot, let''s first confirm that all the steps described
    earlier are performed in this authentication method. Let''s keep track using the
    **No** field in Wireshark:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, the request is performed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: In step 7, the server returns an error message code HTTP 401 with the generated
    `nonce` value. The `nonce` value helps to avoid replay attacks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, the request is performed again. This time, the information required
    for authentication is included and all this information is encrypted in the same
    way we described earlier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in step 11, we obtain the response that tells us the request has been
    successfully executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice, this is a more secure authentication method, mainly used
    if you don't want the overhead of full transport security through TLS/SSL encryption.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter at the following URL:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Authentication through certificates
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a mechanism in which a trust agreement is established between the server
    and the client through certificates. They must be signed by an agency established
    to ensure that the certificate presented for authentication is legitimate, which
    is known as CA.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine an application that uses this mechanism of security. When the
    client attempts to access a protected resource, instead of providing a username
    or password, it presents the certificate to the server. This is the certificate
    that contains the user information for authentication; in other words, the credentials,
    besides a unique private-public key pair. The server determines if the user is
    legitimate through the CA. Then, it verifies whether the user has access to the
    resource. Also, you should know that this authentication mechanism must use HTTPS
    as the communication protocol as we don't have a secure channel and anyone could
    steal the client's identity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will show how to do this in our example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we turn ourselves into the CA; they are usually companies such
    as VERISIGN or others. However, as we want to save you money, we will do it this
    way. The first thing we need is a key for the CA (which is ourselves), and we
    will sign the certificates for the application server and users. As the purpose
    of this book is to explain how this method works and not how to generate certificates,
    we will not include all steps required to generate them, but we include them on
    GitHub at the following link:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s start. First, copy the `server.keystore` and `server.trutstore`
    files to the folder directory `JBOSS_HOME/standalone/configuration/`. You can
    download these files from GitHub using the following link:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we mentioned before, this security mechanism requires our application
    server to use HTTPS as the communication protocol. So, we must enable HTTPS. Let''s
    add a connector in the `standalone.xml` file; look for the following line:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following block of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we add the security domain, as shown:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we need two files: `my-users.properties` and `my-roles.properties`;
    both are empty and located in the `JBOSS_HOME/standalone/configuration` path.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the `<user-data-constraint>` tag in the `web.xml` file in the following
    way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, change the authentication method to `CLIENT-CERT`, as shown:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, change the security domain in the `jboss-web.xml` file in the following
    way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, restart the application server and redeploy the application with Maven
    using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to test this authentication method, we will have to first perform
    some configurations in SOAP UI. First, let''s go to the installation directory,
    find the file `vmoptions.txt`, and add the following line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we will change the SSL settings of SOAP UI. For this, you have to navigate
    to **File** | **Preferences** from the principal menu.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'From the pop-up window, select the **SSL Settings** tab and enter the values
    shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication through certificates](img/0109OS_02_09.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: '**KeyStore** is the place where you should have copied the `.pfx` file. Note
    that **KeyStore Password** is `changeit` and check the option **requires client
    authentication**.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will test the modifications we just did; so, let''s enable the traffic
    analyzer and execute the request using SOAP UI again. Wireshark will show the
    information shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication through certificates](img/0109OS_02_10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: As you can see, all information is encrypted and it can't be interpreted. So,
    if the packages are transmitted and they are intercepted in the network, the information
    is not vulnerable to attacks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code of this section on GitHub at the following URL:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: API keys
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advent of cloud computing, it is not difficult to think of applications
    that integrate with many others available in the cloud. Right now, it's easy to
    see how applications interact with Flickr, Facebook, Twitter, Tumblr, and so on.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To enable these integrations, a new authentication mechanism has been developed
    using API keys. This authentication method is used primarily when we need to authenticate
    from another application but we do not want to access the private user data hosted
    in another application. On the contrary, if you want to access this information,
    you must use OAuth. If you are interested in this, don't worry, we will study
    this wonderful technology later in this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: We want to understand how the API keys work, so let's take the case of Flickr.
    The important thing here is to understand how the API keys work because the same
    concept can be applied to companies like Google, Facebook, and so on. For those
    unfamiliar with Flickr, it is an application in the cloud in which we can store
    our photos, images, screenshots, or similar files.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'To start working with this authentication model, we first obtain an API key;
    in our example with Flickr, you can do this using the following link:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.flickr.com/services/developer/api/](https://www.flickr.com/services/developer/api/)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'When we ask for our API key, we are asked to enter the name of the application
    that we will create and with which we use the API key. Once we enter the information
    requested and submit it, Flickr will deliver us a couple of values; they are a
    secret and a key. Both are displayed in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![API keys](img/0109OS_02_11.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Each application we create is part of Flickr App Garden. App Garden is nothing
    but the set of all applications created by all Flickr members.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that when creating an API key, we consciously accept certain terms
    of use of the provider. These terms clearly detail what we can and can''t do;
    for example, Flickr says:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '*a. You shall:*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '*Comply with the Flickr Community Guidelines at [www.flickr.com/guidelines.gne](http://www.flickr.com/guidelines.gne),
    the Flickr Terms of Use at [http://www.flickr.com/terms.gne](http://www.flickr.com/terms.gne),
    and the Yahoo! Terms of Service at [http://docs.yahoo.com/info/terms/](http://docs.yahoo.com/info/terms/).*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*…*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '*b. You shall not:*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '*Use Flickr APIs for any application that replicates or attempts to replace
    the essential user experience of Flickr.com*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '*…*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, by requiring that users accept the terms of use, API key providers prevent
    the abusive use of its APIs. So, if someone starts disrespecting agreements, the
    provider withdraws the API key. Flickr has a large set of methods that we can
    use in our applications; we will try one of them to show how they work:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flickr.photos.getRecent` method lists all recent photos that have been
    posted in Flickr, and we can invoke it as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.flickr.com/services/rest?method=flickr.photos.getRecent&;&api+key=[your_api_key_from_flicker]`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the key we just generated earlier, and let''s perform the request
    using the browser as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![API keys](img/0109OS_02_12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: First notice how information travels through a secure channel (HTTPS). Then,
    when receiving the request, Flickr authenticates the user by reading the information
    from the API key with the secret key that belongs to the user. Once these validations
    are successful, the server delivers the response to the client. Thus, we obtain
    a response with all the photos that have been recently posted within Flickr. As
    you'll notice, this way, you can easily create applications using the provider's
    API. Also, the provider will allow you to authenticate, access public information,
    and be responsible to keep track of volume or the number of API calls you've made
    using the API key, in order to validate that the use complies with the agreements.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through all possible models of authentication. We will
    use all of them in the next chapter, and we will apply them to the web service
    functionality we just created.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Even if you had trouble with any of the examples, you can continue to the next
    chapter. As for your better understanding, we will go step-by-step and more in-depth
    into how we can leverage each available authentication model.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: As you realize, it is important to choose the correct security management, otherwise
    information is exposed and can easily be intercepted and used by third parties.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in this chapter, we reviewed the differences between authentication
    and authorization. Both concepts are very important and definitely impossible
    to put aside in the context of security terms.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will ask you to join us to go ahead and secure our web service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
