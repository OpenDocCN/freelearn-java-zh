- en: What is Next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At last, we have come to our final chapter together. We've built a number of
    different types of application, attempting to highlight and demonstrate different
    parts of the Java platform, especially those new to Java 9\. As we've discussed,
    it's impossible to write something with **only** new-in-Java-9 technologies and
    APIs, so we also saw a variety of interesting items from Java 7 and 8\. As Java
    9 is finally shipping, it makes sense to look ahead to see what Java's future
    might hold for us, but it's also wise to look around and see what other languages
    are offering so that we can decide if our next Java will actually **be** Java.
    In this chapter, we'll do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Recapping topics we previously covered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we can expect in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before looking forward to Java 10 and beyond, let''s quickly recap some of
    the things we''ve covered in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: The Java Platform Module System, perhaps the largest, most anticipated addition
    to the platform in this release. We saw how to create a module and discussed its
    implications on the runtime system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We walked through the new process management APIs in Java 9 and learned how
    to view processes, and even kill them, if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We looked at some of the major functional interfaces introduced in Java 8, discussing
    how they could be used, and showing how code might look with and without the lambdas
    that these interfaces support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed Java 8's `Optional<T>` at length, showing how to create instances
    of the class, the various methods it exposes, and how one might use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We spent a good deal of time building JavaFX-based applications, demonstrating
    various tips and tricks, working around several **gotchas**, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Java NIO File and Path APIs, we walked the filesystem, looking for
    duplicate files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We implemented data persistence using the Java Persistence API, demonstrating
    how to use the API in a Java SE environment, how to define entities, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We built a calculator using the Java 8 Date/Time APIs, exposing the functionality
    as both a library and a command-line utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of that effort, we briefly compared a few command-line utility frameworks
    (specifically focusing on Crest and Airline), before settling on Crest and demonstrating
    how to create and consume command-line options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we didn't focus on it in every chapter, we did take a break to discuss
    and demonstrate unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about **Service Provider Interfaces** (**SPIs**) as a means to provide
    multiple alternate implementations for an interface that can be loaded dynamically
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We implemented a couple of REST services, demonstrating not only the basic functionality
    of JAX-RS, how to deploy it in a Java SE environment, and POJO mapping, but also
    some more advanced features including server-sent events and securing endpoints
    using `Filter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We built a couple of Android applications and discussed and demonstrated activities,
    fragments, services, content providers, asynchronous messaging, and background
    tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw OAuth2 authentication flows in action, including how to set up credentials
    using the Google OAuth provider and the Java code necessary to drive the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discovered JSON Web Tokens, a cryptographically secure way to pass data back
    and forth between, for example, a client and a server, and saw their very basic
    use as part of an authentication system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We toured the JavaMail API, learning a bit of the history and workings of common
    email protocols, such as POP3 and SMTP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about job scheduling using the Quartz scheduler library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw how to specify constraints for our data in a declarative manner, then
    how to validate data in the light of those constraints using the Bean Validation
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing gears completely, we built a moderately sophisticated application using
    the feature-rich NetBeans Rich Client Platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We looked briefly at world document databases with MongoDB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And we learned about dependency injection and how to use it with the CDI specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's quite a list, and that doesn't cover all of it. One of the stated purposes
    of the book is to discuss and demonstrate the new features of Java 9\. There are
    almost 100 **Java Enhancement Proposals** (**JEPs**) shipping with the release,
    making some of them difficult, at best, to demonstrate, but we've done our best.
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Java 9 done, then, the natural question is, **What is next?** As you might
    expect, the engineers at companies such as Oracle, Red Hat, IBM, Azul Systems,
    and others have been thinking about this question even while Java 9 was being
    planned and developed. While it is next to impossible to say what Java 10 will
    hold with any certainty (remember it took three major releases to get the module
    system done), we do have several items that are currently being discussed and
    designed, with the hope of shipping them in the next release. Over the next few
    pages, we'll explore some of these to get an early look at what our life as Java
    developers might be like in a couple of years.
  prefs: []
  type: TYPE_NORMAL
- en: Project Valhalla
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Valhalla is an *incubation grounds for advanced language-VM co-development
    projects*. It is being led by Oracle engineer, Brian Goetz. As of this writing,
    there are three planned features for Valhalla. They are value types, generic specialization,
    and reified generics.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this effort is to update the Java Virtual Machine, and, if possible,
    the Java language, to support small, immutable, **identity-less** value types.
    Currently, if you instantiate a new `Object`, it is given an identifier by the
    JVM, which allows the **variable** instance to be referenced.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you create a new integer, `new Integer(42)`, a variable with
    the identity of `java.lang.Integer@68f29546`, but the value of `42`, the value
    of this variable will never change, and that's all we, as developers, typically
    care about. However, the JVM doesn't really know that, so it has to maintain the
    identity of the variable, with all of the overhead that entails. According to
    Goetz, that means every instance of this object will require up to 24 additional
    bytes to store the instance. If you have a large array of these, for example,
    that can be a significant amount of memory to manage and, eventually, to garbage-collect.
  prefs: []
  type: TYPE_NORMAL
- en: What the JVM engineers hope to achieve, then, is a way to **gently extend**
    the Java Virtual Machine byte code and the Java language itself to support the
    notion of a small, immutable aggregate type (think of a class with 0 or more properties)
    that lacks identity, which will result, it is hoped, in "memory-and locality-efficient
    programming idioms without sacrificing encapsulation". Their hope is that Java
    developers will be able to create these new types and treat them as just another
    primitive. If they do their jobs correctly, Goetz says, the feature can be summarized
    as **Codes like a class, works like an int!**
  prefs: []
  type: TYPE_NORMAL
- en: 'The current proposal, as of April 2017 ([http://cr.openjdk.java.net/~jrose/values/shady-values.html](http://cr.openjdk.java.net/~jrose/values/shady-values.html)),
    offers the following code snippet as an example of how one might define a value
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When instantiated, instances of this type could be created on the stack, rather
    than the heap, and use much less memory. This is a very low-level and technical
    discussion, which is far beyond the scope of this book, but if you are interested
    in more details, I would suggest reading the page linked earlier, or the effort's
    initial announcement at [http://cr.openjdk.java.net/~jrose/values/values-0.html](http://cr.openjdk.java.net/~jrose/values/values-0.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generic specialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generic specialization is, perhaps, a bit easier to understand. Currently,
    generic type variables can hold only reference types. For example, you can create
    a `List<Integer>`, but not a `List<int>`. There are some pretty complex reasons
    why this is so, but being able to use primitives, and value types, would make
    collections more efficient in terms of memory and computation. You can read more
    about this feature in this document from, again, Brian Goetz--[http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html](http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html).
    Jesper de Jong also has a good write-up about the complexities of primitives in
    generic type variables here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/](http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/)'
  prefs: []
  type: TYPE_NORMAL
- en: Reified generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **reified generics** is one that, more often than not, it seems, causes
    very vocal, animated reactions. Currently, if you declare a variable to be of
    type `List<Integer>`, the byte code generated has no real notion of the parameterized
    type, so it's not discoverable at runtime. If you were to examine the variable
    at runtime, you would see no mention of `Integer`. You could, of course, look
    at the types of each element, but, even then, you can't be sure of the type of
    the `List`, as there is nothing enforcing that **only** the `Integer` can be added
    to the `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Java developers have been clamoring for reified generics, or, put simply, generics
    that retain their type information at runtime since generics were introduced in
    Java 5\. As you might guess, making Java's generics reified is no trivial task,
    but, finally, we have a formal effort to see if it can be done and, if it can
    be done, to find a backwards-compatible way that doesn't have, for example, negative
    performance characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Project Panama
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While not yet targeted for any particular Java release, Project Panama offers
    some hope for those who use, or hope to use, third-party, native libraries. Currently,
    the primary way of exposing native libraries (that is, OS-specific libraries written
    in, say, C or C++) to the JVM is via the **Java Native Interface** (**JNI**).
    The problem with JNI, or at least one of them, is that it requires that every
    Java programmer who wants to expose a native library to the JVM also become a
    C programmer, which means not only the C language itself, but also the related
    build tools for each supported platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Panama hopes to ameliorate that issue by offering the Java developer
    a new means of exposing native libraries without needing a deep understanding
    of the library language''s ecosystem, or the JVM''s. The JEP for Project Panama
    ([http://openjdk.java.net/jeps/191](http://openjdk.java.net/jeps/191)) lists these
    design goals:'
  prefs: []
  type: TYPE_NORMAL
- en: A metadata system to describe native library calls (call protocol, argument
    list structure, argument types, return type) and the native memory structure (size,
    layout, typing, life cycle).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mechanisms to discover and load native libraries. These capabilities may be
    provided by the current `System.loadLibrary` or may include additional enhancements
    for locating platform or version-specific binaries appropriate to the host system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mechanisms for binding, based on metadata, a given library/function coordinate
    to a Java endpoint, likely via a user-defined interface backed by plumbing to
    make the native downcall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mechanisms for binding, based on metadata, a specific memory structure (layout,
    endianness, logical types) to a Java endpoint, either via a user-defined interface
    or a user-defined class, in both cases backed by plumbing to manage a real block
    of native memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appropriate support code to marshal Java data types to native data types and
    vice-versa. This will, in some cases, require the creation of FFI-specific types
    to support bit widths and numeric signs that Java can't represent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JNI has been available for quite some time, and it's finally getting some long
    overdue attention.
  prefs: []
  type: TYPE_NORMAL
- en: Project Amber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Amber's goal is to **explore and incubate smaller, productivity-oriented
    Java language features**. The current list includes local-variable type inference,
    enhanced enums, and lambda leftovers.
  prefs: []
  type: TYPE_NORMAL
- en: Local-Variable Type Inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen countless times in this book alone, when you declare a variable
    in Java, you have to declare the type twice, once on the left-hand and once on
    the right-hand side, plus a variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that this code is verbose and repetitive. The Local-Variable
    Type Inference effort hopes to fix that, enabling something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code is more concise, making it more readable. Notice the addition of the
    `val` keyword. Typically, the compiler knows that a line of code, for example,
    is a variable declaration when it sees `<type> <name> = ...`. Since the effort
    would remove the need for a type on the left-hand side of the declaration, we
    need a cue for the compiler, which the authors of this JEP propose as `var`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also some discussion around simplifying the declaration of immutable,
    or `final`, variables. Among the proposals are `final var` as well as `val`, as
    seen in other languages such as Scala. At the time of writing, no decision that
    has been made on which proposal will make the final cut.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enhanced enums will augment *the expressiveness of the enum construct in the
    Java Language by allowing type-variables in enums (generic enums), and performing
    sharper type-checking for enum constants.* ([http://openjdk.java.net/jeps/301](http://openjdk.java.net/jeps/301)).
    What this means is that enums will finally support a parameterized type, allowing
    something like this (taken from the JEP at the link mentioned previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in addition to specifying a generic type for each `enum` value, we
    can also define type-specific methods for each `enum` type. This will make it
    much easier to define a set of predefined constants, but also to define type-safe
    and type-aware methods for each of the constants.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda leftovers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are currently two items labeled as `leftovers` from the lambda work in
    Java 8\. The first is the use of the underscore for unused parameters in lambda
    declarations. For example, in this very contrived example, all we care about are
    the `Map` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That results in things like this in the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53d98b02-af2f-406b-ad54-765bcbd59ee1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the use of the underscore is allowed, this code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This allows better static checking of unused variables, allowing tools (and
    developers) to more easily identify such parameters and either correct or mark
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other leftover is allowing lambda parameters to shadow variables from the
    enclosing scope. If you were to try that now, you would get the same error if
    you tried to redefine a variable inside a statement block--**variable is already
    defined**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the preceding code would compile and run just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Looking around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JVM has supported alternative languages for years. Some of the better known
    ones include Groovy and Scala. Both of these languages have influenced Java in
    one way or another over the years, but, like any language, they are not without
    their problems. Many feel that Groovy doesn't perform as well as Java (though
    the `invokedynamic` bytecode instruction is supposed to have addressed that),
    and many find Groovy's more dynamic nature less appealing. Scala, on the other
    hand, suffers (fairly or not, depending on who you ask) from the perception that
    it's too complex. Compilation time is also a common complaint. Also, many organizations
    are quite happily using both, so they are definitely worth considering to see
    if they will work in your environment and for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: While those may be great languages, we are taking some time here to see what's
    next, and there are at least two languages that seem to stand out from the crowd--Ceylon
    and Kotlin. We can't give each of these languages an exhaustive treatment, but,
    over the next few pages, we'll take a quick look at the languages to see what
    they offer JVM developers now, and, perhaps, see how they might influence future
    changes to the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: Ceylon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ceylon, a language sponsored by Red Hat, first appeared around 2011\. Led by
    Gavin King of the Hibernate and Seam Framework fame, the team set out to solve,
    at a language and library level, some of the pain points they had experienced
    over the years in developing their own frameworks and libraries. While they confess
    to being **unapologetic fans** of the Java language, they also readily acknowledge
    that the language is not perfect, especially with regard to some of the standard
    libraries, and aim to fix those flaws in Ceylon. The goals of the language include
    readability, predictability, toolability, modularity, and metaprogrammability
    ([https://ceylon-lang.org/blog/2012/01/10/goals](https://ceylon-lang.org/blog/2012/01/10/goals)).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest differences you are likely to notice when getting started
    with Ceylon is that the idea of modules is already baked into the language. In
    many ways, it looks very similar to Java 9''s module declaration, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There is, however, a very obvious difference--Ceylon modules **do** have version
    information, which allows various modules to depend on different versions of a
    module that may already be in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is at least one more rather significant difference between Ceylon and,
    say, Java--Ceylon has a build tool built in. While there is, for example, a Maven
    plugin, the preferred approach is to use Ceylon''s native tooling to build and
    run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Other than the module system, what might Ceylon offer a Java developer? One
    of the more immediately useful and practical features is improved null-handling
    support. Just as we have to do in Java, we still have to check for null in Ceylon,
    but the language offers a much nicer approach, and it all starts with the type
    system.
  prefs: []
  type: TYPE_NORMAL
- en: One of the complaints about Scala (whether its truly warranted or not) is that
    the type system is too complicated. Regardless of whether or not you agree, it
    seems clear that there's certainly room for improvement over what Java offers
    (even the Java language architects agree as evidenced by, for example, the proposed
    local variable type inference proposal). Ceylon offers a very powerful addition
    to the type system--union types and intersection types.
  prefs: []
  type: TYPE_NORMAL
- en: Union types allow a variable to have more than one type, but only one at a time.
    Where this comes into play in discussing nulls is that `String? foo = ...` , which
    declares a variable of type `String` that is nullable, is actually the same as
    `String|Null foo = ...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This declares a variable, foo, whose type is either `String` or `Null`, but
    not both. The `?` syntax is just syntactic sugar over the union type declaration
    (`A | B` or `A` or `B`). If we have a method, then that takes this union type;
    we know that the variable is nullable, so we need to check it using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a union type, we can also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that, once we've tested with `exists` or `is`, we can assume that the variable
    is not null and is a `String`. The compiler won't complain, and we won't have
    an unexpected `NullPointerException` at runtime (they actually don't exist in
    Ceylon as the compiler requires that you be very explicit in your handling of
    nullable variables). This type of compiler awareness of null and type checks is
    called **flow-sensitive** typing. Once you've verified the type of something,
    the compiler knows and remembers, so to speak, the results of that check for that
    remainder of that scope so you can write cleaner, more concise code.
  prefs: []
  type: TYPE_NORMAL
- en: 'While union types are either A or B, intersection types are A **and** B. For
    a completely arbitrary example, let''s say you have a method whose parameter must
    be, say, `Serializable` **and** `Closeable`. In Java, you''d have to check manually
    by writing the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With intersection types, Ceylon would let us write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we try to call that method with something that doesn't implement **both**
    interfaces, or, say, extends one class and implements the other interfaces, then
    we get an error at **compile time**. That's very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Before adopting a new language, or even a library, in an enterprise, one often
    looks to see who else is using it. Are there notable adoption stories? Are there
    other companies confident enough in the technology to build a production system
    using it? Unfortunately, the Ceylon website (at the time of writing) is very thin
    on the details of adoption outside Red Hat, so it's hard to answer that question.
    However, Red Hat is spending a good deal of money designing the language and building
    tooling and a community around it, so it should be a safe bet. It is, of course,
    a decision your enterprise will have to make after careful consideration. You
    can find out more about Ceylon at [https://ceylon-lang.org](https://ceylon-lang.org).
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another up-and-coming language is Kotlin. It is a statically-typed language
    from JetBrains, the makers of IntelliJ IDEA, that targets both the JVM and Javascript.
    It even has nascent support to compile directly to machine code via LLVM for those
    environments, such as iOS, embedded systems, and so on, where a virtual machine
    is not desired or allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin was started in 2010, and open sourced in 2012, as a means to address
    some common issues JetBrains was facing in large-scale Java development. Having
    surveyed the then-current language landscape, their engineers felt that none of
    those languages adequately addressed their concerns. Scala, considered for years
    now by many to be the **next Java**, was, for example, deemed to be too slow in
    compiling, despite having an acceptable feature set, so JetBrains began designing
    their own, eventually releasing 1.0 in February of 2016.
  prefs: []
  type: TYPE_NORMAL
- en: The design goals of the Kotlin team include expressiveness, scalability, and
    interoperability. They aim to allow developers to write less code that does more
    in a clearer fashion via language and library features, and in a language that
    is 100% interoperable with Java. They have added features such as coroutines to
    enable Kotlin-based systems to scale quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: With all of that said, what does Kotlin look like and why should we, as Java
    developers, be interested? Let's start with variables.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll recall, Java has both primitive (`int`, `double`, `float`, `char`,
    and so on) and reference, or **wrapper** types (`Integer`, `Double`, `Float`,
    `String`, and so on). As we've discussed in this chapter, the JVM engineers are
    working on ways to ameliorate some of the behavioral and capability differences
    this dichotomy brings. Kotlin avoids this altogether, as every value is an object,
    so there's no concern over `List<int>` versus `List<Integer>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, Kotlin already supports local variable type inference, as well
    as immutablity. For example, consider the following Java code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code could be written like this in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `var` and `val` keywords. As discussed earlier with regard
    to future Java language changes, these keywords allow us to declare mutable and
    immutable variables (respectively). Also notice that we need not declare the type
    of the variable, as the compiler handles that for us. In certain situations, we
    may need to explicitly declare the type, for example, in situations where the
    compiler might guess incorrectly or when it just does not have enough information
    to make a guess, at which point, it will stop compiling and present an error message.
    In those situations, we can declare the type this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With Java 8, as we''ve seen, we have `Optional<T>` to help deal with null values.
    Kotlin has null support as well, but it''s built into the language. By default,
    all variables in Kotlin are **not** nullable. That is to say, if the compiler
    can tell that you are attempting to assign a null value to a variable, or if it
    can''t determine whether or not a value might be null (for example, a return value
    from a Java API), you''ll get a compiler error. To indicate that a value is null-capable,
    you add a `?` to the variable declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin also offers improved null-handling support in method calls. Suppose,
    for example, you want to get a user''s city. In Java, you may do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, that can be expressed in a single line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If, at any point, one of the methods returns null, the method call chain ends,
    and null is assigned to the variable city. Kotlin doesn''t stop there with null
    handling. It provides, for an example, the `let` function that can serve as a
    shortcut for if-not-null checks. For example, consider the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code become this in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This could, of course, be written as `city?.toUpperCase()`. What this should
    demonstrate, though, is the ability to safely use a nullable variable in an arbitrarily
    large, complex block of code. It's also worth noting that, inside the `let` block,
    the compiler knows that `city` is not null so no further null checks are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden, perhaps, in the preceding example is Kotlin's support for lambdas, without
    which, it seems, no modern language is worth considering. Kotlin does, indeed,
    have full support for lambdas, higher order functions, underscores as lambda parameter
    names, and so on. Its support and syntax are very similar to Java's, so Java developers
    should be very comfortable with Kotlin's lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: The big question is, of course, **Is Kotlin ready for prime time?** JetBrains
    definitely thinks so, as they have it in use in many of their applications, both
    internal and external. Other notable users include Pinterest, Gradle, Evernote,
    Uber, Pivotal, Atlassian, and Basecamp. Kotlin is even officially supported by
    Google (in Android Studio) for Android development, so it's definitely a production-grade
    language.
  prefs: []
  type: TYPE_NORMAL
- en: There's much, much more to this great new language, of course, and space won't
    allow us to discuss all of it, but you can browse through [https://kotlinlang.org](https://kotlinlang.org)
    to learn more and see if Kotlin is a good fit for your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is much more that can be discussed of course, about Java 10 and these
    two languages, and the myriad of other projects happening in and around the Java
    Virtual Machine. After over 20 years of development, Java--the language **and**
    the environment--is still going strong. In the pages of this book, I've tried
    to demonstrate some of these great advancements in the language, giving you a
    variety of starting points for your own projects, sample code to study and reuse,
    and explanations of various libraries, APIs, and technologies that may be helpful
    in your day-to-day work. I hope you've enjoyed the examples and explanations as
    much as I've enjoyed preparing them, and, more importantly, I hope they help you
    build the Next Big Thing.
  prefs: []
  type: TYPE_NORMAL
- en: Good luck!
  prefs: []
  type: TYPE_NORMAL
