- en: What is Next?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步是什么？
- en: At last, we have come to our final chapter together. We've built a number of
    different types of application, attempting to highlight and demonstrate different
    parts of the Java platform, especially those new to Java 9\. As we've discussed,
    it's impossible to write something with **only** new-in-Java-9 technologies and
    APIs, so we also saw a variety of interesting items from Java 7 and 8\. As Java
    9 is finally shipping, it makes sense to look ahead to see what Java's future
    might hold for us, but it's also wise to look around and see what other languages
    are offering so that we can decide if our next Java will actually **be** Java.
    In this chapter, we'll do just that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们一起来到了最后一章。我们构建了多种不同类型的应用程序，试图突出和演示Java平台的不同部分，特别是那些新加入Java 9的部分。正如我们讨论的那样，仅使用Java
    9的新技术和API来编写东西是不可能的，所以我们还看到了来自Java 7和8的许多有趣的项目。随着Java 9终于发布，展望Java的未来对我们来说是有意义的，但同时也明智地看看其他语言提供了什么，这样我们才能决定我们的下一个Java是否真的是Java。在这一章中，我们将这样做。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Recapping topics we previously covered
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾我们之前讨论过的主题
- en: What we can expect in the future
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以期待的未来
- en: Looking back
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Before looking forward to Java 10 and beyond, let''s quickly recap some of
    the things we''ve covered in this book:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在展望Java 10及其以后之前，让我们快速回顾一下这本书中我们涵盖的一些内容：
- en: The Java Platform Module System, perhaps the largest, most anticipated addition
    to the platform in this release. We saw how to create a module and discussed its
    implications on the runtime system.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台模块系统，可能是这次发布中平台最大的、最受期待的添加。我们看到了如何创建一个模块，并讨论了它对运行时系统的影响。
- en: We walked through the new process management APIs in Java 9 and learned how
    to view processes, and even kill them, if needed.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了Java 9中的新进程管理API，学习了如何查看进程，并在需要时终止它们。
- en: We looked at some of the major functional interfaces introduced in Java 8, discussing
    how they could be used, and showing how code might look with and without the lambdas
    that these interfaces support.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们查看了一些Java 8引入的主要功能接口，讨论了它们的使用方法，并展示了使用和未使用这些接口支持的lambda表达式时的代码可能看起来如何。
- en: We discussed Java 8's `Optional<T>` at length, showing how to create instances
    of the class, the various methods it exposes, and how one might use it.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们详细讨论了Java 8的`Optional<T>`，展示了如何创建类的实例，它暴露的各种方法，以及如何使用它。
- en: We spent a good deal of time building JavaFX-based applications, demonstrating
    various tips and tricks, working around several **gotchas**, and so on.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们花了很多时间构建基于JavaFX的应用程序，展示了各种技巧和窍门，解决了一些**陷阱**等问题。
- en: Using the Java NIO File and Path APIs, we walked the filesystem, looking for
    duplicate files.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java NIO文件和路径API，我们在文件系统中漫步，寻找重复文件。
- en: We implemented data persistence using the Java Persistence API, demonstrating
    how to use the API in a Java SE environment, how to define entities, and so on.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Java持久化API实现了数据持久化，展示了如何在Java SE环境中使用该API，如何定义实体等。
- en: We built a calculator using the Java 8 Date/Time APIs, exposing the functionality
    as both a library and a command-line utility.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Java 8日期/时间API构建了一个计算器，将功能作为库和命令行实用工具公开。
- en: As part of that effort, we briefly compared a few command-line utility frameworks
    (specifically focusing on Crest and Airline), before settling on Crest and demonstrating
    how to create and consume command-line options.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为这项工作的一部分，我们简要比较了几种命令行实用工具框架（特别是关注Crest和Airline），然后在Crest上定居，并演示了如何创建和消费命令行选项。
- en: While we didn't focus on it in every chapter, we did take a break to discuss
    and demonstrate unit testing.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们并不是在每一章都关注它，但我们确实停下来讨论并演示了单元测试。
- en: We learned about **Service Provider Interfaces** (**SPIs**) as a means to provide
    multiple alternate implementations for an interface that can be loaded dynamically
    at runtime.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了**服务提供者接口**（**SPIs**）作为提供多个替代实现接口的手段，这些实现可以在运行时动态加载。
- en: We implemented a couple of REST services, demonstrating not only the basic functionality
    of JAX-RS, how to deploy it in a Java SE environment, and POJO mapping, but also
    some more advanced features including server-sent events and securing endpoints
    using `Filter`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了几个REST服务，不仅演示了JAX-RS的基本功能，如何在Java SE环境中部署它，以及POJO映射，还包括一些更高级的功能，如服务器端事件和通过`Filter`保护端点。
- en: We built a couple of Android applications and discussed and demonstrated activities,
    fragments, services, content providers, asynchronous messaging, and background
    tasks.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了几个Android应用程序，讨论并展示了活动、片段、服务、内容提供者、异步消息和后台任务。
- en: We saw OAuth2 authentication flows in action, including how to set up credentials
    using the Google OAuth provider and the Java code necessary to drive the process.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了OAuth2认证流程的实际操作，包括如何使用Google OAuth提供者设置凭据以及驱动此过程的Java代码。
- en: We discovered JSON Web Tokens, a cryptographically secure way to pass data back
    and forth between, for example, a client and a server, and saw their very basic
    use as part of an authentication system.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发现了JSON Web Tokens，这是一种在客户端和服务器之间安全传输数据的加密方式，例如，我们看到了它们作为认证系统一部分的基本用法。
- en: We toured the JavaMail API, learning a bit of the history and workings of common
    email protocols, such as POP3 and SMTP.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们参观了JavaMail API，了解了一些常见电子邮件协议（如POP3和SMTP）的历史和工作原理。
- en: We learned about job scheduling using the Quartz scheduler library.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何使用Quartz调度器库进行工作调度。
- en: We saw how to specify constraints for our data in a declarative manner, then
    how to validate data in the light of those constraints using the Bean Validation
    API.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了如何以声明性方式指定我们数据中的约束，然后如何使用Bean Validation API根据这些约束验证数据。
- en: Changing gears completely, we built a moderately sophisticated application using
    the feature-rich NetBeans Rich Client Platform.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全转变方向，我们使用功能丰富的NetBeans Rich Client Platform构建了一个中等复杂的应用程序。
- en: We looked briefly at world document databases with MongoDB.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要地了解了使用MongoDB的世界文档数据库。
- en: And we learned about dependency injection and how to use it with the CDI specification.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还学习了依赖注入以及如何使用CDI规范来实现它。
- en: That's quite a list, and that doesn't cover all of it. One of the stated purposes
    of the book is to discuss and demonstrate the new features of Java 9\. There are
    almost 100 **Java Enhancement Proposals** (**JEPs**) shipping with the release,
    making some of them difficult, at best, to demonstrate, but we've done our best.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一个相当长的列表，而且还没有涵盖所有内容。本书的一个明确目的是讨论和展示Java 9的新特性。Java 9的发布中包含了近100个**Java增强提案**（**JEPs**），这使得其中一些特性的展示变得相当困难，但我们已经尽力了。
- en: Looking forward
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望未来
- en: With Java 9 done, then, the natural question is, **What is next?** As you might
    expect, the engineers at companies such as Oracle, Red Hat, IBM, Azul Systems,
    and others have been thinking about this question even while Java 9 was being
    planned and developed. While it is next to impossible to say what Java 10 will
    hold with any certainty (remember it took three major releases to get the module
    system done), we do have several items that are currently being discussed and
    designed, with the hope of shipping them in the next release. Over the next few
    pages, we'll explore some of these to get an early look at what our life as Java
    developers might be like in a couple of years.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 既然Java 9已经完成，那么自然而然的问题是，**接下来是什么？**正如你所预期的那样，在Java 9被规划和开发的同时，Oracle、Red Hat、IBM、Azul
    Systems等公司的工程师们已经在思考这个问题。虽然很难确定Java 10将包含什么（记住，完成模块系统需要三个主要版本），但我们确实有一些目前正在讨论和设计中的项目，希望它们能在下一个版本中发布。在接下来的几页中，我们将探讨其中的一些，以便提前了解作为Java开发者，我们的生活可能在几年后是什么样的。
- en: Project Valhalla
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目Valhalla
- en: Project Valhalla is an *incubation grounds for advanced language-VM co-development
    projects*. It is being led by Oracle engineer, Brian Goetz. As of this writing,
    there are three planned features for Valhalla. They are value types, generic specialization,
    and reified generics.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 项目Valhalla是**高级语言-VM协同开发项目的孵化地**。它由Oracle工程师Brian Goetz领导。截至本文撰写时，Valhalla有三个计划中的特性。它们是值类型、泛型特化和具现泛型。
- en: Value types
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型
- en: The goal of this effort is to update the Java Virtual Machine, and, if possible,
    the Java language, to support small, immutable, **identity-less** value types.
    Currently, if you instantiate a new `Object`, it is given an identifier by the
    JVM, which allows the **variable** instance to be referenced.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个努力的目标是更新Java虚拟机，如果可能的话，更新Java语言，以支持小型、不可变、**无身份**的值类型。目前，如果你实例化一个新的`Object`，JVM会为其分配一个标识符，这使得**变量**实例可以被引用。
- en: For example, if you create a new integer, `new Integer(42)`, a variable with
    the identity of `java.lang.Integer@68f29546`, but the value of `42`, the value
    of this variable will never change, and that's all we, as developers, typically
    care about. However, the JVM doesn't really know that, so it has to maintain the
    identity of the variable, with all of the overhead that entails. According to
    Goetz, that means every instance of this object will require up to 24 additional
    bytes to store the instance. If you have a large array of these, for example,
    that can be a significant amount of memory to manage and, eventually, to garbage-collect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你创建一个新的整数，`new Integer(42)`，一个具有`java.lang.Integer@68f29546`身份的变量，但值为`42`，这个变量的值永远不会改变，这是我们作为开发者通常关心的所有。然而，JVM实际上并不知道这一点，因此它必须维护变量的身份，以及所有相关的开销。根据戈茨的说法，这意味着每个对象的实例将需要多达24个额外的字节来存储实例。例如，如果你有一个这样的大型数组，那可能是一个需要管理的显著内存量，最终还需要进行垃圾回收。
- en: What the JVM engineers hope to achieve, then, is a way to **gently extend**
    the Java Virtual Machine byte code and the Java language itself to support the
    notion of a small, immutable aggregate type (think of a class with 0 or more properties)
    that lacks identity, which will result, it is hoped, in "memory-and locality-efficient
    programming idioms without sacrificing encapsulation". Their hope is that Java
    developers will be able to create these new types and treat them as just another
    primitive. If they do their jobs correctly, Goetz says, the feature can be summarized
    as **Codes like a class, works like an int!**
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，JVM工程师希望实现的是一种方法，**温和地扩展**Java虚拟机字节码和Java语言本身，以支持小而不可变的聚合类型（想象一下具有0个或更多属性的一个类）的概念，这种类型没有身份，希望这将导致“内存和局部性高效的编程习惯，而不牺牲封装性”。他们的希望是，Java开发者能够创建这些新类型，并将它们视为另一个原始类型。戈茨说，如果他们正确地完成工作，这个特性可以总结为**像类一样编码，像int一样工作！**
- en: 'The current proposal, as of April 2017 ([http://cr.openjdk.java.net/~jrose/values/shady-values.html](http://cr.openjdk.java.net/~jrose/values/shady-values.html)),
    offers the following code snippet as an example of how one might define a value
    type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到2017年4月为止的当前提案([http://cr.openjdk.java.net/~jrose/values/shady-values.html](http://cr.openjdk.java.net/~jrose/values/shady-values.html))提供了一个代码片段，作为如何定义值类型的示例：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When instantiated, instances of this type could be created on the stack, rather
    than the heap, and use much less memory. This is a very low-level and technical
    discussion, which is far beyond the scope of this book, but if you are interested
    in more details, I would suggest reading the page linked earlier, or the effort's
    initial announcement at [http://cr.openjdk.java.net/~jrose/values/values-0.html](http://cr.openjdk.java.net/~jrose/values/values-0.html).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化时，这种类型的实例可以在栈上而不是在堆上创建，并且使用更少的内存。这是一个非常底层和技术的讨论，远远超出了本书的范围，但如果你对更多细节感兴趣，我建议阅读前面链接的页面，或者这个努力的初始公告在[http://cr.openjdk.java.net/~jrose/values/values-0.html](http://cr.openjdk.java.net/~jrose/values/values-0.html)。
- en: Generic specialization
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型特殊化
- en: 'Generic specialization is, perhaps, a bit easier to understand. Currently,
    generic type variables can hold only reference types. For example, you can create
    a `List<Integer>`, but not a `List<int>`. There are some pretty complex reasons
    why this is so, but being able to use primitives, and value types, would make
    collections more efficient in terms of memory and computation. You can read more
    about this feature in this document from, again, Brian Goetz--[http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html](http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html).
    Jesper de Jong also has a good write-up about the complexities of primitives in
    generic type variables here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型特殊化可能更容易理解。目前，泛型类型变量只能持有引用类型。例如，你可以创建一个`List<Integer>`，但不能创建一个`List<int>`。为什么会有这样的限制，背后有一些相当复杂的原因，但能够使用原始类型和值类型会使集合在内存和计算效率上更加高效。你可以在以下文档中了解更多关于这个特性的信息，再次提到，是布赖恩·戈茨的文档--[http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html](http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html)。Jesper
    de Jong也在这里详细介绍了泛型类型变量中原始类型的复杂性：
- en: '[http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/](http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/](http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/)'
- en: Reified generics
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体化泛型
- en: The term **reified generics** is one that, more often than not, it seems, causes
    very vocal, animated reactions. Currently, if you declare a variable to be of
    type `List<Integer>`, the byte code generated has no real notion of the parameterized
    type, so it's not discoverable at runtime. If you were to examine the variable
    at runtime, you would see no mention of `Integer`. You could, of course, look
    at the types of each element, but, even then, you can't be sure of the type of
    the `List`, as there is nothing enforcing that **only** the `Integer` can be added
    to the `List`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “具体化泛型”这个术语，似乎常常引起非常激烈、生动的反应。目前，如果你声明一个变量为`List<Integer>`类型，生成的字节码没有对参数化类型的真正理解，因此在运行时无法发现。如果你在运行时检查该变量，你将看不到`Integer`的提及。当然，你可以查看每个元素的类型，但即使如此，你也不能确定`List`的类型，因为没有东西强制只允许将`Integer`添加到`List`中。
- en: Java developers have been clamoring for reified generics, or, put simply, generics
    that retain their type information at runtime since generics were introduced in
    Java 5\. As you might guess, making Java's generics reified is no trivial task,
    but, finally, we have a formal effort to see if it can be done and, if it can
    be done, to find a backwards-compatible way that doesn't have, for example, negative
    performance characteristics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Java 5引入泛型以来，Java开发者一直迫切希望实现泛型的具体化，或者说，泛型在运行时保留其类型信息。正如你可能猜到的，使Java的泛型具体化并非易事，但最终，我们有了正式的努力来验证它是否可行，如果可行，还要找到一种向后兼容的方法，例如，不产生例如性能下降等负面影响。
- en: Project Panama
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目Panama
- en: While not yet targeted for any particular Java release, Project Panama offers
    some hope for those who use, or hope to use, third-party, native libraries. Currently,
    the primary way of exposing native libraries (that is, OS-specific libraries written
    in, say, C or C++) to the JVM is via the **Java Native Interface** (**JNI**).
    The problem with JNI, or at least one of them, is that it requires that every
    Java programmer who wants to expose a native library to the JVM also become a
    C programmer, which means not only the C language itself, but also the related
    build tools for each supported platform.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目前尚未针对任何特定的Java版本进行目标定位，但项目Panama为那些使用或希望使用第三方本地库的人提供了一些希望。目前，将本地库（即用C或C++编写的特定于操作系统的库）暴露给JVM的主要方式是通过**Java
    Native Interface**（JNI）。JNI的问题之一（至少是其中之一）是它要求每个希望将本地库暴露给JVM的Java程序员也成为C程序员，这意味着不仅需要C语言本身，还需要为每个支持的平台的相关构建工具。
- en: 'Project Panama hopes to ameliorate that issue by offering the Java developer
    a new means of exposing native libraries without needing a deep understanding
    of the library language''s ecosystem, or the JVM''s. The JEP for Project Panama
    ([http://openjdk.java.net/jeps/191](http://openjdk.java.net/jeps/191)) lists these
    design goals:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 项目Panama希望通过为Java开发者提供一种新的方式来暴露本地库，而无需深入了解库语言生态系统或JVM，从而改善上述问题。项目Panama的JEP（[http://openjdk.java.net/jeps/191](http://openjdk.java.net/jeps/191)）列出了以下设计目标：
- en: A metadata system to describe native library calls (call protocol, argument
    list structure, argument types, return type) and the native memory structure (size,
    layout, typing, life cycle).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个元数据系统，用于描述本地库调用（调用协议、参数列表结构、参数类型、返回类型）以及本地内存结构（大小、布局、类型、生命周期）。
- en: Mechanisms to discover and load native libraries. These capabilities may be
    provided by the current `System.loadLibrary` or may include additional enhancements
    for locating platform or version-specific binaries appropriate to the host system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现和加载本地库的机制。这些功能可能由当前的`System.loadLibrary`提供，或者可能包括为定位适合主机系统的平台或版本特定的二进制文件提供额外的增强。
- en: Mechanisms for binding, based on metadata, a given library/function coordinate
    to a Java endpoint, likely via a user-defined interface backed by plumbing to
    make the native downcall.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于元数据将特定的库/函数坐标绑定到Java端点，很可能是通过用户定义的接口，并由管道支持来实现本地下调用。
- en: Mechanisms for binding, based on metadata, a specific memory structure (layout,
    endianness, logical types) to a Java endpoint, either via a user-defined interface
    or a user-defined class, in both cases backed by plumbing to manage a real block
    of native memory.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于元数据将特定内存结构（布局、字节序、逻辑类型）绑定到Java端点，无论是通过用户定义的接口还是用户定义的类，在这两种情况下都由管道支持来管理实际的本地内存块。
- en: Appropriate support code to marshal Java data types to native data types and
    vice-versa. This will, in some cases, require the creation of FFI-specific types
    to support bit widths and numeric signs that Java can't represent.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的代码来将Java数据类型转换为本地数据类型，反之亦然。在某些情况下，这需要创建FFI特定的类型来支持Java无法表示的位宽和数值符号。
- en: JNI has been available for quite some time, and it's finally getting some long
    overdue attention.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JNI已经存在一段时间了，它终于得到了一些迟到的关注。
- en: Project Amber
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目Amber
- en: Project Amber's goal is to **explore and incubate smaller, productivity-oriented
    Java language features**. The current list includes local-variable type inference,
    enhanced enums, and lambda leftovers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 项目Amber的目标是**探索和孵化更小、面向生产力的Java语言特性**。当前列表包括局部变量类型推断、增强枚举和lambda leftovers。
- en: Local-Variable Type Inference
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部-变量类型推断
- en: 'As we have seen countless times in this book alone, when you declare a variable
    in Java, you have to declare the type twice, once on the left-hand and once on
    the right-hand side, plus a variable name:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在这本书中我们无数次看到的那样，当你Java中声明一个变量时，你必须声明两次类型，一次在左侧，一次在右侧，加上一个变量名：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The problem here is that this code is verbose and repetitive. The Local-Variable
    Type Inference effort hopes to fix that, enabling something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是这段代码冗长且重复。局部变量类型推断的努力希望解决这个问题，使得代码可以像这样：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is more concise, making it more readable. Notice the addition of the
    `val` keyword. Typically, the compiler knows that a line of code, for example,
    is a variable declaration when it sees `<type> <name> = ...`. Since the effort
    would remove the need for a type on the left-hand side of the declaration, we
    need a cue for the compiler, which the authors of this JEP propose as `var`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更加简洁，使其更易于阅读。注意`val`关键字的添加。通常，当编译器看到`<type> <name> = ...`这样的行时，它知道这是一条变量声明。由于这项工作将消除声明左侧类型的需求，我们需要一个提示编译器，这个提示由本JEP的作者提出为`var`。
- en: There is also some discussion around simplifying the declaration of immutable,
    or `final`, variables. Among the proposals are `final var` as well as `val`, as
    seen in other languages such as Scala. At the time of writing, no decision that
    has been made on which proposal will make the final cut.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些关于简化不可变或`final`变量声明的讨论。建议包括`final var`以及`val`，如Scala等语言中所示。在撰写本文时，尚未就哪个建议将最终被采纳做出决定。
- en: Enhanced enums
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强枚举
- en: 'Enhanced enums will augment *the expressiveness of the enum construct in the
    Java Language by allowing type-variables in enums (generic enums), and performing
    sharper type-checking for enum constants.* ([http://openjdk.java.net/jeps/301](http://openjdk.java.net/jeps/301)).
    What this means is that enums will finally support a parameterized type, allowing
    something like this (taken from the JEP at the link mentioned previously):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 增强枚举将通过允许枚举中使用类型变量（泛型枚举）并执行对枚举常量的更精确的类型检查来增强Java语言中枚举构造的表达能力。这意味着枚举最终将支持参数化类型，允许像这样（从之前提到的链接中的JEP中摘取）：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that, in addition to specifying a generic type for each `enum` value, we
    can also define type-specific methods for each `enum` type. This will make it
    much easier to define a set of predefined constants, but also to define type-safe
    and type-aware methods for each of the constants.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了为每个`enum`值指定一个泛型类型外，我们还可以为每个`enum`类型定义特定类型的函数。这将使定义一组预定义常量变得更加容易，同时也为每个常量定义类型安全和类型感知的方法。
- en: Lambda leftovers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda leftovers
- en: 'There are currently two items labeled as `leftovers` from the lambda work in
    Java 8\. The first is the use of the underscore for unused parameters in lambda
    declarations. For example, in this very contrived example, all we care about are
    the `Map` values:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在Java 8的lambda工作中，有两个被标记为`leftovers`的项目。第一个是lambda声明中未使用参数使用下划线的用法。例如，在这个非常牵强的例子中，我们只关心`Map`的值：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That results in things like this in the IDE:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这在IDE中导致如下情况：
- en: '![](img/53d98b02-af2f-406b-ad54-765bcbd59ee1.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53d98b02-af2f-406b-ad54-765bcbd59ee1.png)'
- en: 'Once the use of the underscore is allowed, this code will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦允许使用下划线，这段代码将看起来像这样：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This allows better static checking of unused variables, allowing tools (and
    developers) to more easily identify such parameters and either correct or mark
    them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许更好地检查未使用的变量，使得工具（和开发者）可以更容易地识别这样的参数，并对其进行纠正或标记。
- en: 'The other leftover is allowing lambda parameters to shadow variables from the
    enclosing scope. If you were to try that now, you would get the same error if
    you tried to redefine a variable inside a statement block--**variable is already
    defined**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个遗留问题是允许 lambda 参数遮蔽封装作用域中的变量。如果你现在尝试这样做，你将得到与尝试在语句块内重新定义变量时相同的错误——**变量已定义**：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this change, the preceding code would compile and run just fine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一变化，前面的代码将能够编译并正常运行。
- en: Looking around
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环顾四周
- en: The JVM has supported alternative languages for years. Some of the better known
    ones include Groovy and Scala. Both of these languages have influenced Java in
    one way or another over the years, but, like any language, they are not without
    their problems. Many feel that Groovy doesn't perform as well as Java (though
    the `invokedynamic` bytecode instruction is supposed to have addressed that),
    and many find Groovy's more dynamic nature less appealing. Scala, on the other
    hand, suffers (fairly or not, depending on who you ask) from the perception that
    it's too complex. Compilation time is also a common complaint. Also, many organizations
    are quite happily using both, so they are definitely worth considering to see
    if they will work in your environment and for your needs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 多年来一直支持替代语言。其中一些较为知名的语言包括 Groovy 和 Scala。多年来，这两种语言在某种程度上都影响了 Java，但像任何语言一样，它们并非没有问题。许多人认为
    Groovy 的性能不如 Java（尽管`invokedynamic`字节码指令本应解决这个问题），许多人发现 Groovy 更动态的特性不太吸引人。另一方面，Scala（无论是否公平，取决于你问谁）给人一种过于复杂的印象。编译时间也是常见的抱怨。此外，许多组织都很高兴地使用这两种语言，因此它们绝对值得考虑，看看它们是否适合你的环境和需求。
- en: While those may be great languages, we are taking some time here to see what's
    next, and there are at least two languages that seem to stand out from the crowd--Ceylon
    and Kotlin. We can't give each of these languages an exhaustive treatment, but,
    over the next few pages, we'll take a quick look at the languages to see what
    they offer JVM developers now, and, perhaps, see how they might influence future
    changes to the Java language.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些语言可能很出色，但我们在这里花些时间来看看接下来是什么，至少有两种语言似乎脱颖而出——塞隆和科特林。我们无法对每种语言都进行详尽的介绍，但在接下来的几页中，我们将快速浏览这些语言，看看它们现在为
    JVM 开发者提供了什么，也许还能看看它们可能会如何影响 Java 语言的未来变化。
- en: Ceylon
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 塞隆
- en: Ceylon, a language sponsored by Red Hat, first appeared around 2011\. Led by
    Gavin King of the Hibernate and Seam Framework fame, the team set out to solve,
    at a language and library level, some of the pain points they had experienced
    over the years in developing their own frameworks and libraries. While they confess
    to being **unapologetic fans** of the Java language, they also readily acknowledge
    that the language is not perfect, especially with regard to some of the standard
    libraries, and aim to fix those flaws in Ceylon. The goals of the language include
    readability, predictability, toolability, modularity, and metaprogrammability
    ([https://ceylon-lang.org/blog/2012/01/10/goals](https://ceylon-lang.org/blog/2012/01/10/goals)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由红帽赞助的塞隆语言首次出现在 2011 年左右。由Hibernate 和 Seam 框架的知名人物 Gavin King 领导的团队着手在语言和库层面解决他们在开发自己的框架和库过程中多年来的痛点。虽然他们承认自己是
    Java 语言的**无怨无悔的粉丝**，但他们也乐于承认这种语言并不完美，特别是在一些标准库方面，并旨在在塞隆中修复这些缺陷。该语言的目标包括可读性、可预测性、可工具化、模块化和元编程([https://ceylon-lang.org/blog/2012/01/10/goals](https://ceylon-lang.org/blog/2012/01/10/goals))。
- en: 'One of the biggest differences you are likely to notice when getting started
    with Ceylon is that the idea of modules is already baked into the language. In
    many ways, it looks very similar to Java 9''s module declaration, which is as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用塞隆时，你可能会注意到最大的不同之一是模块的概念已经内置于语言中。在许多方面，它看起来非常类似于 Java 9 的模块声明，如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is, however, a very obvious difference--Ceylon modules **do** have version
    information, which allows various modules to depend on different versions of a
    module that may already be in the system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个非常明显的区别——塞隆模块**确实**有版本信息，这允许不同的模块依赖于系统中可能已经存在的模块的不同版本。
- en: 'There is at least one more rather significant difference between Ceylon and,
    say, Java--Ceylon has a build tool built in. While there is, for example, a Maven
    plugin, the preferred approach is to use Ceylon''s native tooling to build and
    run the project:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 塞隆与，比如说，Java 之间至少还有一个相当显著的不同点——塞隆内置了一个构建工具。虽然例如有一个 Maven 插件，但首选的方法是使用塞隆的本地工具来构建和运行项目：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other than the module system, what might Ceylon offer a Java developer? One
    of the more immediately useful and practical features is improved null-handling
    support. Just as we have to do in Java, we still have to check for null in Ceylon,
    but the language offers a much nicer approach, and it all starts with the type
    system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模块系统，Ceylon 还能为 Java 开发者提供什么？其中一个更直接有用且实用的特性是改进了 null 处理支持。就像我们在 Java 中必须做的那样，在
    Ceylon 中我们仍然需要检查 null，但该语言提供了一种更优雅的方法，这一切都始于类型系统。
- en: One of the complaints about Scala (whether its truly warranted or not) is that
    the type system is too complicated. Regardless of whether or not you agree, it
    seems clear that there's certainly room for improvement over what Java offers
    (even the Java language architects agree as evidenced by, for example, the proposed
    local variable type inference proposal). Ceylon offers a very powerful addition
    to the type system--union types and intersection types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Scala 的一个抱怨（无论其是否真正有理）是类型系统太复杂。无论你是否同意，似乎很清楚，在 Java 提供的基础上确实有改进的空间（例如，Java
    语言架构师也同意，例如，通过提出的局部变量类型推断建议）。Ceylon 为类型系统提供了一个非常强大的补充——联合类型和交叉类型。
- en: Union types allow a variable to have more than one type, but only one at a time.
    Where this comes into play in discussing nulls is that `String? foo = ...` , which
    declares a variable of type `String` that is nullable, is actually the same as
    `String|Null foo = ...`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型允许一个变量具有多个类型，但一次只能有一个。在讨论 null 时，这一点很重要，`String? foo = ...` ，这声明了一个类型为 `String`
    的可空变量，实际上等同于 `String|Null foo = ...`。
- en: 'This declares a variable, foo, whose type is either `String` or `Null`, but
    not both. The `?` syntax is just syntactic sugar over the union type declaration
    (`A | B` or `A` or `B`). If we have a method, then that takes this union type;
    we know that the variable is nullable, so we need to check it using the following
    code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个变量，foo，其类型可以是 `String` 或 `Null`，但不能同时是两者。`?` 语法只是联合类型声明（`A | B` 或 `A`
    或 `B`）的语法糖。如果我们有一个方法，那么它接受这个联合类型；我们知道该变量是可空的，因此我们需要使用以下代码片段进行检查：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since this is a union type, we can also do this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个联合类型，我们也可以这样做：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that, once we've tested with `exists` or `is`, we can assume that the variable
    is not null and is a `String`. The compiler won't complain, and we won't have
    an unexpected `NullPointerException` at runtime (they actually don't exist in
    Ceylon as the compiler requires that you be very explicit in your handling of
    nullable variables). This type of compiler awareness of null and type checks is
    called **flow-sensitive** typing. Once you've verified the type of something,
    the compiler knows and remembers, so to speak, the results of that check for that
    remainder of that scope so you can write cleaner, more concise code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦我们使用 `exists` 或 `is` 进行测试，我们就可以假设该变量不是 null，并且是 `String` 类型。编译器不会报错，我们也不会在运行时遇到意外的
    `NullPointerException`（在 Ceylon 中实际上不存在，因为编译器要求你在处理可空变量时非常明确）。这种编译器对 null 和类型检查的感知称为
    **流敏感** 类型。一旦你验证了某个类型，编译器就会知道并记住，换句话说，在整个作用域的剩余部分都会记住这个检查的结果，这样你可以编写更干净、更简洁的代码。
- en: 'While union types are either A or B, intersection types are A **and** B. For
    a completely arbitrary example, let''s say you have a method whose parameter must
    be, say, `Serializable` **and** `Closeable`. In Java, you''d have to check manually
    by writing the following lines of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型要么是 A 或 B，而交叉类型则是 A **和** B。为了一个完全随机的例子，让我们假设你有一个方法，其参数必须是 `Serializable`
    **和** `Closeable`。在 Java 中，你将不得不手动检查，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With intersection types, Ceylon would let us write this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交叉类型，Ceylon 允许我们这样写：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try to call that method with something that doesn't implement **both**
    interfaces, or, say, extends one class and implements the other interfaces, then
    we get an error at **compile time**. That's very powerful.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试用没有实现 **两个** 接口的东西调用那个方法，或者说，扩展一个类并实现另一个接口，那么我们会在 **编译时** 得到错误。这非常强大。
- en: Before adopting a new language, or even a library, in an enterprise, one often
    looks to see who else is using it. Are there notable adoption stories? Are there
    other companies confident enough in the technology to build a production system
    using it? Unfortunately, the Ceylon website (at the time of writing) is very thin
    on the details of adoption outside Red Hat, so it's hard to answer that question.
    However, Red Hat is spending a good deal of money designing the language and building
    tooling and a community around it, so it should be a safe bet. It is, of course,
    a decision your enterprise will have to make after careful consideration. You
    can find out more about Ceylon at [https://ceylon-lang.org](https://ceylon-lang.org).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中采用新语言或库之前，人们通常会看看其他人是否在使用它。是否有值得注意的采用案例？是否有其他公司对这项技术有足够的信心，用它来构建生产系统？不幸的是，Ceylon网站（在撰写本文时）在Red
    Hat之外的使用细节非常少，所以很难回答这个问题。然而，Red Hat正在投入大量资金设计这种语言，并围绕它构建工具和社区，所以这应该是一个安全的赌注。当然，这是一个企业经过仔细考虑后必须做出的决定。你可以在[https://ceylon-lang.org](https://ceylon-lang.org)了解更多关于Ceylon的信息。
- en: Kotlin
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin
- en: Another up-and-coming language is Kotlin. It is a statically-typed language
    from JetBrains, the makers of IntelliJ IDEA, that targets both the JVM and Javascript.
    It even has nascent support to compile directly to machine code via LLVM for those
    environments, such as iOS, embedded systems, and so on, where a virtual machine
    is not desired or allowed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种新兴的语言是Kotlin。它是由IntelliJ IDEA的制造商JetBrains开发的一种静态类型语言，旨在针对JVM和JavaScript。它甚至为那些环境（如iOS、嵌入式系统等）提供了将代码直接编译成机器代码的支持，在这些环境中不希望或允许使用虚拟机。
- en: Kotlin was started in 2010, and open sourced in 2012, as a means to address
    some common issues JetBrains was facing in large-scale Java development. Having
    surveyed the then-current language landscape, their engineers felt that none of
    those languages adequately addressed their concerns. Scala, considered for years
    now by many to be the **next Java**, was, for example, deemed to be too slow in
    compiling, despite having an acceptable feature set, so JetBrains began designing
    their own, eventually releasing 1.0 in February of 2016.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin于2010年开始开发，并于2012年开源，旨在解决JetBrains在大型Java开发中遇到的一些常见问题。在调查了当时现有的语言环境后，他们的工程师认为当时没有哪种语言能够充分解决他们的担忧。多年来被许多人视为“下一个Java”的Scala，尽管功能集可接受，但在编译速度上被认为太慢，因此JetBrains开始设计他们自己的语言，最终于2016年2月发布了1.0版本。
- en: The design goals of the Kotlin team include expressiveness, scalability, and
    interoperability. They aim to allow developers to write less code that does more
    in a clearer fashion via language and library features, and in a language that
    is 100% interoperable with Java. They have added features such as coroutines to
    enable Kotlin-based systems to scale quickly and easily.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin团队的设计目标包括表达性、可扩展性和互操作性。他们希望通过语言和库功能，让开发者用更少的代码以更清晰的方式完成更多的工作，并且在一个100%与Java互操作的语言中。他们添加了诸如协程等特性，以使基于Kotlin的系统能够快速且容易地扩展。
- en: With all of that said, what does Kotlin look like and why should we, as Java
    developers, be interested? Let's start with variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，Kotlin是什么样的，为什么作为Java开发者我们应该感兴趣呢？让我们从变量开始。
- en: As you'll recall, Java has both primitive (`int`, `double`, `float`, `char`,
    and so on) and reference, or **wrapper** types (`Integer`, `Double`, `Float`,
    `String`, and so on). As we've discussed in this chapter, the JVM engineers are
    working on ways to ameliorate some of the behavioral and capability differences
    this dichotomy brings. Kotlin avoids this altogether, as every value is an object,
    so there's no concern over `List<int>` versus `List<Integer>`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，Java既有原始类型（`int`、`double`、`float`、`char`等）也有引用类型或**包装器**类型（`Integer`、`Double`、`Float`、`String`等）。正如我们在本章中讨论的，JVM工程师正在研究方法来改善这种二分法带来的行为和能力差异。Kotlin完全避免了这种情况，因为每个值都是一个对象，所以无需担心`List<int>`与`List<Integer>`之间的区别。
- en: 'Furthermore, Kotlin already supports local variable type inference, as well
    as immutablity. For example, consider the following Java code as an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kotlin已经支持局部变量类型推断以及不可变性。例如，以下Java代码可以作为示例：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding lines of code could be written like this in Kotlin:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行在Kotlin中可以写成这样：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice the use of the `var` and `val` keywords. As discussed earlier with regard
    to future Java language changes, these keywords allow us to declare mutable and
    immutable variables (respectively). Also notice that we need not declare the type
    of the variable, as the compiler handles that for us. In certain situations, we
    may need to explicitly declare the type, for example, in situations where the
    compiler might guess incorrectly or when it just does not have enough information
    to make a guess, at which point, it will stop compiling and present an error message.
    In those situations, we can declare the type this way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`var`和`val`关键字的使用。如前所述，关于未来Java语言的变化，这些关键字允许我们声明可变和不可变变量（分别）。此外，请注意，我们不需要声明变量的类型，因为编译器会为我们处理。在某些情况下，我们可能需要显式声明类型，例如，在编译器可能猜错或没有足够信息进行猜测的情况下，此时，它将停止编译并显示错误信息。在这些情况下，我们可以这样声明类型：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With Java 8, as we''ve seen, we have `Optional<T>` to help deal with null values.
    Kotlin has null support as well, but it''s built into the language. By default,
    all variables in Kotlin are **not** nullable. That is to say, if the compiler
    can tell that you are attempting to assign a null value to a variable, or if it
    can''t determine whether or not a value might be null (for example, a return value
    from a Java API), you''ll get a compiler error. To indicate that a value is null-capable,
    you add a `?` to the variable declaration as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，随着Java 8的推出，我们有`Optional<T>`来帮助处理null值。Kotlin也有null支持，但它内置在语言中。默认情况下，Kotlin中的所有变量**都不是**可空的。也就是说，如果你尝试将null值赋给变量，或者编译器无法确定值是否可能为null（例如，Java
    API的返回值），你将得到编译器错误。要表示一个值是可空的，你可以在变量声明中添加一个`?`，如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Kotlin also offers improved null-handling support in method calls. Suppose,
    for example, you want to get a user''s city. In Java, you may do something like
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin还在方法调用中提供了改进的null处理支持。例如，假设你想获取一个用户的city。在Java中，你可能这样做：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Kotlin, that can be expressed in a single line, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，这可以表达为以下单行代码：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If, at any point, one of the methods returns null, the method call chain ends,
    and null is assigned to the variable city. Kotlin doesn''t stop there with null
    handling. It provides, for an example, the `let` function that can serve as a
    shortcut for if-not-null checks. For example, consider the following lines of
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候，其中一个方法返回null，方法调用链将结束，并将null赋值给变量city。Kotlin在处理null方面并不止步于此。例如，它提供了一个`let`函数，可以作为if-not-null检查的快捷方式。例如，考虑以下代码行：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding lines of code become this in Kotlin:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行在Kotlin中变为以下形式：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This could, of course, be written as `city?.toUpperCase()`. What this should
    demonstrate, though, is the ability to safely use a nullable variable in an arbitrarily
    large, complex block of code. It's also worth noting that, inside the `let` block,
    the compiler knows that `city` is not null so no further null checks are necessary.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可以写成`city?.toUpperCase()`。但这应该展示的是在任意大、复杂的代码块中安全使用可空变量的能力。还值得注意的是，在`let`块内部，编译器知道`city`不是null，因此不需要进一步的null检查。
- en: Hidden, perhaps, in the preceding example is Kotlin's support for lambdas, without
    which, it seems, no modern language is worth considering. Kotlin does, indeed,
    have full support for lambdas, higher order functions, underscores as lambda parameter
    names, and so on. Its support and syntax are very similar to Java's, so Java developers
    should be very comfortable with Kotlin's lambdas.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，可能隐藏着Kotlin对lambda的支持，没有这种支持，似乎现代语言就失去了考虑的价值。Kotlin确实完全支持lambda、高阶函数、下划线作为lambda参数名等。它的支持和语法与Java非常相似，因此Java开发者应该对Kotlin的lambda感到非常舒适。
- en: The big question is, of course, **Is Kotlin ready for prime time?** JetBrains
    definitely thinks so, as they have it in use in many of their applications, both
    internal and external. Other notable users include Pinterest, Gradle, Evernote,
    Uber, Pivotal, Atlassian, and Basecamp. Kotlin is even officially supported by
    Google (in Android Studio) for Android development, so it's definitely a production-grade
    language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最大的问题是**Kotlin是否已经准备好进入主流使用阶段了？**JetBrains肯定是这样认为的，因为他们已经在许多内部和外部应用中使用它。其他知名用户包括Pinterest、Gradle、Evernote、Uber、Pivotal、Atlassian和Basecamp。Kotlin甚至被Google（在Android
    Studio中）官方支持用于Android开发，所以它绝对是一种生产级语言。
- en: There's much, much more to this great new language, of course, and space won't
    allow us to discuss all of it, but you can browse through [https://kotlinlang.org](https://kotlinlang.org)
    to learn more and see if Kotlin is a good fit for your organization.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于这门伟大的新语言，还有很多很多内容，空间有限，我们无法全部讨论，但你可以浏览[https://kotlinlang.org](https://kotlinlang.org)来了解更多信息，并看看
    Kotlin 是否适合你的组织。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There is much more that can be discussed of course, about Java 10 and these
    two languages, and the myriad of other projects happening in and around the Java
    Virtual Machine. After over 20 years of development, Java--the language **and**
    the environment--is still going strong. In the pages of this book, I've tried
    to demonstrate some of these great advancements in the language, giving you a
    variety of starting points for your own projects, sample code to study and reuse,
    and explanations of various libraries, APIs, and technologies that may be helpful
    in your day-to-day work. I hope you've enjoyed the examples and explanations as
    much as I've enjoyed preparing them, and, more importantly, I hope they help you
    build the Next Big Thing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于 Java 10 以及这两种语言，以及围绕 Java 虚拟机发生的众多其他项目，还有很多可以讨论的内容。经过超过 20 年的发展，Java——这门语言**以及**其环境——仍然势头强劲。在这本书的篇章中，我试图展示语言中的一些重大进步，为你自己的项目提供各种起点，提供供你学习和重用的示例代码，以及解释各种库、API
    和技术，这些可能在你的日常工作中有所帮助。我希望你像我准备这些例子和解释一样喜欢它们，更重要的是，我希望它们能帮助你构建下一个大项目。
- en: Good luck!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运！
