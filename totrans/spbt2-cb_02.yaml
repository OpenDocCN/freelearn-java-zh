- en: Configuring Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Web应用程序
- en: In the previous chapter, we learned about how to create a starting application
    template, add some basic functionalities, and set up a connection to a database.
    In this chapter, we will continue to evolve our BookPub application and give it
    a web presence.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建一个起始应用程序模板，添加一些基本功能，并设置数据库连接。在这一章中，我们将继续演进我们的BookPub应用程序，并为其提供一个网络存在。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下主题：
- en: Creating a basic RESTful application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的RESTful应用程序
- en: Creating Spring Data REST service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Spring Data REST服务
- en: Configuring custom servlet filters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义Servlet过滤器
- en: Configuring custom interceptors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义拦截器
- en: Configuring custom HttpMessageConverters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义HttpMessageConverters
- en: Configuring custom PropertyEditors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义属性编辑器
- en: Configuring custom type formatters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义类型格式化程序
- en: Creating a basic RESTful application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的RESTful应用程序
- en: While the command-line applications do have their place and use, most of today's
    application development is centered around web, REST, and data services. Let's
    start with enhancing our `BookPub` application by providing it with a web-based
    API in order to get access to the book catalogs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令行应用程序确实有其位置和用途，但今天的大多数应用程序开发都是围绕网络、REST和数据处理服务进行的。让我们从通过提供基于网络的API来增强我们的`BookPub`应用程序开始，以便获取图书目录的访问权限。
- en: We will start where we left off in the previous chapter, so there should already
    be an application skeleton with the entity objects and a repository service defined
    and a connection to the database configured.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一章结束的地方开始，因此应该已经有一个包含实体对象和定义了仓库服务以及配置了数据库连接的应用程序骨架。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The very first thing that we will need to do is add a new dependency to `build.gradle`
    with the `spring-boot-starter-web` starter to get us all the necessary libraries
    for web-based functionality. The following code snippet is what it will look like:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要做的是在`build.gradle`中添加一个新的依赖项，使用`spring-boot-starter-web`启动器来获取所有必要的基于网络的库。以下代码片段将展示其外观：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will need to create a Spring controller that will be used to handle
    the web requests for the catalog data in our application. Let's start by creating
    a new package structure to house our controllers so that we have our code nicely
    grouped by its appropriate purposes. Create a package folder called `controllers`
    in the `src/main/java/com/example/bookpub` directory from the root of our project.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个Spring控制器，用于处理我们应用程序中目录数据的Web请求。让我们首先创建一个新的包结构来存放我们的控制器，以便我们的代码根据其适当的目的进行分组。从我们的项目根目录开始，在`src/main/java/com/example/bookpub`目录中创建一个名为`controllers`的包文件夹。
- en: 'As we will be exposing the book data, let''s create the controller class file
    called `BookController` in our newly created package with the following content:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将公开图书数据，让我们在我们的新创建的包中创建一个名为`BookController`的控制器类文件，其内容如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`来启动应用程序。
- en: 'After the application has started, open the browser and go to `http://localhost:8080/books`
    and you should see a response: `[]`.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序启动后，打开浏览器并转到`http://localhost:8080/books`，你应该会看到一个响应：`[]`。
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key to getting the service exposed to web requests is the `@RestController`
    annotation. This is yet another example of a meta-annotation or a convenience
    annotation, as the Spring documentation refers to it at times, which we have seen
    in previous recipes. In `@RestController`, two annotations are defined: `@Controller`
    and `@ResponseBody`. So we could just as easily annotate `BookController`, as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务暴露给Web请求的关键是`@RestController`注解。这是另一个元注解或便利注解的例子，正如Spring文档有时所指出的，我们在之前的食谱中已经见过。在`@RestController`中定义了两个注解：`@Controller`和`@ResponseBody`。因此，我们同样可以像以下这样注解`BookController`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s take a look at the following annotations from the preceding code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下前面代码片段中的以下注解：
- en: '`@Controller`: This is a Spring stereotype annotation that is similar to `@Bean`
    and `@Repository` and declares the annotated class as an MVC'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Controller`：这是一个Spring stereotypes 注解，类似于`@Bean`和`@Repository`，它将注解的类声明为MVC'
- en: '`@ResponseBody`: This is a Spring MVC annotation indicating that responses
    from the web-request-mapped methods constitute the entire content of the HTTP
    response body payload, which is typical for the RESTful applications'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ResponseBody`：这是一个 Spring MVC 注解，表示来自 web 映射方法的响应构成了整个 HTTP 响应体负载的内容，这对于
    RESTful 应用程序来说是典型的。'
- en: '`@RequestMapping`: This is a Spring MVC annotation indicating that requests
    to `/books/*` URL will be routed to  this controller.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping`：这是一个 Spring MVC 注解，表示对 `/books/*` URL 的请求将被路由到这个控制器。'
- en: Creating Spring Data REST service
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Spring Data REST 服务
- en: 'In the previous example, we fronted our `BookRepository` interface with a REST
    controller in order to expose the data behind it via a web RESTful API. While
    this is definitely a quick and easy way to make the data accessible, it does require
    us to manually create a controller and define the mappings for all the desired
    operations. To minimize the boilerplate code, Spring provides us with a more convenient
    way: `spring-boot-starter-data-rest`. This allows us to simply add an annotation
    to the repository interface and Spring will do the rest to expose it to the web.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过 REST 控制器将 `BookRepository` 接口作为前端，以便通过 Web RESTful API 暴露其后的数据。虽然这确实是一种快速简单的方法来使数据可访问，但它确实需要我们手动创建控制器并定义所有期望的操作的映射。为了最小化样板代码，Spring
    提供了一种更方便的方法：`spring-boot-starter-data-rest`。这允许我们只需在存储库接口上添加一个注解，Spring 就会完成其余的工作，将其暴露到
    Web 上。
- en: We will continue from where we finished in the previous recipe, and so the entity
    models and the `BookRepository` interface should already exist.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续进行到上一个菜谱结束的地方，因此实体模型和 `BookRepository` 接口应该已经存在。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start by adding another dependency to our `build.gradle` file in order
    to add the `spring-boot-starter-data-rest` artifact:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在我们的 `build.gradle` 文件中添加另一个依赖项，以便添加 `spring-boot-starter-data-rest` 仓库：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s create a new interface to define `AuthorRepository` in the `src/main/java/com/example/bookpub/repository`
    directory from the root of our project with the following content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在项目根目录下的 `src/main/java/com/example/bookpub/repository` 目录中创建一个新的接口来定义
    `AuthorRepository`，内容如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While we are at it—given how little code it takes—let''s create the repository
    interfaces for the remaining entity models, `PublisherRepository` and `ReviewerRepository`
    by placing the files in the same package directory as `AuthorRepository` with
    the following content:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经开始了——考虑到代码量如此之少——让我们创建剩余实体模型 `PublisherRepository` 和 `ReviewerRepository`
    的存储库接口，将这些文件放置在与 `AuthorRepository` 相同的包目录中，内容如下：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Otherwise, you can use the following code instead of the preceding code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以使用以下代码代替前面的代码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 启动应用程序
- en: After the application has started, open the browser and go to `http://localhost:8080/authors`
    and you should see the following response:![](img/71ab0b14-d267-43a9-a664-393a315e3ff5.png)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序启动后，打开浏览器并转到 `http://localhost:8080/authors`，你应该看到以下响应：![图片](img/71ab0b14-d267-43a9-a664-393a315e3ff5.png)
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As is evidenced from the browser view, we will get significantly more information
    than we got when we wrote the books controller. This is in part due to us extending
    not a `CrudRepository` interface, but a `PagingAndSortingRepository` one, which
    in turn is an extension of `CrudRepository`. The reason that we've decided to
    do this is to get the extra benefits provided by `PagingAndSortingRepository`.
    This will add the extra functionality to retrieve entities using the pagination
    and being able to sort them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如浏览器视图所示，我们将获得比我们编写书籍控制器时多得多的信息。这在一定程度上是因为我们扩展的不是 `CrudRepository` 接口，而是一个 `PagingAndSortingRepository`
    接口，而 `PagingAndSortingRepository` 又是 `CrudRepository` 的扩展。我们决定这样做的原因是为了获得 `PagingAndSortingRepository`
    提供的额外好处。这将添加额外的功能，以便使用分页检索实体，并能够对它们进行排序。
- en: 'The `@RepositoryRestResource` annotation, while optional, provides us with
    the ability to have finer control over the exposure of the repository as a web
    data service. For example, if we wanted to change the URL `path` or `rel` value,
    to `writers` instead of `authors`, we could have tuned the annotation as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RepositoryRestResource` 注解虽然不是必需的，但它为我们提供了更精细地控制将存储库作为 Web 数据服务暴露的能力。例如，如果我们想将
    URL `path` 或 `rel` 值更改为 `writers` 而不是 `authors`，我们可以调整注解如下：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we included `spring-boot-starter-data-rest` in our build dependencies, we
    will also get the `spring-hateoas` library support, which gives us nice ALPS metadata,
    such as a `_links` object. This can be very helpful when building an API-driven
    UI, which can deduce the navigational capabilities from the metadata and present
    them appropriately.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在构建依赖中包含了`spring-boot-starter-data-rest`，我们还将获得`spring-hateoas`库的支持，它为我们提供了很好的ALPS元数据，例如`_links`对象。这在构建API驱动的UI时非常有帮助，可以从元数据中推断导航能力并适当地展示它们。
- en: Configuring custom servlet filters
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义servlet过滤器
- en: In a real-world web application, we almost always find a need to add facades
    or wrappers to service requests, to log them, filter out bad characters for XSS,
    perform authentication, and so on. Out of the box, Spring Boot automatically adds
    `OrderedCharacterEncodingFilter` and `HiddenHttpMethodFilter`, but we can always
    add more. Let's see how Spring Boot helps us achieve this task.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的Web应用程序中，我们几乎总是需要添加门面或包装器来处理服务请求，记录它们，过滤掉XSS中的恶意字符，执行身份验证等等。默认情况下，Spring
    Boot自动添加了`OrderedCharacterEncodingFilter`和`HiddenHttpMethodFilter`，但我们总是可以添加更多。让我们看看Spring
    Boot是如何帮助我们完成这个任务的。
- en: 'Among the various assortments of Spring Boot, Spring Web, Spring MVC, and others,
    there is already a vast variety of different servlet filters that are available
    and all we have to do is define them as beans in the configuration. Let''s say
    that our application will be running behind a load balancer proxy and we would
    like to translate the real request IP that is used by the users instead of the
    IP from the proxy when our application instance receives the request. Luckily,
    Apache Tomcat 8 already provides us with an implementation: `RemoteIpFilter`.
    All we will need to do is add it to our filter chain.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot、Spring Web、Spring MVC和其他各种组合中，已经存在大量的不同servlet过滤器，我们只需要在配置中定义它们作为bean即可。假设我们的应用程序将在负载均衡器代理后面运行，并且我们希望将用户使用的实际请求IP翻译成代理IP，而不是应用程序实例接收请求时使用的代理IP。幸运的是，Apache
    Tomcat 8已经为我们提供了一个实现：`RemoteIpFilter`。我们唯一需要做的就是将其添加到我们的过滤器链中。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何去做...
- en: 'It is a good idea to separate and group the configurations into different classes
    in order to provide more clarity about what kind of things are being configured.
    So, let''s create a separate configuration class called `WebConfiguration` in
    the `src/main/java/com/example/bookpub` directory from the root of our project
    with the following content:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将配置分离并分组到不同的类中，以便更清晰地了解正在配置的内容是个好主意。因此，让我们在项目根目录下的`src/main/java/com/example/bookpub`目录中创建一个名为`WebConfiguration`的单独配置类，其内容如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`来启动应用程序。
- en: 'In the startup log, we should see the following line, indicating that our filter
    has been added:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动日志中，我们应该看到以下行，表明我们的过滤器已被添加：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The magic behind this functionality is actually very simple. Let's start from
    the separate configuration class and work our way to the filter bean detection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能背后的魔法实际上非常简单。让我们从单独的配置类开始，逐步到过滤器bean检测。
- en: If we look in our main class, `BookPubApplication`, we will see that it is annotated
    with `@SpringBootApplication`, which in turn is a convenience meta-annotation
    that declares `@ComponentScan` among others. We discussed this in detail in one
    of our earlier recipes. The presence of `@ComponentScan` instructs Spring Boot
    to detect `WebConfiguration` as a `@Configuration` class and add its definitions
    to the context. So, anything that we will declare in `WebConfiguration` is as
    good as if we were to put it right in `BookPubApplication` itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看主类`BookPubApplication`，我们会看到它被注解了`@SpringBootApplication`，这反过来又是一个便利的元注解，它声明了`@ComponentScan`等。我们已经在之前的菜谱中详细讨论了这一点。`@ComponentScan`的存在指示Spring
    Boot将`WebConfiguration`检测为一个`@Configuration`类，并将其定义添加到上下文中。因此，我们在`WebConfiguration`中声明的任何内容都相当于直接在`BookPubApplication`中放置它。
- en: The `@BeanpublicRemoteIpFilterremoteIpFilter() {...}` declaration simply creates
    a Spring bean for the `RemoteIpFilter` class. When Spring Boot detects all the
    beans of `javax.servlet.Filter`, it will add them to the filter chain automatically.
    So, all we have to do, if we want to add more filters, is to just declare them
    as `@Bean` configurations. For example, for a more advanced filter configuration,
    if we want a particular filter to apply only to specific URL patterns, we can
    create a `@Bean` configuration of a `FilterRegistrationBean` type and use it to
    configure the precise settings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`@BeanpublicRemoteIpFilterremoteIpFilter() {...}`声明只是为`RemoteIpFilter`类创建了一个Spring
    Bean。当Spring Boot检测到所有`javax.servlet.Filter`的Bean时，它会自动将它们添加到过滤器链中。因此，如果我们想添加更多过滤器，我们只需要将它们声明为`@Bean`配置。例如，对于更高级的过滤器配置，如果我们想使特定的过滤器仅应用于特定的URL模式，我们可以创建一个`FilterRegistrationBean`类型的`@Bean`配置，并使用它来配置精确的设置。'
- en: To make supporting this use-case easier Spring Boot provides us with configuration
    properties that can be used instead of manually configuring the `RemoteIpFilter`
    bean for occasions when Tomcat servlet container is being used. Use `server.use-forward-headers=true`
    to indicate to Spring Boot that it needs to automatically configure support for
    proxy headers, to provide proper request obfuscation. Specifically for Tomcat,
    one can also use `server.tomcat.remote_ip_header=x-forwarded-for` and `server.tomcat.protocol_header=x-forwarded-proto`
    properties to configure what specific header names should be used to retrieve
    the values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使支持这个用例更容易，Spring Boot为我们提供了配置属性，可以在使用Tomcat servlet容器时替代手动配置`RemoteIpFilter`
    Bean。使用`server.use-forward-headers=true`来指示Spring Boot需要自动配置对代理头部的支持，以提供适当的请求混淆。对于Tomcat，还可以使用`server.tomcat.remote_ip_header=x-forwarded-for`和`server.tomcat.protocol_header=x-forwarded-proto`属性来配置应使用哪些特定的头部名称来检索值。
- en: Configuring custom interceptors
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义拦截器
- en: 'While servlet filters are a part of the Servlet API and have nothing to do
    with Spring besides being automatically added in the filter chain --Spring MVC
    provides us with another way of wrapping web requests: `HandlerInterceptor`. According
    to the documentation, `HandlerInterceptor` is just like a filter. Instead of wrapping
    a request in a nested chain, an interceptor gives us cutaway points at different
    phases, such as before the request gets handled, after the request has been processed,
    before the view has been rendered, and at the very end, after the request has
    been fully completed. It does not let us change anything about the request, but
    it does let us stop the execution by throwing an exception or returning false
    if the interceptor logic determines so.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然servlet过滤器是Servlet API的一部分，并且除了在过滤器链中自动添加之外与Spring无关 --Spring MVC为我们提供了另一种封装网络请求的方式：`HandlerInterceptor`。根据文档，`HandlerInterceptor`就像一个过滤器。它不是在嵌套链中封装请求，而是在不同的阶段提供切割点，例如在请求被处理之前，在请求被处理后，在视图渲染之前，以及在请求完全完成后。它不会让我们改变请求的任何内容，但如果拦截器逻辑决定这样做，它可以通过抛出异常或返回false来停止执行。
- en: Similar to using filters, Spring MVC comes with a number of premade `HandlerInterceptors`.
    The commonly used ones are `LocaleChangeInterceptor` and `ThemeChangeInterceptor`;
    but there are certainly others that provide great value. So let's add `LocaleChangeInterceptor`
    to our application in order to see how it is done.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用过滤器类似，Spring MVC自带了许多预制的`HandlerInterceptors`。常用的有`LocaleChangeInterceptor`和`ThemeChangeInterceptor`；但当然还有其他提供很大价值的拦截器。所以，让我们将`LocaleChangeInterceptor`添加到我们的应用程序中，以便了解它是如何实现的。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Despite what you might think, after seeing the previous recipe, adding an interceptor
    is not as straightforward as just declaring it as a bean. We actually need to
    do it via `WebMvcConfigurer` or by overriding `WebMvcConfigurationSupport`. Let''s
    take a look at the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能认为，在看过之前的食谱后，添加拦截器并不像只是声明为一个Bean那样简单。我们实际上需要通过`WebMvcConfigurer`或覆盖`WebMvcConfigurationSupport`来实现。让我们看看以下步骤：
- en: 'Let''s enhance our `WebConfiguration` class to implement `WebMvcConfigurer`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们增强我们的`WebConfiguration`类以实现`WebMvcConfigurer`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we will add a `@Bean` declaration for `LocaleChangeInterceptor`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个`LocaleChangeInterceptor`的`@Bean`声明：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will actually create the interceptor Spring bean, but will not add it
    to the request handling chain. For this to happen, we will need to override the
    `addInterceptors` method and add our interceptor to the provided registry:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这实际上会创建拦截器 Spring 豆，但不会将其添加到请求处理链中。为了实现这一点，我们需要重写 `addInterceptors` 方法并将我们的拦截器添加到提供的注册表中：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 来启动应用程序
- en: In the browser, go to `http://localhost:8080/books?locale=foo`
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，访问 `http://localhost:8080/books?locale=foo`
- en: 'Now, if you look at the console logs, you will see a bunch of stack trace errors
    basically saying the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你查看控制台日志，你会看到一堆堆栈跟踪错误，基本上是以下内容：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While the error is not because we entered an invalid locale, but because the
    default locale resolution strategy does not allow the resetting of the locale
    that is requested by the browser, the fact that we got an error shows that our
    interceptor is working.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然错误不是因为我们输入了一个无效的区域设置，而是因为默认的区域设置解析策略不允许重置浏览器请求的区域设置，但我们得到错误的事实表明我们的拦截器正在工作。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When it comes to configuring the Spring MVC internals, it is not as simple as
    just defining a bunch of beans at least not always. This is due to the need to
    provide a more fine-tuned mapping of the MVC components to requests. To make things
    easier, Spring provides us with a collection of default methods in `WebMvcConfigurer` interface
    that we can extend and override the settings of that we need.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到配置 Spring MVC 内部组件时，仅仅定义一系列豆类并不简单，至少不是总是这样。这是因为需要提供更精细的 MVC 组件到请求的映射。为了使事情变得简单，Spring
    在 `WebMvcConfigurer` 接口为我们提供了一系列默认方法，我们可以扩展并覆盖我们需要的设置。
- en: In the particular case of configuring interceptors, we are overriding the `addInterceptors(InterceptorRegistry
    registry)` method. This is a typical callback method where we are given a registry
    in order to register as many additional interceptors as we need. During the MVC
    autoconfiguration phase, Spring Boot, just like in the case of filters, detects
    instances of `WebMvcConfigurer` and sequentially calls the callback methods on
    all of them. It means that we can have more than one implementation of the `WebMvcConfigurer`
    class if we want to have some logical separation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置拦截器的情况下，我们正在重写 `addInterceptors(InterceptorRegistry registry)` 方法。这是一个典型的回调方法，我们被提供一个注册表以便注册尽可能多的额外拦截器。在
    MVC 自动配置阶段，Spring Boot，就像在过滤器的情况下，检测 `WebMvcConfigurer` 的实例，并依次调用它们的所有回调方法。这意味着如果我们想要进行一些逻辑上的分离，我们可以有多个
    `WebMvcConfigurer` 类的实现。
- en: Configuring custom HttpMessageConverters
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义 HttpMessageConverters
- en: While we were building our RESTful web data service, we defined the controllers,
    repositories, and put some annotations on them; but nowhere did we do any kind
    of object translation from the Java entity beans to the HTTP data stream output.
    However, behind the scenes, Spring Boot automatically configured `HttpMessageConverters`
    so as to translate our entity beans into a JSON representation written to HTTP
    response using the `Jackson` library. When multiple converters are available,
    the most applicable one gets selected based on the message object class and the
    requested content type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建我们的 RESTful 网络数据服务时，我们定义了控制器、存储库，并在它们上放置了一些注解；但我们没有在任何地方进行从 Java 实体豆到 HTTP
    数据流输出的对象转换。然而，在幕后，Spring Boot 自动配置了 `HttpMessageConverters`，以便将我们的实体豆转换为 JSON
    表示形式，并使用 `Jackson` 库将其写入 HTTP 响应。当有多个转换器可用时，最适用的转换器会根据消息对象类和请求的内容类型被选中。
- en: The purpose of `HttpMessageConverters` is to translate various object types
    into their corresponding HTTP output formats. A converter can either support a
    range of multiple data types or multiple output formats, or a combination of both.
    For example, `MappingJackson2HttpMessageConverter` can translate any Java object
    into `application/json`, whereas `ProtobufHttpMessageConverter` can only operate
    on instances of `com.google.protobuf.Message` but can write them to the wire as
    `application/json`, `application/xml`, `text/plain`, or `application/x-protobuf`.
    `HttpMessageConverters` support not only writing out to the HTTP stream but also
    converting HTTP requests to appropriate Java objects as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpMessageConverters`的目的在于将各种对象类型转换为它们对应的HTTP输出格式。转换器可以支持多种数据类型或多种输出格式，或者两者的组合。例如，`MappingJackson2HttpMessageConverter`可以将任何Java对象转换为`application/json`，而`ProtobufHttpMessageConverter`只能操作`com.google.protobuf.Message`的实例，但可以将它们写入为`application/json`、`application/xml`、`text/plain`或`application/x-protobuf`。`HttpMessageConverters`不仅支持写入HTTP流，还可以将HTTP请求转换为适当的Java对象。'
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: There are a number of ways in which we can configure converters. It all depends
    on which one you prefer or how much control you want to achieve.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式来配置转换器。这完全取决于你更喜欢哪种方式，或者你想要达到多少控制程度。
- en: 'Let''s add `ByteArrayHttpMessageConverter` as `@Bean` to our `WebConfiguration`
    class in the following manner:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在以下方式中将`ByteArrayHttpMessageConverter`作为`@Bean`添加到我们的`WebConfiguration`类中：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another way to achieve this is to override the `configureMessageConverters`
    method in the `WebConfiguration` class, which extends `WebMvcConfigurerAdapter`,
    defining such a method as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这一目标的另一种方法是覆盖`WebConfiguration`类中的`configureMessageConverters`方法，该类扩展了`WebMvcConfigurerAdapter`，并定义如下方法：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to have a bit more control, we can override the `extendMessageConverters`
    method in the following way:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要有更多的控制，我们可以以以下方式覆盖`extendMessageConverters`方法：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, Spring gives us multiple ways of achieving the same thing and
    it all depends on our preference or particular details of the implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Spring为我们提供了多种实现相同功能的方式，这完全取决于我们的偏好或特定实现的细节。
- en: We covered three different ways of adding `HttpMessageConverter` to our application.
    So what is the difference, one might ask?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了三种向应用程序添加`HttpMessageConverter`的不同方法。那么，它们之间有什么区别呢？
- en: Declaring `HttpMessageConverter` as `@Bean` is the quickest and simplest way
    of adding a custom converter to the application. It is similar to how we added
    servlet filters in an earlier example. If Spring detects a bean of the `HttpMessageConverter`
    type, it will add it to the list automatically. If we did not have a `WebConfiguration`
    class that implements `WebMvcConfigurer`, it would have been the preferred approach.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将`HttpMessageConverter`声明为`@Bean`是向应用程序添加自定义转换器最快、最简单的方式。这与我们在早期示例中添加servlet过滤器的方式类似。如果Spring检测到`HttpMessageConverter`类型的bean，它将自动将其添加到列表中。如果没有实现`WebMvcConfigurer`的`WebConfiguration`类，这将是首选的方法。
- en: When the application needs to define a more precise control over the settings,
    like interceptors, mappings, etc, it is best to use `WebMvcConfigurer` implementation
    to configure those, as it would be more consistent to override the `configureMessageConverters`
    method and add our converter to the list. As there can be multiple instances of
    `WebMvcConfigurers`, which could be either added by us or via the auto-configuration
    settings from various Spring Boot starters, there is no guarantee that our method
    can get called in any particular order.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要定义更精确的设置控制，如拦截器、映射等时，最好使用`WebMvcConfigurer`实现来配置这些设置，因为覆盖`configureMessageConverters`方法并将我们的转换器添加到列表中将更加一致。由于可能有多个`WebMvcConfigurers`实例，这些实例可能是由我们添加的，也可能是通过各种Spring
    Boot启动器的自动配置设置添加的，因此无法保证我们的方法会以任何特定的顺序被调用。
- en: If we need to do something even more drastic such as removing all the other
    converters from the list or clearing it of duplicate converters, this is where
    overriding `extendMessageConverters` comes into play. This method gets invoked
    after all the `WebMvcConfigurers` get called for `configureMessageConverters`
    and the list of converters is fully populated. Of course, it is entirely possible
    that some other instance of `WebMvcConfigurer` could override `extendMessageConverters`
    as well; but the chances of this are very low so you have a high degree of having
    the desired impact.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要做更彻底的事情，比如从列表中移除所有其他转换器或清除重复的转换器，这就是覆盖 `extendMessageConverters` 发挥作用的地方。该方法在所有
    `WebMvcConfigurers` 调用 `configureMessageConverters` 之后被调用，并且转换器列表已经完全填充。当然，完全有可能其他
    `WebMvcConfigurer` 实例也会覆盖 `extendMessageConverters`；但这种情况的可能性非常低，因此你有很大的机会产生期望的影响。
- en: Configuring custom PropertyEditors
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义的 `PropertyEditors`
- en: In the previous example, we learned how to configure converters for an HTTP
    request and response data. There are other kinds of conversions that take place,
    especially in regards to dynamically converting parameters to various objects,
    such as Strings to Date or an Integer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何配置 HTTP 请求和响应数据的转换器。还有其他类型的转换发生，尤其是在动态将参数转换为各种对象时，例如字符串转换为日期或整数。
- en: When we declare a mapping method in a controller, Spring allows us to freely
    define the method signature with the exact object types that we require. The way
    in which this is achieved is via the use of the `PropertyEditor` implementations.
    `PropertyEditor` is a default concept defined as part of the JDK and designed
    to allow the transformation of a textual value to a given type. It was initially
    intended to be used to build Java Swing / **Abstract Window Toolkit** (**AWT**)
    GUI and later proved to be a good fit for Spring's need to convert web parameters
    to method argument types.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在控制器中声明一个映射方法时，Spring 允许我们自由定义方法签名，使用我们所需的精确对象类型。这是通过使用 `PropertyEditor`
    实现来实现的。`PropertyEditor` 是 JDK 部分定义的一个默认概念，旨在允许将文本值转换为给定类型。它最初是为了构建 Java Swing
    / **抽象窗口工具包** (**AWT**) GUI 而设计的，后来证明非常适合 Spring 将网络参数转换为方法参数类型的需求。
- en: Spring MVC already provides you with a lot of `PropertyEditor` implementations
    for most of the common types, such as Boolean, Currency, and Class. Let's say
    that we want to create a proper `Isbn` class object and use this in our controller
    instead of a plain String.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 已经为大多数常见类型提供了大量的 `PropertyEditor` 实现，例如布尔值、货币和类。假设我们想要创建一个合适的 `Isbn`
    类对象，并在我们的控制器中使用它而不是一个普通的字符串。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First, we will need to remove the `extendMessageConverters` method from our
    `WebConfiguration` class as the `converters.clear()` call will break the rendering
    because we removed all of the supported type converters
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从我们的 `WebConfiguration` 类中移除 `extendMessageConverters` 方法，因为 `converters.clear()`
    调用会破坏渲染，因为我们移除了所有支持的类型转换器
- en: Let's create a new package called `model` under the `src/main/java/com/example/bookpub`
    directory from the root of our project
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目根目录下的 `src/main/java/com/example/bookpub` 目录下创建一个名为 `model` 的新包
- en: 'Next we create a class named `Isbn` under our newly created package directory
    from the root of our project with the following content:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在项目根目录下创建一个名为 `Isbn` 的新类，位于我们刚刚创建的包目录中，内容如下：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's create a new package called `editors` under the `src/main/java/com/example/bookpub`
    directory from the root of our project
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目根目录下的 `src/main/java/com/example/bookpub` 目录下创建一个名为 `editors` 的新包
- en: 'Let''s create a class named `IsbnEditor` under our newly created package directory
    from the root of our project with the following content:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目根目录下创建一个名为 `IsbnEditor` 的新类，位于我们刚刚创建的包目录中，内容如下：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will add a method, `initBinder`, to `BookController` where we will
    configure the `IsbnEditor` method with the following content:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向 `BookController` 添加一个名为 `initBinder` 的方法，在其中我们将使用以下内容配置 `IsbnEditor`
    方法：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our `getBook` method in `BookController` will also change in order to accept
    the `Isbn` object, in the following way:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `BookController` 中的 `getBook` 方法也将改变，以便接受 `Isbn` 对象，如下所示：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 启动应用程序
- en: In the browser, go to `http://localhost:8080/books/978-1-78528-415-1`
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，访问 `http://localhost:8080/books/978-1-78528-415-1`
- en: While we will not observe any visible changes,  `IsbnEditor` is indeed at work,
    creating an instance of an `Isbn` class object from the `{isbn}` parameter
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们不会观察到任何明显的变化，但`IsbnEditor`确实在运行，它从`{isbn}`参数创建一个`Isbn`类对象。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spring automatically configures a large number of default editors; but for custom
    types, we have to explicitly instantiate new editors for every web request. This
    is done in the controller in a method that is annotated with `@InitBinder`. This
    annotation is scanned and all the detected methods should have a signature of
    accepting `WebDataBinder` as an argument. Among other things, `WebDataBinder`
    provides us with an ability to register as many custom editors as we require for
    the controller methods to be bound properly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Spring自动配置了大量默认编辑器；但对于自定义类型，我们必须为每个Web请求显式实例化新的编辑器。这是在控制器中通过一个带有`@InitBinder`注解的方法完成的。这个注解会被扫描，所有检测到的方法都应该接受`WebDataBinder`作为参数。`WebDataBinder`还为我们提供了注册所需数量的自定义编辑器的能力，以便正确绑定控制器方法。
- en: It is very important to know that `PropertyEditor` is not thread-safe! For this
    reason, we have to create a new instance of our custom editors for every web request
    and register them with `WebDataBinder`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要知道`PropertyEditor`不是线程安全的！因此，我们必须为每个Web请求创建我们自定义编辑器的新实例，并将它们注册到`WebDataBinder`。
- en: In case a new `PropertyEditor` is needed, it is best to create one by extending
    `PropertyEditorSupport` and overriding the desired methods with custom implementation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要新的`PropertyEditor`，最好通过扩展`PropertyEditorSupport`并覆盖所需的方法以自定义实现来创建一个。
- en: Configuring custom type formatters
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义类型格式化器
- en: Mostly because of its statefulness and lack of thread safety, since version
    3, Spring has added a `Formatter` interface as a replacement for `PropertyEditor`.
    The formatters are intended to provide a similar functionality but in a completely
    thread-safe manner and focusing on a very specific task of parsing a String in
    an object type and converting an object to its String representation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是因为其状态性和缺乏线程安全性，从版本3开始，Spring添加了一个`Formatter`接口来替代`PropertyEditor`。这些格式化器旨在提供类似的功能，但以完全线程安全的方式，并专注于非常具体的任务，即解析对象类型的字符串表示并将其转换为对象。
- en: Let's suppose that for our application, we would like to have a formatter that
    would take the ISBN number of a book in a String form and convert it to a book
    entity object. This way, we can define the controller request methods with a `Book`
    argument when the request URL signature only contains an ISBN number or a database
    ID.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望我们的应用程序有一个格式化器，它可以将书籍的ISBN号码从字符串形式转换为书籍实体对象。这样，我们就可以在请求URL签名只包含ISBN号码或数据库ID时，使用`Book`作为参数定义控制器请求方法。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First, let's create a new package called `formatters` in the `src/main/java/com/example/bookpub`
    directory from the root of our project
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在项目根目录`src/main/java/com/example/bookpub`目录中创建一个新的包，名为`formatters`
- en: 'Next, we will create the `Formatter` implementation called `BookFormatter`
    in our newly created package directory from the root of our project with the following
    content:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`BookFormatter`的`Formatter`实现，位于我们新创建的项目根目录的包目录中，内容如下：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have our formatter, we will add it to the registry by overriding
    an `addFormatters(FormatterRegistry registry)` method in the `WebConfiguration`
    class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的格式化器，我们将通过覆盖`WebConfiguration`类中的`addFormatters(FormatterRegistry registry)`方法将其添加到注册表中：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, let''s add a new request method to our `BookController` class located
    in the `src/main/java/com/example/bookpub/controllers` directory from the root
    of our project that will display the reviewers for a given ISBN of a book:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们向位于项目根目录`src/main/java/com/example/bookpub/controllers`目录中的`BookController`类添加一个新的请求方法，该方法将显示给定ISBN号码的书籍的审稿人：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just so we can have some data to play with, let''s manually (for now) populate
    our database with some test data by adding two more autowired repositories to
    the `StartupRunner` class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们有一些数据来操作，让我们手动（目前）通过向`StartupRunner`类添加两个额外的自动装配的仓库来手动填充我们的数据库，以添加一些测试数据：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code snippet is destined for the `run(...)` method of `StartupRunner`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段是为`StartupRunner`的`run(...)`方法准备的：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`启动应用程序
- en: Let's open `http://localhost:8080/books/978-1-78528-415-1/reviewers` in the
    browser and you should be able to see the following results:![](img/1e5987be-68ce-4e93-b772-67b5b6403036.png)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://localhost:8080/books/978-1-78528-415-1/reviewers`，你应该能看到以下结果！![图片](img/1e5987be-68ce-4e93-b772-67b5b6403036.png)
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The formatter facility is aims to provide a similar functionality to `PropertyEditors`.
    By registering our formatter with `FormatterRegistry` in the overridden `addFormatters`
    method, we are instructing Spring to use our formatter to translate a textual
    representation of our book into an entity object and back. As formatters are stateless,
    we don't need to do the registration in our controller for every call; we have
    to do it only once and this will ensure Spring uses it for every web request.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化工具旨在提供与 `PropertyEditors` 相似的功能。通过在重写的 `addFormatters` 方法中将我们的格式化工具注册到 `FormatterRegistry`，我们指示
    Spring 使用我们的格式化工具将书籍的文本表示转换为实体对象，并反向转换。由于格式化工具是无状态的，我们不需要在控制器中对每个调用进行注册；我们只需做一次，这将确保
    Spring 在每个网络请求中使用它。
- en: It is also good to remember that if you want to define a conversion of a common
    type, such as String or Boolean, for example trimming text, it is best to do this
    via `PropertyEditors` in controller's `InitBinder` because such a change is probably
    not globally desired and is only needed for a particular functionality.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得，如果你想定义一个常见类型的转换，例如 String 或 Boolean，例如修剪文本，最好通过控制器中的 `InitBinder` 下的 `PropertyEditors`
    来做这件事，因为这种改变可能不是全局需要的，而只是需要特定功能。
- en: You have probably noticed that we also autowired `BookRepository` to a `WebConfiguration`
    class, as this was needed to create `BookFormatter`. This is one of the cool parts
    about Spring --it lets us combine the configuration classes and make them dependent
    on the other beans at the same time. As we indicated that in order for a `WebConfiguration`
    class to be created we need `BookRepository`, Spring ensured that `BookRepository`
    will be created first and then automatically injected as a dependency during the
    creation of the `WebConfiguration` class. After `WebConfiguration` is instantiated,
    it is processed for configuration instructions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们还自动将 `BookRepository` 注入到 `WebConfiguration` 类中，因为这是创建 `BookFormatter`
    所必需的。这是 Spring 的一个酷特性——它允许我们组合配置类，并使它们同时依赖于其他豆类。正如我们指出的，为了创建 `WebConfiguration`
    类，我们需要 `BookRepository`，Spring 确保首先创建 `BookRepository`，然后在创建 `WebConfiguration`
    类时自动将其注入为依赖项。`WebConfiguration` 实例化后，它将根据配置指令进行处理。
- en: The rest of the added functionalities should already be familiar as we covered
    them in our previous recipes. We will explore how to automatically populate databases
    with schemas and data in [Chapter 5](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml),
    *Application Testing*, in detail, where we will also talk about application testing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余添加的功能应该已经熟悉，因为我们已经在之前的菜谱中介绍了它们。我们将在第 5 章 [应用测试](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml)中详细探讨如何自动用模式和数据填充数据库，我们还将讨论应用测试。
