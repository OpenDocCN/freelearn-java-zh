- en: Configuring Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about how to create a starting application
    template, add some basic functionalities, and set up a connection to a database.
    In this chapter, we will continue to evolve our BookPub application and give it
    a web presence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic RESTful application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Spring Data REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring custom servlet filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring custom interceptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring custom HttpMessageConverters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring custom PropertyEditors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring custom type formatters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic RESTful application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the command-line applications do have their place and use, most of today's
    application development is centered around web, REST, and data services. Let's
    start with enhancing our `BookPub` application by providing it with a web-based
    API in order to get access to the book catalogs.
  prefs: []
  type: TYPE_NORMAL
- en: We will start where we left off in the previous chapter, so there should already
    be an application skeleton with the entity objects and a repository service defined
    and a connection to the database configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The very first thing that we will need to do is add a new dependency to `build.gradle`
    with the `spring-boot-starter-web` starter to get us all the necessary libraries
    for web-based functionality. The following code snippet is what it will look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will need to create a Spring controller that will be used to handle
    the web requests for the catalog data in our application. Let's start by creating
    a new package structure to house our controllers so that we have our code nicely
    grouped by its appropriate purposes. Create a package folder called `controllers`
    in the `src/main/java/com/example/bookpub` directory from the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we will be exposing the book data, let''s create the controller class file
    called `BookController` in our newly created package with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the application has started, open the browser and go to `http://localhost:8080/books`
    and you should see a response: `[]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key to getting the service exposed to web requests is the `@RestController`
    annotation. This is yet another example of a meta-annotation or a convenience
    annotation, as the Spring documentation refers to it at times, which we have seen
    in previous recipes. In `@RestController`, two annotations are defined: `@Controller`
    and `@ResponseBody`. So we could just as easily annotate `BookController`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following annotations from the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Controller`: This is a Spring stereotype annotation that is similar to `@Bean`
    and `@Repository` and declares the annotated class as an MVC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ResponseBody`: This is a Spring MVC annotation indicating that responses
    from the web-request-mapped methods constitute the entire content of the HTTP
    response body payload, which is typical for the RESTful applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping`: This is a Spring MVC annotation indicating that requests
    to `/books/*` URL will be routed to  this controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Spring Data REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we fronted our `BookRepository` interface with a REST
    controller in order to expose the data behind it via a web RESTful API. While
    this is definitely a quick and easy way to make the data accessible, it does require
    us to manually create a controller and define the mappings for all the desired
    operations. To minimize the boilerplate code, Spring provides us with a more convenient
    way: `spring-boot-starter-data-rest`. This allows us to simply add an annotation
    to the repository interface and Spring will do the rest to expose it to the web.'
  prefs: []
  type: TYPE_NORMAL
- en: We will continue from where we finished in the previous recipe, and so the entity
    models and the `BookRepository` interface should already exist.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by adding another dependency to our `build.gradle` file in order
    to add the `spring-boot-starter-data-rest` artifact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a new interface to define `AuthorRepository` in the `src/main/java/com/example/bookpub/repository`
    directory from the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are at it—given how little code it takes—let''s create the repository
    interfaces for the remaining entity models, `PublisherRepository` and `ReviewerRepository`
    by placing the files in the same package directory as `AuthorRepository` with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can use the following code instead of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the application has started, open the browser and go to `http://localhost:8080/authors`
    and you should see the following response:![](img/71ab0b14-d267-43a9-a664-393a315e3ff5.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As is evidenced from the browser view, we will get significantly more information
    than we got when we wrote the books controller. This is in part due to us extending
    not a `CrudRepository` interface, but a `PagingAndSortingRepository` one, which
    in turn is an extension of `CrudRepository`. The reason that we've decided to
    do this is to get the extra benefits provided by `PagingAndSortingRepository`.
    This will add the extra functionality to retrieve entities using the pagination
    and being able to sort them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@RepositoryRestResource` annotation, while optional, provides us with
    the ability to have finer control over the exposure of the repository as a web
    data service. For example, if we wanted to change the URL `path` or `rel` value,
    to `writers` instead of `authors`, we could have tuned the annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we included `spring-boot-starter-data-rest` in our build dependencies, we
    will also get the `spring-hateoas` library support, which gives us nice ALPS metadata,
    such as a `_links` object. This can be very helpful when building an API-driven
    UI, which can deduce the navigational capabilities from the metadata and present
    them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring custom servlet filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world web application, we almost always find a need to add facades
    or wrappers to service requests, to log them, filter out bad characters for XSS,
    perform authentication, and so on. Out of the box, Spring Boot automatically adds
    `OrderedCharacterEncodingFilter` and `HiddenHttpMethodFilter`, but we can always
    add more. Let's see how Spring Boot helps us achieve this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the various assortments of Spring Boot, Spring Web, Spring MVC, and others,
    there is already a vast variety of different servlet filters that are available
    and all we have to do is define them as beans in the configuration. Let''s say
    that our application will be running behind a load balancer proxy and we would
    like to translate the real request IP that is used by the users instead of the
    IP from the proxy when our application instance receives the request. Luckily,
    Apache Tomcat 8 already provides us with an implementation: `RemoteIpFilter`.
    All we will need to do is add it to our filter chain.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a good idea to separate and group the configurations into different classes
    in order to provide more clarity about what kind of things are being configured.
    So, let''s create a separate configuration class called `WebConfiguration` in
    the `src/main/java/com/example/bookpub` directory from the root of our project
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the startup log, we should see the following line, indicating that our filter
    has been added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The magic behind this functionality is actually very simple. Let's start from
    the separate configuration class and work our way to the filter bean detection.
  prefs: []
  type: TYPE_NORMAL
- en: If we look in our main class, `BookPubApplication`, we will see that it is annotated
    with `@SpringBootApplication`, which in turn is a convenience meta-annotation
    that declares `@ComponentScan` among others. We discussed this in detail in one
    of our earlier recipes. The presence of `@ComponentScan` instructs Spring Boot
    to detect `WebConfiguration` as a `@Configuration` class and add its definitions
    to the context. So, anything that we will declare in `WebConfiguration` is as
    good as if we were to put it right in `BookPubApplication` itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `@BeanpublicRemoteIpFilterremoteIpFilter() {...}` declaration simply creates
    a Spring bean for the `RemoteIpFilter` class. When Spring Boot detects all the
    beans of `javax.servlet.Filter`, it will add them to the filter chain automatically.
    So, all we have to do, if we want to add more filters, is to just declare them
    as `@Bean` configurations. For example, for a more advanced filter configuration,
    if we want a particular filter to apply only to specific URL patterns, we can
    create a `@Bean` configuration of a `FilterRegistrationBean` type and use it to
    configure the precise settings.
  prefs: []
  type: TYPE_NORMAL
- en: To make supporting this use-case easier Spring Boot provides us with configuration
    properties that can be used instead of manually configuring the `RemoteIpFilter`
    bean for occasions when Tomcat servlet container is being used. Use `server.use-forward-headers=true`
    to indicate to Spring Boot that it needs to automatically configure support for
    proxy headers, to provide proper request obfuscation. Specifically for Tomcat,
    one can also use `server.tomcat.remote_ip_header=x-forwarded-for` and `server.tomcat.protocol_header=x-forwarded-proto`
    properties to configure what specific header names should be used to retrieve
    the values.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring custom interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While servlet filters are a part of the Servlet API and have nothing to do
    with Spring besides being automatically added in the filter chain --Spring MVC
    provides us with another way of wrapping web requests: `HandlerInterceptor`. According
    to the documentation, `HandlerInterceptor` is just like a filter. Instead of wrapping
    a request in a nested chain, an interceptor gives us cutaway points at different
    phases, such as before the request gets handled, after the request has been processed,
    before the view has been rendered, and at the very end, after the request has
    been fully completed. It does not let us change anything about the request, but
    it does let us stop the execution by throwing an exception or returning false
    if the interceptor logic determines so.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to using filters, Spring MVC comes with a number of premade `HandlerInterceptors`.
    The commonly used ones are `LocaleChangeInterceptor` and `ThemeChangeInterceptor`;
    but there are certainly others that provide great value. So let's add `LocaleChangeInterceptor`
    to our application in order to see how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite what you might think, after seeing the previous recipe, adding an interceptor
    is not as straightforward as just declaring it as a bean. We actually need to
    do it via `WebMvcConfigurer` or by overriding `WebMvcConfigurationSupport`. Let''s
    take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enhance our `WebConfiguration` class to implement `WebMvcConfigurer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will add a `@Bean` declaration for `LocaleChangeInterceptor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will actually create the interceptor Spring bean, but will not add it
    to the request handling chain. For this to happen, we will need to override the
    `addInterceptors` method and add our interceptor to the provided registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the browser, go to `http://localhost:8080/books?locale=foo`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you look at the console logs, you will see a bunch of stack trace errors
    basically saying the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While the error is not because we entered an invalid locale, but because the
    default locale resolution strategy does not allow the resetting of the locale
    that is requested by the browser, the fact that we got an error shows that our
    interceptor is working.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to configuring the Spring MVC internals, it is not as simple as
    just defining a bunch of beans at least not always. This is due to the need to
    provide a more fine-tuned mapping of the MVC components to requests. To make things
    easier, Spring provides us with a collection of default methods in `WebMvcConfigurer` interface
    that we can extend and override the settings of that we need.
  prefs: []
  type: TYPE_NORMAL
- en: In the particular case of configuring interceptors, we are overriding the `addInterceptors(InterceptorRegistry
    registry)` method. This is a typical callback method where we are given a registry
    in order to register as many additional interceptors as we need. During the MVC
    autoconfiguration phase, Spring Boot, just like in the case of filters, detects
    instances of `WebMvcConfigurer` and sequentially calls the callback methods on
    all of them. It means that we can have more than one implementation of the `WebMvcConfigurer`
    class if we want to have some logical separation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring custom HttpMessageConverters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we were building our RESTful web data service, we defined the controllers,
    repositories, and put some annotations on them; but nowhere did we do any kind
    of object translation from the Java entity beans to the HTTP data stream output.
    However, behind the scenes, Spring Boot automatically configured `HttpMessageConverters`
    so as to translate our entity beans into a JSON representation written to HTTP
    response using the `Jackson` library. When multiple converters are available,
    the most applicable one gets selected based on the message object class and the
    requested content type.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of `HttpMessageConverters` is to translate various object types
    into their corresponding HTTP output formats. A converter can either support a
    range of multiple data types or multiple output formats, or a combination of both.
    For example, `MappingJackson2HttpMessageConverter` can translate any Java object
    into `application/json`, whereas `ProtobufHttpMessageConverter` can only operate
    on instances of `com.google.protobuf.Message` but can write them to the wire as
    `application/json`, `application/xml`, `text/plain`, or `application/x-protobuf`.
    `HttpMessageConverters` support not only writing out to the HTTP stream but also
    converting HTTP requests to appropriate Java objects as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of ways in which we can configure converters. It all depends
    on which one you prefer or how much control you want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `ByteArrayHttpMessageConverter` as `@Bean` to our `WebConfiguration`
    class in the following manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to achieve this is to override the `configureMessageConverters`
    method in the `WebConfiguration` class, which extends `WebMvcConfigurerAdapter`,
    defining such a method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to have a bit more control, we can override the `extendMessageConverters`
    method in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, Spring gives us multiple ways of achieving the same thing and
    it all depends on our preference or particular details of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We covered three different ways of adding `HttpMessageConverter` to our application.
    So what is the difference, one might ask?
  prefs: []
  type: TYPE_NORMAL
- en: Declaring `HttpMessageConverter` as `@Bean` is the quickest and simplest way
    of adding a custom converter to the application. It is similar to how we added
    servlet filters in an earlier example. If Spring detects a bean of the `HttpMessageConverter`
    type, it will add it to the list automatically. If we did not have a `WebConfiguration`
    class that implements `WebMvcConfigurer`, it would have been the preferred approach.
  prefs: []
  type: TYPE_NORMAL
- en: When the application needs to define a more precise control over the settings,
    like interceptors, mappings, etc, it is best to use `WebMvcConfigurer` implementation
    to configure those, as it would be more consistent to override the `configureMessageConverters`
    method and add our converter to the list. As there can be multiple instances of
    `WebMvcConfigurers`, which could be either added by us or via the auto-configuration
    settings from various Spring Boot starters, there is no guarantee that our method
    can get called in any particular order.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to do something even more drastic such as removing all the other
    converters from the list or clearing it of duplicate converters, this is where
    overriding `extendMessageConverters` comes into play. This method gets invoked
    after all the `WebMvcConfigurers` get called for `configureMessageConverters`
    and the list of converters is fully populated. Of course, it is entirely possible
    that some other instance of `WebMvcConfigurer` could override `extendMessageConverters`
    as well; but the chances of this are very low so you have a high degree of having
    the desired impact.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring custom PropertyEditors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we learned how to configure converters for an HTTP
    request and response data. There are other kinds of conversions that take place,
    especially in regards to dynamically converting parameters to various objects,
    such as Strings to Date or an Integer.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a mapping method in a controller, Spring allows us to freely
    define the method signature with the exact object types that we require. The way
    in which this is achieved is via the use of the `PropertyEditor` implementations.
    `PropertyEditor` is a default concept defined as part of the JDK and designed
    to allow the transformation of a textual value to a given type. It was initially
    intended to be used to build Java Swing / **Abstract Window Toolkit** (**AWT**)
    GUI and later proved to be a good fit for Spring's need to convert web parameters
    to method argument types.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC already provides you with a lot of `PropertyEditor` implementations
    for most of the common types, such as Boolean, Currency, and Class. Let's say
    that we want to create a proper `Isbn` class object and use this in our controller
    instead of a plain String.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will need to remove the `extendMessageConverters` method from our
    `WebConfiguration` class as the `converters.clear()` call will break the rendering
    because we removed all of the supported type converters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create a new package called `model` under the `src/main/java/com/example/bookpub`
    directory from the root of our project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next we create a class named `Isbn` under our newly created package directory
    from the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a new package called `editors` under the `src/main/java/com/example/bookpub`
    directory from the root of our project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a class named `IsbnEditor` under our newly created package directory
    from the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a method, `initBinder`, to `BookController` where we will
    configure the `IsbnEditor` method with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `getBook` method in `BookController` will also change in order to accept
    the `Isbn` object, in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the browser, go to `http://localhost:8080/books/978-1-78528-415-1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While we will not observe any visible changes,  `IsbnEditor` is indeed at work,
    creating an instance of an `Isbn` class object from the `{isbn}` parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring automatically configures a large number of default editors; but for custom
    types, we have to explicitly instantiate new editors for every web request. This
    is done in the controller in a method that is annotated with `@InitBinder`. This
    annotation is scanned and all the detected methods should have a signature of
    accepting `WebDataBinder` as an argument. Among other things, `WebDataBinder`
    provides us with an ability to register as many custom editors as we require for
    the controller methods to be bound properly.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to know that `PropertyEditor` is not thread-safe! For this
    reason, we have to create a new instance of our custom editors for every web request
    and register them with `WebDataBinder`.
  prefs: []
  type: TYPE_NORMAL
- en: In case a new `PropertyEditor` is needed, it is best to create one by extending
    `PropertyEditorSupport` and overriding the desired methods with custom implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring custom type formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mostly because of its statefulness and lack of thread safety, since version
    3, Spring has added a `Formatter` interface as a replacement for `PropertyEditor`.
    The formatters are intended to provide a similar functionality but in a completely
    thread-safe manner and focusing on a very specific task of parsing a String in
    an object type and converting an object to its String representation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that for our application, we would like to have a formatter that
    would take the ISBN number of a book in a String form and convert it to a book
    entity object. This way, we can define the controller request methods with a `Book`
    argument when the request URL signature only contains an ISBN number or a database
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's create a new package called `formatters` in the `src/main/java/com/example/bookpub`
    directory from the root of our project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create the `Formatter` implementation called `BookFormatter`
    in our newly created package directory from the root of our project with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our formatter, we will add it to the registry by overriding
    an `addFormatters(FormatterRegistry registry)` method in the `WebConfiguration`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add a new request method to our `BookController` class located
    in the `src/main/java/com/example/bookpub/controllers` directory from the root
    of our project that will display the reviewers for a given ISBN of a book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just so we can have some data to play with, let''s manually (for now) populate
    our database with some test data by adding two more autowired repositories to
    the `StartupRunner` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is destined for the `run(...)` method of `StartupRunner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's open `http://localhost:8080/books/978-1-78528-415-1/reviewers` in the
    browser and you should be able to see the following results:![](img/1e5987be-68ce-4e93-b772-67b5b6403036.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The formatter facility is aims to provide a similar functionality to `PropertyEditors`.
    By registering our formatter with `FormatterRegistry` in the overridden `addFormatters`
    method, we are instructing Spring to use our formatter to translate a textual
    representation of our book into an entity object and back. As formatters are stateless,
    we don't need to do the registration in our controller for every call; we have
    to do it only once and this will ensure Spring uses it for every web request.
  prefs: []
  type: TYPE_NORMAL
- en: It is also good to remember that if you want to define a conversion of a common
    type, such as String or Boolean, for example trimming text, it is best to do this
    via `PropertyEditors` in controller's `InitBinder` because such a change is probably
    not globally desired and is only needed for a particular functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that we also autowired `BookRepository` to a `WebConfiguration`
    class, as this was needed to create `BookFormatter`. This is one of the cool parts
    about Spring --it lets us combine the configuration classes and make them dependent
    on the other beans at the same time. As we indicated that in order for a `WebConfiguration`
    class to be created we need `BookRepository`, Spring ensured that `BookRepository`
    will be created first and then automatically injected as a dependency during the
    creation of the `WebConfiguration` class. After `WebConfiguration` is instantiated,
    it is processed for configuration instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the added functionalities should already be familiar as we covered
    them in our previous recipes. We will explore how to automatically populate databases
    with schemas and data in [Chapter 5](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml),
    *Application Testing*, in detail, where we will also talk about application testing.
  prefs: []
  type: TYPE_NORMAL
