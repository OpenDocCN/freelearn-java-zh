- en: Chapter 8. Organizing Build Logic and Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：组织构建逻辑和插件
- en: Plugins are one of the major building blocks of Gradle, which we have not discussed
    much until now. You have seen different standard plugins such as Java, Eclipse,
    Scala, and so on, which comes with a set of defined tasks. Developers just include
    the plugin, configure the required tasks, and leverage the functionalities. In
    this chapter, we will get an overview of what a plugin is, how you can group tasks
    to a plugin, how you can extract the plugin logic from a build file to `buildSrc`,
    and also how to create a standalone plugin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是 Gradle 的主要构建块之一，我们之前并没有过多讨论。你已经看到了不同的标准插件，如 Java、Eclipse、Scala 等，它们都附带了一系列定义好的任务。开发者只需包含插件，配置所需的任务，就可以利用其功能。在本章中，我们将概述插件是什么，如何将任务分组到插件中，如何将插件逻辑从构建文件提取到
    `buildSrc`，以及如何创建独立的插件。
- en: Extracting build logic to buildSrc
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将构建逻辑提取到 `buildSrc`
- en: Plugins are nothing but the group of tasks with specific orders and default
    configurations, which are created to provide a certain functionality. For example,
    `java` plugin contains tasks that provide the functionality to build a Java project,
    `scala` plugin contains tasks to build Scala projects, and so on. Although Gradle
    provides many standard plugins, you can also find different third-party plugins
    to fulfil the project's need. There might always be a case when you are not able
    to find the desired functionality with the existing plugins and would like to
    create a new one for your custom requirement. We will see the different ways in
    which a developer can create a plugin and use it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 插件不过是按照特定顺序和默认配置创建的任务组，旨在提供某种功能。例如，`java` 插件包含提供构建 Java 项目功能的任务，`scala` 插件包含构建
    Scala 项目的任务，等等。尽管 Gradle 提供了许多标准插件，但你也可以找到不同的第三方插件来满足项目的需求。可能总会有这样的情况，即你无法使用现有的插件找到所需的功能，并希望为你的定制需求创建一个新的插件。我们将探讨开发者可以创建和使用插件的不同方式。
- en: 'The very first plugin that a user can create is in the build file itself. The
    following is the sample code of a plugin, which a developer can write in `build.gradle`
    and use it:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以创建的第一个插件就是构建文件本身。以下是一个插件的示例代码，开发者可以在 `build.gradle` 中编写并使用它：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have created a plugin in the build file itself. This is the beauty
    of Gradle script. You can also write a class in the Gradle file. To create a custom
    plugin, you need to create a Groovy class that implements the `Plugin` interface.
    You can write a plugin even in Java or any other JVN language. Since Gradle build
    scripts are written in Groovy, we have used Groovy to write the plugin implementation.
    All the tasks that you want to implement, you need to define inside the `apply`
    method. We have defined two tasks, `task1` and `task2`. Also, we have defined
    the life cycle as a relationship between the two tasks. If a developer calls `task1`,
    only `task1` will be executed. If you execute `task2`, both `task1` and `task2`
    will get executed. Try to execute the following command:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在构建文件本身中创建了一个插件。这是 Gradle 脚本之美。你还可以在 Gradle 文件中编写一个类。要创建自定义插件，你需要创建一个实现
    `Plugin` 接口的 Groovy 类。你甚至可以用 Java 或任何其他 JVN 语言编写插件。由于 Gradle 构建脚本是用 Groovy 编写的，所以我们使用了
    Groovy 来编写插件实现。你想要实现的所有任务，都需要在 `apply` 方法中定义。我们定义了两个任务，`task1` 和 `task2`。我们还定义了生命周期作为两个任务之间的关系。如果开发者调用
    `task1`，只有 `task1` 将被执行。如果你执行 `task2`，`task1` 和 `task2` 都将执行。尝试执行以下命令：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To use a plugin in the build file, you always need to use `apply plugin:<plugin
    name/plugin` class (if a plugin is implemented in the same script or in the `buildSrc`
    directory).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要在构建文件中使用插件，你始终需要使用 `apply plugin:<plugin name/plugin` class（如果插件是在同一脚本或 `buildSrc`
    目录中实现的）。
- en: 'This is one of the simple ways in which a developer can define a custom plugin.
    However, if we follow the design principles, it is not a good practice to mix
    the build logic and custom logic into the same file. It would be difficult to
    maintain the code and it might also increase the maintenance efforts. We will
    always recommend you to write plugin code separate from the build logic. To achieve
    this, Gradle provides two different ways as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种开发者定义自定义插件简单的方式。然而，如果我们遵循设计原则，将构建逻辑和自定义逻辑混合到同一个文件中并不是一个好的实践。这将很难维护代码，也可能增加维护工作量。我们始终建议你将插件代码与构建逻辑分开编写。为了实现这一点，Gradle
    提供了两种不同的方式，如下所示：
- en: Extract plugin code to `buildSrc`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将插件代码提取到 `buildSrc`
- en: Independent plugin
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立插件
- en: 'To extract plugin code to `buildSrc`, Gradle recommends you to create a `buildSrc`
    directory inside the project directory and keep the plugin code there. The following
    is the folder hierarchy for the same:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将插件代码提取到`buildSrc`，Gradle建议您在项目目录内创建一个`buildSrc`目录，并将插件代码保存在那里。以下是该目录结构的示例：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we have created a separate `buildSrc` directory; inside that, we kept
    the plugin code in the `CustomPlugin.groovy` file. Move the preceding Groovy class
    from the `build.gradle` file into this file. Include the package statement at
    the top. You also need to import the `org.gradle.api.*`. Your `CustomPlugin.groovy`
    file will look as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经创建了一个单独的`buildSrc`目录；在该目录内，我们将插件代码保存在`CustomPlugin.groovy`文件中。将前面的Groovy类从`build.gradle`文件移动到这个文件中。在顶部包含包声明。您还需要导入`org.gradle.api.*`。您的`CustomPlugin.groovy`文件将如下所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `build.gradle` file contents will be as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.gradle`文件的内容将如下所示：'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You just need to import the package and add the apply `plugin` statement. All
    the background work of compiling the class and including the class into classpath
    at the runtime, will be performed by Gradle. Now, try to execute the following
    command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需导入包并添加`apply plugin`语句。所有编译类和将类包含到运行时类路径中的后台工作将由Gradle执行。现在，尝试执行以下命令：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, you can see that Gradle performed the compile and build task for your
    custom plugin code, and now you just need to execute the tasks that are part of
    your custom plugin. Gradle also allows you to configure your custom plugin in
    a build file. You can set a dependency between the tasks or add more functionality
    to the tasks in the build file itself, rather than updating your plugin code again
    and again. If you want to add some more features for `task1`, you can do it as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，您可以看到Gradle为您自定义的插件代码执行了编译和构建任务，现在您只需执行自定义插件中的任务。Gradle还允许您在构建文件中配置自定义插件。您可以在任务之间设置依赖关系或向构建文件中的任务添加更多功能，而不是反复更新插件代码。如果您想为`task1`添加更多功能，可以按照以下方式操作：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if you try to execute `task1`, it will append the preceding statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您尝试执行`task1`，它将附加前面的语句。
- en: In this way, you can separate the build logic from the `build.gradle` file to
    a separate class file under `buildSrc directory`. If you have a multi-project
    build, the plugin defined in the root project `buildSrc` can be reused by all
    the subprojects' build files. You do not need to define a separate plugin for
    each sub-projects. This process has still one limitation. It does not allow you
    to use this plugin for other projects. Since it is tightly coupled with the current
    project, you can use this plugin only with the same project or the sub-projects
    defined in the root project. To overcome this, you can plug out the plugin code
    into a standalone plugin and package it into a JAR file, which you can publish
    to a repository so that it can be reused by any projects. In the next section,
    we will discuss the standalone plugin.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，您可以将构建逻辑从`build.gradle`文件分离出来，将其放置在`buildSrc`目录下的一个单独的类文件中。如果您有一个多项目构建，根项目`buildSrc`中定义的插件可以被所有子项目的构建文件重用。您不需要为每个子项目定义一个单独的插件。这个过程仍然有一个限制。它不允许您将此插件用于其他项目。由于它与当前项目紧密耦合，您只能使用此插件与同一项目或根项目中定义的子项目。为了克服这一点，您可以将插件代码提取出来，创建一个独立的插件，并将其打包成一个JAR文件，这样您就可以将其发布到仓库中，以便任何项目都可以重用它。在下一节中，我们将讨论独立插件。
- en: The first plugin
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个插件
- en: 'To make the plugin reusable for all the other projects, Gradle allows you to
    separate the plugin code and package it in a JAR file. You can include this JAR
    file in any projects in which you want to reuse this functionality. You can create
    the standalone project in Java or Groovy. We will proceed with Groovy. You can
    use any editor (Eclipse, NetBeans, or Idea) to create a plugin. Since our main
    purpose is to show you how to create a standalone plugin, we will not go into
    the details of the editor. We will use a simple text editor. To proceed with the
    standalone plugin, separate the above `buildSrc` code into an independent directory.
    You can name it `CustomPlugin`. So, the directory structure will be as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使插件对所有其他项目可重用，Gradle允许您将插件代码分离出来，并将其打包成一个JAR文件。您可以将此JAR文件包含在任何您想要重用此功能的项目中。您可以使用Java或Groovy创建独立项目。我们将使用Groovy。您可以使用任何编辑器（Eclipse、NetBeans或Idea）来创建插件。由于我们的主要目的是向您展示如何创建独立插件，我们不会深入编辑器的细节。我们将使用一个简单的文本编辑器。要继续创建独立插件，将上述`buildSrc`代码分离到一个独立的目录中。您可以将其命名为`CustomPlugin`。因此，目录结构将如下所示：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might be surprised to know why we are creating a `build.gradle` file here.
    With this `build.gradle`, we will package the plugin code into a jar file. Now,
    the question arises as to how you will include this plugin into other build files.
    You need a **plugin ID** for this plugin. To add a plugin ID to your plugin, you
    need to create a property file inside the `src/main/resources/META-INF/gradle-plugins`
    directory. The name of the properties file will be your plugin ID. Here, we will
    add the `customplugin.properties` file in the above directory. The content of
    this file will be as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地想知道为什么在这里创建 `build.gradle` 文件。通过这个 `build.gradle` 文件，我们将插件代码打包成一个 jar
    文件。现在，问题出现了，那就是你将如何将这个插件包含到其他构建文件中。你需要为这个插件提供一个 **插件 ID**。为了给插件添加一个插件 ID，你需要在
    `src/main/resources/META-INF/gradle-plugins` 目录中创建一个属性文件。属性文件的名字将是你的插件 ID。在这里，我们将在上述目录中添加
    `customplugin.properties` 文件。这个文件的内容如下：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To compile Groovy code, you need to include the preceding two statements in
    compile configurations. Since we are using a plain vanilla Groovy class here,
    we have not added any other dependency JARs. If your plugin code has a dependency
    on any other third-party JARs, you can include them in the dependency and configure
    the respective repositories.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译 Groovy 代码，你需要在编译配置中包含前面的两个语句。由于我们在这里使用的是一个普通的 Groovy 类，所以我们没有添加任何其他的依赖 JAR
    文件。如果你的插件代码依赖于任何其他的第三方 JAR 文件，你可以在依赖中包含它们，并配置相应的仓库。
- en: 'Now, we will build the plugin as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按照以下方式构建插件：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can find the JAR file inside `<project>/build/libs/CustomPlugin-1.0.jar`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `<project>/build/libs/CustomPlugin-1.0.jar` 中找到这个 JAR 文件。
- en: You can publish this plugin JAR to your organization's internal repositories
    so that any other projects can directly download it from there and use it. Now,
    we will create another project and will refer to this plugin JAR into that project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个插件 JAR 发布到组织的内部仓库中，这样其他项目可以直接从那里下载并使用它。现在，我们将创建另一个项目，并将这个插件 JAR 引用到那个项目中。
- en: Create a new directory, `SampleProject`, and add `build.gradle` to the project.
    Now, a question arises as to how will your `build.gradle` refer to `SamplePlugin`.
    For this, you need to mention the location of the `SamplePlugin` JAR in `buildscript
    closure` and add dependency to this JAR in the `dependencies` closure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的目录，`SampleProject`，并将 `build.gradle` 文件添加到项目中。现在，一个问题出现了，那就是你的 `build.gradle`
    文件将如何引用 `SamplePlugin`。为此，你需要在 `buildscript closure` 中提及 `SamplePlugin` JAR 文件的位置，并在
    `dependencies closure` 中添加对这个 JAR 文件的依赖。
- en: 'The content of your `build.gradle` will be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `build.gradle` 文件内容如下：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are using a `flat file repository`, thus, referring to the custom plugin
    JAR using the `flatDir` configuration. We recommend you to use the organization's
    local repository; thus, it can be centrally accessed by any of the organization's
    projects. In the dependencies closure, we are referring to the `CustomPlugin`
    JAR file. This is the prerequisite to use any plugin. Finally, we are adding the
    `apply plugin` statement and mentioning the plugin name in single quotes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是 `flat file repository`，因此使用 `flatDir` 配置来引用自定义插件 JAR 文件。我们建议你使用组织的本地仓库；这样，组织的任何项目都可以集中访问。在
    `dependencies closure` 中，我们引用了 `CustomPlugin` JAR 文件。这是使用任何插件的前提。最后，我们添加了 `apply
    plugin` 语句，并用单引号提到了插件名称。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The plugin name is the name of the property file you create in the `src/main/resources/META-INF/gradle-plugins`
    directory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 插件名称是你创建在 `src/main/resources/META-INF/gradle-plugins` 目录中的属性文件的名称。
- en: 'Now, you can execute the build file using the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令执行构建文件：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Configuring plugins
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置插件
- en: 'So far, we have seen how to create a standalone custom plugin and include it
    in another project build file. Gradle also allows you to configure plugin properties
    and customize them as per your project''s need. You have already learned how you
    can customize the source code location and test code location in a `java` plugin.
    We will see an example of how you can replicate the same behavior in your custom
    plugin. To define plugin properties, you need to create one additional `extension`
    class and register the class into your `plugin` class. Let''s say we want to add
    the `location` property to the plugin. Create the `CustomPluginExtension.groovy`
    class as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何创建一个独立的自定义插件并将其包含在另一个项目的构建文件中。Gradle还允许你配置插件属性并根据项目需求进行自定义。你已经学习了如何在一个`java`插件中自定义源代码位置和测试代码位置。我们将看到一个示例，展示你如何在自定义插件中复制相同的行为。要定义插件属性，你需要创建一个额外的`extension`类并将该类注册到你的`plugin`类中。假设我们想向插件添加`location`属性，创建`CustomPluginExtension.groovy`类如下：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, register this class to your `plugin` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此类注册到你的`plugin`类中：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, build the plugin again so that your changes are part of the latest plugin
    JAR file and then try to execute `build.gradle` of `SampleProject`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次构建插件，以确保你的更改成为最新插件JAR文件的一部分，然后尝试执行`SampleProject`的`build.gradle`：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, you can see the default value on the command line output. If you want
    to change this field to some other value, add `customExt closure` to your `SampleProject`
    `build.gradle` file with a different value configured for the location:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到命令行输出的默认值。如果你想将此字段更改为其他值，请将`customExt closure`添加到你的`SampleProject`
    `build.gradle`文件中，并为位置配置不同的值：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now try to execute `task1` again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次尝试执行`task1`：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, you can observe the update value for the location attribute.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以观察到位置属性的更新值。
- en: Summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed one of Gradle's main building blocks, plugins.
    A plugin helps to organize and modularize the functionality and also helps to
    package a set of related tasks and configurations. We also discussed the different
    ways of creating custom plugins, from writing the plugin code in the build file
    itself to creating a standalone plugin JAR file and reusing it in different projects.
    In the last section, we also covered how you can configure the plugin's existing
    properties and customize them as per your project's requirement.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Gradle的主要构建块之一，插件。插件有助于组织和模块化功能，并有助于打包一系列相关的任务和配置。我们还讨论了创建自定义插件的不同方法，从在构建文件中编写插件代码到创建独立的插件JAR文件并在不同的项目中重用它。在最后一节中，我们还介绍了如何配置插件现有的属性并根据项目需求进行自定义。
- en: Before concluding this book in the next chapter, we will be discussing how you
    can build Groovy and Scala projects with the help of Gradle. Also, as this is
    a mobile age, where all the traditional software or web applications are now moving
    to apps, we will also be discussing building Android projects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章结束本书之前，我们将讨论如何借助 Gradle 构建Groovy和Scala项目。此外，鉴于这是一个移动时代，所有传统的软件或Web应用程序现在都在转向应用，我们还将讨论构建Android项目。
