- en: Chapter 8. Organizing Build Logic and Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are one of the major building blocks of Gradle, which we have not discussed
    much until now. You have seen different standard plugins such as Java, Eclipse,
    Scala, and so on, which comes with a set of defined tasks. Developers just include
    the plugin, configure the required tasks, and leverage the functionalities. In
    this chapter, we will get an overview of what a plugin is, how you can group tasks
    to a plugin, how you can extract the plugin logic from a build file to `buildSrc`,
    and also how to create a standalone plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting build logic to buildSrc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are nothing but the group of tasks with specific orders and default
    configurations, which are created to provide a certain functionality. For example,
    `java` plugin contains tasks that provide the functionality to build a Java project,
    `scala` plugin contains tasks to build Scala projects, and so on. Although Gradle
    provides many standard plugins, you can also find different third-party plugins
    to fulfil the project's need. There might always be a case when you are not able
    to find the desired functionality with the existing plugins and would like to
    create a new one for your custom requirement. We will see the different ways in
    which a developer can create a plugin and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very first plugin that a user can create is in the build file itself. The
    following is the sample code of a plugin, which a developer can write in `build.gradle`
    and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a plugin in the build file itself. This is the beauty
    of Gradle script. You can also write a class in the Gradle file. To create a custom
    plugin, you need to create a Groovy class that implements the `Plugin` interface.
    You can write a plugin even in Java or any other JVN language. Since Gradle build
    scripts are written in Groovy, we have used Groovy to write the plugin implementation.
    All the tasks that you want to implement, you need to define inside the `apply`
    method. We have defined two tasks, `task1` and `task2`. Also, we have defined
    the life cycle as a relationship between the two tasks. If a developer calls `task1`,
    only `task1` will be executed. If you execute `task2`, both `task1` and `task2`
    will get executed. Try to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use a plugin in the build file, you always need to use `apply plugin:<plugin
    name/plugin` class (if a plugin is implemented in the same script or in the `buildSrc`
    directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the simple ways in which a developer can define a custom plugin.
    However, if we follow the design principles, it is not a good practice to mix
    the build logic and custom logic into the same file. It would be difficult to
    maintain the code and it might also increase the maintenance efforts. We will
    always recommend you to write plugin code separate from the build logic. To achieve
    this, Gradle provides two different ways as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract plugin code to `buildSrc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To extract plugin code to `buildSrc`, Gradle recommends you to create a `buildSrc`
    directory inside the project directory and keep the plugin code there. The following
    is the folder hierarchy for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a separate `buildSrc` directory; inside that, we kept
    the plugin code in the `CustomPlugin.groovy` file. Move the preceding Groovy class
    from the `build.gradle` file into this file. Include the package statement at
    the top. You also need to import the `org.gradle.api.*`. Your `CustomPlugin.groovy`
    file will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `build.gradle` file contents will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You just need to import the package and add the apply `plugin` statement. All
    the background work of compiling the class and including the class into classpath
    at the runtime, will be performed by Gradle. Now, try to execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that Gradle performed the compile and build task for your
    custom plugin code, and now you just need to execute the tasks that are part of
    your custom plugin. Gradle also allows you to configure your custom plugin in
    a build file. You can set a dependency between the tasks or add more functionality
    to the tasks in the build file itself, rather than updating your plugin code again
    and again. If you want to add some more features for `task1`, you can do it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you try to execute `task1`, it will append the preceding statement.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can separate the build logic from the `build.gradle` file to
    a separate class file under `buildSrc directory`. If you have a multi-project
    build, the plugin defined in the root project `buildSrc` can be reused by all
    the subprojects' build files. You do not need to define a separate plugin for
    each sub-projects. This process has still one limitation. It does not allow you
    to use this plugin for other projects. Since it is tightly coupled with the current
    project, you can use this plugin only with the same project or the sub-projects
    defined in the root project. To overcome this, you can plug out the plugin code
    into a standalone plugin and package it into a JAR file, which you can publish
    to a repository so that it can be reused by any projects. In the next section,
    we will discuss the standalone plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The first plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the plugin reusable for all the other projects, Gradle allows you to
    separate the plugin code and package it in a JAR file. You can include this JAR
    file in any projects in which you want to reuse this functionality. You can create
    the standalone project in Java or Groovy. We will proceed with Groovy. You can
    use any editor (Eclipse, NetBeans, or Idea) to create a plugin. Since our main
    purpose is to show you how to create a standalone plugin, we will not go into
    the details of the editor. We will use a simple text editor. To proceed with the
    standalone plugin, separate the above `buildSrc` code into an independent directory.
    You can name it `CustomPlugin`. So, the directory structure will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be surprised to know why we are creating a `build.gradle` file here.
    With this `build.gradle`, we will package the plugin code into a jar file. Now,
    the question arises as to how you will include this plugin into other build files.
    You need a **plugin ID** for this plugin. To add a plugin ID to your plugin, you
    need to create a property file inside the `src/main/resources/META-INF/gradle-plugins`
    directory. The name of the properties file will be your plugin ID. Here, we will
    add the `customplugin.properties` file in the above directory. The content of
    this file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To compile Groovy code, you need to include the preceding two statements in
    compile configurations. Since we are using a plain vanilla Groovy class here,
    we have not added any other dependency JARs. If your plugin code has a dependency
    on any other third-party JARs, you can include them in the dependency and configure
    the respective repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will build the plugin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can find the JAR file inside `<project>/build/libs/CustomPlugin-1.0.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: You can publish this plugin JAR to your organization's internal repositories
    so that any other projects can directly download it from there and use it. Now,
    we will create another project and will refer to this plugin JAR into that project.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory, `SampleProject`, and add `build.gradle` to the project.
    Now, a question arises as to how will your `build.gradle` refer to `SamplePlugin`.
    For this, you need to mention the location of the `SamplePlugin` JAR in `buildscript
    closure` and add dependency to this JAR in the `dependencies` closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of your `build.gradle` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a `flat file repository`, thus, referring to the custom plugin
    JAR using the `flatDir` configuration. We recommend you to use the organization's
    local repository; thus, it can be centrally accessed by any of the organization's
    projects. In the dependencies closure, we are referring to the `CustomPlugin`
    JAR file. This is the prerequisite to use any plugin. Finally, we are adding the
    `apply plugin` statement and mentioning the plugin name in single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The plugin name is the name of the property file you create in the `src/main/resources/META-INF/gradle-plugins`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can execute the build file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Configuring plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how to create a standalone custom plugin and include it
    in another project build file. Gradle also allows you to configure plugin properties
    and customize them as per your project''s need. You have already learned how you
    can customize the source code location and test code location in a `java` plugin.
    We will see an example of how you can replicate the same behavior in your custom
    plugin. To define plugin properties, you need to create one additional `extension`
    class and register the class into your `plugin` class. Let''s say we want to add
    the `location` property to the plugin. Create the `CustomPluginExtension.groovy`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, register this class to your `plugin` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build the plugin again so that your changes are part of the latest plugin
    JAR file and then try to execute `build.gradle` of `SampleProject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the default value on the command line output. If you want
    to change this field to some other value, add `customExt closure` to your `SampleProject`
    `build.gradle` file with a different value configured for the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try to execute `task1` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can observe the update value for the location attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed one of Gradle's main building blocks, plugins.
    A plugin helps to organize and modularize the functionality and also helps to
    package a set of related tasks and configurations. We also discussed the different
    ways of creating custom plugins, from writing the plugin code in the build file
    itself to creating a standalone plugin JAR file and reusing it in different projects.
    In the last section, we also covered how you can configure the plugin's existing
    properties and customize them as per your project's requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Before concluding this book in the next chapter, we will be discussing how you
    can build Groovy and Scala projects with the help of Gradle. Also, as this is
    a mobile age, where all the traditional software or web applications are now moving
    to apps, we will also be discussing building Android projects.
  prefs: []
  type: TYPE_NORMAL
