<html><head></head><body>
      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Money – The Quote Manager Application</h1>
            
         </header>
         
         
         <article>
            
            
            <p class="mce-root">Before working on evaluating and enhancing the performance of your application, you
               need to indeed have an application. In this part, we will create a small application
               that we will use to illustrate every part of the book. This chapter doesn't intend
               to explain all the steps required to create a Java EE application. It will give you
               the overall steps and ensure that the references to the steps will be obvious later.
            </p>
            
            <p>The use case of this application will be a microservice that provides a set of web
               services to manage stocks and shares. <span>This chapter will, therefore, introduce you to the application environment</span>:
            </p>
            
            <ul>
               
               <li>Application code structure</li>
               
               <li>Database setup</li>
               
               <li>Data persistence</li>
               
               <li>Exposing data over HTTP</li>
               
               <li>Deploying your application</li>
               
            </ul>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Setting up the environment</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Before starting with writing code, make sure that you have an environment ready to
               work with Java EE. We need a <strong>Java Virtual Machine 8</strong> (<strong>JVM 8</strong>) and, more particularly, the <strong>Java Development Kit</strong> <strong>8</strong> (<strong>JDK</strong> <strong>8</strong>). As a quick reminder, Java EE version <em>V</em> is based on <strong>Java Standalone Edition</strong> (<strong>Java SE</strong>) version <em>V</em> as well. You can download the JDK on the Oracle website (<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>).
            </p>
            
            <div class="packt_infobox">Alternatively, you can download the OpenJDK version of the JDK on the OpenJDK project
               website (<a href="http://openjdk.java.net/install/">http://openjdk.java.net/install/</a>), but I recommend that you use the Oracle version. We will discuss this later in
               the book.
            </div>
            
            <p>Don't forget to accept the license agreement and select the right distribution for
               your operating system (Windows, Linux, or macOS).
            </p>
            
            <p>Now that we have a JDK, we need a tool to build our application and convert it into
               a format that we will be able to deploy in our Java EE server. This book will use
               Apache Maven (<a href="https://maven.apache.org/">https://maven.apache.org/</a>) <span>to build the application. It can be downloaded on the Apache Maven download page (<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>). We need the</span> binary d<span>istribution; Linux users have to select the <kbd>tar.gz</kbd> format while Windows users have to select the</span> <kbd>.zip</kbd> <span>archive.</span></p>
            
            <p>At this point, we have everything we need to create our application. You will probably
               want to have an <strong>Integrated Development Environme</strong><strong>nt</strong> (<strong>IDE</strong>), such as NetBeans (<a href="https://netbeans.org/">https://netbeans.org/</a>), Eclipse (<a href="https://eclipse.org/ide/">https://eclipse.org/ide/</a>), or Intellij Idea (<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a>). Since this book is more about performance than development, we won't go into much
               detail about IDEs. If you need one, just select the one you are the most familiar
               with.
            </p>
            
            <p>To ensure that the environment is ready, we will set variables to define where to
               find the software without having to use the full path to the binary or script each
               time. <kbd>JAVA_HOME</kbd> will point to the folder you extracted from the JDK, and <kbd>MAVEN_HOME</kbd> will point to the folder you extracted from the Apache Maven archive. Here is an
               example for Linux (replace <kbd>export</kbd> with <kbd>set</kbd> for a DOS shell):
            </p>
            <pre><strong>$ export JAVA_HOME=/home/developer/jdk1.8.0_144</strong><br/><strong>$ export MAVEN_HOME=/home/developer/apache-maven-3.5.0</strong></pre>
            <p>Now, we need to ensure that the JDK and Maven tools are available. For this, we add
               them to <kbd>PATH</kbd> on Linux and <kbd>Path</kbd> on Windows:
            </p>
            <pre># On Linux<br/><strong>$ export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH</strong><br/><br/># On Windows<br/><strong>$ set Path=%JAVA_HOME%\bin;%MAVEN_HOME%\bin;%Path%</strong></pre>
            <p>You can validate your setup by executing the following command:</p>
            <pre><strong>$ mvn -version</strong><br/><strong>Maven home: /home/developer/apache-maven-3.5.0</strong><br/><strong>Java version: 1.8.0_144, vendor: Oracle Corporation</strong><br/><strong>Java home: /home/developer/jdk1.8.0_144/jre</strong><br/><strong>Default locale: fr_FR, platform encoding: UTF-8</strong><br/><strong>OS name: "linux", version: "4.10.0-32-generic", arch: "amd64", family: "unix"</strong></pre>
            <p>To run a Java EE application, we also need a container, such as GlassFish, WildFly,
               WebSphere Liberty Profile, or Apache TomEE. The deployment being specific and Java
               EE 8 being very recent, we will use GlassFish in this book.
            </p>
            
            <p>Finally, to get everything ready, we will use a database. We will use MySQL as a very
               common case, but any other relational database will work as well. You can download
               MySQL from <a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a>, but most Linux distributions will have a package ready to install. For instance,
               on Ubuntu you can just execute the following line:
            </p>
            <pre class="code">sudo apt install mysql-server</pre>
            
            
            </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The application architecture</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Our application will import some stock quotations daily; it will then expose them
               and allow you to update them through a web service.
            </p>
            
            <p>To implement it, we will use a standard Java EE architecture:</p>
            
            <ul>
               
               <li>The persistence layer will use JPA 2.2 and store the data in a MySQL database.</li>
               
               <li>A service layer will implement the business logic and orchestrate the persistence
                  layer. It will rely on the following:
                  
                  <ul>
                     
                     <li><strong>Java Transaction API</strong> (<span><strong>JTA</strong>)</span> 1.2 for transactionality
                     </li>
                     
                     <li><strong>Context and Dependency Injection</strong> 2.0 (<strong>CDI</strong>) for <strong>Inversion of Control</strong> (<strong>IoC</strong>)
                     </li>
                     
                     <li>Bean Validation 2.0 for validations</li>
                     
                  </ul>
                  
               </li>
               
               <li>A front layer will expose a part of the service layer through HTTP. It will rely on
                  the following:
                  
                  <ul>
                     
                     <li>JAX-RS 2.1 for stateless endpoints</li>
                     
                     <li>WebSocket 1.1 for stateful communications</li>
                     
                     <li>JSON-B 1.0 for marshalling/unmarshalling</li>
                     
                  </ul>
                  
               </li>
               
            </ul>
            
            <p>Here is a picture summarizing this structure:</p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="115" src="assets/ae41dfe2-23c1-40d1-8b26-2005e62ebb7e.png" width="417"/></div>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Application project highlights</h1>
            
         </header>
         
         
         <article>
            
            
            <p>To be able to create and run this application, we will need to set up a build tool.
               For this book, it will be Apache Maven; however, Gradle, Ant, or any other alternative
               will work perfectly as well. We will then identify some key parts of the application
               code and, finally, we will insert some data to ensure that our application is usable
               before investigating its performance.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The build</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The only dependency Java EE requires is the Java EE API:</p>
            <pre><span>&lt;</span><span>dependency</span><span>&gt;</span><br/>  <span>&lt;</span><span>groupId</span><span>&gt;</span>javax<span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>  <span>&lt;</span><span>artifactId</span><span>&gt;</span>javaee-api<span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>  <span>&lt;</span><span>version</span><span>&gt;</span>${javaee-api.version}<span>&lt;/</span><span>version</span><span>&gt; &lt;!-- 8.0 --&gt;</span><br/>  <span>&lt;</span><span>scope</span><span>&gt;</span>provided<span>&lt;/</span><span>scope</span><span>&gt;</span><br/><span>&lt;/</span><span>dependency</span><span>&gt;</span></pre>
            <div class="packt_tip">If you prefer, you can indeed register all the individual specifications, but it will
               require more work to maintain the list with Java EE upgrades. For this reason, the
               bundle is often preferred.
            </div>
            
            <p>Here, the point is to ensure that the API is provided, which means it will not be
               packaged in the deliverable and will inherit from the server API. The server providing
               the services associated with the API also provides the API with the right supported
               version and the right defaults matching the built-in implementations.
            </p>
            
            <p>Since Java EE 6, there are two main flavors of Java EE: the web profile and the full
               profile. The web profile is a light version, with only half the specifications compared
               with the full profile, <span>more or less</span>. The web profile supports only web applications and, therefore, <kbd>war</kbd> files. Most of this book will work with a web profile server, so we will package
               our application as <kbd>war</kbd>:
            </p>
            <pre>&lt;packaging&gt;war&lt;/packaging&gt;</pre>
            <p>Since we need Java 8, don't forget to configure the Java source and target version
               in the build. It can be done in different ways, but configuring <kbd>maven-compiler-plugin</kbd> as follows is an efficient one:
            </p>
            <pre><span>&lt;</span><span>plugin</span><span>&gt;</span><br/>  <span>&lt;</span><span>groupId</span><span>&gt;</span>org.apache.maven.plugins<span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>  <span>&lt;</span><span>artifactId</span><span>&gt;</span>maven-compiler-plugin<span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>  <span>&lt;</span><span>version</span><span>&gt;</span>3.6.1<span>&lt;/</span><span>version</span><span>&gt;</span><br/>  <span>&lt;</span><span>configuration</span><span>&gt;</span><br/>    <span>&lt;</span><span>source</span><span>&gt;</span>1.8<span>&lt;/</span><span>source</span><span>&gt;</span><br/>    <span>&lt;</span><span>target</span><span>&gt;</span>1.8<span>&lt;/</span><span>target</span><span>&gt;</span><br/>  <span>&lt;/</span><span>configuration</span><span>&gt;</span><br/><span>&lt;/</span><span>plugin</span><span>&gt;<br/></span></pre>
            
            
            </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The persistence layer</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Our data model will be simple: a <em>quote</em> will be linked to a <em>customer</em>. This means that a <em>customer</em> can see a set of <em>quotes</em>, and <em>quotes</em> can be seen by a set of customers. In terms of use cases, we want to be able to monetize
               our API and make the customers pay to access some quote prices. To do so, we will
               need a sort of whitelist of quotes per customer.
            </p>
            
            <p><span>JPA uses a descriptor called</span> <kbd>persistence.xml</kbd>, placed in the META-INF repository of resources (or WEB-INF), which defines how <kbd>EntityManager</kbd>, which is a class that allows the manipulation of our model, will be instantiated.
               Here is what it looks like for our application:
            </p>
            <pre><span>&lt;</span><span>persistence </span><span>xmlns=</span><span>"http://xmlns.jcp.org/xml/ns/persistence"<br/></span><span>             </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>             </span><span>xsi</span><span>:schemaLocation=</span><span>"<br/></span><span>             http://xmlns.jcp.org/xml/ns/persistence<br/></span><span>              http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd"<br/></span><span>             </span><span>version=</span><span>"2.2"</span><span>&gt;</span><br/>  <span>&lt;</span><span>persistence-unit </span><span>name=</span><span>"quote"</span><span>&gt;</span><br/>    <span>&lt;</span><span>class</span><span>&gt;</span>com.github.rmannibucau.quote.manager.model.Customer<span>&lt;/</span><span>class</span><span>&gt;</span><br/>    <span>&lt;</span><span>class</span><span>&gt;</span>com.github.rmannibucau.quote.manager.model.Quote<span>&lt;/</span><span>class</span><span>&gt;</span><br/>    <span>&lt;</span><span>exclude-unlisted-classes</span><span>&gt;</span>true<span>&lt;/</span><span>exclude-unlisted-classes</span><span>&gt;</span><br/>    <span>&lt;</span><span>properties</span><span>&gt;</span><br/>      <span>&lt;</span><span>property </span><span>name=</span><span>"avax.persistence.schema<br/>      -generation.database.action" </span><span>value=</span><span>"create"</span><span>/&gt;</span><br/>    <span>&lt;/</span><span>properties</span><span>&gt;</span><br/>  <span>&lt;/</span><span>persistence-unit</span><span>&gt;</span><br/><span>&lt;/</span><span>persistence</span><span>&gt;</span></pre>
            <p>The link between the database and the Java code is done through entities. An entity
               is a <strong>plain old java object</strong> (<strong>POJO</strong>) that is decorated with the <kbd>javax.persistence</kbd> annotations. They mainly define the mapping between the database and the Java model.
               For instance, <kbd>@Id</kbd> marks a Java field that must match the database identifier.
            </p>
            
            <p>Here is an example of our <kbd>Quote</kbd> entity:
            </p>
            <pre><span>@Entity<br/></span><span>public class </span>Quote {<br/>    <span>@Id<br/></span><span>    @GeneratedValue<br/></span><span>    </span><span>private long </span><span>id</span>;<br/><br/>    <span>private </span>String <span>name</span>;<br/><br/>    <span>private double </span><span>value</span>;<br/><br/>    <span>@ManyToMany<br/></span><span>    </span><span>private </span>Set&lt;Customer&gt; <span>customers</span>;<br/><br/>    // getters/setters<br/>}</pre>
            <p>This simple model implicitly defines a <em>QUOTE</em> <span>table </span>with three columns, <em>ID, NAME,</em> and <em>VALUE</em> (the casing can depend on the database), and a table to manage the relationship with
               the <em>CUSTOMER</em> <span>table</span><span>, </span>which is named  <kbd>QUOTE_CUSTOMER</kbd> <span>by default.</span></p>
            
            <p>In the same spirit, our <kbd>Customer</kbd> entity just defines an identifier and name as columns and also the reverse relationship
               to the <kbd>Quote</kbd> entity:
            </p>
            <pre><span>@Entity<br/></span><span>public class </span>Customer {<br/>    <span>@Id<br/></span><span>    @GeneratedValue<br/></span><span>    </span><span>private long </span><span>id</span>;<br/><br/>    <span>private </span>String <span>name</span>;<br/><br/>    <span>@ManyToMany</span>(mappedBy = <span>"customers"</span>)<br/>    <span>private </span>Set&lt;Quote&gt; <span>quotes</span>;<br/><br/>    // getters/setters<br/>}</pre>
            <p>What is important here is to notice the relationships in the model. We will deal with
               this later on.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The service layer</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The goal of the book being to discuss the performance and not how to write a Java
               EE application, we will not detail the whole service layer here. However, to ensure
               a common knowledge of what we are dealing with, we will illustrate the code with one
               service.
            </p>
            
            <p>We are using JTA 1.2 with JPA 2.2 to establish a link between our database and the
               Java model. The <kbd>QuoteService</kbd> bean, responsible for managing the <kbd>Quote</kbd> persistence, can therefore look like the following:
            </p>
            <pre><span>@Transactional<br/></span><span>@ApplicationScoped<br/></span><span>public class </span>QuoteService {<br/>    <span>@PersistenceContext<br/></span><span>    </span><span>private </span>EntityManager <span>entityManager</span>;<br/><br/>    <span>public </span>Optional&lt;Quote&gt; findByName(<span>final </span>String name) {<br/>        <span>return </span><span>entityManager</span>.createQuery(<span>"select q from Quote q where<br/>        q.name = :name"</span>, Quote.<span>class</span>)<br/>                .setParameter(<span>"name"</span>, name)<br/>                .getResultStream()<br/>                .findFirst();<br/>    }<br/><br/>    <span>public </span>Optional&lt;Quote&gt; findById(<span>final long </span>id) {<br/>        <span>return </span>Optional.<span>ofNullable</span>(<span>entityManager</span>.find(Quote.<span>class</span>, id));<br/>    }<br/><br/>    <span>public long </span>countAll() {<br/>        <span>return </span><span>entityManager</span>.createQuery(<span>"select count(q) from Quote<br/>        q"</span>, Number.<span>class</span>)<br/>                .getSingleResult()<br/>                .longValue();<br/>    }<br/><br/>    <span>public </span>Quote create(<span>final </span>Quote newQuote) {<br/>        <span>entityManager</span>.persist(newQuote);<br/>        <span>entityManager</span>.flush();<br/>        <span>return </span>newQuote;<br/>    }<br/><br/>    // ... other methods based on the same model<br/>}</pre>
            <p><span>JPA may or may not be used in a transactional context, depending on the kind of operation
                  you do. When you <em>read</em> data, you can often do it without any transaction until you need some lazy loading.
                  However, when you <em>write</em> data (insert/update/delete entities), JPA requires a running transaction to be able
                  to execute the action. This is to ensure consistency of data but also has some implications
                  on the code. To respect that requirement, and have an active transaction, w</span><span>e use </span><kbd>@Transactional</kbd><span> on methods instead of relying on <strong>Enterprise Java Bean</strong> <strong>3.2</strong> (<strong>EJB 3.2</strong>), so we can reuse the power of CDI (</span><kbd>@ApplicationScoped</kbd><span>, for instance, which will avoid creating a new instance per injection).</span></p>
            
            <p>Our finders are very simple and directly use the <kbd>EntityManager</kbd> API. The only new thing Java 8 brings us in this code is the ability to wrap the
               result with <kbd>Optional</kbd> which offers a programmatic way to deal with the presence or absense of the entity
               instead of relying on a null check. Concretely, the caller can use our finder this
               way:
            </p>
            <pre>final int quoteCount = getCustomer().getCountFor("myquote");<br/>final double quotesPrice = quoteService.findByName("myquote")<br/>    .map(quote -&gt; quote.getValue() * quoteCount)<br/>    .orElse(0);</pre>
            <p>This kind of code hides the conditional branches behind a fluent API, which makes
               it more expressive and readable, while the lambdas stay small enough.
            </p>
            
            <p>Finally, we used inline queries <span>in this code, </span>not static ones like in the <kbd>@NamedQuery</kbd> API.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The JAX-RS layer</h1>
            
         </header>
         
         
         <article>
            
            
            <p>If we step back one second and think about which stopover the application will execute,
               we can identify a few of them:
            </p>
            
            <ul>
               
               <li>HTTP communication handling</li>
               
               <li>Payload (un)marshalling</li>
               
               <li>Routing</li>
               
               <li>Service invocation</li>
               
            </ul>
            
            <p>Because of the separation of concern principles, or simply for technical constraints
               between layers, it is very common to use a Data Transfer Object between the JAX-RS/front
               layer and the CDI/business layer. Of course, this statement can be applied to the
               business sub-layers as well, but in the case of this book, we will just do it in the
               JAX-RS layer. To make it obvious in the book, we will prefix the JAX-RS model with
               <kbd>Json</kbd>. Check out the following code snippet:
            </p>
            <pre><span>@JsonbPropertyOrder</span>({<span>"id"</span>, <span>"name"</span>, <span>"customerCount"</span>})<br/><span>public class </span>JsonQuote {<br/>    <span>private long </span><span>id</span>;<br/>    <span>private </span>String <span>name</span>;<br/>    <span>private double </span><span>value</span>;<br/><br/>    <span>@JsonbProperty</span>(<span>"customer_count"</span>)<br/>    <span>private long </span><span>customerCount</span>;<br/><br/>    // getters/setters<br/>}</pre>
            <p>In this context, the front layer role is to delegate most of the logic to the service
               layer and convert the business model to the front model (it can almost be seen as
               a Java to JavaScript conversion for a lot of modern applications):
            </p>
            <pre><span>@Path</span>(<span>"quote"</span>)<br/><span>@RequestScoped<br/></span><span>public class </span>QuoteResource {<br/>    <span>@Inject<br/></span><span>    </span><span>private </span>QuoteService <span>quoteService</span>;<br/><br/>    <span>@GET<br/></span><span>    @Path</span>(<span>"{id}"</span>)<br/>    <span>public </span>JsonQuote findById(<span>@PathParam</span>(<span>"id"</span>) <span>final long </span>id) {<br/>        <span>return </span><span>quoteService</span>.findById(id) // delegation to the business<br/>        layer<br/>                .map(quote -&gt; { // the model conversion<br/>                    <span>final </span>JsonQuote json = <span>new </span>JsonQuote();<br/>                    json.setId(quote.getId());<br/>                    json.setName(quote.getName());<br/>                    json.setValue(quote.getValue());<br/>                    <br/>        json.setCustomerCount(<span>ofNullable</span>(quote.getCustomers())<br/>        .map(Collection::size).orElse(<span>0</span>));<br/>                    <span>return </span>json;<br/>                })<br/>                .orElseThrow(() -&gt; <span>new<br/>                </span>WebApplicationException(Response.Status.<span>NO_CONTENT</span>));<br/>    }<br/><br/>    // other methods<br/>}</pre>
            <div class="packt_infobox">We set the JAX-RS <kbd>@ApplicationPath</kbd> to <kbd>/api</kbd> to ensure that our endpoints are deployed under the <kbd>/api</kbd> subcontext.
            </div>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The WebSocket layer</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Why use JAX-RS and WebSocket? Don't they serve the same purpose? Not exactly, in fact,
               it is becoming more and more common to use both in the same application even if WebSocket
               is still a bit recent.
            </p>
            
            <p>JAX-RS (and, more generally, HTTP/1 and the brand new HTTP/2) is generally web application
               oriented. Understand that it is often used for applications with a user interface
               (which needs to be compatible with all browsers). It is also commonly used in environments
               where you cannot assume much about the network setup. More particularly, in environments
               where you cannot assume the network setup, the proxies will let WebSocket connections
               work properly (either preventing them completely or disconnecting them too early).
               The last common case where HTTP-based solutions make a lot of sense is to try to target
               a market where clients can be developed in any language (Java, Python, Ruby, Go, Node.js,
               and so on). The fact that the technology is today spreading all over the world and
               works well with stateless connections, makes it easier to get started with, and it
               is therefore more accessible than WebSocket, which requires some care from client
               developers.
            </p>
            
            <p>However, WebSocket will fit cases where you have higher performance or reactivity
               constraints, a state to maintain in order to handle the business use case, or you
               simply want to push the information from the server without requiring a client operation
               (such as polling).
            </p>
            
            <p>When you start using a connected protocol such as WebSocket, t<span>he first thing to define</span> is your own communication protocol: the format of the message you send/receive and
               the order of the messages (if needed).
            </p>
            
            <p><span>Our WebSocket layer will be responsible for enabling a client to quickly access</span> the quote<span> prices. Therefore, we will react on a client's request (it will contain the name
                  of the quote that we want to get the price for) and we will respond with two pieces
                  of information: whether we found the quote and the current price, if existing.</span></p>
            
            <p>Then, you need to pick a format to prepare the content sent through the WebSocket
               over the wire. Here, the choice is often guided by a trade-off between the client
               (consumers of the service), the requirements, the performances, and the ease of implementation.
               In our case, we will consider that our clients can be written in Java as well as in
               JavaScript. That is why we will use JSON.
            </p>
            
            <p>To summarize the protocol, here is a full communication round-trip, as shown in the
               following diagram:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="311" src="assets/047d3c1b-cce8-44cd-96bb-a5cc090c638c.png" width="519"/></div>
            
            <p>The communication protocol is based on a single message type in our case, so a full
               client/server communication looks like these steps:
            </p>
            
            <ol>
               
               <li>The client will connect to the server.</li>
               
               <li>The client will request the price of a quote N times, based on its symbol (name/identifier).</li>
               
               <li>Assuming there is no I/O error or timeout, the client will trigger a disconnect, which
                  will end the communication.
               </li>
               
            </ol>
            
            <p>In terms of code, we need multiple bricks of Java EE and we need the following to
               put them together:
            </p>
            
            <ul>
               
               <li>The WebSocket API, obviously</li>
               
               <li>JSON-B (we could use JSON-P, but it is less friendly) for the Java to JSON conversion</li>
               
               <li>CDI, to link the WebSocket to the business layer</li>
               
            </ul>
            
            <p>To start easy, we can modelize our payloads. Our request has only one <kbd>name</kbd> attribute, so JSON-B allows us to define it this way:
            </p>
            <pre><span>public class </span>ValueRequest {<br/>    <span>private </span>String <span>name</span>;<br/><br/>    // getter/setter<br/>}</pre>
            <p>On the other side (that is, the response), we have to return a <kbd>value</kbd> attribute with the price of the quote and a <kbd>found</kbd> Boolean marking <kbd>value</kbd> as filled or not. Here again, JSON-B allows us to do a direct mapping of this model
               with a plain POJO:
            </p>
            <pre><span>public static class </span>ValueResponse {<br/>    <span>private double </span><span>value</span>;<br/>    <span>private boolean </span><span>found</span>;<br/><br/>    // getters/setters<br/>}</pre>
            <p>Now, we need to ensure that the WebSocket will be able to deserialize and <span>serialize</span> these objects as required. The specification defines <kbd>Encoder</kbd> and <kbd>Decoder</kbd> APIs for this purpose. Since we will back our implementation by JSON-B, we can directly
               implement it using the (I/O) stream flavors of these APIs (called <kbd>TextStream</kbd>). Actually, before doing so, we need to get a <kbd>Jsonb</kbd> instance. Considering that we have already created one and made it available in CDI,
               we can then simply inject the instance in our coders:
            </p>
            <pre><span>@Dependent<br/></span><span>public class </span>JsonEncoder <span>implements </span>Encoder.TextStream&lt;Object&gt; {<br/>    <span>@Inject<br/></span><span>    </span><span>private </span>Jsonb <span>jsonb</span>;<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span>encode(<span>final </span>Object o, <span>final </span>Writer writer) <span>throws </span>EncodeException, IOException {<br/>        <span>jsonb</span>.toJson(o, writer);<br/>    }<br/><br/>    // other methods are no-op methods<br/>}</pre>
            <p><span>The decoding side is now fast to develop, thanks to the JSON-B API, which fits this
                  usage very well with its </span><kbd>fromJson()</kbd> <span>API. We will just note that this side is specific to </span><kbd>ValueRequest</kbd><em>,</em> <span>since we need to specify the type to instantiate it (compared with the encoding side,
                  which can determine it dynamically):</span></p>
            <pre><span>@Dependent<br/></span><span>public class </span>RequestDecoder <span>implements </span>Decoder.TextStream&lt;ValueRequest&gt; {<br/>    <span>@Inject<br/></span><span>    </span><span>private </span>Jsonb <span>jsonb</span>;<br/><br/>    <span>@Override<br/></span><span>    </span><span>public </span>ValueRequest decode(<span>final </span>Reader reader) <span>throws </span>DecodeException, IOException {<br/>        <span>return </span><span>jsonb</span>.fromJson(reader, ValueRequest.<span>class</span>);<br/>    }<br/><br/>    // other methods are no-op methods<br/>}</pre>
            <p>Now that we have a way to handle our messages, we need to bind our WebSocket endpoint
               and implement the <kbd>@OnMessage</kbd> method to find the price and send it back to the client relying on our business layer.
               In terms of implementation, we will react to a <kbd>ValueRequest</kbd> message, try to find the corresponding quote, fill the response payload, and send
               it back to the client:
            </p>
            <pre><span>@Dependent<br/></span><span>@ServerEndpoint</span>(<br/>  value = <span>"/quote"</span>,<br/>  decoders = RequestDecoder.<span>class</span>,<br/>  encoders = JsonEncoder.<span>class</span>)<br/><span>  public class </span>DirectQuoteSocket {<br/>  <span>@Inject<br/></span><span>  </span><span>private </span>QuoteService <span>quoteService</span>;<br/><br/>  <span>@OnMessage<br/></span><span>  </span><span>public void </span>onMessage(<span>final </span>Session session, <span>final </span>ValueRequest request) {<br/>    <span>final </span>Optional&lt;Quote&gt; quote = <span>quoteService</span>.findByName(request.getName());<br/>      <span>final </span>ValueResponse response = <span>new </span>ValueResponse();<br/>        <span>if </span>(quote.isPresent()) {<br/>            response.setFound(<span>true</span>);<br/>            response.setValue(quote.get().getValue()); <span>// false<br/></span><span>        </span>}<br/><br/>        <span>if </span>(session.isOpen()) {<br/>            <span>try </span>{<br/>                session.getBasicRemote().sendObject(response);<br/>                } <br/><span>                catch </span>(<span>final </span>EncodeException | IOException e) {<br/>                <span>throw new </span>IllegalArgumentException(e);<br/>            }<br/>        }<br/>    }<br/>}</pre>
            
            
            </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Provision some data</h1>
            
         </header>
         
         
         <article>
            
            
            <p>At this point, we have our application. Now, we need to ensure that it has some data
               and, then, move on to evaluating its performance.
            </p>
            
            <p>Without delving too much into the business details, we will implement the provisioning
               in two passes:
            </p>
            
            <ul>
               
               <li>Find all the symbols to update</li>
               
               <li>For each symbol found, update the price in the database</li>
               
            </ul>
            
            <p>To do so, we will use two public webservices:</p>
            
            <ul>
               
               <li><a href="http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv">http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv</a>, to find a set of symbols
               </li>
               
               <li><a href="https://query1.finance.yahoo.com/v10/finance/quoteSummary/%7Bsymbol%7D?modules=financialData">https://query1.finance.yahoo.com/v10/finance/quoteSummary/{symbol}?modules=financialData</a>, to find the current price of each quote
               </li>
               
            </ul>
            
            <p>The first one is a plain CSV file, which we will parse without any library to keep
               things simple and because the format does not require special escaping/parsing. The
               second one will return a JSON payload, which we can read directly using the JAX-RS
               2.1 client API.
            </p>
            
            <p>Here is how we can retrieve our data:</p>
            <pre><span>private </span>String[] getSymbols(<span>final </span>Client client) {<br/>    <span>try </span>(<span>final </span>BufferedReader stream = <span>new </span>BufferedReader(<br/>            <span>new </span>InputStreamReader(<br/>                    client.target(<span>symbolIndex</span>)<br/>                            .request(<span>APPLICATION_OCTET_STREAM_TYPE</span>)<br/>                            .get(InputStream.<span>class</span>),<br/>                    StandardCharsets.<span>UTF_8</span>))) {<br/><br/>        <span>return </span>stream.lines().skip(<span>2</span><span>/*comment+header*/</span>)<br/>                .map(line -&gt; line.split(<span>","</span>))<br/>                .filter(columns -&gt; columns.<span>length </span>&gt; <span>2 </span>&amp;&amp; !columns[<span>1</span>].isEmpty())<br/>                .map(columns -&gt; columns[<span>1</span>])<br/>                .toArray(String[]::<span>new</span>);<br/>    } <span>catch </span>(<span>final </span>IOException e) {<br/>        <span>throw new </span>IllegalArgumentException(<span>"Can't connect to find symbols"</span>, e);<br/>    }<br/>}</pre>
            <p>Note that we directly read a buffered reader backed by the HTTP response stream. Once
               the symbols are extracted, we can simply iterate over them and request the price of
               each quote:
            </p>
            <pre><span>try </span>{<br/>    <span>final </span>Data data = <span>client</span>.target(<span>financialData</span>)<br/>            .resolveTemplate(<span>"symbol"</span>, symbol)<br/>            .request(<span>APPLICATION_JSON_TYPE</span>)<br/>            .get(Data.<span>class</span>);<br/><br/>    <span>if </span>(!data.hasPrice()) {<br/>        <span>LOGGER</span>.warning(<span>"Can't retrieve '" </span>+ symbol + <span>"'</span><span>"</span>);<br/>        <span>return</span>;<br/>    }<br/><br/>    <span>final double </span>value = data.getQuoteSummary().getResult().get(<span>0</span>)<br/>        .getFinancialData().getCurrentPrice().getRaw();<br/><br/>    <span>final </span>Quote quote = <span>quoteService</span>.mutate(symbol, quoteOrEmpty -&gt;<br/>            quoteOrEmpty.map(q -&gt; {<br/>                q.setValue(<span>value</span>);<br/>                <span>return </span>q;<br/>            }).orElseGet(() -&gt; {<br/>                <span>final </span>Quote newQuote = <span>new </span>Quote();<br/>                newQuote.setName(<span>symbol</span>);<br/>                newQuote.setValue(<span>value</span>);<br/>                <span>quoteService</span>.create(newQuote);<br/>                <span>return </span>newQuote;<br/>            }));<br/><br/>    <span>LOGGER</span>.info(<span>"Updated quote '" </span>+ quote.getName() + <span>"'</span><span>"</span>);<br/>} <span>catch </span>(<span>final </span>WebApplicationException error) {<br/>    <span>LOGGER</span>.info(<span>"Error getting '" </span>+ symbol + <span>"': " </span>+ error.getMessage()<br/>    + <span>" (HTTP " </span>+ (error.getResponse() == <span>null </span>? <span>"-" </span>:<br/>    error.getResponse().getStatus()) + <span>")"</span>);<br/>}</pre>
            <p>This piece of code sends an HTTP request, thanks to the JAX-RS client API and JSON-B,
               which unmarshalls a data model. Then, we use the obtained data to update our database
               quote if it already exists; otherwise, we use the data to create the database quote.
            </p>
            
            <p>The code now needs to be wired to be executed. We have multiple options here:</p>
            
            <ul>
               
               <li>Execute it at startup</li>
               
               <li>Execute it regularly</li>
               
               <li>Execute it when an endpoint is called</li>
               
            </ul>
            
            <p>In the context of this book, we will use the first two options. The startup is common
               for us, even if it is not as realistic, because once started, we will get some data.
               The second option will use an EJB 3.2 <kbd>@Schedule</kbd>, which will run hourly.
            </p>
            
            <p>The startup implementation requires a simple CDI bean with a method calling the previous
               logic when <kbd>@ApplicationScoped</kbd> is created (at startup):
            </p>
            <pre><span>@ApplicationScoped<br/></span><span>public class </span>InitialProvisioning {<br/>    <span>@Inject<br/></span><span>    </span><span>private </span>ProvisioningService <span>provisioningService</span>;<br/><br/>    <span>public void </span>onStart(<span>@Observes @Initialized</span>(<span>ApplicationScoped</span>.<span>class</span>) <span>final </span>ServletContext context) {<br/>        <span>provisioningService</span>.refresh();<br/>    }<br/>}</pre>
            <p>The scheduling is done, thanks to the Enterprise Java Bean <kbd>@Schedule</kbd> API, which allows us, in one annotation, to request the container to regularly execute
               a method:
            </p>
            <pre><span>@Singleton<br/></span><span>@Lock</span>(<span>WRITE</span>)<br/><span>public class </span>DataRefresher {<br/>    <span>@Inject<br/></span><span>    </span><span>private </span>ProvisioningService <span>provisioningService</span>;<br/><br/>    <span>@Schedule</span>(hour = <span>"*"</span>, persistent = <span>false</span>, info = <span>"refresh-quotes"</span>)<br/>    <span>public void </span>refresh() {<br/>        <span>provisioningService</span>.refresh();<br/>    }<br/>}</pre>
            <div class="packt_infobox">In a real application, you will probably want to configure the refresh frequency and
               use the <kbd>TimerService</kbd> API to trigger the execution based on the application configuration. In the same
               spirit, the startup execution could be ignored based on the configuration in order
               to have a faster startup.
            </div>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Application summary</h1>
            
         </header>
         
         
         <article>
            
            
            <p>When working on the performance, it is <span>always </span>important to keep <span>two things in </span>mind:
            </p>
            
            <ul>
               
               <li>The application business (what the application does)</li>
               
               <li>The application technical stack (how the application was designed)</li>
               
            </ul>
            
            <p>Even if the information you have about these two points is very high-level, ensure
               that you know them before working on the performance.
            </p>
            
            <p>Let's do this exercise with our application and ensure that we know how to answer
               both the questions.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The application business</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Our application is responsible for providing the quote prices <span>to HTTP or WebSocket clients</span>. With its model and customer/quote relationship, it can enable us to provide (or
               not provide) the price accessed by the customer if we add permissions or rules, for
               instance. What is important to see at this stage is that both the entities are in
               a relationship and that our application can visit this relationship for its business
               needs and trigger an implicit lazy loading of the relationship entities.
            </p>
            
            <p>The data is injected into the system based on two external HTTP sources (CBOE and
               Yahoo). The first one provides a symbol dictionary of the quotes<em>,</em> and the second one, the prices.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The application design</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Technically, the provisioning of the quote and prices is done asynchronously (not
               when a customer request is sent). It retrieves the data using a JAX-RS 2.1 client
               and inserts it as fast as possible into the database.
            </p>
            
            <p>Access to the application is gained either through HTTP or WebSocket. In both cases,
               the application uses a JSON format for message exchange.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">The application server</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Java EE defines specifications and, therefore, you can find several different implementations.
               Each major vendor has its own server but, of course, for us and Java EE, a lot of
               servers are fully open source. As Java EE 8 is very recent, we will use GlassFish,
               which is the reference implementation and is therefore the first one to be compliant
               with the specification (it must be released with the specification). However, there
               are a lot of alternatives (such as Apache TomEE, Wildfly, Payara, Liberty Profile,
               and so on), which will probably follow in the coming months.
            </p>
            
            <p>GlassFish can be downloaded from its website (<a href="https://javaee.github.io/glassfish/download">https://javaee.github.io/glassfish/download</a>). We need the 5.x version to target Java EE 8, but due to its early release, a major
               part of this book will work with the previous versions.
            </p>
            
            <p>If you want to integrate it with your development environment (and Maven), you can
               add <span>the GlassFish repository </span>to <kbd>pom.xml</kbd>, as follows:
            </p>
            <pre><span>&lt;</span><span>pluginRepository</span><span>&gt;</span><br/>  <span>&lt;</span><span>id</span><span>&gt;</span>maven-java-net<span>&lt;/</span><span>id</span><span>&gt;</span><br/>  <span>&lt;</span><span>url</span><span>&gt;</span>https://maven.java.net/content/groups/promoted/<span>&lt;/</span><span>url</span><span>&gt;</span><br/><span>&lt;/</span><span>pluginRepository</span><span>&gt;</span></pre>
            <p>Add the GlassFish plugin without forgetting to specify the version of the server in
               order to override the default one, which is now quite old:
            </p>
            <pre><span>&lt;</span><span>plugin</span><span>&gt; &lt;!-- glassfish.version = 5.0 --&gt;</span><br/>  <span>&lt;</span><span>groupId</span><span>&gt;</span>org.glassfish.embedded<span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>  <span>&lt;</span><span>artifactId</span><span>&gt;</span>maven-embedded-glassfish-plugin<span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>  <span>&lt;</span><span>version</span><span>&gt;</span>3.1.2.2<span>&lt;/</span><span>version</span><span>&gt;</span><br/>  <span>&lt;</span><span>configuration</span><span>&gt;</span><br/>    <span>&lt;</span><span>app</span><span>&gt;</span>target/${project.build.finalName}<span>&lt;/</span><span>app</span><span>&gt;</span><br/>    <span>&lt;</span><span>port</span><span>&gt;</span>9090<span>&lt;/</span><span>port</span><span>&gt;</span><br/>    <span>&lt;</span><span>contextRoot</span><span>&gt;</span>${project.artifactId}<span>&lt;/</span><span>contextRoot</span><span>&gt;</span><br/>  <span>&lt;/</span><span>configuration</span><span>&gt;</span><br/>  <span>&lt;</span><span>dependencies</span><span>&gt;</span><br/>    <span>&lt;</span><span>dependency</span><span>&gt;</span><br/>      <span>&lt;</span><span>groupId</span><span>&gt;</span>org.glassfish.main.common<span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>      <span>&lt;</span><span>artifactId</span><span>&gt;</span>simple-glassfish-api<span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>      <span>&lt;</span><span>version</span><span>&gt;</span>${glassfish.version}<span>&lt;/</span><span>version</span><span>&gt;</span><br/>    <span>&lt;/</span><span>dependency</span><span>&gt;</span><br/>    <span>&lt;</span><span>dependency</span><span>&gt;</span><br/>      <span>&lt;</span><span>groupId</span><span>&gt;</span>org.glassfish.main.extras<span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>      <span>&lt;</span><span>artifactId</span><span>&gt;</span>glassfish-embedded-all<span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>      <span>&lt;</span><span>version</span><span>&gt;</span>${glassfish.version}<span>&lt;/</span><span>version</span><span>&gt;</span><br/>    <span>&lt;/</span><span>dependency</span><span>&gt;</span><br/>  <span>&lt;/</span><span>dependencies</span><span>&gt;</span><br/><span>&lt;/</span><span>plugin</span><span>&gt;</span></pre>
            <p>With this setup, you can run the following command to package the application <span>as <kbd>war</kbd></span> and deploy it in GlassFish:
            </p>
            <pre><strong>$ mvn package embedded-glassfish:run</strong></pre>
            <p>To shut down the server, type <em>X</em> and <em>ENTER</em>.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Testing the application</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Before starting to work on our application from the performance window, let's get
               a bit familiar with it. We will not browse and test all the endpoints but just check
               how to get a price using the JAX-RS layer and WebSocket layer. In other words, we
               will define two customer use cases of our application.
            </p>
            
            <p>The goal here is to ensure that we know how to use the application to be able to write
               test scenarios later. To do so, we will execute some requests manually on both fronts
               (HTTP and WebSocket).
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Get a quote price the JAX-RS way</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The endpoint we saw previously has been deployed on <kbd>/&lt;application_context&gt;/api/quote/{quoteId}</kbd> with <span>the context of the web application,</span> <kbd>application_context</kbd>. If you used the previous setup, it is, most likely, the artifact ID of the Maven
               project. Let's consider from now on that it is <kbd>quote-manager</kbd>.
            </p>
            
            <p>Here is what it returns for one of the quotes:</p>
            <pre>$ curl -v http://localhost:9090/quote-manager/api/quote/8<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 9090 (#0)<br/>&gt; GET /quote-manager/api/quote/8 HTTP/1.1<br/>&gt; Host: localhost:9090<br/>&gt; User-Agent: curl/7.52.1<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 200 OK<br/>&lt; Server: Undefined Product Name - define product and version info in config/branding 0.0.0 <br/>&lt; X-Powered-By: Servlet/3.1 JSP/2.3 (Undefined Product Name - define product and version info in config/branding 0.0.0 Java/Oracle Corporation/1.8)<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 54<br/>&lt; <br/>* Curl_http_done: called premature == 0<br/>* Connection #0 to host localhost left intact<br/>{"id":8,"name":"JOBS","customer_count":0,"value":59.4}</pre>
            <p>This kind of application often needs a kind of index endpoint to be able to browse
               quotes (in a nice user interface or a command-line interface, for instance). In our
               case, it is our <em>find all</em> endpoint, which supports pagination through the query parameters. Here is how to
               use it and the kind of data it returns:
            </p>
            <pre>$ curl -v http://localhost:9090/quote-manager/api/quote?from=0&amp;to=5<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 9090 (#0)<br/>&gt; GET /quote-manager/api/quote?from=0 HTTP/1.1<br/>&gt; Host: localhost:9090<br/>&gt; User-Agent: curl/7.52.1<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 200 OK<br/>&lt; Server: Undefined Product Name - define product and version info in config/branding 0.0.0 <br/>&lt; X-Powered-By: Servlet/3.1 JSP/2.3 (Undefined Product Name - define product and version info in config/branding 0.0.0 Java/Oracle Corporation/1.8)<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 575<br/>&lt; <br/>{"total":10,"items":[{"id":1,"name":"FLWS","customer_count":0,"value":9.0},{"id":2,"name":"VNET","customer_count":0,"value":5.19},{"id":3,"name":"XXII","customer_count":0,"value":2.2},{"id":4,"name":"TWOU","customer_count":0,"value":50.1},{"id":5,"name":"DDD","customer_count":0,"value":12.56},{"id":6,"name":"MMM","customer_count":0,"value":204.32},{"id":7,"name":"WBAI","customer_count":0,"value":10.34},{"id":8,"name":"JOBS","customer_count":0,"value":59.4},{"id":9,"name":"WUBA","customer_count":0,"value":62.63},{"id":10,"name":"CAFD","customer_count":0,"value":14.42}]}</pre>
            
            
            </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Get the price, the WebSocket way</h1>
            
         </header>
         
         
         <article>
            
            
            <p>The WebSocket endpoint is deployed on <kbd>/&lt;application_context&gt;/quote</kbd>, and some exchanges can look like the following:
            </p>
            <pre>connect&gt; ws://localhost:9090/quote-manager/quote<br/>send&gt; {"name":"VNET"}<br/>received&lt; {"found":true,"value":5.19}<br/>send&gt; {"name":"DDD"}<br/>received&lt; {"found":true,"value":12.56}<br/>disconnect&gt;<br/>Connection closed: Close status 1000 (Normal Closure)</pre>
            <p>What is interesting to see in this communication dump is the fact that the connection
               lasts for more than one request, and it is based on the symbol more than the identifier
               (compared to the previous JAX-RS samples).
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Setting up MySQL</h1>
            
         </header>
         
         
         <article>
            
            
            <p>All the previous parts will work transparently in Glassfish, as it can provide you
               with a default database if none is set since Java EE 7. <span>This default database</span> is an Apache Derby one for Glassfish. Considering that we will work on the performance
               soon, we want a recent <em>production</em> database. To ensure this, we will set up MySQL.
            </p>
            
            <p>Assuming that you installed MySQL for your operating system and that it runs on <kbd>localhost:3306</kbd> (the default), we need to create a new database. Let's call it <kbd>quote_manager</kbd>:
            </p>
            <pre>$ mysql -u root -p<br/>Enter password: ******<br/>...<br/>mysql&gt; create database quote_manager;<br/>Query OK, 1 row affected (0.00 sec)</pre>
            <p>Now that we have a database, we can configure it in Glassfish and let JPA 2.2 create
               the tables for us based on our model. For this, we need to create <kbd>glassfish-resources.xml</kbd> in the <kbd>WEB-INF</kbd> folder of the <kbd>war</kbd> package (put it in <kbd>src/main/webapp/WEB-INF</kbd> in the Maven project):
            </p>
            <pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;!DOCTYPE</span><span> </span><span>resources</span><span> </span><span>PUBLIC</span><span> </span><span>"-//GlassFish.org//DTD GlassFish Application Server 3.1 Resource Definitions//EN"</span><span><br/></span><span>    </span><span>"http://glassfish.org/dtds/glassfish-resources_1_5.dtd"</span><span>&gt;<br/></span><span>&lt;</span><span>resources</span><span>&gt;</span><br/>  <span>&lt;</span><span>jdbc-connection-pool </span><span>allow-non-component-callers=</span><span>"false"<br/></span><span>                        </span><span>associate-with-thread=</span><span>"false"<br/></span><span>                        </span><span>connection-creation-retry-attempts=</span><span>"0"<br/></span><span>                        </span><span>connection-creation-retry-interval-in-seconds=</span><span>"10"<br/></span><span>                        </span><span>connection-leak-reclaim=</span><span>"false"<br/></span><span>                        </span><span>connection-leak-timeout-in-seconds=</span><span>"0"<br/></span><span>                        </span><span>connection-validation-method=</span><span>"auto-commit"<br/></span><span>                        </span><span>datasource-classname=</span><span>"com.mysql.jdbc.jdbc2.optional.MysqlDataSource"<br/></span><span>                        </span><span>fail-all-connections=</span><span>"false"<br/></span><span>                        </span><span>idle-timeout-in-seconds=</span><span>"300"<br/></span><span>                        </span><span>is-connection-validation-required=</span><span>"false"<br/></span><span>                        </span><span>is-isolation-level-guaranteed=</span><span>"true"<br/></span><span>                        </span><span>lazy-connection-association=</span><span>"false"<br/></span><span>                        </span><span>lazy-connection-enlistment=</span><span>"false"<br/></span><span>                        </span><span>match-connections=</span><span>"false"<br/></span><span>                        </span><span>max-connection-usage-count=</span><span>"0"<br/></span><span>                        </span><span>max-pool-size=</span><span>"10"<br/></span><span>                        </span><span>max-wait-time-in-millis=</span><span>"120000"<br/></span><span>                        </span><span>name=</span><span>"MySQLConnectinoPool"<br/></span><span>                        </span><span>non-transactional-connections=</span><span>"false"<br/></span><span>                        </span><span>pool-resize-quantity=</span><span>"2"<br/></span><span>                        </span><span>res-type=</span><span>"javax.sql.DataSource"<br/></span><span>                        </span><span>statement-timeout-in-seconds=</span><span>"-1"<br/></span><span>                        </span><span>steady-pool-size=</span><span>"8"<br/></span><span>                        </span><span>validate-atmost-once-period-in-seconds=</span><span>"0"<br/></span><span>                        </span><span>validation-table-name=</span><span>"DUAL" </span><span>wrap-jdbc-objects=</span><span>"false"</span><span>&gt;</span><br/>    <span>&lt;</span><span>property </span><span>name=</span><span>"URL" </span><span>value=</span><span>"jdbc:mysql://localhost:3306/quote_manager"</span><span>/&gt;</span><br/>    <span>&lt;</span><span>property </span><span>name=</span><span>"User" </span><span>value=</span><span>"root"</span><span>/&gt;</span><br/>    <span>&lt;</span><span>property </span><span>name=</span><span>"Password" </span><span>value=</span><span>"password"</span><span>/&gt;</span><br/>  <span>&lt;/</span><span>jdbc-connection-pool</span><span>&gt;</span><br/>  <span>&lt;</span><span>jdbc-resource </span><span>jndi-name=</span><span>"java:app/jdbc/quote_manager" </span><span>pool-name=</span><span>"MySQLConnectinoPool" </span><span>enabled=</span><span>"true"</span><span>/&gt;</span><br/><span>&lt;/</span><span>resources</span><span>&gt;</span></pre>
            <p>Alternatively, you can also do it through code using the <kbd>@DataSourceDefinition</kbd> annotation, which is more portable than the specific descriptor of GlassFish (this
               is the solution we will rely on from now on):
            </p>
            <pre><span>@DataSourceDefinition</span>(<br/>        name = <span>"java:app/jdbc/quote_manager"</span>,<br/>        className = <span>"com.mysql.jdbc.Driver"</span>,<br/>        url = <span>"jdbc:mysql://localhost:3306/quote_manager"</span>,<br/>        user = <span>"root"</span>,<br/>        password = <span>"password"<br/></span>)<br/><span>public class </span>DataSourceConfiguration {<br/>}</pre>
            <p>If you recompile and restart the server, you will see that it has created the tables,
               thanks to our <kbd>persistence.xml</kbd> configuration:
            </p>
            <pre><strong>mysql&gt; show tables;</strong><br/><strong>+-------------------------+</strong><br/><strong>| Tables_in_quote_manager |</strong><br/><strong>+-------------------------+</strong><br/><strong>| CUSTOMER                |</strong><br/><strong>| QUOTE                   |</strong><br/><strong>| QUOTE_CUSTOMER          |</strong><br/><strong>| SEQUENCE                |</strong><br/><strong>+-------------------------+</strong></pre>
            <p>If you are waiting for the server to start and have kept the provisioning activated,
               you will also see some data in the <kbd>QUOTE</kbd> table:
            </p>
            <pre><strong>mysql&gt; select * from QUOTE limit 10;</strong><br/><strong>+----+-------+-------+</strong><br/><strong>| ID | NAME | VALUE  |</strong><br/><strong>+----+-------+-------+</strong><br/><strong>| 1  | FLWS  | 9     |</strong><br/><strong>| 2  | VNET  | 5.19  |</strong><br/><strong>| 3  | XXII  | 2.2   |</strong><br/><strong>| 4  | TWOU  | 50.1  |</strong><br/><strong>| 5  | DDD   | 12.56 |</strong><br/><strong>| 6  | MMM   | 204.32|</strong><br/><strong>| 7  | WBAI  | 10.34 |</strong><br/><strong>| 8  | JOBS  | 59.4  |</strong><br/><strong>| 9  | WUBA  | 62.63 |</strong><br/><strong>| 10 | CAFD  | 14.42 |</strong><br/><strong>+----+-------+-------+</strong></pre>
            
            
            </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Conclusion</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Now we have our functional Quote Manager application, and we can deploy it in a Java
               EE 8 server (GlassFish here) and store our data in a <em>real</em> database (MySQL).
            </p>
            
            <p>Till now, we have mainly worked on making the application functional. Thanks to the
               high-level APIs of Java EE, this was not so hard, but it is important to understand
               what we used and what the performance implications of each element of our stack are,
               to be able to validate/invalidate the performance figures once you have them in your
               hands.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Summary</h1>
            
         </header>
         
         
         <article>
            
            
            <p>In this chapter, we created an application responsible for managing quote prices and
               enabling clients to access them through HTTP and WebSockets. The application uses
               plain Java EE code (no external dependencies). We also saw how to link the application
               to a database. We used MySQL as the database, which is a free and very common choice.
            </p>
            
            <p>In the next chapter, we will go deeper into the Java EE stack, and understand its
               role and what it implies for the application in terms of the application's performance.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   </body></html>