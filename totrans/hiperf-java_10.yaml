- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connection Pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Connection pooling** is a technique used in software development to manage
    database connections. These connections can be reused during program execution
    and conventional wisdom dictates that anything that can be reused should be created
    once and reused as needed. That has been the premise throughout this book as we
    strive to achieve higher-performing Java applications. This chapter covers the
    concept of connection pooling, providing fundamental principles, implementation
    approaches, and examples. Our coverage includes establishing connections, managing
    them, and terminating them when no longer needed. Best practices related to connection
    pooling will also be covered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following main topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Connection pooling concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing connection pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices with connection pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should have a thorough understanding of connection
    pooling, be able to implement a connection pool, and strategically design an approach
    to leverage connection pools for performance enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter10](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Connection pooling concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern systems include multiple databases, especially when **microservices
    architectures** are implemented. This makes the concept of connection pooling
    a critical component of efficient Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are independent components of a software system tied to a specific
    business function. They often have their own database so they can be decoupled
    from the main application and updated independently of other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The key issue is that software applications need to connect to databases and
    those connections draw on system resources. The concept of connection pooling
    is to establish a connection to the required databases and when they are no longer
    in use, return them to a pool. Obtaining a connection from a pool is quicker and
    less resource intensive than creating new connections every time a database operation
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: The following illustration shows the process of connection pooling, which is
    also considered the **connection pool** **life cycle**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Connection pool life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B21942_10_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Connection pool life cycle
  prefs: []
  type: TYPE_NORMAL
- en: Connection pools are initialized when the application initially loads. Part
    of the initialization involves establishing the number of connections. We will
    walk through an example later in this chapter. For now, you should understand
    that we will use a **connection pool library** for our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The second component is **connection borrowing**. Whenever a database operation
    is necessary, a connection is obtained from the pool. The term “borrowing” suggests
    that once a connection is no longer required by a service, it is returned to the
    pool. That is the connection return component’s segment of the life cycle. Unused
    connections are returned to the pool so they can be used again.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of connection pooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three primary advantages of connection pooling. First, the use of
    connection pooling can result in higher performance. This improvement is possible
    because connects are reused, resulting in faster database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of implementing connection pooling in our applications is
    that we are better equipped to optimize resource utilization. The number of database
    connections open at any given time is reduced because the unused connections are
    in a pool. This results in lower application and database server overhead.
  prefs: []
  type: TYPE_NORMAL
- en: An additional advantage of connection pooling is that it supports scalability.
    This is possible because when our applications use connection pooling, they can
    handle many simultaneous database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges of connection pooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are challenges and concerns with virtually every high-performance approach
    we implement in our Java applications and connection pooling is no exception.
    There are three primary areas of concern.
  prefs: []
  type: TYPE_NORMAL
- en: First, it is critical that we establish an optimal **size** for our connection
    pool. If we do not permit enough connections, our applications can become sluggish
    or unresponsive. Bottlenecks can also occur when our connection pools are too
    small. On the other hand, if our connection pool is too large, we could possibly
    overtask database servers, leading to overall system performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection leaks** are another area of concern. It is important that we manage
    the connection pool life cycle, with a focus on connection borrowing and returning
    operations. When we fail to manage these operations properly, connection leaks
    are possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Connection leaks
  prefs: []
  type: TYPE_NORMAL
- en: Connection leaks occur when we fail to properly return connections to the pool.
    This can lead to the connection pool’s resources being depleted.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a foundational understanding of connection pooling and its
    advantages and challenges. The next section walks through implementation examples.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing connection pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should now understand what connection pools are and the associated advantages
    and challenges. Let’s extend our knowledge by implementing connection pools using
    Java. In this section, we will look at connection pool libraries, set up a connection
    pool, integrate our connection pool with application logic, and explore how to
    monitor our connection pools.
  prefs: []
  type: TYPE_NORMAL
- en: Connection pool libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we decide to use connection pools in an application, we need to select
    an appropriate connection pool library. There are several connection pool libraries
    available to us for Java, and which one we select is based on our application’s
    requirements. Let’s look at three popular connection pool libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Apache Commons Database Connection Pooling** (**DBCP**) is a mature library
    that is considered stable and has wide applicability. As the name suggests, this
    is an open-source library from Apache. While this is a proven library, it is less
    efficient than more modern libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: The **C3PO** (**Cloud-Based Confidentiality-Preserving Continuous Query Processing**)
    connection pool library is another viable option. It includes a robust set of
    features to include automatic connection retries when connections cannot be established.
    This library is a bit more versatile than the Apache Commons DBCP library.
  prefs: []
  type: TYPE_NORMAL
- en: A third connection pool library option is the **Hikari Connection Pool** (**HikariCP**).
    This is a newer library than the previous two and is lauded for its simplicity
    and its performance. With the goal of improving the performance of our Java applications,
    HikariCP is a great choice for connection pooling and is the library featured
    in the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six primary factors you should consider when selecting a connection
    pool library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatibility**: You should check to ensure the library is compatible with
    your version of Java as well as any database drivers or tools you plan to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Familiarity**: If you and your development team are already familiar with
    a specific connection pool library, you can introduce faster development and fewer
    bugs if you continue to use a library you are familiar with. The downside to this
    is that you might be sacrificing features and runtime performance for development
    efficiencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Features**: The full list of features should be reviewed to ensure the library
    you choose can do what you expect it to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance**: We should always gravitate toward libraries that are maintainable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: This is a paramount factor. You want to ensure that your chosen
    library does not underperform when under stress (high and persistent workloads).
    This is something you should test before formally adopting a connection pool library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support**: Check the official website to ensure there is ample documentation.
    Additionally, you want to select a library that has robust community support.
    This can help you when you experience development challenges and when troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When selecting a connection pool library, overall application performance should
    be heavily considered. This may require trial and error with multiple libraries.
    Reviewing the features of each library can help you make an informed decision.
    The following table can help with your review.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Apache DBCP** | **C3P0** | **HikariCP** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Good | Good | Great |'
  prefs: []
  type: TYPE_TB
- en: '| Connection timeout | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Statement caching | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Idle connection test/validation | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Connection validation | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Pool sizing flexibility | Good | Good | Great |'
  prefs: []
  type: TYPE_TB
- en: '| Documentation | Good | Good | Great |'
  prefs: []
  type: TYPE_TB
- en: '| Community support | Good | Good | Great |'
  prefs: []
  type: TYPE_TB
- en: '| Configuration ease | Moderately Complex | Moderately Complex | Simple |'
  prefs: []
  type: TYPE_TB
- en: '| Modern framework integration | Poor | Good | Great |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 – Library features
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding table, many of the features are rated the same
    across all three connection libraries. This suggests that a deeper dive might
    be required. The comparison is only provided as a high-level overview and provides
    insights into areas you might consider researching further.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a connection pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that a connection pool library has been selected, HikariCP in our case,
    we need to follow a few specific steps. Let’s walk through an example using Maven
    for our build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add the library to** **your project**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to edit our pom.xml file to add HikariCP to our dependencies. This
    is how we would do that:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`dataSource` and set several parameters to configure our connection pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`static` connection pool in the `DatabaseConfig` class. We implement this approach
    so our connection pool is initialized and ready when the class loads. The global
    access point to our connection is established with the `getDataSource()` method.
    This facilitates connections to be borrowed from the pool by our application’s
    methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getDataSource()` method, we can access the pool and obtain connections. Here
    is a method of accomplishing that task. As previously stated, this is not a complete
    application; rather, it is a representative code snippet to demonstrate how to
    use a connection pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown previously, we implemented the `try-with-resources` statement to automatically
    close our database connection, which returns the connection to the pool so it
    can be used again.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating connection pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrating connection pools into our Java applications requires us to create
    code (as demonstrated in the previous section) that creates, uses, and closes
    database connections. We highlighted that we no longer need to open a new database
    connection every time a database connection is required. Instead, we borrow from
    the pool and return our connections when we are done with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary integration points are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have our connection pool in place, we need to monitor them during runtime
    and perform tuning as needed. Let’s look at those tasks in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring connection pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connection pools are an important component of modern software systems, and
    they can represent a tremendous boon to overall system performance. This underscores
    the importance of monitoring their performance during runtime. We can accomplish
    this by reviewing logs and using monitoring tools. Most connection pool libraries
    come with tools sufficient for the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to errors, we should look for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connection leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long wait times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improper pool sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part of monitoring connection pools includes the need to establish key metrics.
    Simply watching system logs is not enough; we need a set of metrics or benchmarks
    to properly measure the success and performance of our connection pools.
  prefs: []
  type: TYPE_NORMAL
- en: As we continue to monitor our connection pool performance, we can make configuration
    changes that are applied when the application starts up. For always-on systems,
    you may need to restart a service or server. A mindset of continual performance
    improvement can help ensure we get the best possible performance from our connection
    pools and positively impact our system’s overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices with connection pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connection pool implementation is relatively straightforward and, like most
    programming tasks, you will quickly have your own code base that you can refactor
    for follow-up programming projects. This is often a critical component to your
    system’s success as it provides the mechanism for your application to access data.
    Some factors should be considered as part of your connection pool strategy. Let’s
    look at the primary factors.
  prefs: []
  type: TYPE_NORMAL
- en: Connection pool sizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensuring your connection pool is properly sized is the first factor you should
    consider. We should strive to find the ideal balance between performance and resource
    usage. If our pool is too small, the access wait times can increase, which will
    negatively impact performance. Oversized connection pools can result in wasted
    resources such as idle connections requiring system resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The challenge is knowing what the ideal connection pool size is. This can take
    some trial and error. Initially, we can estimate the number of database connections
    our application might need at one time. There is no magic formula for this, so
    consider the following when making your initial estimates:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of services that your application has that need a database connection
    to fully function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of concurrent connections you will need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the usage patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peak load conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using our `HikariCP` example from earlier, we can set the size of our connection
    pool with a single line of code in our `DataSourceConfig` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we set the maximum number of connections to `10` and the minimum
    number of idle connections that the pool maintains to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you make your initial connection pool size decision, continue monitoring
    the performance and adjusting your configuration as needed. You can use tools
    that come with your connection pool library as well as external tools such as
    **application performance monitoring** (**APM**) tools.
  prefs: []
  type: TYPE_NORMAL
- en: Handling connection leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once your application is running, you should commit yourself to continually
    monitoring your connection pool performance. While you hope not to experience
    connection leaks, the best practice is to be prepared for them. As a reminder,
    a connection leak occurs when a connection is not returned to the pool after it
    is no longer in use. This can lead to depleting the available connections in the
    pool. Ultimately, this can lead to your application failing.
  prefs: []
  type: TYPE_NORMAL
- en: There are two primary approaches to handling connection leaks, and they can
    be used in concert with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Timeout settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can set a timeout period for connections that are borrowed. If a connection
    has been borrowed from the pool for what you consider to be too long, then we
    can have it reclaimed or at least a log entry made to help with your monitoring
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the pool configuration part of the code snippet from earlier in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding code snippet, we set the maximum amount of time a connection
    can be in the pool, in an idle state to 60,000 milliseconds (about 1 minute).
    The second line of code sets the maximum lifetime of a connection in the pool
    to approximately 30 minutes, and the third line sets the amount of time to wait
    for a connection from the pool.
  prefs: []
  type: TYPE_NORMAL
- en: Connection handling patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should review our code to ensure connections are always closed. This can
    be done in a `finally` block or in the `try-with-resource` statement we used earlier
    in this chapter. Let’s look at an example of each.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first code snippet is in an abbreviated format for illustration purposes
    only. It demonstrates how we can ensure the connections are closed. In the following
    example, we assume that all appropriate import statements will be included and
    that `dataSource` has been initialized elsewhere in the application. In the `finally`
    block, we ensure that resources are closed to help avoid connection leaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While implementing the `finally` block can help ensure that resources are closed
    to help avoid connection leaks, another approach is to use the `try-with-resources`
    statement. Here is an example of that statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This approach results in the resources automatically being closed once the try-catch
    block is exited. This exit can occur based on normal program flow or when an exception
    is caught. In both cases, the resource will be automatically closed. As you saw,
    there was no need for a `finally` block with this approach and it is therefore
    the recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: Connection pool security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connection pools facilitate access to our databases, and we must always protect
    them. Maintaining a pool of database connections could represent a tremendous
    security risk. There are two types of protection we can implement.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can encrypt our configuration files. These files contain our database
    connection information and should be considered sensitive information. Encryption
    and decryption can take processing time resulting in a small downtick in performance,
    but this is a necessary component of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of protection is to use the concept of **least privilege**, only
    granting the minimum privileges necessary for the application to run. For example,
    if you have a service that merely needs to search a customer database to display
    key information such as names, emails, and account numbers, do not give that service
    create, update, or delete access to the database. In this scenario, you only need
    to grant the service read access.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few connection pool topics that go beyond the basics and are worth
    considering as we aim to optimize the performance of our connection pools. Let’s
    look at four of those topics here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud native**: When we are working with cloud-based applications, we can
    leverage features native to the cloud environment. This can include features aimed
    at improving resiliency, reliability, and scalability. Ideally, our database selection
    will be based on cloud-native database services to further optimize connection
    pooling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection validation**: It is a good idea to periodically execute a function
    to validate the connections in the pool. This can ensure they remain valid and
    can prevent costly problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failover**: Database redundancy is a key feature of cloud computing environments.
    Specific to connection pools, we can implement a failover schema that shifts to
    a backup database if the first one fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redundancy**: To support failover, and as part of normal practice, we should
    implement database redundancy. Taking advantage of cloud computing database services
    can make this relatively easy to configure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the best practices presented in this section can help you implement
    connection pools in a manner that contributes to the high performance of your
    Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took a deep look at the foundational concepts and components of
    connection pools with a focus on increasing the performance, resilience, reliability,
    and scalability of our Java applications. We also explored implementation strategies
    and best practices for optimizing our use of connection pools. Specifically, we
    highlighted how connection pools work, their advantages, and related challenges
    for developers. We reviewed the features of multiple connection pool libraries
    and selected the HikariCP library for our code examples. You should have a firm
    understanding of connection pools, why we should use them, and how to create,
    monitor, and fine-tune them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the **Hypertext Transfer Protocol** (**HTTP**).
    This protocol is used to transmit data and is the backbone of data communication
    over the web. Our focus will be on how to leverage HTTP for our Java applications
    to communicate with web browsers and web servers. The chapter aims to help you
    learn how to use HTTP in Java web applications while maintaining high performance,
    how to implement strategies for effectively using HTTP with Java, and how to use
    HTTP to communicate between Java applications and APIs.
  prefs: []
  type: TYPE_NORMAL
