<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-94"><em class="italic"><a id="_idTextAnchor093"/>Chapter 6</em>: Tackling Different Kinds of JOINs</h1>
			<p>The SQL <strong class="source-inline">JOIN</strong> clause represents one of the most used SQL features. From the well-known <strong class="source-inline">INNER</strong> and <strong class="source-inline">OUTER JOIN</strong> clauses, the fictional Semi and Anti Join, to the fancy <strong class="source-inline">LATERAL</strong> join, this chapter is a comprehensive set of examples meant to help you practice a wide range of <strong class="source-inline">JOIN</strong> clauses via the jOOQ DSL API. </p>
			<p>The topics of this chapter include the following:</p>
			<ul>
				<li>Practicing the most popular types of JOINs (<strong class="source-inline">CROSS</strong>, <strong class="source-inline">INNER</strong>, and <strong class="source-inline">OUTER</strong>)</li>
				<li>The SQL <strong class="source-inline">USING</strong> and jOOQ <strong class="source-inline">onKey()</strong> shortcuts</li>
				<li>Practicing more types of <strong class="source-inline">JOINs</strong> (Implicit, Self, <strong class="source-inline">NATURAL</strong>, <strong class="source-inline">STRAIGHT</strong>, Semi, Anti, and <strong class="source-inline">LATERAL</strong>)</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06</a>.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Practicing the most popular types of JOINs</h1>
			<p>By <a id="_idIndexMarker477"/>most popular types of <strong class="source-inline">JOIN</strong> statements we are referring to <strong class="source-inline">CROSS JOIN</strong>, <strong class="source-inline">INNER JOIN</strong>, <strong class="source-inline">LEFT JOIN</strong>, <strong class="source-inline">RIGHT JOIN</strong>, and <strong class="source-inline">FULL JOIN</strong>. Let's tackle each of them via the jOOQ DSL API, starting with the most basic type of <strong class="source-inline">JOIN</strong>.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>CROSS JOIN</h2>
			<p><strong class="source-inline">CROSS JOIN</strong> is<a id="_idIndexMarker478"/> the most basic type of <strong class="source-inline">JOIN</strong> that gets materialized in a <a id="_idIndexMarker479"/>Cartesian product. Having two tables, <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>, the <strong class="source-inline">CROSS JOIN</strong> operation between them is represented as <strong class="source-inline">A x B</strong>, and practically, it means the combination of every row from <strong class="source-inline">A</strong> with every row from <strong class="source-inline">B</strong>.</p>
			<p>In jOOQ, <strong class="source-inline">CROSS JOIN</strong> can be rendered by enlisting the tables in the <strong class="source-inline">FROM</strong> clause (non<strong class="source-inline">-ANSI JOIN</strong> syntax) or via the <strong class="source-inline">crossJoin()</strong> method that renders the <strong class="source-inline">CROSS JOIN</strong> keywords (<strong class="source-inline">ANSI JOIN</strong> syntax). Here is the first case – let's <strong class="source-inline">CROSS JOIN</strong> the <strong class="source-inline">OFFICE</strong> and <strong class="source-inline">DEPARTMENT</strong> tables:</p>
			<pre class="source-code">ctx.select().from(OFFICE, DEPARTMENT).fetch();</pre>
			<p>Since this query doesn't expose explicitly or clearly, its intention of using <strong class="source-inline">CROSS JOIN</strong> is not as friendly as the following one, which uses the jOOQ <strong class="source-inline">crossJoin()</strong> method:</p>
			<pre class="source-code">ctx.select().from(OFFICE).crossJoin(DEPARTMENT).fetch();</pre>
			<p>Using the <strong class="source-inline">crossJoin()</strong> method renders the <strong class="source-inline">CROSS JOIN</strong> keywords (<strong class="source-inline">ANSI JOIN</strong> syntax), which clearly communicate our intentions and remove any potential confusion:</p>
			<pre class="source-code">SELECT `classicmodels`.`office`.`office_code`,</pre>
			<pre class="source-code">       `classicmodels`.`office`.`city`,</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">       `classicmodels`.`department`.`department_id`,</pre>
			<pre class="source-code">       `classicmodels`.`department`.`name`,</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">FROM `classicmodels`.`office`</pre>
			<pre class="source-code">CROSS JOIN `classicmodels`.`department`</pre>
			<p>Since some offices have <strong class="source-inline">NULL</strong> values for <strong class="source-inline">CITY</strong> and/or <strong class="source-inline">COUNTRY</strong> columns, we can easily exclude them from the <strong class="source-inline">OFFICE x DEPARTMENT</strong> via a predicate. Moreover, just for fun, we may prefer to concatenate the results as <em class="italic">city, country: department</em> (for example, <em class="italic">San Francisco, USA: Advertising</em>):</p>
			<pre class="source-code"> ctx.select(concat(OFFICE.CITY, inline(", "), OFFICE.COUNTRY,</pre>
			<pre class="source-code">            inline(": "), DEPARTMENT.NAME).as("offices"))</pre>
			<pre class="source-code">    .from(OFFICE).crossJoin(DEPARTMENT)</pre>
			<pre class="source-code">    .where(row(OFFICE.CITY, OFFICE.COUNTRY).isNotNull())</pre>
			<pre class="source-code">    .fetch();</pre>
			<p>Basically, once <a id="_idIndexMarker480"/>we've added a predicate, this <a id="_idIndexMarker481"/>becomes <strong class="source-inline">INNER JOIN</strong>, as discussed in the following section. More examples are available in the bundled code as <em class="italic">CrossJoin</em>. </p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>INNER JOIN</h2>
			<p><strong class="source-inline">INNER JOIN</strong> (or simply <strong class="source-inline">JOIN</strong>) represents a Cartesian product filtered by some predicate <a id="_idIndexMarker482"/>commonly placed in the <strong class="source-inline">ON</strong> clause. So, with the <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> tables, <strong class="source-inline">INNERJOIN</strong> returns the <a id="_idIndexMarker483"/>rows of <strong class="source-inline">A x B</strong> that validate the specified predicate.</p>
			<p>In jOOQ, we render <strong class="source-inline">INNER JOIN</strong> via <strong class="source-inline">innerJoin()</strong> (or simply <strong class="source-inline">join()</strong>, if omitting <strong class="source-inline">INNER</strong> is supported by your database vendor) and the <strong class="source-inline">on()</strong> methods. Here is an example that applies <strong class="source-inline">INNER JOIN</strong> between <strong class="source-inline">EMPLOYEE</strong> and <strong class="source-inline">OFFICE</strong> to fetch employee names and the cities of their offices:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, OFFICE.CITY)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .innerJoin(OFFICE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.OFFICE_CODE.eq(OFFICE.OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The rendered SQL for the MySQL dialect is as follows:</p>
			<pre class="source-code">SELECT `classicmodels`.`employee`.`first_name`,</pre>
			<pre class="source-code">       `classicmodels`.`employee`.`last_name`,</pre>
			<pre class="source-code">       `classicmodels`.`office`.`city`</pre>
			<pre class="source-code">FROM `classicmodels`.`employee`</pre>
			<pre class="source-code">JOIN `classicmodels`.`office` ON  </pre>
			<pre class="source-code">   `classicmodels`.`employee`.'office_code' </pre>
			<pre class="source-code">      = `classicmodels`.`office`.`office_code`</pre>
			<p>By default, jOOQ doesn't render the optional <strong class="source-inline">INNER</strong> keyword. But, you can alter this default via the <strong class="source-inline">withRenderOptionalInnerKeyword()</strong> setting and the argument <strong class="source-inline">RenderOptionalKeyword.ON</strong>.</p>
			<p>In jOOQ, chaining multiple <strong class="source-inline">JOIN</strong>s is quite easy. For example, fetching the managers and their offices requires two <strong class="source-inline">INNER JOIN </strong>clauses, since between <strong class="source-inline">MANAGER</strong> and <strong class="source-inline">OFFICE</strong>, we have a many-to-many relationship mapped by the <strong class="source-inline">MANAGER_HAS_OFFICE</strong> junction table:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .innerJoin(OFFICE_HAS_MANAGER)</pre>
			<pre class="source-code">      .on(MANAGER.MANAGER_ID</pre>
			<pre class="source-code">         .eq(OFFICE_HAS_MANAGER.MANAGERS_MANAGER_ID))</pre>
			<pre class="source-code">   .innerJoin(OFFICE)</pre>
			<pre class="source-code">      .on(OFFICE.OFFICE_CODE</pre>
			<pre class="source-code">         .eq(OFFICE_HAS_MANAGER.OFFICES_OFFICE_CODE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In these examples, we <a id="_idIndexMarker484"/>called the jOOQ join method on <strong class="source-inline">org.jooq.SelectFromStep</strong> <a id="_idIndexMarker485"/>and the rendered SQL for PostgreSQL dialect is:</p>
			<pre class="source-code">…</pre>
			<pre class="source-code">FROM </pre>
			<pre class="source-code">   "public"."manager" </pre>
			<pre class="source-code">JOIN "public"."office_has_manager" </pre>
			<pre class="source-code">ON "public"."manager"."manager_id" = </pre>
			<pre class="source-code">   "public"."office_has_manager"."managers_manager_id" </pre>
			<pre class="source-code">JOIN "public"."office" </pre>
			<pre class="source-code">ON "public"."office"."office_code" =  </pre>
			<pre class="source-code">   "public"."office_has_manager"."offices_office_code"</pre>
			<p>But, for convenience, we can call the join method directly after the <strong class="source-inline">FROM</strong> clause on <strong class="source-inline">org.jooq.Table</strong>. In such case, we obtain a nested fluent code as below (feel free to use the approach that you find most convenient):</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(MANAGER</pre>
			<pre class="source-code">      .innerJoin(OFFICE_HAS_MANAGER</pre>
			<pre class="source-code">      .innerJoin(OFFICE)</pre>
			<pre class="source-code">         .on(OFFICE.OFFICE_CODE.eq(</pre>
			<pre class="source-code">             OFFICE_HAS_MANAGER.OFFICES_OFFICE_CODE)))</pre>
			<pre class="source-code">      .on(MANAGER.MANAGER_ID.eq(</pre>
			<pre class="source-code">          OFFICE_HAS_MANAGER.MANAGERS_MANAGER_ID)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The <a id="_idIndexMarker486"/>rendered <a id="_idIndexMarker487"/>SQL for the PostgreSQL dialect is as follows:</p>
			<pre class="source-code">…</pre>
			<pre class="source-code">FROM </pre>
			<pre class="source-code">   "public"."manager" </pre>
			<pre class="source-code">JOIN </pre>
			<pre class="source-code">(</pre>
			<pre class="source-code">   "public"."office_has_manager" </pre>
			<pre class="source-code">    JOIN "public"."office" </pre>
			<pre class="source-code">    ON "public"."office"."office_code" = </pre>
			<pre class="source-code">         "public"."office_has_manager"."offices_office_code"</pre>
			<pre class="source-code">) ON "public"."manager"."manager_id" = </pre>
			<pre class="source-code">     "public"."office_has_manager"."managers_manager_id"</pre>
			<p>Next, let's talk about <strong class="source-inline">OUTER JOIN</strong>.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>OUTER JOIN</h2>
			<p>While <strong class="source-inline">INNER JOIN</strong> returns <a id="_idIndexMarker488"/>only the combinations that pass the <strong class="source-inline">ON</strong> predicate, <strong class="source-inline">OUTER JOIN</strong> will <a id="_idIndexMarker489"/>also fetch rows that have no match on the left-hand side (<strong class="source-inline">LEFT</strong> [<strong class="source-inline">OUTER</strong>] <strong class="source-inline">JOIN</strong>) or right-hand side (<strong class="source-inline">RIGHT</strong> [<strong class="source-inline">OUTER</strong>] <strong class="source-inline">JOIN</strong>) of the join operation. Of course, we have to mention here <strong class="source-inline">FULL</strong> [<strong class="source-inline">OUTER</strong>] <strong class="source-inline">JOIN</strong> as well. This fetches all rows from both sides of the join operation.</p>
			<p>The jOOQ API renders <strong class="source-inline">OUTER JOIN</strong> via <strong class="source-inline">leftOuterJoin()</strong>, <strong class="source-inline">rightOuterJoin()</strong>, and <strong class="source-inline">fullOuterJoin()</strong>. Since the <strong class="source-inline">OUTER</strong> keyword is optional, we can omit it via the analogs, <strong class="source-inline">leftJoin()</strong>, <strong class="source-inline">rightJoin()</strong>, and <strong class="source-inline">fullJoin()</strong>.</p>
			<p>For example, let's fetch all employees (on the left-hand side) and their sales (on the right-hand side). By using <strong class="source-inline">LEFT</strong> [<strong class="source-inline">OUTER</strong>] <strong class="source-inline">JOIN</strong>, we retain all employees, even if they have no sales:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, SALE.SALE_)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .leftOuterJoin(SALE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>If we <a id="_idIndexMarker490"/>want to retain only the employees that have no sales, then we <a id="_idIndexMarker491"/>can rely on an exclusive <strong class="source-inline">LEFT</strong> [<strong class="source-inline">OUTER</strong>] <strong class="source-inline">JOIN</strong> by adding a <strong class="source-inline">WHERE</strong> clause that excludes all matches:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, SALE.SALE_)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .leftOuterJoin(SALE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code"><strong class="bold">   .where(SALE.EMPLOYEE_NUMBER.isNull())</strong></pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The rendered SQL for the SQL Server dialect is as follows:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  [classicmodels].[dbo].[employee].[first_name],</pre>
			<pre class="source-code">  [classicmodels].[dbo].[employee].[last_name],</pre>
			<pre class="source-code">  [classicmodels].[dbo].[sale].[sale] </pre>
			<pre class="source-code">FROM</pre>
			<pre class="source-code">  [classicmodels].[dbo].[employee] </pre>
			<pre class="source-code">LEFT OUTER JOIN</pre>
			<pre class="source-code">  [classicmodels].[dbo].[sale] </pre>
			<pre class="source-code">ON [classicmodels].[dbo].[employee].[employee_number] =     </pre>
			<pre class="source-code">   [classicmodels].[dbo].[sale].[employee_number] </pre>
			<pre class="source-code">WHERE [classicmodels].[dbo].[sale].[employee_number] IS NULL</pre>
			<p>If you prefer to use the Oracle (+) symbol shorthand for performing <strong class="source-inline">OUTER JOIN</strong> then check this example of an <strong class="source-inline">LEFT [OUTER] JOIN</strong>:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, SALE.SALE_)</pre>
			<pre class="source-code">   .from(EMPLOYEE, SALE)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER.plus()</pre>
			<pre class="source-code">       .eq(EMPLOYEE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>And, the Oracle SQL is:</p>
			<pre class="source-code">SELECT </pre>
			<pre class="source-code">  "CLASSICMODELS"."EMPLOYEE"."FIRST_NAME", </pre>
			<pre class="source-code">  "CLASSICMODELS"."EMPLOYEE"."LAST_NAME", </pre>
			<pre class="source-code">  "CLASSICMODELS"."SALE"."SALE" </pre>
			<pre class="source-code">FROM </pre>
			<pre class="source-code">  "CLASSICMODELS"."EMPLOYEE", </pre>
			<pre class="source-code">  "CLASSICMODELS"."SALE" </pre>
			<pre class="source-code">WHERE </pre>
			<pre class="source-code">  "CLASSICMODELS"."SALE"."EMPLOYEE_NUMBER"(+) =  </pre>
			<pre class="source-code">     "CLASSICMODELS"."EMPLOYEE"."EMPLOYEE_NUMBER"</pre>
			<p>By default, jOOQ render the optional <strong class="source-inline">OUTER</strong> keyword for both, <strong class="source-inline">leftOuterJoin()</strong> and <strong class="source-inline">leftJoin()</strong>. Alter this default via the <strong class="source-inline">withRenderOptionalOuterKeyword()</strong> setting and the argument <strong class="source-inline">RenderOptionalKeyword.ON</strong>.</p>
			<p>In the bundled <a id="_idIndexMarker492"/>code, you can <a id="_idIndexMarker493"/>practice more examples, including <strong class="source-inline">RIGHT</strong>/<strong class="source-inline">FULL</strong> [<strong class="source-inline">OUTER</strong>] <strong class="source-inline">JOIN</strong>. For MySQL, which doesn't support <strong class="source-inline">FULL</strong> [<strong class="source-inline">OUTER</strong>] <strong class="source-inline">JOIN</strong>, we wrote some emulation code based on the <strong class="source-inline">UNION</strong> clause. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A special case of <strong class="source-inline">OUTER JOIN</strong> is represented by Oracle's partitioned <strong class="source-inline">OUTER JOIN</strong>. </p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>PARTITIONED OUTER JOIN</h2>
			<p>A special<a id="_idIndexMarker494"/> case of <strong class="source-inline">OUTER JOIN</strong> is represented by the Oracle's partitioned <strong class="source-inline">OUTER JOIN</strong>. Such a join represents an extension<a id="_idIndexMarker495"/> of the classical <strong class="source-inline">OUTER JOIN</strong> syntax and is applied to each logical partition defined via an expression in the <strong class="source-inline">PARTITION BY</strong> clause. A partitioned <strong class="source-inline">OUTER JOIN</strong> returns a <strong class="source-inline">UNION</strong> of the outer joins of each of the partitions in the partitioned table (logically partitions) with the table on the other side of the join. </p>
			<p>Partitioned outer joins are specific to Oracle and they allow us to do the same "densifying" (fill gaps in sparse data) of data using a quite convenient syntax and an efficient Execution Plan. </p>
			<p>A classical scenario where the Oracle's partitioned <strong class="source-inline">OUTER JOIN</strong> can be used sounds like this: write a query returning the sales of every employee (<em class="italic">Sales Representative</em>) in every fiscal year while taking into account that some employees had no sales in some years - fill gaps in sparse data with 0. For instance, if we try to see the sales of all employees (<em class="italic">Sales Representative</em>) grouped by fiscal year via a trivial <strong class="source-inline">JOIN</strong> then we obtain some gaps in data as in the following figure: </p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B16833_Figure_6.1.jpg" alt="Figure 6.1 – Fill gaps in sparse data &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Fill gaps in sparse data </p>
			<p>In figure (a) is what we can easily get from a trivial <strong class="source-inline">JOIN</strong>, while in figure (b) is what we plan to get. So, we want<a id="_idIndexMarker496"/> to see all the <em class="italic">Sales Representative</em> even if they don’t have sales in certain years. This is a job for Oracle <a id="_idIndexMarker497"/>partitioned <strong class="source-inline">OUTER JOIN</strong> where the logical partition is <strong class="source-inline">FISCAL_YEAR</strong>: </p>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR, </pre>
			<pre class="source-code">           EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">           sum(nvl(SALE.SALE_, 0.0d)).as("SALES")) </pre>
			<pre class="source-code">   .from(EMPLOYEE) </pre>
			<pre class="source-code">   .leftOuterJoin(SALE).partitionBy(SALE.FISCAL_YEAR) </pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER)) </pre>
			<pre class="source-code">   .where(EMPLOYEE.JOB_TITLE.eq("Sales Rep")) </pre>
			<pre class="source-code">   .groupBy(SALE.FISCAL_YEAR, </pre>
			<pre class="source-code">            EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME) </pre>
			<pre class="source-code">   .orderBy(1, 2) </pre>
			<pre class="source-code">   .fetch(); </pre>
			<p>Of course, you can express/emulate this query without partitioned <strong class="source-inline">OUTER JOIN</strong>, but for this you have to check out the application <em class="italic">PartitionedOuterJoin</em>.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>The SQL USING and jOOQ onKey() shortcuts</h1>
			<p>So far, we've covered the typical <strong class="source-inline">JOIN</strong>s that are commonly used in daily work. Before we continue with more types of <strong class="source-inline">JOIN</strong>s, let's introduce two convenient shortcuts that are useful for expressing more concise <strong class="source-inline">JOIN</strong>s. </p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>SQL JOIN … USING</h2>
			<p>In <a id="_idIndexMarker498"/>certain cases, the SQL <strong class="source-inline">JOIN … USING</strong> clause can be a convenient alternative to the classical <strong class="source-inline">JOIN … ON</strong> clause. Instead of specifying a condition in the <strong class="source-inline">JOIN … ON</strong> clause, we enlist the <strong class="source-inline">JOIN … USING</strong> clause in the set of fields (columns) whose names are common to both tables – the left-hand side table and right-hand side table of a <strong class="source-inline">JOIN</strong> operation. In jOOQ, the <strong class="source-inline">USING</strong> clause is rendered via the <strong class="source-inline">using()</strong> method, as shown in the following example. The <strong class="source-inline">EMPLOYEE_NUMBER</strong> column mentioned in <strong class="source-inline">using()</strong> is the primary key of the <strong class="source-inline">EMPLOYEE</strong> table and the foreign key of the <strong class="source-inline">SALE</strong> table:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME,    </pre>
			<pre class="source-code">           SALE.SALE_)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .innerJoin(SALE)</pre>
			<pre class="source-code">   .using(EMPLOYEE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>So, <strong class="source-inline">using(EMPLOYEE.EMPLOYEE_NUMBER)</strong> is a less verbose representation of <strong class="source-inline">on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER)</strong>, and the rendered SQL for<a id="_idIndexMarker499"/> the MySQL dialect is as follows:</p>
			<pre class="source-code">SELECT `classicmodels`.`employee`.`first_name`,</pre>
			<pre class="source-code">       `classicmodels`.`employee`.`last_name`,</pre>
			<pre class="source-code">       `classicmodels`.`sale`.`sale`</pre>
			<pre class="source-code">FROM `classicmodels`.`employee`</pre>
			<pre class="source-code">JOIN `classicmodels`.`sale` USING (`employee_number`)</pre>
			<p>But we can use any other field(s). Here is the <strong class="source-inline">USING</strong> clause for a composite primary key:</p>
			<pre class="source-code">...using(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE)</pre>
			<p>Alternatively, this is a <strong class="source-inline">USING</strong> clause for two fields that are not primary/foreign keys:</p>
			<pre class="source-code">.using(OFFICE.CITY, OFFICE.COUNTRY)</pre>
			<p>Note that <strong class="source-inline">using()</strong> without arguments will render <strong class="source-inline">ON TRUE</strong>, so no filter is applied to the join operation. Practice the complete examples via the <em class="italic">JoinUsing</em> bundled application. Next, let's introduce a very handy tool from jOOQ named <strong class="source-inline">onKey()</strong>. </p>
			<p>However, as I said, <strong class="source-inline">USING</strong> fits only for certain cases. Lukas Eder enforces this statement: "<em class="italic">The </em><strong class="source-inline">USING</strong><em class="italic"> clause leads to a bit more difficult to maintain queries when queries get complex, so it's generally not recommended. It's less type-safe (in jOOQ). When you rename a column, your jOOQ code might still compile. It wouldn't if you had been using </em><strong class="source-inline">ON</strong><em class="italic">. When you add a column that accidentally matches a column referenced from </em><strong class="source-inline">USING</strong><em class="italic">, you might get unintended consequences in unrelated queries. Example, </em><strong class="source-inline">A JOIN B USING (X) JOIN C USING (Y)</strong><em class="italic">. This assumes </em><strong class="source-inline">A(X)</strong><em class="italic">, </em><strong class="source-inline">B(X, Y)</strong><em class="italic">, </em><strong class="source-inline">C(Y)</strong><em class="italic">. So, what happens if you add </em><strong class="source-inline">A(Y)</strong><em class="italic">? A runtime exception, because </em><strong class="source-inline">Y</strong><em class="italic"> is now ambiguous. Or, even worse: What happens if you add </em><strong class="source-inline">A(Y)</strong><em class="italic"> but remove </em><strong class="source-inline">B(Y)</strong><em class="italic">? No runtime exception, but possibly (and quietly) wrong query. Moreover, in Oracle, columns referenced from </em><strong class="source-inline">USING</strong><em class="italic"> can no longer be qualified in the query. In conclusion, </em><strong class="source-inline">USING</strong><em class="italic"> can be useful for quick and dirty ad-hoc querying, just like </em><strong class="source-inline">NATURAL</strong><em class="italic">. But I wouldn't use it in production queries. Especially, because implicit joins work much better in jOOQ. </em></p>
			<p><em class="italic">The essence here is always the fact (and this is frequently misunderstood) that joins are *binary* operators between two tables. For instance, </em><strong class="source-inline">A JOIN B USING (X) JOIN C USING (Y)</strong><em class="italic"> is just short for </em><strong class="source-inline">(A JOIN B USING (X)) JOIN C USING (Y)</strong><em class="italic">, so </em><strong class="source-inline">C</strong><em class="italic"> is joined to </em><strong class="source-inline">(A JOIN B USING (X)</strong><em class="italic">) not to B alone. This is also the case for </em><strong class="source-inline">onKey()</strong><em class="italic">.</em>"</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>jOOQ onKey()</h2>
			<p>Whenever we join a<a id="_idIndexMarker500"/> well-known foreign key relationship, we can rely on the jOOQ <strong class="source-inline">onKey()</strong> method. Since this is quite easy to understand for a simple foreign key, let's pick up a composite foreign key containing two fields. Check out the following <strong class="source-inline">ON</strong> clause:</p>
			<pre class="source-code">ctx.select(...)</pre>
			<pre class="source-code">   .from(PAYMENT)</pre>
			<pre class="source-code">   .innerJoin(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .on(PAYMENT.CUSTOMER_NUMBER.eq(</pre>
			<pre class="source-code">       BANK_TRANSACTION.CUSTOMER_NUMBER)               </pre>
			<pre class="source-code">   .and(PAYMENT.CHECK_NUMBER.eq(</pre>
			<pre class="source-code">       BANK_TRANSACTION.CHECK_NUMBER)))</pre>
			<p>The (<strong class="source-inline">CUSTOMER_NUMBER</strong>, <strong class="source-inline">CHECK_NUMBER</strong>) represents a composite foreign key in the <strong class="source-inline">BANK_TRANSACTION</strong> table. jOOQ allows us to replace this verbose <strong class="source-inline">ON</strong> clause with the <strong class="source-inline">onKey()</strong> method without arguments, as follows:</p>
			<pre class="source-code">ctx.select(...)</pre>
			<pre class="source-code">   .from(PAYMENT)</pre>
			<pre class="source-code">   .innerJoin(BANK_TRANSACTION)</pre>
			<pre class="source-code"><strong class="bold">   .onKey()</strong></pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Really cool, isn't it? jOOQ<a id="_idIndexMarker501"/> infers the <strong class="source-inline">ON</strong> condition on our behalf, and the rendered SQL for MySQL is as follows:</p>
			<pre class="source-code">SELECT ...</pre>
			<pre class="source-code">FROM `classicmodels`.`payment`</pre>
			<pre class="source-code">JOIN `classicmodels`.`bank_transaction` </pre>
			<pre class="source-code">ON (`classicmodels`.`bank_transaction`.`customer_number` </pre>
			<pre class="source-code">  = `classicmodels`.`payment`.`customer_number`</pre>
			<pre class="source-code">AND `classicmodels`.`bank_transaction`.`check_number` </pre>
			<pre class="source-code">  = `classicmodels`.`payment`.`check_number`)</pre>
			<p>In case of ambiguity caused by multiple keys' potential matches, we can also rely on foreign keys' field references via <strong class="source-inline">onKey(TableField&lt;?,?&gt;... tfs)</strong>, or the generated foreign keys' references via <strong class="source-inline">onKey(ForeignKey&lt;?,?&gt; fk)</strong>. For instance, in order to avoid the <strong class="source-inline">DataAccessException</strong><em class="italic">: Key ambiguous between tables X and Y</em> exception, while joining table X with table Y via <strong class="source-inline">onKey()</strong>, we can explicitly indicate the foreign key that should be used as follows (here, via the SQL Server generated foreign key reference, <strong class="source-inline">jooq.generated.Keys.PRODUCTLINEDETAIL_PRODUCTLINE_FK)</strong>:</p>
			<pre class="source-code">ctx.select(…)</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .innerJoin(PRODUCTLINEDETAIL)</pre>
			<pre class="source-code">   .onKey(PRODUCTLINEDETAIL_PRODUCTLINE_FK)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, the rendered<a id="_idIndexMarker502"/> SQL is as follows:</p>
			<pre class="source-code">SELECT ... </pre>
			<pre class="source-code">FROM [classicmodels].[dbo].[productline] </pre>
			<pre class="source-code">JOIN </pre>
			<pre class="source-code">     [classicmodels].[dbo].[productlinedetail] </pre>
			<pre class="source-code">  ON </pre>
			<pre class="source-code">   ([classicmodels].[dbo].[productlinedetail].[product_line] = </pre>
			<pre class="source-code">    [classicmodels].[dbo].[productline].[product_line] </pre>
			<pre class="source-code">  AND </pre>
			<pre class="source-code">    [classicmodels].[dbo].[productlinedetail].[code] = </pre>
			<pre class="source-code">    [classicmodels].[dbo].[productline].[code]) </pre>
			<p>But despite its appeal, this method can lead into issues. As Lukas Eder shared here: "<em class="italic">The </em><strong class="source-inline">onKey()</strong><em class="italic"> method is not type-safe, and can break in subtle ways, when tables are modified.</em>" </p>
			<p>More examples are available in the application named <em class="italic">JoinOnKey</em>. For now, let's continue with more types of <strong class="source-inline">JOIN</strong>s. </p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Practicing more types of JOINs</h1>
			<p>Next, let's cover more <strong class="source-inline">JOIN</strong>s, such as Implicit/Self Joins, <strong class="source-inline">NATURAL JOIN</strong>, <strong class="source-inline">STRAIGHT JOIN</strong>, Semi/Anti Joins, and <strong class="source-inline">LATERAL</strong> Joins. Let's continue with Implicit/Self Joins.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Implicit and Self Join</h2>
			<p>Implicit and Self Joins can be easily expressed in jOOQ via type-safe navigation methods produced by the jOOQ generator in classes that mirror the database tables. Let's dissect this aspect of Implicit Joins.</p>
			<h3>Implicit Join</h3>
			<p>As an example, an <a id="_idIndexMarker503"/>explicit join that<a id="_idIndexMarker504"/> fetches a parent table's column from a given child table can be expressed as an Implicit Join. Here is the explicit join:</p>
			<pre class="source-code">SELECT o.office_code, e.first_name, e.last_name</pre>
			<pre class="source-code">FROM employee AS e</pre>
			<pre class="source-code">JOIN office AS o ON e.office_code = o.office_code</pre>
			<p>Here is the less verbose Implicit Join version:</p>
			<pre class="source-code">SELECT e.office.office_code, e.first_name, e.last_name</pre>
			<pre class="source-code">FROM employee AS e</pre>
			<p>If we check the generated Java-based schema, then we notice that the <strong class="source-inline">jooq.generated.tables.Employee</strong> class mirroring the <strong class="source-inline">EMPLOYEE</strong> table contains a method named <strong class="source-inline">office()</strong> especially for expressing this syntax. Here is the previous Implicit Join, written via the jOOQ DSL API:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.office().OFFICE_CODE, </pre>
			<pre class="source-code">           EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here is another<a id="_idIndexMarker505"/> example that chains several navigation methods to express an Implicit Join, starting<a id="_idIndexMarker506"/> from the <strong class="source-inline">ORDERDETAIL</strong> table:</p>
			<pre class="source-code">ctx.select(                      </pre>
			<pre class="source-code">      ORDERDETAIL.order().customer().employee().OFFICE_CODE,</pre>
			<pre class="source-code">      ORDERDETAIL.order().customer().CUSTOMER_NAME,</pre>
			<pre class="source-code">      ORDERDETAIL.order().SHIPPED_DATE,       </pre>
			<pre class="source-code">      ORDERDETAIL.order().STATUS,</pre>
			<pre class="source-code">      ORDERDETAIL.QUANTITY_ORDERED, ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .orderBy(ORDERDETAIL.order().customer().CUSTOMER_NAME)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The names of these navigation methods correspond to the parent table name. Here is another example of writing an Implicit Join in a m:n relationship. If we think to an m:n relationship from the relationship table then we see two to-one relationships that we exploit as follows (between <strong class="source-inline">MANAGER</strong> and <strong class="source-inline">OFFICE</strong> there is a many-to-many relationship):</p>
			<pre class="source-code">ctx.select(OFFICE_HAS_MANAGER.manager().fields())</pre>
			<pre class="source-code">   .from(OFFICE_HAS_MANAGER)</pre>
			<pre class="source-code">   .where(OFFICE_HAS_MANAGER.office().OFFICE_CODE.eq("6"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Notice that the Implicit Joins covered in this section are <em class="italic">foreign key path-based</em>. Most probably, you are also familiar with Implicit Joins where you enlist all the tables you want to fetch data from in the <strong class="source-inline">FROM</strong> clause followed by the <strong class="source-inline">WHERE</strong> clause having conditions based on primary/foreign <a id="_idIndexMarker507"/>keys values for filtering the result. Here is an example of <a id="_idIndexMarker508"/>jOOQ code for such an Implicit Join:</p>
			<pre class="source-code">ctx.select(OFFICE.OFFICE_CODE, </pre>
			<pre class="source-code">           EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(OFFICE, EMPLOYEE)</pre>
			<pre class="source-code">   .where(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE))</pre>
			<pre class="source-code">   .orderBy(OFFICE.OFFICE_CODE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Nevertheless, note that these kind of Implicit Joins are quite prone to human mistakes, and it is better to rely on the ANSI JOIN syntax by explicitly using the <strong class="source-inline">JOIN</strong> keyword. Let me take advantage of this context to say that whenever you have old code that should be updated to an ANSI JOIN, you can rely on jOOQ. Besides the jOOQ DSL API, you can check out <a href="https://www.jooq.org/translate">https://www.jooq.org/translate</a>, and for a quick and neat guide, read this article: <a href="https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/">https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/</a>.</p>
			<p>In the absence of explicit foreign keys in the schema for whatever reasons (including the tables are actually views), users of the commercial editions can specify synthetic foreign keys to the Code Generator as you can see in <a href="B16833_11.xhtml#_idTextAnchor209"><em class="italic">Chapter 11</em></a>, <em class="italic">jOOQ keys</em>.</p>
			<p>Please, consider the jOOQ manual and <a href="https://github.com/jOOQ/jOOQ/issues/12037">https://github.com/jOOQ/jOOQ/issues/12037</a> for covering the limitations of Implicit Joins support. Leaving the context of Implicit Joins, the jOOQ navigation methods are useful for expressing Self Joins as well.  </p>
			<h3>Self Join</h3>
			<p>Whenever a table<a id="_idIndexMarker509"/> is joined <a id="_idIndexMarker510"/>with itself, we can rely on Self Joins. Writing a Self Join is done via a navigation method that has the same name as the table itself. For example, here is a Self Join that fetches a result set containing the name of each employee and the name of their boss (<strong class="source-inline">EMPLOYEE.REPORTS_TO</strong>):</p>
			<pre class="source-code">ctx.select(concat(EMPLOYEE.FIRST_NAME, inline(" "), </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME).as("employee"),</pre>
			<pre class="source-code">           concat(EMPLOYEE.employee().FIRST_NAME, inline(" "), </pre>
			<pre class="source-code">           EMPLOYEE.employee().LAST_NAME).as("reports_to"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In the bundled code, <em class="italic">ImplicitAndSelfJoin</em>, you can practice more examples with implicit and Self Joins.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>NATURAL JOIN</h2>
			<p>Earlier, we<a id="_idIndexMarker511"/> used the <strong class="source-inline">JOIN … USING</strong> syntax by enlisting the fields whose <a id="_idIndexMarker512"/>names are common to both tables (the left and right tables of a join operation) and should be rendered in the condition of the <strong class="source-inline">ON</strong> clause. Alternatively, we can rely on <strong class="source-inline">NATURAL JOIN</strong>, which doesn't require any <strong class="source-inline">JOIN</strong> criteria. This leads to a minimalist syntax but also makes our query a sword with two edges.</p>
			<p>Basically, <strong class="source-inline">NATURAL JOIN</strong> automatically identifies all the columns that share the same name from both joined tables and use them to define the <strong class="source-inline">JOIN</strong> criteria. This can be quite useful when the primary/foreign keys columns share the same names, as in the following example:</p>
			<pre class="source-code">ctx.select().from(EMPLOYEE)</pre>
			<pre class="source-code">   .naturalJoin(SALE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The jOOQ API for <strong class="source-inline">NATURAL JOIN</strong> relies on the <strong class="source-inline">naturalJoin()</strong> method. Next to this method, we have the methods corresponding to <strong class="source-inline">LEFT</strong>/<strong class="source-inline">RIGHT</strong>/<strong class="source-inline">FULL NATURAL OUTER JOIN</strong> as <strong class="source-inline">naturalLeftOuterJoin()</strong>, <strong class="source-inline">naturalRightOuterJoin()</strong>, and <strong class="source-inline">naturalFullOuterJoin()</strong>. Also, you may like to read the article at <a href="https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/">https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/</a> about using <strong class="source-inline">NATURAL FULL JOIN</strong> to compare two tables. You can see all these at work in the bundled code.</p>
			<p>For our example, the rendered SQL for the PostgreSQL dialect is as follows:</p>
			<pre class="source-code">SELECT "public"."employee"."employee_number", ...</pre>
			<pre class="source-code">       "public"."sale"."sale_id", ...</pre>
			<pre class="source-code">FROM "public"."employee"</pre>
			<pre class="source-code">NATURAL JOIN "public"."sale"</pre>
			<p>The <strong class="source-inline">EMPLOYEE</strong> and <strong class="source-inline">SALE</strong> tables <a id="_idIndexMarker513"/>share a single column name, <strong class="source-inline">EMPLOYEE_NUMBER</strong> – the primary key in <strong class="source-inline">EMPLOYEE</strong> and the foreign key in <strong class="source-inline">SALE</strong>. This column is used <a id="_idIndexMarker514"/>behind the scenes by <strong class="source-inline">NATURAL JOIN</strong> for filtering the result, which is the expected behavior.</p>
			<p>But, remember that <strong class="source-inline">NATURAL JOIN</strong> picks up all columns that share the same name, not only the primary/foreign key columns, therefore this <strong class="source-inline">JOIN</strong> may produce undesirable results. For instance, if we join the <strong class="source-inline">PAYMENT</strong> and <strong class="source-inline">BANK_TRANSACTION</strong> tables, then <strong class="source-inline">NATURAL JOIN</strong> will use the common composite key (<strong class="source-inline">CUSTOMER_NUMBER</strong>, <strong class="source-inline">CHECK_NUMBER</strong>) but will also use the <strong class="source-inline">CACHING_DATE</strong> column. If this is not our intention, then <strong class="source-inline">NATURAL JOIN</strong> is not the proper choice. Expecting that only the (<strong class="source-inline">CUSTOMER_NUMBER</strong>, <strong class="source-inline">CHECK_NUMBER</strong>) is used is a wrong assumption, and it is recommended to rely on the <strong class="source-inline">ON</strong> clause or the jOOQ <strong class="source-inline">onKey()</strong> method:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(PAYMENT.innerJoin(BANK_TRANSACTION).onKey())</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>On the other hand, if we expect that only the <strong class="source-inline">CACHING_DATE</strong> column will be used (which is hard to believe), then the <strong class="source-inline">USING</strong> clause can be a good alternative:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(PAYMENT.innerJoin(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .using(PAYMENT.CACHING_DATE))                       </pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The <strong class="source-inline">USING</strong> clause is useful if we need any custom combination of columns that share the same name. On the other hand, <strong class="source-inline">NATURAL JOIN</strong> is considerably more prone to issues, since any schema changes that lead to a new matching column name will cause <strong class="source-inline">NATURAL JOIN</strong> to combine that new column as well.</p>
			<p>It's also worth keeping in mind that Oracle doesn't accept that the columns used by <strong class="source-inline">NATURAL JOIN</strong> for filtering the result have qualifiers (<em class="italic">ORA-25155 – column used in NATURAL join cannot have qualifiers</em>). In this context, using the jOOQ Java-based schema with default settings comes with some issues. For instance, the expression <strong class="source-inline">ctx.select().from(EMPLOYEE).naturalJoin(SALE)…</strong> results in ORA-25155, since, by default, jOOQ qualifies the columns rendered in <strong class="source-inline">SELECT</strong>, including the common <strong class="source-inline">EMPLOYEE_NUMBER</strong> column, which is used by <strong class="source-inline">NATURAL JOIN</strong>. A quick workaround consists<a id="_idIndexMarker515"/> of explicitly<a id="_idIndexMarker516"/> rendering <strong class="source-inline">*</strong> via <strong class="source-inline">asterisk()</strong> instead of the columns list:</p>
			<pre class="source-code">ctx.select(asterisk())</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .naturalJoin(TOP3PRODUCT)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or, we can avoid using Java-based schema and write this:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(table("EMPLOYEE"))</pre>
			<pre class="source-code">   .naturalJoin(table("SALE"))</pre>
			<pre class="source-code">   .fetch()</pre>
			<p>Unqualified references to a common column are considered to belong to the left-hand side table if the join is <strong class="source-inline">INNER</strong>/<strong class="source-inline">LEFT OUTER JOIN</strong>, or to the right-hand side table if it is <strong class="source-inline">RIGHT OUTER JOIN</strong>.</p>
			<p>Alternatively, the Oracle <strong class="source-inline">NATURAL JOIN</strong> is the same <a id="_idIndexMarker517"/>as the Oracle proprietary<a id="_idIndexMarker518"/> Equi Join with a join condition (an Equi Join relies on a join condition containing an equality operator).</p>
			<p>As usual, you can practice all these examples and more in the bundled code. The application is named <em class="italic">NaturalJoin</em>. Next, let's tackle <strong class="source-inline">STRAIGHT JOIN</strong>.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>STRAIGHT JOIN</h2>
			<p>Right<a id="_idIndexMarker519"/> from the start, we have to<a id="_idIndexMarker520"/> mention that <strong class="source-inline">STRAIGHT JOIN</strong> is specific to MySQL.</p>
			<p>Basically, <strong class="source-inline">STRAIGHT JOIN</strong> instructs MySQL to always read the left-hand side table before the right-hand side table of <strong class="source-inline">JOIN</strong>. In this context, <strong class="source-inline">STRAIGHT JOIN</strong> may be useful to affect the execution plan chosen by MySQL for a certain <strong class="source-inline">JOIN</strong>. Whenever we consider that the query optimizer has put the <strong class="source-inline">JOIN</strong> tables in the wrong order, we can affect this order via <strong class="source-inline">STRAIGHT JOIN</strong>. </p>
			<p>For instance, let's assume that the <strong class="source-inline">PRODUCT</strong> table has 5,000 rows, the <strong class="source-inline">ORDERDETAIL</strong> table has 200,000,000 rows, the <strong class="source-inline">ORDER</strong> table has 3,000 rows, and we have a join, as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, ORDER.ORDER_ID)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .innerJoin(ORDERDETAIL).on(</pre>
			<pre class="source-code">       ORDERDETAIL.PRODUCT_ID.eq(PRODUCT.PRODUCT_ID))</pre>
			<pre class="source-code">   .innerJoin(ORDER).on(</pre>
			<pre class="source-code">       ORDER.ORDER_ID.eq(ORDERDETAIL.ORDER_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Now, MySQL may or may not take into account the size of the intersection between <strong class="source-inline">ORDER.ORDER_ID</strong> and <strong class="source-inline">ORDERDETAIL.ORDER_ID</strong> versus <strong class="source-inline">PRODUCT.PRODUCT_ID</strong> and <strong class="source-inline">ORDERDETAIL.PRODUCT_ID</strong>. If the join between <strong class="source-inline">ORDERDETAIL</strong> and <strong class="source-inline">ORDER</strong> returns just as many rows as <strong class="source-inline">ORDERDETAIL</strong>, then this is not an optimal choice. And if starting the join with <strong class="source-inline">PRODUCT</strong> will filter down <strong class="source-inline">ORDERDETAIL</strong> to as many rows as <strong class="source-inline">PRODUCT</strong>, then this will be an optimal choice. This behavior can be <a id="_idIndexMarker521"/>enforced via the jOOQ <strong class="source-inline">straightJoin()</strong> method, which<a id="_idIndexMarker522"/> renders a <strong class="source-inline">STRAIGHT JOIN</strong> statement, as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, ORDER.ORDER_ID)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .straightJoin(ORDERDETAIL).on(</pre>
			<pre class="source-code">       ORDERDETAIL.PRODUCT_ID.eq(PRODUCT.PRODUCT_ID))</pre>
			<pre class="source-code">   .innerJoin(ORDER).on(</pre>
			<pre class="source-code">       ORDER.ORDER_ID.eq(ORDERDETAIL.ORDER_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In Oracle, the order of <strong class="source-inline">JOINs</strong> can be altered via <strong class="source-inline">/*+LEADING(a, b)*/</strong> hint. In jOOQ this kind of hints can be passed via <strong class="source-inline">hint()</strong>: </p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, ORDER.ORDER_ID) </pre>
			<pre class="source-code">   .hint("/*+LEADING(CLASSICMODELS.ORDERDETAIL </pre>
			<pre class="source-code">                     CLASSICMODELS.PRODUCT)*/") </pre>
			<pre class="source-code">   … // joins come here </pre>
			<p>In SQL Server this can be accomplished via <strong class="source-inline">OPTION (FORCE ORDER)</strong>: </p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, ORDER.ORDER_ID) </pre>
			<pre class="source-code">   … // joins come here </pre>
			<pre class="source-code">   .option("OPTION (FORCE ORDER)") </pre>
			<pre class="source-code">   .fetch(); </pre>
			<p>Nevertheless, as Lukas Eder shared here: "<em class="italic">MySQL's problems should have been made significantly less severe since they added hash join support. In any case, I think a disclaimer about premature optimization using hints could be added. With reasonable optimizers, hints should almost never be necessary anymore.</em>"</p>
			<p>You can see the rendered SQL by running the <em class="italic">StraightJoin</em> application available for MySQL. Next, let's cover Semi and Anti Joins.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Semi and Anti Joins</h2>
			<p>Semi and Anti Joins<a id="_idIndexMarker523"/> are two of the relational algebra operators that don't have a <a id="_idIndexMarker524"/>direct correspondent in SQL syntax. Apart from the case of using Cloudera Impala, which <a id="_idIndexMarker525"/>provides a native syntax for Semi/Anti Joins, we have to<a id="_idIndexMarker526"/> rely on workarounds. In this context, Semi Join can be emulated via <strong class="source-inline">EXISTS</strong>/<strong class="source-inline">IN</strong> and Anti Join via <strong class="source-inline">NOT EXISTS</strong>/<strong class="source-inline">NOT IN</strong> predicates.</p>
			<p>Since Semi/Anti Joins can be emulated via (<strong class="source-inline">NOT</strong>) <strong class="source-inline">EXISTS</strong>/(<strong class="source-inline">NOT</strong>) <strong class="source-inline">IN</strong> predicates, it means that we don't really join the right-hand side. In the case of a Semi Join, we just fetch the rows from the first table (left-hand side table) where there are matches found in the second table (right-hand side table), while in the case of Anti Join, we do exactly the opposite of the Semi Join; we just fetch the rows from the first table (the left-hand side table) where there are no matches found in the second table (the right-hand side table).</p>
			<p>For instance, let's fetch the names of all <strong class="source-inline">EMPLOYEE</strong> that have <strong class="source-inline">CUSTOMER</strong>. Accomplishing this via a Semi Join emulated via the <strong class="source-inline">EXISTS</strong> predicate can be done in SQL as follows:</p>
			<pre class="source-code">SELECT employee.first_name, employee.last_name FROM employee</pre>
			<pre class="source-code">WHERE EXISTS</pre>
			<pre class="source-code">    (SELECT 1 FROM customer </pre>
			<pre class="source-code">     WHERE employee.employee_number </pre>
			<pre class="source-code">              = customer.sales_rep_employee_number);</pre>
			<p>In the bundled<a id="_idIndexMarker527"/> code, you can see how to express this SQL via the jOOQ DSL API. In addition, you<a id="_idIndexMarker528"/> can practice this use case emulated via the <strong class="source-inline">IN</strong> predicate. For now, let's <a id="_idIndexMarker529"/>use the jOOQ approach, which fills up the gap in expressiveness and<a id="_idIndexMarker530"/> enforces the clear intention of using a Semi Join via the <strong class="source-inline">leftSemiJoin()</strong> method. This jOOQ method saves us a lot of headaches – having neat code that is always emulated correctly in different SQL dialects and no brain-teasing in handling complex cases such as nesting <strong class="source-inline">EXISTS</strong>/<strong class="source-inline">IN</strong> predicates will make you fall in love with this method:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .leftSemiJoin(CUSTOMER)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(</pre>
			<pre class="source-code">       CUSTOMER.SALES_REP_EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This is just awesome! Check out the bundled code, <em class="italic">SemiAndAntiJoin</em>, to see more examples about chaining and/or nesting Semi Joins via the jOOQ DSL API. Every time, check out the rendered SQL and give a big thanks to jOOQ for it!</p>
			<p>Next, let's focus on Anti Join. The Anti Join is the opposite of the Semi Join and is emulated via the <strong class="source-inline">NOT EXISTS</strong>/<strong class="source-inline">NOT IN</strong> predicates. For example, let's write an SQL representing an Anti Join to fetch the names of all <strong class="source-inline">EMPLOYEE</strong> that don't have <strong class="source-inline">CUSTOMER</strong> via <strong class="source-inline">NOT EXISTS</strong>:</p>
			<pre class="source-code">SELECT employee.first_name, employee.last_name FROM employee</pre>
			<pre class="source-code">WHERE NOT (EXISTS</pre>
			<pre class="source-code">       (SELECT 1</pre>
			<pre class="source-code">       FROM customer</pre>
			<pre class="source-code">       WHERE employee.employee_number </pre>
			<pre class="source-code">               = customer.sales_rep_employee_number))</pre>
			<p>In the bundled <a id="_idIndexMarker531"/>code, you can see how to express this SQL via the jOOQ DSL API and the same <a id="_idIndexMarker532"/>example <a id="_idIndexMarker533"/>based on the <strong class="source-inline">NOT IN</strong> predicate. Nevertheless, I strongly <a id="_idIndexMarker534"/>encourage you to avoid <strong class="source-inline">NOT IN</strong> and opt for <strong class="source-inline">NOT EXISTS</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Most probably, you already know this, but just as a quick reminder, let's mention that the <strong class="source-inline">EXISTS</strong> and <strong class="source-inline">IN</strong> predicates are equivalent, but the <strong class="source-inline">NOT EXISTS</strong> and <strong class="source-inline">NOT IN</strong> predicates are not because the <strong class="source-inline">NULL</strong> values (if any) lead to undesirable results. For more details, please read this short but essential article: <a href="https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/">https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/</a>.</p>
			<p>Alternatively, and even better, use the jOOQ Anti Join represented by the <strong class="source-inline">leftAntiJoin()</strong> method:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .leftAntiJoin(CUSTOMER)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(</pre>
			<pre class="source-code">       CUSTOMER.SALES_REP_EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Check out the rendered SQL and more examples in the application named <em class="italic">SemiAndAntiJoin</em>.</p>
			<p>A typical problem solved by Anti Joins refers to relational division or simply division. This is another operator of relational algebra without a direct correspondent in SQL syntax. In short, division is the inverse of the <strong class="source-inline">CROSS JOIN</strong> operation. </p>
			<p>For <a id="_idIndexMarker535"/>instance, let's<a id="_idIndexMarker536"/> consider the <strong class="source-inline">ORDERDETAIL</strong> and <strong class="source-inline">TOP3PRODUCT</strong> tables. While <strong class="source-inline">CROSS JOIN</strong> gives us the Cartesian product as <strong class="source-inline">ORDERDETAIL x TOP3PRODUCT</strong>, the division gives us <strong class="source-inline">ORDERDETAIL ÷ TOP3PRODUCT</strong> or <strong class="source-inline">TOP3PRODUCT ÷ ORDERDETAIL</strong>. Let's assume that we want the IDs of all orders that contain <a id="_idIndexMarker537"/>at least three products contained in <strong class="source-inline">TOP3PRODUCT</strong>. This kind of task<a id="_idIndexMarker538"/> is a division and is commonly solved via two nested Anti Joins. The jOOQ code that solves this problem is as follows:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(ctx.selectDistinct(ORDERDETAIL.ORDER_ID.as("OID"))</pre>
			<pre class="source-code">   .from(ORDERDETAIL).asTable("T1")</pre>
			<pre class="source-code">   .leftAntiJoin(TOP3PRODUCT    </pre>
			<pre class="source-code">     .leftAntiJoin(ORDERDETAIL)</pre>
			<pre class="source-code">     .on(field("T", "OID")).eq(ORDERDETAIL.ORDER_ID)</pre>
			<pre class="source-code">       .and(TOP3PRODUCT.PRODUCT_ID</pre>
			<pre class="source-code">         .eq(ORDERDETAIL.PRODUCT_ID))))</pre>
			<pre class="source-code">   .on(trueCondition()))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>This is cool and much less verbose than writing the same thing via <strong class="source-inline">NOT EXISTS</strong>. But that's not all! jOOQ comes with an even more elegant solution that can be used to express divisions. This solution uses the <strong class="source-inline">divideBy()</strong> and <strong class="source-inline">returning()</strong> methods to express a division in a concise, expressive, and very intuitive way. Check out the following code that can replace the previous code:</p>
			<pre class="source-code">ctx.select().from(ORDERDETAIL</pre>
			<pre class="source-code">   .divideBy(TOP3PRODUCT)</pre>
			<pre class="source-code">   .on(field(TOP3PRODUCT.PRODUCT_ID).eq(</pre>
			<pre class="source-code">             ORDERDETAIL.PRODUCT_ID))                      </pre>
			<pre class="source-code">   .returning(ORDERDETAIL.ORDER_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Check out this example and another one about finding the orders that contain at least the products of a given order in the <em class="italic">BootAntiJoinDivision</em> application.</p>
			<p>As Lukas Eder pointed out here: "<em class="italic">If you want to see how x is the inverse of ÷, you can choose two different tables, for instance A x B = C and C ÷ B = A</em>". </p>
			<p>Next, let’s cover the <strong class="source-inline">LATERAL</strong>/<strong class="source-inline">APPLY</strong> Join.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>LATERAL/APPLY Join</h2>
			<p>The last topic <a id="_idIndexMarker539"/>covered in this chapter refers to the <strong class="source-inline">LATERAL</strong>/<strong class="source-inline">APPLY</strong> Join. This is part of <a id="_idIndexMarker540"/>standard SQL and is quite similar to a correlated subquery that allows us to return more than one row and/or column or to the Java <strong class="source-inline">Stream.flatMap()</strong>. Mainly, a lateral inner subquery sits on the right-hand side of <strong class="source-inline">JOIN</strong> (<strong class="source-inline">INNER</strong>, <strong class="source-inline">OUTER</strong>, and so on), and it can be materialized as a classical subquery, a derived table, a function call, an array unnesting, and so on. Its power consists of the fact that it can refer to (or <em class="italic">laterally</em> access) tables/columns from the left-hand side to determine which rows to retain. A <strong class="source-inline">LATERAL</strong> Join iterates through each row on the left-hand side, evaluating the inner subquery (the right-hand side) for each row, like a typical for-each loop. The rows returned by the inner subquery are retained to the result of the join with the outer query. The <strong class="source-inline">LATERAL</strong> keyword is essential because, without it, each subquery is evaluated separately (independently) and can't access columns from the left-hand side (from the <strong class="source-inline">FROM</strong> clause).</p>
			<p>For example, selecting all <strong class="source-inline">OFFICE</strong> that has <strong class="source-inline">DEPARTMENT</strong> can be done via the <strong class="source-inline">LATERAL</strong> Join:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE, lateral(select().from(DEPARTMENT)</pre>
			<pre class="source-code">   .where(OFFICE.OFFICE_CODE.eq(</pre>
			<pre class="source-code">          DEPARTMENT.OFFICE_CODE))).as("t"))</pre>
			<pre class="source-code">   .fetch()</pre>
			<p>As you can see, the jOOQ DSL API provides the <strong class="source-inline">lateral()</strong> method for shaping <strong class="source-inline">LATERAL</strong> Joins. The SQL rendered for the MySQL dialect is as follows:</p>
			<pre class="source-code">SELECT `classicmodels`.`office`.`office_code`,...</pre>
			<pre class="source-code">       `t`.`department_id`,</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">FROM `classicmodels`.`office`,</pre>
			<pre class="source-code">  LATERAL</pre>
			<pre class="source-code">   (SELECT `classicmodels`.`department`.`department_id`,...</pre>
			<pre class="source-code">    FROM `classicmodels`.`department`</pre>
			<pre class="source-code">    WHERE `classicmodels`.`office`.`office_code` </pre>
			<pre class="source-code">        = `classicmodels`.`department`.`office_code`) AS `t`</pre>
			<p>Without an <a id="_idIndexMarker541"/>explicit <strong class="source-inline">JOIN</strong>, you would expect that <strong class="source-inline">CROSS JOIN</strong> (<strong class="source-inline">INNER JOIN ON true / INNER JOIN IN 1=1</strong>) is <a id="_idIndexMarker542"/>automatically inferred. Writing the previous query via <strong class="source-inline">LEFT OUTER JOIN LATERAL</strong> requires a dummy <strong class="source-inline">ON true / ON 1=1</strong> clause, as follows:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .leftOuterJoin(lateral(select().from(DEPARTMENT)</pre>
			<pre class="source-code">      .where(OFFICE.OFFICE_CODE</pre>
			<pre class="source-code">          .eq(DEPARTMENT.OFFICE_CODE))).as("t"))</pre>
			<pre class="source-code">      .on(trueCondition())</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>A <strong class="source-inline">LATERAL</strong> Join has several use cases where it fits like a glove. For instance, it can be used for lateral unnesting of the array columns, for finding TOP-N per <em class="italic">Foo</em> (joining TOP-N query to a normal table), and it works nicely in combination with the so-called table-valued functions.</p>
			<h3>Unnesting the array columns</h3>
			<p>If you are an Oracle or <a id="_idIndexMarker543"/>PostgreSQL fan, then you know about their support for nested arrays (or nested collections). In PostgreSQL, we can declare a column of type array exactly as any other type but suffixed with square brackets – <strong class="source-inline">[]</strong> (for example, <strong class="source-inline">text[]</strong>). Since Oracle recognizes only nominal array types, we have to create them first via <strong class="source-inline">CREATE TYPE</strong>. I will not insist on this pure SQL aspect, since our goal is to jump into jOOQ DSL API usage.</p>
			<p>So, let's consider the <strong class="source-inline">DEPARTMENT</strong> table, which has an array column named <strong class="source-inline">TOPIC</strong>. For each department, we have a list of topics (area of activities), and more departments may have interleaved topics. For instance, for the <strong class="source-inline">Sale</strong> department, we have four topics – <strong class="source-inline">'commerce'</strong>, <strong class="source-inline">'trade'</strong>, <strong class="source-inline">'sellout'</strong>, and <strong class="source-inline">'transaction'</strong>.</p>
			<p>Now, let's assume that we want to fetch the departments that have in common the <strong class="source-inline">'commerce'</strong> and <strong class="source-inline">'business'</strong> topics. For this, we can write a <strong class="source-inline">LATERAL</strong> Join via the jOOQ DSL API using the <strong class="source-inline">lateral()</strong> method, and we unnest the array (transform the array into a useable/queryable table) via the <strong class="source-inline">unnest()</strong> method, as follows:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(DEPARTMENT, lateral(select(field(name("t", "topic")))</pre>
			<pre class="source-code">      .from(unnest(DEPARTMENT.TOPIC).as("t", "topic"))</pre>
			<pre class="source-code">      .where(field(name("t", "topic"))</pre>
			<pre class="source-code">         .in("commerce", "business"))).as("r"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>For the PostgreSQL dialect, the rendered SQL is as follows:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  "public"."department"."department_id",</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  "public"."department"."accrued_liabilities",</pre>
			<pre class="source-code">  "r"."topic" </pre>
			<pre class="source-code">FROM</pre>
			<pre class="source-code">  "public"."department",</pre>
			<pre class="source-code"> LATERAL (SELECT</pre>
			<pre class="source-code">            "t"."topic" </pre>
			<pre class="source-code">           FROM</pre>
			<pre class="source-code">            unnest("public"."department"."topic") </pre>
			<pre class="source-code">               AS "t" ("topic") </pre>
			<pre class="source-code">           WHERE</pre>
			<pre class="source-code">            "t"."topic" IN (?, ?)) AS "r"</pre>
			<p>Note that MySQL and <a id="_idIndexMarker544"/>SQL Server don't have support for array (collection) columns, but we can still declare anonymously typed arrays that can be unnested via the same jOOQ <strong class="source-inline">unnest()</strong> method.  Next, let's talk about solving TOP-N per <em class="italic">Foo</em> tasks.</p>
			<h3>Solving TOP-N per Foo</h3>
			<p>While solving TOP-N problems <a id="_idIndexMarker545"/>over the entire dataset can be quite challenging, solving TOP-N per <em class="italic">Foo</em> problems can be really hard to digest. Fortunately, the <strong class="source-inline">LATERAL</strong> Join fits perfectly for these kinds of problems. For instance, fetching TOP-3 sales per employee can be expressed in jOOQ as follows:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.EMPLOYEE_NUMBER, EMPLOYEE.FIRST_NAME,</pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, field(name("t", "sales")))</pre>
			<pre class="source-code">   .from(EMPLOYEE, </pre>
			<pre class="source-code">         lateral(select(SALE.SALE_.as("sales"))</pre>
			<pre class="source-code">                    .from(SALE)</pre>
			<pre class="source-code">                    .where(EMPLOYEE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">                       .eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">                    .orderBy(SALE.SALE_.desc())</pre>
			<pre class="source-code">                    .limit(3).asTable("t")))</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The fact that the <strong class="source-inline">LATERAL</strong> Join allows us to access the <strong class="source-inline">EMPLOYEE.EMPLOYEE_NUMBER</strong> field/column does all the magic! The rendered SQL for MySQL dialect is as follows:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  `classicmodels`.`employee`.`employee_number`,</pre>
			<pre class="source-code">  `classicmodels`.`employee`.`first_name`,</pre>
			<pre class="source-code">  `classicmodels`.`employee`.`last_name`,</pre>
			<pre class="source-code">  `t`.`sales` </pre>
			<pre class="source-code">FROM `classicmodels`.`employee`,</pre>
			<pre class="source-code">LATERAL (SELECT `classicmodels`.`sale`.`sale` as `sales` </pre>
			<pre class="source-code">         FROM `classicmodels`.`sale` </pre>
			<pre class="source-code">         WHERE `classicmodels`.`employee`.`employee_number` </pre>
			<pre class="source-code">             = `classicmodels`.`sale`.`employee_number` </pre>
			<pre class="source-code">        ORDER BY `classicmodels`.`sale`.`sale` desc limit ?) </pre>
			<pre class="source-code">   as `t` </pre>
			<pre class="source-code">ORDER BY `classicmodels`.`employee`.`employee_number`</pre>
			<p>If we think of the <a id="_idIndexMarker546"/>derived table obtained via the inner <strong class="source-inline">SELECT</strong> as a table-valued function that has the employee number as an argument, then, in Oracle, we can write this:</p>
			<pre class="source-code">CREATE TYPE "TABLE_RES_OBJ" AS OBJECT (SALES FLOAT); </pre>
			<pre class="source-code">CREATE TYPE "TABLE_RES" AS TABLE OF TABLE_RES_OBJ;</pre>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE FUNCTION    </pre>
			<pre class="source-code"> "TOP_THREE_SALES_PER_EMPLOYEE" ("employee_nr" IN NUMBER) </pre>
			<pre class="source-code">  RETURN TABLE_RES IS</pre>
			<pre class="source-code">    "table_result" TABLE_RES;</pre>
			<pre class="source-code">  BEGIN</pre>
			<pre class="source-code">    SELECT</pre>
			<pre class="source-code">        TABLE_RES_OBJ("SALE"."SALE") "sales"</pre>
			<pre class="source-code">    BULK COLLECT</pre>
			<pre class="source-code">    INTO "table_result"</pre>
			<pre class="source-code">    FROM</pre>
			<pre class="source-code">        "SALE"</pre>
			<pre class="source-code">    WHERE</pre>
			<pre class="source-code">        "employee_nr" = "SALE"."EMPLOYEE_NUMBER"</pre>
			<pre class="source-code">    ORDER BY</pre>
			<pre class="source-code">        "SALE"."SALE" DESC</pre>
			<pre class="source-code">    FETCH NEXT 3 ROWS ONLY;</pre>
			<pre class="source-code">    RETURN "table_result";</pre>
			<pre class="source-code">  END;</pre>
			<p>Next, we can use a <strong class="source-inline">LATERAL</strong> Join to call <a id="_idIndexMarker547"/>this function. The jOOQ code is as follows:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.EMPLOYEE_NUMBER, EMPLOYEE.FIRST_NAME,</pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, field(name("T", "SALES")))</pre>
			<pre class="source-code">   .from(EMPLOYEE, lateral(select().from(</pre>
			<pre class="source-code">         TOP_THREE_SALES_PER_EMPLOYEE</pre>
			<pre class="source-code">            .call(EMPLOYEE.EMPLOYEE_NUMBER)).asTable("T")))</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The rendered SQL for Oracle is as follows:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  "CLASSICMODELS"."EMPLOYEE"."EMPLOYEE_NUMBER",</pre>
			<pre class="source-code">  "CLASSICMODELS"."EMPLOYEE"."FIRST_NAME",</pre>
			<pre class="source-code">  "CLASSICMODELS"."EMPLOYEE"."LAST_NAME",</pre>
			<pre class="source-code">  "T"."SALES" </pre>
			<pre class="source-code">FROM "CLASSICMODELS"."EMPLOYEE",</pre>
			<pre class="source-code">     LATERAL (SELECT </pre>
			<pre class="source-code">       "TOP_THREE_SALES_PER_EMPLOYEE"."SALES" </pre>
			<pre class="source-code">     FROM</pre>
			<pre class="source-code">       table("CLASSICMODELS"."TOP_THREE_SALES_PER_EMPLOYEE"</pre>
			<pre class="source-code">            ("CLASSICMODELS"."EMPLOYEE"."EMPLOYEE_NUMBER"))    </pre>
			<pre class="source-code">             "TOP_THREE_SALES_PER_EMPLOYEE") "T" </pre>
			<pre class="source-code">ORDER BY "CLASSICMODELS"."EMPLOYEE"."EMPLOYEE_NUMBER"</pre>
			<p>The <strong class="source-inline">TOP_THREE_SALES_PER_EMPLOYEE</strong> static field was generated by the jOOQ generator and is basically an ordinary table placed in the <strong class="source-inline">jooq.generated.tables</strong> package under the name <strong class="source-inline">TopThreeSalesPerEmployee</strong>. It can be used in the <strong class="source-inline">FROM</strong> clause of <strong class="source-inline">SELECT</strong> like any other table. Nevertheless, note that we have access to a method named <strong class="source-inline">call()</strong>, which is used for calling (with arguments) this table-valued function. However, while most databases treat table-valued functions as ordinary tables, in Oracle, it is quite<a id="_idIndexMarker548"/> common to treat them as standalone routines. In this context, jOOQ has a flag setting that allows us to indicate whether table-valued functions should be treated as ordinary tables (<strong class="source-inline">true</strong>) or as plain routines (<strong class="source-inline">false</strong>). Depending on this setting, jOOQ places the generated code in tables-section or the routines-section. This setting is set to <strong class="source-inline">true</strong> in all supported databases except Oracle. To enable this, we have to set the following:</p>
			<pre class="source-code">Maven: &lt;tableValuedFunctions&gt;true&lt;/tableValuedFunctions&gt;</pre>
			<pre class="source-code">Gradle: database { tableValuedFunctions = true }</pre>
			<p>Or, programmatic:</p>
			<pre class="source-code">...withDatabase(new Database()</pre>
			<pre class="source-code">     .withTableValuedFunctions(true)</pre>
			<p>While the <strong class="source-inline">LATERAL</strong> keyword (which, by the way, is a pretty confusing word) can be used in MySQL, PostgreSQL, and Oracle, it cannot be used in SQL Server. Actually, SQL Server and Oracle have support for <strong class="source-inline">CROSS APPLY</strong> and <strong class="source-inline">OUTER APPLY</strong> via the <strong class="source-inline">APPLY</strong> keyword.</p>
			<h3>CROSS APPLY and OUTER APPLY</h3>
			<p>Specific to T-SQL, <strong class="source-inline">CROSS APPLY</strong>, and <strong class="source-inline">OUTER APPLY</strong> use the <a id="_idIndexMarker549"/>more suggestive <strong class="source-inline">APPLY</strong> keyword, which suggests<a id="_idIndexMarker550"/> that we apply a function to each table row. Mainly, <strong class="source-inline">CROSS APPLY</strong> is the same thing as <strong class="source-inline">CROSS JOIN LATERAL</strong>, and <strong class="source-inline">OUTER APPLY</strong> is the same thing as <strong class="source-inline">LEFT OUTER JOIN LATERAL</strong>. This is exactly how jOOQ will emulate <strong class="source-inline">CROSS</strong>/<strong class="source-inline">OUTER APPLY</strong> when they are not supported (for example, in PostgreSQL).</p>
			<p>I guess everyone agrees with Lukas Eder's statement: "<em class="italic">I find APPLY much more intuitive, especially when cross applying a table valued function. T CROSS APPLY F (T.X) means we're applying F to each row in T and create the cross product between T and the result of F. On the other hand, LATERAL is so weird, syntactically, especially this stupid requirement of writing ON TRUE all the time.</em>"</p>
			<p>At the beginning of this section, we wrote a <strong class="source-inline">LATERAL</strong> Join to select all <strong class="source-inline">OFFICE</strong> that has <strong class="source-inline">DEPARTMENT</strong>. Writing the same thing but using <strong class="source-inline">CROSS APPLY</strong> can be done via the jOOQ <strong class="source-inline">crossApply()</strong> method, like this:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE).crossApply(select()</pre>
			<pre class="source-code">                 .from(DEPARTMENT)</pre>
			<pre class="source-code">                 .where(OFFICE.OFFICE_CODE</pre>
			<pre class="source-code">                   .eq(DEPARTMENT.OFFICE_CODE)).asTable("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The render SQL for SQL Server is as follows:</p>
			<pre class="source-code">SELECT [classicmodels].[dbo].[office].[office_code], ...     </pre>
			<pre class="source-code">       [t].[department_id], ...</pre>
			<pre class="source-code">FROM [classicmodels].[dbo].[office] CROSS APPLY</pre>
			<pre class="source-code">  (SELECT [classicmodels].[dbo].[department].[department_id],  </pre>
			<pre class="source-code">          ...</pre>
			<pre class="source-code">   FROM [classicmodels].[dbo].[department]</pre>
			<pre class="source-code">   WHERE [classicmodels].[dbo].[office].[office_code] </pre>
			<pre class="source-code">       = [classicmodels].[dbo].[department].[office_code] ) [t]</pre>
			<p>Writing the previous query via <strong class="source-inline">LEFT OUTER JOIN LATERAL</strong> requires a dummy <strong class="source-inline">ON true/1=1</strong> clause, but using <strong class="source-inline">OUTER APPLY</strong> via the jOOQ <strong class="source-inline">outerApply()</strong> method eliminates this little inconvenience:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .outerApply(select()</pre>
			<pre class="source-code">                 .from(DEPARTMENT)</pre>
			<pre class="source-code">                 .where(OFFICE.OFFICE_CODE</pre>
			<pre class="source-code">                    .eq(DEPARTMENT.OFFICE_CODE)).asTable("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>And the SQL rendered for the SQL Server dialect is as follows:</p>
			<pre class="source-code">SELECT [classicmodels].[dbo].[office].[office_code], ...</pre>
			<pre class="source-code">       [t].[department_id], ...</pre>
			<pre class="source-code">FROM [classicmodels].[dbo].[office] OUTER APPLY</pre>
			<pre class="source-code">  (SELECT [classicmodels].[dbo].[department].[department_id], </pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">   FROM [classicmodels].[dbo].[department]</pre>
			<pre class="source-code">   WHERE [classicmodels].[dbo].[office].[office_code] </pre>
			<pre class="source-code">     = [classicmodels].[dbo].[department].[office_code] ) [t]</pre>
			<p>Done! In the<a id="_idIndexMarker551"/> bundled code, you can practice examples of <strong class="source-inline">cross</strong>/<strong class="source-inline">outerApply()</strong> and <a id="_idIndexMarker552"/>table-valued functions as well.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In the examples of this chapter, we have used <strong class="source-inline">fooJoin(TableLike&lt;?&gt; table)</strong>and <strong class="source-inline">cross</strong>/<strong class="source-inline">outerApply(TableLike&lt;?&gt; table)</strong>, but the jOOQ API also contains other flavors, such as <strong class="source-inline">fooJoin(String sql)</strong>, <strong class="source-inline">cross</strong>/<strong class="source-inline">outerApply(String sql)</strong>, <strong class="source-inline">fooJoin(SQL sql)</strong>, <strong class="source-inline">cross</strong>/<strong class="source-inline">outerApply(SQL sql</strong>), <strong class="source-inline">fooJoin(String sql, Object... bindings)</strong>, <strong class="source-inline">cross</strong>/<strong class="source-inline">outerApply(String sql, Object... bindings)</strong>, <strong class="source-inline">fooJoin(String sql, QueryPart... parts)</strong>, and <strong class="source-inline">cross</strong>/<strong class="source-inline">outerApply(String sql, QueryPart... parts)</strong>. All of them are available in the jOOQ documentation and are marked with <strong class="source-inline">@PlainSQL</strong>. This annotation points out methods/types that allow us to produce a <strong class="source-inline">QueryPart</strong> that renders "plain SQL" inside of an AST, which are covered in <a href="B16833_16.xhtml#_idTextAnchor315"><em class="italic">Chapter 16</em></a>, <em class="italic">Tackling Aliases and SQL Templating</em>.</p>
			<p>All the examples (and more) from this chapter can be found in the <em class="italic">LateralJoin</em> application. Take your time to practice each example.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Summary</h1>
			<p>In this chapter, we have covered a comprehensive list of SQL <strong class="source-inline">JOIN</strong>s and how they can be expressed via the jOOQ DSL API. We started with the well-known <strong class="source-inline">INNER</strong>/<strong class="source-inline">OUTER</strong>/<strong class="source-inline">CROSS JOIN</strong>, continued with Implicit Joins, Self Joins, <strong class="source-inline">NATURAL</strong> and <strong class="source-inline">STRAIGHT JOIN</strong>s, and ended with Semi/Anti Joins, <strong class="source-inline">CROSS APPLY</strong>, <strong class="source-inline">OUTER APPLY</strong>, and <strong class="source-inline">LATERAL</strong> Joins. Also, among others, we covered the <strong class="source-inline">USING</strong> clause and the amazing jOOQ <strong class="source-inline">onKey()</strong> method.</p>
			<p>In the next chapter, we tackle the jOOQ types, converters, and bindings. </p>
		</div>
	</body></html>