- en: Persisting Data Using a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at choosing a database management system. The
    choice of systems depends on various factors, such as visualization and reporting,
    security, scalability, and cost, to name a few. There are also various kinds of
    databases, and one of them is the relational database. This kind of database is
    designed in such a way that it recognizes relations within the stored information.
    In most cases, SQL is used to query and maintain relational databases systems.
    Additionally, we will learn to develop the data in that database along with your
    application and implement data access with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a database management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop the data in that database along with your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement data access with the help of Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational Databases and SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final chapter of this book is about persistence, in other words, using a
    database.
  prefs: []
  type: TYPE_NORMAL
- en: There is software that does not need to store any state. Some software is just
    fired up for a certain task; it performs it and returns its results; some lies
    in the middle of other components and relays messages back and forth. Many software
    systems, however, need to store some state; they are said to **persist** the state.
    There are different forms of data storage, but we will focus on what is most prevalent
    in business applications.
  prefs: []
  type: TYPE_NORMAL
- en: Many different answers may come up. A saved game file on your hard disk may
    not sound like persistence at first, but it is a very valid answer. It is important
    that you understand that most software need some amount of storage, and that the
    form of storage differs widely.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Database Management Systems (RDBMS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Relational Database Management Systems**, **RDBMS** for short, are systems
    that can store data in a relational database. Strictly speaking, the **database**
    is only the data within that is managed by the system. Very often, we do not make
    this distinction in everyday speech and just call this **management system** a
    **relational database**, or even just database.'
  prefs: []
  type: TYPE_NORMAL
- en: Without diving deep into database theory, relational in this context refers
    to relational algebras as introduced by Edgar F Codd in 1970\. In short, it means
    we store data in tables, pre-defining the set of columns for a table (with names
    and types), with each entity taking up a row in it. Databases such as these are
    almost invariably described and queried using the query language SQL; therefore,
    they are sometimes called **SQL databases**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The well-founded semantics of relational algebras are the basis of how to store
    data in an RDBMS and also how to query such data. The original work that is the
    foundation of database theory can be found in Edgar F Codd''s 1970 work ''*A Relational
    Model of Data for Large Shared Data Banks'', Communications of the ACM, 13 (6):
    377–387* ([https://doi.org/10.1145%2F362384.362685](https://doi.org/10.1145%2F362384.362685)).'
  prefs: []
  type: TYPE_NORMAL
- en: There are many good articles on this for different levels of expertise, which
    can be found on Wikipedia or universities' websites. It is worthwhile reading
    even if you are already familiar with SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases are the industry standard, with popular open source software
    such as PostgresQL and MySQL, and expensive enterprise-grade solutions such as
    Oracle and MS SQL Server. They are the best solution for many challenges, and
    still a very good solution for most others, and this has made them prevalent.
    However, for a number of special cases, they are deemed to be too inflexible or
    too slow. This has given rise to a large number of alternative solutions that
    are often collectively known as **NoSQL** to differentiate them from the more
    standard SQL databases. The increased speed or flexibility comes with some cost,
    so they are not a general replacement. Even though Spring offers support for some
    of them, none of this is in scope for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we will focus on SQL databases and the excellent support Spring has
    for these in a number of aspects. We will see how to connect to an RDBMS (even
    to integrate one), how to evolve the database alongside our code, and how to access
    the data. This last aspect in particular, is facilitated, as we will see shortly.
    But, first, we need an RDBMS to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: The H2 Embedded Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many database systems are heavyweight, can store terabytes of data (or, for
    some, that is the memory they take up, and they can store petabytes), they have
    fail-over and backup strategies built in, and an elaborate security concept. Sometimes,
    all of this is too much.
  prefs: []
  type: TYPE_NORMAL
- en: '**H2** is special in that it is small, it is written in Java, it can be embedded
    in your program, and it can store all the data in-memory. Yes, that''s right—
    it will be all in one place, and it will work out of the box. H2 can be used in
    production systems, if required, since it is fast and supports most of SQL. Often,
    however, it will be used only during development.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive right in and use it in our project!
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the H2 Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim here is to embed the in-memory H2 database. You want to add persistence
    to your application. Since you are newly developing the application, you need
    some playground, so you decide not to access your company's enterprise database,
    but to start with an in-memory solution that can be swapped for an external database
    as the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before beginning, locate the blogmania app from the folder present at [https://bit.ly/2qIrUEE](https://bit.ly/2qIrUEE).
    The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the POM, in a convenient spot within the `<dependencies>` element, add the
    following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Upon starting, Spring Boot will auto-discover the database and give you access
    to a pre-configured database instance through the use of injected DataSource beans.
    Everything you need is now there!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is not much to be seen just yet. Let''s turn to another feature
    that can be very helpful during development: the H2 console. This comes with the
    H2 database and is enabled in Spring Boot when the Spring Boot Devtools are available
    (which they are in our application). Go to [https://bit.ly/2QpSiP0](https://bit.ly/2QpSiP0)
    to access the complete code for the `BlogmaniaApplication.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now start the application. Point your browser to `http://localhost:8080/h2-console`,
    and — voilà! — you are now seeing the H2 console login screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d38304fd-9edb-4ec6-ab9f-7b03bfc76eee.png)'
  prefs: []
  type: TYPE_IMG
- en: This console could be used to access any SQL database. The fields are prefilled
    with exactly the correct values to go into the embedded in-memory test database,
    so just click the Connect button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next screen is a bit overwhelming at first. To help you get started, find
    the ''Sample SQL Script'' section in the middle of the screen; when you click
    on it, the script will be copied to the SQL statement window at the top. Press
    the Run button to actually run the script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0cdd20e1-d542-42a0-9529-12765719df92.png)'
  prefs: []
  type: TYPE_IMG
- en: You have now created a table, put some data in it, and updated it! The new table
    called TEST will now appear in the tree to the left. You may want to explore the
    console to get familiar with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you have witnessed, now there is a database that can be used and viewed for
    debugging. However, detailed knowledge of this is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the console does not play well with Spring Security. So, if
    we had that enabled, we would have to relax access a bit. In the security configuration,
    you must perform one change in the configure (`WebSecurity`) method to just take
    the H2 console out of the security loop. That method should then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before going into production, it would be a good idea to undo these changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Gist of SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL is a database language to define, create, read, update, and delete data.
    The initialism has no official meaning. However, it is usually thought to be an
    abbreviation of **Structured Query Language**, and it is sometimes pronounced
    "sequel" but this is, in fact, a relic of its predecessor.
  prefs: []
  type: TYPE_NORMAL
- en: SQL handles data in tables. These tables have a defined number of columns, each
    with a specific type. The database system is strongly typed and can even check
    constraints over the values in a table. A part of SQL referred to as the **Data
    Definition Language** (**DDL**) is responsible for declaring and creating these
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Another part of the language, the **Data Manipulation Language** (**DML**),
    is responsible for working on the data. The two sub-languages are only logically
    separated; they share much of their syntax.
  prefs: []
  type: TYPE_NORMAL
- en: DDL Table Creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen the language in action in the last exercise. Let''s look closer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This bit of DDL defines a table called test with two columns: one column called
    `id`, and another one called `name`. The id column has the type INT, which can
    store integer values. The name column, on the other hand, can store strings of
    a variable number of characters, up to a maximum length of 255.'
  prefs: []
  type: TYPE_NORMAL
- en: It is customary to write all SQL keywords in uppercase. This, however, is only
    a convention, and SQL is case-agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: Slightly contested, but still widespread is the convention to use lowercase
    for identifiers. SQL is case-agnostic here as well.
  prefs: []
  type: TYPE_NORMAL
- en: The id column is meant to store an identifier for the row. This is also called
    a `key` in databases. Identifiers should be unique within a table and adding the
    keywords PRIMARY KEY will make the database enforce this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Most databases can be forced to use identifiers with only the specified case.
    This is asking for trouble.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of standardization in SQL, but, unfortunately, each database
    has its quirks or extensions. For instance, the normal type for storing strings
    of characters is called VARCHAR2 in Oracle, and it cannot store empty strings,
    because empty strings are handled the same as the special NULL values.
  prefs: []
  type: TYPE_NORMAL
- en: DML Data Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next lines, in contrast, are DML and manipulate data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These lines are quite self-explanatory. Note that SELECT statements can also
    have a WHERE clause. This little SQL is enough to carry us through the remainder
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Database from Java with JDBC and JdbcTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we actually access data, it is good to have some data to play around
    with. Normally, data is persistent, but in our current setup, H2 will be empty
    on each start of the application. In cases such as these, Spring Boot offers to
    execute certain SQL scripts upon application start.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Initial Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first script is called `schema.sql` and contain SQL statements (DDL) to
    create the tables used in our application (usually CREATE TABLE statements). The
    second one is `data.sql` and contains SQL statements (DML) to create some data
    (usually INSERT statements). As resource files, they live in the `src/main/resources`
    folder. The example files for this chapter can be found at [https://bit.ly/2Dzb03G](https://bit.ly/2Dzb03G).
  prefs: []
  type: TYPE_NORMAL
- en: Plain JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDBC is the standard interface to use relational databases from Java. The initialism
    means Java Database Connectivity. The standard provides a uniform API to access
    RDBMS from different vendors. The database driver containing the actual low-level
    implementation is supplied by the vendor, while the interfaces and common classes
    are part of the standard Java runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: Plain JDBC Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of what is found in the API is easy to follow through and well documented.
    However, it turns out to be quite cumbersome to use. Users need to take a close
    look at database resources such as connections, and failure to properly close
    those may exhaust the configured connection limit of the database. All this is
    complicated by the use of checked exceptions, even in places where nothing can
    be done about the failure by the application programmer. Consider the following
    excerpt (full code for all examples to be found in the `JdbcDemonstratingRepository`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2Qm2tnM](https://bit.ly/2Qm2tnM) to access the complete
    code for the `JdbcDemonstratingRepository.java file`. This is surely not the way
    we want to write code. All it does is retrieve a single number!
  prefs: []
  type: TYPE_NORMAL
- en: Plain JDBC Since Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bulk of this code is concerned with error handling. Complex queries will
    require more work on the result set but the same amount of error handling, so
    the ratio will improve, but for small queries, the overhead is unpardonable. Most
    people decide not to catch the exceptions in the smallest possible scope, abandoning
    a bit of accuracy in error reporting. Fortunately, all the mentioned classes implement
    `AutoClosable`, which allows us to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is really much better and as good as it gets for simple queries. The try-with-resources
    mechanism ensures that, no matter what errors may arise, all resources will be
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a discussion of possible complications, you may refer to this question
    on StackOverflow: [https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc](https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc).'
  prefs: []
  type: TYPE_NORMAL
- en: JDBC Resources to Handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These JDBC resources are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A connection to the database. Everything runs in the context of this, and it
    incurs network traffic to establish the connection (in the case of a remote database).
    Transactions and rollback, if required, are on the connection level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A statement that encapsulates a single SQL statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of results of the operation. Transmission of this result over the network
    may well be in chunks and batches; the result may be big (as big as your whole
    database), so take care to process it correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring to the Rescue – JdbcTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `JdbcTemplate` class is the central class in the Spring JDBC package. It
    simplifies the use of JDBC and helps to avoid common errors. It can do all the
    work for simple use cases and provides extension points for callback interfaces
    for more advanced use cases. In addition, it performs **exception translation**,
    the usefulness of which will be discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the class contains the word **template** and is often not well understood.
    It refers to the **template method** design pattern, which is one of the 23 well-known
    patterns described in the book *Design Patterns* (Gamma, Helm, Johnson, Vlissides;
    Addison-Wesley 1994; ISBN 0-201-63361-2).
  prefs: []
  type: TYPE_NORMAL
- en: In short, the complete workflow of JDBC (getting the connection, creating a
    statement, …, closing statement, and returning the connection) is performed within
    `JdbcTemplate`. To make the behavior flexible, this workflow calls callback functions
    at various places that the user of `JdbcTemplate` can optionally provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how simple database access can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that is really a one-liner!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this example was trimmed a bit to increase the effect. Nevertheless,
    even complex scenarios are much easier to handle with `JdbcTemplate` than with
    plain JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In detail: Creating the JdbcTemplate'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We left out the details of how to get the `JdbcTemplate` instance and what
    side effects will arise. Let''s catch up on that now. The following is again an
    excerpt from the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Repository` annotation is a Spring annotation that is itself annotated
    with `@Component` and will mark this class as a Spring bean (we have already seen
    it in *[Chapter 1](9c691a93-c936-4976-b836-8ec08d62bffb.xhtml): Spring Project
    and Framework*). It is just a more semantic version, just like the `@Service`
    annotation. It will prepare the whole code for exception translation when using
    JPA, but this is outside the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring will wire in an instance of `javax.sql.DataSource` for us. This is not
    a Spring-specific class, but Spring Boot will create it automatically for us in
    our simple configuration (remember, all we did was add two dependencies to the
    POM) and connect it to our database, the embedded H2 instance. Such a `DataSource`
    has only one purpose: to acquire database connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This DataSource is then used to create an instance of `JdbcTemplate`. It is
    customary to create the instance in the constructor and reuse it throughout the
    class. It is thread-safe. There may be a need to further configure the template,
    but when the defaults are fine, there is one even easier way: just autowire the
    global `JdbcTemplate` bean (that is the approach taken in the other repository
    classes in the example application).'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the instance of the central workhorse of Spring JDBC support and
    can perform the simple query (it will be explained later). This is the simplest
    way to use `JdbcTemplate`; for more advanced needs, there are a plethora of options
    that we will explore shortly. But, first, let's turn our attention to a case when
    there is a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Translation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, JDBC throws checked exceptions in the `SQLException` hierarchy in
    the event of a problem. There was and is great debate on whether checked exceptions
    ever were a good idea in Java. The majority tends to prefer unchecked (or **runtime**)
    exceptions these days. Spring's `JdbcTemplate` will translate these into exceptions
    in the `DataAccessException` hierarchy, which are Spring-specific and unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: As an added benefit, these exceptions are database technology-agnostic. You
    will also get the same set of exceptions for JPA or access to NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exceptions in the `DataAccessException` hierarchy are more detailed than
    those in the `SQLException` hierarchy. The following table lists some of the most
    important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48093b75-b337-4e8a-917b-0d4c850c2e80.png)'
  prefs: []
  type: TYPE_IMG
- en: Advanced Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While exploring the `JdbcTemplate` class, we come across many methods, most
    of them overloaded. This is overwhelming at first, but there is a certain multi-dimensional
    order to it. We have already seen the basic `queryForObject()` method in its simplest
    form, and we are now going to look at some of the overloaded versions.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is important to note that `queryForObject()`, in all its variants,
    is supposed to return exactly one object. That means the SQL must return one row,
    and in the basic version, we have seen, only a single column. Otherwise, it will
    throw `IncorrectResultSizeDataAccessException`. It will not return null except
    when the query returns an SQL NULL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples up to now built upon a simple SQL query that you can find in `JdbcDemonstratingRepository:
    SELECT 42 FROM dual`. This query does not contain any variable parts, it will
    return exactly one row with exactly one column of the integer type. First, let''s
    add some variation by introducing variables.'
  prefs: []
  type: TYPE_NORMAL
- en: What is **dual**? A standard SQL SELECT query requires not only the values or
    column names (right after the SELECT), but also a table expression to draw the
    data from. Many databases are generous in what they accept here, and you can just
    leave out the FROM part when selecting constant values.
  prefs: []
  type: TYPE_NORMAL
- en: Other RDBMS, however, are strict, notably Oracle. You have to give a table here,
    and take note that the constant will be returned once for each row in the table.
    For that purpose, Oracle comes with a predefined table, DUAL. It has one column,
    DUMMY, defined to be VARCHAR2(1), and contains one row with a value X. Others
    RDBMS have adopted this, as you have seen with H2 here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable parts in queries are marked with a single question mark, which substitutes
    an SQL expression. We can change the SQL query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The intention is clear, but how do we pass a value to this? The `queryForObject()` method
    is overloaded for this purpose with an `Object... args` parameter, so the simplest
    thing to do is just add the additional value at the end of the call! (There is
    also another overloaded version, taking an `Object[] args` parameter, that stems
    from before `var-arg` parameters were introduced in Java. We will ignore this
    version.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Other Result Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All our queries up to now contained a single `Integer.class` parameter to map
    the result from the database to a Java type. Most SQL types map into Java types
    quite naturally, and there is a lot of flexibility; we could have used `BigDecimal.class`
    or even `double.class` instead. To demonstrate that, let''s query the database
    for its current time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates nicely that we can either use `java.sql.Timestamp`, a low-level
    type created to match closely the values that an SQL database driver may return,
    or the new `Java 8 DateTime-API type LocalDateTime`. These conversions are conveniently
    performed for us by Spring!
  prefs: []
  type: TYPE_NORMAL
- en: Returning Multiple Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there is more than just one value in the result set, or if there may be
    zero, it is better to request a list of results, and `JdbcTemplate` offers just
    such a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get us a list of all the full names of all the authors in the database
    (remember they were imported in the `data.sql startup` script): [Administrator,
    Peter Quinn, Paul Nipkow, Catherine Sakai].'
  prefs: []
  type: TYPE_NORMAL
- en: The restriction that remains is that the query may only return a single column
    to convert into the given type. The next step is to query multiple columns at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Structured Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A query that returns more than one column poses the problem of how to represent
    these columns in Java. There are two approaches to tackle this—return the data
    as a map or make use of callback functions. The map approach is very convenient
    for one-off queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result is a `Map<String, Object>`, which in this case contains `{USERNAME=admin,
    FULLNAME=Administrator}`. (Note that H2 returns column names all in uppercase,
    even if it accepts them as lowercase in the query.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding call to get a list is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is a slight asymmetry here; to get a map instead of a single
    object, we have to change `queryForObject()` into `queryForMap()`, while to get
    a list of maps instead a list of single objects, we use the same `queryForList()`
    call, but leave out the expected type.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using maps is simple, but we would prefer proper objects for our application
    instead of these maps. Instead of taking the maps and converting them afterward,
    Spring allows us to tap into the process of mapping each row of a result into
    a list element, using the `RowMapper<T>` interface. This interface is generic;
    its type parameter determines the type of the return value of the query method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Mapping Rows (short)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Luckily, `RowMapper<T>` is and always has been an interface with just one abstract
    method, which allows us to use it as a functional interface in Java 8\. Thus,
    the previous code can be shortened to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the mere mention of `RowMapper<Author>` in the extended version
    also serves as a kind of documentation; the second version mentions neither the
    type nor the actual mapping of rows. This is made worse by the fact that the `query()`
    method allows two further callbacks to be given: `RowCallbackHandler` and `ResultSetExtractor<T>`.
    So, look out for the two parameters `rs` and `rowNum` to spot the `RowMapper<T>`
    or store the mapper in a variable. Often, the following may be the most readable
    compromise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One other very important thing to note is that a `RowMapper<T>` is supposed
    to directly map one row to one object. In particular, authors are not supposed
    to `call next()` on the given SQL `ResultSet`. In many cases, this is just what
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced Mapping: Row-Spanning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, more than one row of the `ResultSet` will be mapped into just one
    entity in our application. This technique has been used in `AuthorRepository`
    in the database-intro application. Why would we want that?
  prefs: []
  type: TYPE_NORMAL
- en: 'An author can have more than one role, and the way to map this into tables
    in an RDBMS is to split the entity in two tables: one for the author proper, and
    one for the roles. To fetch the author by name, there are two methods.'
  prefs: []
  type: TYPE_NORMAL
- en: First, fetch the author's row from the author table by name and look up the
    ID. Then, using that ID, fetch the roles from the role table. This is very straightforward
    but requires two trips to the database.
  prefs: []
  type: TYPE_NORMAL
- en: We can fetch from both the author and the role table at once using an SQL JOIN
    operation. For an author with just one role, this is straightforward as well,
    but when an author has more than one role, then the operation will return the
    author data more than once. Therefore, we need to advance the result set and de-duplicate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The overhead caused by the data duplication in the second method is usually
    less than that from the two round trips to the database. Of course, all this optimization
    is unnecessary for our small application, and often even for big applications.
  prefs: []
  type: TYPE_NORMAL
- en: In our repository, we use `ResultSetExtractor<Author>` to create author instances.
    In contrast to what happens in `RowMapper<T>`, the `extractData(ResultSet rs)` method
    has the result set as its only parameter and can process it in whatever way it
    wishes. This is closer to handwritten JDBC code; in particular, this time we need
    to call `next()` on the `ResultSet` to advance the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Note that both in `RowMapper<T>` and in `ResultSetExtractor<T>`, we do not have
    to worry about exceptions, since the `JdbcTemplate` will take over the exception
    translation.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The acronym **CRUD** reminds us of the types of database operations that we
    usually perform. The four letters stand for **Create**, **Read**, **Update**,
    and **Delete**. They more or less correspond to the SQL keywords `INSERT`, `SELECT`,
    `UPDATE`, and `DELETE`. Up to now, we have only covered reading, so we now turn
    to the other three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading is different than the others in that it returns data, while the other
    three return an update count at most. In a wider sense, creating rows and deleting
    them is also an update to the database, and so there is only one call in `JdbcTemplate`
    to cater for all these needs— `update()`. Its use is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This statement will add a role the user cate by inserting a row with that value
    into the database. The call returns the number of updated rows, which is one,
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '`UPDATE` and `DELETE` work just the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Schema Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only a short-lived application has no need to change. If you have a long-lived
    application, the requirements will change over time. And as your requirements
    change, so does your application. Finally, you will find that your data model
    needs to evolve as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this latter example, adding the new table is not enough; we also need to
    migrate the existing data from the old column to the new table and subsequently
    drop the old, now useless, column.
  prefs: []
  type: TYPE_NORMAL
- en: You need to make sure that your code and your database stay compatible. Doing
    this with the methods we have seen so far is difficult and error-prone. We want
    to keep the schema and the code close, within the same code base, and not tell
    the operations department to perform certain steps during deployment. For very
    simple cases only, we can use the `execute()` method on `JdbcTemplate` to perform
    schema changes.
  prefs: []
  type: TYPE_NORMAL
- en: There are tools and libraries to support us in this endeavor. There is **Flyway**,
    which we will look at in a minute, and **Liquibase**. Both are available both
    as a Java library and as a command-line tool. Liquibase has a lot more features,
    but, as is so often the case, it is also quite a lot more complicated. Many users
    find that they have no need for all the advanced features. The general advice
    is to stick to Flyway, and to keep Liquibase at the back of your mind in case
    you ever find that you actually need more.
  prefs: []
  type: TYPE_NORMAL
- en: Database Migrations with Flyway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flyway helps to keep your code and your database schema in sync by keeping both
    of them in the same place, your source code repository. Our introductory app sported
    something similar, yet quite trivial—the `schema.sql` file that contains the SQL
    to create the database schema, is part of the source code. This, however, assumes
    an empty database. For an in-memory database which is started alongside the application,
    that is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: In most applications, the data in the database will far outlive the runtime
    of the application; this is, in fact, the whole point of using a DBMS in the first
    place assuming an empty database will not cut it. When we release a new version
    of our software, we have to change the database accordingly to match this. One
    very effective way to do that is to run this change upon the first start of the
    new application before it actually reads any data. This change in the schema and
    data is called a **migration**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at how Java and SQL evolved side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bdcb03e-e531-4f98-9d25-4c66c5ca209d.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we need to keep track of which changes are already in the database.
    This is where Flyway comes into the game. Each migration necessary for keeping
    the database in sync with the application is stored alongside the application,
    and Flyway remembers that a migration has already run, and will run it only once.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Flyway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to utilize Flyway for schema migrations. You want to add migrate
    your schema alongside your application. You want that
  prefs: []
  type: TYPE_NORMAL
- en: to happen automatically on startup, so you decide to use Flyway and Spring Boot's
    excellent support for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before beginning, locate the database-intro app at [https://bit.ly/2zeKkl7](https://bit.ly/2zeKkl7). The
    steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the POM, in a convenient spot within the `<dependencies>` element (right
    after the other two database dependencies would be just splendid), add the following
    dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `src/main/resources` folder, create a new folder, `db`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is most easily done right from within IntelliJ IDEA: Right-click on `resources`
    in the tree and choose New Directory.'
  prefs: []
  type: TYPE_NORMAL
- en: In this newly created `db` folder, create a new folder, `migration`. This is
    the place where Flyway expects its database migrations by default.
  prefs: []
  type: TYPE_NORMAL
- en: Move the `schema.sql` and `data.sql` files from the `resources` folder into
    the new `db/migration` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `schema.sql` to `V01__initial.sql` and `rename data.sql` to `V02__data.sql`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac7a20be-26ea-4186-941e-27f43926d675.png)'
  prefs: []
  type: TYPE_IMG
- en: Renaming can be done in IntelliJ IDEA by pressing *Shift + F6*. In both cases,
    the important thing is the prefix before the two underscores (and the `.sql` suffix),
    while the rest of the name is informational.
  prefs: []
  type: TYPE_NORMAL
- en: Start the application. It behaves just as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the log you will find these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2NEFqG9](https://bit.ly/2NEFqG9) to access the code for
    the `DatabaseIntroApplication.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Flyway – Behind the Scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The log lines on the application's startup tell the whole story. Flyway records
    all migrations in a database table called `flyway_schema_history`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have a look at the schema history table in the H2 console, if you want.
    Note, however, that the table really is called `flyway_schema_history`, in lowercase.
    To view everything in it, you can use SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for all the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d40029c1-8fae-415a-991c-b21a2bcf83e1.png)'
  prefs: []
  type: TYPE_IMG
- en: If the table does not exist yet, Flyway will create it on the fly, and that
    is what will happen on each start with our in-memory-only database. In such a
    case, the current version of the schema will be empty as well.
  prefs: []
  type: TYPE_NORMAL
- en: Flyway finds all migrations on the classpath under `db.migration;` in our case,
    there are two files. All migration filenames start with the version number — an
    uppercase V followed by a number, which may be subdivided by single underscores
    or dots. Double underscores delimit the version number from an arbitrary name;
    this is the human-readable part. Flyway orders the migrations by the numerical
    value of their version. The leading zero in the previous names is only for proper
    lexical ordering in file views.
  prefs: []
  type: TYPE_NORMAL
- en: Then, Flyway executes all migrations that have not already run (all of them
    in the initial case). Flyway will also compute a checksum of all of the files.
    Remember that once applied, a migration will not be executed again. Changing it
    would have no effect and is likely to be an error, so Flyway will refuse to continue
    if any checksum does not match anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Trivial Migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The migrations seen so far allow you to evolve the database schema alongside
    the Java source code throughout the lifetime of the application. Flyway has two
    extensions that allow us to handle exceptional cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we may want to support different database systems with our codebase,
    for instance, an H2 database for testing and an Oracle database for production.
    Mostly we can use the same SQL, but not always. In this case, we can use vendor-specific
    SQL. To use that, we need to configure the path to the migrations to contain the
    vendor. One possible setting in our `application.properties` could be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.flyway.locations=db/migration/{vendor},db/migration`'
  prefs: []
  type: TYPE_NORMAL
- en: The placeholder `{vendor}` will be replaced by the real database driver. For
    instance, when using MySQL, Flyway will search in `db/migration/mysql` first and
    then in `db/migration`.
  prefs: []
  type: TYPE_NORMAL
- en: Another case may be when a migration includes complicated computations that
    cannot be done in SQL alone, or that are much easier to do in Java. For these
    cases, Flyway also supports Java migrations. Spring Boot makes using these a breeze.
    All we have to do is create beans that extend `BaseFlywayCallback`; the order
    can be specified with the `@Order` annotation. Within the bean, we can have the
    `Datasource` injected and use `JdbcTemplate` as we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: Outlook – Advanced Database Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To round things up, let's have one final look into some advanced sections that
    are otherwise outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: External Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, we have made use of an in-memory database. Spring Boot did a lot
    of work for us behind the scenes. The database management system was auto-detected,
    started, and the connection to the database automatically established.
  prefs: []
  type: TYPE_NORMAL
- en: This setup is perfect for exploring database technology. It can also be used
    in production. H2 is lightweight and fast. It can also be configured to actually
    save all data to disk. Then it will be persistent, as long as that file survives.
    If you only have this one client (your application), and the data fits into your
    memory, H2 is an option to consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Production-ready databases offer a plethora of other features. They can store
    more data, they can be distributed, have fail-over and backup strategies, security,
    multitenancy, and much more. These generally run on a host of their own. That
    brings us to the question of how to access them from Spring Boot. The solution
    is extremely simple. All we have to do is set three properties: the URL, the user,
    and the password. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Connection Pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting a JDBC connection is quite a slow operation for most databases. It can
    take longer than the query itself. It is not efficient to get a new connection
    for each JDBC statement. However, using a connection for many statements requires
    very careful resource management.
  prefs: []
  type: TYPE_NORMAL
- en: The standard technique to solve this challenge is to use a connection pool,
    where connections are held in a store for later reuse. A number of such pool implementations
    exist. To use one, we have to do nothing at all!
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot will automatically use HikariCP as its connection pool when it is
    on the classpath. Since spring-boot-starter-jdbc depends on HikariCP, it is already
    found and configured with sensible defaults.
  prefs: []
  type: TYPE_NORMAL
- en: If HikariCP is not on the classpath for some reason, the first fallback will
    be the Tomcat pooling `Datasource`, which you will also have available on a web
    project. It is actually hard not to get connection pooling with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Other Database Technologies – JPA and Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JPA is a Java standard to access a database that given a level of abstraction.
    It maps Java classes to database tables automatically or with the help of annotations,
    and is therefore also called an object-relational mapper, or ORM. The most widely
    known implementation of JPA is Hibernate, and the two terms are sometimes used
    interchangeably (even though falsely).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot supports this with the spring-boot-starter-data-jpa POM. In addition
    to the normal JPA capabilities, this also includes Spring Data, a Spring sub-project
    that allows us to write DAOs (or repositories) by just creating the interface.
    Such a repository may just look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The **implementation** of this interface will be created on the fly upon startup.
    JPA may not be the best choice in every project.
  prefs: []
  type: TYPE_NORMAL
- en: Other Database Technologies – jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing the database with JDBC has one serious drawback — by using SQL, we
    embed another language into our Java programs. The statements are hidden in strings.
    They will not be checked at compilation time, and they are not type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of approaches to tackle this problem. IntelliJ IDEA offers
    great support for embedded languages in the ultimate edition, but relying solely
    on the IDE is not a good approach. The alternative is to have a tool that queries
    the database and generates Java classes from it that reflect the tables in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ is one such product and it is supported directly by Spring Boot. It offers
    a fluent API that always starts with an object of the `DSLContext` class. If jOOQ
    is on the classpath, Spring Boot will automatically create such a DSLContext,
    connected to your global `Datasource`, as a Spring Bean. All we have to do is
    to wire it into a bean of ours and we can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Creating an SMS Application to Display Multiple Authors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To create a short message list that can show multiple authors for a single article.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: We build this activity upon the simple message app used in the last two chapters;
    for simplicity, it is stripped of the login. It already has a human-facing web
    frontend. You find the source code at [https://bit.ly/2BcfVW1](https://bit.ly/2BcfVW1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: You have a working application that needs to evolve; messages can have more
    than one author now. We need changes to the schema, the existing data, the database
    access, and the view — we will cover a lot in one go!
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: To start, in the `ShortMessage` class, change the author field and change the
    repository when creating a message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Thymeleaf `index.html` view to accept multiple authors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the app now to verify that everything is displayed as it was before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Flyway migration and you need a new table, so copy data from the message
    and finally drop the column ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the required code at the start of the `retrieveAll` method to make the repository
    compatible with the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using this map from article IDs to authors, change the query and the implementation
    for the second `jdbcTemplate` execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the app now to verify that everything is displayed as it was before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the H2 console in another browser tab to add some co-authors and immediately
    see the results after reloading in the original tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new migration, `V04__coauthors.sql`, with message–author links. When
    you start the application again, these are visible, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ffbb8d41-9848-4120-9c9f-4ab5381fec2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The short message list can show multiple authors for a single article.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2Mnhjaw](https://bit.ly/2Mnhjaw) to access the code for
    the `DatabaseIntroApplicationTests.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2OiSCh4](https://bit.ly/2OiSCh4) to access the complete
    code for the `DatabaseIntroApplication.java` file for the solution.
  prefs: []
  type: TYPE_NORMAL
- en: To refer to the detailed steps, go to the *Solutions* section at the end of this
    book on page 263.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter of the Spring Boot book, our focus was on the data that
    applications process, and in particular on the data that they persist. Storing
    data in a database is paramount for many types of applications. We had a brief
    introduction into relational databases, the workhorses of the industry. Spring
    makes it easy to access those databases. You connected a lightweight in-memory
    database and saw how to connect to a production database. You then queried data
    from that database using SQL and Spring's support class, `JdbcTemplate`. To evolve
    the database alongside the application code, you then used Flyway migrations.
  prefs: []
  type: TYPE_NORMAL
- en: This rounds off the book. You have learned how to develop Spring Boot applications,
    how to develop web pages backed by Spring applications or offer REST APIs to customers,
    and how to interface with databases. Spring Boot and the Spring project have much
    more to offer, and that world is now at your fingertips.
  prefs: []
  type: TYPE_NORMAL
- en: Book Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, you learnt about the basic building blocks of a Spring application,
    Spring application creation, and testing Spring applications. Then, we analyzed
    the MVC pattern, displaying and editing data using Thymeleaf, and RESTful APIs.
    Lastly, we implemented the basics of web application security and persisting data
    using a database.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some closing words of wisdom:'
  prefs: []
  type: TYPE_NORMAL
- en: If in doubt, check [StackOverflow.com](https://stackoverflow.com/)!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the Javadoc or even source code of the frameworks or libraries you use,
    it really helps!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use open source frameworks and contribute patches and bug reports, or just report
    documentation errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
