- en: '*Chapter 16*: Tackling Aliases and SQL Templating'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：处理别名和SQL模板化'
- en: 'This chapter covers two important topics that sustain your road to becoming
    a jOOQ power user: aliases and SQL templating.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了两个重要的主题，这些主题将帮助您成为jOOQ高级用户：别名和SQL模板化。
- en: The first part of this chapter tackles several practices for aliasing tables
    and columns via the jOOQ DSL. The goal of this part is to make you comfortable
    when you need to express your SQL aliases via jOOQ and to provide you with a comprehensive
    list of examples that cover the most common use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分探讨了通过jOOQ DSL对表和列进行别名的几种实践。这部分的目标是在您需要通过jOOQ表达SQL别名时让您感到舒适，并为您提供一份全面的示例列表，涵盖最常见的用例。
- en: The second part of this chapter is all about SQL templating or how to express
    SQL when the jOOQ DSL cannot help us. There will be rare cases when you'll have
    to write plain SQL or combine DSL and plain SQL to obtain some corner cases or
    vendor-specific features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分全部关于SQL模板化，或者说是当jOOQ DSL无法帮助我们时如何表达SQL。在极少数情况下，您将不得不编写纯SQL或结合DSL和纯SQL来获取一些边缘情况或特定供应商的功能。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Expressing SQL aliases in jOOQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在jOOQ中表达SQL别名
- en: SQL templating
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL模板化
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16)。
- en: Expressing SQL aliases in jOOQ
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在jOOQ中表达SQL别名
- en: 'SQL aliasing is a simple task. After all, it''s just about giving some nicknames
    to your columns and tables and referring to them via these nicknames instead of
    using their real names. But as simple as this may seem, this is a rather controversial
    topic. Some of the open questions you may come across will sound like this: Should
    I only use aliases when it''s mandatory (for instance, when I reference the same
    table twice)? Should I use meaningful names or will single letters work just fine
    (`p`, `q`, `t1`, `t2`, and so on)? Do they increase readability and decrease typing
    time? Most probably, the correct answer is that it depends… on the context, on
    the query, on who is writing the query (a developer, a DBA, a generator), and
    so on!'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SQL别名化是一个简单的任务。毕竟，这仅仅是给你的列和表起一些昵称，并通过这些昵称来引用它们，而不是使用它们的真实名称。但尽管这看起来可能很简单，这实际上是一个相当有争议的话题。您可能会遇到的一些开放性问题可能听起来像这样：我只有在必要时才使用别名吗（例如，当我需要两次引用同一张表时）？我应该使用有意义的名称，还是单个字母就能行得通（如`p`、`q`、`t1`、`t2`等）？它们是否会提高可读性并减少输入时间？最可能的正确答案是这取决于……上下文、查询、谁在编写查询（开发者、DBA、生成器）等等！
- en: As you'll see shortly, using aliasing via a DSL requires us to respect several
    rules and to be prepared for some verbosity since the host language (here, Java)
    comes with several shortcomings that a DSL must address as elegantly as possible.
    Aliasing sits next to derived tables, arithmetic expressions, and casting as one
    of the main challenges for a DSL, so let's see exactly what we should know about
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您很快就会看到的，通过DSL进行别名化需要我们遵守一些规则，并准备好应对一些冗长，因为宿主语言（在这里是Java）存在一些DSL必须尽可能优雅地解决的缺点。别名化与派生表、算术表达式和类型转换并列，是DSL面临的主要挑战之一，因此让我们看看我们究竟需要了解哪些内容。
- en: The examples from the following sections are available via *SimpleAliases* and
    *AliasesSamples*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分中的示例可以通过*SimpleAliases*和*AliasesSamples*获取。
- en: Expressing simple aliased tables and columns
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达简单的别名表和列
- en: 'Independent of how you like to use SQL aliases, when you want to express them
    in jOOQ, you must be aware of several methods, including `as()` and `asTable()`,
    which come in many flavors, such as `as(String alias)`, `as(Name alias)`, `as(Name
    as, Name... fieldAliases)`, `asTable()`, `asTable(String alias)`, `asTable(Name
    alias)`, `asTable(Table<?> alias)`, and so on. Commonly, we must deal with aliased
    tables and fields. Here is a quick sample of using aliased tables in jOOQ:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您喜欢如何使用SQL别名，当您想在jOOQ中表达它们时，您必须了解几个方法，包括`as()`和`asTable()`，它们有多种风味，如`as(String
    alias)`、`as(Name alias)`、`as(Name as, Name... fieldAliases)`、`asTable()`、`asTable(String
    alias)`、`asTable(Name alias)`、`asTable(Table<?> alias)`等等。通常，我们必须处理别名表和字段。以下是一个使用jOOQ中别名表的快速示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is an example of using some aliased fields (used here to take
    full control of the column names that are generated in your SQL):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用别名字段的示例（在这里用于完全控制SQL中生成的列名）：
- en: '[PRE13]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we'll look at some more complex examples of using aliases.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些使用别名的更复杂示例。
- en: Aliases and JOINs
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名与JOIN
- en: 'One of the common cases where we see SQL aliases at work is in `JOIN` statements.
    Instead of repeating the table names, people prefer to associate aliases with
    the joined tables and refer to them via these aliases. For instance, in the following
    screenshot, we have a `JOIN` between two MySQL tables (`OFFICE` and `DEPARTMENT`)
    expressed without aliases (top) and with aliases (bottom):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到SQL别名在`JOIN`语句中工作的一个常见情况是在`JOIN`语句中。人们宁愿将别名与连接的表关联起来，并通过这些别名来引用它们。例如，在下面的屏幕截图中，我们有一个没有使用别名的`JOIN`（顶部）和带有别名的`JOIN`（底部）的两个MySQL表（`OFFICE`和`DEPARTMENT`）：
- en: '![Figure 16.1 – JOIN with and without aliases'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 – 带与不带别名的JOIN'
- en: '](img/B16833_Figure_16.1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_16.1.jpg)'
- en: Figure 16.1 – JOIN with and without aliases
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 带与不带别名的JOIN
- en: 'If we express the first SQL in jOOQ (without using aliases) then we obtain
    this – in jOOQ, whenever you can omit the usage of aliases, do it! This way, you
    have better a chance to obtain clean expressions, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在jOOQ中表达第一个SQL（不使用别名），那么我们会得到这个结果——在jOOQ中，每当你可以省略别名的使用时，就去做吧！这样，你就有更好的机会获得干净的表达式，就像这里所示：
- en: '[PRE21]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a clean and readable jOOQ snippet of code. Since jOOQ generates the
    SQL on our behalf, we don't feel the need to add some aliases to increase readability
    or reduce the typing time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个干净且可读的jOOQ代码片段。由于jOOQ代表我们生成SQL，我们不需要添加一些别名来提高可读性或减少输入时间。
- en: 'Nevertheless, next, let''s add the proper aliases to obtain the second SQL.
    As our first attempt, we may have written this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，接下来，让我们添加适当的别名以获得第二个SQL。作为我们的第一次尝试，我们可能写了这个：
- en: '[PRE26]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So, we have associated the `t1` alias with the `OFFICE` table via `OFFICE.as("t1")`,
    and the `t2` alias with the `DEPARTMENT` table via `DEPARTMENT.as("t2")`. Furthermore,
    we used our aliases via the `field()` method as `t1` and `t2`, respectively. Besides
    losing some readability in the jOOQ code, have you spotted other issues in this
    code compared to the jOOQ code without aliases? Sure you did – it's not type-safe
    and it renders unquoted identifiers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过`OFFICE.as("t1")`将`t1`别名与`OFFICE`表关联起来，通过`DEPARTMENT.as("t2")`将`t2`别名与`DEPARTMENT`表关联起来。此外，我们通过`field()`方法分别使用别名`t1`和`t2`。除了在jOOQ代码中失去一些可读性之外，你在这段代码与不带别名的jOOQ代码相比是否发现了其他问题？当然发现了——它不是类型安全的，并且渲染了未引号的标识符。
- en: When we say `field("t1.city")`, jOOQ renders `t1.city`, not `` `t1`.`city` ``
    (in MySQL). However, it is advisable to strive for qualified and quoted identifiers
    to avoid name conflicts and potential errors (for instance, using a keyword such
    as `ORDER` as an unquoted table name leads to errors). Generally speaking, quoted
    identifiers allow us to use reserved names as object names (for instance, `ORDER`),
    use special characters in object names (whitespaces and so on), and instructs
    (most databases) us to treat case-insensitive identifiers as case-sensitive ones
    (for example, `"address"` and `"ADDRESS"` are different identifiers, whereas `address`
    and `ADDRESS` are not).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`field("t1.city")`时，jOOQ渲染为`t1.city`，而不是` `t1`.`city` ``（在MySQL中）。然而，努力追求有资格和引号的标识符以避免名称冲突和潜在错误是明智的（例如，使用像`ORDER`这样的关键字作为未引号的表名会导致错误）。一般来说，引号标识符允许我们使用保留名称作为对象名称（例如，`ORDER`），在对象名称中使用特殊字符（空格等），并指示（大多数数据库）我们将不区分大小写的标识符视为区分大小写的标识符（例如，`"address"`和`"ADDRESS"`是不同的标识符，而`address`和`ADDRESS`不是）。
- en: 'However, jOOQ can render qualified and quoted identifiers if we rely on explicitly
    using `DSL.name()`, which is a very handy `static` method that comes in several
    flavors and it is useful for constructing SQL-injection-safe, syntax-safe SQL
    identifiers for use in plain SQL. It is commonly used in the `table()` and `field()`
    methods – for example, `name(table_name, field_name)` – but you can check out
    all the flavors in the documentation. The following table represents what jOOQ
    renders for different usages of the `name()` method and different databases:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们依赖于显式使用`DSL.name()`，jOOQ可以渲染有资格和引号的标识符，这是一个非常方便的`static`方法，它有多种形式，并且对于构建用于纯SQL的SQL注入安全、语法安全的SQL标识符非常有用。它通常用于`table()`和`field()`方法——例如，`name(table_name,
    field_name)`——但你可以在文档中查看所有形式。以下表格表示jOOQ为`name()`方法的不同用法和不同数据库渲染的内容：
- en: '![Figure 16.2 – Using jOOQ name()'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2 – 使用jOOQ name()'
- en: '](img/B16833_Figure_16.2.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16833_Figure_16.2.jpg)'
- en: Figure 16.2 – Using jOOQ name()
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 使用jOOQ的name()
- en: 'When an identifier occurs several times, it can be extracted in a local variable
    as a `Name` and reused in queries as needed, like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个标识符出现多次时，它可以作为一个`Name`提取到局部变量中，并在需要时在查询中重复使用，如下所示：
- en: '[PRE32]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When jOOQ evaluates `name("ORDER", "ORDER_ID")` (for MySQL), it renders ``
    `ORDER`.`ORDER_ID` ``. Of course, `ORDER_ID` doesn''t necessarily need the back
    ticks – only `ORDER` does. Playing with quotations for identifiers can be done
    via `quotedName()` and `unquotedName()` of the `DSL` class, like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当jOOQ评估`name("ORDER", "ORDER_ID")`（针对MySQL）时，它渲染为`` `ORDER`.`ORDER_ID` ``。当然，`ORDER_ID`不一定需要反引号——只需要`ORDER`需要。通过`quotedName()`和`unquotedName()`方法来玩转标识符的引号，如下所示：
- en: '[PRE35]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Moreover, jOOQ allows us to control (globally or at the query level) how identifiers
    are quoted via the `RenderQuotedNames` setting and cases via the `RenderNameCase`
    setting. For instance, we can instruct jOOQ to quote all the identifiers in the
    upper part of the current query, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jOOQ允许我们通过`RenderQuotedNames`设置来控制（全局或查询级别）标识符的引号方式，以及通过`RenderNameCase`设置来控制大小写。例如，我们可以指示jOOQ在当前查询的上半部分引用所有标识符，如下所示：
- en: '[PRE38]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: While you can find more details about these settings in the documentation ([https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/](https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/)),
    keep in mind that they only affect identifiers that are expressed via Java-based
    schemas or `name()`. In other words, they have no effect on `field("identifier")`
    and `table("identifier")`. These are rendered exactly as you provide them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在文档中找到有关这些设置的更多详细信息（[https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/](https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/)），但请记住，它们仅影响通过基于Java的模式或`name()`表达的标识符。换句话说，它们对`field("identifier")`和`table("identifier")`没有影响。这些将按照您提供的方式渲染。
- en: jOOQ doesn't force us in any way to use quoting, qualifications, and cases consistently
    in the same query or across multiple queries (since jOOQ renders by default).
    However, juggling these aspects may lead to issues, from inconsistent results
    to SQL errors. This happens because, in some databases (for instance, SQL Server),
    identifiers are always case insensitive. This means that quoting only helps to
    allow special characters or escape keywords in identifiers. In other databases
    (for instance, Oracle), identifiers are only case insensitive if they are unquoted,
    while quoted identifiers are case sensitive. However, there are also databases
    (for instance, Sybase ASE) where identifiers are always case sensitive, regardless
    of them being quoted. Again, quoting only helps to allow special characters or
    escape keywords in identifiers. And, let's not forget the dialects (for instance,
    MySQL) that mix the preceding rules, depending on the operating system, object
    type, configuration, and other events.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ不会以任何方式强迫我们在同一个查询或多个查询中一致地使用引号、限定符和大小写（因为jOOQ默认渲染）。然而，处理这些方面可能会导致问题，从结果不一致到SQL错误。这是因为，在某些数据库（例如，SQL
    Server）中，标识符始终是不区分大小写的。这意味着引号仅有助于允许在标识符中使用特殊字符或转义关键字。在其他数据库（例如，Oracle）中，如果标识符未引用，则它们是不区分大小写的，而引用的标识符是大小写敏感的。然而，也存在标识符始终是大小写敏感的数据库（例如，Sybase
    ASE），无论它们是否被引用。再次强调，引号仅有助于允许在标识符中使用特殊字符或转义关键字。而且，我们不要忘记那些混合上述规则的方言（例如，MySQL），这些规则取决于操作系统、对象类型、配置和其他事件。
- en: So, pay attention to how you decide to handle quoting, qualification, and case
    sensitivity aspects. The best/safest way is to express queries via the Java-based
    schema, use aliases only when they are mandatory, and always use `name()` if you
    have to refer to identifiers as plain strings. From that point on, let jOOQ do
    the rest.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请注意您如何决定处理引号、限定符和大小写敏感性的方面。最好的/最安全的方法是通过基于Java的模式表达查询，仅在必要时使用别名，并且如果您必须将标识符作为纯字符串引用，则始终使用`name()`。从那时起，让jOOQ做剩下的工作。
- en: 'That being said, if we apply `name()` to our query, we obtain the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果您在我们的查询中应用`name()`，则会得到以下代码：
- en: '[PRE49]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This time, the rendered identifiers correspond to our expectations, but this
    snippet of jOOQ code is still not type-safe. To transform this non-type-safe query
    into a type-safe one, we must extract the aliases and define them in local variables
    before using them, as follows (notice that there is no reason to explicitly use
    `name()`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，渲染的标识符符合我们的预期，但这个 jOOQ 代码片段仍然不是类型安全的。要将这个非类型安全的查询转换为类型安全的查询，我们必须在使用之前提取别名并在局部变量中定义它们，如下所示（注意没有必要显式使用
    `name()`）：
- en: '[PRE56]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Alternatively, you may prefer a minimalist aliasing approach, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能更喜欢以下这种最小化别名方法：
- en: '[PRE63]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Calling the `as()` method on the generated tables (here, on `OFFICE` and `DEPARTMENT`)
    returns an object of the same type as the table (`jooq.generated.tables.Office`
    and `jooq.generated.tables.Department`). The resulting object can be used to dereference
    fields from the aliased table in a type-safe way. So, thanks to `as()`, `Office`,
    and `Department`, we are type-safe again while using the desired table aliases.
    And, of course, the identifiers are implicitly rendered, quoted, and qualified.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的表上调用 `as()` 方法（在这里，在 `OFFICE` 和 `DEPARTMENT` 上）返回与表相同类型的对象（`jooq.generated.tables.Office`
    和 `jooq.generated.tables.Department`）。这个结果对象可以用来以类型安全的方式从别名表中取消引用字段。因此，多亏了 `as()`，`Office`
    和 `Department`，我们在使用所需的表别名时再次实现了类型安全。当然，标识符是隐式渲染、引号和限定的。
- en: Important Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a rule of thumb, in jOOQ, strive to extract and declare aliases in local
    variables before using them in queries. Do this especially if your aliases refer
    to the generated tables, are aliases that should be reused across multiple queries,
    you wish to increase the readability of the jOOQ expression and/or avoid typos,
    and so on. Of course, if your jOOQ expression simply associates some aliases to
    columns (to take full control of the column names that are generated in your SQL),
    then extracting them as local variables won't produce a significant improvement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，在 jOOQ 中，在使用查询之前，尽量在局部变量中提取和声明别名。特别是如果你的别名引用了生成的表，是应该在多个查询中重复使用的别名，你希望提高
    jOOQ 表达式的可读性以及避免打字错误等。当然，如果你的 jOOQ 表达式只是将一些别名关联到列（以完全控制你 SQL 中生成的列名），那么将它们作为局部变量提取不会产生显著的改进。
- en: 'Let''s look at a table that''s been aliased as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下这样别名的表：
- en: '[PRE70]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this case, we can refer to fields in a non-type-safe manner via `field(Name
    name)`, as shown in the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过 `field(Name name)` 以非类型安全的方式引用字段，如下例所示：
- en: '[PRE72]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The same `field()` method can be applied to any type-unsafe aliased table as
    `Table<?>` to return `Field<?>`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的 `field()` 方法可以应用于任何类型不安全的别名表，作为 `Table<?>` 返回 `Field<?>`。
- en: 'In this case, we can make these fields look type-safe via the `<T> Field<T>
    field(Field<T> field)` method as well (introduced in [*Chapter 14*](B16833_14.xhtml#_idTextAnchor284)*,
    Derived Tables, CTEs, and Views*). The `t3.field(name("city"))` expression indirectly
    refers to the `t1.CITY` field, so we can rewrite our queries in a type-safe manner,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过 `<T> Field<T> field(Field<T> field)` 方法（在[*第14章*](B16833_14.xhtml#_idTextAnchor284)*，派生表、CTE和视图*中介绍）使这些字段看起来是类型安全的。`t3.field(name("city"))`
    表达式间接引用了 `t1.CITY` 字段，因此我们可以以类型安全的方式重写我们的查询，如下所示：
- en: '[PRE79]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: However, remember that `Table.field(Field<T>):Field<T>` just looks type-safe.
    It's as good as an unsafe cast in Java because the lookup only considers the identifier,
    not the type. Nor does it coerce the expression.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，`Table.field(Field<T>):Field<T>` 只是看起来是类型安全的。它和 Java 中的不安全转换一样好，因为查找只考虑标识符，而不是类型。它也不会强制转换表达式。
- en: So far, so good! You can practice these examples in *AliasesSamples*. Now, let's
    take some time to cover several fundamental aspects of jOOQ aliases and practice
    some simple but essential exercises.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里为止，一切顺利！你可以在 *AliasesSamples* 中练习这些示例。现在，让我们花一些时间来介绍 jOOQ 别名的几个基本方面，并练习一些简单但重要的练习。
- en: Aliases and GROUP BY/ORDER BY
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名和 GROUP BY/ORDER BY
- en: 'Let''s consider the following SQL expressed in SQL Server:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下在 SQL Server 中表达的 SQL：
- en: '[PRE84]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This query uses an alias named `pl` for the `PRODUCT_LINE` column. Attempting
    to express this query via jOOQ, based on what we learned earlier, may result in
    something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询使用了一个名为 `pl` 的别名来表示 `PRODUCT_LINE` 列。根据我们之前学到的知识，尝试通过 jOOQ 表达这个查询可能会得到如下结果：
- en: '[PRE88]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: But this isn't correct! The problem here is related to our expectations. We
    expect `PRODUCT.PRODUCT_LINE.as("pl")` to produce `[pl]` in `ORDER BY`, `[classicmodels].[dbo].[product].[product_line]`
    in `GROUP BY`, and `[classicmodels].[dbo].[product].[product_line] [pl]` in `SELECT`.
    In other words, we expect that the three usages of the local `pl` variable will
    magically render the output that makes more sense for us. Well, this isn't true!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不正确！这里的问题与我们的期望有关。我们期望`PRODUCT.PRODUCT_LINE.as("pl")`在`ORDER BY`中产生`[pl]`，在`GROUP
    BY`中产生`[classicmodels].[dbo].[product].[product_line]`，在`SELECT`中产生`[classicmodels].[dbo].[product].[product_line]
    [pl]`。换句话说，我们期望局部变量`pl`的三种使用方式能够神奇地渲染出对我们更有意义的输出。但是，这不是真的！
- en: 'Think about the jOOQ DSL more as an expression tree. So, we can store both
    `PRODUCT.PRODUCT_LINE` and `PRODUCT.PRODUCT_LINE.as("pl")` in separate local variables,
    and explicitly reuse the one that makes the most sense:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑jOOQ DSL更像是表达式树。因此，我们可以将`PRODUCT.PRODUCT_LINE`和`PRODUCT.PRODUCT_LINE.as("pl")`存储在单独的局部变量中，并明确重用那个最有意义的：
- en: '[PRE94]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This time, it is correct!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，这是正确的！
- en: Important Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Reusing the `x.as("y")` expression in a query and thinking that it "magically"
    produces `x` or `y`, whatever makes more sense, is a really bad understanding
    of jOOQ aliases. Thinking that `x.as("y")` generates `x` in `GROUP BY`, `y` in
    `ORDER BY`, and `x.as("y")` in `SELECT` is dangerous logic that will give you
    headaches. The aliased expression, `x.as("y")`, produces `y` "everywhere" outside
    of `SELECT`, and it produces the alias declaration in `SELECT` (but only immediately
    in `SELECT`). It "never" produces only `x`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询中重复使用`x.as("y")`表达式，并认为它“神奇地”产生`x`或`y`，无论哪个更有意义，这是对jOOQ别名的真正错误理解。认为`x.as("y")`在`GROUP
    BY`中生成`x`，在`ORDER BY`中生成`y`，在`SELECT`中生成`x.as("y")`是危险的逻辑，这会让你头疼。别名的表达式`x.as("y")`在`SELECT`之外“到处”产生`y`，并在`SELECT`中产生别名的声明（但只在`SELECT`中立即产生）。它“永远不会”只产生`x`。
- en: You can practice these examples in *AliasesSamples*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*AliasesSamples*中练习这些示例。
- en: Aliases and bad assumptions
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名和错误的假设
- en: 'Next, let''s consider the examples shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑以下截图所示的示例：
- en: '![Figure 16.3 – Aliases use case'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3 – 别名使用案例'
- en: '](img/B16833_Figure_16.3.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片/B16833_Figure_16.3.jpg]'
- en: Figure 16.3 – Aliases use case
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 别名使用案例
- en: 'What can you say about (A) and (B)? If you said that (A) is correct while (B)
    is wrong, then you are right. Congratulations! Speaking about (B), since we assigned
    an alias to the `[office]` table, the `[office].[city]` column becomes unknown.
    The rendered SQL highlights the following aspect:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你对（A）和（B）有什么看法？如果你说（A）是正确的，而（B）是错误的，那么你是正确的。恭喜！关于（B），由于我们给`[office]`表分配了一个别名，`[office].[city]`列就变得未知了。渲染的SQL突出了以下方面：
- en: '[PRE101]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'So, one simple and straightforward solution is to simply remove the alias.
    Now, let''s examine a few bad choices. First, let''s explore this one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个简单直接的方法就是简单地移除别名。现在，让我们考察几个错误的选项。首先，让我们探索这个：
- en: '[PRE103]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This construction is based on the assumption that jOOQ exposes a method, `field(String
    table_name, String field_name)`, but there is no such method! Then why does the
    preceding code compile? Because DSL exposes a `field(String sql, Object... bindings)`
    that is used for SQL templating, it's being used in the wrong context. Pay attention
    to such silly mistakes! Who didn't feel lucky and tried to use an API without
    reading the documentation?!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建基于这样的假设，即jOOQ公开了一个方法`field(String table_name, String field_name)`，但实际上没有这样的方法！那么为什么前面的代码可以编译呢？因为DSL公开了一个`field(String
    sql, Object... bindings)`，它用于SQL模板，它被用在了错误的环境中。注意这样的愚蠢错误！谁没有觉得幸运并试图在不阅读文档的情况下使用API呢？!
- en: Now, how about this one?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个怎么样？
- en: '[PRE107]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This is just another example built on wrong assumptions. While jOOQ exposes
    a `table(String sql)`, which is useful for returning a table that wraps the given
    plain SQL, this example assumes the existence of a `table(String alias)` that
    returns a table that wraps an alias and is aware of its fields.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是基于错误假设的另一个例子。虽然jOOQ公开了一个`table(String sql)`，这对于返回一个包装给定普通SQL的表很有用，但这个例子假设存在一个`table(String
    alias)`，它返回一个包装别名的表，并且知道其字段。
- en: 'Going further, let''s try this approach:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，让我们尝试这种方法：
- en: '[PRE112]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This approach works just fine but you must be aware that the unqualified `[city]`
    is prone to ambiguities. For instance, let''s say that we enrich this query, as
    follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以正常工作，但你必须意识到，未限定的`[city]`容易产生歧义。例如，假设我们按照以下方式丰富这个查询：
- en: '[PRE116]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This leads to an ambiguous column, `[city]`, because it''s unclear if we are
    referring to `OFFICE.CITY` or `CUSTOMERDETAIL.CITY`. In this case, table aliases
    can help us express this clearly:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个模糊的列，`[city]`，因为它不清楚我们是引用`OFFICE.CITY`还是`CUSTOMERDETAIL.CITY`。在这种情况下，表别名可以帮助我们清楚地表达这一点：
- en: '[PRE119]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'It''s much better to declare aliases before using them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前声明别名要好得多：
- en: '[PRE123]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Now, let's look at another case and start with two wrong approaches. So, what's
    wrong here?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个案例，并从以下代码片段开始。那么，这里有什么问题？
- en: '[PRE133]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'After joining `OFFICE` and `DEPARTMENT`, the result contains two columns named
    `office_code` – one from `OFFICE` and another from `DEPARTMENT`. Joining this
    result with `EMPLOYEE` reveals that the `office_code` column in the `ON` clause
    is ambiguous. To remove this ambiguity, we can use aliased tables:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`OFFICE`和`DEPARTMENT`连接后，结果包含两个名为`office_code`的列——一个来自`OFFICE`，另一个来自`DEPARTMENT`。将此结果与`EMPLOYEE`连接显示，`ON`子句中的`office_code`列是模糊的。为了消除这种模糊性，我们可以使用别名的表：
- en: '[PRE141]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Is this correct? This time, we have associated aliases with our `OFFICE.as("o")`
    and `DEPARTMENT.as("d")` tables. While joining `OFFICE` with `DEPARTMENT`, we
    correctly used the aliases, but when we joined the result to `EMPLOYEE`, we didn''t
    use the `OFFICE` alias – we used the un-aliased `OFFICE.OFFICE_CODE`. This is
    rendered in MySQL as `` `classicmodels`.`office`.`office_code` `` and it represents
    an unknown column in the `ON` clause. So, the correct expression is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这正确吗？这次，我们已经将别名与我们的`OFFICE.as("o")`和`DEPARTMENT.as("d")`表相关联。在将`OFFICE`与`DEPARTMENT`连接时，我们正确地使用了别名，但当我们将结果连接到`EMPLOYEE`时，我们没有使用`OFFICE`别名——我们使用了未别名的`OFFICE.OFFICE_CODE`。这在MySQL中表示为``
    `classicmodels`.`office`.`office_code` ``，它代表`ON`子句中的一个未知列。因此，正确的表达式如下：
- en: '[PRE149]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Can we write this more compact and type-safe? Sure we can – via local variables:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将其写得更紧凑且类型安全？当然可以——通过局部变量：
- en: '[PRE158]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Again, local variables help us express aliases and obtain elegant code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，局部变量帮助我们表达别名并获得优雅的代码。
- en: Aliases and typos
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名和打字错误
- en: 'Next, let''s look at another way to extract aliases in local variables. Check
    out the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一种在局部变量中提取别名的办法。查看以下代码：
- en: '[PRE166]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'There is a mistake (a typo) in this expression. Can you spot it? (It isn''t
    easy!) If not, you''ll end up with valid SQL that returns inaccurate results.
    The typo snuck into the `.and(field("s1.product_line").eq("s2.product_line")))`
    part of the code, which should be `.and(field("s1.product_line").eq(field("s2.product_line"))))`.
    But if we extract the aliases in local variables, then the code eliminates the
    risk of a typo and increases the readability of the expression (notice that `s1`,
    `s2`, `s3`, and `s4` are not equal objects and that they cannot be used interchangeably):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式中有一个错误（一个打字错误）。你能找到它吗？（这并不容易！）如果不能，你将得到一个有效的SQL语句，但它返回不准确的结果。这个打字错误悄悄地进入了代码的`.and(field("s1.product_line").eq("s2.product_line")))`部分，它应该是`.and(field("s1.product_line").eq(field("s2.product_line"))))`。但如果我们在局部变量中提取别名，那么代码就消除了打字错误的风险，并提高了表达式的可读性（注意`s1`、`s2`、`s3`和`s4`不是相等对象，它们不能互换使用）：
- en: '[PRE176]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: You can practice these examples in *AliasesSamples*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*AliasesSamples*中练习这些例子。
- en: Aliases and derived tables
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名和派生表
- en: 'Let''s look at another example that starts with the following snippet of code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，它从以下代码片段开始：
- en: '[PRE190]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'So, what''s wrong here?! Let''s inspect the generated SQL (this is for MySQL):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里有什么问题？！让我们检查生成的SQL（这是针对MySQL的）：
- en: '[PRE200]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: As you can see, jOOQ has automatically associated an alias with the derived
    table (`alias_84938429`) that was obtained from `JOIN` and used this alias to
    reference `customer_number`, `customer_name`, and `invoice_amount`. While `customer_number`
    and `customer_name` are correctly qualified and quoted, `invoice_amount` has been
    incorrectly rendered as `t.invoice_amount`. The problem is in `field("t.invoice_amount")`,
    which instructs jOOQ that the column name is `t.invoice_amount`, not `invoice_amount`,
    so the resulting `` `alias_84938429`.t.invoice_amount `` is an unknown column.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，jOOQ已自动将一个别名与从`JOIN`获得的派生表（`alias_84938429`）相关联，并使用此别名来引用`customer_number`、`customer_name`和`invoice_amount`。虽然`customer_number`和`customer_name`被正确地限定和引用，但`invoice_amount`被错误地表示为`t.invoice_amount`。问题在于`field("t.invoice_amount")`，它指示jOOQ列名是`t.invoice_amount`，而不是`invoice_amount`，因此结果``
    `alias_84938429`.t.invoice_amount ``是一个未知列。
- en: 'There are a few solutions to this problem, and one of them consists of using
    `name()` for proper quoting and qualifying:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种解决方案可以解决这个问题，其中之一是使用`name()`来进行适当的引号和限定：
- en: '[PRE215]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: This time, jOOQ renders `` `alias_10104609`.`invoice_amount` ``. In the bundled
    code, you can see four more solutions to this problem.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，jOOQ渲染了` `alias_10104609`.`invoice_amount` ``。在捆绑的代码中，您可以看到针对此问题的四个更多解决方案。
- en: 'To understand this context, let''s check out the following example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个上下文，让我们看看以下示例：
- en: '[PRE225]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Here, we have explicitly associated column aliases with the inner `SELECT`,
    but we did not associate an alias with the derived table produced by `JOIN`. These
    aliases are further used to reference the columns outside this `SELECT` (in the
    outer `SELECT`). Notice that we let jOOQ qualify these aliases to the generated
    alias for the divided table accordingly:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确地将列别名与内部`SELECT`关联起来，但没有将别名与由`JOIN`产生的派生表关联起来。这些别名进一步用于引用此`SELECT`（外部`SELECT`）之外的列。请注意，我们让jOOQ将这些别名限定为生成的分割表的别名：
- en: '[PRE234]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'If we want to control the alias of the derived table as well, then we can do
    the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要控制派生表的别名，则可以这样做：
- en: '[PRE246]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'This time, the rendered SQL uses our table alias:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，渲染的SQL使用了我们的表别名：
- en: '[PRE257]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'Finally, here is a more verbose example of using aliases:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一个使用别名的更详细示例：
- en: '[PRE268]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Take your time to analyze this expression and the generated SQL:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 请花时间分析这个表达式和生成的SQL：
- en: '[PRE282]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Now, let's look at a few more examples of using aliases.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看更多使用别名的例子。
- en: Derived column list
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派生列列表
- en: 'When column names are not known in advance (but the table''s degree is!), we
    can use the so-called *derived column list*. You saw many examples of using this
    feature with unnested tables, so here are two more for the `VALUES()` table constructor
    and a regular table:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当列名事先未知（但表度已知！）时，我们可以使用所谓的*派生列列表*。您已经看到了许多使用此功能与未嵌套表的例子，所以这里再提供两个关于`VALUES()`表构造器和常规表的例子：
- en: '[PRE299]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'The following code is for a regular table:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是针对常规表的：
- en: '[PRE301]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: If you are not familiar with these kinds of aliases, take your time to inspect
    the rendered SQL and read some documentation.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这类别名，请花时间检查渲染的SQL并阅读一些文档。
- en: Aliases and the CASE expression
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名和CASE表达式
- en: 'Aliases can be used with `CASE` expressions as well. Here is an example:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 别名也可以与`CASE`表达式一起使用。以下是一个示例：
- en: '[PRE313]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'They can also be used in `FILTER WHERE` expressions:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用于`FILTER WHERE`表达式：
- en: '[PRE323]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: As you can see, using aliases in `CASE`/`FILTER` expressions is quite handy
    since it allows us to express the meaning of each case better.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在`CASE`/`FILTER`表达式中使用别名非常方便，因为它允许我们更好地表达每个案例的含义。
- en: Aliases and IS NOT NULL
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名和IS NOT NULL
- en: 'Aliases can be used with `IS NOT NULL` (and companions) if we wrap our `Condition`
    in `field()` to obtain a `Field<Boolean>`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Condition`包裹在`field()`中，以获得`Field<Boolean>`，则可以使用别名与`IS NOT NULL`（及其相关项）一起使用：
- en: '[PRE333]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: Finally, let's take a quick look at aliases and CTEs.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速看一下别名和CTE。
- en: Aliases and CTEs
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名和CTE（公用表表达式）
- en: In [*Chapter 14*](B16833_14.xhtml#_idTextAnchor284), *Derived Tables, CTEs,
    and Views*, we looked at tons of examples of using aliases in CTEs and derived
    tables, so please consider that chapter if you wish to become familiar with this
    topic. Next, let's talk about SQL templating.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第14章*](B16833_14.xhtml#_idTextAnchor284)“派生表、CTE和视图”中，我们探讨了在CTE和派生表中使用别名的许多示例，所以如果您想熟悉这个主题，请考虑这一章。接下来，让我们谈谈SQL模板。
- en: SQL templating
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL模板
- en: When we talk about SQL templating or the Plain SQL Templating Language, we're
    talking about covering those cases where the DSL cannot help us express our SQL.
    The jOOQ DSL strives to cover SQL as much as possible by constantly adding more
    and more features, but it is normal to still find some corner case syntax or vendor-specific
    features that won't be covered by the DSL. In such cases, jOOQ allows us to express
    SQL as plain SQL strings with bind values or query parts via the Plain SQL API.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论SQL模板或纯SQL模板语言时，我们是在谈论那些DSL无法帮助我们表达SQL的情况。jOOQ DSL通过不断添加更多功能，力求尽可能覆盖SQL，但仍然可能会发现一些角落案例语法或供应商特定的功能不会被DSL覆盖。在这种情况下，jOOQ允许我们通过纯SQL字符串或查询部分（{0}，{1}，……）使用Plain
    SQL API来表示SQL。
- en: 'The Plain SQL API materializes in a set of overloaded methods that can be used
    where the DSL doesn''t help. Here are some examples:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 纯SQL API在一系列重载方法中实现，可以在DSL无法提供帮助的地方使用。以下是一些示例：
- en: '[PRE338]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'So, we can pass SQL as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以按以下方式传递SQL：
- en: Plain SQL strings
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯SQL字符串
- en: Plain SQL strings and bindings (?)
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯SQL字符串和绑定(?)
- en: Plain SQL strings and `QueryPart` ({0}, {1}, …)
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯SQL字符串和`QueryPart`
- en: Binding and the query part argument overloads use the so-called Plain SQL Templating
    Language.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定和查询部分重载使用所谓的纯 SQL 模板语言。
- en: 'Here are several examples of using plain SQL with bind values (these examples
    are available in *SQLTemplating*):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用纯 SQL 和绑定值的示例（这些示例在 *SQLTemplating* 中可用）：
- en: '[PRE350]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'Now, let''s look at some examples to help you become familiar with the technique
    of mixing plain SQL with SQL expressed via DSL. Let''s consider the following
    MySQL query:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些示例，帮助你熟悉将纯 SQL 与通过 DSL 表达的 SQL 混合的技术。让我们考虑以下 MySQL 查询：
- en: '[PRE366]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'If you are a jOOQ novice and you''re trying to express this query via the jOOQ
    DSL, then you''ll probably encounter some issues in the highlighted code. Can
    we express that part via the DSL? The answer is yes, but if we cannot find the
    proper solution, then we can embed it as plain SQL as well. Here is the code:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 jOOQ 新手，并且试图通过 jOOQ DSL 表达此查询，那么你可能会在突出显示的代码中遇到一些问题。我们能否通过 DSL 表达这部分？答案是肯定的，但如果找不到适当的解决方案，我们也可以将其嵌入为纯
    SQL。以下是代码：
- en: '[PRE379]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: 'Done! Of course, once you become more familiar with the jOOQ DSL, you''ll be
    able to express this query 100% via the DSL, and let jOOQ emulate it accordingly
    (much better!):'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！当然，一旦你更熟悉 jOOQ DSL，你将能够通过 DSL 100% 表达此查询，并让 jOOQ 适当模拟（更好！）：
- en: '[PRE395]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: 'But sometimes, you''ll need SQL templating. For instance, MySQL defines a function,
    `CONCAT_WS(separator, exp1, exp2, exp3,...)`, that adds two or more expressions
    together with the given separator. This function doesn''t have a jOOQ correspondent,
    so we can use it via SQL templating (here, plain SQL and query parts), as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，你需要 SQL 模板。例如，MySQL 定义了一个函数，`CONCAT_WS(separator, exp1, exp2, exp3,...)`，该函数使用给定的分隔符将两个或多个表达式组合在一起。此函数没有
    jOOQ 对应项，因此我们可以通过 SQL 模板（这里为纯 SQL 和查询部分）使用它，如下所示：
- en: '[PRE403]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: 'Since the number of parts to concatenate can vary, it will be more practical
    to rely on the convenient `DSL.list(QueryPart...)`, which allows us to define
    a comma-separated list of query parts in a single template argument:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 由于要连接的部分数量可能不同，因此依赖方便的 `DSL.list(QueryPart...)` 会更实用，它允许我们在单个模板参数中定义逗号分隔的查询部分列表：
- en: '[PRE409]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: This time, the template argument, `{1}`, has been replaced with the list of
    strings that should be concatenated. Now, you can simply pass that list.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，模板参数 `{1}` 已被替换为应连接的字符串列表。现在，你可以简单地传递那个列表。
- en: The jOOQ DSL also doesn't support MySQL variables (`@variable`). For instance,
    how would you express the following MySQL query, which uses the `@type` and `@num`
    variables?
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ DSL 也不支持 MySQL 变量 (`@variable`)。例如，你将如何表达以下使用 `@type` 和 `@num` 变量的 MySQL
    查询？
- en: '[PRE415]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'Here''s SQL templating to the rescue:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 SQL 模板可以救命：
- en: '[PRE423]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: You can practice these examples, along with others, in *SQLTemplating*.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *SQLTemplating* 中练习这些示例以及其他示例。
- en: SQL templating is also useful when we need to work with certain data types,
    such as the PostgreSQL `HSTORE` data type. We know that jOOQ allows us to define
    converters and bindings, especially for dealing with such types. In [*Chapter
    7*](B16833_07.xhtml#_idTextAnchor110), *Types, Converters, and Bindings*, we wrote
    an `org.jooq.Converter` and an `org.jooq.Binding` for the `HSTORE` data type.
    Moreover, the `jooq-postgres-extensions` module supports `HSTORE` as well.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要处理某些数据类型时，SQL 模板也非常有用，例如 PostgreSQL 的 `HSTORE` 数据类型。我们知道 jOOQ 允许我们定义转换器和绑定，特别是用于处理此类类型。在
    [*第 7 章*](B16833_07.xhtml#_idTextAnchor110)，*类型、转换器和绑定* 中，我们为 `HSTORE` 数据类型编写了一个
    `org.jooq.Converter` 和一个 `org.jooq.Binding`。此外，`jooq-postgres-extensions` 模块也支持
    `HSTORE`。
- en: 'However, using SQL templating can represent a quick solution as well – for
    instance, you may only need to write a few queries and you don''t have time to
    write a converter/binding. We can insert this into our `HSTORE` (`PRODUCT.SPECS`)
    via SQL templating, as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 SQL 模板也可以是一个快速解决方案——例如，你可能只需要编写几个查询，而没有时间编写转换器/绑定。我们可以通过 SQL 模板将此插入到我们的
    `HSTORE` (`PRODUCT.SPECS`) 中，如下所示：
- en: '[PRE430]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'We can select everything from a `HSTORE` like so:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样从 `HSTORE` 中选择所有内容：
- en: '[PRE439]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: Notice that both examples rely on `org.postgresql.util.HStoreConverter`.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个示例都依赖于 `org.postgresql.util.HStoreConverter`。
- en: 'Other operations that are performed against an `HSTORE` rely on vendor-specific
    operators. Using such operators is a perfect job for SQL templating. For instance,
    getting an `HSTORE` entry by its key can be done by respecting the PostgreSQL
    syntax, as shown here:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `HSTORE` 执行的其他操作依赖于特定供应商的运算符。使用此类运算符是 SQL 模板的一个完美工作。例如，可以通过尊重 PostgreSQL 语法来获取
    `HSTORE` 的条目，如下所示：
- en: '[PRE447]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'Alternatively, we can delete entries by key, as shown here:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'We can also convert an `HSTORE` into JSON:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'More examples are available in the bundled code – *SQLTemplating* for PostgreSQL.
    If you need these operators more often, then you should retrieve their SQL templating
    code in static/utility methods and simply call those methods. For example, a get-by-key
    method can be expressed as follows:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: 'We can also define CTE via SQL templating. Here is an example of defining a
    CTE via `ResultQuery` and SQL templating:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'This code still uses `ResultQuery` and SQL templating, but this time, the plain
    SQL looks as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: More examples are available in *SQLTemplating* for PostgreSQL.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'How about calling some SQL Server functions? Let''s try to call a function
    that returns an integer that measures the difference between the `SOUNDEX()` values
    of two different character expressions. Yes – the `DIFFERENCE()` function:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: How about calling the `FORMAT()` function?
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: 'Now, let''s try the following SQL Server batch, which uses SQL Server local
    variables:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: 'Again, combining SQL and SQL templating comes to the rescue:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: You can practice these examples in *SQLTemplating* for SQL Server.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve looked at examples that are specific to MySQL, PostgreSQL, and
    SQL Server. Finally, let''s add one for Oracle. For instance, if you plan to update/delete
    records that are referenced by a `SELECT FOR UPDATE` statement, you can use a
    `WHERE CURRENT OF` statement. The following example uses SQL templating to build
    such a SQL sample:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: 'The SQL is as follows:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: You can practice these examples in *SQLTemplating* for Oracle.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, especially for those corner cases that require complex SQL clauses,
    jOOQ exposes a set of classes that are very well exemplified in the official documentation:
    [https://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-queryparts/](https://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-queryparts/).'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a short but comprehensive chapter about jOOQ aliases and SQL templating.
    In jOOQ, most of the time, you can have a peaceful life without being a power
    user of these features, but when they come into play, it is nice to understand
    their basics and exploit them.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tackle multitenancy.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
