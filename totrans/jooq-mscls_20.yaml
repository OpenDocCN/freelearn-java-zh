- en: '*Chapter 16*: Tackling Aliases and SQL Templating'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers two important topics that sustain your road to becoming
    a jOOQ power user: aliases and SQL templating.'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this chapter tackles several practices for aliasing tables
    and columns via the jOOQ DSL. The goal of this part is to make you comfortable
    when you need to express your SQL aliases via jOOQ and to provide you with a comprehensive
    list of examples that cover the most common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this chapter is all about SQL templating or how to express
    SQL when the jOOQ DSL cannot help us. There will be rare cases when you'll have
    to write plain SQL or combine DSL and plain SQL to obtain some corner cases or
    vendor-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Expressing SQL aliases in jOOQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL templating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Expressing SQL aliases in jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL aliasing is a simple task. After all, it''s just about giving some nicknames
    to your columns and tables and referring to them via these nicknames instead of
    using their real names. But as simple as this may seem, this is a rather controversial
    topic. Some of the open questions you may come across will sound like this: Should
    I only use aliases when it''s mandatory (for instance, when I reference the same
    table twice)? Should I use meaningful names or will single letters work just fine
    (`p`, `q`, `t1`, `t2`, and so on)? Do they increase readability and decrease typing
    time? Most probably, the correct answer is that it depends… on the context, on
    the query, on who is writing the query (a developer, a DBA, a generator), and
    so on!'
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see shortly, using aliasing via a DSL requires us to respect several
    rules and to be prepared for some verbosity since the host language (here, Java)
    comes with several shortcomings that a DSL must address as elegantly as possible.
    Aliasing sits next to derived tables, arithmetic expressions, and casting as one
    of the main challenges for a DSL, so let's see exactly what we should know about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The examples from the following sections are available via *SimpleAliases* and
    *AliasesSamples*.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing simple aliased tables and columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Independent of how you like to use SQL aliases, when you want to express them
    in jOOQ, you must be aware of several methods, including `as()` and `asTable()`,
    which come in many flavors, such as `as(String alias)`, `as(Name alias)`, `as(Name
    as, Name... fieldAliases)`, `asTable()`, `asTable(String alias)`, `asTable(Name
    alias)`, `asTable(Table<?> alias)`, and so on. Commonly, we must deal with aliased
    tables and fields. Here is a quick sample of using aliased tables in jOOQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of using some aliased fields (used here to take
    full control of the column names that are generated in your SQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll look at some more complex examples of using aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and JOINs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the common cases where we see SQL aliases at work is in `JOIN` statements.
    Instead of repeating the table names, people prefer to associate aliases with
    the joined tables and refer to them via these aliases. For instance, in the following
    screenshot, we have a `JOIN` between two MySQL tables (`OFFICE` and `DEPARTMENT`)
    expressed without aliases (top) and with aliases (bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – JOIN with and without aliases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_16.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – JOIN with and without aliases
  prefs: []
  type: TYPE_NORMAL
- en: 'If we express the first SQL in jOOQ (without using aliases) then we obtain
    this – in jOOQ, whenever you can omit the usage of aliases, do it! This way, you
    have better a chance to obtain clean expressions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a clean and readable jOOQ snippet of code. Since jOOQ generates the
    SQL on our behalf, we don't feel the need to add some aliases to increase readability
    or reduce the typing time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, next, let''s add the proper aliases to obtain the second SQL.
    As our first attempt, we may have written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So, we have associated the `t1` alias with the `OFFICE` table via `OFFICE.as("t1")`,
    and the `t2` alias with the `DEPARTMENT` table via `DEPARTMENT.as("t2")`. Furthermore,
    we used our aliases via the `field()` method as `t1` and `t2`, respectively. Besides
    losing some readability in the jOOQ code, have you spotted other issues in this
    code compared to the jOOQ code without aliases? Sure you did – it's not type-safe
    and it renders unquoted identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: When we say `field("t1.city")`, jOOQ renders `t1.city`, not `` `t1`.`city` ``
    (in MySQL). However, it is advisable to strive for qualified and quoted identifiers
    to avoid name conflicts and potential errors (for instance, using a keyword such
    as `ORDER` as an unquoted table name leads to errors). Generally speaking, quoted
    identifiers allow us to use reserved names as object names (for instance, `ORDER`),
    use special characters in object names (whitespaces and so on), and instructs
    (most databases) us to treat case-insensitive identifiers as case-sensitive ones
    (for example, `"address"` and `"ADDRESS"` are different identifiers, whereas `address`
    and `ADDRESS` are not).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, jOOQ can render qualified and quoted identifiers if we rely on explicitly
    using `DSL.name()`, which is a very handy `static` method that comes in several
    flavors and it is useful for constructing SQL-injection-safe, syntax-safe SQL
    identifiers for use in plain SQL. It is commonly used in the `table()` and `field()`
    methods – for example, `name(table_name, field_name)` – but you can check out
    all the flavors in the documentation. The following table represents what jOOQ
    renders for different usages of the `name()` method and different databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Using jOOQ name()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_16.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.2 – Using jOOQ name()
  prefs: []
  type: TYPE_NORMAL
- en: 'When an identifier occurs several times, it can be extracted in a local variable
    as a `Name` and reused in queries as needed, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When jOOQ evaluates `name("ORDER", "ORDER_ID")` (for MySQL), it renders ``
    `ORDER`.`ORDER_ID` ``. Of course, `ORDER_ID` doesn''t necessarily need the back
    ticks – only `ORDER` does. Playing with quotations for identifiers can be done
    via `quotedName()` and `unquotedName()` of the `DSL` class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, jOOQ allows us to control (globally or at the query level) how identifiers
    are quoted via the `RenderQuotedNames` setting and cases via the `RenderNameCase`
    setting. For instance, we can instruct jOOQ to quote all the identifiers in the
    upper part of the current query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: While you can find more details about these settings in the documentation ([https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/](https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/settings-name-style/)),
    keep in mind that they only affect identifiers that are expressed via Java-based
    schemas or `name()`. In other words, they have no effect on `field("identifier")`
    and `table("identifier")`. These are rendered exactly as you provide them.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ doesn't force us in any way to use quoting, qualifications, and cases consistently
    in the same query or across multiple queries (since jOOQ renders by default).
    However, juggling these aspects may lead to issues, from inconsistent results
    to SQL errors. This happens because, in some databases (for instance, SQL Server),
    identifiers are always case insensitive. This means that quoting only helps to
    allow special characters or escape keywords in identifiers. In other databases
    (for instance, Oracle), identifiers are only case insensitive if they are unquoted,
    while quoted identifiers are case sensitive. However, there are also databases
    (for instance, Sybase ASE) where identifiers are always case sensitive, regardless
    of them being quoted. Again, quoting only helps to allow special characters or
    escape keywords in identifiers. And, let's not forget the dialects (for instance,
    MySQL) that mix the preceding rules, depending on the operating system, object
    type, configuration, and other events.
  prefs: []
  type: TYPE_NORMAL
- en: So, pay attention to how you decide to handle quoting, qualification, and case
    sensitivity aspects. The best/safest way is to express queries via the Java-based
    schema, use aliases only when they are mandatory, and always use `name()` if you
    have to refer to identifiers as plain strings. From that point on, let jOOQ do
    the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, if we apply `name()` to our query, we obtain the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the rendered identifiers correspond to our expectations, but this
    snippet of jOOQ code is still not type-safe. To transform this non-type-safe query
    into a type-safe one, we must extract the aliases and define them in local variables
    before using them, as follows (notice that there is no reason to explicitly use
    `name()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you may prefer a minimalist aliasing approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `as()` method on the generated tables (here, on `OFFICE` and `DEPARTMENT`)
    returns an object of the same type as the table (`jooq.generated.tables.Office`
    and `jooq.generated.tables.Department`). The resulting object can be used to dereference
    fields from the aliased table in a type-safe way. So, thanks to `as()`, `Office`,
    and `Department`, we are type-safe again while using the desired table aliases.
    And, of course, the identifiers are implicitly rendered, quoted, and qualified.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, in jOOQ, strive to extract and declare aliases in local
    variables before using them in queries. Do this especially if your aliases refer
    to the generated tables, are aliases that should be reused across multiple queries,
    you wish to increase the readability of the jOOQ expression and/or avoid typos,
    and so on. Of course, if your jOOQ expression simply associates some aliases to
    columns (to take full control of the column names that are generated in your SQL),
    then extracting them as local variables won't produce a significant improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a table that''s been aliased as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can refer to fields in a non-type-safe manner via `field(Name
    name)`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The same `field()` method can be applied to any type-unsafe aliased table as
    `Table<?>` to return `Field<?>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can make these fields look type-safe via the `<T> Field<T>
    field(Field<T> field)` method as well (introduced in [*Chapter 14*](B16833_14.xhtml#_idTextAnchor284)*,
    Derived Tables, CTEs, and Views*). The `t3.field(name("city"))` expression indirectly
    refers to the `t1.CITY` field, so we can rewrite our queries in a type-safe manner,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: However, remember that `Table.field(Field<T>):Field<T>` just looks type-safe.
    It's as good as an unsafe cast in Java because the lookup only considers the identifier,
    not the type. Nor does it coerce the expression.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good! You can practice these examples in *AliasesSamples*. Now, let's
    take some time to cover several fundamental aspects of jOOQ aliases and practice
    some simple but essential exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and GROUP BY/ORDER BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider the following SQL expressed in SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This query uses an alias named `pl` for the `PRODUCT_LINE` column. Attempting
    to express this query via jOOQ, based on what we learned earlier, may result in
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: But this isn't correct! The problem here is related to our expectations. We
    expect `PRODUCT.PRODUCT_LINE.as("pl")` to produce `[pl]` in `ORDER BY`, `[classicmodels].[dbo].[product].[product_line]`
    in `GROUP BY`, and `[classicmodels].[dbo].[product].[product_line] [pl]` in `SELECT`.
    In other words, we expect that the three usages of the local `pl` variable will
    magically render the output that makes more sense for us. Well, this isn't true!
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about the jOOQ DSL more as an expression tree. So, we can store both
    `PRODUCT.PRODUCT_LINE` and `PRODUCT.PRODUCT_LINE.as("pl")` in separate local variables,
    and explicitly reuse the one that makes the most sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This time, it is correct!
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Reusing the `x.as("y")` expression in a query and thinking that it "magically"
    produces `x` or `y`, whatever makes more sense, is a really bad understanding
    of jOOQ aliases. Thinking that `x.as("y")` generates `x` in `GROUP BY`, `y` in
    `ORDER BY`, and `x.as("y")` in `SELECT` is dangerous logic that will give you
    headaches. The aliased expression, `x.as("y")`, produces `y` "everywhere" outside
    of `SELECT`, and it produces the alias declaration in `SELECT` (but only immediately
    in `SELECT`). It "never" produces only `x`.
  prefs: []
  type: TYPE_NORMAL
- en: You can practice these examples in *AliasesSamples*.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and bad assumptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s consider the examples shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Aliases use case'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_16.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.3 – Aliases use case
  prefs: []
  type: TYPE_NORMAL
- en: 'What can you say about (A) and (B)? If you said that (A) is correct while (B)
    is wrong, then you are right. Congratulations! Speaking about (B), since we assigned
    an alias to the `[office]` table, the `[office].[city]` column becomes unknown.
    The rendered SQL highlights the following aspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'So, one simple and straightforward solution is to simply remove the alias.
    Now, let''s examine a few bad choices. First, let''s explore this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This construction is based on the assumption that jOOQ exposes a method, `field(String
    table_name, String field_name)`, but there is no such method! Then why does the
    preceding code compile? Because DSL exposes a `field(String sql, Object... bindings)`
    that is used for SQL templating, it's being used in the wrong context. Pay attention
    to such silly mistakes! Who didn't feel lucky and tried to use an API without
    reading the documentation?!
  prefs: []
  type: TYPE_NORMAL
- en: Now, how about this one?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This is just another example built on wrong assumptions. While jOOQ exposes
    a `table(String sql)`, which is useful for returning a table that wraps the given
    plain SQL, this example assumes the existence of a `table(String alias)` that
    returns a table that wraps an alias and is aware of its fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, let''s try this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach works just fine but you must be aware that the unqualified `[city]`
    is prone to ambiguities. For instance, let''s say that we enrich this query, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to an ambiguous column, `[city]`, because it''s unclear if we are
    referring to `OFFICE.CITY` or `CUSTOMERDETAIL.CITY`. In this case, table aliases
    can help us express this clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s much better to declare aliases before using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at another case and start with two wrong approaches. So, what's
    wrong here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'After joining `OFFICE` and `DEPARTMENT`, the result contains two columns named
    `office_code` – one from `OFFICE` and another from `DEPARTMENT`. Joining this
    result with `EMPLOYEE` reveals that the `office_code` column in the `ON` clause
    is ambiguous. To remove this ambiguity, we can use aliased tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Is this correct? This time, we have associated aliases with our `OFFICE.as("o")`
    and `DEPARTMENT.as("d")` tables. While joining `OFFICE` with `DEPARTMENT`, we
    correctly used the aliases, but when we joined the result to `EMPLOYEE`, we didn''t
    use the `OFFICE` alias – we used the un-aliased `OFFICE.OFFICE_CODE`. This is
    rendered in MySQL as `` `classicmodels`.`office`.`office_code` `` and it represents
    an unknown column in the `ON` clause. So, the correct expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we write this more compact and type-safe? Sure we can – via local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Again, local variables help us express aliases and obtain elegant code.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and typos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s look at another way to extract aliases in local variables. Check
    out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a mistake (a typo) in this expression. Can you spot it? (It isn''t
    easy!) If not, you''ll end up with valid SQL that returns inaccurate results.
    The typo snuck into the `.and(field("s1.product_line").eq("s2.product_line")))`
    part of the code, which should be `.and(field("s1.product_line").eq(field("s2.product_line"))))`.
    But if we extract the aliases in local variables, then the code eliminates the
    risk of a typo and increases the readability of the expression (notice that `s1`,
    `s2`, `s3`, and `s4` are not equal objects and that they cannot be used interchangeably):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *AliasesSamples*.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and derived tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at another example that starts with the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what''s wrong here?! Let''s inspect the generated SQL (this is for MySQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, jOOQ has automatically associated an alias with the derived
    table (`alias_84938429`) that was obtained from `JOIN` and used this alias to
    reference `customer_number`, `customer_name`, and `invoice_amount`. While `customer_number`
    and `customer_name` are correctly qualified and quoted, `invoice_amount` has been
    incorrectly rendered as `t.invoice_amount`. The problem is in `field("t.invoice_amount")`,
    which instructs jOOQ that the column name is `t.invoice_amount`, not `invoice_amount`,
    so the resulting `` `alias_84938429`.t.invoice_amount `` is an unknown column.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few solutions to this problem, and one of them consists of using
    `name()` for proper quoting and qualifying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: This time, jOOQ renders `` `alias_10104609`.`invoice_amount` ``. In the bundled
    code, you can see four more solutions to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this context, let''s check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have explicitly associated column aliases with the inner `SELECT`,
    but we did not associate an alias with the derived table produced by `JOIN`. These
    aliases are further used to reference the columns outside this `SELECT` (in the
    outer `SELECT`). Notice that we let jOOQ qualify these aliases to the generated
    alias for the divided table accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to control the alias of the derived table as well, then we can do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the rendered SQL uses our table alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is a more verbose example of using aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Take your time to analyze this expression and the generated SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at a few more examples of using aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Derived column list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When column names are not known in advance (but the table''s degree is!), we
    can use the so-called *derived column list*. You saw many examples of using this
    feature with unnested tables, so here are two more for the `VALUES()` table constructor
    and a regular table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for a regular table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: If you are not familiar with these kinds of aliases, take your time to inspect
    the rendered SQL and read some documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and the CASE expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aliases can be used with `CASE` expressions as well. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be used in `FILTER WHERE` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using aliases in `CASE`/`FILTER` expressions is quite handy
    since it allows us to express the meaning of each case better.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and IS NOT NULL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aliases can be used with `IS NOT NULL` (and companions) if we wrap our `Condition`
    in `field()` to obtain a `Field<Boolean>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's take a quick look at aliases and CTEs.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases and CTEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 14*](B16833_14.xhtml#_idTextAnchor284), *Derived Tables, CTEs,
    and Views*, we looked at tons of examples of using aliases in CTEs and derived
    tables, so please consider that chapter if you wish to become familiar with this
    topic. Next, let's talk about SQL templating.
  prefs: []
  type: TYPE_NORMAL
- en: SQL templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about SQL templating or the Plain SQL Templating Language, we're
    talking about covering those cases where the DSL cannot help us express our SQL.
    The jOOQ DSL strives to cover SQL as much as possible by constantly adding more
    and more features, but it is normal to still find some corner case syntax or vendor-specific
    features that won't be covered by the DSL. In such cases, jOOQ allows us to express
    SQL as plain SQL strings with bind values or query parts via the Plain SQL API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Plain SQL API materializes in a set of overloaded methods that can be used
    where the DSL doesn''t help. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can pass SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Plain SQL strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain SQL strings and bindings (?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain SQL strings and `QueryPart` ({0}, {1}, …)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding and the query part argument overloads use the so-called Plain SQL Templating
    Language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several examples of using plain SQL with bind values (these examples
    are available in *SQLTemplating*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at some examples to help you become familiar with the technique
    of mixing plain SQL with SQL expressed via DSL. Let''s consider the following
    MySQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are a jOOQ novice and you''re trying to express this query via the jOOQ
    DSL, then you''ll probably encounter some issues in the highlighted code. Can
    we express that part via the DSL? The answer is yes, but if we cannot find the
    proper solution, then we can embed it as plain SQL as well. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Of course, once you become more familiar with the jOOQ DSL, you''ll be
    able to express this query 100% via the DSL, and let jOOQ emulate it accordingly
    (much better!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: 'But sometimes, you''ll need SQL templating. For instance, MySQL defines a function,
    `CONCAT_WS(separator, exp1, exp2, exp3,...)`, that adds two or more expressions
    together with the given separator. This function doesn''t have a jOOQ correspondent,
    so we can use it via SQL templating (here, plain SQL and query parts), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the number of parts to concatenate can vary, it will be more practical
    to rely on the convenient `DSL.list(QueryPart...)`, which allows us to define
    a comma-separated list of query parts in a single template argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: This time, the template argument, `{1}`, has been replaced with the list of
    strings that should be concatenated. Now, you can simply pass that list.
  prefs: []
  type: TYPE_NORMAL
- en: The jOOQ DSL also doesn't support MySQL variables (`@variable`). For instance,
    how would you express the following MySQL query, which uses the `@type` and `@num`
    variables?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s SQL templating to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples, along with others, in *SQLTemplating*.
  prefs: []
  type: TYPE_NORMAL
- en: SQL templating is also useful when we need to work with certain data types,
    such as the PostgreSQL `HSTORE` data type. We know that jOOQ allows us to define
    converters and bindings, especially for dealing with such types. In [*Chapter
    7*](B16833_07.xhtml#_idTextAnchor110), *Types, Converters, and Bindings*, we wrote
    an `org.jooq.Converter` and an `org.jooq.Binding` for the `HSTORE` data type.
    Moreover, the `jooq-postgres-extensions` module supports `HSTORE` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, using SQL templating can represent a quick solution as well – for
    instance, you may only need to write a few queries and you don''t have time to
    write a converter/binding. We can insert this into our `HSTORE` (`PRODUCT.SPECS`)
    via SQL templating, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'We can select everything from a `HSTORE` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: Notice that both examples rely on `org.postgresql.util.HStoreConverter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other operations that are performed against an `HSTORE` rely on vendor-specific
    operators. Using such operators is a perfect job for SQL templating. For instance,
    getting an `HSTORE` entry by its key can be done by respecting the PostgreSQL
    syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can delete entries by key, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also convert an `HSTORE` into JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'More examples are available in the bundled code – *SQLTemplating* for PostgreSQL.
    If you need these operators more often, then you should retrieve their SQL templating
    code in static/utility methods and simply call those methods. For example, a get-by-key
    method can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define CTE via SQL templating. Here is an example of defining a
    CTE via `ResultQuery` and SQL templating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'This code still uses `ResultQuery` and SQL templating, but this time, the plain
    SQL looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in *SQLTemplating* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about calling some SQL Server functions? Let''s try to call a function
    that returns an integer that measures the difference between the `SOUNDEX()` values
    of two different character expressions. Yes – the `DIFFERENCE()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: How about calling the `FORMAT()` function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try the following SQL Server batch, which uses SQL Server local
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, combining SQL and SQL templating comes to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *SQLTemplating* for SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve looked at examples that are specific to MySQL, PostgreSQL, and
    SQL Server. Finally, let''s add one for Oracle. For instance, if you plan to update/delete
    records that are referenced by a `SELECT FOR UPDATE` statement, you can use a
    `WHERE CURRENT OF` statement. The following example uses SQL templating to build
    such a SQL sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *SQLTemplating* for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, especially for those corner cases that require complex SQL clauses,
    jOOQ exposes a set of classes that are very well exemplified in the official documentation:
    [https://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-queryparts/](https://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-queryparts/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a short but comprehensive chapter about jOOQ aliases and SQL templating.
    In jOOQ, most of the time, you can have a peaceful life without being a power
    user of these features, but when they come into play, it is nice to understand
    their basics and exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tackle multitenancy.
  prefs: []
  type: TYPE_NORMAL
