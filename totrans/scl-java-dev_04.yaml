- en: Chapter 4. Testing Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter which language you are programming in, testing should be performed
    with great care, as it will not only document your code in a consistent way but
    will also be of great help for refactoring and maintenance activities, such as
    fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The Scala ecosystem largely follows Java trends towards testing at all levels,
    but with some differences. At many places, we will see that Scala is using **DSLs**
    (**Domain Specific** **Languages**), which makes the testing code very clear to
    read and understand. As a matter of fact, testing can be a good area to start
    with when introducing Scala, migrating progressively from an existing Java project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover some of the major testing tools and their
    usage through a number of code examples. We have already written a tiny JUnit-like
    test in Scala in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"),
    *Understanding the Scala Ecosystem*, so we will go from here and focus on BDD-style
    tests that belong to **Behavior Driven Development** (**BDD**). Agnostic to which
    technology stack is used, BDD has emerged in these past few years as a compliant
    choice for writing clear specifications in the Gherkin language (which is part
    of the cucumber framework and is explained at [http://cukes.info/gherkin.html](http://cukes.info/gherkin.html))
    on how code should behave. Already used in Java and many other languages, tests
    written in that style are often easier to understand and maintain as they are
    closer to plain English. They are one step closer to the true adoption of BDD
    that aims at making the business analysts write the test specifications in a structured
    way, which the programs can understand and implement. They often represent the
    sole documentation; it is therefore very important to keep them up to date and
    close to the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Scala primarily offers two frameworks to write tests, **ScalaTest** ([www.scalatest.org](http://www.scalatest.org))
    and **Specs2** ([etorreborre.github.io/specs2/](http://etorreborre.github.io/specs2/)).
    As they are quite similar to each other, we are only going to cover ScalaTest,
    and interested readers can look through the Specs2 documentation to understand
    their differences. Moreover, we will take a look at automated property-based testing
    using the **ScalaCheck** framework ([www.scalacheck.org](http://www.scalacheck.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests with ScalaTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to quickly start visualizing some of the tests that can be written
    with ScalaTest, we can take advantage of the `test-patterns-scala` template from
    the Typesafe Activator that we introduced in the previous chapter. It consists
    of a number of examples that essentially target the ScalaTest framework.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the `test-patterns-scala` activator project only requires you to
    go to the directory where you installed the Typesafe Activator, as we did earlier,
    and then, either start the GUI through the `> activator ui` command, or type `>
    activator new` to create a new project and select the appropriate template when
    prompted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template project already contains the `sbteclipse` plugin; therefore, you
    can generate eclipse-related files by simply entering from a command prompt in
    the root directory of the project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the eclipse project is successfully created, you may import it into your
    IDE workspace by selecting **File** | **Import...** | **General** |**Existing
    Projects**. As a reminder from the previous chapter, you can also create project
    files for IntelliJ or other IDEs since the Typesafe Activator is just a customized
    version of SBT.
  prefs: []
  type: TYPE_NORMAL
- en: You can look into the various test cases in `src/test/scala`. As some of the
    tests use frameworks such as Akka, Spray, or Slick, which we haven't covered yet,
    we will skip these for now to concentrate on the most straightforward ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, a `ScalaTest` class (which, by the way, might also test
    Java code and not just Scala code) can be declared by extending `org.scalatest.FunSuite`.
    Each test is represented as a function value, and this is implemented in the `Test01.scala`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute only this single test class, you should enter the following command
    in the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, this command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The example given under `src/test/scala/scalatest/Test02.scala` within the
    `test-patterns-scala` project is very similar, but the extra `===` instead of
    `==` will give you additional info when the test fails. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again running the test can be done by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before fixing the failing test, this time, we can execute the test in the continuous
    mode, using the `~` character in front of `test-only` (from the activator prompt),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The continuous mode will make SBT rerun the `test-only` command each time the
    `Test02` class is edited and saved. This feature of SBT can make you save a significant
    amount of time by running in the background tests or just programs without having
    to explicitly write the command. On the first execution of `Test02`, you can see
    some red text indicating `"abc[]" did not equal "abc[d]" (Test02.scala:10)`.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you correct the `abdc` string and save the file, SBT will automatically
    re-execute the test in the background, and you can see the text turning green.
  prefs: []
  type: TYPE_NORMAL
- en: The continuous mode works for the other SBT commands as well, such as `~run`
    or `~test`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Test03` shows you how to expect or catch exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first scenario fails as it was expecting an `IndexOutOfBoundsException`,
    but the code is indeed returning a valid `h`, the character at index 0 of the
    `hello` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run ScalaTest test suites as JUnit test suites (for example,
    to run them within the IDE or when extending an existing JUnit-based project that
    is already built in Maven, or when reporting to a build server), we can use the
    available `JUnitRunner` class along with the `@RunWith` annotation, as shown in
    the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: BDD-style testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Test06` is an example of a test written in a different style, namely BDD.
    In short, you specify some kind of a user story in almost plain English that describes
    the behavior of the scenario you want to test. This can be seen in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: BDD-style tests represent a higher level of abstraction than JUnit tests, and
    are more suitable for integration and acceptance testing as well as documentation,
    for people knowledgeable about the domain. You just need to extend the `FeatureSpec`
    class, optionally with a `GivenWhenThen` trait, to describe acceptance requirements.
    More details about BDD-style tests can be found at [http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development).
    We just want to illustrate here that it is possible to write the BDD-style tests
    in Scala, but we won't go further into their details as they are already largely
    documented for Java and other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'ScalaTest provides a convenient DSL to write assertions in a way close to plain
    English. The `org.scalatest.matchers.Matchers` trait contains many possible assertions
    and you should look at its ScalaDoc documentation to see many usage examples.
    `Test07.scala` expresses a very simple matcher, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although built with Version 2.0 of ScalaTest, the original sample given in the
    activator project uses the now deprecated `org.scalatest.matchers.ShouldMatchers`
    trait; the preceding code sample achieves the same behavior but is more up to
    date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a few more assertions using a Scala Worksheet. Right-click on
    the `scalatest` package that contains all the test files that were previously
    reviewed and then select **new** | **Scala Worksheet**. We will name this worksheet
    as `ShouldWork`. We can then write and evaluate matchers by extending a `FlatSpec`
    specification with the `Matchers` trait, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving this worksheet will not produce any output as the matcher passes the
    test. However, try to make it fail by changing one `true` to `false`. This is
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we get a full stack trace as part of the evaluation, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![BDD-style testing](img/3637OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can start evaluating many more `should` matchers, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The evaluation of the worksheet stops whenever we encounter a test failure.
    Therefore, we have to fix it in order to be able to progress in the test. This
    is identical to running the whole testsuite with the SBT `test` command, as we
    did previously, and as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the last statement (which is the opposite of the first
    one) should fail; instead, it is not evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ScalaTest is well integrated with Selenium (it is a tool for automating testing
    in browsers and is available at [www.seleniumhq.org](http://www.seleniumhq.org))
    by providing a complete DSL, making it straightforward to write functional tests.
    `Test08` is a clear example of this integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to run a similar invocation directly into a worksheet. As worksheets
    give feedback on every statement evaluation, they are very convenient to directly
    identify what the problem is, for instance, if a link, a button, or content is
    not found as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Just create another worksheet called **Functional** next to the **ShouldWork**
    worksheet that is already present. Right-click on the `scalatest` package and
    select **New** | **Scala Worksheet**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worksheet can be filled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Upon the save operation (*Ctrl* + *S*), the worksheet will be evaluated and
    should probably display some output information for every statement, except for
    the last two lines with `should` matchers, as they should evaluate to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to change `("Search | Packt Publishing")` to a different value, such as
    `Results` or just `Packt Publishing`, and notice how the console output provides
    handy information on what does not match. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional testing](img/3637OS_04_04_revised.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This functional test just scratches the surface of what's possible. As we are
    using the Java Selenium library, in Scala, you can inherit the power of the Selenium
    framework that is available in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking with ScalaMock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mocking is a technique by which you can test code without requiring all of its
    dependencies in place. Java offers several frameworks for mocking objects when
    writing tests. The most well known are JMock, EasyMock, and Mockito. As the Scala
    language introduces new elements such as traits and functions, the Java-based
    mocking frameworks are not enough, and this is where ScalaMock ([www.scalamock.org](http://www.scalamock.org))
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'ScalaMock is a native Scala-mocking framework that is typically used within
    ScalaTest (or Specs2), by importing the following dependencies into the SBT (`build.sbt`)
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Within Specs2, the following dependencies need to be imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since the release of the Scala Version 2.10, ScalaMock has been rewritten, and
    the ScalaMock Version 3.*x* is the version that we are going to cover briefly
    by going through an example of mocking a trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first define the code that we are going to test. It consists of a tiny
    currency converter (available at [http://www.luketebbs.com/?p=58](http://www.luketebbs.com/?p=58))
    that fetches currency rates from the European Central Bank. Retrieving and parsing
    the XML file of currency rates is only a matter of a few lines of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the currency rates are fetched from a URL using the `xml.XML.load`
    method. As XML is part of the Scala standard library, there is no need for imports
    here. The load method parses and returns the XML rates as an immutable structure
    of type `Elem`, which is a case class that represents XML elements. This is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the list of currency rates from this XML document is done through
    an XPath expression by navigating inside the Cube nodes, hence the `xml.XML.load(exchangeRates)
    \ "Cube" \ "Cube" \ "Cube"` expression. A single for comprehension (the `for (…)`
    `yield (…)` construct that we introduced in the previous chapter) is required
    to loop over the currency rates and return a collection of `key -> value` pairs
    where, in our case, a key will be a string that represents the currency name,
    and `value` will be a BigDecimal value that represents the rate. Notice how the
    information is extracted from `<Cube currency="USD" rate="1.3460"/>` by writing
    `(elem \ "@currency").text` to capture the currency attribute and `(elem \ "@rate").text`
    to capture the rate respectively. The latter will be further processed by creating
    a new `BigDecimal` value from the given string.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we get a `Map[String, BigDecimal]` that contains all our currencies
    with their rates. To this value, we add the mapping for the currency EUR (Euros)
    that will represent the reference rate one; this is why we use the `++` operator
    to merge two maps, that is, the one we just created together with a new map containing
    only one `key -> value` element, `Map[String,BigDecimal]("EUR"-> 1).`
  prefs: []
  type: TYPE_NORMAL
- en: 'Before mocking, let''s write a regular test using ScalaTest with `FlatSpec`
    and `Matchers`. We will make use of our `Converter` trait, by integrating it into
    the following `MoneyService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible test specification derived from the `MoneyService` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to instantiate the `Converter` trait, we use an `ECBConverter` class
    defined in the `Converter.scala` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the test from the SBT command prompt or directly within Eclipse
    (as a JUnit), we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the URL from which we are retrieving the currency rates is not always available,
    or if the currency rates have changed a lot on one particular day and the resulting
    amount of the conversion is not in the given interval of the assertion `should
    (be > (1700) and be <= (1800))`, then our test might fail. In that case, mocking
    the converter in our test seems appropriate, and can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `expects` method contains the arguments that we expect when our code should
    invoke the `convert` method, and the returning method contains our expected output
    in place of the real return result.
  prefs: []
  type: TYPE_NORMAL
- en: ScalaMock has many variations on how to apply the mocking code, and is planning
    to enhance the mocking syntax using the **Macros** in future releases. In short,
    Macros are functions that are called by the compiler during compilation. It is
    an experimental feature added in Scala from Version 2.10 that makes it possible
    for the developer to access the compiler APIs and apply transformations to the
    **AST** (**Abstract Syntax Tree**), that is, the tree representation of a program.
    Macros are out of the scope of this book, but among other things, they are useful
    for the Code Generation and DSLs. Their usage will improve the ScalaMock syntax;
    for instance, you can apply your mock expectations within `inSequence {… }` or
    the `inAnyOrder {… }` blocks of code or in nested combinations of these blocks,
    as illustrated in their documentation, which is available at [scalamock.org](http://scalamock.org).
    ScalaMock also supports a more Mockito-like style with a **Record-then-Verify**
    cycle rather than the **Expectations-First** style, which we have been using.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with ScalaCheck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a complete and consistent test suite that consists of unit, integration,
    or functional tests is essential in ensuring a good overall quality of your software
    development. However, sometimes, such a suite is not enough. While testing for
    example-specific data structures, it often happens that there are too many possible
    values to test with, which means that there is a very large amount of mocking
    or production of test data. Automated property-based testing is the aim of ScalaCheck,
    a Scala library inspired by Haskell that allows generating, more or less randomly,
    the test data to verify some properties about the code you are testing. This library
    can be applied to Scala as well as to Java projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get up and running quickly with ScalaCheck, you can include the appropriate
    library in the `build.sbt` file, as we have often done till now. This is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: From the SBT prompt, you may type `reload` instead of exiting and relaunching
    SBT, to get a fresh version of the build file, and then type `update` to fetch
    the new dependency. Once this is done, you may also type `eclipse` to update your
    project with the dependency so that it will be a part of your classpath, and the
    editor will recognize the ScalaCheck classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first run the `StringSpecification` test that is proposed by the **Quick
    start** page available at [www.scalacheck.org](http://www.scalacheck.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, ScalaCheck produces (randomly) a number of strings and
    verifies that the properties are correct; the first one is straightforward; it
    should verify that adding two strings `a` and `b` should produce a string that
    starts with `a`. It probably sounds obvious that this test will pass, no matter
    what the values of the strings are, but the second property that verifies the
    length of the concatenation of the two strings is not always true; feeding both
    `a` and `b` with the empty value `""` is a counter example that shows that the
    property is not verified. We can illustrate that by running the test via SBT as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'ScalaCheck conveniently outputs a counter example, `ARG_0: ""` and `ARG_1:
    ""` that makes the test fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a few more tests on more complex objects than just strings. Let''s
    add a new test class named `ConverterSpecification` as part of our test suite,
    to test the `Converter` that we have created in the *Mocking with ScalaMock* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the test in SBT, the following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this specification, we added two specific generators; the first one named
    `currencies` is able to generate only a few strings taken from a list of valid
    currencies that we want to test, as otherwise, a randomly generated string would
    produce strings that are not part of the `Map`. Let''s add an invalid item `"DUMMY"`
    to the generated list to verify that the test is failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'On saving this, the tests are rerun automatically as we specified the `~` sign
    in front of `test-only`. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The second generator named `conversions` illustrates the construction of a more
    complex generator that takes advantage of the power of for comprehensions. In
    particular, notice the `suchThat {_ >= 0}` filter method that makes sure that
    the arbitrary chosen integer has a positive value. This generator returns a `Tuple3`
    triplet that contains all the necessary values to test the `Converter.convert`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the major testing frameworks available in
    Scala, which largely inherit from the rich Java ecosystem. Moreover, by applying
    property-based testing via ScalaCheck, we explored novel approaches to enhance
    the testing quality. To further improve the quality of the software, interested
    readers can look at additional SBT plugins that are listed on the [http://www.scala-sbt.org/](http://www.scala-sbt.org/)
    website, notably `scalastyle-sbt-plugin` to check the coding style or the various
    code-coverage plugins. In the next chapter, we are going to dive into the huge
    area of web development and take advantage of the power of the Scala language
    to make the development of portals and web apps a productive and fun activity.
  prefs: []
  type: TYPE_NORMAL
