<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Contexts and Dependency Injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Contexts and Dependency Injection</h1></div></div></div><p>
<span class="strong"><strong>Contexts and Dependency Injection</strong></span> (<span class="strong"><strong>CDI</strong></span>) was<a id="id506" class="indexterm"/> added to the Java EE specification in Java EE 6. It provides several advantages that were previously unavailable to Java EE developers, such as allowing any JavaBean to be used as a <span class="strong"><strong>JavaServer Faces</strong></span> (<span class="strong"><strong>JSF</strong></span>) managed bean, including stateless and stateful session beans. As the name implies, CDI simplifies dependency injection in Java EE applications.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Named beans</li><li class="listitem" style="list-style-type: disc">Dependency injection</li><li class="listitem" style="list-style-type: disc">Scopes</li><li class="listitem" style="list-style-type: disc">Qualifiers</li></ul></div><div class="section" title="Named beans"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Named beans</h1></div></div></div><p>CDI provides us with the ability to name our beans via the <code class="literal">@Named</code> annotation. Named beans allow us to easily<a id="id507" class="indexterm"/> inject our <a id="id508" class="indexterm"/>beans into other classes that depend on them (see the <span class="emphasis"><em>Dependency injection</em></span> section), and to easily refer to them from JSF pages via the unified expression language.</p><p>The following example shows us the <code class="literal">@Named</code> annotation in action:</p><div class="informalexample"><pre class="programlisting">package net.ensode.cdidependencyinjection.beans;

import javax.enterprise.context.RequestScoped;
<span class="strong"><strong>import javax.inject.Named;</strong></span>

<span class="strong"><strong>@Named</strong></span>
@RequestScoped
public class Customer {

  private String firstName;
  private String lastName;

  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
}</pre></div><p>As we can see, all we need to do to name our class is to decorate it with the <code class="literal">@Named</code> annotation. By default, the name of the bean will be the class name with its first letter switched to lowercase; in our example, the name of the bean would be <code class="literal">customer</code>. If we wish to use a<a id="id509" class="indexterm"/> different name, <a id="id510" class="indexterm"/>we can do so by setting the <code class="literal">value</code> attribute of the <code class="literal">@Named</code> annotation. For example, if we wanted to use the name <code class="literal">customerBean</code> for our bean in the previous example, we could have done so by modifying the <code class="literal">@Named</code> annotation as follows:</p><div class="informalexample"><pre class="programlisting">@Named(value="customerBean")</pre></div><p>Or, we could have simply used the following code:</p><div class="informalexample"><pre class="programlisting">@Named("customerBean")</pre></div><p>Since the <code class="literal">value</code> attribute's name does not need to be specified, if we don't use an attribute name, then <code class="literal">value</code> is implied.</p><p>The CDI name can be used to access our bean from JSF pages using the unified expression language, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;Enter Customer Information&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:form&gt;
      &lt;h:panelGrid columns="2"&gt;
        &lt;h:outputLabel for="firstName" value="First Name"/&gt;
<span class="strong"><strong>        &lt;h:inputText id="firstName"</strong></span>
<span class="strong"><strong>                              value="#{customer.firstName}"/&gt;</strong></span>
        &lt;h:outputLabel for="lastName" value="Last Name"/&gt;
<span class="strong"><strong>        &lt;h:inputText id="lastName"</strong></span>
<span class="strong"><strong>                              value="#{customer.lastName}"/&gt;        </strong></span>
        &lt;h:panelGroup/&gt;       
      &lt;/h:panelGrid&gt;
    &lt;/h:form&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>As we can see, named beans are accessed from JSF pages exactly like standard JSF managed beans. This allows JSF<a id="id511" class="indexterm"/> to access any named bean, decoupling the Java code from the JSF API.</p><p>When deployed and <a id="id512" class="indexterm"/>executed, our simple application looks like the following screenshot (shown after the user has entered some data):</p><div class="mediaobject"><img src="graphics/6886EN_05_01.jpg" alt="Named beans"/></div></div></div>
<div class="section" title="Dependency injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Dependency injection</h1></div></div></div><p>Dependency injection is a technique that is used to supply external dependencies to a Java class. Java EE 5 introduced dependency injection via the <code class="literal">@Resource</code> annotation; however, this annotation is<a id="id513" class="indexterm"/> limited to injecting resources such as database connections, JMS resources, and so on. CDI includes the <code class="literal">@Inject</code> annotation, which can be used to inject instances of Java classes into any dependent objects.</p><p>JSF applications typically follow the <span class="strong"><strong>Model-View-Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) design pattern. As such, some JSF-managed beans frequently <a id="id514" class="indexterm"/>take on the role of controllers in the pattern, while others take on the role of the model. This approach typically requires the controller-managed bean to have access to one or more of the model-managed beans.</p><p>Because of the pattern described in the previous paragraph, one of the most frequently asked JSF questions is how to access one managed bean from another. There is more than one way to do this; however, before CDI, none of the ways were straightforward. Before CDI, the easiest way was to declare a managed property in the controller-managed bean, which required modifying the application's <code class="literal">faces-config.xml</code> file; another approach was to use code like the following one:</p><div class="informalexample"><pre class="programlisting">ELContext elc = FacesContext.getCurrentInstance().getELContext();
SomeBean someBean 
    = (SomeBean) FacesContext.getCurrentInstance().getApplication()
        .getELResolver().getValue(elc, null, "someBean");</pre></div><p>In this example, <code class="literal">someBean</code> is the name of the bean as specified in the application's <code class="literal">faces-config.xml</code>. As we can see, neither approach is simple or easy to remember. Fortunately, code like this is not needed anymore thanks to CDI's dependency injection capabilities, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.cdidependencyinjection.ejb;

import java.util.logging.Logger;
import javax.inject.Inject;
import javax.inject.Named;

@Named
@RequestScoped
public class CustomerController {

  private static final Logger logger = Logger.getLogger(
      CustomerController.class.getName());
<span class="strong"><strong>  @Inject</strong></span>
  private Customer customer;

  public String saveCustomer() {

    logger.info("Saving the following information \n" + customer.
        toString());

    //If this was a real application, we would have code to save
    //customer data to the database here.

    return "confirmation";
  }
}</pre></div><p>Notice that all we had to do to initialize our customer instance was to decorate it with the <code class="literal">@Inject</code> annotation. When the bean is constructed by the application server, an instance of the <code class="literal">Customer</code> bean<a id="id515" class="indexterm"/> is automatically injected into this field. Notice<a id="id516" class="indexterm"/> that the injected bean is used in the <code class="literal">saveCustomer()</code> method. As we can see, CDI makes accessing one bean from another a snap, a far cry from the code we had to use in previous versions of the Java EE specification.</p></div>
<div class="section" title="Working with CDI Qualifiers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Working with CDI Qualifiers</h1></div></div></div><p>In some instances, the type of the <a id="id517" class="indexterm"/>bean we wish to inject into our code may be an interface or a Java superclass, but we may be interested in injecting a subclass or a class implementing the interface. For cases like this, CDI provides qualifiers that we can use to indicate the specific type we wish to inject into our code.</p><p>A CDI qualifier is an annotation<a id="id518" class="indexterm"/> that must be decorated with the <code class="literal">@Qualifier</code> annotation. This annotation can then be used to decorate the specific subclass or interface implementation that we wish to qualify. Additionally, the injected field in the client code needs to be decorated with the qualifier as well.</p><p>Suppose our application could have <a id="id519" class="indexterm"/>a special kind of customer; for example, frequent customers could be given the status of premium customers. To handle these premium customers, we could extend our <code class="literal">Customer</code> named bean and decorate it with the following qualifier:</p><div class="informalexample"><pre class="programlisting">package net.ensode.cdidependencyinjection.qualifiers;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import javax.inject.Qualifier;

<span class="strong"><strong>@Qualifier</strong></span>
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface Premium {
}</pre></div><p>Like we mentioned previously, qualifiers are standard annotations; they typically have retention of runtime and can target methods, fields, parameters, or types, as illustrated in the previous example by the value of the <code class="literal">@Retention</code> annotation. The only difference between a qualifier and a standard<a id="id520" class="indexterm"/> annotation is that qualifiers are decorated with the <code class="literal">@Qualifier</code> annotation.</p><p>Once we have our qualifier in place, we need to use it to decorate the specific subclass or interface implementation:</p><div class="informalexample"><pre class="programlisting">package net.ensode.cdidependencyinjection.beans;

import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import net.ensode.cdidependencyinjection.qualifiers.Premium;

@Named
@RequestScoped
<span class="strong"><strong>@Premium</strong></span>
public class PremiumCustomer extends Customer {

  private Integer discountCode;

  public Integer getDiscountCode() {
    return discountCode;
  }

  public void setDiscountCode(Integer discountCode) {
    this.discountCode = discountCode;
  }
}</pre></div><p>Once we have decorated the specific instance that we need to qualify, we can use our qualifiers in the client code to specify the exact type of dependency we need:</p><div class="informalexample"><pre class="programlisting">package net.ensode.cdidependencyinjection.beans;

import java.util.Random;
import java.util.logging.Logger;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.inject.Named;
import net.ensode.cdidependencyinjection.qualifiers.Premium;

@Named
@RequestScoped
public class CustomerController {

  private static final Logger logger = Logger.getLogger(
      CustomerController.class.getName());
  @Inject 
<span class="strong"><strong>  @Premium</strong></span>
  private Customer customer;

  public String saveCustomer() {

    PremiumCustomer premiumCustomer = (PremiumCustomer) customer;

    premiumCustomer.setDiscountCode(generateDiscountCode());

    logger.info("Saving the following information \n"
        + premiumCustomer.getFirstName() + " "
        + premiumCustomer.getLastName()
        + ", discount code = "
        + premiumCustomer.getDiscountCode());

    //If this was a real application, we would have code to save
    //customer data to the database here.
    
    return "confirmation";
  }

  public Integer generateDiscountCode() {
    return new Random().nextInt(100000);
  }
}</pre></div><p>As we used our <code class="literal">@Premium</code> qualifier<a id="id521" class="indexterm"/> to decorate the customer field, an instance of <code class="literal">PremiumCustomer</code> is injected into that field, since this class is also decorated with the <code class="literal">@Premium qualifier</code>.</p><p>As far as our JSF pages go, we simply access our named bean as usual, using its name:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
    &lt;h:head&gt;
        &lt;title&gt;Enter Customer Information&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
        &lt;h:form&gt;
            &lt;h:panelGrid columns="2"&gt;
                &lt;h:outputLabel for="firstName" value="First Name"/&gt;
                &lt;h:inputText id="firstName"
                  value="#{premiumCustomer.firstName}"/&gt;
                &lt;h:outputLabel for="lastName" value="Last Name"/&gt;
                &lt;h:inputText id="lastName"          
                   value="#{premiumCustomer.lastName}"/&gt;
                &lt;h:outputLabel for="discountCode" value="Discount Code"/&gt;
                &lt;h:inputText id="discountCode"
                   value="#{premiumCustomer.discountCode}"/&gt;
                &lt;h:panelGroup/&gt;
                &lt;h:commandButton value="Submit"
                  action="#{customerController.saveCustomer}"/&gt;
            &lt;/h:panelGrid&gt;
        &lt;/h:form&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>In this example, we are using<a id="id522" class="indexterm"/> the default name for our bean, which is the class name with the first letter switched to lowercase.</p><p>Our simple application renders and acts just like a plain (that is, not using CDI) JSF application as far as the user is concerned. Take a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_05_02.jpg" alt="Working with CDI Qualifiers"/></div></div>
<div class="section" title="Named bean scopes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Named bean scopes</h1></div></div></div><p>Just like JSF-managed beans, CDI named beans are scoped. This means that CDI beans are contextual objects. <a id="id523" class="indexterm"/>When a named bean is needed, either because of injection or because it is referred from a JSF page, CDI looks for an instance of the bean in the scope it belongs to and injects it to<a id="id524" class="indexterm"/> the dependent code. If no instance is found, one is created and stored in the appropriate scope for future use. The different scopes are the context in which the bean exists.</p><p>The following table lists the different valid CDI scopes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Scope</p>
</th><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Request <a id="id525" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">@RequestScoped</code><a id="id526" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Request scoped beans are shared through the duration of a single request. A single request could refer to an HTTP request, an invocation to a method in an EJB, a web service invocation, or sending a JMS message to a message-driven bean.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Conversation<a id="id527" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">@ConversationScoped</code><a id="id528" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The conversation scope can span multiple requests, but it is typically shorter than the session scope.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Session<a id="id529" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">@SessionScoped</code><a id="id530" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Session scoped beans are shared across all requests in an HTTP session. Each user of an application gets its own instance of a session scoped bean.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Application<a id="id531" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">@ApplicationScoped</code><a id="id532" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Application scoped beans live through the whole application lifetime. Beans in this scope are shared across user sessions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Dependent<a id="id533" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">@Dependent</code><a id="id534" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Dependent scoped beans are not shared; any time a dependent scoped bean is injected, a new instance is created.</p>
</td></tr></tbody></table></div><p>As we can see, CDI includes all scopes supported by JSF; it also adds a couple of its own. CDI's request scope differs from JSF's request scope in which a request does not necessarily refer to an HTTP request; it could simply be an invocation on an EJB method, a web service invocation, or sending a JMS message to a message driven bean.</p><p>The conversation scope does not exist in JSF. This scope is longer than the request scope but shorter than the session scope, and it typically spans three or more pages. Classes wishing to access a conversation scoped bean <a id="id535" class="indexterm"/>must have an instance of <code class="literal">javax.enterprise.context.Conversation</code> injected. At the point where we want to start the conversation, the <code class="literal">begin()</code> method<a id="id536" class="indexterm"/> must be invoked on this object. At the point where we want to end the conversation, the <code class="literal">end()</code> method<a id="id537" class="indexterm"/> must be invoked on it.</p><p>CDI's session scope behaves just like its JSF counterpart. The lifecycle of session scoped beans is tied to the life of an HTTP session.</p><p>CDI's application scope also behaves just like the equivalent scope in JSF. Application scoped beans are tied to the life of an application. A single instance of each application scoped beans exists per application, which means that the same instance is accessible to all HTTP sessions.</p><p>Just like the conversation scope, CDI's dependent scope does not exist in JSF. A new dependent scoped bean is instantiated every time it is needed, usually, when it is injected into a class that depends on it.</p><p>Suppose we wanted to have a user enter some data that would be stored in a single named bean; however, this bean has several fields and therefore, we would like to split the data entry into several pages. This is a fairly common situation and one that was not easy to handle using previous versions of JSF (JSF 2.2 added Faces Flows to solve this problem; refer to <a class="link" href="ch02.html" title="Chapter 2. JavaServer Faces">Chapter 2</a>, <span class="emphasis"><em>JavaServer Faces</em></span>) or the servlet API, for that matter. The reason this situation is not trivial to manage using these technologies is that we can only put a class in the request scope, in which case, the class is destroyed after every single request, losing its data in the process; or in session scope, in which the class sticks around in the memory long after it is needed. </p><p>For cases like this, CDI's conversation scope is a good <a id="id538" class="indexterm"/>solution, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.conversationscope.model;

import java.io.Serializable;
import javax.enterprise.context.ConversationScoped;
import javax.inject.Named;
import org.apache.commons.lang.builder.ReflectionToStringBuilder;

@Named
<span class="strong"><strong>@ConversationScoped</strong></span>
public class Customer implements Serializable {

    private String firstName;
    private String middleName;
    private String lastName;
    private String addrLine1;
    private String addrLine2;
    private String addrCity;
    private String state;
    private String zip;
    private String phoneHome;
    private String phoneWork;
    private String phoneMobile;

    //getters and setters omitted for brevity

    @Override
    public String toString() {
        return ReflectionToStringBuilder.reflectionToString(this);
    }
} </pre></div><p>We declare that our bean is conversation scoped by decorating it with the <code class="literal">@ConversationScoped</code> annotation. <a id="id539" class="indexterm"/>Conversation scoped beans also need to implement <code class="literal">java.io.Serializable</code>. Other than these two requirements, there is nothing special about our code. It is a simple JavaBean code with private properties and corresponding getter and setter methods.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>We are using the Apache <code class="literal">commons-lang</code> library in our code to easily implement a <code class="literal">toString()</code> method<a id="id540" class="indexterm"/> for our bean. The <code class="literal">commons-lang</code> library has several utility methods like this that implement frequently needed, tedious to code functionality. commons-lang is available in the central Maven repositories at <a class="ulink" href="http://commons.apache.org/lang">http://commons.apache.org/lang</a>.</p></div></div><p>In addition to having our conversation scoped bean injected, our client code must also have an instance of <code class="literal">javax.enterprise.context.Conversation</code> injected, as illustrated in the<a id="id541" class="indexterm"/> following example:</p><div class="informalexample"><pre class="programlisting">package net.ensode.conversationscope.controller;

import java.io.Serializable;
import javax.enterprise.context.Conversation;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.inject.Named;
import net.ensode.conversationscope.model.Customer;

@Named
@RequestScoped
public class CustomerInfoController implements Serializable {

<span class="strong"><strong>    @Inject</strong></span>
<span class="strong"><strong>    private Conversation conversation;</strong></span>
<span class="strong"><strong>    @Inject</strong></span>
<span class="strong"><strong>    private Customer customer;</strong></span>

    public String customerInfoEntry() {
<span class="strong"><strong>        conversation.begin();</strong></span>
        System.out.println(customer);
        return "page1";
    }

    public String navigateToPage1() {
        System.out.println(customer);
        return "page1";
    }

    public String navigateToPage2() {
        System.out.println(customer);
        return "page2";
    }

    public String navigateToPage3() {
        System.out.println(customer);
        return "page3";
    }

    public String navigateToConfirmationPage() {
        System.out.println(customer);
<span class="strong"><strong>        conversation.end();</strong></span>
        return "confirmation";
    }
}</pre></div><p>Conversations can be either long running or transient. Transient conversations finish at the end of a request. Long running conversations span multiple requests. In most cases, we will use long running<a id="id542" class="indexterm"/> conversations to hold a reference to a conversation scoped bean across multiple HTTP requests in a web application. </p><p>A long running conversation starts when the <code class="literal">begin()</code> method<a id="id543" class="indexterm"/> is invoked in the injected conversation instance, and it ends when we invoke the <code class="literal">end()</code> method on this same object.</p><p>JSF pages simply access our CDI beans as usual:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
    &lt;h:head&gt;
        &lt;title&gt;Customer Information&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
        &lt;h3&gt;Enter Customer Information (Page 1 of 3)&lt;/h3&gt;
        &lt;h:form&gt;
            &lt;h:panelGrid columns="2"&gt;
                &lt;h:outputLabel for="firstName" value="First Name"/&gt;
                &lt;h:inputText id="firstName"
                                      value="#{customer.firstName}"/&gt;
                &lt;h:outputLabel for="middleName" value="Middle Name"/&gt;
                &lt;h:inputText id="middleName"
                                      value="#{customer.middleName}"/&gt;
                &lt;h:outputLabel for="lastName" value="Last Name"/&gt;
                &lt;h:inputText id="lastName" value="#{customer.lastName}"/&gt;
                &lt;h:panelGroup/&gt;
                &lt;h:commandButton value="Next" 
                  action="#{customerInfoController.navigateToPage2}"/&gt;
            &lt;/h:panelGrid&gt;
        &lt;/h:form&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>As we navigate from one page to the next, we keep the same instance of our conversation scoped bean. Therefore, all user-entered data remains. When the <code class="literal">end()</code> method is called on our conversation bean, the conversation ends and our conversation scoped bean is destroyed.</p><p>Keeping our bean in the<a id="id544" class="indexterm"/> conversation scope simplifies the task of implementing wizard-style user interfaces, where data can be entered across several pages, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_05_03.jpg" alt="Named bean scopes"/></div><p>In our example, after clicking on the <span class="strong"><strong>Next</strong></span> button on the first page, we can see our partially populated bean in the GlassFish log:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>INFO:  HYPERLINK "mailto:net.ensode.conversationscope.model.Customer@6e1c51b4"net.ensode.conversationscope.model.Customer@6e1c51b4[firstName=Daniel,middleName=,lastName=Jones,addrLine1=,addrLine2=,addrCity=,state=AL,zip=&lt;null&gt;,phoneHome=&lt;null&gt;,phoneWork=&lt;null&gt;,phoneMobile=&lt;null&gt;]</strong></span>
</pre></div><p>At this point, the second <a id="id545" class="indexterm"/>page in our simple wizard is displayed as follows:</p><div class="mediaobject"><img src="graphics/6886EN_05_04.jpg" alt="Named bean scopes"/></div><p>By clicking on <span class="strong"><strong>Next</strong></span>, we can see that additional fields are populated in our conversation scoped bean.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>INFO: net.ensode.conversationscope.model.Customer@6e1c51b4[firstName=Daniel,middleName=,lastName=Jones,addrLine1=123 Basketball Ct,addrLine2=,addrCity=Montgomery,state=AL,zip=36101,phoneHome=&lt;null&gt;,phoneWork=&lt;null&gt;,phoneMobile=&lt;null&gt;]</strong></span>
</pre></div><p>When we submit the third page in our wizard, additional bean properties corresponding to the fields on that page are populated, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_05_05.jpg" alt="Named bean scopes"/></div><p>When we are at the point where<a id="id546" class="indexterm"/> we don't need to keep the customer information in mind anymore, we need to call the <code class="literal">end()</code> method on the conversation bean that was injected into our code. This is exactly what we do in our code before displaying the confirmation page:</p><div class="informalexample"><pre class="programlisting">public String navigateToConfirmationPage() {
        System.out.println(customer);
<span class="strong"><strong>        conversation.end();</strong></span>
        return "confirmation";
    }</pre></div><p>After the request to show the confirmation page is completed, our conversation scoped bean is destroyed, as we invoked the <code class="literal">end()</code> method in our injected <code class="literal">Conversation</code> class.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we provided an introduction to Contexts and Dependency Injection. We covered how JSF pages can access CDI named beans as if they were JSF managed beans. We also covered how CDI makes it easy to inject dependencies into our code via the <code class="literal">@Inject</code> annotation. Additionally, we explained how we can use qualifiers to determine the specific implementation of a dependency to be injected into our code. Finally, we covered all the scopes that a CDI bean can be placed into, which include the equivalents to all the JSF scopes, plus an additional two scopes not included in JSF, namely, the conversation scope and the dependent scope.</p><p>In the next chapter, we will cover processing JavaScript Object Notation (JSON) formatted data using the new JSON-P API.</p></div></body></html>