- en: Implementing Server-Side Components with Internationalization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a login form is arguably one of the most common requirements in web applications.
    In this chapter, you will learn how to implement a reusable and extensible login
    form that supports multiple languages, and see the advantages of favoring *composition*
    over *extension* when implementing UI components. Through examples, we'll discuss
    why *extension* is not always the best approach, and we'll explore several alternatives
    for implementing custom server-side UI components with Vaadin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Extending layout components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Composite` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalization of Java Strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/fu8W3W](https://goo.gl/fu8W3W)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Using extensions to develop a UI component
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore how to implement a login form component. The first idea that comes
    to mind when starting to develop a UI component is to extend, in the Java sense,
    an existing component. Most of the time, the natural choice is to extend a layout
    component such as `VerticalLayout` or `HorizontalLayout`. For example, a login
    form usually includes at least a username field, a password field, a login button,
    and a remember me checkbox, with all of them aligned vertically. So, let's start
    by directly extending `VerticalLayout`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Extending VerticalLayout
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following snippet of code shows a typical way of extending `VerticalLayout`
    to implement a UI component, in this case, the login form:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The logic to handle events and additional UI configuration that might be required
    is omitted in the previous example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The full implementation of the `LoginFormLayout` class is located in the `Data-centric-Applications-with-Vaadin-8/chapter-03`
    Maven project of the source code that accompanies this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Why avoid extension?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is wrong with the previous implementation? Well, there's nothing inherently
    wrong with it. However, it can be highly improved. The `LoginFormLayout` class
    violates encapsulation! Clients of the class know that a `VerticalLayout` is used.
    All public methods of `VerticalLayout` are exposed to clients of `LoginFormLayout`.
    If, for some reason, the implementation needs to change to a different layout
    (a `FormLayout`, `CssLayout`, or even a `Panel`, for instance), clients calling
    any method in `VerticalLayout` that are not in the new base layout class would
    break.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To the outside world, `LoginFormLayout` is a `Layout`. The purpose of a login
    form is not to serve as a layout (to position other components), but to show the
    fields that are required to authenticate users with the application. So, let's
    try to get more encapsulation into the design!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Using composition to develop custom components
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If extending `VerticalLayout` is a problem, a possible solution is to not extend
    any class at all. However, in that case, we wouldn''t get a `Component`, but a
    class of which instances cannot be added to the components tree. What about extending
    a more suitable component in the hierarchy? Let''s start with interfaces. The
    following figure shows some of the top interfaces in the hierarchy:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fadb91a-9c91-4591-b36a-3ad65a8595e9.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Going up the hierarchy, we find the `Component` interface which has more than
    20 methods that would require an implementation. The other interfaces inherit
    these 20+ methods and add some more. Fortunately, Vaadin provides abstract implementations
    for these interfaces. The following figure shows some of the equivalent implementations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50d0b746-91f7-4bba-9f98-57031e8165df.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: '`AbstractComponent` is the default implementation of `Component`. Many Vaadin
    components directly extend this class. It''s not a convenient class for the login
    form, though, since it''s too general and doesn''t offer methods to add other
    components to it. `AbstractField` and `AbstractListing` can be discarded as well
    because the login form is not just a field showing a value or a list of values,
    respectively.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The next candidates are the `AbstractSingleComponentContainer`, `AbstractComponentContainer`,
    and `AbstractLayout` classes. These classes help with the implementation of layouts,
    but as we discussed previously, a login form shouldn't look like a layout to the
    external world.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a factory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How about a factory of components? The following is an implementation of a
    factory with a method that returns a `Component`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This hides the implementation details but also makes it more difficult and complex
    to offer functionality to the clients. For example, how would clients of the class
    get the username or password values introduced by the user in the form? One option
    is to implement getters in the factory class, but that would require some more
    adjustments in the `LoginFormFactory` class. At the end of the day, this kind
    of implementation would require you to implement (and maintain) two highly coupled
    classes for a single custom component. Not a very good idea.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Using the Composite class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have some experience with Vaadin, chances are that you already know
    the `CustomComponent` class. The `Composite` class works in the same way as the
    `CustomComponent` class, but it''s more lightweight since it only adds a simple
    `<div>` element to the DOM in the browser. The `Composite` class eases the development
    of compositions of components by eliminating some of the problems previously described.
    `Composite` directly extends `AbstractComponent`, which means that any class extending
    `Composite` is a `Component` itself that can be added to any Vaadin layout. A
    `Composite` can specify a composition root that serves as the root of the components
    tree (usually a layout), for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the LoginForm class
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vaadin comes with a `LoginForm` class that, by default, renders a username
    and a password field. It also adds *auto-completion* and *auto-fill* in the browser.
    The `LoginForm` class is a good candidate for extension (and you have to extend
    it if you want to override its defaults). For example, the following snippet of
    code creates a `loginForm` and a listener that is invoked when the user clicks
    the login button:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To add more fields to the form, override the `createContent` method. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Despite its design for extension, it''s always a good idea to hide implementation
    details by extending `Composite` and abstracting away the underlying `LoginForm`
    class. The following snippet of code shows a first iteration of the new `LoginFormComponent`
    class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `createContent` method is called internally by the `LoginForm` class. Notice
    how the `username` and `password` variables are assigned to references in the
    `LoginFormComponent` class. These references can be used later to retrieve the
    values in the fields.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowing clients of the `LoginFormComponent` class to be notified when the
    user clicks the login button can be implemented with a custom `LoginListener`
    interface:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `LoginListener` interface defines one method that accepts a `LoginFormComponent`.
    Now, it''s easy to define getters to allow clients to obtain the values in the
    fields:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If a new component is added to the login form in future, it's possible to add
    a getter to return the value in the added field without breaking existing clients
    of the class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The final version of the `LoginFormComponent` class can be found in the `Data-centric-Applications-with-Vaadin-8\chapter-03`
    Maven project of the source code that accompanies this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Using internationalization for Multiple Language Support
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internationalization** is the process of making an application ready to support
    several languages and data formats. An internationalized application can be adapted
    for a particular language and region, a process known as *localization*, which
    consists of adding a specific set of resources (usually text, images, and data
    formats) to an internationalized application. Ideally, localization should not
    require rebuilding the application, but only adding the localized resources and,
    at most, restarting the web container.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Addressing internationalization early in a software development project and
    knowing the audience makes the process much easier. Internationalization is orthogonal
    to all the application layers, and the process of localizing can involve translating
    and defining several resources such as texts, images, videos, audio files, number
    formats, date formats, currency symbols, and even colors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Removing hardcoded strings
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Custom reusable UI components should not depend on the mechanism used to handle
    internationalization. The `LoginFormComponent`, for instance, should include setters
    (or alternatively, parameters in the constructor) to configure the captions of
    the inner UI components. The following implementation shows how to use setters
    to configure captions in the login form:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's a good idea to provide defaults and a method to set all the captions in
    one call. The implementation in the example application includes such features.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Getting localized strings
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, the `LoginFormComponent` can be internationalized. The next step
    is to pass the strings containing the captions in the correct language. Usually,
    the `Locale` and `ResourceBundle` standard Java classes are good enough to externalize
    localized messages. However, it is also a good idea to isolate string externalization
    logic into a separate class that allows clients to add resource bundles and get
    localized strings by name. Encapsulating this logic into a separate class allows
    you to change the underlying mechanism (for example, to read the messages from
    a database) and add features such as caching without affecting the rest of the
    application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of the `Messages` utility class used to
    encapsulate string externalization logic:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This class can be used to register a *base name* used internally by the standard
    `ResourceBundle` class. This base name should match the name of the properties
    files with the translations. For example, to add English and Spanish messages,
    you have to create two files, `messages_en.properties` and `messages_es.properties`.
    The `messages` part in the name of these files corresponds to the *base name*.
    You can load these resource bundles by calling `Messages.addBundle("messages")`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The `Messages` class is located in the `Data-centric-Applications-with-Vaadin-8\chapter-03`
    Maven project of the source code that accompanies this book. The class includes
    a method to get all the available languages that you can use to allow end users
    to change the language from the UI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Supporting a new language is as easy (or complicated) as adding a new `.properties`
    file (in the `resources` directory) containing the translated properties. For
    example, a `messages_en.properties` file could define the following properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To support Spanish, for example, you would have to add a `messages_es.properties`
    file with the following content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that you have to use *unicode scape* *syntax* if you want to include special
    characters (like the Spanish *n* with a *tilde* in the example).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a message in the language of the browser by calling `Messages.get("property")`.
    For example, the following snippet of code sets the correct labels for the components
    in the `LoginFormComponent`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting and setting the locale
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vaadin automatically sets the `Locale` reported by the browser. You can get
    this `Locale` by calling the `UI::getLocale()` method and the `UI::setLocale(Locale)`
    method to set the `Locale` for the current user. The example application in this
    chapter uses the locale reported by the browser. There''s no need do anything
    else except add the resource bundle using the helper `Messages` class. The example
    application does this in a static block in the `UI` implementation (the `VaadinUI`
    class):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In more complex scenarios, you should use an event listener such as `ServletContextListener`
    to add the resource bundle when the context starts, for example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: You can configure your browser in a different language to test this functionality.
    How to configure this may depend on your browser and operating system vendor.
    In Chrome, however, you can use the Language settings. Just move the language
    that you wish to test to the top of the list. You have to restart Chrome for this
    change to take effect.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the `LoginFormComponent` using the Spanish
    locale:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f35b3de-cc5e-43d0-af68-5d8a7fe59631.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Internationalization requires a constant effort throughout the development of
    UIs. Try to catch yourself *hard-coding* strings and immediately fix them by creating
    an entry in the appropriate properties file. Incorporate this practice into your
    coding routine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: When implementing truly internationalized applications, you should have a well-defined
    and simple process that allows translators to create all the localizations (translations)
    for new resources. A way of doing this is by using well-defined directories or
    files that translators can take and complete (by translating the strings, for
    example) before a new production-ready artifact is constructed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to design UI components with the help of object-oriented
    techniques by considering several approaches such as extending layout components,
    extending a specialized component, and using composition with the help of the
    `Composite` class. We developed a `LoginForm` class that uses the browser's language
    to show captions in the appropriate language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过考虑几种方法，如扩展布局组件、扩展专用组件以及使用`Composite`类进行组合，学习了如何在面向对象技术的帮助下设计UI组件。我们开发了一个`LoginForm`类，该类使用浏览器的语言来显示适当的语言字幕。
- en: In the next chapter, you will learn how to make the login form functional by
    adding authentication and authorization capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过添加身份验证和授权功能来使登录表单变得可用。
