["```java\n(def tdata [23 19 21 24 26 20 22 21 25 168 23 20 29 172 22 24 26])\n\n(defn var-std-dev\n  \"Return variance and standard deviation in a vector\"\n  [data]\n  (let [size (count data)\n        mean (/ (reduce + data) size)\n        sum (->> data\n                 (map #(let [v (- % mean)] (* v v)))                 (reduce +))\n        variance (double (/ sum (dec size)))]\n    [variance (Math/sqrt variance)]))\n\nuser=> (println (var-std-dev tdata))\n[2390.345588235294 48.89116063497873]\n```", "```java\nuser=> (require '[criterium.core :refer [bench]])\nnil\nuser=> (bench (reduce + (range 1000)))\nEvaluation count : 162600 in 60 samples of 2710 calls.\n             Execution time mean : 376.756518 us\n    Execution time std-deviation : 3.083305 us\n   Execution time lower quantile : 373.021354 us ( 2.5%)\n   Execution time upper quantile : 381.687904 us (97.5%)\n\nFound 3 outliers in 60 samples (5.0000 %)\nlow-severe 2 (3.3333 %)\nlow-mild 1 (1.6667 %)\n Variance from outliers : 1.6389 % Variance is slightly inflated by outliers\n```", "```java\n(ns foo.bench\n  (:require [perforate.core :as p]))\n\n(p/defgoal str-concat \"String concat\")\n(p/defcase str-concat :apply\n  [] (apply str [\"foo\" \"bar\" \"baz\"]))\n(p/defcase str-concat :reduce\n  [] (reduce str [\"foo\" \"bar\" \"baz\"]))\n\n(p/defgoal sum-numbers \"Sum numbers\")\n(p/defcase sum-numbers :apply\n  [] (apply + [1 2 3 4 5 6 7 8 9 0]))\n(p/defcase sum-numbers :reduce\n  [] (reduce + [1 2 3 4 5 6 7 8 9 0]))\n```", "```java\n(ns foo.bench\n  (:require [citius.core :as c]))\n\n(c/with-bench-context [\"Apply\" \"Reduce\"]\n  {:chart-title \"Apply vs Reduce\"\n   :chart-filename \"bench-simple.png\"}\n  (c/compare-perf\n    \"concat strs\"\n    (apply str [\"foo\" \"bar\" \"baz\"])\n    (reduce str [\"foo\" \"bar\" \"baz\"]))\n  (c/compare-perf\n    \"sum numbers\"\n    (apply + [1 2 3 4 5 6 7 8 9 0])\n    (reduce + [1 2 3 4 5 6 7 8 9 0])))\n```", "```java\n(ns foo.bench\n  (:require\n    [clojure.test :refer [deftest]]\n    [citius.core :as c])\n  (:import [java.util.concurrent.atomic AtomicLong]))\n\n(def a (atom 0))\n(def ^AtomicLong b (AtomicLong. 0))\n\n(deftest test-counter\n  (c/with-bench-context [\"Atom\" \"AtomicLong\"] {}\n    (c/compare-perf \"counter\"\n      (swap! a unchecked-inc) (.incrementAndGet b))))\n\n;; Under Unix-like systems run the following command in terminal:\n;; CITIUS_CONCURRENCY=4,4 lein test\n```", "```java\n(import '[java.util.concurrent ExecutorService Executors Future])\n(defn concurrently\n  ([n f]\n    (concurrently n f #(mapv deref %)))\n  ([n f g]\n    (let [^ExecutorService\n          thread-pool (Executors/newFixedThreadPool n)\n          future-vals (transient [])]\n      (dotimes [i n]\n        (let [^Callable task (if (coll? f) (nth f i) f)\n              ^Future each-future (.submit thread-pool task)]\n          (conj! future-vals each-future)))\n      (try\n        (g (persistent! future-vals))\n        (finally\n          (.shutdown thread-pool))))))\n\n(defn call-count\n  []\n  (let [stats (atom 0)]\n    (fn\n      ([] (deref stats))\n      ([k] (if (identical? :reset k)\n             (reset! stats 0)\n             (swap! stats unchecked-inc))))))\n\n(defn wrap-call-stats\n  [stats f]\n  (fn [& args]\n    (try\n      (let [result (apply f args)]\n        (stats :count)\n        result))))\n\n(defn wait-until-millis\n  ([^long timeout-millis]\n    (wait-until-millis timeout-millis 100))\n  ([^long timeout-millis ^long progress-millis]\n    (while (< (System/currentTimeMillis) timeout-millis)\n      (let [millis (min progress-millis\n                     (- timeout-millis (System/currentTimeMillis)))]\n        (when (pos? millis)\n          (try\n            (Thread/sleep millis)\n            (catch InterruptedException e\n              (.interrupt ^Thread (Thread/currentThread))))\n          (print \\.)\n          (flush))))))\n```", "```java\n(defn benchmark-throughput*\n  [^long concurrency ^long warmup-millis ^long bench-millis f]\n  (let [now        #(System/currentTimeMillis)\n        exit?      (atom false)\n        stats-coll (repeatedly concurrency call-count)\n        g-coll     (->> (repeat f)\n                     (map wrap-call-stats stats-coll)\n                     (map-indexed (fn [i g]\n                                    (fn []\n                                      (let [r (nth stats-coll i)]\n                                        (while (not (deref exit?))\n                                          (g))\n                                        (r)))))\n                     vec)\n        call-count (->> (fn [future-vals]\n                          (print \"\\nWarming up\")\n                          (wait-until-millis (+ (now) warmup-millis))\n                          (mapv #(% :reset) stats-coll) ; reset count\n                          (print \"\\nBenchmarking\")\n                          (wait-until-millis (+ (now) bench-millis))\n                          (println)\n                          (swap! exit? not)\n                          (mapv deref future-vals))\n                     (concurrently concurrency g-coll)\n                     (apply +))]\n    {:concurrency concurrency\n     :calls-count call-count\n     :duration-millis bench-millis\n     :calls-per-second (->> (/ bench-millis 1000)\n                         double\n                         (/ ^long call-count)\n                         long)}))\n\n(defmacro benchmark-throughput\n  \"Benchmark a body of code for average throughput.\"\n  [concurrency warmup-millis bench-millis & body]\n  `(benchmark-throughput*\n    ~concurrency ~warmup-millis ~bench-millis (fn [] ~@body)))\n```", "```java\n(def a (atom 0))\n(println\n  (benchmark-throughput\n    4 20000 40000 (swap! a inc)))\n```", "```java\n(let [^Runtime r (Runtime/getRuntime)]\n  (println \"Maximum memory\" (.maxMemory r))\n  (println \"Total memory\" (.totalMemory r))\n  (println \"Free memory\" (.freeMemory r)))\nOutput:\nMaximum memory 704643072\nTotal memory 291373056\nFree memory 160529752\n```", "```java\n(defn cpu-work []\n  (reduce + (range 100000000)))\n\n(defn mem-work []\n  (->> (range 1000000)\n       (map str)\n       vec\n       (map keyword)\n       count))\n```"]