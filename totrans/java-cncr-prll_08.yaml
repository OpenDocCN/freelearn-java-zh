- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Microservices in the Cloud and Java’s Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云中的微服务和Java的并发
- en: In today’s fast-evolving digital landscape, microservices have emerged as a
    game-changing architectural style, enabling organizations to enhance scalability,
    flexibility, and deployment speeds. Java, with its robust ecosystem and powerful
    concurrency tools, stands at the forefront of this transformation, facilitating
    the seamless integration of microservices into cloud environments. This chapter
    delves into how Java’s advanced features empower developers to build, deploy,
    and scale microservices more efficiently, making it an ideal choice for modern
    cloud-based applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天快速发展的数字景观中，微服务已成为一种颠覆性的架构风格，使组织能够提高可伸缩性、灵活性和部署速度。Java凭借其强大的生态系统和强大的并发工具，站在这一变革的前沿，促进微服务与云环境的无缝集成。本章深入探讨了Java的先进功能如何使开发者能够更高效地构建、部署和扩展微服务，使其成为现代云应用的理想选择。
- en: By embracing Java-powered microservices, businesses can break down complex applications
    into manageable, independently deployable components that are tailored to specific
    business functions. This modularity not only accelerates development cycles but
    also improves system resilience and maintenance. Furthermore, Java’s concurrency
    utilities play a crucial role in optimizing these services to handle vast scales
    of operations with ease, ensuring high availability and responsiveness across
    distributed systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用Java驱动的微服务，企业可以将复杂的应用程序分解为可管理的、独立部署的组件，这些组件针对特定的业务功能进行了定制。这种模块化不仅加速了开发周期，还提高了系统的弹性和维护性。此外，Java的并发实用工具在优化这些服务以轻松处理大量操作方面发挥着关键作用，确保分布式系统的高可用性和响应性。
- en: 'In this chapter, we will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: '**Principles of microservices in the cloud**: Understand the architectural
    shifts that make microservices a preferred model in modern software development,
    focusing on their dynamic integration with cloud platforms'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云中微服务的原则**：了解使微服务成为现代软件开发首选模式的架构转变，重点关注它们与云平台的动态集成'
- en: '**Java’s concurrency essentials**: Dive into Java’s concurrency **Application
    Programming Interface** (**API**) to discover how these tools can dramatically
    improve the performance and scalability of your microservices'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java的并发基础**：深入了解Java的并发**应用程序编程接口**（API），以发现这些工具如何显著提高微服务的性能和可伸缩性'
- en: '**Concurrency patterns and techniques**: Learn about advanced patterns such
    as circuit breakers and event-driven communication, which are essential for maintaining
    high service availability and robust error handling'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发模式和技巧**：了解如断路器和事件驱动通信等高级模式，这些模式对于保持高服务可用性和健壮的错误处理至关重要'
- en: '**Best practices for microservices**: Explore strategic guidelines for deploying
    and scaling your microservices, ensuring they are optimized for the cloud environment'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务的最佳实践**：探索部署和扩展微服务的战略指南，确保它们在云环境中得到优化'
- en: '**Hands-on design and implementation**: Apply what you’ve learned through practical
    case studies and real-world applications that demonstrate effective microservice
    design using Java'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动手设计和实现**：通过实际案例研究和现实世界的应用来应用你所学到的知识，这些案例研究展示了使用Java进行有效微服务设计的实例'
- en: By the end of this chapter, you’ll be well-equipped to leverage Java’s advanced
    features for designing, deploying, and managing microservices that are not only
    scalable and efficient but also resilient and easy to maintain. Prepare to transform
    theoretical knowledge into practical skills that will advance your capabilities
    in developing cloud-native applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将准备好利用Java的先进功能来设计、部署和管理既可伸缩又高效、弹性好且易于维护的微服务。准备将理论知识转化为实际技能，这将提高你在开发云原生应用方面的能力。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: '**frameworkframework**For detailed setup instructions on microservices frameworks,
    refer to their official documentation. This chapter will focus on using Spring
    Boot for the microservice example.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架框架**：有关微服务框架的详细设置说明，请参阅它们的官方文档。本章将专注于使用Spring Boot作为微服务示例。'
- en: 'Here are the official documentation sites:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是官方文档网站：
- en: '**Spring** **Boot**: [https://spring.io/guides/gs/spring-boot](https://spring.io/guides/gs/spring-boot)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot**：[https://spring.io/guides/gs/spring-boot](https://spring.io/guides/gs/spring-boot)'
- en: '**Micronaut**: [https://guides.micronaut.io/latest/creating-your-first-micronaut-app-maven-java.html](https://guides.micronaut.io/latest/creating-your-first-micronaut-app-maven-java.html)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Micronaut**：[https://guides.micronaut.io/latest/creating-your-first-micronaut-app-maven-java.html](https://guides.micronaut.io/latest/creating-your-first-micronaut-app-maven-java.html)'
- en: '**Quarkus**: [https://quarkus.io/get-started/](https://quarkus.io/get-started/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quarkus**：[https://quarkus.io/get-started/](https://quarkus.io/get-started/)'
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Core principles of microservices – architectural benefits in cloud platforms
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务核心原则——在云平台上的架构优势
- en: '**Microservices architecture** offers a modern approach to software development,
    particularly in cloud environments. This architecture divides complex systems
    into smaller, independent services, providing flexibility and scalability. In
    this section, we will explore the foundational concepts of microservices architecture,
    its advantages over traditional designs, and how it integrates seamlessly into
    cloud ecosystems.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**为软件开发提供了一种现代方法，尤其是在云环境中。这种架构将复杂系统划分为更小、独立的子服务，提供了灵活性和可扩展性。在本节中，我们将探讨微服务架构的基础概念、其相对于传统设计的优势，以及它如何无缝集成到云生态系统中。'
- en: Foundational concepts – microservices architecture and its benefits in the cloud
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础概念——微服务架构及其在云中的优势
- en: 'Microservices architecture is a modern approach to software development that
    focuses on dividing complex systems into small, loosely coupled services. This
    architecture has proven especially beneficial in cloud environments, where its
    modularity and flexibility offer numerous advantages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是软件开发的现代方法，它侧重于将复杂系统划分为小型、松耦合的服务。这种架构在云环境中特别有益，其模块化和灵活性提供了许多优势：
- en: '**Modularity**: Microservices architecture divides a system into independent,
    loosely coupled services, each with its own functionality. This modularity allows
    for granular control over each component, making it easier to develop, test, deploy,
    and maintain individual services. It also enables teams to work on different services
    simultaneously, promoting parallel development.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：微服务架构将系统划分为独立的、松耦合的服务，每个服务都有自己的功能。这种模块化允许对每个组件进行细粒度控制，使得开发、测试、部署和维护单个服务变得更加容易。它还允许团队同时处理不同的服务，促进并行开发。'
- en: '**Communication**: Microservices communicate via lightweight, standardized
    protocols such as HTTP/REST or gRPC, allowing for efficient interaction between
    services. These communication patterns, both synchronous and asynchronous, enable
    the development of scalable systems that can handle increasing workloads. Services
    expose well-defined APIs, which act as contracts for communication and facilitate
    loose coupling.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信**：微服务通过轻量级、标准化的协议如HTTP/REST或gRPC进行通信，允许服务之间高效交互。这些同步和异步的通信模式，使得可以开发出能够处理不断增长工作负载的可扩展系统。服务暴露了定义良好的API，这些API作为通信的契约，并促进了松耦合。'
- en: '**Independent deployment**: Microservices can be deployed, scaled, and updated
    independently without affecting the functionality of other services. This flexibility
    reduces downtime, enhances scalability, and simplifies the integration of new
    features. It also allows for the use of different technologies within each microservice.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立部署**：微服务可以独立部署、扩展和更新，而不会影响其他服务的功能。这种灵活性减少了停机时间，增强了可扩展性，并简化了新特性的集成。它还允许在每个微服务中使用不同的技术。'
- en: '**Resilience and fault isolation**: Microservices architecture promotes resilience
    by isolating failures within individual services. If one service fails, it doesn’t
    necessarily bring down the entire system. This fault isolation is achieved through
    design patterns such as circuit breakers and bulkheads.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性和故障隔离**：微服务架构通过隔离单个服务内的故障来提高弹性。如果一个服务失败，并不一定会导致整个系统崩溃。这种故障隔离是通过设计模式如断路器和防波堤来实现的。'
- en: '**Scalability**: Microservices can be scaled individually based on their specific
    resource requirements and demand patterns. This granular scalability allows for
    optimized resource allocation and cost-efficiency.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：微服务可以根据其特定的资源需求和需求模式进行单独扩展。这种细粒度的可扩展性允许优化资源分配和成本效益。'
- en: By leveraging the benefits of modularity, communication, independent deployment,
    resilience, and scalability, microservices architecture enables the development
    of flexible, maintainable, and scalable systems in cloud environments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用模块化、通信、独立部署、弹性和可扩展性的优势，微服务架构使得在云环境中开发灵活、可维护和可扩展的系统成为可能。
- en: 'Let’s look at the following image:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图像：
- en: '![Figure 8.1: A microservices architecture](img/B20937_08_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：微服务架构](img/B20937_08_01.jpg)'
- en: 'Figure 8.1: A microservices architecture'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：微服务架构
- en: '*Figure 8**.1* showcases a microservices architecture deployed in a cloud environment,
    highlighting the interplay between various services that cater to end user functionalities.
    It includes these key components:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1*展示了在云环境中部署的微服务架构，突出了各种服务之间的相互作用，这些服务为最终用户提供功能。它包括以下关键组件：'
- en: '**User service**: Enables users to place orders'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户服务**：使用户能够下订单'
- en: '**Order service**: Processes orders by interacting with the product service
    for product details and the inventory service for stock checks; if items are available,
    it proceeds to initiate payment via the payment service'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单服务**：通过与产品服务交互获取产品详情，并与库存服务交互进行库存检查来处理订单；如果项目可用，它将启动通过支付服务进行支付的流程'
- en: '**Payment service**: Handles payment processing'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付服务**：处理支付流程'
- en: '**Notification service**: Alerts users about their order status once the payment
    is confirmed, facilitated by notifications sent from the order service'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知服务**：一旦支付确认，通过订单服务发送的通知来提醒用户订单状态'
- en: '**Inventory service**: Updates stock levels post-order to ensure accurate inventory
    management'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库存服务**：在订单后更新库存水平，以确保准确的库存管理'
- en: The architecture is built to be modular and scalable, with each service dedicated
    to a specific task and communicating through defined interfaces. This setup allows
    for flexibility in development and deployment, while the cloud environment supports
    scalability and robustness, adjusting to workload variations and ensuring system
    resilience.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计为模块化和可扩展，每个服务都专注于特定的任务，并通过定义的接口进行通信。这种设置允许在开发和部署方面具有灵活性，同时云环境支持可扩展性和鲁棒性，能够适应工作负载的变化并确保系统弹性。
- en: Architectural comparison – differences between monolithic and microservices
    designs
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构比较——单体和微服务设计之间的差异
- en: Microservices architecture presents a modern alternative to traditional monolithic
    designs. However, each has its distinct benefits and drawbacks. Here we focus
    on contrasting these two architectural styles.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是传统单体设计的现代替代方案。然而，每种架构都有自己的优点和缺点。在这里，我们专注于对比这两种架构风格。
- en: 'The details surrounding monolithic architecture are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构的细节如下：
- en: '**Structure**: Monolithic designs are characterized by a single, unified codebase
    that houses all functionalities, including the **User Interface** (**UI**), business
    logic, data storage, and processing.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**：单体设计的特点是有一个单一的、统一的代码库，其中包含所有功能，包括**用户界面**（**UI**）、业务逻辑、数据存储和处理。'
- en: '**Deployment**: In a monolithic architecture, the entire application is deployed
    as a single entity. Any changes or updates necessitate redeploying the whole application,
    potentially causing downtime and limiting flexibility.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：在单体架构中，整个应用程序作为一个单一实体进行部署。任何更改或更新都需要重新部署整个应用程序，这可能会导致停机并限制灵活性。'
- en: '**Scalability**: Scaling monolithic applications can be cumbersome as it often
    involves scaling the whole system even if only specific functionalities require
    it. This can lead to inefficiency and the unnecessary use of resources.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：单体应用程序的可扩展性可能很繁琐，因为它通常涉及扩展整个系统，即使只有特定的功能需要扩展。这可能导致效率低下和资源的不必要使用。'
- en: '**Advantages**: Monolithic architectures are simpler in terms of development
    and deployment, which makes them ideal for smaller projects or for organizations
    that lack extensive resources.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：单体架构在开发和部署方面更为简单，这使得它们非常适合小型项目或资源不足的组织。'
- en: 'Let’s look at *Figure 8**.2*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*图8.2*：
- en: '![Figure 8.2: A comparative overview of monolithic and microservices architectures](img/B20937_08_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：单体和微服务架构的比较概述](img/B20937_08_02.jpg)'
- en: 'Figure 8.2: A comparative overview of monolithic and microservices architectures'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：单体和微服务架构的比较概述
- en: In the monolithic architecture, the application is constructed as a single unit,
    integrating UI, business logic, and data storage within one codebase. This approach
    is initially simpler for development and deployment but can become cumbersome
    as the application scales. Changes in one area can affect the entire system, and
    scaling necessitates deploying the whole application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，应用程序作为一个单一单元构建，将UI、业务逻辑和数据存储集成在一个代码库中。这种方法在开发和部署初期较为简单，但随着应用程序的扩展可能会变得繁琐。一个区域的变更可能会影响整个系统，而扩展则需要部署整个应用程序。
- en: Conversely, microservices architecture decomposes the application into small,
    autonomous services, each handling a distinct function. These services interact
    via defined interfaces, supporting loose coupling and independent development,
    deployment, and scaling. While this structure enhances agility and scalability,
    it also brings complexity in coordinating services and increases operational demands.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，微服务架构将应用程序分解为小型、自主的服务，每个服务处理一个特定的功能。这些服务通过定义的接口进行交互，支持松散耦合和独立开发、部署和扩展。虽然这种结构增强了灵活性和可扩展性，但也带来了协调服务的复杂性，并增加了运营需求。
- en: 'Let’s look at some comparison and transition considerations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些比较和过渡的考虑因素：
- en: '**Complexity**: Monolithic architectures are simpler, but microservices increase
    in complexity with the need for detailed service orchestration. This can be mitigated
    with specific tools and frameworks.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：单体架构较为简单，但微服务架构随着详细的服务编排需求而增加复杂性。这可以通过特定的工具和框架来缓解。'
- en: '**Adoption**: Transitioning from monolithic to microservices architecture involves
    segmenting the existing codebase into separate services and establishing new patterns
    for inter-service communication.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用**：从单体架构过渡到微服务架构涉及将现有代码库分割成独立的服务，并建立新的服务间通信模式。'
- en: The choice between these architectures should be guided by the application’s
    requirements for scale and complexity, as well as the organization’s strategic
    objectives. Often, businesses start with a monolithic design and evolve toward
    microservices as their operational needs grow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些架构之间的选择应基于应用程序对扩展和复杂性的需求，以及组织的战略目标。通常，企业从单体设计开始，随着运营需求的增长逐渐转向微服务。
- en: Real-world examples – Netflix’s evolution and Amazon’s flexibility
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实世界的例子——Netflix的演变和亚马逊的灵活性
- en: Netflix’s journey to microservices architecture began in 2009 when it faced
    rapid growth and scaling challenges. This transition was driven by the need to
    handle massive workloads and deliver content seamlessly to a global audience.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix转向微服务架构的旅程始于2009年，当时它面临着快速增长和扩展的挑战。这次过渡是由处理大量工作负载和无缝向全球观众提供内容的需求驱动的。
- en: Netflix introduced adaptive streaming, allowing it to deliver video content
    with varying resolutions based on users’ internet speeds and devices. Microservices
    architecture allowed services such as video encoding, content delivery, and user
    profiling to work independently yet cohesively. Netflix’s microservices design
    also enabled the incorporation of a recommendation engine that suggests content
    based on users’ viewing history, enhancing user engagement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix引入了自适应流媒体，允许它根据用户的网络速度和设备提供不同分辨率的视频内容。微服务架构使得视频编码、内容交付和用户画像等服务能够独立但协同工作。Netflix的微服务设计还使得能够集成基于用户观看历史的推荐引擎，从而增强用户参与度。
- en: Over time, Netflix’s architecture has allowed for the integration of additional
    services, such as multilingual support, regional content libraries, and offline
    viewing, demonstrating how microservices architecture accommodates evolving functionalities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Netflix的架构允许集成额外的服务，如多语言支持、区域内容库和离线观看，展示了微服务架构如何适应不断发展的功能。
- en: Amazon’s transition to a microservices architecture has enabled it to scale
    its e-commerce platform efficiently, accommodating diverse functionalities and
    third-party services. Amazon’s microservices architecture enables integration
    with various third-party services, including payment gateways, analytics platforms,
    and customer review systems, allowing it to accommodate diverse user needs and
    incorporate new features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊转向微服务架构使其能够高效地扩展其电子商务平台，适应多样化的功能和第三方服务。亚马逊的微服务架构允许与各种第三方服务集成，包括支付网关、分析平台和客户评论系统，使其能够满足多样化的用户需求并集成新功能。
- en: Amazon’s microservices design allows for the integration of different technologies
    and tools, enabling it to evolve its technology stack smoothly. The independent
    deployment capabilities of Amazon’s microservices architecture allow it to iterate
    rapidly, ensuring its e-commerce platform stays competitive and adapts to changing
    market demands.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的微服务设计允许集成不同的技术和工具，使其能够平滑地演进其技术堆栈。亚马逊微服务架构的独立部署能力允许其快速迭代，确保其电子商务平台保持竞争力并适应不断变化的市场需求。
- en: Netflix and Amazon serve as powerful examples of how microservices architectures
    can be leveraged to address real-world challenges and drive business success.
    However, it’s important to note that these benefits are not limited to these tech
    giants, and that businesses across various industries are embracing microservices
    to build scalable, flexible, and resilient applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix和Amazon是微服务架构如何被用来应对现实世界挑战并推动商业成功的强大例证。然而，重要的是要注意，这些好处并不仅限于这些科技巨头，而且各个行业的公司都在接受微服务来构建可扩展、灵活和健壮的应用程序。
- en: In this section, we delved into microservices architecture in the cloud, discussing
    its core principles, such as modularity and scalability, and contrasting these
    with monolithic designs. We highlighted how companies such as Netflix and Amazon
    have leveraged microservices to enhance business outcomes through real-world case
    studies. Moving forward, we will examine Java’s concurrency tools, which are essential
    for developing scalable and resilient microservices, and how they address the
    unique demands of cloud-based microservices architecture.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了云中的微服务架构，讨论了其核心原则，如模块化和可扩展性，并将这些原则与单体设计进行了对比。我们强调了Netflix和Amazon等公司如何通过实际案例研究利用微服务来提升业务成果。展望未来，我们将考察Java的并发工具，这对于开发可扩展和健壮的微服务至关重要，以及它们如何满足基于云的微服务架构的独特需求。
- en: Essential Java concurrency tools for microservice management
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务管理的必备Java并发工具
- en: Java’s concurrency tools are vital for managing microservices in cloud environments,
    enabling efficient task management and **parallel processing**. In this section,
    we’ll explore how these tools facilitate the development of responsive and scalable
    microservices architectures, integrating seamlessly into modern cloud ecosystems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java的并发工具对于在云环境中管理微服务至关重要，它能够实现高效的任务管理和**并行处理**。在本节中，我们将探讨这些工具如何促进响应性和可扩展的微服务架构的开发，并无缝集成到现代云生态系统中。
- en: Concurrency tools – an exploration of Java’s concurrency tools that are tailored
    for microservices
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发工具 – 探索为微服务量身定制的Java并发工具
- en: In Java, concurrency tools such as **ExecutorService**, **parallel streams**,
    **CompletableFuture**, and the **Fork/Join frameworkframework** play crucial roles
    in microservices architectures. ExecutorService manages pools of worker threads
    for efficient task execution, while parallel streams expedite data processing
    tasks by operating concurrently, thereby enhancing performance. CompletableFuture
    supports asynchronous programming, facilitating non-blocking tasks and inter-service
    communication. The Fork/Join frameworkframework helps divide and conquer large
    tasks by breaking them down into smaller, parallelizable units, thus optimizing
    execution times. These tools are foundational for developing scalable and efficient
    microservices, and we will further explore their practical applications in enhancing
    cloud-based microservices management in upcoming sections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，**ExecutorService**、**并行流**、**CompletableFuture**和**Fork/Join框架**等并发工具在微服务架构中扮演着至关重要的角色。ExecutorService管理工作线程池以实现高效的任务执行，而并行流通过并发操作加速数据处理任务，从而提高性能。CompletableFuture支持异步编程，促进非阻塞任务和服务间通信。Fork/Join框架通过将大任务分解为更小的、可并行化的单元来帮助分而治之，从而优化执行时间。这些工具是开发可扩展和高效微服务的基础，我们将在后续章节中进一步探讨它们在增强基于云的微服务管理中的实际应用。
- en: Task parallelism – using Java’s concurrency mechanisms to manage microservices
    efficiently
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务并行 – 使用Java的并发机制来高效管理微服务
- en: '**Task parallelism** is an essential aspect of managing microservices efficiently.
    Java’s concurrency mechanisms offer practical solutions to distribute workloads,
    handle multiple tasks concurrently, and ensure responsive microservices.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务并行**是高效管理微服务的必要方面。Java的并发机制提供了实际解决方案来分配工作负载，同时处理多个任务，并确保微服务的响应性。'
- en: 'Let’s look at a code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码片段：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The provided code snippet demonstrates task parallelism using Java’s concurrency
    mechanisms within a microservices architecture. Here’s a concise analysis:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码片段展示了在微服务架构中使用Java的并发机制实现任务并行化。以下是一个简要的分析：
- en: '`List<Future<?>>` collects tasks submitted to an `executorService` for asynchronous
    execution. Tasks include inventory adjustments, invoice processing, and email
    confirmations related to an order.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Future<?>>`收集提交给`executorService`进行异步执行的任务。任务包括与订单相关的库存调整、发票处理和电子邮件确认。'
- en: Using `Future<?>` allows for tracking task outcomes and synchronizing them upon
    completion.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Future<?>`可以跟踪任务结果并在完成后同步它们。
- en: '`get()`, ensuring that all operations finish before proceeding. This synchronization
    is critical for maintaining consistency and reliability in service response.*   **Handling
    failures**: Exceptions from tasks are caught, logged, and rethrown, demonstrating
    robust error handling that allows the system to maintain high fault tolerance'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`，确保所有操作完成后再进行。这种同步对于保持服务响应的一致性和可靠性至关重要。*   **处理故障**：任务中的异常被捕获、记录并重新抛出，展示了强大的错误处理能力，使系统能够保持高容错性。'
- en: In a microservices architecture, task parallelism enables different microservices
    to work concurrently, each focusing on its specific responsibility. This approach
    allows for efficient processing of requests and optimizes the overall performance
    of the system. By leveraging task parallelism, microservices can handle multiple
    tasks simultaneously, leading to faster response times and improved throughput.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，任务并行化使不同的微服务能够并发工作，每个微服务专注于其特定的职责。这种方法允许高效地处理请求并优化系统的整体性能。通过利用任务并行化，微服务可以同时处理多个任务，从而实现更快的响应时间和提高吞吐量。
- en: However, task parallelism is just one aspect of achieving high performance in
    microservices. Another important concept is parallel processing, which involves
    breaking down a large task into smaller, independent subtasks that can be processed
    concurrently. In the next section, we will explore how parallel processing can
    be applied in microservices using Java’s parallel streams and the Fork/Join framework.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任务并行化只是实现微服务高性能的一个方面。另一个重要的概念是并行处理，它涉及将大任务分解成更小、独立的子任务，这些子任务可以并行处理。在下一节中，我们将探讨如何使用Java的并行流和Fork/Join框架在微服务中应用并行处理。
- en: Parallel processing for responsive microservices
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行处理响应式微服务
- en: Parallel processing is a powerful technique for improving the performance and
    responsiveness of microservices. By breaking down large tasks into smaller, independent
    subtasks and processing them concurrently, microservices can handle data-intensive
    operations and computationally expensive tasks more efficiently.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理是提高微服务性能和响应性的强大技术。通过将大任务分解成更小、独立的子任务并并行处理它们，微服务可以更有效地处理数据密集型操作和计算密集型任务。
- en: Java provides several tools for parallel processing, including parallel streams
    and the Fork/Join framework. Let’s explore how these tools can be used in a microservices
    context.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了几个并行处理工具，包括并行流和Fork/Join框架。让我们探讨这些工具如何在微服务环境中使用。
- en: 'Let’s look at a parallel stream example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个并行流的示例：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the `processData()` method receives a list of Data objects.
    Instead of processing the data sequentially, it uses the `parallelStream()` method
    to create a parallel stream. The `map()` operation is applied to each data item,
    invoking the `processDataItem ()` method concurrently. Finally, the processed
    results are collected into a list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`processData()`方法接收一个数据对象列表。它不是按顺序处理数据，而是使用`parallelStream()`方法创建一个并行流。`map()`操作应用于每个数据项，并发调用`processDataItem()`方法。最后，处理后的结果被收集到一个列表中。
- en: By using parallel streams, the data processing can be distributed across multiple
    threads, allowing for faster execution and improved microservice responsiveness.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用并行流，数据处理可以分布在多个线程上，从而实现更快的执行和改进的微服务响应性。
- en: The Fork/Join framework is another powerful tool for parallel processing in
    Java. It is designed to efficiently handle recursive algorithms and divide-and-conquer
    scenarios.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/Join框架是Java中用于并行处理的另一个强大工具。它旨在高效地处理递归算法和分而治之的场景。
- en: 'Here’s an example of using the Fork/Join framework in a microservice to perform
    a complex computation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在微服务中使用Fork/Join框架进行复杂计算的示例：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `ComplexComputationService` uses the Fork/Join framework
    to perform a complex computation. The `computeResult()` method receives a `Problem`
    object and submits a `ComplexComputationTask` to the `ForkJoinPool`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ComplexComputationService` 使用 Fork/Join 框架来执行复杂计算。`computeResult()`
    方法接收一个 `Problem` 对象，并将一个 `ComplexComputationTask` 提交到 `ForkJoinPool`。
- en: The `ComplexComputationTask` extends `RecursiveTask` and implements the `compute()`
    method. If the problem is simple, it solves it directly. Otherwise, it decomposes
    the problem into smaller subtasks, forks them for parallel execution, and then
    joins the results using the `join()` method. The results are combined using the
    `reduce()` operation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComplexComputationTask` 扩展了 `RecursiveTask` 并实现了 `compute()` 方法。如果问题简单，它将直接解决它。否则，它将问题分解成更小的子任务，并行执行它们，然后使用
    `join()` 方法合并结果。结果通过 `reduce()` 操作合并。'
- en: By utilizing the Fork/Join framework, the microservice can efficiently solve
    complex problems by recursively dividing them into smaller subproblems and processing
    them in parallel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Fork/Join框架，微服务可以有效地通过递归地将问题分解成更小的子问题并并行处理它们来解决复杂问题。
- en: These examples demonstrate how parallel processing techniques, such as parallel
    streams and the Fork/Join framework, can be applied in microservices to achieve
    better performance and responsiveness. By leveraging the power of parallel processing,
    microservices can handle large-scale data processing and complex computations
    more efficiently, resulting in improved user experience and faster response times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例演示了如何将并行处理技术，如并行流和Fork/Join框架，应用于微服务以实现更好的性能和响应性。通过利用并行处理的力量，微服务可以更有效地处理大规模数据处理和复杂计算，从而改善用户体验并加快响应时间。
- en: In this section, we examined Java’s concurrency tools and their role in microservices.
    We discussed how thread pools, parallel streams, and the Fork/Join framework enhance
    microservice performance through task parallelism, improving throughput and responsiveness.
    While beneficial, Java’s concurrency mechanisms also present challenges. Next,
    in the *Challenges and solutions in microservices concurrency* section, we will
    address common issues with concurrency in microservices and outline effective
    strategies and practices.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Java的并发工具及其在微服务中的作用。我们讨论了线程池、并行流和Fork/Join框架如何通过任务并行性增强微服务性能，提高吞吐量和响应性。虽然有益，但Java的并发机制也带来了挑战。接下来，在
    *微服务并发中的挑战与解决方案* 部分，我们将解决微服务并发中的常见问题，并概述有效的策略和实践。
- en: Challenges and solutions in microservices concurrency
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务并发中的挑战与解决方案
- en: Microservices architectures offer unparalleled flexibility and scalability for
    modern applications, yet their concurrent nature presents unique challenges. This
    section delves into critical aspects of microservices concurrency, exploring potential
    bottlenecks, strategies for ensuring data consistency, approaches to achieving
    resilience, and practical solutions to these challenges through Java’s concurrency
    mechanisms.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构为现代应用提供了无与伦比的灵活性和可扩展性，然而它们的并发特性也带来了独特的挑战。本节深入探讨了微服务并发的关键方面，包括潜在瓶颈、确保数据一致性的策略、实现弹性的方法，以及通过Java的并发机制解决这些挑战的实际解决方案。
- en: Bottlenecks – diagnosing potential challenges in concurrent microservices architectures
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓶颈 - 诊断并发微服务架构中的潜在挑战
- en: The introduction of concurrency in microservices architectures often leads to
    challenges and potential bottlenecks. Efficiently identifying and resolving these
    bottlenecks is crucial for maintaining the performance and smooth operation of
    concurrent microservices. This section outlines tools and strategies for effectively
    diagnosing and mitigating these issues, with a focus on cloud-based utilities.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构中并发引入通常会导致挑战和潜在瓶颈。有效地识别和解决这些瓶颈对于保持并发微服务的性能和顺畅运行至关重要。本节概述了用于有效诊断和缓解这些问题的工具和策略，重点关注基于云的实用工具。
- en: First, let us look at **API Gateway**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 **API网关**。
- en: 'API Gateway acts as the central hub for incoming requests. It manages the flow
    of traffic efficiently, ensuring smooth operation and preventing bottlenecks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: API网关作为入站请求的中心枢纽。它有效地管理流量，确保平稳运行并防止瓶颈：
- en: '**Request throttling**: Imposes rate limits on requests to prevent service
    overload and ensure consistent performance'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求节流**：对请求施加速率限制，以防止服务过载并确保一致的性能'
- en: '**Traffic routing**: Directs traffic efficiently to the appropriate services,
    distributing loads evenly and reducing coordination and communication bottlenecks'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量路由**：将流量有效地引导到适当的服务，均匀分配负载，并减少协调和通信瓶颈。'
- en: '**Caching**: By caching responses to frequently accessed endpoints, the gateway
    lessens the load on backend services and enhances response times'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：通过缓存频繁访问端点的响应，网关减轻了后端服务的负载，并提高了响应时间。'
- en: '**Metrics collection**: Collects critical metrics such as response times, error
    rates, and request volumes, which are crucial for identifying and addressing bottlenecks'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标收集**：收集关键指标，如响应时间、错误率和请求数量，这些对于识别和解决瓶颈至关重要。'
- en: Next, we will explore monitoring and logging tools.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨监控和日志记录工具。
- en: 'These tools are vital for diagnosing and resolving bottlenecks in microservices
    architectures:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具对于诊断和解决微服务架构中的瓶颈至关重要：
- en: '**AWS CloudWatch**: This offers real-time monitoring and logging, enabling
    the tracking of metrics such as resource utilization and response times. Alarms
    can be configured to alert threshold breaches, helping promptly identify and address
    emerging bottlenecks.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CloudWatch**：这提供实时监控和日志记录，能够跟踪资源利用率和响应时间等指标。可以配置警报以在阈值被突破时发出警报，帮助及时识别和解决新兴瓶颈。'
- en: '**Azure Monitor**: This provides comprehensive monitoring, alerting, and log
    analytics features, offering insights into potential contention points and communication
    delays.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Monitor**：这提供了全面的监控、警报和日志分析功能，提供了对潜在争用点和通信延迟的洞察。'
- en: '**Google Cloud Logging**: This captures logs from various microservices, offering
    insights into service interactions and identifying areas of latency or overhead.
    Log-based metrics help track specific bottleneck-inducing events.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Logging**：这捕获了来自各种微服务的日志，提供了对服务交互的洞察，并识别了延迟或开销区域。基于日志的指标有助于跟踪特定瓶颈诱导事件。'
- en: These solutions enable ongoing tracking and analysis of performance metrics,
    revealing trends that can pinpoint bottlenecks. They also guide necessary architectural
    adjustments, such as implementing caching strategies, sharding databases, or modifying
    communication patterns to boost efficiency.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案使持续跟踪和分析性能指标成为可能，揭示了可以定位瓶颈的趋势。它们还指导必要的架构调整，例如实施缓存策略、分片数据库或修改通信模式以提高效率。
- en: By integrating API Gateways with robust monitoring tools, microservices architectures
    can proactively diagnose and resolve bottlenecks, thus ensuring enhanced performance,
    scalability, and resilience. This integrated approach ensures that concurrency
    challenges are managed effectively, fostering a robust environment for microservices
    operation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将API网关与强大的监控工具集成，微服务架构可以主动诊断和解决瓶颈，从而确保性能、可扩展性和弹性的提升。这种集成方法确保了并发挑战得到有效管理，为微服务操作营造了一个稳健的环境。
- en: Consistency – ensuring data consistency and smooth inter-service communication
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性——确保数据一致性和服务间通信的顺畅。
- en: Ensuring consistency in microservices architecture, particularly given its distributed
    nature, is critical. This section delves into how distributed databases and message
    brokers are fundamental in achieving consistency across services.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中确保一致性，尤其是考虑到其分布式特性，至关重要。本节深入探讨了分布式数据库和消息代理如何对于在服务间实现一致性至关重要。
- en: We’ll start with distributed databases. Selecting the right distributed databases
    such as Amazon RDS, Google Cloud SQL, and Azure Database for PostgreSQL is key.
    These services ensure transactional consistency and **Atomicity, Consistency,
    Isolation, Durability** (**ACID**) compliance, which is crucial for operations
    that require reliable data handling. They manage data integrity across microservices
    by ensuring complete transactions before committing, and if a transaction fails,
    it is fully rolled back to maintain consistency.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从分布式数据库开始。选择正确的分布式数据库，如Amazon RDS、Google Cloud SQL和Azure Database for PostgreSQL至关重要。这些服务确保了事务一致性和**原子性、一致性、隔离性、持久性**（**ACID**）的合规性，这对于需要可靠数据处理的操作至关重要。它们通过确保在提交前完成完整事务来管理微服务之间的数据完整性，如果事务失败，则完全回滚以保持一致性。
- en: These databases enhance scalability with features such as read replicas and
    sharding. They support robust data replication across zones or regions for improved
    availability and disaster recovery. Fully managed solutions reduce operational
    overhead, allowing teams to focus on core functionalities. Alternatives such as
    Apache Cassandra and Google Cloud Spanner, while offering less stringent consistency,
    excel in scenarios needing high scalability and low-latency access across geographic
    regions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据库通过读取副本和分片等功能增强可扩展性。它们支持跨区域或地区的稳健数据复制，以改善可用性和灾难恢复。完全管理的解决方案减少了运营开销，使团队能够专注于核心功能。Apache
    Cassandra和Google Cloud Spanner等替代方案，虽然一致性要求不那么严格，但在需要高可扩展性和跨地理区域低延迟访问的场景中表现出色。
- en: 'Next, let’s consider message brokers. Tools such as AWS SQS, Google Pub/Sub,
    Apache Kafka, and Azure Service Bus streamline inter-service communication by
    managing asynchronous message queues. They enhance consistency in the following
    ways:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑消息代理。AWS SQS、Google Pub/Sub、Apache Kafka和Azure Service Bus等工具通过管理异步消息队列来简化服务间通信。它们通过以下方式提高一致性：
- en: '**Decoupling services**: These brokers allow services to operate independently,
    improving system uptime by maintaining functionality even when parts fail.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦服务**：这些代理允许服务独立运行，通过在部分失败时保持功能来提高系统正常运行时间。'
- en: '**Reliable delivery**: They ensure that messages accurately reach intended
    services, supporting high-volume conditions. Kafka, for instance, is known for
    its durability, while Azure Service Bus offers reliability within its ecosystem.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠投递**：它们确保消息准确到达目标服务，支持高容量条件。例如，Kafka以其耐用性而闻名，而Azure Service Bus在其生态系统中提供可靠性。'
- en: '**Event-driven architecture support**: They aid services in dynamically responding
    to changes, essential for maintaining consistency across services reacting to
    the same events.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动架构支持**：它们帮助服务动态响应变化，这对于维护对同一事件做出反应的服务之间的一致性至关重要。'
- en: 'From a design perspective, the choice between using a **Relational Database
    Service** (**RDS**) or a message broker depends on the specific requirements of
    your application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，选择使用**关系数据库服务**（**RDS**）或消息代理取决于您应用程序的具体要求：
- en: '**Use RDS** for transactional data needs requiring ACID properties, complex
    data relationships needing strong integrity, or centralized data management, as
    well as when complex queries are necessary for analytics'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RDS**来满足需要ACID属性的事务数据需求、需要强完整性的复杂数据关系或集中式数据管理，以及当需要复杂的查询进行分析时'
- en: '**Use message brokers** for asynchronous communication needs, event-driven
    architectures, scalability under varying loads, efficient high-volume traffic
    handling, or complex workflow orchestration across multiple microservices'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用消息代理**来满足异步通信需求、事件驱动架构、不同负载下的可扩展性、高效处理高流量或跨多个微服务的复杂工作流编排'
- en: Often, the strengths of RDSs and message brokers complement each other in a
    microservices architecture, and they are not mutually exclusive. For example,
    you might use an RDS to manage transactional data integrity while using a message
    broker to handle events that result from changes in the data, thus combining reliable
    data management with reactive service orchestration. This approach leverages the
    strengths of both technologies to create a robust, scalable, and resilient architecture.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RDS和消息代理在微服务架构中的优势相互补充，它们不是相互排斥的。例如，您可能使用RDS来管理事务数据完整性，同时使用消息代理来处理数据变化引起的事件，从而将可靠的数据管理与反应式服务编排相结合。这种方法利用了两种技术的优势，以创建一个强大、可扩展和有弹性的架构。
- en: 'Let’s look at *Figure 8**.3*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*图8.3*：
- en: '![Figure 8.3: A microservice architecture with an API Gateway, message broker,
    and RDS](img/B20937_08_03.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：具有API网关、消息代理和RDS的微服务架构](img/B20937_08_03.jpg)'
- en: 'Figure 8.3: A microservice architecture with an API Gateway, message broker,
    and RDS'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：具有API网关、消息代理和RDS的微服务架构
- en: This figure depicts a microservice architecture design leveraging an RDS and
    a message broker to facilitate communication and data persistence.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了利用RDS和消息代理来促进通信和数据持久性的微服务架构设计。
- en: 'Key components of this design include the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计的核心组件包括以下内容：
- en: '**UI layer**: Users interact here'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户界面层**：用户在此交互'
- en: '**API Gateway**: Routes requests to microservices'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**API网关**：将请求路由到微服务'
- en: '**Microservices**: Handle specific functionalities'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**微服务**：处理特定功能'
- en: '**RDS**: Stores data persistently (relational tables)'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RDS**：存储持久数据（关系表）'
- en: '**Message broker**: Enables asynchronous communication between microservices'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**消息代理**：使微服务之间实现异步通信'
- en: 'Here’s how it works:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理如下：
- en: A user initiates a request through UI.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户通过UI发起请求。
- en: The API Gateway routes requests to the relevant microservice(s).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关将请求路由到相关的微服务（们）。
- en: The microservice interacts with the RDS or publishes a message to the message
    broker.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与RDS交互或向消息代理发布消息。
- en: Other microservices subscribed to the message broker receive and process the
    message.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅消息代理的其他微服务接收并处理消息。
- en: Data persistence might occur in an RDS.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据持久性可能发生在RDS中。
- en: The microservice generates a response and sends it back to the user through
    the API gateway.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务生成响应并通过API网关将其发送回用户。
- en: 'Its benefits are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它的好处如下：
- en: '**Decoupling**: Microservices are loosely coupled and can scale independently'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦**：微服务松散耦合且可独立扩展'
- en: '**Data consistency**: Using RDS maintains data integrity across services'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性**：使用RDS维护服务间数据完整性'
- en: In essence, the message broker fosters asynchronous communication, while the
    RDS offers persistent storage.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，消息代理促进异步通信，而RDS提供持久存储。
- en: Resilience – achieving system resilience and fault tolerance
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性 - 实现系统弹性和容错性
- en: 'Achieving robustness in microservices involves implementing the following strategies
    that enhance system resilience and fault tolerance:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中实现健壮性涉及实施以下策略，这些策略增强了系统弹性和容错性：
- en: '**Circuit breakers**: Utilizing tools such as Netflix Hystrix or Resilience4j,
    circuit breakers help manage service failures gracefully. They prevent cascading
    failures by halting the propagation of faults across services, thus maintaining
    system functionality during partial outages.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电路断路器**：利用Netflix Hystrix或Resilience4j等工具，电路断路器帮助优雅地管理服务故障。它们通过停止故障在服务间传播来防止级联故障，从而在部分中断期间保持系统功能。'
- en: '**Load balancers**: Employing cloud-native load balancers assists in evenly
    distributing incoming traffic among available services. This not only enhances
    fault tolerance by avoiding overloading any single service but also helps in preventing
    bottlenecks, thus ensuring smoother operation and better response times across
    the system.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器**：使用云原生负载均衡器有助于在可用服务之间均匀分配传入流量。这不仅通过避免任何单个服务的过载来提高容错性，还有助于防止瓶颈，从而确保系统运行更顺畅，响应时间更好。'
- en: Circuit breakers and load balancers can work together to build resilient microservices.
    Load balancers distribute traffic, preventing bottlenecks and single points of
    failure. Circuit breakers provide additional protection by isolating failing services
    and preventing cascading failures.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器和负载均衡器可以协同工作，构建健壮的微服务。负载均衡器分配流量，防止瓶颈和单点故障。电路断路器通过隔离失败的服务并防止级联故障，提供额外的保护。
- en: This section has outlined the pivotal role of concurrency management in microservices,
    delving into the challenges and solutions related to potential bottlenecks and
    ensuring data consistency. We examined tools and strategies for mitigating issues
    such as traffic congestion and maintaining data integrity across distributed services,
    utilizing API gateways for traffic management, and utilizing message brokers for
    seamless inter-service communication. By integrating distributed databases and
    robust messaging systems, microservices can achieve enhanced performance, scalability,
    and resilience.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了并发管理在微服务中的关键作用，深入探讨了与潜在瓶颈相关的挑战和解决方案，确保数据一致性。我们研究了缓解如流量拥堵和确保分布式服务间数据完整性的工具和策略，利用API网关进行流量管理，以及利用消息代理实现服务间通信的无缝性。通过集成分布式数据库和强大的消息系统，微服务可以实现更高的性能、可扩展性和弹性。
- en: Moving forward, we will transition from theoretical concepts to practical applications.
    The upcoming section, *Hands-on – designing concurrent microservices in Java*,
    will provide a detailed guide on implementing these concurrency principles in
    Java.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，我们将从理论概念过渡到实际应用。接下来的章节，*动手实践 - 在Java中设计并发微服务*，将提供关于在Java中实现这些并发原则的详细指南。
- en: Practical design and implementation – building effective Java microservices
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际设计和实现 - 构建有效的Java微服务
- en: This section dives into practical Java code examples, showcasing how to tackle
    concurrency challenges in a microservices architecture using cloud utilities and
    mechanisms such as message brokers, distributed databases, and circuit breakers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨实际的Java代码示例，展示如何使用云工具和机制（如消息代理、分布式数据库和断路器）解决微服务架构中的并发挑战。
- en: Use case 1 – e-commerce application – processing orders
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例1 - 电子商务应用 - 处理订单
- en: In an e-commerce application with a microservice for processing orders, concurrency
    challenges can arise due to multiple order requests trying to deduct from the
    same balance simultaneously, leading to inconsistencies and data integrity issues.
    To address these challenges, we can leverage the optimistic locking that is offered
    by most distributed databases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个具有处理订单微服务的电子商务应用中，由于多个订单请求同时尝试从同一余额中扣除，可能会出现并发挑战，导致不一致性和数据完整性问题。为了解决这些挑战，我们可以利用大多数分布式数据库提供的乐观锁。
- en: 'Optimistic locking uses a version number associated with the user’s account
    balance. When an update query is executed, it includes the expected version number.
    If the version in the database doesn’t match the expected version, it indicates
    that another transaction might have modified the balance first, causing the update
    to fail. This prevents race conditions and ensures data consistency. Here are
    steps involved in the code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 乐观锁使用与用户账户余额关联的版本号。当执行更新查询时，它包括预期的版本号。如果数据库中的版本号与预期版本号不匹配，则表示另一个事务可能首先修改了余额，导致更新失败。这防止了竞态条件并确保了数据一致性。以下是代码片段中涉及到的步骤：
- en: 'Open the `pom.xml` file in the project’s root directory and add the following
    dependencies:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目根目录下的`pom.xml`文件并添加以下依赖项：
- en: '[PRE3]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the `UserAccount` class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`UserAccount`类：
- en: '[PRE4]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code defines a `UserAccount` JPA entity. It has a `@Version` number (version)
    for optimistic locking, ensuring data consistency during updates.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码定义了一个`UserAccount` JPA实体。它有一个`@Version`数字（版本号）用于乐观锁，确保更新期间的数据一致性。
- en: 'Create the `AccountRepository` interface in the same package. This interface
    should extend `JpaRepository` and define the `deductBalance()` method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中创建`AccountRepository`接口。此接口应扩展`JpaRepository`并定义`deductBalance()`方法：
- en: '[PRE5]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the `AccountService` class in the same package and inject an `AccountRepository`
    instance into it:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中创建`AccountService`类并将`AccountRepository`实例注入其中：
- en: '[PRE6]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For optimistic locking, the method retrieves the current version number of the
    account being updated. It then invokes `accountRepository.deductBalance()` using
    the user ID, the amount to be deducted, and the expected version number. After
    this operation, the method checks the number of rows that were updated (`rowsUpdated`).
    A successful update — which is indicated by exactly one row being updated — allows
    the process to proceed. If the update affects either no rows or more than one
    row, it suggests that the account may have been concurrently modified by another
    process. In this case, an `OptimisticLockingException` is thrown, indicating that
    the update failed due to outdated data, prompting a retry to maintain data consistency.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于乐观锁，该方法检索正在更新的账户的当前版本号。然后使用用户ID、要扣除的金额和预期的版本号调用`accountRepository.deductBalance()`。在此操作之后，该方法检查更新的行数（`rowsUpdated`）。成功的更新（表示恰好更新了一行）允许进程继续进行。如果更新影响零行或多于一行，则表明账户可能已被另一个进程并发修改。在这种情况下，抛出`OptimisticLockingException`，表示由于数据过时导致更新失败，提示重试以保持数据一致性。
- en: 'Next, we can use a message broker for asynchronous communication:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用消息代理进行异步通信：
- en: '[PRE7]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can create the `OrderService` class and inject a `MessageProducer`
    instance into it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以创建`OrderService`类并将`MessageProducer`实例注入其中：
- en: '[PRE8]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The order processing microservice publishes a message to the message broker
    after successful validation and balance deduction. Separate services subscribed
    to the broker can then handle order confirmation and fulfillment asynchronously.
    This ensures that the order processing microservice isn’t blocked by these downstream
    tasks.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 订单处理微服务在验证成功并扣除余额后向消息代理发布消息。订阅了代理的独立服务可以随后异步处理订单确认和履行。这确保了订单处理微服务不会被这些下游任务阻塞。
- en: These examples showcase how Java code can leverage cloud functionalities to
    address concurrency challenges in microservices. By combining optimistic locking
    and message brokers, you can build a more robust and scalable e-commerce application.
    These are simplified examples. Real-world implementations might involve additional
    error handling, logging, and configuration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了Java代码如何利用云功能来解决微服务中的并发挑战。通过结合乐观锁和信息代理，您可以构建一个更健壮和可扩展的电子商务应用程序。这些是简化示例。现实世界的实现可能涉及额外的错误处理、日志记录和配置。
- en: Use case 2 – building a data processing pipeline with microservices
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例2 - 使用微服务构建数据处理管道
- en: 'This case study delves into designing and implementing a data processing pipeline
    using a microservices architecture:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例研究深入探讨了使用微服务架构设计和实现数据处理管道：
- en: 'The first step is to design the microservices. We’ll construct the pipeline
    with three distinct microservices:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设计微服务。我们将使用三个不同的微服务构建管道：
- en: '**Data ingestion service**: This service acts as the entry point, which is
    responsible for receiving and validating incoming data from external sources.
    Once validated, it publishes the data to an Amazon SQS queue for further processing.
    The service depends on the Amazon SQS client library.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据摄取服务**：此服务作为入口点，负责接收和验证来自外部源的数据。一旦验证通过，它将数据发布到Amazon SQS队列以进行进一步处理。该服务依赖于Amazon
    SQS客户端库。'
- en: '**Data processing service**: This service subscribes to the Amazon SQS queue
    used by the data ingestion service. It consumes the data, applies business logic
    for transformation, and publishes the processed data to another SQS queue for
    persistence. This service relies on both the Amazon SQS client library and the
    AWS Glue SDK.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理服务**：此服务订阅数据摄取服务使用的Amazon SQS队列。它消费数据，应用业务逻辑进行转换，并将处理后的数据发布到另一个SQS队列以进行持久化。此服务依赖于Amazon
    SQS客户端库和AWS Glue SDK。'
- en: '**Data persistence service**: The final service consumes the processed data
    from the second SQS queue. Its primary function is to store the data persistently
    in Amazon RDS for long-term accessibility. This service utilizes both the Amazon
    SQS client library and the Amazon RDS client library.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据持久化服务**：该服务最终消费来自第二个SQS队列的处理后数据。其主要功能是将数据持久化存储在Amazon RDS中，以便长期访问。此服务利用了Amazon
    SQS客户端库和Amazon RDS客户端库。'
- en: By leveraging AWS services, we can build a scalable and efficient data processing
    solution that benefits from the modularity and flexibility inherent in a microservices
    architecture.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过利用AWS服务，我们可以构建一个可扩展且高效的数据处理解决方案，该方案得益于微服务架构固有的模块化和灵活性。
- en: 'The next step is to set up the AWSs:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置AWS：
- en: '**Two AWS Simple Queue Service** (**SQS**) **queues** will be set up:'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个AWS简单队列服务**（**SQS**）**队列**将被设置：'
- en: '**Initial data queue**: Create a queue intended for receiving initial unprocessed
    data'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始数据队列**：创建一个用于接收初始未处理数据的队列。'
- en: '**Processed data queue**: Set up another queue for holding processed data ready
    for further actions or storage'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理数据队列**：为存储准备进一步操作或存储的处理数据设置另一个队列。'
- en: '**AWS RDS instance**: Set up an RDS instance to provide persistent storage
    for your application. You can choose MySQL, PostgreSQL, or any other available
    RDS database engine depending on your application requirements. This database
    will be used to store and manage the data processed by your application.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS RDS实例**：设置一个RDS实例以提供应用程序的持久存储。您可以根据应用程序需求选择MySQL、PostgreSQL或其他可用的RDS数据库引擎。此数据库将用于存储和管理应用程序处理的数据。'
- en: '**AWS Simple Notification Service** (**SNS**): Create an SNS topic to facilitate
    the notification process. This topic will be used to publish messages notifying
    subscribers of successful data processing events and other important notifications.
    Determine the subscribers to this topic, which could include email addresses,
    SMS, HTTP endpoints, or even other AWS services such as Lambda or SQS, depending
    on your notification requirements.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS简单通知服务**（**SNS**）：创建一个SNS主题以简化通知过程。此主题将用于发布消息，通知订阅者数据处理成功事件和其他重要通知。确定此主题的订阅者，这可能包括电子邮件地址、短信、HTTP端点，甚至根据您的通知需求，其他AWS服务如Lambda或SQS。'
- en: The third step is to set up a Maven project. Create a new Maven project for
    each microservice (DataIngestionService, DataProcessingLambda, and DataPersistenceService)
    in your preferred `pom.xml` file in each project’s root directory and add the
    related dependencies.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是设置 Maven 项目。在每个项目的根目录中，为每个微服务（DataIngestionService、DataProcessingLambda
    和 DataPersistenceService）创建一个新的 Maven 项目，并在每个项目的首选 `pom.xml` 文件中添加相关依赖项。
- en: 'The fourth step is to implement the data ingestion service:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四步是实现数据摄取服务：
- en: '[PRE9]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code represents the implementation of the data ingestion service, which
    is responsible for receiving incoming data, validating it, and publishing it to
    Amazon SQS for further processing.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码表示数据摄取服务的实现，该服务负责接收传入的数据，验证它，并将其发布到 Amazon SQS 以进行进一步处理。
- en: The `DataIngestionService` class is annotated with `@Service`, indicating that
    it is a Spring service component. It has a dependency on the `AmazonSQS client`,
    which is injected through the constructor.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataIngestionService` 类被注解为 `@Service`，表示它是一个 Spring 服务组件。它依赖于 `AmazonSQS`
    客户端，该客户端通过构造函数注入。'
- en: The `ingestData()` method takes a `data object` as input and performs data validation
    by calling the `isValid()` method. If the data is valid, it creates a `SendMessageRequest`
    object with the specified SQS queue URL and the data payload as the message body.
    The message is then sent to the SQS queue using the `sqsClient.sendMessage()`
    method.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ingestData()` 方法接收一个 `data object` 作为输入，并通过调用 `isValid()` 方法执行数据验证。如果数据有效，它将创建一个包含指定
    SQS 队列 URL 和数据负载作为消息体的 `SendMessageRequest` 对象。然后，使用 `sqsClient.sendMessage()`
    方法将消息发送到 SQS 队列。'
- en: 'The fifth step is to implement the data processing service using AWS Lambda:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五步是使用 AWS Lambda 实现数据处理服务：
- en: '[PRE10]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This Lambda function, `DataProcessingLambda`, processes data from an Amazon
    SQS queue by implementing the `RequestHandler` interface to handle `SQSEvent`
    events. It initializes an Amazon SQS client in the constructor and uses it to
    send transformed data to another SQS queue for further processing or storage.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 Lambda 函数 `DataProcessingLambda` 通过实现 `RequestHandler` 接口来处理 `SQSEvent` 事件，从而处理来自
    Amazon SQS 队列的数据。它在构造函数中初始化一个 Amazon SQS 客户端，并使用它将转换后的数据发送到另一个 SQS 队列，以进行进一步处理或存储。
- en: The `handleRequest()` method, serving as the function’s entry point, processes
    each `SQSMessage` from the `SQSEvent`, extracting the data and transforming it
    directly within the function through the `transformData()` method. Here, the transformation
    appends a timestamp to the data as a simple example, but typically this would
    involve more complex operations tailored to specific data processing requirements.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`handleRequest()` 方法作为函数的入口点，处理来自 `SQSEvent` 的每个 `SQSMessage`，提取数据并通过 `transformData()`
    方法在函数内部直接转换数据。在这里，转换通过添加时间戳到数据作为一个简单的示例，但通常这会涉及针对特定数据处理需求定制的更复杂操作。'
- en: Following the data transformation, the function sends the processed data to
    a specified SQS queue by invoking the `sendMessage()` method on the SQS client.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在数据转换之后，该函数通过在 SQS 客户端上调用 `sendMessage()` 方法，将处理后的数据发送到指定的 SQS 队列。
- en: 'The next step is to create a Spring-managed service that handles storing processed
    data in a database and notifies subscribers via AWS SNS upon successful persistence:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个 Spring 管理的服务，该服务负责将处理后的数据存储在数据库中，并在成功持久化后通过 AWS SNS 通知订阅者：
- en: '[PRE11]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`DataPersistenceService` is a Spring-managed bean responsible for handling
    data persistence and notifying other components or services via Amazon SNS. Here’s
    a step-by-step description of its functionality:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataPersistenceService` 是一个由 Spring 管理的 Bean，负责处理数据持久化和通过 Amazon SNS 通知其他组件或服务。以下是其功能的逐步描述：'
- en: '`AmazonSNS` client used for sending notifications.'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AmazonSNS` 客户端发送通知。
- en: '`persistData()` method takes a `String data` parameter, which is the processed
    data. It creates a `Data entity`, sets the processed data, and saves it to the
    database using the `DataRepository`.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persistData()` 方法接收一个 `String data` 参数，即处理后的数据。它创建一个 `Data entity`，设置处理后的数据，并使用
    `DataRepository` 将其保存到数据库。'
- en: '`sendNotification()` to notify other parts of the application. It constructs
    a `PublishRequest` with a `topic ARN (Amazon Resource Name)` and the message detailing
    the successful persistence. The message is then published to the specified SNS
    topic.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendNotification()` 用于通知应用程序的其他部分。它构建一个包含 `topic ARN (Amazon Resource Name)`
    和详细成功持久化消息的 `PublishRequest`。然后，将消息发布到指定的 SNS 主题。'
- en: This service is particularly useful in microservice architectures where decoupled
    components must communicate state changes or updates. Using SNS for notifications
    enhances the reliability of the system by ensuring not only that data is persisted
    but also that relevant services or components are informed of the update through
    a robust, scalable messaging system.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务特别适用于微服务架构，其中解耦的组件必须通信状态变化或更新。使用 SNS 进行通知通过确保数据持久化，并且通过一个强大、可扩展的消息系统通知相关服务或组件，从而增强了系统的可靠性。
- en: This section details the practical application of Java to manage concurrency
    in a microservices architecture, particularly for an e-commerce application processing
    order. It explains how using optimistic locking with version numbers in a distributed
    database can prevent data inconsistencies during concurrent order processing.
    Additionally, the use of message brokers is discussed as a method for asynchronous
    communication, which aids in keeping microservices from being blocked by downstream
    tasks, thereby improving efficiency and scalability.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细介绍了 Java 在微服务架构中管理并发性的实际应用，特别是对于处理订单的电子商务应用程序。它解释了如何在分布式数据库中使用带版本号的乐观锁如何防止并发订单处理中的数据不一致。此外，还讨论了使用消息代理作为异步通信的方法，这有助于防止微服务被下游任务阻塞，从而提高效率和可扩展性。
- en: Moving forward, the next section will cover strategic best practices for deploying
    and scaling microservices. This includes leveraging cloud-native services and
    architectures to optimize performance, scalability, and reliability, as well as
    providing a comprehensive guide for developers and architects on how to effectively
    manage microservices in a cloud environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将介绍部署和扩展微服务的战略最佳实践。这包括利用云原生服务和架构来优化性能、可扩展性和可靠性，并为开发人员和架构师提供全面指南，说明如何在云环境中有效地管理微服务。
- en: Strategic best practices – deploying and scaling microservices
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战略最佳实践 - 部署和扩展微服务
- en: When designing, deploying, and scaling microservices in a cloud environment,
    it’s essential to utilize cloud-native services and architectures to maximize
    performance, scalability, and reliability.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计、部署和扩展云环境中的微服务时，利用云原生服务和架构以最大化性能、可扩展性和可靠性是至关重要的。
- en: 'Here’s a straightforward guide on best practices, tailored for developers and
    architects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个针对开发人员和架构师的简单指南，关于最佳实践：
- en: '**Load balancing**:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：'
- en: '**Purpose**: Distribute incoming traffic evenly across multiple microservice
    instances to enhance reliability and availability'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的**：将传入流量均匀分布在多个微服务实例上，以增强可靠性和可用性'
- en: '**How** **to implement**:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何实现**：'
- en: Use cloud-managed load balancers such as AWS **Elastic Load Balancing** (**ELB)**,
    Azure Load Balancer, or Google Cloud Load Balancing, which can automatically adjust
    to traffic demands
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用云管理的负载均衡器，例如 AWS **弹性负载均衡器**（**ELB**）、Azure 负载均衡器或 Google Cloud 负载均衡器，它们可以自动调整以适应流量需求
- en: Integrate service discovery tools (e.g., AWS Cloud Map, Azure Service Discovery,
    or Google Cloud Service Directory) to dynamically manage service instances
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成服务发现工具（例如，AWS Cloud Map、Azure 服务发现或 Google Cloud 服务目录）以动态管理服务实例
- en: '**Caching solutions**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存解决方案**'
- en: '**Purpose**: Reduce database load and speed up response times by caching frequently
    accessed data'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的**：通过缓存频繁访问的数据来减少数据库负载并加快响应时间'
- en: '**How** **to implement**:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何实现**：'
- en: Opt for managed caching services such as Amazon ElastiCache, Azure Redis Cache,
    or Google Cloud Memorystore, which offer distributed caching capabilities
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择托管缓存服务，如 Amazon ElastiCache、Azure Redis Cache 或 Google Cloud Memorystore，它们提供分布式缓存功能
- en: Choose an appropriate caching strategy (local, distributed, or hybrid) and ensure
    proper management of cache coherence and expiration
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的缓存策略（本地、分布式或混合），并确保正确管理缓存一致性和过期
- en: '**Managed databases**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管数据库**'
- en: '**Purpose**: Simplify database management tasks (scaling, backups, patching),
    allowing developers to concentrate on building functionalities'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的**：简化数据库管理任务（扩展、备份、修补），使开发者能够专注于构建功能'
- en: '**How** **to implement**:'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何实现**：'
- en: Implement a database-per-service model using **Database as a Service** (**DBaaS**)
    solutions such as Amazon RDS, Azure SQL Database, or Google Cloud SQL to ensure
    resource isolation and optimized performance
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **数据库即服务**（**DBaaS**）解决方案，如 Amazon RDS、Azure SQL 数据库或 Google Cloud SQL，实现数据库按服务模型，以确保资源隔离和优化性能
- en: Leverage automated features within DBaaS for scaling, backups, and ensuring
    high availability
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用DBaaS中的自动化功能进行扩展、备份和确保高可用性
- en: '**Microservices** **architecture considerations**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务** **架构考虑事项**'
- en: Maintain loose coupling among services to enable independent development, deployment,
    and scaling
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持服务之间的松散耦合，以实现独立开发、部署和扩展
- en: Apply **Domain-Driven Design** (**DDD**) principles by organizing microservices
    around business capabilities and defining clear bounded contexts
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过围绕业务能力组织微服务并定义清晰的边界上下文来应用**领域驱动设计**（**DDD**）原则
- en: '**Deployment** **and scaling**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署** **和扩展**'
- en: '**Containers and orchestration**: Deploy microservices using containerization
    with Kubernetes, which is supported by AWS EKS, Azure AKS, and Google GKE, to
    manage container lifecycles and automate scaling'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器和编排**: 使用Kubernetes容器化部署微服务，Kubernetes由AWS EKS、Azure AKS和Google GKE支持，以管理容器生命周期和自动化扩展'
- en: '**Scalability**: Implement auto-scaling based on CPU, memory usage, or custom
    metrics aligned with your application’s needs'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**: 根据CPU、内存使用情况或与您的应用程序需求对齐的自定义指标实现自动扩展'
- en: '**Monitoring** **and logging**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控** **和日志记录**'
- en: '**Observability**: Implement comprehensive monitoring and logging to keep track
    of microservice performance and operational health; also, utilize tools such as
    AWS CloudWatch, Azure Monitor, or Google’s Operations Suite for real-time monitoring,
    performance tracking, and alert management'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性**: 实施全面的监控和日志记录以跟踪微服务性能和运行状况；同时，利用AWS CloudWatch、Azure Monitor或Google的Operations
    Suite等工具进行实时监控、性能跟踪和警报管理'
- en: Adhering to these best practices leverages the strengths of cloud computing,
    enhancing the resilience, performance, and scalability of your microservices architecture.
    This strategic approach not only ensures robust service delivery but also maintains
    the agility needed for continuous innovation and growth.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些最佳实践利用了云计算的优势，增强了微服务架构的弹性、性能和可伸缩性。这种战略方法不仅确保了稳健的服务交付，还保持了持续创新和增长所需的敏捷性。
- en: Advanced concurrency patterns – enhancing microservice resilience and performance
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级并发模式——增强微服务的弹性和性能
- en: When developing microservices in Java, it is essential to employ concurrency
    patterns and techniques that enhance the application’s responsiveness, fault tolerance,
    and scalability. These patterns help manage the complexities inherent in distributed
    systems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中开发微服务时，采用增强应用程序响应性、容错性和可伸缩性的并发模式和技术的至关重要。这些模式有助于管理分布式系统固有的复杂性。
- en: Here’s a discussion on key concurrency and data management patterns applicable
    to microservices.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论了适用于微服务的关键并发和数据管理模式。
- en: Data management patterns
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据管理模式
- en: Understanding and implementing effective data management patterns is crucial
    for designing robust microservices. Let’s look at them one by one.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和实施有效的数据管理模式对于设计健壮的微服务至关重要。让我们逐一探讨。
- en: Command Query Responsibility Segregation
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令查询责任分离
- en: '**Command Query Responsibility Segregation** or **CQRS** separates the read
    and write operations of a data store to optimize performance, scalability, and
    security. This pattern allows reads and writes to be scaled independently. Let’s
    look at the details:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令查询责任分离**或**CQRS**将数据存储的读取和写入操作分开，以优化性能、可伸缩性和安全性。此模式允许读取和写入独立扩展。让我们看看细节：'
- en: '**Use case**: Useful in complex domains where the read operations significantly
    outnumber the write operations, or when they can be clearly differentiated'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**: 在读取操作显著多于写入操作，或者可以明确区分的复杂领域中有用'
- en: '**Implementation details**: *Figure 8**.4* shows a system using CQRS, which
    separates data updates (commands) from data retrieval (queries)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现细节**: *图8*.4显示了使用CQRS的系统，它将数据更新（命令）与数据检索（查询）分开'
- en: '![Figure 8.4: CQRS architecture flow](img/B20937_08_04.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：CQRS架构流程](img/B20937_08_04.jpg)'
- en: 'Figure 8.4: CQRS architecture flow'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：CQRS架构流程
- en: '**Command side**: Handles updates with a Command API, CommandHandler, and Write
    Database'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令端**: 使用命令API、CommandHandler和写数据库处理更新'
- en: '**Query side**: Handles reads with a Query API and a separate Read Database
    optimized for fast reads'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询端**: 使用查询API和单独的针对快速读取优化的读数据库处理读取'
- en: This separation improves performance and scalability. Each side can be optimized
    for its task and scaled independently. Additionally, the Query Side can stay available
    during updates on the Write Side.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离提高了性能和可扩展性。每一方都可以针对其任务进行优化并独立扩展。此外，查询端可以在写入端更新期间保持可用。
- en: Event sourcing
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件溯源
- en: '**Event sourcing** is a design pattern in which changes to the state of an
    application are stored as a sequence of events. Instead of storing just the current
    state of the data in a domain, event sourcing stores a sequence of state-changing
    events. Whenever the state of a business entity changes, a new event is appended
    to the list of events associated with that entity. This sequence of events serves
    as the principal source of truth and can be used to reconstruct past states of
    an entity. Let’s take a closer look:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件溯源**是一种设计模式，其中应用程序状态的变化以事件序列的形式存储。与仅在域中存储数据的当前状态不同，事件溯源存储了状态变化的事件序列。每当业务实体的状态发生变化时，就会将一个新事件追加到与该实体相关的事件列表中。这个事件序列作为主要真相来源，可以用来重建实体的过去状态。让我们更详细地看看：'
- en: '**Use case**: Imagine a banking application that requires a robust mechanism
    for tracking the movement of funds between accounts, ensuring compliance with
    auditing standards, and the ability to revert or reconstruct account states during
    disputes or investigations.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**: 想象一个需要强大机制来跟踪账户间资金流动、确保符合审计标准，并在争议或调查期间能够回滚或重建账户状态的银行应用程序。'
- en: '**Implementation details**: Let’s look at this diagram:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现细节**: 让我们看看这个图：'
- en: '![Figure 8.5: The Event Sourcing pattern](img/B20937_08_05.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：事件溯源模式](img/B20937_08_05.jpg)'
- en: 'Figure 8.5: The Event Sourcing pattern'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：事件溯源模式
- en: '*Figure 8**.5* illustrates the Event Sourcing pattern in software architecture
    using a horizontal multi-level layout. Here’s a description of its components
    and flow:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.5*使用水平多级布局展示了软件架构中的事件溯源模式。以下是其组件和流程的描述：'
- en: '**Client**: Initiates the process by sending commands to the system'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**: 通过向系统发送命令来启动流程'
- en: '**Command handler**: Receives commands from the client and processes them;
    generates events based on the commands received'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令处理器**: 接收来自客户端的命令并处理它们；根据接收到的命令生成事件'
- en: '**Event store**: Captures and stores these events; this storage acts as the
    authoritative source of truth about the state of the system'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件存储**: 捕获并存储这些事件；此存储作为系统状态的权威真相来源'
- en: '**Event bus**: Distributes the stored events to appropriate handlers'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件总线**: 将存储的事件分发到适当的处理器'
- en: '**Event handlers**: React to the events by processing them and potentially
    generating new events or commands'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理器**: 通过处理事件并可能生成新事件或命令来响应事件'
- en: '**Projections**: Update the read models based on the events processed by the
    event handlers'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影**: 根据事件处理器处理的事件更新读取模型'
- en: '**Read models**: Provide the updated state of the system back to the client
    based on the projections'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取模型**: 根据投影向客户端提供系统的更新状态'
- en: '**Client**: May query the read models to retrieve the current state or results
    of operations'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**: 可以查询读取模型以检索当前状态或操作结果'
- en: The Event sourcing pattern allows the system to maintain a full historical record
    of state changes, which is crucial for auditing and compliance. It also supports
    scalability by decoupling command processing from state storage and enabling asynchronous
    event processing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源模式允许系统维护状态变化的完整历史记录，这对于审计和合规至关重要。它还通过解耦命令处理与状态存储以及启用异步事件处理来支持可扩展性。
- en: API versioning
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API版本控制
- en: '**API versioning** is a strategy employed to manage changes to an API. It allows
    for new features and changes without disrupting the existing user experience or
    requiring clients to make immediate upgrades. This approach is particularly crucial
    when introducing breaking changes that would otherwise compromise backward compatibility.
    Here’s a more detailed look:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**API版本控制**是一种用于管理API更改的策略。它允许在不干扰现有用户体验或要求客户端立即升级的情况下添加新功能或进行更改。这种方法在引入会破坏向后兼容性的破坏性更改时尤其重要。以下是更详细的说明：'
- en: '**Use case**: Imagine a scenario where a financial services API needs to add
    new fields to a response object that could disrupt existing client applications.
    By introducing a new version of the API, the service can provide these enhancements
    while still supporting the older version, ensuring that existing applications
    continue to function without modification until they opt to upgrade.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：想象一个场景，金融服务 API 需要向响应对象添加新字段，这可能会破坏现有的客户端应用程序。通过引入 API 的新版本，服务可以在支持旧版本的同时提供这些增强功能，确保现有应用程序在它们选择升级之前无需修改即可继续运行。'
- en: '`/api/v1/users` for the first version and `/api/v2/users` for the second version.
    This method is transparent and easy to understand.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一版使用 `/api/v1/users`，第二版使用 `/api/v2/users`。这种方法透明且易于理解。
- en: '`GET /api/users?version=1`. This keeps the URI clean and allows for more flexibility
    but can be less intuitive.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/users?version=1`。这保持了 URI 的简洁性，并提供了更大的灵活性，但可能不太直观。'
- en: '`Accept:application/vnd.myapi.v1+json`. This approach is less obtrusive and
    separates versioning from the business logic of the API.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accept:application/vnd.myapi.v1+json`。这种方法不太侵入性，并将版本控制与 API 的业务逻辑分离。'
- en: 'Here’s a basic example of how to implement API versioning in a web application
    using Spring Boot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何在 Spring Boot 中实现 API 版本化的基本示例：
- en: '[PRE12]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, different versions of the same endpoint are triggered based
    on the custom `X-API-Version` request header. This allows clients to specify which
    version of the API they wish to interact with, enabling backward compatibility
    while new features are rolled out.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，根据自定义的 `X-API-Version` 请求头触发同一端点的不同版本。这允许客户端指定他们希望交互的 API 版本，在推出新功能的同时实现向后兼容。
- en: Saga pattern
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Saga pattern
- en: 'The **Saga pattern** is a valuable approach for managing data consistency across
    multiple microservices in distributed transactions. It provides a way to handle
    long-running business processes that span multiple services, ensuring that each
    step is executed successfully or compensated if an error occurs. Let’s find out
    more:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**Saga 模式**是一种在分布式事务中管理多个微服务数据一致性的宝贵方法。它提供了一种处理跨越多个服务、持续时间长的业务流程的方式，确保每个步骤都能成功执行，或者在发生错误时进行补偿。让我们了解更多：'
- en: '**Use case**: The Saga pattern excels in coordinating long-running microservice
    workflows where each step requires confirmation. This is ideal for scenarios such
    as order processing (inventory, payment, and shipping) or hotel booking (reservation,
    payment, and confirmation). It ensures that the entire process succeeds or is
    rolled back if a step fails.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：Saga 模式在协调需要确认的长期运行的微服务工作流方面表现出色。这适用于订单处理（库存、支付和发货）或酒店预订（预订、支付和确认）等场景。它确保整个过程成功，或者在某个步骤失败时回滚。'
- en: '**Implementation details**: Let’s look at *Figure 8**.6*.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现细节**：让我们看看*图8**.6*。'
- en: '![Figure 8.6: The Saga pattern](img/B20937_08_06.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：Saga 模式](img/B20937_08_06.jpg)'
- en: 'Figure 8.6: The Saga pattern'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：Saga 模式
- en: 'This activity diagram demonstrates the Saga pattern, showing the flow of a
    transaction with potential compensating actions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动图演示了 Saga 模式，显示了具有潜在补偿操作的交易流程：
- en: '**Start transaction**: The process begins'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始事务**：过程开始'
- en: '**Service 1**: The first service is called:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务1**：调用第一个服务：'
- en: If Service 1 succeeds, it proceeds to Service 2
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务1成功，则继续到服务2
- en: If Service 1 fails, it triggers Compensate 1 and returns to the start
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务1失败，则触发补偿1并返回到开始
- en: '**Service 2**: The second service is called:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务2**：调用第二个服务：'
- en: If Service 2 succeeds, it proceeds to Service 3
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务2成功，则继续到服务3
- en: If Service 2 fails, it triggers Compensate 2 and returns to Compensate 1
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务2失败，则触发补偿2并返回到补偿1
- en: '**Service 3**: The third service is called:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务3**：调用第三个服务：'
- en: If Service 3 succeeds, the transaction ends
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务3成功，则事务结束
- en: If Service 3 fails, it triggers Compensate 3 and returns to Compensate 2
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务3失败，则触发补偿3并返回到补偿2
- en: '**End transaction**: The process completes successfully'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束事务**：过程成功完成'
- en: Compensation steps are taken to revert to previous steps when a failure occurs,
    ensuring that the system maintains consistency
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生故障时，采取补偿步骤以回滚到之前的步骤，确保系统保持一致性
- en: The Saga pattern allows for the coordination of complex transactions across
    multiple microservices while maintaining loose coupling and independence between
    the services. Each service performs its own local transaction and publishes events
    to trigger the next step in the Saga pattern. If any step fails, compensating
    actions are executed to roll back the previous steps, guaranteeing eventual consistency.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Saga模式允许在多个微服务之间协调复杂事务，同时保持服务之间的松散耦合和独立性。每个服务执行自己的本地事务并发布事件以触发Saga模式中的下一步。如果任何步骤失败，将执行补偿操作以回滚之前的步骤，从而保证最终一致性。
- en: Database per service
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按服务数据库
- en: 'The **database per service** pattern is an architectural approach in which
    each microservice has its own dedicated database. Instead of sharing a single
    database across multiple services, each service owns and manages its own data
    store. This pattern promotes loose coupling, autonomy, and scalability in microservices
    architectures. Let’s take a closer look:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**按服务数据库**模式是一种架构方法，其中每个微服务都有自己的专用数据库。而不是在多个服务之间共享单个数据库，每个服务都拥有并管理自己的数据存储。这种模式促进了微服务架构中的松散耦合、自主性和可伸缩性。让我们更详细地看看：'
- en: '**Use case**: The Database per service pattern thrives when microservices have
    diverse data requirements. It empowers each service to leverage the most suitable
    database technology, optimize data models and queries, and scale independently
    based on its specific load. This approach fosters polyglot persistence and ensures
    strict data isolation, making it ideal for multi-tenant architectures and compliance-driven
    scenarios.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：当微服务具有不同的数据需求时，数据库按服务模式表现得尤为出色。它赋予每个服务利用最合适的数据库技术、优化数据模型和查询以及根据其特定负载独立扩展的能力。这种方法促进了多语言持久性并确保了严格的数据隔离，使其非常适合多租户架构和受合规性驱动的场景。'
- en: '**Implementation strategies**: Let’s look at *Figure 8**.7*:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现策略**：让我们看看**图8.7**：'
- en: '![Figure 8.7: The Database per service pattern](img/B20937_08_07.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：按服务数据库模式](img/B20937_08_07.jpg)'
- en: 'Figure 8.7: The Database per service pattern'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：按服务数据库模式
- en: 'This component diagram illustrates the *Database per service* architectural
    pattern, where each microservice operates with its own dedicated database. This
    design emphasizes loose coupling, autonomy, and scalability within a microservices
    architecture. Here’s a breakdown of the key components shown in the diagram:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件图展示了**按服务数据库**的架构模式，其中每个微服务都使用自己的专用数据库。这种设计强调在微服务架构中实现松散耦合、自主性和可伸缩性。以下是图中展示的关键组件的分解：
- en: '**Microservices (A, B, and C)**: Each microservice is shown with its respective
    database. For example, Microservice A uses Database A, Microservice B uses Database
    B, and Microservice C uses Database C. This design ensures that each microservice
    can operate independently, manage its own data store, and use a database technology
    that best suits its needs.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务（A、B和C）**：每个微服务都与其相应的数据库一起展示。例如，微服务A使用数据库A，微服务B使用数据库B，微服务C使用数据库C。这种设计确保每个微服务可以独立运行，管理自己的数据存储，并使用最适合其需求的数据库技术。'
- en: '**API Gateway**: The API Gateway acts as an intermediary that external clients
    interact with. It abstracts the underlying microservices and provides a single
    point of entry into the system. Each microservice accesses the API Gateway, allowing
    for a simplified client interaction model and centralizing some cross-cutting
    concerns such as authentication and rate limiting.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：API网关充当外部客户端与之交互的中介。它抽象了底层的微服务并提供进入系统的单一入口点。每个微服务都通过API网关访问，从而简化了客户端交互模型并集中处理一些横切关注点，如身份验证和速率限制。'
- en: '**Service mesh**: The service mesh is represented as facilitating communication
    between the microservices, API Gateway, and external systems. It helps manage
    service-to-service communications, ensuring reliable data transfer, and implements
    resilience patterns such as retries and circuit breakers.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务网格**：服务网格表示促进微服务、API网关和外部系统之间的通信。它帮助管理服务间的通信，确保可靠的数据传输，并实现诸如重试和断路器等弹性模式。'
- en: '**Change Data Capture** (**CDC**): A note on CDC is included to indicate its
    role in the architecture. CDC tools such as Debezium can be used to capture changes
    in each microservice’s database and propagate these changes to other services
    or external systems. This setup supports maintaining eventual consistency across
    the distributed data stores.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更数据捕获**（**CDC**）：包含关于CDC的说明，以表明其在架构中的作用。可以使用如Debezium之类的CDC工具来捕获每个微服务数据库中的更改并将这些更改传播到其他服务或外部系统。这种设置支持在分布式数据存储中保持最终一致性。'
- en: '**Interactions**: The diagram shows the flow of data and interactions. Each
    microservice interacts with the API Gateway, which in turn communicates with the
    service mesh. The service mesh coordinates further interactions, potentially with
    external systems, and facilitates the implementation of CDC.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互**：该图显示了数据流和交互。每个微服务都与API网关交互，而API网关随后与服务网格通信。服务网格进一步协调交互，可能涉及外部系统，并促进CDC的实施。'
- en: This diagram effectively communicates the separation of concerns and the independence
    of each microservice within the system, highlighting the advantages of the Database
    per service pattern in supporting diverse data requirements and scalability.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此图有效地传达了关注点的分离以及系统内每个微服务的独立性，突出了数据库按服务模式在支持多样化的数据需求和可伸缩性方面的优势。
- en: Shared database pattern
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享数据库模式
- en: 'The **shared database pattern** is an architectural approach in which each
    microservice has its own dedicated database. Instead of sharing a single database
    across multiple services, each service owns and manages its data store. This pattern
    promotes loose coupling, autonomy, and scalability in microservices architectures:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享数据库模式**是一种架构方法，其中每个微服务都有自己的专用数据库。而不是在多个服务之间共享单个数据库，每个服务都拥有和管理自己的数据存储。这种模式促进了微服务架构中的松散耦合、自主性和可伸缩性：'
- en: '**Use case**: Shared databases excel in enterprises, real-time systems, and
    compliance-driven environments. They provide a single source of truth for organizations
    (e.g., customer data across sales, HR, and finance) and ensure consistent data
    for real-time applications. In regulated industries (such as finance and healthcare),
    they enforce compliance standards across services, simplifying audits. This pattern
    thrives where data consistency and integrity are paramount.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：共享数据库在企业、实时系统和受合规性驱动的环境中表现卓越。它们为组织提供单一的真实数据源（例如，销售、人力资源和财务中的客户数据）并确保实时应用的数据一致性。在受监管的行业（如金融和医疗保健）中，它们在服务中强制执行合规性标准，简化了审计。这种模式在数据一致性和完整性至关重要的地方蓬勃发展。'
- en: '**Implementation strategies**: Let’s look at *Figure 8**.8*:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施策略**：让我们看看*图 8.8*：'
- en: '![Figure 8.8: The shared database pattern](img/B20937_08_08.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8：共享数据库模式](img/B20937_08_08.jpg)'
- en: 'Figure 8.8: The shared database pattern'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：共享数据库模式
- en: 'The diagram represents the shared database pattern where multiple services
    (microservices A, B, and C) utilize a single, central database. This architecture
    is commonly adopted to maintain a unified source of truth across different parts
    of an organization, facilitating consistency and compliance in data management.
    Its key components include the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表示共享数据库模式，其中多个服务（微服务A、B和C）使用单个中央数据库。这种架构通常被采用以维护组织不同部分之间的统一数据源，促进数据管理的一致性和合规性。其关键组件包括以下内容：
- en: '**A shared database**: All microservices access this single database for both
    reading and writing operations. This setup ensures data consistency and simplifies
    transaction management across services.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享数据库**：所有微服务都通过此单一数据库进行读写操作。这种设置确保了数据一致性并简化了服务间的交易管理。'
- en: '**Microservices (A, B, and C)**: These services are independent in functionality
    but share the same database for data operations. They represent different business
    capabilities within the organization.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务（A、B和C）**：这些服务在功能上是独立的，但共享相同的数据库进行数据操作。它们代表了组织内的不同业务能力。'
- en: '**An API layer for access**: An API layer abstracts the database interactions
    from the services. This layer helps enforce security, manage access patterns,
    and ensure that changes to the database schema do not directly impact service
    operations.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问API层**：API层抽象了数据库交互从服务中。这一层有助于执行安全、管理访问模式并确保数据库模式的变化不会直接影响到服务操作。'
- en: '**Performance optimization**: This note suggests the use of strategies such
    as connection pooling, creating read replicas, and caching to optimize database
    performance and handle high loads efficiently.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：本节建议使用连接池、创建只读副本和缓存等策略来优化数据库性能并高效地处理高负载。'
- en: In Java, the implementation of these patterns can be supported by various frameworks
    and libraries that facilitate asynchronous programming and provide tools for building
    resilient microservices. By selecting the appropriate patterns for specific challenges,
    developers can craft robust, scalable, and efficient microservice architectures.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，这些模式的实现可以通过各种框架和库得到支持，这些框架和库促进了异步编程并提供构建健壮微服务的工具。通过为特定挑战选择合适的模式，开发者可以构建强大、可扩展和高效的微服务架构。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored microservices in the cloud, as well as how Java’s
    concurrency tools can be leveraged to build and manage these services effectively.
    We discussed the principles of microservices, their advantages over monolithic
    architectures, and their integration into cloud environments. The key characteristics
    of microservices, such as modularity and loose coupling, were examined, highlighting
    their contribution to building resilient and scalable systems.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了云中的微服务，以及如何利用Java的并发工具有效地构建和管理这些服务。我们讨论了微服务的原则、它们相对于单体架构的优势以及它们在云环境中的集成。还考察了微服务的关键特征，如模块化和松散耦合，突出了它们在构建弹性和可扩展系统方面的贡献。
- en: To develop high-performance microservices, we delved into Java’s concurrency
    essentials, including thread pools, parallel streams, and the Fork/Join framework.
    These tools enable developers to incorporate parallel processing and efficient
    task management techniques, thus optimizing microservice performance.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发高性能的微服务，我们深入探讨了Java的并发基础，包括线程池、并行流和Fork/Join框架。这些工具使开发者能够融入并行处理和高效的任务管理技术，从而优化微服务的性能。
- en: We also addressed potential bottlenecks and concurrency-related issues in microservices
    architectures, providing practical solutions using Java’s concurrent mechanisms.
    Strategies for ensuring smooth communication, data consistency, and resilience
    across services were also discussed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了微服务架构中可能出现的瓶颈和并发相关的问题，并提供了使用Java并发机制的实用解决方案。还讨论了确保服务间通信顺畅、数据一致性和弹性的策略。
- en: Best practices for designing, deploying, and scaling concurrent microservices
    in the cloud were covered, including load balancing, caching, and database management.
    Essential patterns for building resilient and fault-tolerant microservices, such
    as circuit breakers, bulkheads, and event-driven communication patterns, were
    explored.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖了在云中设计、部署和扩展并发微服务的最佳实践，包括负载均衡、缓存和数据库管理。探讨了构建健壮和容错微服务的基本模式，如断路器、隔离舱和事件驱动通信模式。
- en: Hands-on exercises and case studies demonstrated how to apply Java’s concurrency
    tools, best practices, and design patterns in real-world scenarios, allowing readers
    to gain practical experience in designing, deploying, and scaling concurrent microservices
    in the cloud.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实践练习和案例研究，展示了如何在现实场景中应用Java的并发工具、最佳实践和设计模式，使读者能够在设计、部署和扩展云中的并发微服务方面获得实践经验。
- en: As we conclude this chapter, readers should have a comprehensive understanding
    of creating scalable, resilient microservices using Java’s concurrency tools and
    design patterns in the cloud. They should be equipped with the knowledge and skills
    necessary to tackle the challenges of building high-performance, fault-tolerant
    microservices architectures.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，读者应该对使用Java的并发工具和设计模式在云中创建可扩展、健壮的微服务有一个全面的理解。他们应该具备解决构建高性能、容错微服务架构挑战所需的知识和技能。
- en: Looking ahead, the next chapter, *Serverless Computing and Java’s Concurrent
    Capabilities*, will explore how Java’s concurrency features can be utilized in
    serverless environments, providing insights and practical guidance on harnessing
    Java’s concurrency tools to build high-performance, event-driven serverless applications.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一章“无服务器计算和Java的并发能力”将探讨如何在无服务器环境中利用Java的并发特性，提供关于利用Java的并发工具构建高性能、事件驱动的无服务器应用的见解和实用指导。
- en: Questions
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a key advantage of microservices architecture over monolithic architecture?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与单体架构相比，微服务架构的关键优势是什么？
- en: Increased complexity and coupling
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加复杂性和耦合
- en: Reduced flexibility and scalability
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 降低灵活性和可伸缩性
- en: Independent deployment and scalability
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立部署和可伸缩性
- en: Single point of failure
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单点故障
- en: Which Java feature is essential for managing asynchronous tasks within microservices?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Java特性对于在微服务中管理异步任务是必不可少的？
- en: '**Java Virtual** **Machine** (**JVM**)'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java虚拟** **机** （**JVM**）'
- en: '**Java Database** **Connectivity** (**JDBC**)'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java数据库** **连接** （**JDBC**）'
- en: CompletableFuture
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CompletableFuture
- en: JavaBeans
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaBeans
- en: What is the primary role of a load balancer in a microservices architecture?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务架构中，负载均衡器的主要角色是什么？
- en: Encrypting data transfers
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密数据传输
- en: Distributing incoming network traffic across multiple instances
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多个实例之间分配传入的网络流量
- en: Data storage and management
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据存储和管理
- en: Error logging and handling
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误日志记录和处理
- en: Which pattern helps prevent a network or service failure from cascading to other
    parts of the system in microservices?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模式有助于防止网络或服务故障在微服务中级联到系统的其他部分？
- en: Singleton pattern
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Factory pattern
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Circuit breaker pattern
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断路器模式
- en: Builder pattern
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造者模式
- en: Which best practice is recommended when implementing microservices in the cloud
    for handling data consistency?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在云中实现微服务时，处理数据一致性的最佳实践是哪一个？
- en: Using a single shared database for all services
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单个共享数据库为所有服务
- en: Employing different caching strategies for each microservice
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个微服务采用不同的缓存策略
- en: Assigning a separate managed database instance for each microservice
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个微服务分配一个单独的托管数据库实例
- en: Centralizing all data management in one microservice
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有数据管理集中在一个微服务中
