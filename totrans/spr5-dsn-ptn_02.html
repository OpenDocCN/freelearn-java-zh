<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Overview of GOF Design Patterns - Core Design Patterns</h1>
                </header>
            
            <article>
                
<p>In this chapter, you'll be given an overview of GOF Design Patterns, including some best practices for making an application design. You'll also get an overview of common problem--solving with design patterns.</p>
<p>I will explain the design patterns that are commonly used by the Spring Framework for better design and architecture. We are all in a global world, which means that if we have services in the market, they can be accessed across the Globe. Simply put, now is the age of the distributed computing system. So first, what is a distributed system? It's an application that is divided into smaller parts that run simultaneously on different computers and the smaller parts communicate over the network, generally using protocols. These smaller parts are called <strong>tiers</strong>. So if we want to create a distributed application, <em>n</em>-tier architecture is a better choice for that type of application. But developing an <em>n</em>-tier distributed application is a complex and challenging job. Distributing the processing into separate tiers leads to better resource utilization. It also support the allocation of tasks to experts who are best suited to work and develop a particular tier. Many challenges exist in developing distributed applications, some of which are detailed here:</p>
<ul>
<li>Integration between the tiers</li>
<li>Transaction management</li>
<li>Concurrency handling of enterprise data</li>
<li>Security of the application and so on</li>
</ul>
<p>So my focus in this book is on simplifying Java EE application design and development by applying patterns and best practices with the Spring Framework. In this book, I will cover some common GOF Design Patterns, and how Spring adopted these for providing the best solutions to the aforementioned listed problems of enterprise application because the design of distributed objects is an immensely complicated task, even for experienced professionals. You need to consider critical issues, such as scalability, performance, transactions, and so on, before drafting a final solution. That solution is described as a pattern.</p>
<p>At the end of this chapter, you will understand how design patterns provide the best solution to address any design-related and development-related issues, and how to start development with the best practices. Here, you will get more ideas about GOF Design Patterns, with real-life examples. You will get information about how the Spring Framework implements these design patterns internally to provide the best enterprise solution.</p>
<p>This chapter will cover the following points:</p>
<ul>
<li>Introducing the power of design patterns</li>
<li>Common GOF Design Patterns overview
<ul>
<li>Core <span>design patterns</span>
<ul>
<li>Creational <span>design patterns</span></li>
<li>Structural <span>design patterns</span></li>
<li>Behavioral <span>design patterns</span></li>
</ul>
</li>
<li>J2EE <span>design patterns</span>
<ul>
<li>Design patterns at presentation layer</li>
<li>Design patterns at business layer</li>
<li>Design patterns at integration layer</li>
</ul>
</li>
</ul>
</li>
<li>Some best practices for Spring application development</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the power of design patterns</h1>
                </header>
            
            <article>
                
<p>So what is a design pattern? Actually, the phrase design pattern is not associated with any programming language, and also it doesn't provide language-specific solutions to problems. A design pattern is associated with the solution to repetitive problems. For example, if any problem occurs frequently, a solution to that problem has been used effectively. Any non-reusable solution to a problem can't be considered a pattern, but the problem must occur frequently in order to have a reusable solution, and to be considered as a pattern. So a design pattern is a software engineering concept describing recurring solutions to common problems in software design. Design patterns also represent the best practices used by experienced object-oriented software developers.</p>
<p>When you make a design for an application, you should consider all the solutions to common problems, and these solutions are called <strong>design patterns</strong>. The understanding of design patterns must be good across the developer team so that the staff can communicate with each other effectively. In fact, you may be familiar with some design patterns; however, you may not have used well-known names to describe them. This book will take you through a step-by-step approach and show you examples that use Java while you learn design pattern concepts.</p>
<p>A design pattern has three main characteristics:</p>
<ul>
<li>A Design pattern is <em>specific to a particular scenario</em> rather than a specific platform. So its context is the surrounding condition under which the problem exists. The context must be documented within the pattern.</li>
<li>Design patterns have been <em>evolved to provide the best solutions</em> to certain problems faced during software development. So this should be limited by the context in which it is being considered.</li>
<li>Design patterns are <em>the remedy for the problems under consideration</em>.</li>
</ul>
<p>For example, if a developer is referring to the GOF Singleton design pattern and signifies the use of a single object, then all developers involved should understand that you need to design an object that will only have a single instance in the application. So the Singleton design pattern will be composed of a single object and the developers can tell each other that the program is following a Singleton pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common GoF Design Pattern overview</h1>
                </header>
            
            <article>
                
<p>The authors Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides are often referred to as the GoF, or Gang of Four. They published a book titled <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, which initiated the concept of design patterns in software development.</p>
<p>In this chapter, you will learn what GOF patterns are and how they help solve common problems encountered in object-oriented design.</p>
<p>The <strong>Gang of Four</strong> (<strong>GoF</strong>) patterns are 23 classic software design patterns providing recurring solutions to common problems in software design. The patterns are defined in the book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. These patterns are categorized into two main categories:</p>
<ul>
<li>Core Design Patterns</li>
<li>J2EE Design Patterns</li>
</ul>
<p>Furthermore, <strong>Core Design Patterns</strong> are also subdivided into three main categories of design pattern, as follows:</p>
<ul>
<li><strong>Creational Design Pattern</strong>: Patterns under this category provide a way to construct objects when constructors will not serve your purpose. The creation logic of objects is hidden. The programs based on these patterns are more flexible in deciding object creation according to your demands and your use cases for the application.</li>
<li><strong>Structural Design Pattern</strong>: Patterns under this category deal with the composition of classes or objects. In the enterprise application, there are two commonly used techniques for reusing functionality in object-oriented systems: one is class Inheritance and the other is the Object Composition Concept of inheritance. The Object Composition Concept of inheritance is used to compose interfaces and define ways to compose objects to obtain new functionalities.</li>
<li><strong>Behavioral Design Pattern</strong>: Patterns under this category, characterize the ways in which classes or objects interact and distribute responsibility. These design patterns are specifically concerned with communication between objects. The behavioral design pattern is used to control and reduce complicated application flow in the enterprise application.</li>
</ul>
<p>Now, let's look at the other category, the <strong>JEE Design patterns</strong>. This is the other main category of design patterns. Application design can be immensely simplified by applying Java EE design patterns. Java EE design patterns have been documented in Sun's Java Blueprints. These Java EE Design patterns provide time-tested solution guidelines and best practices for object interaction in the different layers of a Java EE application. These design patterns are specifically concerned with the following listed layers:</p>
<ul>
<li>Design pattern at the presentation layer</li>
<li>Design pattern at the business layer</li>
<li>Design pattern at the integration layer</li>
</ul>
<p>Let's explore creational design patterns in the upcoming section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creational design patterns</h1>
                </header>
            
            <article>
                
<p>Let's look at the underlying design patterns of this category and how Spring Framework adopts them to provide loose coupling between components and create and manage the lifecycle of Spring components. Creational design patterns are associated with the method of object creation. The creation logic of the object is hidden to the caller of this object.</p>
<p>We are all aware of how to create an object using the <kbd>new</kbd> keyword in Java, as follows:</p>
<pre>     Account account = new Account(); </pre>
<p>But this way is not suitable for some cases, because it is a hardcoded way of creating an object. It is also not a best practice to create an object because the object might be changed according to the nature of the program. Here, the creational design pattern provides the flexibility to create an object according to the nature of the program.</p>
<p>Now let's look at the different design patterns under this category.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Factory design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</em><br/>
- GOF Design Pattern</div>
<p>The Factory design pattern is a creational design pattern. The Factory design pattern is also known as the Factory method design pattern. According to this design pattern, you get an object of a class without exposing the underlying logic to the client. It assigns a new object to the caller by using a common interface or abstract class. This means that the design pattern hides the actual logic of the implementation of an object, how to create it, and which class to instantiate it in. So the client shouldn't worry about creating, managing, and destroying an object-the Factory pattern takes responsibility for these tasks. The Factory pattern is one of the most-used design patterns in Java.</p>
<p>Let's look at the benefits of the Factory pattern:</p>
<ul>
<li>The Factory pattern promotes loose coupling between collaborating components or classes by using interfaces rather than binding application-specific classes into the application code</li>
<li>Using this pattern, you can get an implementation of an object of classes that implement an interface, at runtime</li>
<li>The object life cycle is managed by the factory implemented by this pattern</li>
</ul>
<p>Now let's discuss some common problems where you should apply the Factory design pattern:</p>
<ul>
<li>This pattern removes the burden on the developer to create and manage the objects</li>
<li>This pattern removes the tight coupling between collaboration components because a component doesn't know what subclasses it will be required to create</li>
<li>Avoid hard code to create an object of the class</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Factory design pattern in Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring Framework transparently uses this Factory design pattern to implement Spring containers using <kbd>BeanFactory</kbd> and <kbd>ApplicationContext</kbd> interfaces. Spring's container works based on the Factory pattern to create spring beans for the Spring application and also manages the life cycle of every Spring bean. <kbd>BeanFactory</kbd> and <kbd>ApplicationContext</kbd> are factory interfaces, and Spring has lots of implementing classes. The <kbd>getBean()</kbd>method is the factory method that gives you Spring beans accordingly.</p>
<p>Let's see a sample implementation of the Factory design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the Factory design pattern</h1>
                </header>
            
            <article>
                
<p>There are two classes <kbd>SavingAccount</kbd> and <kbd>CurrentAccount</kbd> implementing an interface <kbd>Account</kbd>. So, you can create a <kbd>Factory</kbd> class with a method that takes one or more arguments and its return type is <kbd>Account</kbd>. This method is known as the Factory method because it creates the instances of either <kbd>CurrentAccount</kbd> or <kbd>SavingAccount</kbd>. The <kbd>Account</kbd> interface is used for loose coupling. So, according to the passed arguments in the factory method, it chooses which subclass to instantiate. This factory method will have the superclass as its return type:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="246" width="395" class=" image-border" src="assets/c60c9cd5-b79a-4a6b-9966-6afe4a68c056.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML Diagram for the Factory design pattern</div>
<p>Let's look at this design pattern in the following example. Here, I am going to create an <kbd>Account</kbd> interface and some concrete classes that implement the <kbd>Account</kbd> interface:</p>
<pre><span>    package com.packt.patterninspring.chapter2.factory;</span><br/>    public interface Account { 
      void accountType(); 
   } </pre>
<p>Now let's create <kbd>SavingAccount.java</kbd>, which will implement the <kbd>Account</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter2.factory; 
    public class SavingAccount implements Account{ 
      @Override 
      public void accountType() { 
         System.out.println("SAVING ACCOUNT"); 
      } 
    } </pre>
<p>Same with <kbd>CurrentAccount.java</kbd>, it will also implement the <kbd>Account</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter2.factory; 
    public class CurrentAccount implements Account { 
      @Override 
      public void accountType() { 
         System.out.println("CURRENT ACCOUNT"); 
      } 
    } </pre>
<p>A Factory class <kbd>AccountFactory</kbd> is now going to be defined. <kbd>AccountFactory</kbd> generates an object of the concrete class, either <kbd>SavingAccount</kbd> or <kbd>CurrentAccount,</kbd> based on the account type given as an argument to the Factory method:</p>
<p><kbd>AccountFactory.java</kbd> is a Factory to produce the <kbd>Account</kbd> type object:</p>
<pre>    package com.packt.patterninspring.chapter2.factory.pattern; 
    import com.packt.patterninspring.chapter2.factory.Account; 
    import com.packt.patterninspring.chapter2.factory.CurrentAccount; 
    import com.packt.patterninspring.chapter2.factory.SavingAccount; 
    public class AccountFactory { 
      final String CURRENT_ACCOUNT = "CURRENT"; 
      final String SAVING_ACCOUNT  = "SAVING"; 
      //use getAccount method to get object of type Account    
      //It is factory method for object of type Account 
      public Account getAccount(String accountType){   
         if(CURRENT_ACCOUNT.equals(accountType)) {   
               return new CurrentAccount();   
         }<br/>         else if(SAVING_ACCOUNT.equals(accountType)){   
               return new SavingAccount();   
         }    
         return null;   
      }   
    } </pre>
<p><kbd>FactoryPatternMain</kbd> is the main calling class of <kbd>AccountFactory</kbd> to get an <kbd>Account</kbd> object. It will pass an argument to the factory method that contains information of the account type, such as <kbd>SAVING</kbd> and <kbd>CURRENT</kbd>. <kbd>AccountFactory</kbd> returns the object of the type that you passed to the factory method.</p>
<p>Let's create a demo class <kbd>FactoryPatterMain.java</kbd> to test the factory method design pattern:</p>
<pre>    package com.packt.patterninspring.chapter2.factory.pattern; 
    import com.packt.patterninspring.chapter2.factory.Account; 
    public class FactoryPatterMain { 
      public static void main(String[] args) { 
         AccountFactory accountFactory = new AccountFactory(); 
         //get an object of SavingAccount and call its accountType()<br/>         method. 
         Account savingAccount = accountFactory.getAccount("SAVING"); 
         //call accountType method of SavingAccount 
         savingAccount.accountType(); 
         //get an object of CurrentAccount and call its accountType() <br/>         method. 
         Account currentAccount = accountFactory.getAccount("CURRENT"); 
         //call accountType method of CurrentAccount 
         currentAccount.accountType(); 
      } 
    } </pre>
<p>You can test this file and see the output on the console, which should look like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/52068e84-43ce-438a-ba1d-83ed3ed69890.png"/></div>
<p>Now that we've seen the Factory design pattern, let's turn to a different variant of it-the Abstract factory design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstract factory design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><em>Provide an interface for creating families of related or dependent objects without specifying their concrete cla</em>sses. - GOF Design Patterns</div>
<p>The Abstract Factory pattern comes under the creational design pattern. It is a high-level design pattern compared to the factory method design pattern. According to this design pattern, you just define an interface or abstract class to create a related dependent object without specifying its concrete subclass. So here, the abstract factory returns a factory of classes. Let me simplify it for you. You have a set of factory method design patterns, and you just put these factories under a factory using the factory design pattern, which means that it is simply a factory of factories. And there is no need to take the knowledge about all of the factories into the factory--you can make your program using a top-level factory.</p>
<p>In the Abstract Factory pattern, an interface is responsible for creating a factory of related objects without explicitly specifying their classes. Each generated factory can give the objects as per the Factory pattern.</p>
<p>The benefits of the Abstract Factory pattern are as follows:</p>
<ul>
<li>The Abstract Factory Design provides loose coupling between the component families. It also isolates the client code from concrete classes.</li>
<li>This design pattern is a higher-level design than the Factory pattern.</li>
<li>This pattern provides better consistency at construction time of objects across the application.</li>
<li>This pattern easily swaps component families.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common problems where you should apply the Abstract factory design pattern</h1>
                </header>
            
            <article>
                
<p>When you design a Factory pattern for object creation in your application, there are times when you want a particular set of related objects to be created with certain constraints and apply the desired logic across the related objects in your application. You can achieve this design by creating another factory inside the factory for a set of related objects and apply the required constraints. You can also program the logic to a set of related objects.</p>
<p>When you want to customize the instantiation logic of related objects, then you could use this design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Abstract factory design pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>In the Spring Framework, the <kbd>FactoryBean</kbd> interface is based on the Abstract Factory design pattern. Spring provides a lot of implementation of this interface, such as <kbd>ProxyFactoryBean</kbd>, <kbd>JndiFactoryBean</kbd>, <kbd>LocalSessionFactoryBean</kbd>, <kbd>LocalContainerEntityManagerFactoryBean</kbd>, and so on. A <kbd>FactoryBean</kbd> is also useful to help Spring construct objects that it couldn't easily construct itself. Often this is used to construct complex objects that have many dependencies. It might also be used when the construction logic itself is highly volatile and depends on the configuration.</p>
<p>For example, in Spring Framework, one of the <kbd>FactoryBean</kbd> implementations is <kbd>LocalSessionFactoryBean</kbd>, which is used to get a reference of a bean that was associated with the hibernate configuration. It is a specific configuration concerning the data source. It should be applied before you get an object of <kbd>SessionFactory</kbd>. You can use the <kbd>LocalSessionFactoryBean</kbd> to apply the specific data source configuration in a consistent way. You may inject the result of a FactoryBean's <kbd>getObject()</kbd> method into any other property.</p>
<p>Let's create a sample implementation of the Abstract Factory design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the Abstract Factory design pattern</h1>
                </header>
            
            <article>
                
<p>I am going to create a <kbd>Bank</kbd> and <kbd>Account</kbd> interface and some concrete classes implementing these interfaces. Here, I also create an abstract factory class, <kbd>AbstractFactory</kbd>. I have some factory classes, <kbd>BankFactory</kbd> and <kbd>AccountFactory;</kbd> these classes extend the <kbd>AbstractFactory</kbd> class. I will also create a <kbd>FactoryProducer</kbd> class to create the factories.</p>
<p>Let's see this design pattern in the following image:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/d8d85280-efd6-4c84-8214-3744f7296304.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML diagram for the Abstract Factory design pattern</div>
<p>Create a demo class, <kbd>AbstractFactoryPatternMain</kbd>; it uses <kbd>FactoryProducer</kbd> to get an <kbd>AbstractFactory</kbd> object. Here, I pass information such as <kbd>ICICI</kbd>, <kbd>YES</kbd> to <kbd>AbstractFactory</kbd> to get an object of <kbd>Bank</kbd>, and I also pass information such as <kbd>SAVING</kbd>, <kbd>CURRENT</kbd> to <kbd>AbstractFactory</kbd> to get an <kbd>Account</kbd> type.</p>
<p>Here is the code for <kbd>Bank.java</kbd>, which is an interface:</p>
<pre>    package com.packt.patterninspring.chapter2.model; 
    public interface Bank { 
      void bankName(); 
    } </pre>
<p>Now let's create <kbd>ICICIBank.java</kbd>, which implements the <kbd>Bank</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter2.model; 
    public class ICICIBank implements Bank { 
      @Override 
      public void bankName() { 
        System.out.println("ICICI Bank Ltd."); 
      } 
    } </pre>
<p>Let's create another <kbd>YesBank.java</kbd>, an implementing <kbd>Bank</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter2.model; 
    public class YesBank implements Bank{ 
      @Override 
      public void bankName() { 
         System.out.println("Yes Bank Pvt. Ltd."); 
      } 
   } </pre>
<p>In this example, I am using the same interface and implementing classes of <kbd>Account</kbd> as I used in the Factory pattern example in this book.</p>
<p><kbd>AbstractFactory.java</kbd> is an abstract class that is used to get factories for <kbd>Bank</kbd> and <kbd>Account</kbd> objects:</p>
<pre>    package com.packt.patterninspring.chapter2.abstractfactory.pattern; 
    import com.packt.patterninspring.chapter2.model.Account; 
    import com.packt.patterninspring.chapter2.model.Bank; 
    public abstract class AbstractFactory { 
      abstract Bank getBank(String bankName); 
      abstract Account getAccount(String accountType); 
    } </pre>
<p><kbd>BankFactory.java</kbd> is a factory class extending <kbd>AbstractFactory</kbd> to generate an object of the concrete class based on the given information:</p>
<pre>    package com.packt.patterninspring.chapter2.abstractfactory.pattern; 
    import com.packt.patterninspring.chapter2.model.Account; 
    import com.packt.patterninspring.chapter2.model.Bank; 
    import com.packt.patterninspring.chapter2.model.ICICIBank; 
    import com.packt.patterninspring.chapter2.model.YesBank; 
    public class BankFactory extends AbstractFactory { 
      final String ICICI_BANK = "ICICI"; 
      final String YES_BANK   = "YES"; 
      //use getBank method to get object of name bank    
      //It is factory method for object of name bank 
      @Override 
      Bank getBank(String bankName) { 
         if(ICICI_BANK.equalsIgnoreCase(bankName)){   
               return new ICICIBank();   
         } <br/>         else if(YES_BANK.equalsIgnoreCase(bankName)){   
               return new YesBank();   
         }   
         return null; 
      } 
      @Override 
      Account getAccount(String accountType) { 
         return null; 
      } 
    } </pre>
<p><kbd>AccountFactory.java</kbd> is a factory class that extends <kbd>AbstractFactory.java</kbd> to generate an object of the concrete class based on the given information:</p>
<pre>     package com.packt.patterninspring.chapter2.abstractfactory.pattern; 
     import com.packt.patterninspring.chapter2.model.Account; 
     import com.packt.patterninspring.chapter2.model.Bank; 
     import com.packt.patterninspring.chapter2.model.CurrentAccount; 
     import com.packt.patterninspring.chapter2.model.SavingAccount; 
     public class AccountFactory extends AbstractFactory { 
       final String CURRENT_ACCOUNT = "CURRENT"; 
       final String SAVING_ACCOUNT  = "SAVING"; 
       @Override 
       Bank getBank(String bankName) { 
          return null; 
      } 
      //use getAccount method to get object of type Account    
      //It is factory method for object of type Account 
      @Override 
      public Account getAccount(String accountType){   
        if(CURRENT_ACCOUNT.equals(accountType)) {   
               return new CurrentAccount();   
        }<br/>        else if(SAVING_ACCOUNT.equals(accountType)){   
               return new SavingAccount();   
        }    
        return null;   
      } 
    } </pre>
<p><kbd>FactoryProducer.java</kbd> is a class that creates a Factory generator class to get factories by passing a piece of information, such as <kbd>Bank</kbd> or <kbd>Account</kbd>:</p>
<pre>    package com.packt.patterninspring.chapter2.abstractfactory.pattern; 
    public class FactoryProducer { 
      final static String BANK    = "BANK"; 
      final static String ACCOUNT = "ACCOUNT"; 
      public static AbstractFactory getFactory(String factory){ 
         if(BANK.equalsIgnoreCase(factory)){ 
               return new BankFactory(); 
         }<br/>         else if(ACCOUNT.equalsIgnoreCase(factory)){ 
               return new AccountFactory(); 
         } 
         return null; 
       } 
    } </pre>
<p><kbd>FactoryPatterMain.java</kbd> is a demo class for the Abstract Factory design pattern. <kbd>FactoryProducer</kbd> is a class to get <kbd>AbstractFactory</kbd> in order to get the factories of concrete classes by passing a piece of information, such as the type:</p>
<pre>    package com.packt.patterninspring.chapter2.factory.pattern; 
    import com.packt.patterninspring.chapter2.model.Account; 
    public class FactoryPatterMain { 
      public static void main(String[] args) { 
         AccountFactory accountFactory = new AccountFactory(); 
         //get an object of SavingAccount and call its accountType() <br/>         method. 
         Account savingAccount = accountFactory.getAccount("SAVING"); 
         //call accountType method of SavingAccount 
         savingAccount.accountType(); 
         //get an object of CurrentAccount and call its accountType() <br/>         method. 
         Account currentAccount = accountFactory.getAccount("CURRENT"); 
         //call accountType method of CurrentAccount 
         currentAccount.accountType(); 
      } 
    } </pre>
<p>You can test this file and see the output on the console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/56f08c15-3ef2-4bd2-9384-e04bfe2e1058.png"/></div>
<p>Now that we've seen the abstract Factory design pattern, let's turn to a different variant of it-the singleton design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><em>Ensure a class has only one instance and provide a global point of access to it - GOF Design Patterns</em></div>
<p>The Singleton pattern is a creational design pattern, it is one of the simplest design patterns in Java. According to the singleton design pattern, the class provides the same single object for each call--that is, it is restricting the instantiation of a class to one object and provides a global point of access to that class. So the class is responsible for creating an object and also ensures that only a single object should be created for each client call for this object. This class doesn't allow a direct instantiation of an object of this class. It allows you to get an object instance only by an exposed static method.</p>
<p>This is useful when exactly one object is needed to coordinate actions across the system. You can create a single pattern using two forms, as listed here:</p>
<ul>
<li><strong>Early instantiation</strong>: Creation of instance at load time</li>
<li><strong>Lazy instantiation</strong>: Creation of instance when required</li>
</ul>
<p><strong>Benefits of the Singleton pattern:</strong></p>
<ul>
<li>It provides controller access to crucial (usually heavy object) classes, such as the connection class for DB and the <kbd>SessionFactory</kbd> class in hibernate</li>
<li>It saves heaps of memory</li>
<li>It is a very efficient design for multithreaded environments</li>
<li>It is more flexible because the class controls the instantiation process, and the class has the flexibility to change the instantiation process</li>
<li>It has low latency</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common problems where you should apply Singleton pattern</h1>
                </header>
            
            <article>
                
<p>The Singleton pattern solves only one problem--if you have a resource that can only have a single instance, and you need to manage that single instance, then you need a singleton. Normally, if you want to create a database connection with the given configuration in the distributed and multithread environment, it might be the case that every thread can create a new database connection with a different configuration object, if you don't follow the singleton design. With the Singleton pattern, each thread gets the same database connection object with the same configuration object across the system. It is mostly used in multithreaded and database applications. It is used in logging, caching, thread pools, configuration settings, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton design pattern implementation in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>The Spring Framework provides a Singleton scoped bean as a singleton pattern. It is similar to the singleton pattern, but it's not exactly the same as the Singleton pattern in Java. According to the Singleton pattern, a scoped bean in the Spring Framework means a single bean instance per container and per bean. If you define one bean for a particular class in a single Spring container, then the Spring container creates one and only one instance of the class defined by that bean definition.</p>
<p>Let's create a sample application of the singleton design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the Singleton design pattern</h1>
                </header>
            
            <article>
                
<p>In the following code example, I will be creating a class with a method to create an instance of this class if one does not exist. If the instance is already present, then it will simply return the reference of that object. I have also taken thread safety into consideration, and so I have used a synchronized block here before creating the object of that class.</p>
<p>Let's check out the UML diagram for the Singleton design pattern:</p>
<pre>    package com.packt.patterninspring.chapter2.singleton.pattern; 
    public class SingletonClass { 
      private static SingletonClass instance = null; 
      private SingletonClass() { 
      } 
      public static SingletonClass getInstance() { 
        if (instance == null) { 
          synchronized(SingletonClass.class){   
               if (instance == null) { 
                  instance = new SingletonClass(); 
               } 
          } 
        } 
       return instance; 
      } 
    } 
  } </pre>
<p>One thing to be noted in the preceding code is that I have written a private constructor of the <kbd>SingletonClass</kbd> class to make sure that there is no way to create the object of that class. This example is based on lazy initialization, which means that the program creates an instance on demand the first time. So you could also eagerly instantiate the object to improve the runtime performance of your application. Let's see the same <kbd>SingletonClass</kbd> with eager initialization:</p>
<pre>    package com.packt.patterninspring.chapter2.singleton.pattern; 
    public class SingletonClass { 
      private static final SingletonClass INSTANCE = <br/>         new SingletonClass(); 
      private SingletonClass() {} 
      public static SingletonClass getInstance() { 
        return INSTANCE; 
      } 
    } </pre>
<p>Now that we've seen the singleton design pattern, let's turn to a different variant of it--the Prototype design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prototype design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><em>Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype.</em> - GOF Design Patterns</div>
<p>The Prototype pattern comes under the creational design pattern family of GOF patterns in software development. This pattern is used to create the objects by using a clone method of objects. It is determined by a prototypical instance. In the enterprise application, object creation is costly in terms of creating and initializing the initial properties of objects. If such a type of object is already in your hand, then you go for the prototype pattern; you just copy an existing similar object instead of creating it, which is time-consuming.</p>
<p>This pattern involves implementing a prototype interface, it creates a clone of the current object. This pattern is used when the direct creation of the object is costly. For example, say that an object is to be created after a costly database operation. We can cache the object, returns its clone on the next request, and update the database as and when it is needed, thus reducing database calls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of the Prototype design pattern</h1>
                </header>
            
            <article>
                
<p>The following list shows the benefits of using the Prototype pattern:</p>
<ul>
<li>Reduces the time to create the time-consuming objects by using the prototype pattern</li>
<li>This pattern reduces subclassing</li>
<li>This pattern adds and removes objects at runtime</li>
<li>This pattern configures the application with classes dynamically</li>
</ul>
<p>Let's see the UML class structure of the Prototype design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UML class structure</h1>
                </header>
            
            <article>
                
<p>The following UML diagram shows all the components of the Prototype design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/7d707f1e-6cb1-491f-9ac8-aa3b634fb6ad.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML diagram for Prototype design pattern</div>
<p>Let's see these components as listed in following points:</p>
<ul>
<li><strong>Prototype</strong>: The Prototype is an interface. It is uses the clone method to create instances of this interface type.</li>
</ul>
<ul>
<li><strong>ConcretePrototype</strong>: This is a concrete class of the Prototype interface to implement an operation to clone itself.</li>
</ul>
<ul>
<li><strong>Client</strong>: This is a <kbd>caller</kbd> class to create a new object of a Prototype interface by calling a <kbd>clone</kbd> method of the prototype interface.</li>
</ul>
<p>Let's see a sample implementation of the prototype design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the Prototype design pattern</h1>
                </header>
            
            <article>
                
<p>I am going to create an abstract <kbd>Account</kbd> class and concrete classes extending the <kbd>Account</kbd> class. An <kbd>AccountCache</kbd> class is defined as a next step, which stores account objects in a <kbd>HashMap</kbd> and returns their clone when requested. Create an abstract class implementing the <kbd>Clonable</kbd> interface.</p>
<pre>    package com.packt.patterninspring.chapter2.prototype.pattern;<br/>    public abstract class Account implements Cloneable{<br/>      abstract public void accountType();<br/>      public Object clone() {<br/>        Object clone = null;<br/>        try {<br/>          clone = super.clone();<br/>        }<br/>        catch (CloneNotSupportedException e) {<br/>          e.printStackTrace();<br/>        }<br/>        return clone;<br/>      }<br/>    }</pre>
<p>Now let's create concrete classes extending the preceding class:</p>
<p>Here's the <kbd>CurrentAccount.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter2.prototype.pattern;<br/>    public class CurrentAccount extends Account {<br/>      @Override<br/>      public void accountType() {<br/>        System.out.println("CURRENT ACCOUNT");<br/>      }<br/>    }</pre>
<p>Here's how <kbd>SavingAccount.java</kbd> should look:</p>
<pre>    package com.packt.patterninspring.chapter2.prototype.pattern;<br/>    public class SavingAccount extends Account{<br/>      @Override<br/>      public void accountType() {<br/>        System.out.println("SAVING ACCOUNT");<br/>      }<br/>    }</pre>
<p>Let's create a class to get concrete classes in the <kbd>AccountCache.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter2.prototype.pattern;<br/>    import java.util.HashMap;<br/>    import java.util.Map;<br/>    public class AccountCache {<br/>       public static Map&lt;String, Account&gt; accountCacheMap =<br/>           new HashMap&lt;&gt;();<br/>       static{<br/>         Account currentAccount = new CurrentAccount();<br/>         Account savingAccount = new SavingAccount();<br/>         accountCacheMap.put("SAVING", savingAccount);<br/>         accountCacheMap.put("CURRENT", currentAccount);<br/>       }<br/>     }</pre>
<p><kbd>PrototypePatternMain.java</kbd> is a demo class that we will use to test the design pattern <kbd>AccountCache</kbd> to get the <kbd>Account</kbd> object by passing a piece of information, such as the type, and then call the <kbd>clone()</kbd> method:</p>
<pre>    package com.packt.patterninspring.chapter2.prototype<br/>         .pattern;<br/>    public class PrototypePatternMain {<br/>      public static void main(String[] args) {<br/>        Account currentAccount = (Account) <br/>          AccountCache.accountCacheMap.get("CURRENT").clone();<br/>       currentAccount.accountType();<br/>       Account savingAccount = (Account) <br/>         AccountCache.accountCacheMap.get("SAVING") .clone();<br/>       savingAccount.accountType();<br/>     }<br/>   }</pre>
<p>We've covered this so far and it's good. Now let's look at the next design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Builder design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><em>Separate the construction of a complex object from its representation so that the same construction process can create different representations.</em> - GOF Design Patterns</div>
<p>The Builder design pattern is used to construct a complex object step by step, and finally it will return the complete object. The logic and process of object creation should be generic so that you can use it to create different concrete implementations of the same object type. This pattern simplifies the construction of complex objects and it hides the details of the object's construction from the client caller code. When you are using this pattern, remember you have to build it one step at a time, which means you have to break the object construction login into multiple phases, unlike other patterns, such as the abstract factory and the factory method pattern, which the object in a single step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of the Builder pattern:</h1>
                </header>
            
            <article>
                
<ul>
<li>This pattern provides you with complete isolation between the construction and representation of an object</li>
<li>This pattern allows you to construct the object in multiple phases, so you have greater control over the construction process</li>
<li>This pattern provides the flexibility to vary an object's internal representation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UML class structure</h1>
                </header>
            
            <article>
                
<p>The following UML diagram shows all the components of the Builder design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a88351cd-892f-4c63-911c-940c09fe227e.png"/></div>
<p>UML diagram for the Builder design pattern:</p>
<ul>
<li><strong>Builder</strong> (AccountBuilder): This is an abstract class or interface <span>for creating the details of an Account object.</span></li>
</ul>
<ul>
<li><strong>ConcreteBuilder</strong>: This is an implementation to construct and assemble details of the account by implementing the Builder interface.</li>
</ul>
<ul>
<li><strong>Director</strong>: This constructs an object using the Builder interface.</li>
</ul>
<ul>
<li><strong>Product</strong> (Account): This represents the complex object under construction. <kbd>AccountBuilder</kbd> <span>builds the account's internal representation and defines the process by which it's assembled.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Builder pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>The Spring Framework implements the Builder design pattern transparently in some functionalities. The following classes are based on the Builder design pattern in the Spring Framework:</p>
<ul>
<li><kbd>EmbeddedDatabaseBuilder</kbd></li>
<li><kbd>AuthenticationManagerBuilder</kbd></li>
<li><kbd>UriComponentsBuilder</kbd></li>
<li><kbd>BeanDefinitionBuilder</kbd></li>
<li><kbd>MockMvcWebClientBuilder</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common problems where you should apply Builder pattern</h1>
                </header>
            
            <article>
                
<p>In an enterprise application, you can apply the Builder pattern where the object creation has been done by using multiple steps. In each step, you do a portion of the process. In this process, you set some required parameters and some optional parameters, and after the final step, you will get a complex object.</p>
<p>The Builder pattern is an object creation software design pattern. The intention is to abstract the steps of construction so that different implementations of these steps can construct different representations of objects. Often, the Builder pattern is used to build products in accordance with the composite pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the Builder design pattern</h1>
                </header>
            
            <article>
                
<p>In the following code example, I am going to create an <kbd>Account</kbd> class that has <kbd>AccountBuilder</kbd> as an inner class. The <kbd>AccountBuilder</kbd> class has a method to create an instance of this class:</p>
<pre>    package com.packt.patterninspring.chapter2.builder.pattern; 
    public class Account { 
      private String accountName; 
      private Long accountNumber; 
      private String accountHolder; 
      private double balance; 
      private String type; 
      private double interest; 
      private Account(AccountBuilder accountBuilder) { 
         super(); 
         this.accountName = accountBuilder.accountName; 
         this.accountNumber = accountBuilder.accountNumber; 
         this.accountHolder = accountBuilder.accountHolder; 
         this.balance = accountBuilder.balance; 
         this.type = accountBuilder.type; 
         this.interest = accountBuilder.interest; 
      } 
      //setters and getters 
       public static class AccountBuilder { 
         private final String accountName; 
         private final Long accountNumber; 
         private final String accountHolder; 
         private double balance; 
         private String type; 
         private double interest; 
         public AccountBuilder(String accountName, <br/>            String accountHolder, Long accountNumber) { 
            this.accountName = accountName; 
            this.accountHolder = accountHolder; 
            this.accountNumber = accountNumber; 
         } 
         public AccountBuilder balance(double balance) { 
            this.balance = balance; 
            return this; 
         } 
         public AccountBuilder type(String type) { 
            this.type = type; 
            return this; 
         } 
         public AccountBuilder interest(double interest) { 
            this.interest = interest; 
            return this; 
         } 
         public Account build() { 
            Account user =  new Account(this); 
            return user; 
         } 
       } 
       public String toString() { 
       return "Account [accountName=" + accountName + ", <br/>          accountNumber=" + accountNumber + ", accountHolder=" 
          + accountHolder + ", balance=" + balance + ", type="<br/>          + type + ", interest=" + interest + "]"; 
       } 
    } </pre>
<p><kbd>AccountBuilderTest.java</kbd> is a demo class that we will use to test the design pattern. Let's look at how to build an <kbd>Account</kbd> object by passing the initial information to the object:</p>
<pre>     package com.packt.patterninspring.chapter2.builder.pattern; 
     public class AccountBuilderTest { 
       public static void main(String[] args) { 
         Account account = new Account.AccountBuilder("Saving<br/>            Account", "Dinesh Rajput", 1111l) 
              .balance(38458.32) 
              .interest(4.5) 
              .type("SAVING") 
              .build(); 
         System.out.println(account); 
       } 
     } </pre>
<p>You can test this file and see the output on the console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/68c90b98-5bfc-4f6e-bacd-6a7f75a4e268.png"/></div>
<p>Now, we've seen the Builder design pattern. In the upcoming <a href="bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml" target="_blank">Chapter 3</a>, <em>Consideration of Structural and Behavioural</em> <em>Patterns,</em> I will explore another part of the GOF Design Patterns family.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>After reading this chapter, the reader should now have a good idea about the overview of GOF creational design patterns and its best practices. I highlighted the problems that come from not using design patterns in enterprise application development, and how Spring solves these problems by using the creational design patterns and good practices in the application. In this chapter, I have mentioned only one of the Creational Design pattern categories out of the three main categories of the GOF Design Patterns. The Creational design pattern is used for the creation of object instances, and also applies constraints at the creation time in the enterprise application in a specific manner using the Factory, Abstract Factory, Builder, Prototype, and Singleton patterns. In the next chapter, we will look at the other categories of the GOF Design Patterns-the structural design pattern and the behavioral design pattern. The structural design pattern is used to design the structure of an enterprise application by dealing with the composition of classes or objects so that it reduces the application's complexity and improves the reusability and performance of the application. The Adapter Pattern, Bridge Pattern, Composite Pattern, Decorator Pattern, Facade Pattern, and Flyweight Pattern come under this category of the pattern. The Behavioral design pattern characterizes the ways in which classes or objects interact and distribute responsibility. The patterns that come under this category are specifically concerned with communication between objects. Let's move to complete the remaining GOF patterns in the next chapter.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>