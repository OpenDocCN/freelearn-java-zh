- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Introduction to Spring Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud 简介
- en: So far, we have seen how we can use Spring Boot to build microservices with
    well-documented APIs, along with Spring WebFlux and `springdoc-openapi`; persist
    data in MongoDB and SQL databases using Spring Data for MongoDB and JPA; build
    reactive microservices either as non-blocking APIs using Project Reactor or as
    event-driven asynchronous services using Spring Cloud Stream with RabbitMQ or
    Kafka, together with Docker; and manage and test a system landscape consisting
    of microservices, databases, and messaging systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用 Spring Boot 来构建具有良好文档的 API 的微服务，以及 Spring WebFlux 和 `springdoc-openapi`；使用
    Spring Data for MongoDB 和 JPA 在 MongoDB 和 SQL 数据库中持久化数据；构建响应式微服务，要么作为非阻塞 API 使用
    Project Reactor，要么作为使用 RabbitMQ 或 Kafka 的 Spring Cloud Stream 的事件驱动异步服务，同时结合 Docker；以及管理和测试由微服务、数据库和消息系统组成的系统景观。
- en: Now, it’s time to see how we can use **Spring Cloud** to make our services production-ready,
    that is, scalable, robust, configurable, secure, and resilient.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看我们如何使用 **Spring Cloud** 来使我们的服务达到生产就绪状态，即可扩展、健壮、可配置、安全且具有弹性。
- en: 'In this chapter, we will introduce you to how Spring Cloud can be used to implement
    the following design patterns from *Chapter 1*, *Introduction to Microservices*,
    in the *Design patterns for microservices* section:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍如何使用 Spring Cloud 来实现 *第 1 章*，*微服务简介*，在 *微服务设计模式* 部分中提到的以下设计模式：
- en: Service discovery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Edge server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: Centralized configuration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式配置
- en: Circuit breaker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器
- en: Distributed tracing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not contain any source code, and so no tools need to be installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含任何源代码，因此不需要安装任何工具。
- en: The evolution of Spring Cloud
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud 的演变
- en: 'In its initial 1.0 release in March 2015, Spring Cloud was mainly a wrapper
    around tools from Netflix OSS, which are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2015 年 3 月的初始 1.0 版本中，Spring Cloud 主要是对 Netflix OSS 工具的包装，具体如下：
- en: Netflix Eureka, a discovery server
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Eureka，一个发现服务器
- en: Netflix Ribbon, a client-side load balancer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Ribbon，一个客户端负载均衡器
- en: Netflix Zuul, an edge server
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Zuul，一个边缘服务器
- en: Netflix Hystrix, a circuit breaker
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Hystrix，一个电路断路器
- en: The initial release of Spring Cloud also contained a configuration server and
    integration with Spring Security that provided OAuth 2.0 protected APIs. In May
    2016, the Brixton release (v1.1) of Spring Cloud was made generally available.
    With the Brixton release, Spring Cloud got support for distributed tracing based
    on Spring Cloud Sleuth and Zipkin, which originated from Twitter. These initial
    Spring Cloud components could be used to implement the preceding design patterns.
    For more details, see [https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now](https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now)
    and [https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available](https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 的最初版本也包含了一个配置服务器以及与 Spring Security 的集成，提供了受 OAuth 2.0 保护的 API。2016
    年 5 月，Spring Cloud 的 Brixton 版本（v1.1）被公开发布。随着 Brixton 版本的发布，Spring Cloud 获得了基于
    Spring Cloud Sleuth 和 Zipkin 的分布式跟踪支持，这两者最初源于 Twitter。这些最初的 Spring Cloud 组件可以用来实现前面的设计模式。更多详情请参阅
    [https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now](https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now)
    和 [https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available](https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available)。
- en: 'Since its inception, Spring Cloud has grown considerably over the years and
    has added support for the following, among others:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Spring Cloud 诞生以来，经过多年的发展，它已经增加了对以下内容的支持，以及其他内容：
- en: Service discovery and centralized configuration based on HashiCorp Consul and
    Apache Zookeeper
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 HashiCorp Consul 和 Apache Zookeeper 的服务发现和集中式配置
- en: Event-driven microservices using Spring Cloud Stream
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Stream 的事件驱动微服务
- en: Cloud providers such as Microsoft Azure, Amazon Web Services, and Google Cloud
    Platform
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务提供商，如 Microsoft Azure、Amazon Web Services 和 Google Cloud Platform
- en: See [https://spring.io/projects/spring-cloud](https://spring.io/projects/spring-cloud)
    for a complete list of tools.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以获取完整工具列表：[https://spring.io/projects/spring-cloud](https://spring.io/projects/spring-cloud)
- en: Since the release of Spring Cloud Greenwich (v2.1) in January 2019, some of
    the Netflix tools mentioned previously have been placed in maintenance mode in
    Spring Cloud.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 2019 年 1 月 Spring Cloud Greenwich（v2.1）版本发布以来，之前提到的某些 Netflix 工具已被置于 Spring
    Cloud 的维护模式。
- en: 'The reason for this is a mixture of Netflix no longer adding new features to
    some of the tools and Spring Cloud adding better alternatives. The following replacements
    are recommended by the Spring Cloud project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是Netflix不再向某些工具添加新功能，而Spring Cloud添加了更好的替代方案。以下替代方案由Spring Cloud项目推荐：
- en: '| **Current component** | **Replaced by** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **当前组件** | **替代组件** |'
- en: '| Netflix Hystrix | Resilience4j |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Netflix Hystrix | Resilience4j |'
- en: '| Netflix Hystrix Dashboard/Netflix Turbine | Micrometer and monitoring system
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Netflix Hystrix Dashboard/Netflix Turbine | Micrometer和监控系统 |'
- en: '| Netflix Ribbon | Spring Cloud LoadBalancer |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Netflix Ribbon | Spring Cloud LoadBalancer |'
- en: '| Netflix Zuul | Spring Cloud Gateway |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Netflix Zuul | Spring Cloud Gateway |'
- en: 'Table 8.1: Spring Cloud tool replacements'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：Spring Cloud工具替代
- en: 'For more details, see:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多细节，请参阅：
- en: '[https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available](https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available](https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available)'
- en: '[https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status)'
- en: '[https://github.com/Netflix/ribbon#project-status-on-maintenance](https://github.com/Netflix/ribbon#project-status-on-maintenance)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix/ribbon#project-status-on-maintenance](https://github.com/Netflix/ribbon#project-status-on-maintenance)'
- en: With the release of Spring Cloud Ilford (v2020.0.0) in December 2020, the only
    remaining Netflix component in Spring Cloud is Netflix Eureka.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着2020年12月Spring Cloud Ilford（v2020.0.0）的发布，Spring Cloud中剩下的唯一Netflix组件是Netflix
    Eureka。
- en: Finally, together with Spring Boot 3, Spring Cloud Kilburn (v2022.0.0) was released
    in December 2022\. As already mentioned in *Chapter 2*, *Introduction to Spring
    Boot*, in the *News in Spring Boot 3.0* section, Spring Cloud Sleuth has been
    replaced by Micrometer Tracing to support distributed tracing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与Spring Boot 3一起，Spring Cloud Kilburn（v2022.0.0）于2022年12月发布。正如在*第2章*，*Spring
    Boot介绍*中的*Spring Boot 3.0新闻*部分所提到的，Spring Cloud Sleuth已被Micrometer Tracing取代以支持分布式跟踪。
- en: 'In this book, we will use the software components in the following table to
    implement the design patterns mentioned previously:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用以下表格中的软件组件来实现之前提到的设计模式：
- en: '| **Design pattern** | **Software component** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **设计模式** | **软件组件** |'
- en: '| Service discovery | Netflix Eureka and Spring Cloud LoadBalancer |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 服务发现 | Netflix Eureka和Spring Cloud LoadBalancer |'
- en: '| Edge server | Spring Cloud Gateway and Spring Security OAuth |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 边缘服务器 | Spring Cloud Gateway和Spring Security OAuth |'
- en: '| Centralized configuration | Spring Cloud Configuration Server |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 集中配置 | Spring Cloud Configuration Server |'
- en: '| Circuit breaker | Resilience4j |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 电路断路器 | Resilience4j |'
- en: '| Distributed tracing | Micrometer Tracing and Zipkin |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 分布式跟踪 | Micrometer Tracing和Zipkin |'
- en: 'Table 8.2: Software components by design pattern'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2：按设计模式划分的软件组件
- en: Now, let’s go through the design patterns and introduce the software components
    that will be used to implement them!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨设计模式，并介绍将用于实现它们的软件组件！
- en: Using Netflix Eureka for service discovery
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka进行服务发现
- en: Service discovery is probably the most important support function required to
    make a landscape of cooperating microservices production ready. As we already
    described in *Chapter 1*, *Introduction to Microservices*, in the *Service discovery*
    section, a service discovery service (or a *discovery service* as an abbreviation)
    can be used to keep track of existing microservices and their instances.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现可能是使协作微服务景观生产就绪所需的最重要支持功能。正如我们在*第1章*，*微服务介绍*中的*服务发现*部分所描述的，一个服务发现服务（或简称*发现服务*）可以用来跟踪现有的微服务和它们的实例。
- en: The first discovery service that Spring Cloud supported was *Netflix Eureka*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud最初支持的第一个发现服务是*Netflix Eureka*。
- en: We will use this in *Chapter 9*, *Adding Service Discovery Using Netflix Eureka*,
    along with aload balancer based on Spring Cloud LoadBalancer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第9章*，*使用Netflix Eureka添加服务发现*中用到它，以及一个基于Spring Cloud LoadBalancer的负载均衡器。
- en: We will see how easy it is to register microservices with Netflix Eureka when
    using Spring Cloud. We will also learn how a client can send HTTP requests, such
    as a call to a RESTful API, to one of the instances registered in Netflix Eureka.
    In addition, the chapter will cover how to scale up the number of instances of
    a microservice, and how requests to a microservice will be load-balanced over
    its available instances (based on, by default, round-robin scheduling).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到使用 Spring Cloud 时注册微服务是多么简单。我们还将学习客户端如何发送 HTTP 请求，例如调用 RESTful API，到 Netflix
    Eureka 中注册的实例之一。此外，本章还将涵盖如何增加微服务实例的数量，以及如何将请求负载均衡到微服务的可用实例上（默认情况下基于轮询调度）。
- en: 'The following screenshot demonstrates the web UI from Eureka, where we can
    see what microservices we have registered:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 Eureka 的网页界面，我们可以看到我们注册了哪些微服务：
- en: '![Graphical user interface, website  Description automatically generated](img/B19825_08_01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站，自动生成的描述](img/B19825_08_01.png)'
- en: 'Figure 8.1: Viewing microservices currently registered with Eureka'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：查看当前与 Eureka 注册的微服务
- en: From the preceding screenshot, we can see that the review service has three
    instances available, while the other three services only have one instance each.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，我们可以看到审查服务有三个可用实例，而其他三个服务每个只有一个实例。
- en: With Netflix Eureka introduced, let’s introduce how Spring Cloud can help to
    protect a microservices system landscape using an edge server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Netflix Eureka 的引入，让我们来看看 Spring Cloud 如何通过使用边缘服务器来帮助保护微服务系统架构。
- en: Using Spring Cloud Gateway as an edge server
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Gateway 作为边缘服务器
- en: Another very important support function is an edge server. As we already described
    in *Chapter 1*, *Introduction to Microservices*, in the *Edge server* section,
    it can be used to secure a microservice landscape, which involves hiding private
    services from external usage and protecting public services when they’re used
    by external clients.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的支持功能是边缘服务器。正如我们在 *第 1 章*，*微服务简介*，*边缘服务器* 部分所描述的，它可以用来保护微服务景观，这涉及到隐藏私有服务以防止外部使用，并在外部客户端使用时保护公共服务。
- en: Initially, Spring Cloud used Netflix Zuul v1 as its edge server. Since the Spring
    Cloud Greenwich release, it’s recommended to use **Spring Cloud Gateway** instead.
    Spring Cloud Gateway comes with similar support for critical features, such as
    URL path-based routing and the protection of endpoints via the use of **OAuth
    2.0** and **OpenID Connect** (**OIDC**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Spring Cloud 使用 Netflix Zuul v1 作为其边缘服务器。自从 Spring Cloud Greenwich 版本发布以来，建议使用
    **Spring Cloud Gateway** 代替。Spring Cloud Gateway 提供了对关键功能类似的支撑，例如基于 URL 路径的路由以及通过使用
    **OAuth 2.0** 和 **OpenID Connect**（**OIDC**）来保护端点。
- en: One important difference between Netflix Zuul v1 and Spring Cloud Gateway is
    that Spring Cloud Gateway is based on non-blocking APIs that use Spring 6, Project
    Reactor, and Spring Boot 3, while Netflix Zuul v1 is based on blocking APIs. This
    means that Spring Cloud Gateway should be able to handle larger numbers of concurrent
    requests than Netflix Zuul v1, which is important for an edge server that all
    external traffic goes through.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Zuul v1 和 Spring Cloud Gateway 之间的重要区别在于，Spring Cloud Gateway 基于非阻塞
    API，使用 Spring 6、Project Reactor 和 Spring Boot 3，而 Netflix Zuul v1 基于阻塞 API。这意味着
    Spring Cloud Gateway 应该能够处理比 Netflix Zuul v1 更多的并发请求，这对于所有外部流量都通过边缘服务器来说非常重要。
- en: 'The following diagram shows how all requests from external clients go through
    Spring Cloud Gateway as an edge server. Based on URL paths, it routes requests
    to the intended microservice:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了所有来自外部客户端的请求都通过 Spring Cloud Gateway 作为边缘服务器。基于 URL 路径，它将请求路由到目标微服务：
- en: '![Graphical user interface, diagram, text  Description automatically generated](img/B19825_08_02.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表，自动生成的文本描述](img/B19825_08_02.png)'
- en: 'Figure 8.2: Requests being routed through an edge server'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：请求通过边缘服务器进行路由
- en: In the preceding diagram, we can see how the edge server will send external
    requests that have a URL path that starts with `/product-composite/` to the **Product
    Composite** microservice. The core services **Product**, **Recommendation**, and
    **Review** are not reachable from external clients.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到边缘服务器将具有以 `/product-composite/` 开头的 URL 路径的外部请求发送到 **产品组合** 微服务。核心服务
    **产品**、**推荐** 和 **审查** 对外部客户端不可达。
- en: In *Chapter 10*, *Using Spring Cloud Gateway to Hide Microservices Behind an
    Edge Server*, we will look at how to set up Spring Cloud Gateway with our microservices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 10 章*，*使用 Spring Cloud Gateway 在边缘服务器后隐藏微服务* 中，我们将探讨如何设置与我们的微服务一起使用的 Spring
    Cloud Gateway。
- en: In *Chapter 11*, *Securing Access to APIs*, we will see how we can use Spring
    Cloud Gateway together with Spring Security OAuth2 to protect access to the edge
    server using OAuth 2.0 and OIDC. We will also see how Spring Cloud Gateway can
    propagate identity information of the caller down to our microservices, for example,
    the username or email address of the caller.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 11 章*，*保护 API 访问安全* 中，我们将看到如何使用 Spring Cloud Gateway 与 Spring Security
    OAuth2 一起使用，以 OAuth 2.0 和 OIDC 保护对边缘服务器的访问。我们还将看到 Spring Cloud Gateway 如何将调用者的身份信息传播到我们的微服务中，例如调用者的用户名或电子邮件地址。
- en: With Spring Cloud Gateway introduced, let’s see how Spring Cloud can help to
    manage the configuration of a system landscape of microservices.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 Spring Cloud Gateway 之后，让我们看看 Spring Cloud 如何帮助管理微服务系统景观的配置。
- en: Using Spring Cloud Config for centralized configuration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Config 进行集中配置
- en: To manage the configuration of a system landscape of microservices, Spring Cloud
    contains Spring Cloud Config, which provides the centralized management of configuration
    files according to the requirements described in *Chapter 1*, *Introduction to
    Microservices*, in the *Central configuration* section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理微服务系统景观的配置，Spring Cloud 包含 Spring Cloud Config，它根据 *第 1 章*，*微服务简介*，*集中配置*部分中描述的要求提供集中式配置文件管理。
- en: 'Spring Cloud Config supports storing configuration files in a number of different
    backends, such as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config 支持将配置文件存储在多种不同的后端，例如以下内容：
- en: A Git repository, for example, on GitHub or Bitbucket
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Git 仓库，例如 GitHub 或 Bitbucket
- en: A local filesystem
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统
- en: HashiCorp Vault
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault
- en: A JDBC database
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 JDBC 数据库
- en: Spring Cloud Config allows us to handle configuration in a hierarchical structure;
    for example, we can place common parts of the configuration in a common file and
    microservice-specific settings in separate configuration files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config 允许我们以分层结构处理配置；例如，我们可以将配置的公共部分放在一个公共文件中，而将特定于微服务的设置放在单独的配置文件中。
- en: Spring Cloud Config also supports detecting changes in the configuration and
    pushing notifications to the affected microservices. It uses **Spring Cloud Bus**
    to transport the notifications. Spring Cloud Bus is an abstraction on top of Spring
    Cloud Stream that we are already familiar with; that is, it supports the use of
    either RabbitMQ or Kafka as the messaging system for transporting notifications
    out of the box.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config 还支持检测配置中的更改并将通知推送到受影响的微服务。它使用 **Spring Cloud Bus** 来传输通知。Spring
    Cloud Bus 是在 Spring Cloud Stream 之上的一个抽象，我们已经很熟悉了；也就是说，它支持使用 RabbitMQ 或 Kafka
    作为传输通知的消息系统。
- en: 'The following diagram illustrates the cooperation between Spring Cloud Config,
    its clients, a Git repository, and Spring Cloud Bus:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了 Spring Cloud Config、其客户端、Git 仓库和 Spring Cloud Bus 之间的协作：
- en: '![Diagram, text  Description automatically generated](img/B19825_08_03.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图示，自动生成文本描述](img/B19825_08_03.png)'
- en: 'Figure 8.3: How Spring Cloud Config fits into the microservice landscape'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：Spring Cloud Config 如何融入微服务架构
- en: 'The diagram shows the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图中展示了以下内容：
- en: When the microservices start up, they ask the configuration server for its configuration.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当微服务启动时，它们会向配置服务器请求其配置。
- en: The configuration server gets the configuration from, in this case, a Git repository.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务器从，在这种情况下，Git 仓库中获取配置。
- en: Optionally, the Git repository can be configured to send notifications to the
    configuration server when Git commits are pushed to the Git repository.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，Git 仓库可以被配置为在 Git 提交推送到 Git 仓库时向配置服务器发送通知。
- en: The configuration server will publish change events using Spring Cloud Bus.
    The microservices that are affected by the change will react and retrieve its
    updated configuration from the configuration server.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务器将使用 Spring Cloud Bus 发布更改事件。受更改影响的微服务将做出反应，并从配置服务器检索其更新的配置。
- en: Finally, Spring Cloud Config also supports the encryption of sensitive information
    in the configuration, such as credentials.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Spring Cloud Config 还支持对配置中的敏感信息进行加密，例如凭证。
- en: We will learn about Spring Cloud Config in *Chapter 12*, *Centralized Configuration*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 12 章*，*集中配置* 中了解 Spring Cloud Config。
- en: With Spring Cloud Config introduced, let’s see how Spring Cloud can help make
    microservices more resilient to failures that happen from time to time in a system
    landscape.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Spring Cloud Config 的引入，让我们看看 Spring Cloud 如何帮助使微服务在面对系统环境中不时发生的故障时更加具有弹性。
- en: Using Resilience4j for improved resilience
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Resilience4j 提高弹性
- en: In a fairly large-scale system landscape of cooperating microservices, we must
    assume that there is something going wrong all of the time. Failures must be seen
    as a normal state, and the system landscape must be designed to handle it!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个相当大规模的系统景观中，合作的微服务，我们必须假设总有什么事情出错。故障必须被视为正常状态，系统景观必须设计来处理它！
- en: 'Initially, Spring Cloud came with Netflix Hystrix, a well-proven circuit breaker.
    But as already mentioned above, since the Spring Cloud Greenwich release, it is
    recommended to replace Netflix Hystrix with **Resilience4j**. Resilience4j is
    an open source-based fault tolerance library. It comes with a larger range of
    fault tolerance mechanisms compared to Netflix Hystrix:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，Spring Cloud 随 Netflix Hystrix 一起提供，这是一个经过充分验证的断路器。但如上所述，自 Spring Cloud
    Greenwich 版本发布以来，建议用 **Resilience4j** 替换 Netflix Hystrix。Resilience4j 是一个基于开源的容错库。它提供的容错机制范围比
    Netflix Hystrix 更广：
- en: '**A circuit breaker** is used to prevent a chain of failure reaction if a remote
    service stops responding.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**用于防止远程服务停止响应时发生连锁故障反应。'
- en: '**A rate limiter** is used to limit the number of requests to a service during
    a specified time period.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限流器**用于在指定时间段内限制对服务的请求数量。'
- en: '**A bulkhead** is used to limit the number of concurrent requests to a service.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离舱**用于限制对服务的并发请求数量。'
- en: '**Retries** are used to handle random errors that might happen from time to
    time.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试**用于处理可能不时发生的随机错误。'
- en: '**A time limiter** is used to avoid waiting too long for a response from a
    slow or unresponsive service.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间限制器**用于避免等待慢或无响应的服务响应时间过长。'
- en: You can discover more about Resilience4j at [https://github.com/resilience4j/resilience4j](https://github.com/resilience4j/resilience4j).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/resilience4j/resilience4j](https://github.com/resilience4j/resilience4j)
    上了解更多关于 Resilience4j 的信息。
- en: 'In *Chapter 13*, *Improving Resilience Using Resilience4j*, we will focus on
    the circuit breaker in Resilience4j. It follows the classic design of a circuit
    breaker, as illustrated in the following state diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 13 章，*使用 Resilience4j 提高弹性*中，我们将重点关注 Resilience4j 中的断路器。它遵循经典的断路器设计，如下面的状态图所示：
- en: '![Diagram  Description automatically generated](img/B19825_08_04.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_08_04.png)'
- en: 'Figure 8.4: Circuit breaker state diagram'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：断路器状态图
- en: 'Let’s take a look at the state diagram in more detail:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看状态图：
- en: A circuit breaker starts as **Closed**, allowing requests to be processed.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断路器以**关闭**状态开始，允许请求被处理。
- en: As long as the requests are processed successfully, it stays in the **Closed**
    state.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要请求处理成功，它就会保持在**关闭**状态。
- en: If failures start to happen, a counter starts to count up.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开始出现故障，计数器开始增加。
- en: If a threshold of failures is reached within a specified period of time, the
    circuit breaker will **trip**, that is, go to the **Open** state, not allowing
    further requests to be processed. Both the threshold of failures and the period
    of time are configurable.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在指定时间段内达到失败阈值，断路器将**跳闸**，即进入**打开**状态，不允许进一步处理请求。失败阈值和时间段都是可配置的。
- en: Instead, a request will **fast fail**, meaning it will return immediately with
    an exception.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，一个请求会**快速失败**，意味着它会立即返回一个异常。
- en: After a configurable period of time, the circuit breaker will enter a **Half
    Open** state and allow one request to go through, as a probe, to see whether the
    failure has been resolved.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可配置的时间段后，断路器将进入**半开**状态，允许一个请求通过，作为探测，以查看故障是否已解决。
- en: If the probe request fails, the circuit breaker goes back to the **Open** state.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果探测请求失败，断路器将回到**打开**状态。
- en: If the probe request succeeds, the circuit breaker goes to the initial **Closed**
    state, allowing new requests to be processed.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果探测请求成功，断路器将回到初始的**关闭**状态，允许新的请求被处理。
- en: Sample usage of the circuit breaker in Resilience4j
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Resilience4j 中断路器的示例用法
- en: Let’s assume we have a REST service, called `myService`, that is protected by
    a circuit breaker using Resilience4j.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `myService` 的 REST 服务，该服务使用 Resilience4j 的断路器进行保护。
- en: If the service starts to produce internal errors, for example, because it can’t
    reach a service it depends on, we might get a response from the service such as
    `500 Internal Server Error`. After a number of configurable attempts, the circuit
    will open and we will get a fast failure that returns an error message such as
    `CircuitBreaker 'myService' is open`. When the error is resolved and we make a
    new attempt (after the configurable wait time), the circuit breaker will allow
    a new attempt as a probe. If the call succeeds, the circuit breaker will be closed
    again; that is, operate normally.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务开始产生内部错误，例如，因为它无法访问它所依赖的服务，我们可能会从服务中得到如下响应：`500 内部服务器错误`。经过一系列可配置的尝试后，电路将打开，我们将得到一个快速失败，返回错误消息，例如`CircuitBreaker
    'myService' is open`。当错误解决后，我们再次尝试（在可配置的等待时间之后），断路器将允许新的尝试作为探测。如果调用成功，断路器将再次关闭；即，正常操作。
- en: 'When using Resilience4j together with Spring Boot, we will be able to monitor
    the state of the circuit breakers in a microservice using its Spring Boot Actuator
    `health` endpoint. We can, for example, use `curl` to see the state of the circuit
    breaker, `myService`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Spring Boot 一起使用 Resilience4j 时，我们将能够通过其 Spring Boot Actuator `health` 端点监控微服务中断路器的状态。例如，我们可以使用
    `curl` 来查看断路器 `myService` 的状态：
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If it operates normally, that is, the circuit is *closed*, it will respond
    with something such as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它正常工作，即电路是*关闭*的，它将响应如下：
- en: '![Text  Description automatically generated](img/B19825_08_05.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_08_05.png)'
- en: 'Figure 8.5: Closed circuit response'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：闭路响应
- en: 'If something is wrong and the circuit is *open*, it will respond with something
    such as the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题并且电路是*打开*的，它将响应如下：
- en: '![A screenshot of a computer screen  Description automatically generated with
    medium confidence](img/B19825_08_06.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，中等置信度](img/B19825_08_06.png)'
- en: 'Figure 8.6: Open circuit response'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：开路响应
- en: With Resilience4j introduced, we have seen an example of how the circuit breaker
    can be used to handle errors for a REST client. Let’s wrap up this chapter with
    an introduction to how Spring Cloud can be used for distributed tracing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Resilience4j 的引入，我们已经看到了如何使用断路器来处理 REST 客户端的错误示例。让我们以介绍 Spring Cloud 如何用于分布式跟踪来结束这一章。
- en: Using Micrometer Tracing and Zipkin for distributed tracing
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Micrometer 跟踪和 Zipkin 进行分布式跟踪
- en: To understand what is going on in a distributed system such as a system landscape
    of cooperating microservices, it is crucial to be able to track and visualize
    how requests and messages flow between microservices when processing an external
    call to the system landscape.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解分布式系统（如协作微服务的系统景观）中正在发生的事情，能够跟踪和可视化在处理对系统景观的外部调用时，请求和消息如何在微服务之间流动至关重要。
- en: Refer to *Chapter 1*, *Introduction to Microservices*, in the *Distributed tracing*
    section, for more information on this subject.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅*分布式跟踪*部分的*第 1 章*，*微服务介绍*。
- en: Starting with Spring Boot 3, distributed tracing is handled by **Micrometer
    Tracing**, replacing **Spring Cloud Sleuth**. Micrometer Tracing can mark requests
    and messages/events that are part of the same processing flow with a common **correlation
    ID**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring Boot 3 开始，分布式跟踪由 **Micrometer 跟踪** 处理，取代了 **Spring Cloud Sleuth**。Micrometer
    跟踪可以为属于同一处理流程的请求和消息/事件标记一个共同的 **关联 ID**。
- en: Micrometer Tracing can also be used to decorate log records with correlation
    IDs to make it easier to track log records from different microservices that come
    from the same processing flow. **Zipkin** is a distributed tracing system ([http://zipkin.io](http://zipkin.io))
    that Micrometer Tracing can send tracing data to for storage and visualization.
    Later on, in *Chapter 19*, *Centralized Logging with the EFK Stack*, we will learn
    how to find and visualize log records from one and the same processing flow using
    the correlation ID.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer 跟踪还可以用来装饰日志记录，添加关联 ID，以便更容易跟踪来自同一处理流程的不同微服务的日志记录。**Zipkin** 是一个分布式跟踪系统
    ([http://zipkin.io](http://zipkin.io))，Micrometer 跟踪可以将跟踪数据发送到它进行存储和可视化。在后面的*第
    19 章*，*使用 EFK 栈进行集中式日志记录*中，我们将学习如何使用关联 ID 来查找和可视化同一处理流程中的日志记录。
- en: The infrastructure for handling distributed tracing information in Micrometer
    Tracing and Zipkin is originally based on Google Dapper ([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356)).
    In Dapper, the tracing information from a complete workflow is called a **trace
    tree**, and subparts of the tree, such as the basic units of work, are called
    **spans**. Spans can, in turn, consist of sub-spans, which form the trace tree.
    A correlation ID is called **TraceId**, and a span is identified by its own unique
    **SpanId**, along with the **TraceId** of the trace tree it belongs to.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer Tracing和Zipkin中处理分布式跟踪信息的基础设施最初基于Google Dapper([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356))。在Dapper中，完整工作流程的跟踪信息被称为**跟踪树**，树的部分，如工作基本单元，被称为**跨度**。跨度可以进一步由子跨度组成，这些子跨度形成了跟踪树。关联ID被称为**TraceId**，一个跨度由其唯一的**SpanId**以及它所属的跟踪树的**TraceId**来识别。
- en: 'A short history lesson regarding the evolution of standards (or at least commons
    efforts on establishing open de facto standards) for implementing distributed
    tracing:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实现分布式跟踪标准（或至少是建立开放事实标准的共同努力）的简短历史课：
- en: Google published the paper on Dapper back in 2010, after using it internally
    since 2005.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Google在2005年开始内部使用后，于2010年发布了关于Dapper的论文。
- en: In 2016, the **OpenTracing** project joined **CNCF**. OpenTracing is heavily
    influenced by Dapper and provides vendor-neutral APIs and language-specific libraries
    for instrumenting distributed tracing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在2016年，**OpenTracing**项目加入了**CNCF**。OpenTracing深受Dapper的影响，并为分布式跟踪提供了供应商中立的API和特定语言的库。
- en: In 2019, the OpenTracing project merged with the **OpenCensus** project, forming
    a new CNCF project, **OpenTelemetry**. The OpenCensus project delivers a set of
    libraries for collecting metrics and distributed traces.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在2019年，OpenTracing项目与**OpenCensus**项目合并，形成了一个新的CNCF项目，**OpenTelemetry**。OpenCensus项目提供了一套用于收集指标和分布式跟踪的库。
- en: 'Suggested URLs for further reading:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 建议进一步阅读的URL：
- en: '[https://opentracing.io](https://opentracing.io)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opentracing.io](https://opentracing.io)'
- en: '[https://opencensus.io](https://opencensus.io)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opencensus.io](https://opencensus.io)'
- en: '[https://opentelemetry.io](https://opentelemetry.io)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opentelemetry.io](https://opentelemetry.io)'
- en: 'In *Chapter 14*, *Understanding Distributed Tracing*, we will see how we can
    use Micrometer Tracing and Zipkin to trace the processing that goes on in our
    microservice landscape. The following is a screenshot from the Zipkin UI, which
    visualizes the trace tree that was created as a result of processing the creation
    of an aggregated product:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第14章*理解分布式跟踪*中，我们将看到如何使用Micrometer Tracing和Zipkin来跟踪我们的微服务景观中的处理过程。以下是从Zipkin
    UI中截取的屏幕截图，它可视化了一个创建聚合产品的处理过程中创建的跟踪树：
- en: '![Graphical user interface  Description automatically generated](img/B19825_08_07.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成的描述](img/B19825_08_07.png)'
- en: 'Figure 8.7: Trace tree in Zipkin'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Zipkin中的跟踪树
- en: From the preceding screenshot, we can see that an HTTP `POST` request is sent
    to the **product-composite** service through the gateway (our edge server) and
    it responds by publishing create events to the topics for products, recommendations,
    and reviews. These events are consumed by the three core microservices in parallel
    and asynchronously, meaning that the **product-composite** service does not wait
    for the core microservices to complete their work. The data in the create events
    is stored in each microservice’s database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，我们可以看到通过网关（我们的边缘服务器）向**product-composite**服务发送了一个HTTP `POST`请求，并且它通过向产品、推荐和评论的主题发布创建事件来响应。这些事件由三个核心微服务并行和异步地消费，这意味着**product-composite**服务不会等待核心微服务完成其工作。创建事件中的数据存储在每个微服务的数据库中。
- en: With Micrometer Tracing and Zipkin for distributed tracing having been introduced,
    we have seen an example of distributed tracing of the processing of an external
    synchronous HTTP request that includes asynchronous passing of events between
    the involved microservices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了Micrometer Tracing和Zipkin进行分布式跟踪之后，我们看到了一个外部同步HTTP请求处理的分布式跟踪示例，该请求包括涉及微服务之间的异步事件传递。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how Spring Cloud has evolved from being rather Netflix
    OSS-centric to having a much larger scope as of today, used together with tools
    including Resilience4j and Micrometer Tracing. We also introduced how components
    from the latest release of Spring Cloud 2022 can be used to implement some of
    the design patterns we described in *Chapter 1*, *Introduction to Microservices*,
    in the *Design patterns for microservices* section. These design patterns are
    required to make a landscape of cooperating microservices production ready.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Spring Cloud是如何从相对Netflix OSS中心化的状态发展到今天拥有更广泛的应用范围，包括与Resilience4j和Micrometer
    Tracing等工具一起使用。我们还介绍了Spring Cloud 2022最新版本中的组件如何用于实现我们在*第1章*，“微服务简介”，*微服务设计模式*部分中描述的一些设计模式。这些设计模式是使协作微服务环境生产就绪所必需的。
- en: Head over to the next chapter to see how we can implement service discovery
    using Netflix Eureka and Spring Cloud LoadBalancer!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下一章，了解我们如何使用Netflix Eureka和Spring Cloud LoadBalancer实现服务发现！
- en: Questions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of Netflix Eureka?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Netflix Eureka的目的是什么？
- en: What are the main features of Spring Cloud Gateway?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway的主要特性有哪些？
- en: What backends are supported by Spring Cloud Config?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Config支持哪些后端？
- en: What are the capabilities that Resilience4j provides?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Resilience4j提供了哪些功能？
- en: What are the concepts of trace trees and spans used for in distributed tracing,
    and what is the paper called that originally defined them?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式追踪中使用的跟踪树和跨度概念是什么，以及最初定义它们的论文叫什么名字？
