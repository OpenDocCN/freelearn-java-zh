- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how we can use Spring Boot to build microservices with
    well-documented APIs, along with Spring WebFlux and `springdoc-openapi`; persist
    data in MongoDB and SQL databases using Spring Data for MongoDB and JPA; build
    reactive microservices either as non-blocking APIs using Project Reactor or as
    event-driven asynchronous services using Spring Cloud Stream with RabbitMQ or
    Kafka, together with Docker; and manage and test a system landscape consisting
    of microservices, databases, and messaging systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to see how we can use **Spring Cloud** to make our services production-ready,
    that is, scalable, robust, configurable, secure, and resilient.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce you to how Spring Cloud can be used to implement
    the following design patterns from *Chapter 1*, *Introduction to Microservices*,
    in the *Design patterns for microservices* section:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not contain any source code, and so no tools need to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its initial 1.0 release in March 2015, Spring Cloud was mainly a wrapper
    around tools from Netflix OSS, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Eureka, a discovery server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Ribbon, a client-side load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Zuul, an edge server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Hystrix, a circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial release of Spring Cloud also contained a configuration server and
    integration with Spring Security that provided OAuth 2.0 protected APIs. In May
    2016, the Brixton release (v1.1) of Spring Cloud was made generally available.
    With the Brixton release, Spring Cloud got support for distributed tracing based
    on Spring Cloud Sleuth and Zipkin, which originated from Twitter. These initial
    Spring Cloud components could be used to implement the preceding design patterns.
    For more details, see [https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now](https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now)
    and [https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available](https://spring.io/blog/2016/05/11/spring-cloud-brixton-release-is-available).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since its inception, Spring Cloud has grown considerably over the years and
    has added support for the following, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery and centralized configuration based on HashiCorp Consul and
    Apache Zookeeper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven microservices using Spring Cloud Stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud providers such as Microsoft Azure, Amazon Web Services, and Google Cloud
    Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://spring.io/projects/spring-cloud](https://spring.io/projects/spring-cloud)
    for a complete list of tools.
  prefs: []
  type: TYPE_NORMAL
- en: Since the release of Spring Cloud Greenwich (v2.1) in January 2019, some of
    the Netflix tools mentioned previously have been placed in maintenance mode in
    Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is a mixture of Netflix no longer adding new features to
    some of the tools and Spring Cloud adding better alternatives. The following replacements
    are recommended by the Spring Cloud project:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Current component** | **Replaced by** |'
  prefs: []
  type: TYPE_TB
- en: '| Netflix Hystrix | Resilience4j |'
  prefs: []
  type: TYPE_TB
- en: '| Netflix Hystrix Dashboard/Netflix Turbine | Micrometer and monitoring system
    |'
  prefs: []
  type: TYPE_TB
- en: '| Netflix Ribbon | Spring Cloud LoadBalancer |'
  prefs: []
  type: TYPE_TB
- en: '| Netflix Zuul | Spring Cloud Gateway |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Spring Cloud tool replacements'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available](https://spring.io/blog/2019/01/23/spring-cloud-greenwich-release-is-now-available)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/Netflix/ribbon#project-status-on-maintenance](https://github.com/Netflix/ribbon#project-status-on-maintenance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the release of Spring Cloud Ilford (v2020.0.0) in December 2020, the only
    remaining Netflix component in Spring Cloud is Netflix Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, together with Spring Boot 3, Spring Cloud Kilburn (v2022.0.0) was released
    in December 2022\. As already mentioned in *Chapter 2*, *Introduction to Spring
    Boot*, in the *News in Spring Boot 3.0* section, Spring Cloud Sleuth has been
    replaced by Micrometer Tracing to support distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use the software components in the following table to
    implement the design patterns mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Design pattern** | **Software component** |'
  prefs: []
  type: TYPE_TB
- en: '| Service discovery | Netflix Eureka and Spring Cloud LoadBalancer |'
  prefs: []
  type: TYPE_TB
- en: '| Edge server | Spring Cloud Gateway and Spring Security OAuth |'
  prefs: []
  type: TYPE_TB
- en: '| Centralized configuration | Spring Cloud Configuration Server |'
  prefs: []
  type: TYPE_TB
- en: '| Circuit breaker | Resilience4j |'
  prefs: []
  type: TYPE_TB
- en: '| Distributed tracing | Micrometer Tracing and Zipkin |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.2: Software components by design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go through the design patterns and introduce the software components
    that will be used to implement them!
  prefs: []
  type: TYPE_NORMAL
- en: Using Netflix Eureka for service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service discovery is probably the most important support function required to
    make a landscape of cooperating microservices production ready. As we already
    described in *Chapter 1*, *Introduction to Microservices*, in the *Service discovery*
    section, a service discovery service (or a *discovery service* as an abbreviation)
    can be used to keep track of existing microservices and their instances.
  prefs: []
  type: TYPE_NORMAL
- en: The first discovery service that Spring Cloud supported was *Netflix Eureka*.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this in *Chapter 9*, *Adding Service Discovery Using Netflix Eureka*,
    along with aload balancer based on Spring Cloud LoadBalancer.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how easy it is to register microservices with Netflix Eureka when
    using Spring Cloud. We will also learn how a client can send HTTP requests, such
    as a call to a RESTful API, to one of the instances registered in Netflix Eureka.
    In addition, the chapter will cover how to scale up the number of instances of
    a microservice, and how requests to a microservice will be load-balanced over
    its available instances (based on, by default, round-robin scheduling).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the web UI from Eureka, where we can
    see what microservices we have registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B19825_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Viewing microservices currently registered with Eureka'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see that the review service has three
    instances available, while the other three services only have one instance each.
  prefs: []
  type: TYPE_NORMAL
- en: With Netflix Eureka introduced, let’s introduce how Spring Cloud can help to
    protect a microservices system landscape using an edge server.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Gateway as an edge server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very important support function is an edge server. As we already described
    in *Chapter 1*, *Introduction to Microservices*, in the *Edge server* section,
    it can be used to secure a microservice landscape, which involves hiding private
    services from external usage and protecting public services when they’re used
    by external clients.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, Spring Cloud used Netflix Zuul v1 as its edge server. Since the Spring
    Cloud Greenwich release, it’s recommended to use **Spring Cloud Gateway** instead.
    Spring Cloud Gateway comes with similar support for critical features, such as
    URL path-based routing and the protection of endpoints via the use of **OAuth
    2.0** and **OpenID Connect** (**OIDC**).
  prefs: []
  type: TYPE_NORMAL
- en: One important difference between Netflix Zuul v1 and Spring Cloud Gateway is
    that Spring Cloud Gateway is based on non-blocking APIs that use Spring 6, Project
    Reactor, and Spring Boot 3, while Netflix Zuul v1 is based on blocking APIs. This
    means that Spring Cloud Gateway should be able to handle larger numbers of concurrent
    requests than Netflix Zuul v1, which is important for an edge server that all
    external traffic goes through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how all requests from external clients go through
    Spring Cloud Gateway as an edge server. Based on URL paths, it routes requests
    to the intended microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, diagram, text  Description automatically generated](img/B19825_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Requests being routed through an edge server'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see how the edge server will send external
    requests that have a URL path that starts with `/product-composite/` to the **Product
    Composite** microservice. The core services **Product**, **Recommendation**, and
    **Review** are not reachable from external clients.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 10*, *Using Spring Cloud Gateway to Hide Microservices Behind an
    Edge Server*, we will look at how to set up Spring Cloud Gateway with our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 11*, *Securing Access to APIs*, we will see how we can use Spring
    Cloud Gateway together with Spring Security OAuth2 to protect access to the edge
    server using OAuth 2.0 and OIDC. We will also see how Spring Cloud Gateway can
    propagate identity information of the caller down to our microservices, for example,
    the username or email address of the caller.
  prefs: []
  type: TYPE_NORMAL
- en: With Spring Cloud Gateway introduced, let’s see how Spring Cloud can help to
    manage the configuration of a system landscape of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Config for centralized configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage the configuration of a system landscape of microservices, Spring Cloud
    contains Spring Cloud Config, which provides the centralized management of configuration
    files according to the requirements described in *Chapter 1*, *Introduction to
    Microservices*, in the *Central configuration* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Config supports storing configuration files in a number of different
    backends, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Git repository, for example, on GitHub or Bitbucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashiCorp Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JDBC database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Config allows us to handle configuration in a hierarchical structure;
    for example, we can place common parts of the configuration in a common file and
    microservice-specific settings in separate configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config also supports detecting changes in the configuration and
    pushing notifications to the affected microservices. It uses **Spring Cloud Bus**
    to transport the notifications. Spring Cloud Bus is an abstraction on top of Spring
    Cloud Stream that we are already familiar with; that is, it supports the use of
    either RabbitMQ or Kafka as the messaging system for transporting notifications
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the cooperation between Spring Cloud Config,
    its clients, a Git repository, and Spring Cloud Bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, text  Description automatically generated](img/B19825_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: How Spring Cloud Config fits into the microservice landscape'
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When the microservices start up, they ask the configuration server for its configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration server gets the configuration from, in this case, a Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, the Git repository can be configured to send notifications to the
    configuration server when Git commits are pushed to the Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration server will publish change events using Spring Cloud Bus.
    The microservices that are affected by the change will react and retrieve its
    updated configuration from the configuration server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, Spring Cloud Config also supports the encryption of sensitive information
    in the configuration, such as credentials.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about Spring Cloud Config in *Chapter 12*, *Centralized Configuration*.
  prefs: []
  type: TYPE_NORMAL
- en: With Spring Cloud Config introduced, let’s see how Spring Cloud can help make
    microservices more resilient to failures that happen from time to time in a system
    landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Using Resilience4j for improved resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a fairly large-scale system landscape of cooperating microservices, we must
    assume that there is something going wrong all of the time. Failures must be seen
    as a normal state, and the system landscape must be designed to handle it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, Spring Cloud came with Netflix Hystrix, a well-proven circuit breaker.
    But as already mentioned above, since the Spring Cloud Greenwich release, it is
    recommended to replace Netflix Hystrix with **Resilience4j**. Resilience4j is
    an open source-based fault tolerance library. It comes with a larger range of
    fault tolerance mechanisms compared to Netflix Hystrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A circuit breaker** is used to prevent a chain of failure reaction if a remote
    service stops responding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A rate limiter** is used to limit the number of requests to a service during
    a specified time period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A bulkhead** is used to limit the number of concurrent requests to a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retries** are used to handle random errors that might happen from time to
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A time limiter** is used to avoid waiting too long for a response from a
    slow or unresponsive service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can discover more about Resilience4j at [https://github.com/resilience4j/resilience4j](https://github.com/resilience4j/resilience4j).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 13*, *Improving Resilience Using Resilience4j*, we will focus on
    the circuit breaker in Resilience4j. It follows the classic design of a circuit
    breaker, as illustrated in the following state diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Circuit breaker state diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the state diagram in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A circuit breaker starts as **Closed**, allowing requests to be processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As long as the requests are processed successfully, it stays in the **Closed**
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If failures start to happen, a counter starts to count up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a threshold of failures is reached within a specified period of time, the
    circuit breaker will **trip**, that is, go to the **Open** state, not allowing
    further requests to be processed. Both the threshold of failures and the period
    of time are configurable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead, a request will **fast fail**, meaning it will return immediately with
    an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a configurable period of time, the circuit breaker will enter a **Half
    Open** state and allow one request to go through, as a probe, to see whether the
    failure has been resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the probe request fails, the circuit breaker goes back to the **Open** state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the probe request succeeds, the circuit breaker goes to the initial **Closed**
    state, allowing new requests to be processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sample usage of the circuit breaker in Resilience4j
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume we have a REST service, called `myService`, that is protected by
    a circuit breaker using Resilience4j.
  prefs: []
  type: TYPE_NORMAL
- en: If the service starts to produce internal errors, for example, because it can’t
    reach a service it depends on, we might get a response from the service such as
    `500 Internal Server Error`. After a number of configurable attempts, the circuit
    will open and we will get a fast failure that returns an error message such as
    `CircuitBreaker 'myService' is open`. When the error is resolved and we make a
    new attempt (after the configurable wait time), the circuit breaker will allow
    a new attempt as a probe. If the call succeeds, the circuit breaker will be closed
    again; that is, operate normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Resilience4j together with Spring Boot, we will be able to monitor
    the state of the circuit breakers in a microservice using its Spring Boot Actuator
    `health` endpoint. We can, for example, use `curl` to see the state of the circuit
    breaker, `myService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If it operates normally, that is, the circuit is *closed*, it will respond
    with something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Closed circuit response'
  prefs: []
  type: TYPE_NORMAL
- en: 'If something is wrong and the circuit is *open*, it will respond with something
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated with
    medium confidence](img/B19825_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Open circuit response'
  prefs: []
  type: TYPE_NORMAL
- en: With Resilience4j introduced, we have seen an example of how the circuit breaker
    can be used to handle errors for a REST client. Let’s wrap up this chapter with
    an introduction to how Spring Cloud can be used for distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Using Micrometer Tracing and Zipkin for distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what is going on in a distributed system such as a system landscape
    of cooperating microservices, it is crucial to be able to track and visualize
    how requests and messages flow between microservices when processing an external
    call to the system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to *Chapter 1*, *Introduction to Microservices*, in the *Distributed tracing*
    section, for more information on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Spring Boot 3, distributed tracing is handled by **Micrometer
    Tracing**, replacing **Spring Cloud Sleuth**. Micrometer Tracing can mark requests
    and messages/events that are part of the same processing flow with a common **correlation
    ID**.
  prefs: []
  type: TYPE_NORMAL
- en: Micrometer Tracing can also be used to decorate log records with correlation
    IDs to make it easier to track log records from different microservices that come
    from the same processing flow. **Zipkin** is a distributed tracing system ([http://zipkin.io](http://zipkin.io))
    that Micrometer Tracing can send tracing data to for storage and visualization.
    Later on, in *Chapter 19*, *Centralized Logging with the EFK Stack*, we will learn
    how to find and visualize log records from one and the same processing flow using
    the correlation ID.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure for handling distributed tracing information in Micrometer
    Tracing and Zipkin is originally based on Google Dapper ([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356)).
    In Dapper, the tracing information from a complete workflow is called a **trace
    tree**, and subparts of the tree, such as the basic units of work, are called
    **spans**. Spans can, in turn, consist of sub-spans, which form the trace tree.
    A correlation ID is called **TraceId**, and a span is identified by its own unique
    **SpanId**, along with the **TraceId** of the trace tree it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'A short history lesson regarding the evolution of standards (or at least commons
    efforts on establishing open de facto standards) for implementing distributed
    tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: Google published the paper on Dapper back in 2010, after using it internally
    since 2005.
  prefs: []
  type: TYPE_NORMAL
- en: In 2016, the **OpenTracing** project joined **CNCF**. OpenTracing is heavily
    influenced by Dapper and provides vendor-neutral APIs and language-specific libraries
    for instrumenting distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: In 2019, the OpenTracing project merged with the **OpenCensus** project, forming
    a new CNCF project, **OpenTelemetry**. The OpenCensus project delivers a set of
    libraries for collecting metrics and distributed traces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suggested URLs for further reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://opentracing.io](https://opentracing.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://opencensus.io](https://opencensus.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://opentelemetry.io](https://opentelemetry.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Chapter 14*, *Understanding Distributed Tracing*, we will see how we can
    use Micrometer Tracing and Zipkin to trace the processing that goes on in our
    microservice landscape. The following is a screenshot from the Zipkin UI, which
    visualizes the trace tree that was created as a result of processing the creation
    of an aggregated product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19825_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Trace tree in Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see that an HTTP `POST` request is sent
    to the **product-composite** service through the gateway (our edge server) and
    it responds by publishing create events to the topics for products, recommendations,
    and reviews. These events are consumed by the three core microservices in parallel
    and asynchronously, meaning that the **product-composite** service does not wait
    for the core microservices to complete their work. The data in the create events
    is stored in each microservice’s database.
  prefs: []
  type: TYPE_NORMAL
- en: With Micrometer Tracing and Zipkin for distributed tracing having been introduced,
    we have seen an example of distributed tracing of the processing of an external
    synchronous HTTP request that includes asynchronous passing of events between
    the involved microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how Spring Cloud has evolved from being rather Netflix
    OSS-centric to having a much larger scope as of today, used together with tools
    including Resilience4j and Micrometer Tracing. We also introduced how components
    from the latest release of Spring Cloud 2022 can be used to implement some of
    the design patterns we described in *Chapter 1*, *Introduction to Microservices*,
    in the *Design patterns for microservices* section. These design patterns are
    required to make a landscape of cooperating microservices production ready.
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the next chapter to see how we can implement service discovery
    using Netflix Eureka and Spring Cloud LoadBalancer!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of Netflix Eureka?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main features of Spring Cloud Gateway?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What backends are supported by Spring Cloud Config?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the capabilities that Resilience4j provides?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the concepts of trace trees and spans used for in distributed tracing,
    and what is the paper called that originally defined them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
