<html><head></head><body>
<div id="_idContainer066">
<h1 class="chapter-number" id="_idParaDest-177"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-178"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.2.1">Jakarta Messaging</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Jakarta Messaging</span></strong><span class="koboSpan" id="kobo.4.1"> provides </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.5.1">a mechanism for Jakarta EE applications to send messages to each other. </span><span class="koboSpan" id="kobo.5.2">Jakarta Messaging applications do not communicate directly; instead, message producers send messages to a destination, and message consumers receive the message from </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the destination.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">The message destination is a message queue when</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.8.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">point-to-point</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.11.1">PTP</span></strong><span class="koboSpan" id="kobo.12.1">) messaging domain is used, or a message topic when the </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">publish/subscribe</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.15.1">pub/sub</span></strong><span class="koboSpan" id="kobo.16.1">) messaging</span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.17.1"> domain </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">is used.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">message queues</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">message topics</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.25.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.26.1">Example source code for this chapter can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.30.1">Working with message queues</span></h1>
<p><span class="koboSpan" id="kobo.31.1">As we mentioned earlier, message queues </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.32.1">are used when our Jakarta Messaging code uses the </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.33.1">PTP messaging domain. </span><span class="koboSpan" id="kobo.33.2">For the PTP messaging domain, there is usually one message producer and one message consumer. </span><span class="koboSpan" id="kobo.33.3">The message producer</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.34.1"> and the message consumer</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.35.1"> don’t need to be running concurrently in order to communicate. </span><span class="koboSpan" id="kobo.35.2">The messages placed in the message queue by the message producer will stay in the message queue until the message consumer executes and requests the messages from </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the queue.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.37.1">Sending messages to a message queue</span></h2>
<p><span class="koboSpan" id="kobo.38.1">The </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.39.1">following example illustrates how to add messages to a </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">message queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.41.1">
package com.ensode.jakartaeebook.ptpproducer;
//imports omitted for brevity
</span><strong class="bold"><span class="koboSpan" id="kobo.42.1">@JMSDestinationDefinition(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.43.1">    name = "java:global/queue/JakartaEEBookQueue",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.44.1">    interfaceName = "jakarta.jms.Queue"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.45.1">)</span></strong><span class="koboSpan" id="kobo.46.1">
@Named
@RequestScoped
public class MessageSender {
  @Resource
  private ConnectionFactory connectionFactory;
  </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">@Resource(mappedName = "java:global/queue/JakartaEEBookQueue")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.48.1">  private Queue queue;</span></strong><span class="koboSpan" id="kobo.49.1">
  public void produceMessages() {
    JMSContext jmsContext = connectionFactory.createContext();
    JMSProducer jmsProducer = jmsContext.createProducer();
    String msg1 = "Testing, 1, 2, 3. </span><span class="koboSpan" id="kobo.49.2">Can you hear me?";
    String msg2 = "Do you copy?";
    String msg3 = "Good bye!";
    jmsProducer.send(queue, msg1);
    jmsProducer.send(queue, msg2);
    jmsProducer.send(queue, msg3);
  }
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.50.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.51.1">Most examples in </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.52.1">this chapter are implemented as </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">Contexts and Dependency Injection</span></strong><span class="koboSpan" id="kobo.54.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.55.1">CDI</span></strong><span class="koboSpan" id="kobo.56.1">) beans. </span><span class="koboSpan" id="kobo.56.2">Refer to </span><a href="B21231_02.xhtml#_idTextAnchor022"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.58.1"> for an explanation </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">of CDI.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.61.1">class-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">@JMSDestinationDefinition</span></strong><span class="koboSpan" id="kobo.63.1"> annotation defines a Jakarta Messaging destination where our messages will be placed. </span><span class="koboSpan" id="kobo.63.2">This annotation has two required attributes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">name</span></strong><span class="koboSpan" id="kobo.65.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">interfaceName</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">name</span></strong><span class="koboSpan" id="kobo.69.1"> attribute of </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">@JMSDestinationDefinition</span></strong><span class="koboSpan" id="kobo.71.1"> defines a </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Java Naming and Directory Interface</span></strong><span class="koboSpan" id="kobo.73.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.74.1">JNDI</span></strong><span class="koboSpan" id="kobo.75.1">) name </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.76.1">for our Jakarta Messaging destination, which is used by the Jakarta EE runtime to look up the destination. </span><span class="koboSpan" id="kobo.76.2">Meanwhile, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">interfaceName</span></strong><span class="koboSpan" id="kobo.78.1"> specifies the Jakarta Messaging destination interface; PTP messaging, this value must always</span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.79.1"> be </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">jakarta.jms.Queue</span></strong><span class="koboSpan" id="kobo.81.1">.The </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">produceMessages()</span></strong><span class="koboSpan" id="kobo.83.1"> method of the preceding class is invoked from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">commandButton</span></strong><span class="koboSpan" id="kobo.85.1"> from a Jakarta Faces page implemented using Facelets. </span><span class="koboSpan" id="kobo.85.2">For brevity, we will not show the XHTML markup for this page. </span><span class="koboSpan" id="kobo.85.3">The code download bundle for this chapter contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">complete example.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">produceMessages()</span></strong><span class="koboSpan" id="kobo.89.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">MessageSender</span></strong><span class="koboSpan" id="kobo.91.1"> class performs all the necessary steps to send messages to a </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">message queue.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">The first thing this method does is create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">jakarta.jms.JMSContext</span></strong><span class="koboSpan" id="kobo.95.1"> by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">createContext()</span></strong><span class="koboSpan" id="kobo.97.1"> method on the injected instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">jakarta.jms.ConnectionFactory</span></strong><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">Notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">mappedName</span></strong><span class="koboSpan" id="kobo.101.1"> attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">@Resource</span></strong><span class="koboSpan" id="kobo.103.1"> annotation decorating the connection factory object matches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">name</span></strong><span class="koboSpan" id="kobo.105.1"> attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">@JMSDestinationDefinition</span></strong><span class="koboSpan" id="kobo.107.1"> annotation. </span><span class="koboSpan" id="kobo.107.2">Behind the scenes, a JNDI lookup is made using this name to obtain the connection </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">factory object.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Next, we create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">jakarta.jms.JMSProducer</span></strong><span class="koboSpan" id="kobo.111.1"> by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">createProducer()</span></strong><span class="koboSpan" id="kobo.113.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">JMSContext</span></strong><span class="koboSpan" id="kobo.115.1"> instance we </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">just created.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">After </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.118.1">obtaining an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">JMSProducer</span></strong><span class="koboSpan" id="kobo.120.1">, the code sends a series of text messages by invoking its </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">send()</span></strong><span class="koboSpan" id="kobo.122.1"> method. </span><span class="koboSpan" id="kobo.122.2">This method takes the message destination as its first parameter, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">String</span></strong><span class="koboSpan" id="kobo.124.1"> containing the message text as its </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">second parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">There are several overloaded versions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">send()</span></strong><span class="koboSpan" id="kobo.128.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">JMSProducer</span></strong><span class="koboSpan" id="kobo.130.1">. </span><span class="koboSpan" id="kobo.130.2">The one we used in our example is a convenient method that creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">jakarta.jms.TextMessage</span></strong><span class="koboSpan" id="kobo.132.1"> and sets its text to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">String</span></strong><span class="koboSpan" id="kobo.134.1"> we provide as the second parameter in the </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">method invocation.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">Although the preceding example sends only text messages to the queue, we are not limited to this type of message. </span><span class="koboSpan" id="kobo.136.2">Jakarta Messaging provides several types of messages that can be sent and received by Jakarta Messaging applications. </span><span class="koboSpan" id="kobo.136.3">All message types are defined as interfaces in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">jakarta.jms</span></strong><span class="koboSpan" id="kobo.138.1"> package. </span><em class="italic"><span class="koboSpan" id="kobo.139.1">Table 13.1</span></em><span class="koboSpan" id="kobo.140.1"> lists all of the available </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">message types:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.142.1">Message Type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.143.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">BytesMessage</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.145.1">Allows</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.146.1"> sending an array of bytes as a message</span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.147.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">JMSProducer</span></strong><span class="koboSpan" id="kobo.149.1"> has a convenient </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">send()</span></strong><span class="koboSpan" id="kobo.151.1"> method that takes an array of bytes as one of its parameters. </span><span class="koboSpan" id="kobo.151.2">This method creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">jakarta.jms.BytesMessage</span></strong><span class="koboSpan" id="kobo.153.1"> on the fly as the message is </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">being sent.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">MapMessage</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.156.1">Allows sending an implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">java.util.Map</span></strong><span class="koboSpan" id="kobo.158.1"> as a message. </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">JMSProducer</span></strong><span class="koboSpan" id="kobo.160.1"> has a convenient </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">send()</span></strong><span class="koboSpan" id="kobo.162.1"> method that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">Map</span></strong><span class="koboSpan" id="kobo.164.1"> as one of its parameters. </span><span class="koboSpan" id="kobo.164.2">This method creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">jakarta.jms.MapMessage</span></strong><span class="koboSpan" id="kobo.166.1"> on the fly as the message is </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">being sent.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">ObjectMessage</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.169.1">Allows sending any Java object implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">java.io.Serializable</span></strong><span class="koboSpan" id="kobo.171.1"> as a message. </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">JMSProducer</span></strong><span class="koboSpan" id="kobo.173.1"> has a convenient </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">send()</span></strong><span class="koboSpan" id="kobo.175.1"> method, which takes an instance of a class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">java.io.Serializable</span></strong><span class="koboSpan" id="kobo.177.1"> as its second parameter. </span><span class="koboSpan" id="kobo.177.2">This method creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">jakarta.jms.ObjectMessage</span></strong><span class="koboSpan" id="kobo.179.1"> on the fly as the message is </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">being sent.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">StreamMessage</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.182.1">Allows sending an array of bytes as a message. </span><span class="koboSpan" id="kobo.182.2">Differs from </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">BytesMessage</span></strong><span class="koboSpan" id="kobo.184.1"> in that it stores the type of each primitive added to </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the stream</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">TextMessage</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.187.1">Allows </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.188.1">sending </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">java.lang.String</span></strong><span class="koboSpan" id="kobo.190.1"> as a message. </span><span class="koboSpan" id="kobo.190.2">As seen in the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">JMSProducer</span></strong><span class="koboSpan" id="kobo.192.1"> has a convenient </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">send()</span></strong><span class="koboSpan" id="kobo.194.1"> method that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">String</span></strong><span class="koboSpan" id="kobo.196.1"> as its second parameter. </span><span class="koboSpan" id="kobo.196.2">This method creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">jakarta.jms.TextMessage</span></strong><span class="koboSpan" id="kobo.198.1"> on the fly as the message is </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">being sent.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.200.1">Table 13.1 – Jakarta Messaging message types</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.201.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.202.1">For more information on all of </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.203.1">the preceding message types, consult the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">JavaDoc</span></strong><span class="koboSpan" id="kobo.205.1"> documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">at </span></span><a href="https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary"><span class="No-Break"><span class="koboSpan" id="kobo.207.1">https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.208.1">.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.209.1">Retrieving messages from a message queue</span></h2>
<p><span class="koboSpan" id="kobo.210.1">Of course, there is no point in</span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.211.1"> sending messages from a queue if nothing is going to receive them. </span><span class="koboSpan" id="kobo.211.2">The following example illustrates how to retrieve messages from a </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">message queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
package com.ensode.jakartaeebook.ptpconsumer;
//imports omitted for brevity
</span><strong class="bold"><span class="koboSpan" id="kobo.214.1">@JMSDestinationDefinition(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.215.1">  name = "java:global/queue/JakartaEEBookQueue",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.216.1">  interfaceName = "jakarta.jms.Queue"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.217.1">)</span></strong><span class="koboSpan" id="kobo.218.1">
@Named
@RequestScoped
public class MessageReceiver implements Serializable {
  </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">@Resource</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.220.1">  private ConnectionFactory connectionFactory;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.221.1">  @Resource(mappedName =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.222.1">    "java:global/queue/JakartaEEBookQueue")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.223.1">  private Queue </span></strong><strong class="bold"><span class="koboSpan" id="kobo.224.1">queue;</span></strong><span class="koboSpan" id="kobo.225.1">
  private static final Logger LOG =
    Logger.getLogger(MessageReceiver.class.getName());
  public void receiveMessages() {
    String message;
    boolean goodByeReceived = false;
    </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">JMSContext jmsContext = connectionFactory.</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.227.1">      createContext();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.228.1">    JMSConsumer jMSConsumer =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.229.1">      jmsContext.createConsumer(queue);</span></strong><span class="koboSpan" id="kobo.230.1">
    while (!goodByeReceived) {
      message = </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">jMSConsumer.receiveBody(String.class)</span></strong><span class="koboSpan" id="kobo.232.1">;
      LOG.log(Level.INFO, "Received message: {0}", message);
      if (message.equals("Good bye!")) {
        goodByeReceived = true;
      }
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.233.1">Just like in the previous example, we define a destination via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">@JMSDestinationDefinition</span></strong><span class="koboSpan" id="kobo.235.1"> annotation, plus we inject instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">jakarta.jms.ConnectionFactory</span></strong><span class="koboSpan" id="kobo.237.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">jakarta.jms.Queue</span></strong><span class="koboSpan" id="kobo.239.1"> by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Resource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">In our code, we get an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">jakarta.jms.JMSContext</span></strong><span class="koboSpan" id="kobo.245.1"> by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">createContext()</span></strong><span class="koboSpan" id="kobo.247.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">ConnectionFactory</span></strong><span class="koboSpan" id="kobo.249.1">, just like in the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">previous example.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">In this example, we obtain an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">jakarta.jms.JMSConsumer</span></strong><span class="koboSpan" id="kobo.253.1"> by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">createConsumer()</span></strong><span class="koboSpan" id="kobo.255.1"> method on our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">JMSContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Messages are </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.259.1">received by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">receiveBody()</span></strong><span class="koboSpan" id="kobo.261.1"> method on our instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">JMSConsumer</span></strong><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">This method takes the type of the message we are expecting as its sole parameter (</span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">String.class</span></strong><span class="koboSpan" id="kobo.265.1"> in our example). </span><span class="koboSpan" id="kobo.265.2">This method returns an object of the type specified in its parameter (an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">java.lang.String</span></strong><span class="koboSpan" id="kobo.267.1"> in our example). </span><span class="koboSpan" id="kobo.267.2">Once the message is consumed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">JMSConsumer.receiveBody()</span></strong><span class="koboSpan" id="kobo.269.1">, it is removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">In this particular example, we placed this method call in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">while</span></strong><span class="koboSpan" id="kobo.273.1"> loop since we are expecting a message that will let us know no more messages are coming. </span><span class="koboSpan" id="kobo.273.2">Specifically, we are looking for a message containing the text “Good bye!”. Once we receive said message, we break out of the loop and continue processing. </span><span class="koboSpan" id="kobo.273.3">In this particular case, there is no more processing to do, therefore execution ends after we break out of </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">the loop.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">After executing the code, we should see the following output in the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">server log:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.277.1">
Waiting for messages...
</span><span class="koboSpan" id="kobo.277.2">Received the following message: Testing, 1, 2, 3. </span><span class="koboSpan" id="kobo.277.3">Can you hear me?
</span><span class="koboSpan" id="kobo.277.4">Received the following message: Do you copy?
</span><span class="koboSpan" id="kobo.277.5">Received the following message: Good bye!</span></pre> <p><span class="koboSpan" id="kobo.278.1">This of course</span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.279.1"> assumes that the previous example was already executed and it placed messages in the </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">message queue.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.281.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.282.1">A disadvantage of processing messages as discussed in this section is that message processing is synchronous. </span><span class="koboSpan" id="kobo.282.2">In Jakarta EE environments, we can process messages asynchronously by employing message-driven beans, as discussed in </span><a href="B21231_12.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.283.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.284.1">.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.285.1">Browsing message queues</span></h2>
<p><span class="koboSpan" id="kobo.286.1">Jakarta Messaging </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.287.1">provides a way to browse message queues without actually removing the messages from the queue. </span><span class="koboSpan" id="kobo.287.2">The following example illustrates how to </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
package com.ensode.jakartaeebook.queuebrowser;
//imports omitted for brevity
//Messaging destination definition annotation omitted
@Named
@RequestScoped
public class MessageQueueBrowser {
  </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">@Resource</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.291.1">  private ConnectionFactory connectionFactory;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.292.1">  @</span></strong><strong class="bold"><span class="koboSpan" id="kobo.293.1">Resource(mappedName =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.294.1">    "java:global/queue/JakartaEEBookQueue")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.295.1">  private Queue queue;</span></strong><span class="koboSpan" id="kobo.296.1">
  private static final Logger LOG =
    Logger.getLogger(MessageQueueBrowser.class.getName());
  public void browseMessages() throws JMSException {
    Enumeration messageEnumeration;
    TextMessage textMessage;
    </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">JMSContext jmsContext =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.298.1">      connectionFactory.createContext();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.299.1">    QueueBrowser browser = jmsContext.createBrowser(queue);</span></strong><span class="koboSpan" id="kobo.300.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">messageEnumeration = browser.getEnumeration();</span></strong><span class="koboSpan" id="kobo.302.1">
    LOG.log(Level.INFO, "messages in the queue:");
    while (messageEnumeration.hasMoreElements()) {
      textMessage = (TextMessage) messageEnumeration.
</span><span class="koboSpan" id="kobo.302.2">        nextElement();
      LOG.log(Level.INFO, </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">textMessage.getText()</span></strong><span class="koboSpan" id="kobo.304.1">);
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.305.1">As we can see, the </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.306.1">procedure to browse messages in a message queue is straightforward. </span><span class="koboSpan" id="kobo.306.2">We obtain a connection factory, a queue, and a context the usual way, then invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">createBrowser()</span></strong><span class="koboSpan" id="kobo.308.1"> method on the context object. </span><span class="koboSpan" id="kobo.308.2">This method returns an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">jakarta.jms.QueueBrowser</span></strong><span class="koboSpan" id="kobo.310.1"> interface. </span><span class="koboSpan" id="kobo.310.2">This interface contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">getEnumeration()</span></strong><span class="koboSpan" id="kobo.312.1"> method, which we can invoke to obtain an </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Enumeration</span></strong><span class="koboSpan" id="kobo.314.1"> containing all messages in the queue. </span><span class="koboSpan" id="kobo.314.2">To examine the messages in the queue, we simply traverse this enumeration and obtain the messages one by one. </span><span class="koboSpan" id="kobo.314.3">In the example that we discussed, we simply invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">getText()</span></strong><span class="koboSpan" id="kobo.316.1"> method of each message in </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">Now that we’ve seen how to send and receive messages to and from a queue with the PTP messaging domain, we’ll focus our attention on sending and receiving messages to and from message topics with the pub/sub </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">messaging domain.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.320.1">Working with message topics</span></h1>
<p><span class="koboSpan" id="kobo.321.1">Message topics are used when</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.322.1"> our Jakarta Messaging code uses the pub/sub messaging domain. </span><span class="koboSpan" id="kobo.322.2">When using this messaging domain, the same message can be sent to all subscribers to </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the topic.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.324.1">Sending messages to a message topic</span></h2>
<p><span class="koboSpan" id="kobo.325.1">The following example</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.326.1"> illustrates how to send messages to a </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">message topic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
package com.ensode.jakartaeebook.pubsubproducer;
//imports omitted
</span><strong class="bold"><span class="koboSpan" id="kobo.329.1">@JMSDestinationDefinition(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.330.1">    name = "java:global/topic/JakartaEEBookTopic",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.331.1">    interfaceName = "jakarta.jms.Topic"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.332.1">)</span></strong><span class="koboSpan" id="kobo.333.1">
@Named
@RequestScoped
public class MessageSender {
  @Resource
  private ConnectionFactory connectionFactory;
</span><strong class="bold"><span class="koboSpan" id="kobo.334.1">  @Resource(mappedName =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.335.1">    "java:global/topic/JakartaEEBookTopic")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.336.1">  private Topic topic;</span></strong><span class="koboSpan" id="kobo.337.1">
  public void produceMessages() {
    JMSContext jmsContext =
      connectionFactory.createContext();
    JMSProducer jmsProducer = jmsContext.createProducer();
    String msg1 = "Testing, 1, 2, 3. </span><span class="koboSpan" id="kobo.337.2">Can you hear me?";
    String msg2 = "Do you copy?";
    String msg3 = "Good bye!";
    </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">jmsProducer.send(topic, msg1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.339.1">    jmsProducer.send(topic, msg2);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.340.1">    jmsProducer.send(topic, msg3);</span></strong><span class="koboSpan" id="kobo.341.1">
  }
}</span></pre> <p><span class="koboSpan" id="kobo.342.1">As we can see, the preceding code is nearly identical to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">MessageSender</span></strong><span class="koboSpan" id="kobo.344.1"> class we saw when we discussed PTP messaging. </span><span class="koboSpan" id="kobo.344.2">Jakarta Messaging was designed so that the same API can be used for both the PTP and </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">pub/sub domains.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">Since the code in this example is nearly identical to the corresponding example in the </span><em class="italic"><span class="koboSpan" id="kobo.347.1">Working with message queues</span></em><span class="koboSpan" id="kobo.348.1"> section, we will only explain the differences between the two examples. </span><span class="koboSpan" id="kobo.348.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">@JMSDestinationDefinition</span></strong><span class="koboSpan" id="kobo.350.1"> has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">jakarta.jms.Topic</span></strong><span class="koboSpan" id="kobo.352.1"> for its </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">name</span></strong><span class="koboSpan" id="kobo.354.1"> attribute, as required when using the pub/sub messaging domain. </span><span class="koboSpan" id="kobo.354.2">Additionally, instead of declaring an instance of a class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">jakarta.jms.Queue</span></strong><span class="koboSpan" id="kobo.356.1">, we declare an instance of a class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">jakarta.jms.Topic</span></strong><span class="koboSpan" id="kobo.358.1">. </span><span class="koboSpan" id="kobo.358.2">We then pass this </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.359.1">instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">jakarta.jms.Topic</span></strong><span class="koboSpan" id="kobo.361.1"> as the first method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">send()</span></strong><span class="koboSpan" id="kobo.363.1"> method of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">JMSProducer</span></strong><span class="koboSpan" id="kobo.365.1"> object, along with the message we wish </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">to send.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.367.1">Receiving messages from a message topic</span></h2>
<p><span class="koboSpan" id="kobo.368.1">Just as sending </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.369.1">messages to a message topic is nearly identical to sending messages to a message queue, receiving messages from a message topic is nearly identical to receiving messages from a </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">message queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
package com.ensode.jakartaeebook.pubsubconsumer;
//imports omitted
@JMSDestinationDefinition(
    name = "java:global/topic/JakartaEEBookTopic",
    interfaceName = "jakarta.jms.Topic"
)
@Named
@RequestScoped
public class MessageReceiver {
  @Resource
  private ConnectionFactory connectionFactory;
  </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">@Resource(mappedName = "java:global/topic/JakartaEEBookTopic")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.373.1">  private Topic topic;</span></strong><span class="koboSpan" id="kobo.374.1">
  private static final Logger LOG =
    Logger.getLogger(MessageReceiver.class.getName());
  public void receiveMessages() {
    String message;
    boolean goodByeReceived = false;
    </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">JMSContext jmsContext = connectionFactory.createContext();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.376.1">    JMSConsumer jMSConsumer = jmsContext.createConsumer(topic);</span></strong><span class="koboSpan" id="kobo.377.1">
    while (!goodByeReceived) {
      message = </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">jMSConsumer.receiveBody(String.class)</span></strong><span class="koboSpan" id="kobo.379.1">;
      LOG.log(Level.INFO, "Received message: {0}", message);
      if (message.equals("Good bye!")) {
        goodByeReceived = true;
      }
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.380.1">Once again, the</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.381.1"> differences between this code and the corresponding code for PTP are trivial. </span><span class="koboSpan" id="kobo.381.2">Instead of declaring an instance of a class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">jakarta.jms.Queue</span></strong><span class="koboSpan" id="kobo.383.1">, we declare a class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">jakarta.jms.Topic</span></strong><span class="koboSpan" id="kobo.385.1">. </span><span class="koboSpan" id="kobo.385.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">@Resource</span></strong><span class="koboSpan" id="kobo.387.1"> annotation to inject an instance of this class into our code, using the JNDI name we used when configuring our application server. </span><span class="koboSpan" id="kobo.387.2">We then obtain an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">JMSContext</span></strong><span class="koboSpan" id="kobo.389.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">JMSConsumer</span></strong><span class="koboSpan" id="kobo.391.1"> like before, then it receives the messages from the topic by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">receiveBody()</span></strong><span class="koboSpan" id="kobo.393.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">JMSConsumer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Using the pub/sub messaging domain as illustrated in this section has the advantage that messages can be sent to several message consumers. </span><span class="koboSpan" id="kobo.397.2">This can be easily tested by concurrently executing two instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">MessageReceiver</span></strong><span class="koboSpan" id="kobo.399.1"> class we developed in this section, and then executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">MessageSender</span></strong><span class="koboSpan" id="kobo.401.1"> class we developed in the previous section. </span><span class="koboSpan" id="kobo.401.2">We should see console output for each instance, indicating</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.402.1"> that both instances received </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">all messages.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.404.1">Creating durable subscribers</span></h2>
<p><span class="koboSpan" id="kobo.405.1">The disadvantage</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.406.1"> of using the pub/sub messaging domain is that message consumers must be executing when the messages are sent to the topic. </span><span class="koboSpan" id="kobo.406.2">If the message consumer is not executing at the time, it will not receive the messages, whereas in PTP, messages are kept in the queue until the message consumer executes. </span><span class="koboSpan" id="kobo.406.3">Fortunately, Jakarta Messaging provides a way to use the pub/sub messaging domain and keep messages in the topic until all subscribed message consumers execute and receive the message. </span><span class="koboSpan" id="kobo.406.4">This can be accomplished by creating durable subscribers to a </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">message topic.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">In order to be able to service durable subscribers, we need to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">clientId</span></strong><span class="koboSpan" id="kobo.410.1"> property of our Jakarta Messaging connection factory. </span><span class="koboSpan" id="kobo.410.2">Each durable subscriber must have a unique client ID, therefore a unique connection factory must be declared for each potential </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">durable subscriber.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">We can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">clientId</span></strong><span class="koboSpan" id="kobo.414.1"> property of our connection factory using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">@JMSConnectionFactoryDefinition</span></strong><span class="koboSpan" id="kobo.416.1"> annotation, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
package com.ensode.jakartaeebook.pubsubdurablesubscriber;
//imports omitted for brevity
</span><strong class="bold"><span class="koboSpan" id="kobo.419.1">@JMSConnectionFactoryDefinition(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.420.1">    name = "java:global/messaging/DurableConnectionFactory",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.421.1">    clientId = "DurableConnectionFactoryClientId"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.422.1">)</span></strong><span class="koboSpan" id="kobo.423.1">
//Messaging destination definition annotation omitted
@Named
@ApplicationScoped
public class MessageReceiver {
  </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">@Resource(mappedName =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.425.1">   "java:global/messaging/DurableConnectionFactory")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.426.1">  private ConnectionFactory connectionFactory;</span></strong><span class="koboSpan" id="kobo.427.1">
  @Resource(mappedName =
    "java:global/topic/JakartaEEBookTopic")
  private Topic topic;
  private static final Logger LOG =
   Logger.getLogger(MessageReceiver.class.getName());
  public void receiveMessages() {
    String message;
    boolean goodByeReceived = false;
    JMSContext jmsContext =
      connectionFactory.createContext();
    </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">JMSConsumer jMSConsumer =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.429.1">      jmsContext.createDurableConsumer(topic,"Subscriber1");</span></strong><span class="koboSpan" id="kobo.430.1">
    while (!goodByeReceived) {
      message = jMSConsumer.receiveBody(String.class);
      LOG.log(Level.INFO, "Received message: {0}", message);
      if (message.equals("Good bye!")) {
        goodByeReceived = true;
      }
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.431.1">As we can see, the preceding code is not much different from previous examples whose purpose was to retrieve messages. </span><span class="koboSpan" id="kobo.431.2">There are only a few differences from previous examples: the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">ConnectionFactory</span></strong><span class="koboSpan" id="kobo.433.1"> we are injecting is defined via </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">@JMSConnectionFactoryDefinition</span></strong><span class="koboSpan" id="kobo.435.1"> and given a client ID via its </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">clientId</span></strong><span class="koboSpan" id="kobo.437.1"> attribute. </span><span class="koboSpan" id="kobo.437.2">Notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">@Resource</span></strong><span class="koboSpan" id="kobo.439.1"> annotation for our connection factory has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">mappedName</span></strong><span class="koboSpan" id="kobo.441.1"> attribute whose value matches the name attribute we defined </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">@JMSConnectionFactoryDefinition</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">Another </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.446.1">difference is that instead of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">createConsumer()</span></strong><span class="koboSpan" id="kobo.448.1"> method on  </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">JMSContext</span></strong><span class="koboSpan" id="kobo.450.1">, we are calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">createDurableConsumer()</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">createDurableConsumer()</span></strong><span class="koboSpan" id="kobo.454.1"> method takes two arguments, a messaging </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">Topic</span></strong><span class="koboSpan" id="kobo.456.1"> object to retrieve messages from and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">String</span></strong><span class="koboSpan" id="kobo.458.1"> designating a name for this subscription. </span><span class="koboSpan" id="kobo.458.2">This second parameter must be unique between all subscribers to the </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">durable topic.</span></span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.460.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.461.1">In this chapter, we discussed at length how to send messages with Jakarta Messaging, using both the PTP and pub/sub </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">messaging domains.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">Topics we covered included </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.465.1">How to send messages to a message queue via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">jakarta.jms.JMSProducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1"> interface</span></span></li>
<li><span class="koboSpan" id="kobo.468.1">How to receive messages from a message queue via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">jakarta.jms.JMSConsumer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> interface</span></span></li>
<li><span class="koboSpan" id="kobo.471.1">How to asynchronously receive messages from a message queue by implementing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">jakarta.jms.MessageListener</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1"> interface</span></span></li>
<li><span class="koboSpan" id="kobo.474.1">How to use the preceding interfaces to send and receive messages to and from a </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">message topic</span></span></li>
<li><span class="koboSpan" id="kobo.476.1">How to browse messages in a message queue without removing the messages from the queue via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">jakarta.jms.QueueBrowser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.478.1"> interface</span></span></li>
<li><span class="koboSpan" id="kobo.479.1">How to set up and interact with durable subscriptions to </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">messaging topics</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.481.1">Armed with the knowledge in this chapter, we can now implement asynchronous communication between processes with </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">Jakarta Messaging.</span></span></p>
</div>
</body></html>