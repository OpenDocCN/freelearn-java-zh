<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer015" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-15" lang="en-GB"><a id="_idTextAnchor014" class="pcalibre pcalibre2 pcalibre1 calibre6"/>1</h1>
<h1 id="_idParaDest-16" lang="en-GB" class="calibre5"><a id="_idTextAnchor015" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Different Parts of the Java Memory</h1>
<p lang="en-GB" class="calibre4">Do you know the phenomenon of having to restart an application to boost the performance of that application? If so, you may have experienced the outcome of poor <strong class="bold" lang="">memory management</strong>: the<a id="_idIndexMarker000" class="pcalibre pcalibre2 pcalibre1 calibre6"/> memory getting full and the application slowing down. This is not always why applications slow down – other causes such as processing data from a server or a bottleneck in the network, among other things, play a role – but memory management problems are a usual suspect of degrading <span lang="">application performance.</span></p>
<p lang="en-GB" class="calibre4">You’ve probably heard of memory in the field of computer science before. That makes sense because computers have memory and they use this memory to store and access data while running programs (which in their turn are <span lang="">data too!).</span></p>
<p lang="en-GB" class="calibre4">So, when does an application use memory? Well, for example, let’s say you’d like to run an application that is going to process a huge video file. If you do this with your activity monitoring application (for example, Activity Monitor on macOS or Task Manager on Windows) open, you’ll see that the used memory increases once you open the application and load the video. Memory is a finite resource on your computer and once your computer runs out of it, it <span lang="">becomes slow.</span></p>
<p lang="en-GB" class="calibre4">There are many ways to improve the performance of an application. A deeper understanding of how exactly this memory works is one of the ways that could help you improve the performance of your applications. Memory that is used efficiently by using good practices in coding is going to boost the performance of your application. So, coding well and being mindful of how the memory works should always be the first way to achieve high performance when it comes to memory management. There is another way in which Java memory management can be influenced<a id="_idIndexMarker001" class="pcalibre pcalibre2 pcalibre1 calibre6"/> and that is by configuring the <strong class="bold" lang="">Java Virtual Machine</strong> (<strong class="bold" lang="">JVM</strong>), which takes care of the <strong class="bold" lang="">Java memory</strong>. This <a id="_idIndexMarker002" class="pcalibre pcalibre2 pcalibre1 calibre6"/>is something that we’ll cover in <a href="B18762_06.xhtml#_idTextAnchor086" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 6</em></span></a> when we’re ready <span lang="">for it.</span></p>
<p lang="en-GB" class="calibre4">The efficient handling of Java memory is of crucial importance for the performance of a Java application. In Java, this is especially the case because it comes with expensive processes such as garbage collection, which again, we’ll see later after gaining enough basic knowledge to <span lang="">comprehend it.</span></p>
<p lang="en-GB" class="calibre4">Memory management is <a id="_idIndexMarker003" class="pcalibre pcalibre2 pcalibre1 calibre6"/>also important for data integrity in a concurrent context. Don’t worry if this sounds very complicated at the moment. By the end of this book, you’ll understand what is meant <span lang="">by this.</span></p>
<p lang="en-GB" class="calibre4">So, to optimize the usage of our application’s Java memory, we’ll first need to understand what this memory looks like and gain knowledge of the basic processes with the memory. In this chapter, we’ll do just that. We’re going to explore the different parts of Java memory and how we use this in our day-to-day coding. You’ll get a good overview of Java memory and you’ll be ready for the deep dive that’s coming in the next chapters. In order to do so, we’ll cover the <span lang="">following topics:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Understanding computer memory and <span lang="">Java memory</span></li>
<li lang="en-GB" class="calibre11">Creating variables <span lang="">in Java</span></li>
<li lang="en-GB" class="calibre11">Storing variables on <span lang="">the stack</span></li>
<li lang="en-GB" class="calibre11">Creating objects <span lang="">in Java</span></li>
<li lang="en-GB" class="calibre11">Storing objects on <span lang="">the heap</span></li>
<li lang="en-GB" class="calibre11">Exploring <span lang="">the Metaspace</span></li>
</ul>
<h1 id="_idParaDest-17" lang="en-GB" class="calibre5"><a id="_idTextAnchor016" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Technical requirements</h1>
<p lang="en-GB" class="calibre4">The code for this chapter can be found on GitHub <span lang="">at </span><span lang="">PacktPublishing/B18762_Java-Memory-Management</span><span lang="">.</span></p>
<h1 id="_idParaDest-18" lang="en-GB" class="calibre5"><a id="_idTextAnchor017" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Understanding computer memory and Java memory</h1>
<p lang="en-GB" class="calibre4">First things first – running applications, Java or not, requires computer memory. The application’s memory is the physical memory of the computer. Having more knowledge about the memory of the computer is going to help in our understanding of Java memory. Therefore, let’s discuss the concept of memory and Java memory in a bit <span lang="">more detail.</span></p>
<h2 id="_idParaDest-19" lang="en-GB" class="calibre7"><a id="_idTextAnchor018" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Computer memory</h2>
<p lang="en-GB" class="calibre4">Chances are<a id="_idIndexMarker004" class="pcalibre pcalibre2 pcalibre1 calibre6"/> that you already know this, but just to reiterate: a computer has memory. This is the part of the computer that is used for storing information that is used for executing processes. We also call this the main memory or sometimes primary storage. An important point to make here is that this is different from computer storage, where long-term information is stored. This storage is long-term because the HDD storage stores the information magnetically and the SDD can be qualified<a id="_idIndexMarker005" class="pcalibre pcalibre2 pcalibre1 calibre6"/> as <strong class="bold" lang="">Electrically Erasable Programmable Read-Only Memory</strong> (<strong class="bold" lang="">EEPROM</strong>). They don’t need constant power to persist the data. On the other hand, one common type of main memory, <strong class="bold" lang="">Random Access Memory</strong> (<strong class="bold" lang="">RAM</strong>), needs<a id="_idIndexMarker006" class="pcalibre pcalibre2 pcalibre1 calibre6"/> constant electricity power to <span lang="">persist data.</span></p>
<p lang="en-GB" class="calibre4">This can be compared to our human brains, at least partially. We have long-term and short-term memory. We use our long-term memory for our, well, memories – for example, a cherished childhood memory of your father pushing you around playfully in a wheelbarrow while your mother quoted from your most beloved storybook while you were wearing your favorite outfit that you had as a 3-year-old (magical, let’s save the rest for my memoir or therapist). Then there’s short-term memory, which is great when you want to remember the six digits for a two-step verification process and even better if you can’t recall them a few <span lang="">minutes later.</span></p>
<h2 id="_idParaDest-20" lang="en-GB" class="calibre7"><a id="_idTextAnchor019" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Accessing the main memory</h2>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker007" class="pcalibre pcalibre2 pcalibre1 calibre6"/>computer, or actually the CPU of the computer, can access the main memory much faster than it can access the permanent storage space. In the main memory, programs are currently open and the data that they’re using is <span lang="">being stored.</span></p>
<p lang="en-GB" class="calibre4">Maybe you can recall starting your computer and opening an app you use daily for the first time that day and realizing that it takes a few seconds to boot. If you close it, perhaps accidentally, and open it again right after closing it, it is a lot faster. The main memory works as some sort of cache or buffer, and this explains the phenomenon of the shorter load time the second time. The second time, it can open it from the main memory instead of from the storage, which proves, or at least supports, the point that the main memory <span lang="">is faster.</span></p>
<p lang="en-GB" class="calibre4">The great news is that you don’t need to understand the tiniest details of the computer memory, but a rough overview <span lang="">will help.</span></p>
<h2 id="_idParaDest-21" lang="en-GB" class="calibre7"><a id="_idTextAnchor020" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Overview of the main memory</h2>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker008" class="pcalibre pcalibre2 pcalibre1 calibre6"/>most common part of the main memory is the RAM. The RAM is a huge part of what determines the performance of a computer. Running or active applications need RAM for storing and accessing data. This memory can be accessed very quickly by the applications and processes. If there is enough RAM available and if<a id="_idIndexMarker009" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the <strong class="bold" lang="">Operating System</strong> (<strong class="bold" lang="">OS</strong>) does a great job of managing the RAM, your applications will reach their <span lang="">performance potential.</span></p>
<p lang="en-GB" class="calibre4">You can see how much RAM is available by having a look at your monitoring app. For me, that is Activity Monitor. As you can see in the following figure, my computer is using quite a bit of memory at <span lang="">the moment:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer006">
<img alt="Figure 1.1 – Screenshot of Activity Monitor on macOS 12.5" src="image/Figure_1.1_B18762.jpg" class="calibre18"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Screenshot of Activity Monitor on macOS 12.5</p>
<p lang="en-GB" class="calibre4">I have sorted the processes from high memory to low. At the bottom, you can see a summary of the available memory and the memory used. To be honest, this seems a little high and I should probably investigate it after writing <span lang="">this chapter.</span></p>
<p lang="en-GB" class="calibre4">Why <a id="_idIndexMarker010" class="pcalibre pcalibre2 pcalibre1 calibre6"/>should I investigate this if I still have a lot of memory available? Well, if the RAM gets too full, the applications that are running can only do so very slowly. This is something you’re likely to have experienced already when you've run more or heavier applications than your computer <span lang="">specifications allowed.</span></p>
<p lang="en-GB" class="calibre4">The RAM is volatile. This means that when you turn off the power, the information is gone. The main memory does not only consist of<a id="_idIndexMarker011" class="pcalibre pcalibre2 pcalibre1 calibre6"/> RAM. The <strong class="bold" lang="">Read-Only Memory</strong> (<strong class="bold" lang="">ROM</strong>) is part of the main memory too, but it’s non-volatile. It contains instructions that the computer needs to start, so luckily this does not disappear when we turn the <span lang="">power off!</span></p>
<p class="callout-heading" lang="en-GB">Fun fact</p>
<p class="callout" lang="en-GB">We refer to the main memory as RAM, which is very common terminology, but now you know it’s technically incorrect! A fun <span lang="">fact indeed.</span></p>
<h2 id="_idParaDest-22" lang="en-GB" class="calibre7"><a id="_idTextAnchor021" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Java memory and the JVM</h2>
<p lang="en-GB" class="calibre4">You may <a id="_idIndexMarker012" class="pcalibre pcalibre2 pcalibre1 calibre6"/>wonder if we are still going to cover Java memory – and yes, we are! The Java memory is somewhat similar to, but also different from, the computer’s memory model. However, before we talk about Java memory, I’ll need to explain what the JVM is. I really appreciate your patience, I <span lang="">must say.</span></p>
<h2 id="_idParaDest-23" lang="en-GB" class="calibre7"><a id="_idTextAnchor022" class="pcalibre pcalibre2 pcalibre1 calibre6"/>The JVM</h2>
<p lang="en-GB" class="calibre4">The JVM <a id="_idIndexMarker013" class="pcalibre pcalibre2 pcalibre1 calibre6"/>executes Java applications. Does that mean that the JVM understands Java? No, not at all! It understands bytecode – the <strong class="source-inline" lang="">.class</strong> files. This means the compiled Java programs. The code of some other languages, such as <strong class="bold" lang="">Kotlin</strong>, is<a id="_idIndexMarker014" class="pcalibre pcalibre2 pcalibre1 calibre6"/> compiled to JVM bytecode as well and can therefore be interpreted by the JVM. This is why they’re sometimes referred to as JVM languages, such as Java, Kotlin, and Scala, <span lang="">among others.</span></p>
<p lang="en-GB" class="calibre4">The steps can be seen in <span lang=""><em class="italic" lang="">Figure 1</em></span><span lang=""><em class="italic" lang="">.2</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer007">
<img alt="Figure 1.2 – Write once, run anywhere" src="image/Figure_1.2_B18762.jpg" class="calibre19"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Write once, run anywhere</p>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker015" class="pcalibre pcalibre2 pcalibre1 calibre6"/>source code (in the figure, we assume this is Java source code) is being compiled by the Java compiler. The result is <strong class="source-inline" lang="">.class</strong> files containing bytecode. This bytecode can be interpreted by the JVM. Every platform, whether macOS, Windows, or Linux, has its own version of the JVM to execute the bytecode. This means that the application doesn’t need to be modified to run on different environments because the platform-specific JVM takes care <span lang="">of that.</span></p>
<p lang="en-GB" class="calibre4">The JVM is actually why Java once was famous and beloved for its <em class="italic" lang="">write once, run anywhere</em> principle. The reason Java is not so famous for this anymore is that it’s sort of normal for languages to work this way nowadays. Any platform with a JVM installed on it could run Java since the JVM takes care of translating it to the machine it’s <span lang="">running on.</span></p>
<p lang="en-GB" class="calibre4">I typically <a id="_idIndexMarker016" class="pcalibre pcalibre2 pcalibre1 calibre6"/>compare this to a travel plug adapter. Plugs don’t fit globally because different regions use different sockets. You can use your own adapter wherever you are when you have the right travel adapter plug with you. In this case, the travel adapter would be the JVM. The “<em class="italic" lang="">wherever you are</em>” would be the platform you’re trying to run Java on and your adapter would be your <span lang="">Java program.</span></p>
<p lang="en-GB" class="calibre4">Let’s see the basics of how the JVM deals with <span lang="">memory management.</span></p>
<h2 id="_idParaDest-24" lang="en-GB" class="calibre7"><a id="_idTextAnchor023" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Memory management and the JVM</h2>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker017" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Java memory stores the data that is <a id="_idIndexMarker018" class="pcalibre pcalibre2 pcalibre1 calibre6"/>required to run Java applications. All the instances of classes that live in a Java application are stored in the Java memory. This is also true for primitive values. What about constants? Also stored in the Java memory! And what about the method codes, native methods, field data, method data, and the order in which methods are being executed? You can probably guess that they are all stored in <span lang="">Java memory!</span></p>
<p lang="en-GB" class="calibre4">One of the tasks of the JVM is managing the Java memory. Without this memory management, no memory could be allocated and objects couldn’t be stored. Even if that part was in place, it would never be cleaned up. So, cleaning up the memory, which is also called the <em class="italic" lang="">deallocation of objects</em>, is of great importance for running Java code. Without it, the code can’t run, or if it’s only allocated, it will get full and the program will run out of memory. How exactly this works is something will learn in <a href="B18762_04.xhtml#_idTextAnchor057" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 4</em></span></a> when we discuss the deallocation process – called <span lang=""><em class="italic" lang="">garbage collection</em></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Long story short: memory management is important. It is one of the very important tasks of the JVM. Actually, nowadays, we sort of take automatic memory management for granted, but in its early days, this was very new and special. Let’s have a look at what could happen if the JVM was not managing the memory <span lang="">for us.</span></p>
<h2 id="_idParaDest-25" lang="en-GB" class="calibre7"><a id="_idTextAnchor024" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Memory management before Java</h2>
<p lang="en-GB" class="calibre4">In older<a id="_idIndexMarker019" class="pcalibre pcalibre2 pcalibre1 calibre6"/> languages, such as C and C++, memory management was the responsibility of the developer. This meant that allocation and deallocation of a memory area had to be done using a command. For example, in C, the following code snippet shows how you could allocate some memory and assign a value to it. Please note that this is just a small example to illustrate how awesome <a id="_idIndexMarker020" class="pcalibre pcalibre2 pcalibre1 calibre6"/>automatic garbage collection is and in no way a complete guide to how to do memory allocation in C – there’s a lot more <span lang="">to it:</span></p>
<pre class="source-code" lang="en-GB">int* x;</pre>
<pre class="source-code" lang="en-GB">x = (int*)malloc(4 * sizeof(int));</pre>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">int*</strong> means that <strong class="source-inline" lang="">x</strong> holds the value of the pointer to the base address of the <span lang="">memory block.</span></p>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">malloc</strong>, which stands for memory allocation, is a function that is used to allocate a block of memory with a specified size. In this case, that specified size is four times the size of <strong class="source-inline" lang="">int</strong>. The function returns the <span lang="">base address.</span></p>
<p lang="en-GB" class="calibre4">If we would then like to assign a value to the memory allocation, we need to do this by using <strong class="source-inline" lang="">*x</strong> – otherwise, we will be overriding <span lang="">the location:</span></p>
<pre class="source-code" lang="en-GB">*x = 5;</pre>
<pre class="source-code" lang="en-GB">printf("Our value: %d\n", *x);</pre>
<p lang="en-GB" class="calibre4">The preceding code snippet assigns a value of <strong class="source-inline" lang="">5</strong> to the memory location that <strong class="source-inline" lang="">x</strong> is pointing to. So, if we then go ahead and print the value stored in that location (<strong class="source-inline" lang="">*x</strong>), we will see the value of <strong class="source-inline" lang="">5</strong>. It’s just <strong class="source-inline" lang="">x</strong>, not <strong class="source-inline" lang="">*x</strong>, that is the <span lang="">memory location.</span></p>
<p lang="en-GB" class="calibre4">When we no longer need <strong class="source-inline" lang="">*x</strong> to hold the memory location, we need to manually free the memory. If we don’t do this, the memory is going to be unavailable and used up unnecessarily. Here’s how we could free <span lang="">the memory:</span></p>
<pre class="source-code" lang="en-GB">free(x);</pre>
<pre class="source-code" lang="en-GB">x = NULL;</pre>
<p lang="en-GB" class="calibre4">We use the <strong class="source-inline" lang="">free</strong> function to make the memory available again so that it can be reallocated later when we request another block of memory. Are we done then? No, we’re not. We are still holding the pointer to that memory location. Since the memory location is freed up right now, it could be overwritten with something else and we wouldn't know what was stored at that point. Therefore, we set our pointer <span lang="">to </span><span lang=""><strong class="source-inline" lang="">NULL</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">So, what would <strong class="source-inline" lang="">x</strong> be pointing at after freeing up the memory? Well, the very same address – but what is in there? That’s uncertain. Depending on how the freeing works, it could either be empty or the old value if it’s not overwritten yet, but when it’s overwritten, it would be whatever it was overwritten with. In other words: a big surprise! Of <a id="_idIndexMarker021" class="pcalibre pcalibre2 pcalibre1 calibre6"/>course, I usually love surprises, but typically not so much when it comes to the value of the variables in <span lang="">my code.</span></p>
<p lang="en-GB" class="calibre4">Here are some<a id="_idIndexMarker022" class="pcalibre pcalibre2 pcalibre1 calibre6"/> common problems with doing memory <span lang="">management manually:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Dangling pointers</strong>: This is what happens if you don’t set the variable holding the pointer to <strong class="source-inline" lang="">NULL</strong> after freeing up the <span lang="">memory address.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Memory leaks</strong>: This is what happens if you don’t free up memory that is no longer needed. It doesn’t become available again and it remains blocked unnecessarily. Eventually, you can run out of memory by holding all the values you <span lang="">don’t need.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Boilerplate code</strong>: You have a lot of code in the code base that deals with allocation and deallocation, but not so much with your business logic. All this code needs to <span lang="">be maintained.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Error-prone</strong>: Even though developers are (usually) aware of what needs to happen, it’s easy to make a small mistake and forget to free up the memory or set a pointer to <strong class="source-inline" lang="">NULL</strong>, <span lang="">for example.</span></li>
</ul>
<p lang="en-GB" class="calibre4">There are other common pitfalls, but I believe that this is more than enough to appreciate the JVM and its garbage collector and automatic allocation. Let’s see what is implemented in the JVM to be able to do <span lang="">all this.</span></p>
<h2 id="_idParaDest-26" lang="en-GB" class="calibre7"><a id="_idTextAnchor025" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Understanding the JVM’s components for memory management</h2>
<p lang="en-GB" class="calibre4">To be<a id="_idIndexMarker023" class="pcalibre pcalibre2 pcalibre1 calibre6"/> able to execute applications, the JVM has roughly three components in place. One is used to load all the classes, the <strong class="bold" lang="">class loader</strong>. This is <a id="_idIndexMarker024" class="pcalibre pcalibre2 pcalibre1 calibre6"/>actually a complex process in itself; the classes are loaded and the bytecode is verified. The<a id="_idIndexMarker025" class="pcalibre pcalibre2 pcalibre1 calibre6"/> loading of the classes and the execution of the bytecode requires memory. This memory is needed for storing the class data, memory allocation, and the instructions that are being executed. This is<a id="_idIndexMarker026" class="pcalibre pcalibre2 pcalibre1 calibre6"/> what the <strong class="bold" lang="">runtime data areas</strong> component is for. This is the part that this book is all about: the Java memory. When the classes are loaded, the files need to be executed. The component that executes the bytecode after it’s loaded in the main memory using the first two components is commonly referred to as the <strong class="bold" lang="">execution engine</strong>. The <a id="_idIndexMarker027" class="pcalibre pcalibre2 pcalibre1 calibre6"/>execution engine interacts with the <strong class="bold" lang="">Java Native Interface</strong> (<strong class="bold" lang="">JNI</strong>) to<a id="_idIndexMarker028" class="pcalibre pcalibre2 pcalibre1 calibre6"/> use the <a id="_idIndexMarker029" class="pcalibre pcalibre2 pcalibre1 calibre6"/>native libraries that are required for executing the bytecode. These processes and the <a id="_idIndexMarker030" class="pcalibre pcalibre2 pcalibre1 calibre6"/>steps between them are depicted in <span lang=""><em class="italic" lang="">Figure 1</em></span><span lang=""><em class="italic" lang="">.3</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer008">
<img alt="Figure 1.3 – Overview of the JVM components for application execution" src="image/Figure_1.3_B18762.jpg" class="calibre20"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Overview of the JVM components for application execution</p>
<p lang="en-GB" class="calibre4">Now that we know what elements the memory roughly consists of, let’s explore the most important component for memory management in more detail: the runtime <span lang="">data area.</span></p>
<h2 id="_idParaDest-27" lang="en-GB" class="calibre7"><a id="_idTextAnchor026" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Runtime data area</h2>
<p lang="en-GB" class="calibre4">Here are<a id="_idIndexMarker031" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the runtime data areas of <span lang="">the </span><span lang=""><a id="_idIndexMarker032" class="pcalibre pcalibre2 pcalibre1 calibre6"/></span><span lang="">JVM:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><span lang="">The stack</span></li>
<li lang="en-GB" class="calibre11"><span lang="">The heap</span></li>
<li lang="en-GB" class="calibre11">The <span lang="">method area/Metaspace</span></li>
<li lang="en-GB" class="calibre11">The runtime <span lang="">constant pool</span></li>
<li lang="en-GB" class="calibre11">The program <span lang="">counter register</span></li>
<li lang="en-GB" class="calibre11">The native <span lang="">method stack</span></li>
</ul>
<p lang="en-GB" class="calibre4">The different parts of the Java memory are depicted in <span lang=""><em class="italic" lang="">Figure 1</em></span><span lang=""><em class="italic" lang="">.4</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer009">
<img alt="Figure 1.4 – Overview of the different runtime areas" src="image/Figure_1.4_B18762.jpg" class="calibre21"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Overview of the different runtime areas</p>
<p lang="en-GB" class="calibre4">The memory consists of different parts as shown in the picture. All these parts are needed for the Java application to run. Let us take a detailed look at each of these <span lang="">memory parts.</span></p>
<h3 lang="en-GB" class="calibre8">The heap</h3>
<p lang="en-GB" class="calibre4">When<a id="_idIndexMarker033" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the JVM starts, it reserves a piece of the RAM for the Java application to use for dynamic memory allocation. This memory is called the heap. This is the area where the runtime data is stored. Class instances can be found on the heap. The JVM takes care of assigning space to the heap and cleaning it up with a process called garbage collection. Assigning space is also called allocation and freeing up this space again is also called deallocation. The deallocation of objects on the heap is handled <a id="_idIndexMarker034" class="pcalibre pcalibre2 pcalibre1 calibre6"/>by the garbage collection process of the JVM. The garbage collection works with different areas of the heap. These different areas and garbage collection are very interesting topics and we’ll discuss them in much more detail in <a href="B18762_03.xhtml#_idTextAnchor049" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 3</em></span></a> and <a href="B18762_04.xhtml#_idTextAnchor057" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 4</em></span></a><span lang="">.</span></p>
<h3 lang="en-GB" class="calibre8">The stack</h3>
<p lang="en-GB" class="calibre4">The stack, or <a id="_idIndexMarker035" class="pcalibre pcalibre2 pcalibre1 calibre6"/>more precisely, the JVM stack, is where the primitives and pointers to the heap are stored. For every method that is called, a frame gets created on a stack and this frame also holds the values for this method, such as partial results and <span lang="">return values.</span></p>
<p lang="en-GB" class="calibre4">There is not just one stack. Every thread in the application has its own thread. This is displayed in <span lang=""><em class="italic" lang="">Figure 1</em></span><span lang=""><em class="italic" lang="">.5</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer010">
<img alt="Figure 1.5 – Stack area containing stacks for every thread" src="image/Figure_1.5_B18762.jpg" class="calibre22"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Stack area containing stacks for every thread</p>
<p lang="en-GB" class="calibre4">A thread is a path of execution. When an application has multiple threads, this means that multiple things are happening at the same time. This happening at the same time in an application is a very important concept <a id="_idIndexMarker036" class="pcalibre pcalibre2 pcalibre1 calibre6"/><span lang="">called </span><span lang=""><strong class="bold" lang="">concurrency</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">This means that the stack area of the memory actually contains a lot of stacks – one for every thread. The<a id="_idIndexMarker037" class="pcalibre pcalibre2 pcalibre1 calibre6"/> threads can only access their own stacks and the stacks cannot have links <span lang="">between them.</span></p>
<p lang="en-GB" class="calibre4">So, the stack stores the values necessary for method execution and every thread has its own stack. The next part of the runtime data area that we’re going to look at is the <span lang="">method area.</span></p>
<h3 lang="en-GB" class="calibre8">The method area (Metaspace)</h3>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker038" class="pcalibre pcalibre2 pcalibre1 calibre6"/>method area is where the runtime representation of classes is stored. The method area contains the runtime code, static variables, constants pools, and constructor code. To summarize: this is where the class’s metadata is stored. All threads share this method area. The JVM only specifies the <a id="_idIndexMarker039" class="pcalibre pcalibre2 pcalibre1 calibre6"/>method area, but the implementation we have been dealing with since <strong class="bold" lang="">Java 8</strong> is called<a id="_idIndexMarker040" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the Metaspace. The old name for this area was<a id="_idIndexMarker041" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the <strong class="bold" lang="">PermGen</strong> (as in, <strong class="bold" lang="">permanent generation</strong>) space. There are actually also some differences between PermGen and the Metaspace, but these juicy details are for later. Don’t we all love a <span lang="">good cliffhanger?</span></p>
<h3 lang="en-GB" class="calibre8">The PC register</h3>
<p lang="en-GB" class="calibre4">The <strong class="bold" lang="">Program Counter</strong> (<strong class="bold" lang="">PC</strong>) register <a id="_idIndexMarker042" class="pcalibre pcalibre2 pcalibre1 calibre6"/>knows<a id="_idIndexMarker043" class="pcalibre pcalibre2 pcalibre1 calibre6"/> what code is being executed by holding the address of the instruction that is being executed in its thread. In <span lang=""><em class="italic" lang="">Figure 1</em></span><em class="italic" lang="">.6</em>, you can see a depiction <span lang="">of this:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer011">
<img alt="Figure 1.6 – A PC register containing a register for every thread" src="image/Figure_1.6_B18762.jpg" class="calibre23"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.6 – A PC register containing a register for every thread</p>
<p lang="en-GB" class="calibre4">Every <a id="_idIndexMarker044" class="pcalibre pcalibre2 pcalibre1 calibre6"/>thread<a id="_idIndexMarker045" class="pcalibre pcalibre2 pcalibre1 calibre6"/> has its own PC register, sometimes also referred to as the call stack. It knows the sequence of statements that needs to be executed and which one it is executing currently. This is why we need a separate one for every thread – with just one PC register, we couldn’t execute multiple threads at the <span lang="">same time!</span></p>
<p lang="en-GB" class="calibre4">This is similar to the stack area, as you can see when you compare <span lang=""><em class="italic" lang="">Figure 1</em></span><em class="italic" lang="">.5</em> and <span lang=""><em class="italic" lang="">Figure 1</em></span><span lang=""><em class="italic" lang="">.6</em></span><span lang="">.</span></p>
<h3 lang="en-GB" class="calibre8">The native method stack</h3>
<p lang="en-GB" class="calibre4">There’s <a id="_idIndexMarker046" class="pcalibre pcalibre2 pcalibre1 calibre6"/>also a native method stack, also known as a <strong class="bold" lang="">C stack</strong>. It is<a id="_idIndexMarker047" class="pcalibre pcalibre2 pcalibre1 calibre6"/> there for the native code that is executed. Native code is part of the implementation that is not written in Java, but for example, in C. These are the stacks that store the values for the native code, just as the JVM stack does for the Java code. Again, every thread has its own. How these are implemented depends on the specific implementation of the JVM. Some JVMs don’t support native code; clearly, they don’t need native stacks either. This can be found in the documentation of the JVM that you <span lang="">are using.</span></p>
<p lang="en-GB" class="calibre4">With this, we <a id="_idIndexMarker048" class="pcalibre pcalibre2 pcalibre1 calibre6"/>have seen the different<a id="_idIndexMarker049" class="pcalibre pcalibre2 pcalibre1 calibre6"/> parts of the Java runtime data area in a bit more detail. Chances are that a lot of new information has been thrown at you at this point, and this can be tough! Before we continue, let me explain why we even want to <span lang="">know this.</span></p>
<p lang="en-GB" class="calibre4">At this point, you might be wondering what I’m still waiting for and be itching to get started – and you’re right! We’ll be discussing the basics of memory management, stack and heap memory, and the Metaspace in more detail in this chapter, but first, we need to have a look at creating variables <span lang="">in Java.</span></p>
<h1 id="_idParaDest-28" lang="en-GB" class="calibre5"><a id="_idTextAnchor027" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Creating variables in Java</h1>
<p lang="en-GB" class="calibre4">Creating variables in <a id="_idIndexMarker050" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Java means that we have to declare a <a id="_idIndexMarker051" class="pcalibre pcalibre2 pcalibre1 calibre6"/>variable. If we also want to use it, we have to initialize it. As you most likely know, declaration is the process of assigning a type and a name. Initializing is about giving the variable an <span lang="">actual value:</span></p>
<pre class="source-code" lang="en-GB">int number = 3;</pre>
<pre class="source-code" lang="en-GB">char letter = 'z';</pre>
<p lang="en-GB" class="calibre4">Here, we declare the variable and initialize it on the same line. We declare it with the type and name. The types here are <strong class="source-inline" lang="">int</strong> and <strong class="source-inline" lang="">char</strong> and the variable names are <strong class="source-inline" lang="">number</strong> and <strong class="source-inline" lang="">letter</strong>. This can also be separated over multiple lines <span lang="">as follows:</span></p>
<pre class="source-code" lang="en-GB">double percentage;</pre>
<pre class="source-code" lang="en-GB">percentage = 8.6;</pre>
<p lang="en-GB" class="calibre4">The JVM doesn’t check the types anymore – this is done by the compiler prior to running the application. There is actually a difference between the storage of primitive types and reference types. This is what we’re going to look <span lang="">at now.</span></p>
<h2 id="_idParaDest-29" lang="en-GB" class="calibre7"><a id="_idTextAnchor028" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Primitives and reference types</h2>
<p lang="en-GB" class="calibre4">The JVM deals <a id="_idIndexMarker052" class="pcalibre pcalibre2 pcalibre1 calibre6"/>with two types of variables: primitives and reference types. There <a id="_idIndexMarker053" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are eight primitive types <span lang="">in Java:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">int</strong></span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">byte</strong></span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">short</strong></span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">long</strong></span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">float</strong></span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">double</strong></span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">boolean</strong></span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">char</strong></span></li>
</ul>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker054" class="pcalibre pcalibre2 pcalibre1 calibre6"/>primitive types<a id="_idIndexMarker055" class="pcalibre pcalibre2 pcalibre1 calibre6"/> store just the value, and they are limited to eight types. There are also reference types. Reference types are instances of classes. You can create your own classes. Therefore, there’s no real limit to how many reference types <span lang="">there are.</span></p>
<p lang="en-GB" class="calibre4">When you create variables, there can be two types of values stored in them: primitive values and reference values. The primitive values have the type of one of the primitives. The reference value is holding a pointer to an <span lang="">object location.</span></p>
<p lang="en-GB" class="calibre4">References come in <a id="_idIndexMarker056" class="pcalibre pcalibre2 pcalibre1 calibre6"/><span lang="">four flavors:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><span lang="">Class references</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Array references</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Interface references</span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="source-inline" lang="">null</strong></span></li>
</ul>
<p lang="en-GB" class="calibre4">Class<a id="_idIndexMarker057" class="pcalibre pcalibre2 pcalibre1 calibre6"/> reference types hold the (dynamically) created class objects. The array reference type has a component type. This is the type of the array. If the component type is not of the array type, it is called the element type. The array reference always has a single dimension, but the component type can be another array, creating multi-dimensional arrays. It doesn’t matter how many dimensions the array has; the last component type is not of the array type and is therefore the element type. This element type can be one of three types: primitive, class, <span lang="">or interface.</span></p>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">null</strong> is the special case where the reference is not pointing to anything. The value of the<a id="_idIndexMarker058" class="pcalibre pcalibre2 pcalibre1 calibre6"/> reference <a id="_idIndexMarker059" class="pcalibre pcalibre2 pcalibre1 calibre6"/>is <span lang="">then </span><span lang=""><strong class="source-inline" lang="">null</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">How are these variables stored? Primitive and reference variables are stored on the stack. The actual object is stored on the heap. Let’s first have a look at storing variables on <span lang="">the stack.</span></p>
<h1 id="_idParaDest-30" lang="en-GB" class="calibre5"><a id="_idTextAnchor029" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Storing variables on the stack</h1>
<p lang="en-GB" class="calibre4">Variables <a id="_idIndexMarker060" class="pcalibre pcalibre2 pcalibre1 calibre6"/>used in a method are stored on the stack. The <a id="_idIndexMarker061" class="pcalibre pcalibre2 pcalibre1 calibre6"/>stack memory is the memory that is used for executing methods. In <span lang=""><em class="italic" lang="">Figure 1</em></span><em class="italic" lang="">.7</em>, we have shown a stack area for three threads, each containing <span lang="">several frames.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer012">
<img alt="Figure 1.7 – Overview of the frames in the stack area for three threads" src="image/Figure_1.7_B18762.jpg" class="calibre24"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Overview of the frames in the stack area for three threads</p>
<p lang="en-GB" class="calibre4">Inside a method, primitives and references exist. Every thread in the application has its own stack. The <a id="_idIndexMarker062" class="pcalibre pcalibre2 pcalibre1 calibre6"/>stack consists of frames. Every method that gets invoked comes <a id="_idIndexMarker063" class="pcalibre pcalibre2 pcalibre1 calibre6"/>with a new frame on the stack. When the method execution is finished, the frame <span lang="">is removed.</span></p>
<p lang="en-GB" class="calibre4">If the stack memory is too small to store what is needed for the frame, <strong class="source-inline" lang="">StackOverFlowError</strong> is thrown. When there is not enough space for a new stack for a new thread, <strong class="source-inline" lang="">OutOfMemoryError</strong> is thrown. The method that currently is being executed by a thread is called the <a id="_idIndexMarker064" class="pcalibre pcalibre2 pcalibre1 calibre6"/>current method and its data is held in the <span lang="">current frame.</span></p>
<h2 id="_idParaDest-31" lang="en-GB" class="calibre7"><a id="_idTextAnchor030" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Current frame and current method</h2>
<p lang="en-GB" class="calibre4">The reason that a <a id="_idIndexMarker065" class="pcalibre pcalibre2 pcalibre1 calibre6"/>stack is named as such is that it can only access the top frame of the stack. You can compare this to a stack of plates where you can only (safely) take plates from the top. The top frame is called the current frame as it belongs to the current method – the method that is being executed at <span lang="">that time.</span></p>
<p lang="en-GB" class="calibre4">If a method that is being executed calls another method, a frame gets placed on top of the frame. This new frame becomes the current frame since the newly invoked method is the current method that is <span lang="">being executed.</span></p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 1</em></span><em class="italic" lang="">.7</em>, there are three current frames, because there are three threads. The current frames are the ones on top. So, let’s <a id="_idIndexMarker066" class="pcalibre pcalibre2 pcalibre1 calibre6"/>see <span lang="">the following:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">The <strong class="bold" lang="">Frame for method y</strong> is for <span lang=""><strong class="bold" lang="">thread 1</strong></span></li>
<li lang="en-GB" class="calibre11">The <strong class="bold" lang="">Frame for method c</strong> is for <span lang=""><strong class="bold" lang="">thread 2</strong></span></li>
<li lang="en-GB" class="calibre11">The <strong class="bold" lang="">Frame for method k</strong> is for <span lang=""><strong class="bold" lang="">thread 3</strong></span></li>
</ul>
<p lang="en-GB" class="calibre4">When the method is executed, it gets removed. The previous frame then becomes the current frame again since the method that has called the other method is the one that gets the control back for the moment and is the method that is being executed at that time (the <span lang="">current method).</span></p>
<h2 id="_idParaDest-32" lang="en-GB" class="calibre7"><a id="_idTextAnchor031" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Elements of the frame</h2>
<p lang="en-GB" class="calibre4">A frame<a id="_idIndexMarker067" class="pcalibre pcalibre2 pcalibre1 calibre6"/> contains a number of elements. These elements are needed to store all the necessary data for a method to be executed. An overview of all the elements can be seen in <span lang=""><em class="italic" lang="">Figure 1</em></span><span lang=""><em class="italic" lang="">.8</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer013">
<img alt="Figure 1.8 – Schematic overview of a stack frame" src="image/Figure_1.8_B18762.jpg" class="calibre25"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Schematic overview of a stack frame</p>
<p lang="en-GB" class="calibre4">As you can see, a frame has a local variable array, an operand stack, and frame data. Let us explore the separate elements of the frame in <span lang="">more detail.</span></p>
<h3 lang="en-GB" class="calibre8">The array of local variables</h3>
<p lang="en-GB" class="calibre4">The<a id="_idIndexMarker068" class="pcalibre pcalibre2 pcalibre1 calibre6"/> local variables of the frame are stored in an array. This array length is set during compile time. The array has single and double spots. Single spots are for types of <strong class="source-inline" lang="">int</strong>, <strong class="source-inline" lang="">short</strong>, <strong class="source-inline" lang="">char</strong>, <strong class="source-inline" lang="">float</strong>, <strong class="source-inline" lang="">byte</strong>, <strong class="source-inline" lang="">boolean</strong>, and <strong class="source-inline" lang="">reference</strong>. The double spots are for <strong class="source-inline" lang="">long</strong> and <strong class="source-inline" lang="">double</strong> (they are 64 bits <span lang="">in size).</span></p>
<p lang="en-GB" class="calibre4">The local variables can be accessed by their index. There are two types of methods: <strong class="source-inline" lang="">static</strong> methods (class methods) and <strong class="source-inline" lang="">instance</strong> methods. For these <strong class="source-inline" lang="">instance</strong> methods, the first element of the local variable array is always the reference to the object that they exist on, also known as <strong class="source-inline" lang="">this</strong>. Parameters that are given to the method start from index <strong class="source-inline" lang="">1</strong> on the local <span lang="">variable array.</span></p>
<p lang="en-GB" class="calibre4">For <strong class="source-inline" lang="">static</strong> methods, no instance needs to be provided to the frame, so they start with the parameters that were used to invoke them at <span lang="">index </span><span lang=""><strong class="source-inline" lang="">0</strong></span><span lang="">.</span></p>
<h3 lang="en-GB" class="calibre8">The operand stack</h3>
<p lang="en-GB" class="calibre4">This<a id="_idIndexMarker069" class="pcalibre pcalibre2 pcalibre1 calibre6"/> concept can be a bit rough, so bear with me. Every stack frame <a id="_idIndexMarker070" class="pcalibre pcalibre2 pcalibre1 calibre6"/>has an operand stack – a stack (operand stack) on the element (frame) of the stack – and this operand stack is used to write operands so that they can be, well, operated upon. This is where all the values <span lang="">fly around.</span></p>
<p lang="en-GB" class="calibre4">It begs for an<a id="_idIndexMarker071" class="pcalibre pcalibre2 pcalibre1 calibre6"/> example, so let’s have a look at one. When the<a id="_idIndexMarker072" class="pcalibre pcalibre2 pcalibre1 calibre6"/> frame is newly created, there is nothing on the operand stack, but let’s assume that the method for which the frame was created is going to do a basic mathematical operation, such as adding <em class="italic" lang="">x</em> <span lang="">and </span><span lang=""><em class="italic" lang="">y</em></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">x</strong> and <strong class="source-inline" lang="">y</strong> are local variables and their values are in the aforementioned array of local variables. In order to do the operation, their values need to be pushed to the operand stack – so, the value of <strong class="source-inline" lang="">x</strong> is going to be pushed first and the value of <strong class="source-inline" lang="">y</strong> is going to be <span lang="">pushed second.</span></p>
<p lang="en-GB" class="calibre4">The operand stack is a stack, so when it needs to access the variables, it can only grab them from the top of the stack. It pops <strong class="source-inline" lang="">y</strong> first and then pops <strong class="source-inline" lang="">x</strong>. After this, the operand stack is empty again. The operation that is being performed knows the order of the popped variables. When the operation is done, the result is pushed to the operand stack and it can be popped <span lang="">from there.</span></p>
<p lang="en-GB" class="calibre4">The operand stack is also used for other important operations, such as preparing parameters that need to be sent to a method as input and receiving the results that the <span lang="">methods return.</span></p>
<h3 lang="en-GB" class="calibre8">Frame data</h3>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker073" class="pcalibre pcalibre2 pcalibre1 calibre6"/>frame data consists of diverse data needed to execute the method. Some examples are a reference to the constant pool, how to normally return a method, and abruptly completed methods (<span lang="">or exceptions).</span></p>
<p lang="en-GB" class="calibre4">The first of these, a reference to the constant pool, requires special attention. A class file has all the symbolic references that need to be resolved in the runtime constant pool. This pool contains all the constants needed for running the class and it is generated by the compiler. It contains the names of identifiers in the class and the JVM uses this file during runtime to link the class to <span lang="">other classes.</span></p>
<p lang="en-GB" class="calibre4">Every frame has a reference to the constant pool of the current method at runtime. Since this is a runtime constant pool with symbolic references, linking needs to <span lang="">happen dynamically.</span></p>
<p lang="en-GB" class="calibre4">Let’s have a look at what the constant pool looks like for our silly <strong class="source-inline" lang="">Example</strong> class. Here is the code for our <span lang=""><strong class="source-inline" lang="">Example</strong></span><span lang=""> class:</span></p>
<pre class="source-code" lang="en-GB">package chapter1;</pre>
<pre class="source-code" lang="en-GB">public class Example {</pre>
<pre class="source-code" lang="en-GB">    public static void main(String[] args) {</pre>
<pre class="source-code" lang="en-GB">        int number = 3;</pre>
<pre class="source-code" lang="en-GB">        char letter = 'z';</pre>
<pre class="source-code" lang="en-GB">        double percentage;</pre>
<pre class="source-code" lang="en-GB">        percentage = 8.6;</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">By <a id="_idIndexMarker074" class="pcalibre pcalibre2 pcalibre1 calibre6"/>running the following command (after we compiled it with <strong class="source-inline" lang="">javac Example.java</strong>), we can see the <span lang="">constant pool:</span></p>
<pre class="source-code" lang="en-GB">javap -v Example.class</pre>
<p lang="en-GB" class="calibre4">Here, you can see <span lang="">the output:</span></p>
<pre class="source-code" lang="en-GB">Classfile /Users/maaikevanputten/Documents/packt/memorymanagement/src/main/java/chapter1/Example.class</pre>
<pre class="source-code" lang="en-GB">  Last modified 12 Jun 2022; size 298 bytes</pre>
<pre class="source-code" lang="en-GB">  SHA-256 checksum b2a6321e598c50c5d97ba053ca0faf689197df18c5141b727603 eaec0fecac3e</pre>
<pre class="source-code" lang="en-GB">  Compiled from "Example.java"</pre>
<pre class="source-code" lang="en-GB">public class chapter1.Example</pre>
<pre class="source-code" lang="en-GB">  minor version: 0</pre>
<pre class="source-code" lang="en-GB">  major version: 61</pre>
<pre class="source-code" lang="en-GB">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</pre>
<pre class="source-code" lang="en-GB">  this_class: #9                          // chapter1/Example</pre>
<pre class="source-code" lang="en-GB">  super_class: #2                         // java/lang/Object</pre>
<pre class="source-code" lang="en-GB">  interfaces: 0, fields: 0, methods: 2, attributes: 1</pre>
<pre class="source-code" lang="en-GB">Constant pool:</pre>
<pre class="source-code" lang="en-GB">   #1 = Methodref          #2.#3          // java/lang/Object."&lt;init&gt;":()V</pre>
<pre class="source-code" lang="en-GB">   #2 = Class              #4             // java/lang/Object</pre>
<pre class="source-code" lang="en-GB">   #3 = NameAndType        #5:#6          // "&lt;init&gt;":()V</pre>
<pre class="source-code" lang="en-GB">   #4 = Utf8               java/lang/Object</pre>
<pre class="source-code" lang="en-GB">   #5 = Utf8               &lt;init&gt;</pre>
<pre class="source-code" lang="en-GB">   #6 = Utf8               ()V</pre>
<pre class="source-code" lang="en-GB">   #7 = Double             8.6d</pre>
<pre class="source-code" lang="en-GB">   #9 = Class              #10            // chapter1/Example</pre>
<pre class="source-code" lang="en-GB">  #10 = Utf8               chapter1/Example</pre>
<pre class="source-code" lang="en-GB">  #11 = Utf8               Code</pre>
<pre class="source-code" lang="en-GB">  #12 = Utf8               LineNumberTable</pre>
<pre class="source-code" lang="en-GB">  #13 = Utf8               main</pre>
<pre class="source-code" lang="en-GB">  #14 = Utf8               ([Ljava/lang/String;)V</pre>
<pre class="source-code" lang="en-GB">  #15 = Utf8               SourceFile</pre>
<pre class="source-code" lang="en-GB">  #16 = Utf8               Example.java</pre>
<pre class="source-code" lang="en-GB">{</pre>
<pre class="source-code" lang="en-GB">  public chapter1.Example();</pre>
<pre class="source-code" lang="en-GB">    descriptor: ()V</pre>
<pre class="source-code" lang="en-GB">    flags: (0x0001) ACC_PUBLIC</pre>
<pre class="source-code" lang="en-GB">    Code:</pre>
<pre class="source-code" lang="en-GB">      stack=1, locals=1, args_size=1</pre>
<pre class="source-code" lang="en-GB">         0: aload_0</pre>
<pre class="source-code" lang="en-GB">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</pre>
<pre class="source-code" lang="en-GB">         4: return</pre>
<pre class="source-code" lang="en-GB">      LineNumberTable:</pre>
<pre class="source-code" lang="en-GB">        line 3: 0</pre>
<pre class="source-code" lang="en-GB">  public static void main(java.lang.String[]);</pre>
<pre class="source-code" lang="en-GB">    descriptor: ([Ljava/lang/String;)V</pre>
<pre class="source-code" lang="en-GB">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</pre>
<pre class="source-code" lang="en-GB">    Code:</pre>
<pre class="source-code" lang="en-GB">      stack=2, locals=5, args_size=1</pre>
<pre class="source-code" lang="en-GB">         0: iconst_3</pre>
<pre class="source-code" lang="en-GB">         1: istore_1</pre>
<pre class="source-code" lang="en-GB">         2: bipush        122</pre>
<pre class="source-code" lang="en-GB">         4: istore_2</pre>
<pre class="source-code" lang="en-GB">         5: ldc2_w        #7                  // double 8.6d</pre>
<pre class="source-code" lang="en-GB">         8: dstore_3</pre>
<pre class="source-code" lang="en-GB">         9: return</pre>
<pre class="source-code" lang="en-GB">      LineNumberTable:</pre>
<pre class="source-code" lang="en-GB">        line 5: 0</pre>
<pre class="source-code" lang="en-GB">        line 6: 2</pre>
<pre class="source-code" lang="en-GB">        line 8: 5</pre>
<pre class="source-code" lang="en-GB">        line 9: 9</pre>
<pre class="source-code" lang="en-GB">}</pre>
<pre class="source-code" lang="en-GB">SourceFile: "Example.java"</pre>
<p lang="en-GB" class="calibre4">As you can see, the <a id="_idIndexMarker075" class="pcalibre pcalibre2 pcalibre1 calibre6"/>constant pool has 16 entries. These are the ones created by us, but also some created by Java. They are needed to execute the program, so the name of the program, method, and so on are created in the constant pool to run <span lang="">the program.</span></p>
<h2 id="_idParaDest-33" lang="en-GB" class="calibre7"><a id="_idTextAnchor032" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Values on the stack</h2>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker076" class="pcalibre pcalibre2 pcalibre1 calibre6"/>values of the primitive’s local variables are stored directly in the stack – to be more precise, on the array of the frame of the method that the local variables are in. Objects are not stored on the stack. Instead, the object reference is stored on the stack. The object reference is the address at which to find the object on <span lang="">the heap.</span></p>
<h2 id="_idParaDest-34" lang="en-GB" class="calibre7"><a id="_idTextAnchor033" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Primitives and wrapper classes</h2>
<p lang="en-GB" class="calibre4">Be careful<a id="_idIndexMarker077" class="pcalibre pcalibre2 pcalibre1 calibre6"/> not to confuse the primitive types with their object wrapper classes. They are easily recognized by the type being in uppercase. The wrapper class objects don’t live on the stack, simply because they are objects. Whenever a method has been executed, the values of the associated primitives are cleaned up from the stack and they are <span lang="">gone forever.</span></p>
<p lang="en-GB" class="calibre4">Some <a id="_idIndexMarker078" class="pcalibre pcalibre2 pcalibre1 calibre6"/>wrapper classes are more easily recognized than others. Let’s take a look at a <span lang="">code snippet:</span></p>
<pre class="source-code" lang="en-GB">int primitiveInt = 2;</pre>
<pre class="source-code" lang="en-GB">Integer wrapperInt = 2;</pre>
<pre class="source-code" lang="en-GB">char primitiveChar = 'A';</pre>
<pre class="source-code" lang="en-GB">Character wrapperChar = 'A';</pre>
<p lang="en-GB" class="calibre4">As you can see, the wrappers start with a capital and are longer. For many types, however, the word is exactly the same and the only difference is that it starts with a capital. Personally, I’m most often fooled by <strong class="source-inline" lang="">Boolean</strong> and <strong class="source-inline" lang="">boolean</strong> (I blame C# for this since the equivalent of the Java <strong class="source-inline" lang="">boolean</strong> primitive in C# <span lang="">is </span><span lang=""><strong class="source-inline" lang="">bool</strong></span><span lang="">).</span></p>
<p lang="en-GB" class="calibre4">Here, you can see the<a id="_idIndexMarker079" class="pcalibre pcalibre2 pcalibre1 calibre6"/> difference between the other primitives and their <span lang="">reference types:</span></p>
<pre class="source-code" lang="en-GB">short primitiveShort = 15;</pre>
<pre class="source-code" lang="en-GB">Short wrapperShort = 15;</pre>
<pre class="source-code" lang="en-GB">long primitiveLong = 8L;</pre>
<pre class="source-code" lang="en-GB">Long wrapperLong = 8L;</pre>
<pre class="source-code" lang="en-GB">double primitiveDouble = 3.4;</pre>
<pre class="source-code" lang="en-GB">Double wrapperDouble = 3.4;</pre>
<pre class="source-code" lang="en-GB">float primitiveFloat = 5.6f;</pre>
<pre class="source-code" lang="en-GB">Float wrapperFloat = 5.6f;</pre>
<pre class="source-code" lang="en-GB">boolean primitiveBoolean = true;</pre>
<pre class="source-code" lang="en-GB">Boolean wrapperBoolean = true;</pre>
<pre class="source-code" lang="en-GB">byte primitiveByte = 0;</pre>
<pre class="source-code" lang="en-GB">Byte wrapperByte = 0;</pre>
<p lang="en-GB" class="calibre4">Please note that <a id="_idIndexMarker080" class="pcalibre pcalibre2 pcalibre1 calibre6"/>they have the exact same name. We need to look at the first letter to distinguish between the wrapper class and the primitive type. Wrapper classes are objects and these are created differently. Let’s find <span lang="">out how.</span></p>
<h1 id="_idParaDest-35" lang="en-GB" class="calibre5"><a id="_idTextAnchor034" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Creating objects in Java</h1>
<p lang="en-GB" class="calibre4">Objects <a id="_idIndexMarker081" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are a bundle of values. In Java, they can be created by<a id="_idIndexMarker082" class="pcalibre pcalibre2 pcalibre1 calibre6"/> instantiating classes using the <span lang=""><strong class="source-inline" lang="">new</strong></span><span lang=""> keyword.</span></p>
<p lang="en-GB" class="calibre4">Here is a very basic <span lang=""><strong class="source-inline" lang="">Person</strong></span><span lang=""> class:</span></p>
<pre class="source-code" lang="en-GB">public class Person {</pre>
<pre class="source-code" lang="en-GB">    private String name;</pre>
<pre class="source-code" lang="en-GB">    private String hobby;</pre>
<pre class="source-code" lang="en-GB">    public String getName() {</pre>
<pre class="source-code" lang="en-GB">        return name;</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">    public void setName(String name) {</pre>
<pre class="source-code" lang="en-GB">        this.name = name;</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">    public String getHobby() {</pre>
<pre class="source-code" lang="en-GB">        return hobby;</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">    public void setHobby(String hobby) {</pre>
<pre class="source-code" lang="en-GB">        this.hobby = hobby;</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">If we<a id="_idIndexMarker083" class="pcalibre pcalibre2 pcalibre1 calibre6"/> want <a id="_idIndexMarker084" class="pcalibre pcalibre2 pcalibre1 calibre6"/>to instantiate it, we’ll use <span lang="">the following:</span></p>
<pre class="source-code" lang="en-GB">Person p = new Person();</pre>
<p lang="en-GB" class="calibre4">What this does is create a new <strong class="source-inline" lang="">Person</strong> object and store it on the heap. Storing on the heap deserves a bit more of an explanation. This is what we’re going to zoom in <span lang="">on now!</span></p>
<h1 id="_idParaDest-36" lang="en-GB" class="calibre5"><a id="_idTextAnchor035" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Storing objects on the heap</h1>
<p lang="en-GB" class="calibre4">Storing <a id="_idIndexMarker085" class="pcalibre pcalibre2 pcalibre1 calibre6"/>objects on the heap is very different from storing values on the stack. As we’ve just seen, references to places on the heap are stored on the stack. These references are memory addresses and these memory addresses translate to a certain place on the heap where the object is being stored. Without this object reference, we would have no way to access an object on <span lang="">the heap.</span></p>
<p lang="en-GB" class="calibre4">Object references have a certain type. There are very many built-in types in Java that we can use, such as <strong class="source-inline" lang="">ArrayList</strong>, <strong class="source-inline" lang="">String</strong>, all the wrapper classes, and more, but we can also create our own objects and these objects will be stored on the <span lang="">heap too.</span></p>
<p lang="en-GB" class="calibre4">The heap memory holds all the objects that exist in the application. Objects on the heap can be accessed from everywhere in the application using the address of the object, the object reference. The objects contain the same things as the blocks on the stack: the primitive values directly and the addresses for other objects on <span lang="">the heap.</span></p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 1</em></span><em class="italic" lang="">.9</em>, you can see an overview of the stack and the heap and what this would look like (in a simplified view) for the following <span lang="">Java code:</span></p>
<pre class="source-code" lang="en-GB">public static void main(String[] args) {</pre>
<pre class="source-code" lang="en-GB">    int x = 5;</pre>
<pre class="source-code" lang="en-GB">    Person p = new Person();</pre>
<pre class="source-code" lang="en-GB">    p.setName("maaike");</pre>
<pre class="source-code" lang="en-GB">    p.setHobby("coding");</pre>
<pre class="source-code" lang="en-GB">}</pre>
<div class="calibre2">
<div class="img---figure" id="_idContainer014">
<img alt="Figure 1.9 – Overview of the connection between the stack and the heap" src="image/Figure_1.9_B18762.jpg" class="calibre26"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Overview of the connection between the stack and the heap</p>
<p lang="en-GB" class="calibre4">It’s very <a id="_idIndexMarker086" class="pcalibre pcalibre2 pcalibre1 calibre6"/>much simplified – for example, the <strong class="source-inline" lang="">String</strong> objects in the <strong class="source-inline" lang="">Person</strong> object would be separate objects themselves. We’ll focus on the heap in <a href="B18762_03.xhtml#_idTextAnchor049" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 3</em></span></a> to get a more accurate understanding of the <span lang="">heap area.</span></p>
<p lang="en-GB" class="calibre4">So, what happens when we run out of heap memory? If the application needs more heap space than is available, <strong class="source-inline" lang="">OutOfMemoryError</strong> <span lang="">is thrown.</span></p>
<p lang="en-GB" class="calibre4">Alright, we have seen the stack and the heap. There is just one memory area that we need to discuss here and that is <span lang="">the Metaspace.</span></p>
<h1 id="_idParaDest-37" lang="en-GB" class="calibre5"><a id="_idTextAnchor036" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Exploring the Metaspace</h1>
<p lang="en-GB" class="calibre4">The Metaspace is the<a id="_idIndexMarker087" class="pcalibre pcalibre2 pcalibre1 calibre6"/> memory space that holds the class <strong class="source-inline" lang="">metadata</strong> that is necessary for runtime.  It is the method area in the JVM specification and in most popular Java implementations after Java SE 7, this area is called <span lang="">the Metaspace.</span></p>
<p lang="en-GB" class="calibre4">If you <a id="_idIndexMarker088" class="pcalibre pcalibre2 pcalibre1 calibre6"/>know about PermGen, or you come across it, just know that this is the old memory area where all class <strong class="source-inline" lang="">metadata</strong> was stored. It had some limitations and has been replaced by <span lang="">the Metaspace.</span></p>
<p lang="en-GB" class="calibre4">So, back to this class <strong class="source-inline" lang="">metadata</strong>. What even is that? Class <strong class="source-inline" lang="">metadata</strong> is the runtime representation of the Java classes that are necessary to run the program. It actually contains a lot of things, such as <span lang="">the following:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">The <em class="italic" lang="">Klass</em> structure (we’ll see more in <a href="B18762_05.xhtml#_idTextAnchor077" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 5</em></span></a> when we take a deep dive into <span lang="">the Metaspace!)</span></li>
<li lang="en-GB" class="calibre11">Bytecode <span lang="">of methods</span></li>
<li lang="en-GB" class="calibre11">The <span lang="">constant pool</span></li>
<li lang="en-GB" class="calibre11">Annotations <span lang="">and more</span></li>
</ul>
<p lang="en-GB" class="calibre4">That’s it! These are the basics of Java memory management. There is a lot more to say about the specific parts. We are going to start with a closer look at primitives and objects on the heap in the next chapter, but first, let’s recap what <span lang="">we’ve done.</span></p>
<h1 id="_idParaDest-38" lang="en-GB" class="calibre5"><a id="_idTextAnchor037" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Summary</h1>
<p lang="en-GB" class="calibre4">In this chapter, we have gone through an overview of Java memory. We started with computer memory and learned that the computer has main memory and secondary storage. The main memory is most important for us since this is what is used to run programs, including <span lang="">Java programs.</span></p>
<p lang="en-GB" class="calibre4">The main memory consists of RAM and ROM. Java applications use RAM to run. Java applications are executed by the JVM. This JVM executes Java applications and in order to do so, it has three components: a class loader, runtime data areas, and an <span lang="">execution engine.</span></p>
<p lang="en-GB" class="calibre4">We focused on the different components of the runtime data area: the heap, stack, method area, PC register, and native <span lang="">method stack.</span></p>
<p lang="en-GB" class="calibre4">The stack is the memory area that is used to store variables and values of methods in frames. The heap is used for storing objects. The stack holds references to objects on the heap. The heap is accessible from everywhere within the application and whoever has an object’s address on the heap can access the object. The stack is only accessible for the thread that has created <span lang="">this stack.</span></p>
<p lang="en-GB" class="calibre4">The Metaspace is the memory area where the class metadata that is needed during runtime <span lang="">is stored.</span></p>
<p lang="en-GB" class="calibre4">In the next chapter, we’re going to visualize and have a closer look at how heap and stack memory <span lang="">are combined.</span></p>
</div>
<div class="calibre2">
<div id="_idContainer016" class="calibre2">
</div>
</div>
</div></body></html>