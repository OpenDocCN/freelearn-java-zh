<html><head></head><body>
		<div id="_idContainer087">
			<h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor077"/>Chapter 4</em>: Graal Just-In-Time Compiler</h1>
			<p>In <a href="B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">GraalVM Architecture</em>, we went through the GraalVM architecture and the various components that constitute it. We went through some details of the GraalVM Polyglot architecture with Truffle and touched upon the Graal's <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler. We looked at how Graal JIT plugs into the Java Virtual Machine by implementing the Java Virtual Machine Compiler Interface. In this chapter, we will explore how the Graal JIT compiler works by running sample code and visualizing the Graal graphs and optimizations that Graal JIT performs, using the Ideal Graph Visualizer tool.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up the environment</li>
				<li>Understanding the Graal JIT compiler</li>
				<li>Understanding Graal compiler optimizations</li>
				<li>Debugging and monitoring applications</li>
			</ul>
			<p>By the end of the chapter, you will have a very clear understanding of how Graal JIT compilation works, understand the various optimization techniques, know how to diagnose and debug performance problems using the Ideal Graph Visualizer, and be able to fine-tune Graal JIT compiler configurations for optimum performance.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>In this chapter, we will take some sample code and use tools to analyze it. The following are some of the tools/runtimes that are required to follow this chapter: </p>
			<ul>
				<li>OpenJDK (<a href="https://openjdk.java.net/">https://openjdk.java.net/</a>)</li>
				<li>GraalVM (<a href="https://www.graalvm.org/">https://www.graalvm.org/</a>)</li>
				<li>VisualVM (<a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a>)</li>
				<li>The Ideal Graph Visualizer</li>
				<li>There are some sample code snippets, which are available in our Git repository. The code can be downloaded from <a href="https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04">https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04</a>.</li>
				<li>The Code in Action video for this chapter can be found at <a href="https://bit.ly/3fmPsaP.">https://bit.ly/3fmPsaP.</a></li>
			</ul>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor079"/>Setting up the environment</h1>
			<p>In this chapter, we will be using VisualVM and the Ideal Graph Visualizer to understand how Graal JIT works. This understanding will help us, in the subsequent chapters, to build optimum code with Graal.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>Setting up Graal</h2>
			<p>In <a href="B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">GraalVM Architecture</em>, we discussed the <a id="_idIndexMarker283"/>two editions of Graal – Community Edition and <strong class="bold">Enterprise Edition</strong> (<strong class="bold">EE</strong>). Graal Community Edition can be downloaded from <a id="_idIndexMarker284"/>the Git repository mentioned in the <em class="italic">Technical requirements</em> section, while EE requires you to register with Oracle to download it. EE is available for free for evaluation and non-production applications.</p>
			<h3>Installing the Community Edition</h3>
			<p>To install <a id="_idIndexMarker285"/>GraalVM Community Edition, go to <a href="https://github.com/graalvm/graalvm-ce-builds/releases">https://github.com/graalvm/graalvm-ce-builds/releases</a> and download the <a id="_idIndexMarker286"/>latest release for the target operating system (macOS, Linux, and Windows). At the time of writing this book, the latest version is 21.0.0.2, with base Java 8 or Java 11 versions. The Community Edition is built on OpenJDK.</p>
			<p>Please follow the instructions provided next for your target operating system. The latest instructions can be found at https://www.graalvm.org/docs/getting-started/#install-graalvm. </p>
			<h3>Installing GraalVM on macOS</h3>
			<p>For macOS, after <a id="_idIndexMarker287"/>downloading the GraalVM archive file, unzip the archive and copy the contents of the unzipped folder to <strong class="source-inline">/Library/Java/JavaVirtualMachines/&lt;graalvm&gt;/Contents/Home</strong>.</p>
			<p>Once we have <a id="_idIndexMarker288"/>copied the files, we have to export the paths to access the GraalVM binaries. Let's run the following <strong class="source-inline">export</strong> commands on the terminal:</p>
			<p class="source-code">export PATH=/Library/Java/JavaVirtualMachines/&lt;graalvm&gt;/Contents/Home/bin:$PATH</p>
			<p class="source-code">export JAVA_HOME=/Library/Java/JavaVirtualMachines/&lt;graalvm&gt;/Contents/Home</p>
			<p>For macOS Catalina and later, the <strong class="source-inline">quarantine</strong> attribute needs to be removed. It can be done with the following command:</p>
			<p class="source-code">sudo xattr -r -d com.apple.quarantine &lt;graalvm-path&gt;</p>
			<p>If this is not done, you will see the following error message:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_4.1_B16878.jpg" alt="Figure 4.1 – Error message while running Graal on MacOS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Error message while running Graal on MacOS</p>
			<p>SDKMAN provides <a id="_idIndexMarker289"/>an automated <a id="_idIndexMarker290"/>way of installing GraalVM. Please <a id="_idIndexMarker291"/>refer to <a href="https://sdkman.io/">https://sdkman.io/</a> for more details.</p>
			<h3>Installing GraalVM on Linux</h3>
			<p>To install GraalVM on Linux, extract the <a id="_idIndexMarker292"/>downloaded zip file, copy it to any <a id="_idIndexMarker293"/>target folder, and set the <strong class="source-inline">PATH</strong> and <strong class="source-inline">JAVA_HOME</strong> paths to point to the folder where the extracted files are. To do this, execute the following commands on the command line:</p>
			<p class="source-code">export PATH=&lt;graalvm&gt;/bin:$PATH</p>
			<p class="source-code">export JAVA_HOME=&lt;graalvm&gt;</p>
			<h3>Installing GraalVM on Windows</h3>
			<p>To install GraalVM on Windows, extract the <strong class="source-inline"><a id="_idIndexMarker294"/></strong><strong class="source-inline">.zip</strong> file, copy it to any <a id="_idIndexMarker295"/>target folder, set the <strong class="source-inline">PATH</strong> and <strong class="source-inline">JAVA_HOME</strong> paths to point to the folder where the extracted files are. To set the <strong class="source-inline">PATH</strong> environment variables, execute the following commands on the terminal:</p>
			<p class="source-code">setx /M PATH "C:\Progra~1\Java\&lt;graalvm&gt;\bin;%PATH%"</p>
			<p class="source-code">setx /M JAVA_HOME "C:\Progra~1\Java\&lt;graalvm&gt;"</p>
			<p>To check that the installation and setup are complete, run the <strong class="source-inline">java -version</strong> command on the terminal. </p>
			<p>After executing the command, you should see something like the following output (I am using GraalVM EE 21.0.0 on Java 11. You should see the version that you installed):</p>
			<p class="source-code">java version "11.0.10" 2021-01-19 LTS</p>
			<p class="source-code">Java(TM) SE Runtime Environment GraalVM EE 21.0.0 (build 11.0.10+8-LTS-jvmci-21.0-b06)</p>
			<p class="source-code">Java HotSpot(TM) 64-Bit Server VM GraalVM EE 21.0.0 (build 11.0.10+8-LTS-jvmci-21.0-b06, mixed mode, sharing)</p>
			<p>Let's now explore the folder structure of GraalVM installation. In the GraalVM installation folder, you will find the folder structure explained in the following table: </p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/01.jpg" alt=""/>
				</div>
			</div>
			<p>In the <a id="_idIndexMarker296"/>previous chapter, we <a id="_idIndexMarker297"/>covered in detail the various runtimes, tools, and utilities that come with Graal. Graal Updater is <a id="_idIndexMarker298"/>one of the very important tools that is used to install optional runtimes. To check the runtimes that are available, execute <strong class="source-inline">gu list</strong>. The following screenshot shows the typical output:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_4.2_B16878.jpg" alt="Figure 4.2 – Graal Updater listing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Graal Updater listing</p>
			<p>We can run <strong class="source-inline">gu install &lt;runtime&gt;</strong> to install other runtimes.</p>
			<h3>Installing EE</h3>
			<p>GraalVM EE is available for <a id="_idIndexMarker299"/>free for trial and non-production use. It can be <a id="_idIndexMarker300"/>downloaded from <a href="https://www.graalvm.org/downloads/">https://www.graalvm.org/downloads/</a>.</p>
			<p>Select the required GraalVM Enterprise version. The website will redirect you to Oracle's registration page. If you are already registered, you should be able to log in, and you will be redirected to a page from where you can download GraalVM and the supporting tools. At the time of writing this book, the screen looks something like the following screenshot:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_4.3_B16878.jpg" alt="Figure 4.3 – GraalVM EE download page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – GraalVM EE download page</p>
			<p>You can select the <a id="_idIndexMarker301"/>right version of EE that you want to download along with the base JDK version. At the time of writing the book, Java 8 and Java 11 are two viable versions. When you scroll down this page, you will find download links for the following:</p>
			<ul>
				<li><strong class="bold">Oracle GraalVM Enterprise Edition Core</strong>: This the <a id="_idIndexMarker302"/>code for GraalVM.</li>
				<li><strong class="bold">Oracle GraalVM Enterprise Edition Native Image</strong>: This is the <a id="_idIndexMarker303"/>native image tool. It can also be downloaded using Graal Updater later.</li>
				<li><strong class="bold">Ideal Graph Visualizer</strong>: This is a <a id="_idIndexMarker304"/>very powerful Graal graph analyzer tool. It needs to be downloaded for this chapter. See the instructions in the <em class="italic">Installing the Ideal Graph Visualizer</em> section.</li>
				<li><strong class="bold">GraalVM LLVM Toolchain</strong>: This is the <a id="_idIndexMarker305"/>LLVM toolchain, which is required if you want to compile and run C/C++ applications on GraalVM.</li>
				<li><strong class="bold">Oracle GraalVM Enterprise Edition Ruby Language Plugin</strong>: This is the Ruby language compiler and runtime. It <a id="_idIndexMarker306"/>can also be downloaded using Graal Updater later.</li>
				<li><strong class="bold">Oracle GraalVM Enterprise Edition Python Language Plugin</strong>: This is the Python language compiler and runtime. It <a id="_idIndexMarker307"/>can also be downloaded using Graal Updater later.</li>
				<li><strong class="bold">Oracle GraalVM Enterprise Edition WebAssembly Language Plugin</strong>: This is the WebAssembly language <a id="_idIndexMarker308"/>compiler and runtime. It can also be <a id="_idIndexMarker309"/>downloaded using Graal Updater later.</li>
				<li><strong class="bold">Oracle GraalVM Enterprise Edition Java on Truffle</strong>: This is the JVM implementation <a id="_idIndexMarker310"/>on the Truffle interpreter.</li>
			</ul>
			<h3>Switching between editions</h3>
			<p>We can have <a id="_idIndexMarker311"/>multiple versions/distributions of GraalVM installed on the same machine, and we can switch between these various distributions. In this chapter, we will be switching between the distributions to compare their performance. The best way to switch between distributions is by using Visual Studio Code. Visual Studio Code <a id="_idIndexMarker312"/>provides a GraalVM plugin that <a id="_idIndexMarker313"/>helps us to add the various distributions, and with single click of a button, allows us to switch between the various distributions. Please refer to <a href="https://www.graalvm.org/tools/vscode/">https://www.graalvm.org/tools/vscode/</a> and <a href="https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm ">https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm </a>for more details. Refer to the <em class="italic">Debugging and monitoring applications</em> section later in this chapter for more details on how to install Visual Studio Code and use it for debugging applications.</p>
			<p>We can also create shell scripts to <a id="_idIndexMarker314"/>switch between the various distributions by setting the PATH and JAVA_HOME environment variables to point to appropriate distributions.</p>
			<h3>Installing Graal VisualVM</h3>
			<p>Java VisualVM is one of the most <a id="_idIndexMarker315"/>powerful tools for analyzing an application's heap, thread, and CPU utilization. VisualVM is widely used to analyze core dumps, heap dumps, and applications that are offline. It is a very sophisticated tool that can identify bottlenecks and optimize Java code. </p>
			<p>Since JDK 9, VisualVM has been moved and upgraded to Graal VisualVM. Graal VisualVM extends the functionality to include the analysis of Graal processes, and currently supports JavaScript, Python, Ruby, and R. Graal VisualVM also supports some limited monitoring and analysis functionality for native image processes. Graal VisualVM comes bundled with both Graal Community Edition and EE. Graal VisualVM can be found at <strong class="source-inline">.bin/jvisualvm</strong> (<strong class="source-inline">.exe</strong> for windows).</p>
			<p>Let's quickly go through the key features of Graal VisualVM. Graal VisualVM has a very intuitive interface. The left panel of the main window (see <em class="italic">Figure 4.3</em>) shows all the <strong class="bold">Local</strong> and <strong class="bold">Remote</strong> processes. Using this, we can easily connect to those processes to start our analysis:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_4.4_B16878.jpg" alt="Figure 4.4 – VisualVM, left pane&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – VisualVM, left pane</p>
			<p>Once we connect to the process, in the <a id="_idIndexMarker316"/>right panel, we will see the following five tabs:</p>
			<ul>
				<li><strong class="bold">Overview</strong>: On this tab, we can see the process configuration, JVM arguments, and system properties. The following screenshot shows the typical screen for the <strong class="bold">FibonacciCalculator</strong> process that we are running:</li>
			</ul>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_4.5_B16878.jpg" alt="Figure 4.5 – VisualVM – application overview&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – VisualVM – application overview</p>
			<ul>
				<li><strong class="bold">Monitor</strong>: On this tab, we can see CPU usage, heap allocation, the number of classes that are loaded, the number of threads that are running, and so on. We can also force a garbage collection to see how the process behaves. We can perform a heap dump to do a deeper analysis of the heap allocations. Here is a screenshot of the window:</li>
			</ul>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_4.6_B16878.jpg" alt="Figure 4.6 – VisualVM – application monitoring&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – VisualVM – application monitoring</p>
			<ul>
				<li><strong class="bold">Threads</strong>: This tab provides <a id="_idIndexMarker317"/>detailed information about the various threads that are running the processes. We can also capture a thread dump to perform further analysis. This tab not only shows the live threads, but we can also analyze the threads that have finished execution. The following screenshot shows the typical <strong class="bold">Threads</strong> tab:</li>
			</ul>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_4.7_B16878.jpg" alt="Figure 4.7 – VisualVM – application threads&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – VisualVM – application threads</p>
			<p>Here is a <a id="_idIndexMarker318"/>typical screenshot of the thread dump that can be used to identify if there are any deadlocks or thread waits:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_4.8_B16878.jpg" alt="Figure 4.8 – VisualVM – thread dump&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – VisualVM – thread dump</p>
			<ul>
				<li><strong class="bold">Sampler</strong>: This tab can be <a id="_idIndexMarker319"/>used to take a snapshot of the running process and carry out analysis on CPU, memory, and so on. Here is a screenshot that shows the memory usage for the snapshot we take by clicking the <strong class="bold">Snapshots</strong> button:</li>
			</ul>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_4.9_B16878.jpg" alt="Figure 4.9 – VisualVM – Memory usage using Snapshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – VisualVM – Memory usage using Snapshot</p>
			<ul>
				<li><strong class="bold">Profiler</strong>: This is like the <a id="_idIndexMarker320"/>sampler, but it runs all the time. Apart from CPU and memory, we can also look at JDBC invocations and the time it takes to get the response. The next screenshot shows CPU profiling:</li>
			</ul>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_4.10_B16878.jpg" alt="Figure 4.10 – VisualVM – application profiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – VisualVM – application profiler</p>
			<p>Apart from this, Graal VisualVM can be used to <a id="_idIndexMarker321"/>analyze Core dumps and to identify the root cause of any Java process crashes. At the time of writing this book, Graal VisualVM supports JavaScript and Ruby (heap, object view, and thread view only), Python, and R (heap and object view only).</p>
			<p><strong class="bold">JDK Flight Recorder</strong> (<strong class="bold">JFR</strong>) analysis is <a id="_idIndexMarker322"/>another powerful feature of VisualVM. It helps us to analyze the data that is connected by JFR with no overhead on the running process. JFR provides more advanced analysis, including capturing and analyzing file I/O, socket I/O, and thread locks apart from CPU and thread.</p>
			<p>Graal VisualVM also provides extension APIs so we can write custom plugins. Various plugins can be used to extend Graal VisualVM. Here are some of the most widely used plugins:</p>
			<ul>
				<li><strong class="bold">Visual GC plugin</strong>: This plugin <a id="_idIndexMarker323"/>provides a powerful <a id="_idIndexMarker324"/>interface to monitor garbage collection, class loader, and JIT compiler performance. It is a very powerful plugin that can identify optimizations in the code to improve performance.</li>
				<li><strong class="bold">Tracer</strong>: Tracer <a id="_idIndexMarker325"/>provides a <a id="_idIndexMarker326"/>better user interface for detailed monitoring and analyzing of the applications. </li>
				<li><strong class="bold">Startup Profiler</strong>: As the name <a id="_idIndexMarker327"/>suggests, this provides <a id="_idIndexMarker328"/>instrumentation to profile the startups and identify any optimizations that can be performed to improve the startups.</li>
			</ul>
			<p>You can find the full list of available plugins at <a href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a>.</p>
			<h3>Installing the Ideal Graph Visualizer</h3>
			<p>Ideal Graph Visualizer is a <a id="_idIndexMarker329"/>very powerful tool for analyzing how Graal JIT is performing various optimizations. This requires an advanced understanding of Graal Graphs, which is an intermediate representation. Later in this chapter, we will cover Graal Graph and how to use the Ideal Graph Visualizer so that we can see how Graal performs various optimizations. This is critical, as it helps us write better code and optimize the code at development time, and reduces the load on the compiler to perform it just in time. </p>
			<p>The The Ideal Graph Visualizer is available with GraalVM EE. It can be downloaded from the Oracle website. The Ideal Graph Visualizer can be launched with the following command, after setting the <strong class="source-inline">PATH</strong> to the location where it has been unzipped/installed:</p>
			<p class="source-code">idealgraphvisualizer</p>
			<p>The <strong class="source-inline">--jdkhome</strong> flag can be used to point to the right version of GraalVM. Once it has been launched, you will see the following screen:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_4.11_B16878.jpg" alt="Figure 4.11 – The Ideal Graph Visualizer – main window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – The Ideal Graph Visualizer – main window</p>
			<p>The Ideal Graph Visualizer <a id="_idIndexMarker330"/>requires Graal dumps to render and analyze Graal Graphs. Graal dumps can be created using the following command:</p>
			<p class="source-code">java -Dgraal.Dump=:n &lt;java class file&gt;</p>
			<p>The <strong class="source-inline">n</strong> in the preceding command can be <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, or <strong class="source-inline">3</strong>, and each number denotes a level of verbosity. This generates a folder called <strong class="source-inline">graal_dumps</strong>, which consists of <strong class="source-inline">bgv</strong> files (Binary Graph Files). Sometimes you will find various <strong class="source-inline">bgv</strong> files due to invalidation and recompilation (deoptimization or on-stack replacements – please refer to <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT </em>, and find the <em class="italic">On-stack replacement</em> section to find out more). These <strong class="source-inline">bgv</strong> files can be opened in The Ideal Graph Visualizer to do the analysis. Once the <strong class="source-inline">bgv</strong> file is loaded, you will see a screen like this:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_4.12_B16878.jpg" alt="Figure 4.12 – The Ideal Graph Visualizer – main window–Graal dump&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – The Ideal Graph Visualizer – main window–Graal dump</p>
			<p>The left pane can be used to <a id="_idIndexMarker331"/>navigate through the various phases of compilation and optimization, the main window shows the graph, and the right pane can be used to configure how to render these graphs. We can view the Graal Graphs, Call Graph, AST, and Truffle Call Tree. </p>
			<p>The Ideal Graph Visualizer can also be connected from the Java runtime (using the <strong class="source-inline">Dgraal.PrintGraph=Network</strong> flag) to view the graphs in real time, while the application code is executing.</p>
			<p>In the next section, we will explore how these Graal Graphs can be read to understand how the Graal compiler works. </p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor081"/>Understanding the Graal JIT compiler</h1>
			<p>In the previous chapter, we <a id="_idIndexMarker332"/>briefly touched upon the Graal compiler and the ecosystem around it. In this section, we will dig deeper into various compiler options and see how Graal optimizes the code just in time. In the next section, we will take a look at Ahead-of-Time compilation, and how a native image can be created. Before we get into the details of how the Graal compiler works, let's quickly go through some of the Graal compiler configurations, which can be passed as arguments to the virtual machine. </p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor082"/>Graal compiler configuration</h2>
			<p>The Graal compiler can be <a id="_idIndexMarker333"/>configured with various <a id="_idIndexMarker334"/>arguments that can be passed from the <strong class="source-inline">java</strong> command (in the GraalVM version of <strong class="source-inline">java</strong>). In this section, we will go through some of the most useful command-line configurations. </p>
			<p>We will be trying these various flags on a sample application to see how it affects the Graal compiler. </p>
			<p>Let's write a simple Java class called <strong class="source-inline">FibonacciCalculator</strong>. Here is the source code of the class:</p>
			<p class="source-code">class FibonacciCalculator{</p>
			<p class="source-code">    public int[] findFibonacci(int count) {</p>
			<p class="source-code">        int fib1 = 0;</p>
			<p class="source-code">        int fib2 = 1;</p>
			<p class="source-code">        int currentFib, index;</p>
			<p class="source-code">        int [] fibNumbersArray = new int[count];</p>
			<p class="source-code">        for(index=2; index &lt; count; ++index ) {    </p>
			<p class="source-code">            currentFib = fib1 + fib2;    </p>
			<p class="source-code">            fib1 = fib2;    </p>
			<p class="source-code">            fib2 = currentFib;    </p>
			<p class="source-code">            fibNumbersArray[index - 1] = currentFib;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return fibNumbersArray;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String args[])  </p>
			<p class="source-code">    {</p>
			<p class="source-code">        FibonacciCalculator fibCal =             new FibonacciCalculator();</p>
			<p class="source-code">        long startTime = System.currentTimeMillis();</p>
			<p class="source-code">        long now = 0;</p>
			<p class="source-code">        long last = startTime;</p>
			<p class="source-code">        for (int i = 1000000000; i &lt; 1000000010; i++) {</p>
			<p class="source-code">            int[] fibs = fibCal.findFibonacci(i);</p>
			<p class="source-code">            long total = 0;</p>
			<p class="source-code">            for (int j=0; j&lt;fibs.length; j++) {</p>
			<p class="source-code">                total += fibs[j];</p>
			<p class="source-code">            }</p>
			<p class="source-code">            now = System.currentTimeMillis();</p>
			<p class="source-code">            System.out.printf("%d (%d ms)%n", i , now – last);</p>
			<p class="source-code">            last = now;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        long endTime = System.currentTimeMillis();</p>
			<p class="source-code">        System.out.printf ("total: (%d ms)%n",            System.currentTimeMillis() - startTime);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see, we are <a id="_idIndexMarker335"/>generating <strong class="source-inline">1000000000</strong> to <strong class="source-inline">1000000010</strong> Fibonacci numbers, and then later calculating the sum total of all the Fibonacci number that are generated. The code is written to loops to trigger the <a id="_idIndexMarker336"/>compilation threshold. </p>
			<p>There are a lot of optimization opportunities for JIT. Let's first run this program with Java HotSpot:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_4.13_B16878.jpg" alt="Figure 4.13 – FibonnaciCalculator – Java HotSpot output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – FibonnaciCalculator – Java HotSpot output</p>
			<p>As you can see, the initial iterations took the most time, and it optimized to around 1,300 ms over the iterations. Let's now compile the code with <strong class="source-inline">javac</strong>, which we got from the Graal EE distribution, and run the same program with Graal JIT. The following screenshot shows the output of running the same application with GraalVM (GraalVM EE 21.0.0.2 on Java 11):</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_4.14_B16878.jpg" alt="Figure 4.14 – FibonnaciCalculator – GraalVM output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – FibonnaciCalculator – GraalVM output</p>
			<p>We can see significant <a id="_idIndexMarker337"/>improvement in <a id="_idIndexMarker338"/>performance. Graal started similarly to Java HotSpot, but over the iterations it optimized to 852 ms, compared to the 1,300 ms it took to run with HotSpot. The following option is used to disable GraalJIT and use HotSpot on GraalVM:</p>
			<p class="source-code">-XX:-UseJVMCICompiler</p>
			<p>This is normally used to compare the performance of Graal. Let's run this option with the preceding source code, with the GraalVM EE 21.0.0.2 compiler:</p>
			<p class="source-code">java -XX:-UseJVMCICompiler FibonacciCalculator/</p>
			<p>The following is a screenshot of the output after running the preceding command:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_4.15_B16878.jpg" alt="Figure 4.15 – FibonnaciCalculator – GraalVM (21/Java 11) output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – FibonnaciCalculator – GraalVM (21/Java 11) output</p>
			<p>As you can see, even though we are using the Graal compiler, the performance is similar to Java HotSpot, and in fact is slower than Java HotSpot 15. Note that our Graal is running on Java 11.</p>
			<p>The <strong class="source-inline">CompilerConfiguration</strong> flag is <a id="_idIndexMarker339"/>used to specify which JIT compiler is to be used. The following is the argument that we can pass to set the <a id="_idIndexMarker340"/>compiler configuration:</p>
			<p class="source-code">-Dgraal.CompilerConfiguration</p>
			<p>We have three options; let's also run these options with our sample code to see how it performs:</p>
			<ul>
				<li><strong class="source-inline">-Dgraal.CompilerConfiguration=enterprise</strong>: This uses the enterprise JIT, and generates the optimum code. However, there will be initial slowdowns due to compilation:</li>
			</ul>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_4.16_B16878.jpg" alt="Figure 4.16 – FibonnaciCalculator – enterprise compiler configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – FibonnaciCalculator – enterprise compiler configuration</p>
			<ul>
				<li><strong class="source-inline">-Dgraal.CompilerConfiguration=community</strong>: This produces the community version of JIT, which optimizes to a decent extent. The compilation is therefore faster.</li>
			</ul>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_4.17_B16878.jpg" alt="Figure 4.17 – FibonnaciCalculator – community compiler configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – FibonnaciCalculator – community compiler configuration</p>
			<ul>
				<li><strong class="source-inline">-Dgraal.CompilerConfiguration=economy</strong>: This compiles quickly, with fewer optimizations:</li>
			</ul>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_4.18_B16878.jpg" alt="Figure 4.18 – FibonnaciCalculator – economy compiler configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – FibonnaciCalculator – economy compiler configuration</p>
			<p>We can see a significant <a id="_idIndexMarker341"/>difference in the performance when using enterprise, community, and economy. Here is a comparison of the <a id="_idIndexMarker342"/>performances of three options:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_4.19_B16878.jpg" alt="Figure 4.19 – FibonnaciCalculator – enterprise versus community versus economy configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – FibonnaciCalculator – enterprise versus community versus economy configuration</p>
			<p>Apart from this, there are a lot of other performance tuning options that can be used to improve the performance of the compiler, such as this:</p>
			<p class="source-code">-Dgraal.UsePriorityInlining (true/false)</p>
			<p>The preceding flag can be used to enable/disable advanced inlining algorithm. Disabling this improves the <a id="_idIndexMarker343"/>compilation time and helps throughput.</p>
			<p>This flag can be used to disable auto-vectorization optimization:</p>
			<p class="source-code">-Dgraal.Vectorization (true/false)</p>
			<p>This flag can be used to <a id="_idIndexMarker344"/>disable the path duplication optimization, such as Dominance-Based Duplication Simulation. When this is disabled, it has an impact on the throughput:</p>
			<p class="source-code">-Dgraal.OptDuplication (true/false)</p>
			<p class="source-code">This next flag can be set to values between -1 and 1. When the value is below 0, the JIT reduces the effort spent on inlining. This will improve the startup and provides throughput. When the value is greater than 0, the JIT spends more effort in inlining, increasing the performance:</p>
			<p class="source-code">-Dgraal.TuneInlinerExploration (-1 to +1)</p>
			<p>This is a very useful flag that can be enabled to trace how the JIT compiler takes decisions on inlining optimization:</p>
			<p class="source-code">-Dgraal.TraceInlining (true/false)</p>
			<p>When we enable this flag for sample code, we get the following: </p>
			<p class="source-code">compilation of FibonacciCalculator.main(String[]): </p>
			<p class="source-code">  at FibonacciCalculator.main(FibonacciCalculator.java:20) [bci: 4]: &lt;GraphBuilderPhase&gt; FibonacciCalculator.&lt;init&gt;(): yes, inline method</p>
			<p class="source-code">  at FibonacciCalculator.main(FibonacciCalculator.java:25) [bci: 32]: &lt;GraphBuilderPhase&gt; FibonacciCalculator.findFibonacci(int): no, bytecode parser did not replace invoke</p>
			<p class="source-code">compilation of FibonacciCalculator.main(String[]): </p>
			<p class="source-code">  at FibonacciCalculator.main(FibonacciCalculator.java:20) [bci: 4]: &lt;GraphBuilderPhase&gt; FibonacciCalculator.&lt;init&gt;(): yes, inline method</p>
			<p class="source-code">  at FibonacciCalculator.main(FibonacciCalculator.java:25) [bci: 32]: </p>
			<p class="source-code">  ├──&lt;GraphBuilderPhase&gt; FibonacciCalculator.findFibonacci(int): no, bytecode parser did not replace invoke</p>
			<p class="source-code">  └──&lt;PriorityInliningPhase&gt; FibonacciCalculator.findFibonacci(int): yes, worth inlining according to the cost-benefit analysis.</p>
			<p class="source-code">compilation of java.lang.String.hashCode(): </p>
			<p class="source-code">  at java.lang.String.hashCode(String.java:1504) [bci: 19]: </p>
			<p class="source-code">  ├──&lt;GraphBuilderPhase&gt; java.lang.String.isLatin1(): no, bytecode parser did not replace invoke</p>
			<p class="source-code">  └──&lt;PriorityInliningPhase&gt; java.lang.String.isLatin1(): yes, budget was large enough to inline this callsite.</p>
			<p class="source-code">  at java.lang.String.hashCode(String.java:1504) [bci: 29]: </p>
			<p class="source-code">  ├──&lt;GraphBuilderPhase&gt; java.lang.StringLatin1.hashCode(byte[]): no, bytecode parser did not replace invoke</p>
			<p class="source-code">  └──&lt;PriorityInliningPhase&gt; java.lang.StringLatin1.hashCode(byte[]): yes, budget was large enough to inline this callsite.</p>
			<p>We can see <a id="_idIndexMarker345"/>how the <a id="_idIndexMarker346"/>JIT compiler is taking decisions on inlining.</p>
			<p>These optimization flags can be set even for other GraalVM launchers, such as <strong class="source-inline">js</strong> (for JavaScript), <strong class="source-inline">node</strong>, and <strong class="source-inline">lli</strong>.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor083"/>Graal JIT compilation pipeline and tiered optimization</h2>
			<p>In the previous chapter, in the <em class="italic">Graal JIT compiler</em> section, we looked at how Graal JIT integrates with the virtual machine through JVMCI. In this section, let's take a deeper look at how Graal JIT interacts with virtual machine.</p>
			<p>Graal optimizes the <a id="_idIndexMarker347"/>code in three tiers. The tiered approach <a id="_idIndexMarker348"/>helps Graal to perform optimizations starting from more platform-independent representations (high-level intermediate representation) to more platform-dependent representations (low-level intermediate representation). The following diagram shows how Graal JIT interfaces with the virtual machine and performs these three tiers of optimization:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_4.20_B16878.jpg" alt="Figure 4.20 – Graal JIT compiler – compilation tiers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20 – Graal JIT compiler – compilation tiers</p>
			<p>Let's try to <a id="_idIndexMarker349"/>understand this picture better:</p>
			<ul>
				<li>The virtual machine <a id="_idIndexMarker350"/>passes the bytecode and metadata to the Graal JIT when it hits the compilation threshold (refer to <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT</em>, to find out more about the compilation thresholds). </li>
				<li>Graal parses the <a id="_idIndexMarker351"/>bytecode and generates a <strong class="bold">high-level intermediate representation</strong> (<strong class="bold">HIR</strong>).</li>
				<li>It then performs various optimizations on the <strong class="bold">HIR</strong>. These are some of the standard Java optimization techniques that are applied, with some new techniques that have been introduced in Graal, such as partial escape analysis and advanced inlining techniques.</li>
				<li>Once these high-level optimizations are performed, Graal starts converting the high-level operations to low-level operations. This phase is called lowering. There are two tiers of <a id="_idIndexMarker352"/>optimizations that it performs during this phase, and it eventually generates the <strong class="bold">low-level intermediate representation</strong> (<strong class="bold">LIR</strong>) for the target processor architecture.</li>
				<li>Once all the optimizations are performed on the LIR, the final optimized machine code is generated and stored in the code cache, along with the reference maps that the garbage collector will use and the metadata that will be required for deoptimization.</li>
			</ul>
			<p>In this section, we looked at how the Graal JIT compiler works internally, and we also explored various compiler configurations that will affect the compiler's performance. Now let's understand the Graal Intermediate Representation better.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor084"/>Graal intermediate representation</h2>
			<p><strong class="bold">Intermediate Representations</strong> (<strong class="bold">IRs</strong>) are <a id="_idIndexMarker353"/>among the most important data structures for compiler design. IRs provide a graph that helps the compiler understand the structure of the code, identify opportunities, and perform optimizations. Selecting the right type of data structure and IR is key for a compiler to identify <a id="_idIndexMarker354"/>these opportunities for optimization. In GraalVM, apart from the C1 and C2 compilers that exist in the JVM, the Graal compiler was introduced with a new IR, which is based on a directed graph data structure. Each node in the graph <a id="_idIndexMarker355"/>represents a value in <strong class="bold">Static Single Assignment</strong> (<strong class="bold">SSA</strong>) form. Since the Graal compiler is completely built on Java, the node types are declarative as class definitions, each node has a Java class definition, and the node types are all defined as a hierarchy of Java classes. The operations and the values, which are represented as nodes, are defined by their corresponding types, for example <strong class="source-inline">AddNode</strong>, <strong class="source-inline">IfNode</strong>, and <strong class="source-inline">SwitchNode</strong>, all of them deriving from the base class, <strong class="source-inline">Node</strong>. The edges (operands) are represented as fields of the class. The following diagram shows the hierarchy of various types of node: </p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_4.21_B16878.jpg" alt="Figure 4.21 – Graal Graph nodes – The class hierarchy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.21 – Graal Graph nodes – The class hierarchy</p>
			<p>The representation of code in SSA enables the <a id="_idIndexMarker356"/>creation of a single version of the variable for each value. This helps perform better data flow analysis and optimizations. A phi function (Φ) is used to convert decision-based control paths (such as <strong class="source-inline">if</strong> and <strong class="source-inline">switch</strong>). The Phi function is a function of two values, and the value is selected based on the control flow. Refer to the following papers on SSA for more details: https://gcc.gnu.org/onlinedocs/gccint/SSA.html and <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">https://en.wikipedia.org/wiki/Static_single_assignment_form</a>. The key point is that the complete program is converted into an SSA to perform the optimizations.</p>
			<p>Graal IRs are built as a Graal graph, where each node has input edges that point to the nodes that create the operands and the successor edges that show the control flow. The successor edge points to the <a id="_idIndexMarker357"/>node that succeeds the current node in terms of the control flow. </p>
			<p>To demonstrate everything that we have discussed so far, let's analyze some simple Java code with The Ideal Graph Visualizer. The logic in this code may not generate a simple graph – the code is intentionally kept simple. The loops are there to hit the threshold so that when the JVM hits the threshold, it will perform Graal JIT compilation, as shown next:</p>
			<p class="source-code">public class DemonstrateGraalGraph {</p>
			<p class="source-code">    public long calculateResult() {</p>
			<p class="source-code">        long result = 0;</p>
			<p class="source-code">        for (int i=0; i&lt;2000; i++) {</p>
			<p class="source-code">            result = result + i;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return result;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        DemonstrateGraalGraph obj =            new DemonstrateGraalGraph();</p>
			<p class="source-code">        while (true) { </p>
			<p class="source-code">    //This loop is just to reach the compiler threshold</p>
			<p class="source-code">            long result = obj.calculateResult();</p>
			<p class="source-code">            System.out.println("Total: " + result);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's now compile the preceding code using the <strong class="source-inline">javac DemonstrateGraalGraph.java</strong> command. To keep the graph simple, we will compile only the <strong class="source-inline">calculateResult()</strong> method by using the <strong class="source-inline">-XX:CompileOnly=DemonstrateGraalGraph:calculateResult</strong> flag. Let's also disable <a id="_idIndexMarker358"/>some optimizations using the following flags:</p>
			<p><strong class="source-inline">-Dgraal.FullUnroll=false</strong>, <strong class="source-inline">-Dgraal.PartialUnroll=false</strong>, <strong class="source-inline">-Dgraal.LoopPeeling=false</strong>, <strong class="source-inline">-Dgraal.LoopUnswitch=false</strong>, <strong class="source-inline">-Dgraal.OptScheduleOutOfLoops=false</strong>, and <strong class="source-inline">-Dgraal.VectorizeLoops=false</strong> </p>
			<p>So, we get the following:</p>
			<p class="source-code">java -XX:CompileOnly=DemonstrateGraalGraph::calculateResult \</p>
			<p class="source-code"> -XX:-UseOnStackReplacement \</p>
			<p class="source-code"> -Dgraal.Dump=:1 \</p>
			<p class="source-code"> -XX:+PrintCompilation \    </p>
			<p class="source-code">  -Dgraal.FullUnroll=false \</p>
			<p class="source-code">  -Dgraal.PartialUnroll=false \</p>
			<p class="source-code">  -Dgraal.LoopPeeling=false \</p>
			<p class="source-code">  -Dgraal.LoopUnswitch=false \</p>
			<p class="source-code">  -Dgraal.OptScheduleOutOfLoops=false \</p>
			<p class="source-code">  -Dgraal.VectorizeLoops=false  \</p>
			<p class="source-code">DemonstrateGraalGraph</p>
			<p>This will create a folder called <strong class="source-inline">graal_dumps</strong> with a dump of all the Graal JIT activities. Once you load the <strong class="source-inline">bgv</strong> file that is generated by Graal, you will find the various tiers of optimization listed in the left pane, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_4.22_B16878.jpg" alt="Figure 4.22 – The Ideal Graph Visualizer – DemonstrateGraalGraph – left pane&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22 – The Ideal Graph Visualizer – DemonstrateGraalGraph – left pane</p>
			<p>When you click on <strong class="bold">0: After parsing</strong> on the right page, you will see the Graal graph representation after parsing the bytecode. In the graph, the red lines represent the control flow and the blue lines represent the <a id="_idIndexMarker359"/>data flow. The control flow has to be read from top to bottom, but data flow normally can be understood by reading upward. Let's understand this picture and compare it with the code. Please note that this graph is only for the <strong class="source-inline">calculateResult()</strong> method as we asked the JVM to create only compile <strong class="source-inline">calculateResult()</strong> method. Let's understand this graph better: </p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_4.23_B16878.jpg" alt="Figure 4.23 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph after parsing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph after parsing</p>
			<p>The program starts with <strong class="bold">0 Start</strong> and the loop starts at the <strong class="bold">7 LoopBegin</strong> node. To make the graph easier to understand, some of the <a id="_idIndexMarker360"/>sections are highlighted with the labels <strong class="bold">A</strong> and <strong class="bold">B</strong>. Let's explore what these sections of the graph are. </p>
			<p><strong class="bold">Section A</strong></p>
			<ul>
				<li>Section A highlights the <strong class="source-inline">for</strong> loop. It is converted into a <strong class="source-inline">18 if</strong> statement. The input for the <strong class="source-inline">if</strong> statement is the current value of I, which is the output of the Phi node <strong class="source-inline">9 Phi(4,22,i32)</strong> and constant 2000 node <strong class="source-inline">11 C(2000) i32</strong>.</li>
				<li>Phi is attached where the control flows merge. In this case, <em class="italic">9 Phi (4,22, i32)</em> merges the output from <strong class="source-inline">4 C(0) i32</strong> (<strong class="source-inline">i=0</strong> in the <strong class="source-inline">for</strong> loop) and the output of the <strong class="source-inline">22 +</strong> node (which is <strong class="source-inline">i++</strong>). This node will simply output the current value of the <strong class="source-inline">i</strong> after incrementing by the value of the <strong class="bold">21 C(1) i32 node</strong>. </li>
				<li>This then flows into the <strong class="bold">12 &lt;</strong> node and is compared with <strong class="bold">11 C(2000) i32</strong> (which is the maximum value of the loop), and this expression is evaluated by control flow node <strong class="bold">18 if</strong>.</li>
			</ul>
			<p><strong class="bold">Section B</strong></p>
			<ul>
				<li>Section B highlights the section where the result is calculated.</li>
				<li>The initial value of the <a id="_idIndexMarker361"/>result is represented as <strong class="bold">C (0) i64</strong>. It is <strong class="source-inline">i64</strong>, as we declared it as a <strong class="source-inline">long</strong>.</li>
				<li>The <strong class="bold">8 Phi(3, 20, i64)</strong> node merges the control flow to calculate the <strong class="source-inline">result = result + i</strong> expression. The value of <strong class="source-inline">i</strong> is flowing from the <strong class="bold">19 SignExtend</strong> node, which is an output of the current value of <strong class="source-inline">I</strong>, which flows from <strong class="bold">9 Phi(4,22, i32)</strong>.</li>
				<li>The final out flows into <strong class="bold">24 Return</strong> when the loop ends at <strong class="bold">18 if</strong>.</li>
			</ul>
			<p>Now we can go through each phase of optimization by selecting the phase in the left pane to see how the code is optimized. Let's quickly look at how this graph is transformed through the phases. When we select <strong class="bold">Before Phase Lowering</strong> in the left pane's <strong class="bold">Outline</strong> window, we will see the following graph:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_4.24_B16878.jpg" alt="Figure 4.24 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal graph before lowering&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.24 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal graph before lowering</p>
			<p>In this phase, we can see the following optimizations:</p>
			<ul>
				<li>The <strong class="bold">19 Sign Extend</strong> node is replaced with <strong class="bold">27 Zero Extend</strong>, as the compiler found out that it is an unsigned integer. Operations with unsigned integers are less expensive than operations with signed integers.</li>
				<li>The <strong class="bold">12 &lt;</strong> node is <a id="_idIndexMarker362"/>replaced with <strong class="bold">26 |&lt;|</strong>, which is an unsigned less than operation, which is faster. The compiler arrives at this conclusion based on the various iterations and profiling. Since the operands are considered unsigned, even the operations are considered unsigned.</li>
				<li>The graph also illustrates application of the canonicalization technique of replacing &lt;= with &lt;, to speed up the <strong class="source-inline">if</strong> (which is originally the <strong class="source-inline">for</strong> loop) statements.</li>
			</ul>
			<p>The subsequent phases – high tier, mid tier, and low tier – may not show significant optimizations, as the code is relatively simple and we have <a id="_idIndexMarker363"/>disabled some of the optimizations to keep the graph simple to read and understand: </p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_4.25_B16878.jpg" alt="Figure 4.25 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph, other tiers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.25 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph, other tiers</p>
			<p><em class="italic">Figure 4.26</em> is a diagram of the graph with all optimizations enabled. You will see that loop unrolling has been used very prominently to speed up the loops:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_4.26_B16878.jpg" alt="Figure 4.26 – The Ideal Graph Visualizer – DemonstrateGraalGraph – The final optimized graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.26 – The Ideal Graph Visualizer – DemonstrateGraalGraph – The final optimized graph</p>
			<p>Graal performs various optimizations as part of the <a id="_idIndexMarker364"/>tiered compilation. We will go through this in detail in the next section, and also see how we can use this knowledge to improve the way we write the code.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor085"/>Understanding Graal compiler optimizations</h1>
			<p>The Graal compiler performs <a id="_idIndexMarker365"/>some of the most advanced optimizations on the code just in time. The most critical ones are discussed in the following subsections. </p>
			<p>Before getting into this session, please refer to the <em class="italic">Understanding the optimizations performed by JIT</em> section of <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT</em>.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor086"/>Speculative optimization</h2>
			<p>JIT compilation relies <a id="_idIndexMarker366"/>heavily on the runtime profiling of the code. As we have seen, the graphs are optimized based on the HotSpots. HotSpots, as we covered in <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT</em>, are the control flows that the program goes through most frequently. There is no point in trying to optimize the <a id="_idIndexMarker367"/>whole code; instead, the JIT compiler tries to optimize the hot control paths/flows. This is based on speculation and assumption. When an assumption is proven wrong during execution, the compiler quickly deoptimizes and waits for another opportunity to optimize based on new HotSpots. We covered compiler thresholds and Hot Spots in <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT</em>, in the <em class="italic">Compiler threshold</em> section. Graal JIT also uses similar techniques to identify the hotspots. Graal performs all the optimizations that we discussed in <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, Hotspot, and GraalJIT</em>, in the <em class="italic">Understanding the optimizations performed by JIT</em> section, but also uses some advanced techniques. Let's go through some of the most important optimization techniques that Graal JIT applies to the code.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor087"/>Partial escape analysis</h2>
			<p>In <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT</em>, in the <a id="_idIndexMarker368"/>section titled <em class="italic">Understanding the optimizations performed by JIT</em>, we explored escape analysis. Escape analysis is one of the most powerful techniques. It identifies the <a id="_idIndexMarker369"/>object's scope and the objects escape from local to global scope. If it identifies objects that don't escape, there is an opportunity to optimize, and the compiler will optimize the code to use stack allocation instead of heap allocation for the objects that are within the local scope. This saves a significant amount of time in allocating and deallocating memory in the heap. </p>
			<p>Partial escape analysis takes this <a id="_idIndexMarker370"/>further by not just limiting to identifying objects that escape a method level scope to control branches. This <a id="_idIndexMarker371"/>helps to optimize the code when an object is found to be escaping only in certain control flows. Other control flows where the object is not escaping can be optimized to either use a local value or scalar replacements.</p>
			<p>Partial escape analysis looks for escapes that might happen through method calls, return values, throw statements, and so on. Let's use a simple code to understand how this works:</p>
			<p class="source-code">public void method(boolean flag) {</p>
			<p class="source-code">    Class1 object1 = new Class1();</p>
			<p class="source-code">    Class2 object2 = new Class2();</p>
			<p class="source-code">    //some processing</p>
			<p class="source-code">    object1.parameter = value;</p>
			<p class="source-code">    //some more logic</p>
			<p class="source-code">    if(flag) {</p>
			<p class="source-code">        return object1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return object2;</p>
			<p class="source-code">}</p>
			<p>The preceding is some sample code, just to illustrate partial escape analysis. In this code we are creating <strong class="source-inline">object1</strong> as an instance of <strong class="source-inline">Class1</strong> and <strong class="source-inline">object2</strong> as an instance of <strong class="source-inline">Class2</strong>. Some processing is happening, and <strong class="source-inline">object1</strong> fields are updated with some values that are calculated. Based on the flag, <strong class="source-inline">object1</strong> or <strong class="source-inline">object2</strong> will escape. Let's assume that most of the time the flag is <strong class="source-inline">false</strong>, and only <strong class="source-inline">object1</strong> escapes, so there is no point in creating <strong class="source-inline">object1</strong> every time the method is called. This code gets optimized to something like the following (this is just an illustration of how partial escape analysis works; the Graal JIT may not do this exact refactoring):</p>
			<p class="source-code">public void method(boolean flag) {</p>
			<p class="source-code">    </p>
			<p class="source-code">    Class2 object2 = new Class2();</p>
			<p class="source-code">    </p>
			<p class="source-code">    tempValue = value;</p>
			<p class="source-code">    if(flag) {</p>
			<p class="source-code">        Class1 object1 = new Class1();</p>
			<p class="source-code">        object1.parameter = tempValue;</p>
			<p class="source-code">        return object1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return object2;</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">object1</strong> is only <a id="_idIndexMarker372"/>created if required, and a temporary <a id="_idIndexMarker373"/>variable is used to store the intermediate values, and if <strong class="source-inline">object1</strong> has to be initialized then it uses the temporary values before it escapes. This optimizes heap allocation time and heap size.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor088"/>Inter-procedural analysis and inlining</h2>
			<p>Graal performs <a id="_idIndexMarker374"/>optimization at <a id="_idIndexMarker375"/>the AST/Graph level. This helps Graal to perform inter-procedural <a id="_idIndexMarker376"/>analysis and identify any option <a id="_idIndexMarker377"/>that may never become empty and skips compiling that part of the code, as it may never be called. It adds a guard to that code block, just in case. If the control flows through that block, the JIT can deoptimize the code.</p>
			<p>To understand inter-procedural analysis and inlining, one commonly used example is a JDK class, <strong class="source-inline">OptionalDouble</strong>. Here is a snippet of the <strong class="source-inline">OptionalDouble</strong> class:</p>
			<p class="source-code">public class OptionalDouble {</p>
			<p class="source-code">    public double getAsDouble() {</p>
			<p class="source-code">        if (!isPresent) {</p>
			<p class="source-code">            throw new                 NoSuchElementException("No valuepresent");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return value;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's say we call this <strong class="source-inline">getAsDouble()</strong> method, and the method has a <strong class="source-inline">throw</strong> block, but that <strong class="source-inline">throw</strong> block may <a id="_idIndexMarker378"/>never be called. The Graal compiler will compile all the code, except the <strong class="source-inline">if</strong> block, and will place a <strong class="source-inline">guard</strong> statement so <a id="_idIndexMarker379"/>that, if it gets called, it can <a id="_idIndexMarker380"/>deoptimize the code. Apart from this, Graal performs more advanced inlining to optimize the code. We can look at the complete set of <a id="_idIndexMarker381"/>optimizations that Graal performs by passing <strong class="source-inline">-Dgraal.Dump=:2</strong>. With Graal dump at level 2, we get a much more detailed list of graphs for each phase. In the next screenshot, you can see a whole list of optimizations the Graal JIT performed on the code across the various tiers of compilation:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_4.27_B16878.jpg" alt="Figure 4.27 – The Ideal Graph Visualizer – DemonstrateGraalGraph – compilation tiers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.27 – The Ideal Graph Visualizer – DemonstrateGraalGraph – compilation tiers</p>
			<p>By looking at how the graph is <a id="_idIndexMarker382"/>optimized at each step, we can see every area where the code can be optimized at <a id="_idIndexMarker383"/>development time. This <a id="_idIndexMarker384"/>will reduce the load on Graal JIT and the code will perform better. Some of these <a id="_idIndexMarker385"/>optimization techniques are covered in the <em class="italic">Understanding the optimizations performed by JIT</em> section of <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT</em>.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor089"/>Debugging and monitoring applications</h1>
			<p>GraalVM comes with a rich set of <a id="_idIndexMarker386"/>tools for debugging and monitoring applications. We have already looked at VisualVM and the Ideal Graph Visualizer. As you saw in the previous sections, these two tools are very powerful for detailed analysis. This analysis also provides insights into how we can improve the code at the development time to reduce the load on Graal JIT, and write high-performing and low-footprint Java code. Apart from these two tools, the following are some of the other tools that Graal comes with.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor090"/>Visual Studio Code extension</h2>
			<p>The Visual Studio Code extension is <a id="_idIndexMarker387"/>one of the <a id="_idIndexMarker388"/>most powerful integrated development environments for Graal. The following screenshot shows the GraalVM Extension for Visual Studio Code:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_4.28_B16878.jpg" alt="Figure 4.28 – GraalVM environments on Visual Studio Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.28 – GraalVM environments on Visual Studio Code</p>
			<p>In the previous screenshot, you <a id="_idIndexMarker389"/>can see all the various GraalVM installations that have been <a id="_idIndexMarker390"/>configured on the left pane. It is very easy to switch between various versions of GraalVM, and the terminal and the whole environment will use the selected GraalVM.</p>
			<p>This extension also makes it easy to install optional components. We don't have to manually run <strong class="source-inline">gu</strong> commands. This extension provides easy way to build, debug, and run code written in Java, Python, R, Ruby, and Polyglot (mixed language code).</p>
			<p>This extension can be directly installed from the Visual Studio Code Extensions tab by searching for Graal. The following screenshot shows the extension installation page:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_4.29_B16878.jpg" alt="Figure 4.29 – Installing the GraalVM Extension for Visual Studio Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.29 – Installing the GraalVM Extension for Visual Studio Code</p>
			<p>There is also a GraalVM Extension Pack that <a id="_idIndexMarker391"/>comes with <a id="_idIndexMarker392"/>additional features such as Micronaut framework integration and NetBeans Language Server, which provide Java code completion, refactoring, Javadoc integration, and many more advanced features. The next screenshot shows the installation page for the GraalVM Extension Pack:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_4.30_B16878.jpg" alt="Figure 4.30 – GraalVM Extension Pack plugin for Visual Studio Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.30 – GraalVM Extension Pack plugin for Visual Studio Code</p>
			<p>You can learn more about this <a id="_idIndexMarker393"/>extension on the GraalVM website at <a href="https://www.graalvm.org/tools/vscode/graalvm-extension/">https://www.graalvm.org/tools/vscode/graalvm-extension/</a>.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor091"/>GraalVM Dashboard</h2>
			<p>GraalVM Dashboard is a <a id="_idIndexMarker394"/>web-based tool with <a id="_idIndexMarker395"/>which we can perform detailed analysis of both static and dynamic compilations. This is very powerful for Native Image analysis. The tool provides details dashboard reports on compilation, reachability, usability, profiling data, dynamic compilation parameters, deoptimization, and more.</p>
			<p>We will run this tool in the next chapter, when we create a native image of our sample code and perform more detailed analysis of the native image code.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor092"/>Command-line tools</h2>
			<p>There are two command-line tools that <a id="_idIndexMarker396"/>can be used in the context of Polyglot to identify further opportunities the optimize the code. We will be using these tools in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>, for Polyglot optimization. The following are the two command-line tools that come with GraalVM:</p>
			<ul>
				<li><strong class="bold">Profiling CLI</strong>: This tool <a id="_idIndexMarker397"/>helps to identify <a id="_idIndexMarker398"/>opportunities to optimize CPU and memory usage. Please refer to <a href="https://www.graalvm.org/tools/profiling/">https://www.graalvm.org/tools/profiling/</a> for <a id="_idIndexMarker399"/>more details.</li>
				<li><strong class="bold">Code Coverage CLI</strong>: This tools records and analyzes <a id="_idIndexMarker400"/>the code coverage for each execution. This is very powerful for running test <a id="_idIndexMarker401"/>cases and ensuring good code coverage. This tool can also identify possible dead code that can be eliminated, or hot code that <a id="_idIndexMarker402"/>can be optimized at development time. Please refer to <a href="https://www.graalvm.org/tools/code-coverage/">https://www.graalvm.org/tools/code-coverage/</a> for more details.</li>
			</ul>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor093"/>Chrome debugger</h2>
			<p>The Chrome debugger provides the <a id="_idIndexMarker403"/>Chrome developer <a id="_idIndexMarker404"/>tool extension to debug guest language applications. The Chrome debugger can be used while running the application with the <strong class="source-inline">--inspect</strong> option. This helps debug JavaScript (Node.js) using Chrome. The extension can be installed from <a href="https://developers.google.com/web/tools/chrome-devtools/">https://developers.google.com/web/tools/chrome-devtools/</a>.We will be <a id="_idIndexMarker405"/>covering this tool while we discuss JavaScript and Node.js on Graal in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor094"/>Summary</h1>
			<p>In this chapter, we went through Graal JIT and Ahead of Time compilers in detail. We took a sample code and looked at how Graal JIT performs various optimizations using the Ideal Graph Visualizer. We also went through Graal Graphs in detail. This is very critical knowledge that will help you analyze and identify optimizations that can be applied during development to speed up Graal JIT compilation at runtime. </p>
			<p>In this chapter, you have gained a detailed understanding of the internal workings of Graal JIT compilation, and how to fine-tune Graal JIT. You also have gained a good understanding of how to use some of the advanced analysis and diagnosis tools to debug Graal JIT compilation, and identify opportunities to optimize the code.</p>
			<p>In the next chapter, we will take a more detailed look at Graal Ahead of Time compilation.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor095"/>Questions</h1>
			<ol>
				<li>What are the various tiers of Graal JIT compilation?</li>
				<li>What is an intermediate representation?</li>
				<li>What is SSA?</li>
				<li>What is speculative optimization?</li>
				<li>What is the difference between escape analysis and partial escape analysis?</li>
			</ol>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor096"/>Further reading</h1>
			<ul>
				<li>Partial Escape Analysis and Scalar Replacement for Java (<a href="https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf">https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf</a>)</li>
				<li>Understanding Basic Graal Graphs (<a href="https://chrisseaton.com/truffleruby/basic-graal-graphs/">https://chrisseaton.com/truffleruby/basic-graal-graphs/</a>)</li>
				<li>Optimizing Strategies of GraalVM (<a href="https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm">https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm</a>)</li>
				<li>GraalVM Enterprise Edition (EE) (<a href="https://docs.oracle.com/en/graalvm/enterprise/19/index.html">https://docs.oracle.com/en/graalvm/enterprise/19/index.html</a>)</li>
				<li>GraalVM documentation (<a href="https://www.graalvm.org/docs/introduction/">https://www.graalvm.org/docs/introduction/</a>)</li>
				<li>Static Single Assignment (<a href="https://gcc.gnu.org/onlinedocs/gccint/SSA.html">https://gcc.gnu.org/onlinedocs/gccint/SSA.html</a>)</li>
			</ul>
		</div>
	</body></html>