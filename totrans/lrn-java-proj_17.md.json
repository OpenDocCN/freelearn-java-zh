["```java\nclass MyThread extends Thread {    @Override\n    public void run() {\n        System.out.println(\"Hello from MyThread!\");\n    }\n}\n```", "```java\npublic class Main {    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        myThread.start(); // starts the new thread\n    System.out.println(\"Hello from Main!\");\n    }\n}\n```", "```java\nHello from MyThread!Hello from Main!\n```", "```java\nclass MyRunnable implements Runnable {    @Override\n    public void run() {\n        System.out.println(\"Hello from MyRunnable!\");\n    }\n}\n```", "```java\npublic class Main {    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start(); // starts the new thread\n    }\n}\n```", "```java\nHello from MyRunnable!\n```", "```java\nclass MyRunnable implements Runnable {    @Override\n    public void run() {\n        System.out.println(\"Hello from thread: \" + Thread.\n          currentThread().threadId());\n    }\n}\n```", "```java\npublic class Main {    public static void main(String[] args) {\n        System.out.println(\"Hello from main: \" + Thread.\n          currentThread().threadId());\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start(); // starts the new thread\n    }\n}\n```", "```java\nHello from main: 1Hello from thread: 22\n```", "```java\npublic static void main(String[] args) {        System.out.println(\"Hello from main: \" + Thread.\n          currentThread().threadId());\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.run(); // doesn't start a new thread\n    }\n```", "```java\nHello from main: 1Hello from thread: 1\n```", "```java\npublic static void main(String[] args) {    Runnable myRunnable = () -> System.out.println(\"Hello\n      from a lambda Runnable!\");\n    Thread thread = new Thread(myRunnable);\n    thread.start(); // starts the new thread\n}\n```", "```java\nHello from a lambda Runnable!\n```", "```java\npublic class Main {    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            try {\n      // Next two lines represent the same Java line\n                System.out.println(\"Thread will go to sleep\n                  for 2 seconds...\");\n                Thread.sleep(2000);\n                System.out.println(\"*Yawn...* I'm awake!\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        t.start();\n    }\n}\n```", "```java\npublic class Main {    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            System.out.println(\"t1 started\");\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Thread finished!\");\n        });\n        t1.start();\n        try {\n            System.out.println(\"Main thread will be waiting\n              for other t1 to be done...\");\n            t1.join();\n            System.out.println(\"Main thread continues...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\nMain thread will be waiting for other t1 to be done...t1 started\nt1 finished!\nMain thread continues...\n```", "```java\npublic class ExampleAtomicInteger {    private static AtomicInteger counter = new\n      AtomicInteger(0);\n    public static void main(String[] args) throws\n      InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 10000; i++) {\n                counter.getAndIncrement();\n            }\n        });\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 10000; i++) {\n                counter.getAndIncrement();\n            }\n        });\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        System.out.println(\"Counter value: \" + counter);\n    }\n}\n```", "```java\nCounter value: 20000\n```", "```java\npublic class Count {    static int counter = 0;\n    static void incrementCounter() {\n        int current = counter;\n        System.out.println(\"Before: \" + counter + \",\n          Current thread: \" + Thread.currentThread()\n            .threadId());\n        counter = current + 1;\n        System.out.println(\"After: \" + counter);\n    }\n}\n```", "```java\nBefore: 0, Current thread: 1After: 1\nBefore: 1, Current thread: 1\nAfter: 2\nBefore: 2, Current thread: 1\nAfter: 3\nBefore: 3, Current thread: 1\nAfter: 4\nBefore: 4, Current thread: 1\nAfter: 5\nBefore: 5, Current thread: 1\nAfter: 6\nBefore: 6, Current thread: 1\nAfter: 7\nBefore: 7, Current thread: 1\nAfter: 8\nBefore: 8, Current thread: 1\nAfter: 9\nBefore: 9, Current thread: 1\nAfter: 10\n```", "```java\npublic class Main {    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Thread(Count::incrementCounter).start();\n        }\n    }\n}\n```", "```java\nBefore: 0, Current thread: 26Before: 0, Current thread: 29\nBefore: 0, Current thread: 22\nBefore: 0, Current thread: 30\nBefore: 0, Current thread: 25\nBefore: 0, Current thread: 31\nBefore: 0, Current thread: 23\nBefore: 0, Current thread: 24\nBefore: 0, Current thread: 27\nBefore: 0, Current thread: 28\nAfter: 1\nAfter: 1\nAfter: 1\nAfter: 1\nAfter: 1\nAfter: 1\nAfter: 1\nAfter: 1\nAfter: 1\nAfter: 1\n```", "```java\npublic class Count {    static int counter = 0;\n    static synchronized void incrementCounter() {\n        int current = counter;\n        System.out.println(\"Before: \" + counter + \",\n          Current thread: \" + Thread.currentThread()\n            .threadId());\n        counter = current + 1;\n        System.out.println(\"After: \" + counter);\n    }\n}\n```", "```java\nBefore: 0, Current thread: 22After: 1\nBefore: 1, Current thread: 31\nAfter: 2\nBefore: 2, Current thread: 30\nAfter: 3\nBefore: 3, Current thread: 29\nAfter: 4\nBefore: 4, Current thread: 28\nAfter: 5\nBefore: 5, Current thread: 27\nAfter: 6\nBefore: 6, Current thread: 26\nAfter: 7\nBefore: 7, Current thread: 25\nAfter: 8\nBefore: 8, Current thread: 24\nAfter: 9\nBefore: 9, Current thread: 23\nAfter: 10\n```", "```java\nclass Counter {    private int count;\n    public void increment() {\n        synchronized (this) {\n            count++;\n        }\n    }\n    public int getCount() {\n        synchronized (this) {\n            return count;\n        }\n    }\n}\n```", "```java\nimport java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;\npublic class Count {\n    static int counter = 0;\n    static Lock lock = new ReentrantLock();\n    static void incrementCounter() {\n        try {\n            lock.lock();\n            int current = counter;\n            System.out.println(\"Before: \" + counter + \",\n              Current thread: \" + Thread.currentThread()\n                .threadId());\n            counter = current + 1;\n            System.out.println(\"After: \" + counter);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```", "```java\npublic class Main {    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Thread(Count::incrementCounter).start();\n        }\n    }\n}\n```", "```java\nBefore: 0, Current thread: 22After: 1\nBefore: 1, Current thread: 23\nAfter: 2\nBefore: 2, Current thread: 24\nAfter: 3\nBefore: 3, Current thread: 25\nAfter: 4\nBefore: 4, Current thread: 26\nAfter: 5\nBefore: 5, Current thread: 27\nAfter: 6\nBefore: 6, Current thread: 28\nAfter: 7\nBefore: 7, Current thread: 29\nAfter: 8\nBefore: 8, Current thread: 30\nAfter: 9\nBefore: 9, Current thread: 31\nAfter: 10\n```", "```java\npublic class Count {    static int counter = 0;\n    static Lock lock = new ReentrantLock();\n    static void incrementCounter() {\n        if (lock.tryLock()) {\n            try {\n                int current = counter;\n                System.out.println(\"Before: \" + counter +\n                  \", Current thread: \" + Thread.\n                    currentThread().threadId());\n                counter = current + 1;\n                System.out.println(\"After: \" + counter);\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\"Thread didn't get the lock\n              and is looking for a new task.\");\n        }\n    }\n}\n```", "```java\nMap<String, String> languageMap = new HashMap<>();languageMap.put(\"Maaike\", \"Java\");\nlanguageMap.put(\"Seán\", \"C#\");\nfor (String key : languageMap.keySet()) {\n    System.out.println(key + \" loves coding\");\n    languageMap.remove(key);\n}\n```", "```java\nConcurrentMap<String, String> languageMap = new  ConcurrentHashMap<>();\nlanguageMap.put(\"Maaike\", \"Java\");\nlanguageMap.put(\"Seán\", \"C#\");\nfor (String key : languageMap.keySet()) {\n    System.out.println(key + \" loves coding\");\n    languageMap.remove(key);\n}\n```", "```java\nConcurrentMap<String, String> map = new  ConcurrentHashMap<>();\nmap.put(\"Nadesh\", \"PHP\");\nString language = map.get(\"Nadesh\");  // Returns \"PHP\"\n```", "```java\nBlockingQueue<String> queue = new LinkedBlockingQueue<>();queue.offer(\"Maria\");\nString name = queue.poll();\n```", "```java\nSet<String> set = new ConcurrentSkipListSet<>();set.add(\"Gaia\");\nset.add(\"Jonas\");\nset.add(\"Adnane\");\nfor (String s : set) {\n    System.out.println(s);\n}\n```", "```java\nMap<String, String> map = new ConcurrentSkipListMap<>();map.put(\"Flute\", \"Nabeel\");\nmap.put(\"Bass\", \"Job\");\nmap.put(\"Piano\", \"Malika\");\nfor (String s : map.keySet()) {\n    System.out.println(s + \": \" + map.get(s));\n}\n```", "```java\nList<String> list = new CopyOnWriteArrayList<>();list.add(\"Squirrel\");\nlist.add(\"Labradoodle\");\nlist.add(\"Bunny\");\nfor (String item : list) {\n    System.out.println(item);\n    list.add(item);\n}\nSystem.out.println(list);\n```", "```java\nSet<String> set = new CopyOnWriteArraySet<>();set.add(\"Dog\");\nset.add(\"Cat\");\nset.add(\"Horse\");\nfor (String s : set) {\n    System.out.println(s);\n    set.add(s);\n}\nSystem.out.println(set);\n```", "```java\nList<String> regularList = new ArrayList<>();List<String> syncList =\n  Collections.synchronizedList(regularList);\n```", "```java\nimport java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;\npublic class VoteCounter {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.\n          newSingleThreadExecutor();\n        // Submitting tasks\n        for(int i=1; i<=4; i++) {\n      // We must create a new variable to use in the\n      // lambda, because variables in lambdas must be\n      // effectively final. And i is not.\n            int voteId = i;\n            executor.execute(() -> {\n                System.out.println(\"Vote \" + voteId + \"\n                  counted by \" + Thread.currentThread().\n                    threadId());\n            });\n        }\n        // Remember to shutdown the executor\n        executor.shutdown();\n    }\n}\n```", "```java\nVote 1 counted by 22Vote 2 counted by 22\nVote 3 counted by 22\nVote 4 counted by 22\n```", "```java\nimport java.util.concurrent.*;public class VoteCounter {\n    private static final ExecutorService executorService =\n      Executors.newSingleThreadExecutor();\n    public static void main(String[] args) {\n        try {\n            Future<Integer> vote1 = getRandomVote(1);\n            Future<Integer> vote2 = getRandomVote(2);\n            Future<Integer> vote3 = getRandomVote(3);\n            Future<Integer> vote4 = getRandomVote(4);\n            // wait until all tasks are done\n            while (!(vote1.isDone() && vote2.isDone() &&\n              vote3.isDone() && vote4.isDone())) {\n                Thread.sleep(10); // sleep for 10ms then\n                                 //   try again\n            }\n            int totalVotes = vote1.get() + vote2.get() +\n              vote3.get() + vote4.get();\n            System.out.println(\"Total votes: \" +\n              totalVotes);\n        } catch (InterruptedException |\n            ExecutionException e) {\n            e.printStackTrace();\n        } finally {\n            executorService.shutdown();\n        }\n    }\n    public static Future<Integer> getRandomVote(int i) {\n        return executorService.submit(() -> {\n            Thread.sleep(1000); // simulate delay\n            System.out.println(\"Vote \" + i + \" counted by \"\n              + Thread.currentThread().threadId());\n            return 1; // each vote counts as 1\n        });\n    }\n}\n```", "```java\nVote 1 counted by 22Vote 2 counted by 22\nVote 3 counted by 22\nVote 4 counted by 22\nTotal votes: 4\n```", "```java\nimport java.util.Arrays;import java.util.List;\nimport java.util.concurrent.*;\npublic class VoteCounter {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.\n          newSingleThreadExecutor();\n        List<Callable<Integer>> callables = Arrays.asList(\n                () -> { Thread.sleep(1000); return 1; },\n                () -> { Thread.sleep(2000); return 2; }\n        );\n        try {\n            // Invoking any task and printing result\n            Integer result = executor.invokeAny(callables);\n            System.out.println(\"Result of the fastest task:\n              \" + result);\n            // Invoking all tasks and printing results\n            List<Future<Integer>> futures = executor.\n              invokeAll(callables);\n            for (Future<Integer> future : futures) {\n                System.out.println(\"Task result: \" +\n                  future.get());\n            }\n        } catch (InterruptedException |\n             ExecutionException e) {\n            e.printStackTrace();\n        }\n        executor.shutdown();\n    }\n}\n```", "```java\nResult of the fastest task: 1Task result: 1\nTask result: 2\n```", "```java\npublic static void main(String[] args) {    ExecutorService executorService = Executors.\n      newFixedThreadPool(3);\n    for (int i = 0; i < 100; i++) {\n        final int stationId = i;\n        executorService.submit(() -> {\n            try {\n                System.out.println(\"Counting votes from\n                   station: \" + stationId + \", Thread id: \"\n                     + Thread.currentThread().threadId());\n                Thread.sleep((int) (Math.random() * 200));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n    executorService.shutdown();\n}\n```", "```java\nCounting votes from station: 1, Thread id: 23Counting votes from station: 2, Thread id: 24\nCounting votes from station: 0, Thread id: 22\nCounting votes from station: 3, Thread id: 23\nCounting votes from station: 4, Thread id: 23\n[part omitted]\nCounting votes from station: 97, Thread id: 22\nCounting votes from station: 98, Thread id: 23\nCounting votes from station: 99, Thread id: 24\n```", "```java\npublic static void main(String[] args) {    ExecutorService executorService = Executors.\n       newCachedThreadPool();\n    for (int i = 0; i < 100; i++) {\n        final int stationId = i;\n        executorService.submit(() -> {\n            try {\n                System.out.println(\"Counting votes at\n                   station: \" + stationId + \", Thread id: \"\n                     + Thread.currentThread().threadId());\n                Thread.sleep((int) (Math.random() * 200));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n    executorService.shutdown();\n}\n```", "```java\nCounting votes at station: 5, Thread id: 27Counting votes at station: 19, Thread id: 41\nCounting votes at station: 24, Thread id: 46\nCounting votes at station: 3, Thread id: 25\nCounting votes at station: 6, Thread id: 28\nCounting votes at station: 0, Thread id: 22\n[middle omitted]\nCounting votes at station: 97, Thread id: 125\nCounting votes at station: 98, Thread id: 126\nCounting votes at station: 99, Thread id: 127\n```", "```java\nimport java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\npublic class VotingSystem {\n    private static final ScheduledExecutorService scheduler\n      = Executors.newScheduledThreadPool(1);\n    public static void main(String[] args) {\n        // Open voting\n        System.out.println(\"Voting started!\");\n        // Schedule voting to close after 1 hour\n        scheduler.schedule(VotingSystem::closeVoting, 1,\n          TimeUnit.HOURS);\n    }\n    private static void closeVoting() {\n        // Close voting\n        System.out.println(\"Voting closed!\");\n        // Shut down the scheduler\n        scheduler.shutdown();\n    }\n}\n```", "```java\nVoting started!Voting closed!\n```", "```java\n// Schedule reminders every 15 minutes  scheduler.scheduleAtFixedRate(VotingSystem::remindVoters,\n  15, 15, TimeUnit.MINUTES);\n// ...\nprivate static void remindVoters() {\n    // Remind voters\n    System.out.println(\"Remember to vote! Voting will close\n      soon!\");\n}\n```", "```java\nVoting started!Remember to vote! Voting will close soon!\nRemember to vote! Voting will close soon!\nRemember to vote! Voting will close soon!\nRemember to vote! Voting will close soon!\nVoting closed!\n```", "```java\n    private static int counter = 0;    public static void main(String[] args) throws\n      InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 10000; i++) {\n                counter++;\n            }\n        });\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 10000; i++) {\n                counter++;\n            }\n        });\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        System.out.println(\"Counter value: \" + counter);\n    }\n}\n```", "```java\nCounter value: 12419\n```", "```java\nCounter value: 13219\n```", "```java\nCounter value: 15089\n```", "```java\nclass Counter {    private int count = 0;\n    public void increment() {\n        count++;\n    }\n    public int getCount() {\n        return count;\n    }\n}\n```", "```java\nclass Flight {    private int seatsAvailable;\n    public Flight(int seats) {\n        this.seatsAvailable = seats;\n    }\n    public void bookSeat() {\n        if(seatsAvailable > 0) {\n            try {\n                // Simulate the time needed\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(e);\n            }\n            seatsAvailable--;\n            System.out.println(Thread.currentThread().\n                getName() + \" successfully booked a seat.\n                Remaining seats: \" + seatsAvailable);\n        } else {\n            System.out.println(\"Sorry, \" + Thread.\n              currentThread().getName() + \". The flight is\n                fully booked.\");\n        }\n    }\n    public int getSeatsAvailable() {\n        return seatsAvailable;\n    }\n}\n```", "```java\nObject resourceA = new Object();Object resourceB = new Object();\nThread thread1 = new Thread(() -> {\n    synchronized (resourceA) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        synchronized (resourceB) {\n            System.out.println(\"Thread 1: Locked\n              ResourceB\");\n        }\n    }\n});\nThread thread2 = new Thread(() -> {\n    synchronized (resourceB) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        synchronized (resourceA) {\n            System.out.println(\"Thread 2: Locked\n              ResourceA\");\n        }\n    }\n});\nthread1.start();\nthread2.start();\n```", "```java\npublic class ExampleLivelock {    public static void main(String[] args) {\n        run();\n    }\n    public static void run(){\n        final PhoneCall buddy1 = new PhoneCall(\"Patricia\");\n        final PhoneCall buddy2 = new PhoneCall(\"Patrick\");\n        final HangUpButton s = new HangUpButton(buddy1);\n        new Thread(new Runnable() {\n            public void run() { buddy1.callWith(s, buddy2); }\n        }).start();\n        new Thread(new Runnable() {\n            public void run() { buddy2.callWith(s, buddy1); }\n        }).start();\n    }\n    static class HangUpButton {\n        private PhoneCall owner;\n        public HangUpButton(PhoneCall d) { owner = d; }\n        public PhoneCall getOwner() { return owner; }\n        public synchronized void setOwner(PhoneCall d) {\n            owner = d;\n        }\n        public synchronized void use() {\n            System.out.printf(\"%s has hang up!\",\n              owner.name);\n        }\n    }\n    static class PhoneCall {\n        private String name;\n        private boolean isDone;\n        public PhoneCall(String n) {\n            name = n; isDone = true;\n        }\n        public String getName() { return name; }\n        public boolean isDone() { return isDone; }\n        public void callWith(HangUpButton hangUpButton,\n          PhoneCall buddy) {\n            while (isDone) {\n                if (hangUpButton.owner != this) {\n                    try {\n                        Thread.sleep(1);\n                    }catch(InterruptedException e) {\n                        continue;\n                    }\n                    continue;\n                }\n                if (buddy.isDone()) {\n                    System.out.printf(\n                            \"%s: You hang up, buddy %s!%n\",\n                            name, buddy.getName());\n                    hangUpButton.setOwner(buddy);\n                    continue;\n                }\n            }\n        }\n    }\n}\n```", "```java\nObject sharedResource = new Object();Thread highPriorityThread = new Thread(() -> {\n    synchronized (sharedResource) {\n        try {\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n});\nhighPriorityThread.setPriority(Thread.MAX_PRIORITY);\nhighPriorityThread.start();\nThread lowPriorityThread = new Thread(() -> {\n    synchronized (sharedResource) {\n        System.out.println(\"Low priority thread accessed\n          the shared resource.\");\n    }\n});\nlowPriorityThread.setPriority(Thread.MIN_PRIORITY);\nlowPriorityThread.start();\n```", "```java\n    class Dinosaur {    private String status;    public Dinosaur(String status) {        this.status = status;    }    public String getStatus() {        return status;    }    public void setStatus(String status) {        this.status = status;    }}class DinosaurStatusUpdater implements Runnable {    private Dinosaur;    private String newStatus;    public DinosaurStatusUpdater(Dinosaur dinosaur,      String newStatus) {        this.dinosaur = dinosaur;        this.newStatus = newStatus;    }    @Override    public void run() {        dinosaur.setStatus(newStatus);        System.out.println(\"Dinosaur status set to: \"          + dinosaur.getStatus());    }}public class Main {    public static void main(String[] args) {        Dinosaur dinosaur = new Dinosaur(\"Healthy\");        Thread updater1 = new Thread(new          DinosaurStatusUpdater(dinosaur, \"Feeding\"));        Thread updater2 = new Thread(new          DinosaurStatusUpdater(dinosaur, \"Resting\"));        updater1.start();        updater2.start();    }}\n    ```", "```java\nimport java.util.concurrent.*;class ParkStatus {\n    private int foodStock;\n    public ParkStatus(int foodStock) {\n        this.foodStock = foodStock;\n    }\n    public int getFoodStock() {\n        return this.foodStock;\n    }\n    public void reduceFood(int amount) {\n        this.foodStock -= amount;\n    }\n}\nclass FeedingDinosaurs implements Runnable {\n    private ParkStatus parkStatus;\n    public FeedingDinosaurs(ParkStatus parkStatus) {\n        this.parkStatus = parkStatus;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            parkStatus.reduceFood(1);\n            System.out.println(\"Food stock after feeding: \"\n              + parkStatus.getFoodStock());\n        }\n    }\n}\nclass TrackingMovements implements Runnable {\n    private ParkStatus parkStatus;\n    public TrackingMovements(ParkStatus parkStatus) {\n        this.parkStatus = parkStatus;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            System.out.println(\"Current food stock: \" +\n              parkStatus.getFoodStock());\n        }\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        ParkStatus parkStatus = new ParkStatus(100);\n        Thread feedingThread = new Thread(new\n          FeedingDinosaurs(parkStatus));\n        Thread trackingThread = new Thread(new\n          TrackingMovements(parkStatus));\n        feedingThread.start();\n        trackingThread.start();\n    }\n}\n```"]