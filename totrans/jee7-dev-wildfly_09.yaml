- en: Chapter 9. Managing the Application Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered many Java Enterprise examples and deployed them on the
    application server. We will now dive headlong into the vast and varied ocean of
    instruments that are available to manage the application server. The purpose of
    this chapter is to teach you how to use these instruments to administer and monitor
    all the resources available on the application server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the WildFly **Command-line Interface** (**CLI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create scripts with the CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to programmatically manage your server resources using scripting languages
    and WildFly's client API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enforce role-based security for administrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entering the WildFly CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CLI is a complete management tool that can be used to start and stop servers,
    deploy and undeploy applications, configure system resources, and perform other
    administrative tasks. Operations in it can be executed in an atomic way or in
    batch modes, allowing you to run multiple tasks as a group.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Windows, you can start the CLI by entering the following command
    from the `JBOSS_HOME/bin` folder using the Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, enter the following command if you are using Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the CLI has started, you can connect to the managed server instance using
    the `connect` command, which by default connects to `localhost` and the `9990`
    port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to connect to another address or port, you can simply pass it to
    the `connect` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to launch a CLI in the connected mode; this allows it to
    be connected automatically and to possibly specify the commands to be executed.
    For example, the following `shell` command automatically connects to a WildFly
    instance and issues a `shutdown` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: CLI is especially useful for the automation of your software development process—**Continuous
    Integration** (**CI**) and production environment management systems can automatically
    control the life cycle of your application server with tools such as Chef ([https://www.getchef.com/](https://www.getchef.com/))
    or Puppet ([http://puppetlabs.com/](http://puppetlabs.com/)). It might be handy
    if you would like to minimize the number of manual tasks that are required to
    be done to deploy an application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting from remote hosts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting from the 7.1.0 Beta release of the application server, security is
    enabled on AS management interfaces by default to prevent unauthorized remote
    access to the application server. Although local clients of the application server
    are still allowed to access management interfaces without any authentication,
    remote clients need to enter a username/password pair to access a CLI. Here''s
    an example session that successfully connects to a remote host with the IP address
    `10.13.2.255`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 2](part0017_split_000.html#page "Chapter 2. Your First
    Java EE Application on WildFly"), *Your First Java EE Application on WildFly*,
    for more information about creating a user with the `add-user.sh` shell command.
  prefs: []
  type: TYPE_NORMAL
- en: Using a CLI in the graphical mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An interesting option available for the command-line interface is the graphical
    mode, which can be activated by adding the `--gui` parameter to the shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how CLI looks in the graphical mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a CLI in the graphical mode](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As described in the label, the resource will expand when you click on a folder;
    on the other hand, if you right-click on a node, you can fire an operation on
    it. The graphical mode could be useful to explore the possible configuration values
    or if you are not a big fan of console tools.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses how to construct CLI commands, which can be executed
    either in the terminal mode or the graphical mode.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing CLI commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All CLI operation requests allow you to have low-level interactions with the
    server management model. They provide a controlled way to edit the server configurations.
    An operation request consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An address that is prefixed with `/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operation name that is prefixed with `:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional set of parameters contained within `()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the resource address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The server configuration is presented as a hierarchical tree of addressable
    resources. Each resource node offers a different set of operations. The address
    specifies the resource node on which to perform the operation. An address uses
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The notations are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node-type`: This is the resource node type. This maps to an element name in
    the server configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node-name`: This specifies the resource node name. This maps to the name attribute
    of the element in the server configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Separate each level of the resource tree with a slash (`/`). So, for example,
    the following CLI expression identifies the ExampleDS data source registered in
    the data source subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Performing operations on resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have identified a resource, you can perform operations on the resource.
    An operation uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So in the previous example, you can query the list of available resources for
    your nodes by adding the `read-resource` command at the end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to query for a specific attribute of your node, you can use the
    `read-attribute` operation instead. For example, the following code shows how
    to read the enabled attribute from the data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from the operations on a specific resource, you can also perform a set
    of commands that are available on every path of your WildFly subsystem, such as
    `cd` or `ls` commands. These commands are pretty much equivalent to their Unix
    shell counterparts, and they allow you to navigate through the WildFly subsystems.
    Other important additions are the `deploy` and `undeploy` commands that, as you
    might guess, allow you to manage the deployment of applications. These key commands
    are discussed in the *Deploying applications using the CLI* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI, however, is not just about querying attributes from the WildFly subsystems;
    you can also set attributes or create resources. For example, if you were to set
    the HTTP port of the HTTP connector, you will have to use the corresponding `write`
    attribute on HTTP''s socket binding interface, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the operations that we have seen so far, which can be performed
    on every resource of your subsystems, there can be special operations that can
    be performed exclusively on one resource. For example, within the naming subsystem,
    you will be able to issue a `jndi-view` operation that will display the list of
    JNDI bindings, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using the tab completion helper
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Getting to know all the available commands in the CLI is a pretty hard task;
    this management interface includes an essential feature, the tab completion. Suppose
    the cursor is positioned at the beginning of an empty line; now if you type in
    `/` and press the *Tab* key, you will get the following list of all the available
    node types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After selecting the node type, you want to enter into the tree of resources,
    so type `=` and press the *Tab* key again. This will result in a list of all the
    following node names available for the chosen node type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have finished with the node path, adding a colon (`:`) at the end
    of the node path and pressing the *Tab* key will display all the available operation
    names for the selected node, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all the parameters of the `add` operation (after the operation name),
    press the *Tab* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Choose the parameter you want and specify its value after `=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when all the parameters have been specified, add `)` and press *Enter*
    to issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Deploying applications using the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying an application (in the standalone mode) can be easily performed by
    copying the application's archives into the `deployment` folder of your server
    distribution. That's a pretty handy option; however, we would like to stress the
    advantage of using a CLI, which offers a wide choice of additional options when
    deploying and also provides the opportunity to deploy applications remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'All it takes to deploy an application''s archive is a connection to the management
    instance, either local or remote, and by issuing of the `deploy` shell command.
    When used without arguments, the `deploy` command provides a list of applications
    that are currently deployed, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you feed a resource archive such as a `WAR` file to the shell, it will deploy
    it on the standalone server right away, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, a CLI uses the `JBOSS_HOME/bin` file as a source for your deployment
    archives. You can, however, use absolute paths when specifying the location of
    your archives; the CLI expansion facility (using the *Tab* key) makes this option
    fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Redeploying the application requires an additional flag to be added to the
    `deploy` command. Use the `-f` argument to force the application''s redeployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Undeploying the application can be done through the `undeploy` command, which
    takes the application that is deployed as an argument. This is shown in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By checking the WildFly configuration file (for example, `standalone.xml` or
    `domain.xml`), you will notice that the deployment element for your application
    has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying applications to a WildFly domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you are deploying an application using the domain mode, you will have
    to specify to which server group the deployment is associated with. The CLI lets
    you choose between the following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy to all server groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy to a single server group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss these choices in two separate sections.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to all server groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If this option is chosen, the application will be deployed to all the available
    server groups. The `--all-server-groups` flag can be used for this purpose. For
    example, refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you want to undeploy an application from all the server
    groups that belong to a domain, you will have to issue the `undeploy` command
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that the `undeploy` command uses the `--all-relevant-server`-group
    instead of the `--all-server-` group. The reason for this difference is that the
    deployment might not be enabled on all the server groups; therefore, by using
    this option, you will actually undeploy it from all the server groups in which
    the deployment is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to a single server group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other option lets you perform a selective deployment of your application
    only on the server groups you indicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You are not limited to a single server group, and you can separate multiple
    server groups with a comma (`,`). For example, refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The tab completion feature will help you to complete the value for the list
    of `--server-groups` selected for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we want to undeploy the application from just one server group.
    In this case, there can be two possible outcomes. If the application is available
    just on that server group, you will successfully complete the undeployment as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if your application is available on other server groups,
    the following error will be returned by the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It seems that something went wrong. As a matter of fact, when you are removing
    an application from a server group, the domain controller will verify that any
    other server group will not refer to the application; otherwise, the previous
    command will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, instruct the domain controller to undeploy the application
    without deleting the content as well. This is shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Creating CLI scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a program developer, you might be interested to know that a CLI can execute
    commands in a non-interactive way by adding them to a file, just as a shell script.
    In order to execute the script, you can launch the CLI with the `--file` parameter
    as in the following example (for Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent command for Unix users will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at some useful scripts that can be added to
    your administrator toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application to several WildFly nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The earlier JBoss AS releases used to ship with a `farm` folder, which would
    trigger a deployment to all the nodes that are part of a JBoss cluster. This option
    is not included anymore with JBoss AS7 and WildFly, but resurrecting a farm deployment
    is just a matter of following a few CLI instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are deploying an application to the default server
    address (`127.0.0.1` and port `9990`) and to another server instance that is bound
    to the same address but to port `10190`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Restarting servers in a domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common requirement for the domain administrator is to restart the application
    server nodes, for example, when some server libraries are updated. CLI provides
    a handy shortcut to stop and start all the servers that are part of a server group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer a more granular approach, you can start the single server nodes
    as shown in the following example, which shows how you can apply conditional execution
    logic in your CLI scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the `if end-if` part of the code, we are checking for the server's status
    attribute. If the status is **STARTED**, the application servers are stopped and
    then restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a data source as a module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In WildFly, you can use the `module` command in order to install a new module.
    We already did something similar in [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining
    Persistence with CDI"), *Combining Persistence with CDI*. Now, you can fully automate
    a data source creation as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the script, after the connection, installs a new module named
    `org.postgresql` in your server modules' directory, including the PostgreSQL JDBC
    driver and the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The second line installs the JDBC driver for the `org.postgresql` module into
    the `datasources/jdbc-driver` subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a data source is added to `jndi java:jboss/datasources/PostgreSQLDS`
    with the required URL and credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JMS resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding a new JMS destination is quite easy since it does not require a lengthy
    set of commands. However, it is sometimes your application that needs to set up
    lots of JMS destinations in order to work, so why not create a script for it too?
    The following is a tiny script that adds a JMS queue to the server configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the corresponding script you can use to create a JMS topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using advanced languages to create powerful CLI scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to write CLI shell commands to manage the application
    server's resources. This approach has the advantage that you can easily access
    every server resource easily and quickly, thanks to the built-in autocompletion
    feature. If, on the other hand, you want to perform some sophisticated logic around
    your commands, then you need to find some other alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a shell guru, you might easily resort to some bash scripting in order
    to capture the output of the CLI and use the rich set of Unix/Linux tools to perform
    some administrative actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplying a short overview of the bash functionalities might be an amusing
    exercise; however, if we do this, we would move away from the scope of this book.
    We will instead document some built-in functionalities such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, we will show how to use a CLI remote client API from within
    a Python script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will use the raw management API to execute CLI commands
    from within Java applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple use cases in which the JBoss CLI scripts could be useful.
    A script could be used to configure a developer's machine, a test environment,
    or as an initial configuration for production. In many cases, the configuration
    needed to start a full-blown enterprise application may be nontrivial; you might
    need to use a specific port configuration to cluster tests or your own security
    domain. You might also need your continuous integration server to do this for
    you. Besides this, it's better to have an automatic configuration script than
    set up the configuration manually every time, which is just a waste of time and
    a potential source of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Using scripting languages to wrap CLI execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JBoss AS 7 has introduced a new CLI remote API that acts as a facade for the
    CLI public API. The core class that acts as a bridge between these two APIs is
    the `scriptsupport.CLI` class that is contained in the `JBOSS_HOME/bin/client/jboss-cli-client.jar`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this API, you can execute CLI commands using lots of different languages
    such as Jython, Groovy, or JavaScript. Since Jython is also the de facto management
    standard for other application servers, such as Oracle, WebLogic, and WebSphere,
    we will use it to perform some basic management tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jython is an implementation of Python for JVM. Jython is extremely useful because
    it provides the productivity features of a mature scripting language while running
    on a JVM. Unlike a Python program, a Jython program can run in any environment
    that supports a JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Jython is invoked using the `jython` script, which is a short script that invokes
    your local JVM, running the Java class file, `org.python.util.jython`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to do in order to get started is download the Jython
    installer from [http://www.jython.org/downloads.html](http://www.jython.org/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the installer with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `JYTHON_HOME/bin` folder (for example, `C:\jython2.5.3\bin`)
    to the system path and add the `jboss-cli-client.jar` file to the system, `CLASSPATH`.
    For example, in Windows, use the given command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the same command for Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Ok, now we will create our first script that will basically return the JNDI
    view of our application server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that Jython, just like Python, uses indentation to determine the code
    structure instead of using braces or keywords. Therefore, do not use them randomly.
    An IDE might help you with this—for Python you can use, for example, Vim with
    python-mode ([https://github.com/klen/python-mode](https://github.com/klen/python-mode))
    or Eclipse with the PyDev extension ([http://pydev.org/](http://pydev.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `script.py` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now execute the script with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is very self-explanatory; we are importing the `org.jboss.as.cli.scriptsupport.CLI`
    class, which is used to send commands and read the response. Then, we are connecting
    to the local WildFly instance and issuing a `:jndi-view` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `connect` command can be used to connect to a remote WildFly host as well
    by adding the following parameters: `connect (String controllerHost, int controllerPort,
    String username, String password)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The response variable is `org.jboss.dmr.ModelNode`. This can be further inspected
    as shown in the following example, which goes in to some depth about platform
    MBeans, to get some memory statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we tracked the resources contained in `/core-service=platform-mbean/type=memory`.
    The available resources are, however, child resources of the two kinds of available
    heap memory areas (`heap-memory-usage` and `non-heap-memory-usage`), as shown
    by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using just the `get` command of the `ModelNode` object, you can refer to the
    child resources of the memory type and reach all the single attributes. Once you
    have got the attributes, it's easy to cast them to an integer using the `asInt()`
    function of the `ModelNode` object and use the cool Python constructs to alert
    your administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Using the raw management API to manage the application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't feel like learning a scripting language to manage the application
    server, you can still use the raw management API from within your Java classes.
    Don't be influenced by the fact that we left this option as the last one; in fact,
    using the native management API is not difficult at all since it is based on very
    few classes and has little compile-time and runtime dependencies on the WildFly
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, you can use the management API as well from any Java EE application
    by simply adding the following dependencies to the `META-INF/MANIFEST.MF` file
    of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The core API named **detyped management API** is quite simple; the primary class
    is `org.jboss.dmr.ModelNode`, which we already mentioned in the Jython section.
    A `ModelNode` class is essentially just a wrapper around a value; the value is
    typically a basic JDK type that can be retrieved using the `getType()` method
    of `ModelNode`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `jboss-dmr` API, the other module that is used to connect
    to the management API is `jboss-as-controller-client`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't need to download any of these libraries since both of these modules
    are included in the application server since release 7.
  prefs: []
  type: TYPE_NORMAL
- en: Reading management model descriptions via the raw management API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the **detyped management API** is not too different from its scripting
    language counterpart; at first, you need to create a management client that can
    connect to your target process''s native management socket (which can be an individual
    standalone mode server, or in a domain mode environment, the domain controller):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to create an operation request object using the `org.jboss.dmr.ModelNode`
    class, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `ModelNode` objects can be chained in order to reach an operation
    (in the example, the JNDI view), which is available on a node path (in our case,
    the naming subsystem).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have added the `ModelNode` attributes, you can issue the `execute`
    commands on your node, which will in turn return `ModelNode` where the result
    of the operation will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: In the samples, you can find a fully working project containing these management
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your resource watches using the detyped API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have learned the basics of the **detyped** **management API**,
    we will illustrate a concrete example; our goal will be to monitor a server resource
    (the number of active JDBC connections for a data source) using an EJB. You can
    use this pattern to create your own server watches that can be integrated with
    your application environment. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We will not rehash the basic concepts about EJB Timers, which have been discussed
    in [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing Java EE 7
    – EJBs"), *Introducing Java EE 7 – EJBs*. We suggest that you have a look at the
    highlighted section of the code, which shows how you can chain your `ModelNode`
    objects in order to reach the attribute that we are going to monitor (the `activeCount`
    attribute of the `ExampleDS` datasource).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the value of the `activeCount` attribute, we leave it to your
    imagination to envision all the possible actions you can undertake!
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that there are additional means of monitoring WildFly. One
    of them is using the `hawt.io` plugin for JBoss ([http://hawt.io/plugins/jboss/](http://hawt.io/plugins/jboss/)).
    We already tried this for ActiveMQ when we were developing MessageBeans. Another
    tool is Jolokia ([http://www.jolokia.org/](http://www.jolokia.org/)), which exposes
    JMX beans over HTTP. So, if you are not into writing your own monitors, there
    are other options worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JBoss 7, a logged-in administrator has unlimited power over every configuration
    aspect of a running server. This could be a problem in a production environment
    when multiple users have access to the server to do different tasks. One user
    could only be interested in deploying new applications, another should only be
    able to restart the server, and there could be one who should not be able to change
    anything (for example, a monitoring agent sending data about the execution of
    an application).
  prefs: []
  type: TYPE_NORMAL
- en: 'To support these kinds of requirements, WildFly brings two access control strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple, which is the all-or-nothing approach known from JBoss AS 7 and EAP in
    versions earlier than 6.2 (every authenticated administrator has full access to
    the application server). This is the default strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role based access control (RBAC), which allows you to assign administrative
    users to specific management roles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s navigate to `http://localhost:8080/console` and log in with our administrator
    password. The upper menu contains a tab named **Administration**. This is used
    to configure the access control mechanism. Once you click on it (you should see
    a message box informing you that RBAC is not yet enabled), we will see three subtabs:
    **Users**, **Groups**, and **Roles**. Let''s take a closer look at each of these
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Users are defined using the `add-user.bat` (`.sh`) scripts in the `JBOSS_HOME/bin`
    directory. We have already defined one before the first time we accessed the JBoss
    console. The created user, however, requires some additional information in order
    to determine his or her security level. The easiest way to achieve this is to
    organize them into groups. The assignment can be done via the user creation scripts
    or by the `mgmt-groups.properties` files in the WildFly's configuration directory.
    Another way to do this is to define a security realm connected to an external
    source (an LDAP server for instance). We will talk more about security realms
    in the next chapter. For now, you can create a user assigned to a group named
    `TestGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: A group is mapped to a set of security roles to provide specific permissions.
    For example, we can create user groups for developers and junior administrators
    and map them to a subset of desired roles. A user can be part of multiple groups,
    so there is also a possibility to exclude a role for a specific group so that
    no other group could grant it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have roles that cover multiple areas of the server''s functionality.
    Every role has a set of permissions assigned and some of them are additionally
    constrained (for instance, to allow you to configure modifications in only specific
    subsystems such as data sources). A list of built-in roles is available in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Role | Permissions | Sensitive data (passwords and auditing) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Monitor` | Read-only access to configuration and runtime state. | No access.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Operator` | All permissions of **Monitor**. This role can restart the server,
    control JMS destination, and database connection pools. It cannot modify the configuration.
    | No access. |'
  prefs: []
  type: TYPE_TB
- en: '| `Maintainer` | All permissions of **Operator**. This role can modify the
    configuration (including deploying new applications). | No access. |'
  prefs: []
  type: TYPE_TB
- en: '| `Deployer` | All permissions of **Maintainer**, but with restrictions on
    deploying new applications (cannot change the configuration of the server). |
    No access. |'
  prefs: []
  type: TYPE_TB
- en: '| `Administrator` | All permissions of **Maintainer**. | Read/write access.
    No access to the audit system. |'
  prefs: []
  type: TYPE_TB
- en: '| `Auditor` | All permissions of **Monitor**. | Read-only access. Full access
    to the auditing system. |'
  prefs: []
  type: TYPE_TB
- en: '| `Super User` | Everything is permitted. The administrator known from JBoss
    AS 7 and the simple strategy in WildFly. Also, this is the default role for a
    local user (connecting from a localhost). | Full access. |'
  prefs: []
  type: TYPE_TB
- en: Besides relying on the group-role mapping mechanism, you have another option
    to assign users to roles. You can use the **Administration/Users** screen in the
    admin console to directly assign a user to a role (be sure to select **Include**
    as the type). Assign the `SuperUser` role now to your current user using the **Add**
    button. Additionally, you can use **Administration/Groups** to add our newly created
    `TestGroup` to, for instance, the `Monitor` role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our configuration is now in place; try and check it out. To switch to the RBAC
    strategy, we will need to issue the following command using the CLI interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Reload the server and log in to the web console again using the account you
    designed as `SuperUser`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are testing the web console, but the RBAC mechanism also works for the CLI.
    Note that the CLI will allow you to access it from `localhost` as long as you
    have the `$local` user allowed in your security realm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you wish to disable it, simply remove this line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are wondering what your current role is, you can click on **Username**
    in the upper-right corner of the screen. You should see a bit of information about
    the currently logged-in administrator in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Role-based security](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see that the user root is logged in as a
    `SuperUser` role. Besides having the possibility to do everything with the application
    server, the `SuperUser` role has one additional feature. It can impersonate other
    roles using **Run as…**, which can be useful if you want to check what are the
    limitations of another role. Feel free to check them out right now. For instance,
    as a `Monitor`, you should not be able to alter any settings in the admin console.
  prefs: []
  type: TYPE_NORMAL
- en: You can also relogin with the user you've created earlier, which is assigned
    to `TestGroup`. It should have the **Monitor** role shown in the upper-right corner
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing administrative operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WildFly introduces an audit-log feature that allows the administrators to track
    the configuration changes made on the server. The feature is initially disabled
    but can be useful in some scenarios, so let's take a short look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The audit-log configuration consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Formatter**: This formats the log output. By default, it''s based on JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler**: This handles the output. By default, it is a file-based handler,
    but it is possible to use a TCP or UDP to send the logs to a remote server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logger**: This controls the login process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed configuration can be found in the official WildFly documentation at
    [https://docs.jboss.org/author/display/WFLY8/Audit+logging](https://docs.jboss.org/author/display/WFLY8/Audit+logging).
  prefs: []
  type: TYPE_NORMAL
- en: 'The audit log is disabled by default. To enable it, we must issue the following
    CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now you can try to do any administrative action using the web console (for instance,
    disabling a data source). After this, you should find a trace of it in `JBOSS_HOME/standalone/data/audit-log.log`
    (along with information about switching the audit logging on).
  prefs: []
  type: TYPE_NORMAL
- en: Patching a running instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The newest version of the JBoss Application Server comes with a patching utility
    that allows you to automatically update parts of the server with newer versions.
    Currently, the patching is done using a CLI. Any patch can be reverted, and the
    administrator is able to track the history of patches.
  prefs: []
  type: TYPE_NORMAL
- en: A patch can be applied by simply calling the `patch apply <file path> (without
    -)` command. A complementary command is `patch rollback --patch-id = id`, a patch-rollback
    command. To obtain information about the installed patches, simply call `patch
    info`. Patches are distributed by teams responsible for specific WildFly subsystems.
    Visit their websites if you need a patch for a specific module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the application server's management API from a developer's
    perspective, which will enable you to write your own scripts to monitor the health
    of your application server.
  prefs: []
  type: TYPE_NORMAL
- en: The most effective tool for monitoring the application server is the command-line
    interface. However, if you want to spice it up with some typical programming logic,
    you can resort to some other alternatives such as scripting languages or the raw
    management API.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored some of the new, advanced features that were introduced with
    WildFly. You now know how to restrict access to your management console and how
    to audit the changes done to the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our review of management. In the next chapter, we are
    going to discuss clustering, which is the environment where critical applications
    are deployed.
  prefs: []
  type: TYPE_NORMAL
