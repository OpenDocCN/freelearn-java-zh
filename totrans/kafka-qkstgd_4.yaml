- en: Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern (internet) computing, we often forget that entities must be transmitted
    from one computer to another. In order to be able to transmit the entities, they
    must first be serialized.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization is the process of transforming an object into a stream of bytes
    commonly used to transmit it from one computer to another.
  prefs: []
  type: TYPE_NORMAL
- en: Deserialization, as the name implies, is the opposite of serialization, that
    is, to convert a stream of bytes into an object (for didactic purposes, we can
    say that the object is inflated or rehydrated), normally from the side that receives
    the message. Kafka provides **Serializer**/**Deserializer** (**SerDe**) for the
    primitive data types (byte, integer, long, double, String, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, a new company is introduced: Kioto (standing for Kafka Internet
    of Things). This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build a Java `PlainProducer`, a consumer, and a processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run a Java `PlainProducer` and a processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a custom serializer and a custom deserializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a Java `CustomProducer`, a consumer, and a processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run a Java `CustomProducer` and a processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kioto, a Kafka IoT company
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kioto is a fictional company dedicated to energy production and distribution.
    To operate, Kioto has several **Internet of Things** (**IoT**) devices.
  prefs: []
  type: TYPE_NORMAL
- en: Kioto also wants to build an enterprise service bus with Apache Kafka. Its goal
    is to manage all of the messages received by all of the machines' IoT sensors
    every minute. Kioto has hundreds of machines in several locations, sending thousands
    of different messages per minute to the enterprise service bus.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, Kioto has a lot of IoT on its machines that continuously send
    status messages to a control center. These machines generate electricity, so it
    is very important for Kioto to know exactly the machines' uptime and their state
    (running, shutting down, shutdown, starting, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Kioto also needs to know the weather forecast, because some machines should
    not operate over certain temperatures. Some machines display different behavior
    based on the environmental temperature. It is different starting a machine in
    cold rather than in warm conditions, so the start up time is important when calculating
    the uptime. To warrant the continuous electricity supply, the information has
    to be precise. It is always better to face an electrical power failure having
    to start the machines from a warm temperature rather than from cold temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4.1* shows the health check event in JSON format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.1*,`healthcheck.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.1: healthcheck.json'
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposed representation of this message in JSON has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event`: The string with the message''s type (in this case, `HEALTH_CHECK`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factory`: The name of the city where the plant is physically located'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialNumber`: The machine''s serial number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: Represents the machine''s type, which could be `GEOTHERMAL`, `HYDROELECTRIC`,
    `NUCLEAR`, `WIND`, or `SOLAR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: The point on the life cycle: `RUNNING`, `SHUTTING-DOWN`, `SHUT-DOWN`,
    `STARTING`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastStartedAt`: The last start time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temperature`: A float representing the machine''s temperature in degrees celsius'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipAddress`: The machine''s IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, JSON is a human-readable message format.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create the Kioto project. Create a directory called `kioto`.
    Go to that directory and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Gradle creates a default project in the directory, including two Java files
    called `Library.java` and `LibraryTest.java`; delete both files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your directory should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`- build.gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-- wrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- gradle-wrapper.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- gradle-vreapper.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- gradlew`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- gradle.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- settings.gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- src`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-- main`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`----- Library.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-- test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`----- LibraryTest.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `build.gradle` file and replace it with *Listing 4.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.2*, the Kioto Gradle build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Some library dependencies added to the application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kafka_2.12`, the necessary dependencies for Apache Kafka'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafaker`, the necessary dependencies for JavaFaker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jackson-core`, for JSON parsing and manipulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kafka-avro-serializer`, to serialize in Kafka with Apache Avro'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that to use the `kafka-avro-serializer` function, we added the Confluent
    repository in the repositories section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the project and download the required dependencies, type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The project can also be created with Maven, SBT, or even from the IDE. But
    for simplicity, it was created with Gradle. For more information about these projects,
    visit the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle''s main page: [http://www.gradle.org](http://www.gradle.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maven''s main page: [http://maven.apache.org](http://maven.apache.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SBT''s main page: [http://www.scala-sbt.org/](http://www.scala-sbt.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jackson''s main page: [https://github.com/FasterXML](https://github.com/FasterXML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaFaker''s main page: [https://github.com/DiUS/java-faker](https://github.com/DiUS/java-faker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to code our `Constants` class. This class is a static class
    with all of the `Constants` needed in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Open the project with your favorite IDE and, under the `src/main/java/kioto`
    directory, create a file called `Constants.java` with the content of *Listing
    4.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.3*, `Constants.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Constants` class, there are some methods that we will need later. These
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getHealthChecksTopic`: It returns the name of the health checks input topic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getHealthChecksAvroTopic`: It returns the name of the topic with the health
    checks in Avro'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUptimesTopic`: It returns the name of the `uptimes` topic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`machineType`: This is an `enum` with the types of the Kioto energy producing
    machines types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`machineType`: This is an `enum` with the types of the Kioto machines'' possible
    statuses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getJsonMapper`: It returns the object mapper for JSON serialization and we
    set the serialization format for dates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a `Constants` class; in languages such as Kotlin, the constants don't
    require an independent class, but we are using Java. Some purists of object-oriented
    programming argue that to code constant classes is an object-oriented anti-pattern.
    However, for simplicity here, we need some constants in our system.
  prefs: []
  type: TYPE_NORMAL
- en: HealthCheck message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second step is to code the `HealthCheck` class. This class is a **Plain
    Old Java Object** (**POJO**). The `model` class is the template for the value
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Open the project with your favorite IDE and, in the `src/main/java/kioto` directory,
    create a file called `HealthCheck.java` with the content of *Listing 4.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.4*,`HealthCheck.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Listing 4.4:HealthCheck.java
  prefs: []
  type: TYPE_NORMAL
- en: 'With your IDE, generate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A no-parameter constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor with all of the attributes passed as parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getters and the setters for each attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a data class, a POJO in Java. In languages such as Kotlin, the model
    classes require so much less boilerplate code, but now we are in Java. Some purists
    of object-oriented programming argue that value objects is an object-oriented
    anti-pattern. However, the serialization libraries to produce messages need these
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: To generate fake data with JavaFaker, our code should be as shown in *Listing
    4.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.5*, a health check mock generator
    with JavaFaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an analysis of how to generate fake health check data:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, `address().city()` generates a fictitious city name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, in the expression `?` for alpha `#` for numeric, `true` if alpha
    is uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, we use the machine type `enum` in `Constants` , and a fake number
    between `0` and `` `4` ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, we use the machine status `enum` in `Constants` and a fake number
    between `0` and `3`, inclusively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, we are saying that we want a fake date between the past `100`
    days from today
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//6`, we build a fake IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we depend on the attributes order of the constructor. Other languages,
    such as Kotlin, allow specifying each assigned attribute name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to transform our Java POJO into a JSON string, we use the method in the
    `Constants` class—something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that this method throws a JSON processing exception.
  prefs: []
  type: TYPE_NORMAL
- en: Java PlainProducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, to build a Kafka Message producer that we use the Java client
    library, in particular the producer API (in the following chapters, we will see
    how to use Kafka Streams and KSQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is a data source; to make it simple we need to produce
    our mock data. Each message will be a health message with all of its attributes.
    The first step is to build a producer to send these messages in JSON format to
    a topic, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's start by creating a Kafka producer that we will use to send the input
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already know, there are two requisites that all of the Kafka producers
    should have: they must be `KafkaProducer` and have specific properties set, as
    shown in *Listing 4.6*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.6,* the constructor method for `PlainProducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the `PlainProducer` constructor includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, the list of the brokers where our producer will be running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, the serializer type for the messages' keys (we will see serializers
    later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, the serializer type for the messages' values (in this case, the
    values are strings)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, with these properties we build a `KafkaProducer` with string
    keys and string values, for example, `<String, String>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that properties behave like a HashMap; in languages such as Kotlin, the
    properties assignment could be made using the `=` operator, rather than by calling
    a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are using a string serializer for both keys and values: in this first approach,
    we will serialize the values to JSON manually using Jackson. We will see later
    how to write a custom serializer.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the `src/main/java/kioto/plain` directory, create a file called `PlainProducer.java`
    with the content of *Listing 4.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.7*,`PlainProducer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the `PlainProducer` class includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, `ratePerSecond` is the number of messages to send in a one second
    period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, to simulate repetition, we use an infinite loop (try to avoid
    this in production)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, the code to serialize as JSON a Java POJO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, we use a Java Future to send the message to `HealthChecksTopic`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, we wait this time to send messages again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//6`, we read the result of the future created previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//7`, everything runs on the broker in localhost in port `9092`, sending
    two messages at intervals of one second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important to note that here we are sending records without a key; we
    only specified the value (a JSON string), so the key is `null`. We are also calling
    the `get()` method on the result in order to wait for the write acknowledgment:
    without that, messages could be sent to Kafka but are lost without our program
    noticing the failure.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the PlainProducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the project, run this command from the `kioto` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is okay, the output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'From a command-line terminal, move to the `confluent` directory and start it
    by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The broker is running on port `9092`. To create the `healthchecks` topic, execute
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a console consumer for the `healthchecks` topic by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From our IDE, run the main method of the `PlainProducer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output on the console consumer should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Remember that, when producing data, there are several write guarantees that
    we could achieve.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in case of a network failure or a broker failure, is our system
    ready to lose data?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a trade-off among three factors: the availability to produce messages,
    the latency in the production, and the guarantee of the safe write.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we just have one broker, and we use the default value for `acks`
    of 1\. When we call the `get()` method in the future, we are waiting for the broker
    acknowledgment, that is, we have a guarantee that the message is persisted before
    sending another message. In this configuration, we don't lose messages, but our
    latency is higher than in a fire and forget schema.
  prefs: []
  type: TYPE_NORMAL
- en: Java plain consumer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, to build a Kafka message consumer, we use the Java client
    library—in particular, the consumer API (in the following chapters, we will see
    how to use Kafka Streams and KSQL).
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a Kafka consumer that we will use to receive the input messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already know, there are two requisites that all of the Kafka consumers
    should have: to be a `KafkaConsumer` and to set the specific properties, such
    as those shown in *Listing 4.8*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.8*, the constructor method for plain
    consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the plain consumer constructor includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, the group ID of our consumer, in this case, `healthcheck-processor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, the list of `brokers` where our consumer will be running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, the deserializer type for the messages' keys (we will see deserializers
    later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, the deserializer type for the messages' values, in this case,
    values are strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, with these properties, we build a `KafkaConsumer` with string
    keys and string values, for example, `<String, String>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the customers, we need to provide a group ID to specify the consumer group
    that our consumer will join.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that multiple consumers are started in parallel, through different
    threads or through different processes, each consumer will be assigned with a
    subset of the topic partitions. In our example, we created our topic with four
    partitions, which means that, to consume the data in parallel, we could create
    up to four consumers.
  prefs: []
  type: TYPE_NORMAL
- en: For a consumer, we provide deserializers rather than serializers. Although we
    don't use the key deserializer (because if you remember, it is `null`), the key
    deserializer is a mandatory parameter for the consumer specification. On the other
    hand, we need the deserializer for the value, because we are reading our data
    in a JSON string, whereas here we deserialize the object manually with Jackson.
  prefs: []
  type: TYPE_NORMAL
- en: Java PlainProcessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, in the `src/main/java/kioto/plain` directory, create a file called `PlainProcessor.java`
    with the content of *Listing 4.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.9*, `PlainProcessor.java` (part
    1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the first part of the `PlainProcessor` class includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we declare a consumer, as in *Listing 4.8*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second part, we declare a producer, as in *Listing 4.6*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before continuing to write code, let's remember the project requirements for
    the Kioto stream processing engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, the specification is to create a stream engine that
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generates messages to a Kafka topic called **healthchecks**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads messages from the Kafka topic called **healthchecks**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculates the uptime based on the start up time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writes the messages in a Kafka topic called **uptimes**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This entire process is detailed in *Figure 4.1*, that is, the Kioto stream
    processing application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e950097d-1b87-4c2d-b542-1ae7a2c74fef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The messages are generated into HealthChecksTopic, then read, and
    finally the calculated uptimes are written it in the uptimes topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're in the `src/main/java/kioto/plain` directory, let's complete
    the `PlainProcessor.java` file with the content of *Listing 4.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.10*, `PlainProcessor.java` (part
    2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.10: PlainProcessor.java (part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'An analysis of the `PlainProcessor` includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, the consumer is created and subscribed to the source topic. This
    is a dynamic assignment of the partitions to our customer and join to the customer
    group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, an infinite loop to consume the records, the pool duration is
    passed as a parameter to the method pool. The customer waits no longer than one
    second before return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, we iterate over the records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, the JSON string is deserialized to extract the health check object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, the start time is transformed formatted at the current time zone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//6`, the uptime is calculated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//7`, the uptime is written to the `uptimes` topic, using the serial
    number as the key and the uptime as value. Both values are written as normal strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moment at which the broker returns records to the client also depends on
    the `fetch.min.bytes` value; its default is 1, and is the minimum data amount
    to wait before the broker is available to the client. Our broker returns as soon
    as 1 byte of data is available, while waiting a maximum of one second.
  prefs: []
  type: TYPE_NORMAL
- en: The other configuration property is `fetch.max.bytes`, which defines the amount
    of data returned at once. With our configuration, the broker will return all of
    the available records (without exceeding the maximum of 50 MB).
  prefs: []
  type: TYPE_NORMAL
- en: If there are no records available, the broker returns an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could reuse the producer that generates the mock data, but it is
    clearer to use another producer to write `uptimes`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the PlainProcessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the project, run the following command from the `kioto` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is correct, the output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our broker is running on port `9092`, so to create the `uptimes` topic, execute
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a console consumer for the `uptimes` topic, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From our IDE, run the main method of `PlainProcessor`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From our IDE, run the main method of `PlainProducer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output on the console consumer for the `uptimes` topic should be similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have said that, when producing data, there are two factors to think about;
    one is the delivery guarantee, and the other is the partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'When consuming data, we have to think about the following four factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of consumers to run in parallel (in parallel threads and/or parallel
    processes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of data to consume at once (think in terms of memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time to wait to receive messages (throughput and latency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to mark a message as processed (committing offset)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `enable.auto.commit` is set to `true` (the default is `true`), the consumer
    automatically will commit the offsets in the next call to the poll method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the whole batch of records is committed; if something fails and the
    application crashes after processing only some messages, but not all of the batch,
    the events are not committed and they will be reprocessed by other consumer; this
    way to process data is called at least once processing.
  prefs: []
  type: TYPE_NORMAL
- en: Custom serializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to produce and consume JSON messages using plain Java
    and Jackson. We will see here how to create our custom serializers and deserializers.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to use `StringSerializer` in the producer and `StringDeserializer`
    in the consumer. Now, we will see how to build our own SerDe to abstract the serialization/deserialization
    processes away from the core code of the application.
  prefs: []
  type: TYPE_NORMAL
- en: To build a custom serializer, we need to create a class that implements the
    `org.apache.kafka.common.serialization.Serializer` interface. This is a generic
    type, so we can indicate the custom type to be converted into an array of bytes
    (serialization).
  prefs: []
  type: TYPE_NORMAL
- en: In the `src/main/java/kioto/serde` directory, create a file called `HealthCheckSerializer.java`
    with the content of *Listing 4.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.11*, `HealthCheckSerializer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.11: HealthCheckSerializer.java'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the serializer class is located in a special module called **kafka-clients**
    in the `org.apache.kafka` route. The objective here is to use the serializer class
    instead of Jackson (manually).
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the important method to implement is the `serialize` method.
    The `close` and `configure` methods can be left with an empty body.
  prefs: []
  type: TYPE_NORMAL
- en: We import the `JsonProcessingException` of Jackson just because the `writeValueAsBytes`
    method throws this exception, but we don't use Jackson for serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Java CustomProducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to incorporate the serializer in our producer, there are two requisites
    that all Kafka producers should fulfill: to be a `KafkaProducer`, and to set the
    specific properties, such as *Listing 4.12*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.12*,the constructor method for `CustomProducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the `CustomProducer` constructor includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, this is the list of the brokers where our producer will be running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, the serializer type for the messages' keys in this case keys
    remains as strings. In line `//3`, this is the serializer type for the messages'
    values, in this case, the values are `HealthCheck`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, with these properties we build a `KafkaProducer` with string
    keys and `HealthCheck` values, for example, `<String, HealthCheck>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, in the `src/main/java/kioto/custom` directory, create a file called `CustomProducer.java`
    with the content of *Listing 4.13*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.13*, `CustomProducer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.13: CustomProducer.java'
  prefs: []
  type: TYPE_NORMAL
- en: 'An analysis of the `CustomProducer` class includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, `ratePerSecond` is the number of messages to send in a one-second
    period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, to simulate repetition, we use a infinite loop (try to avoid
    this in production)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, we use a Java future to send the message to `HealthChecksTopic`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, we wait this time to send messages again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, we read the result of the future created previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//6`, everything runs on the broker in localhost in port `9092`, sending
    two messages in an interval of one second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the CustomProducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the project, run the following command from the `kioto` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is okay, the output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a console consumer for `HealthChecksTopic` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From our IDE, run the main method of the `CustomProducer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output on the console consumer should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Custom deserializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a similar way, to build a custom deserializer, we need to create a class
    that implements the `org.apache.kafka.common.serialization.Deserializer` interface.
    We must indicate how to convert an array of bytes into a custom type (deserialization).
  prefs: []
  type: TYPE_NORMAL
- en: In the `src/main/java/kioto/serde` directory, create a file called `HealthCheckDeserializer.java`
    with the content of *Listing 4.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.14*, `HealthCheckDeserializer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.14: HealthCheckDeserializer.java'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the deserializer class is located in a module called kafka-clients
    in the `org.apache.kafka` route. The objective here is to use the deserializer
    class instead of Jackson (manually).
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the important method to implement is the `deserialize` method.
    The `close` and `configure` methods can be left with an empty body.
  prefs: []
  type: TYPE_NORMAL
- en: We import the `HealthCheck` class because the `readValue` method requires a
    POJO (a class with public constructor and public getters and setters). Note also
    that all of the POJO attributes should be serializables.
  prefs: []
  type: TYPE_NORMAL
- en: Java custom consumer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a Kafka consumer that we will use to receive the custom input messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to incorporate the deserializer in our consumer, there are two
    requisites that all of the Kafka consumers should have: to be a `KafkaConsumer`,
    and to set the specific properties, such as those in *Listing 4.15*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.15*, the constructor method for
    `CustomConsumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the `CustomConsumer` constructor includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, the group ID of our consumer, in this case, `healthcheck- processor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, the list of the brokers where our consumer will be running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, the deserializer type for the messages' keys; in this case, the
    keys remains as strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, the deserializer type for the messages' values; in this case,
    the values are `HealthChecks`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, with these properties, we build a `KafkaConsumer` with string
    keys and `HealthChecks` values, for example, `<String, HealthCheck>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a consumer, we provide deserializers rather than serializers. Although we
    don't use the key deserializer (because if you remember, it is `null`), the key
    deserializer is a mandatory parameter for the consumer specification. On the other
    hand, we need the deserializer for the value, because we are reading our data
    in a JSON string; here, we deserialize the object with the custom deserializer.
  prefs: []
  type: TYPE_NORMAL
- en: Java custom processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, in the `src/main/java/kioto/custom` directory, create a file called `CustomProcessor.java`
    with the content of *Listing 4.16*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.16*, `CustomProcessor.java` (part
    1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the first part of the custom processor class includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we declare a consumer, as in *Listing 4.15*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second part, we declare a producer, as in *Listing 4.13*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, in the `src/main/java/kioto/custom` directory, let's complete the `CustomProcessor.java`
    file with the content of *Listing 4.17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 4.17*, `CustomProcessor.java` (part
    2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An analysis of the `CustomProcessor` process method includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, here the consumer is created and subscribed to the source topic.
    This is a dynamic assignment of the partitions to our customer and join to the
    customer group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, an infinite loop to consume the records, the pool duration is
    passed as a parameter to the method pool. The customer waits no longer than one
    second before return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, we iterate over the records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, the JSON string is deserialized to extract the `HealthCheck`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, the start time is transformed in format at the current time zone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//6`, the uptime is calculated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//7`, the uptime is written to the `uptimes` topic, using the serial
    number as the key and the uptime as the value. Both values are written as normal
    strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the custom processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build the project, run the following command from the `kioto` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is correct, the output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a console consumer for the `uptimes` topic as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: From our IDE, run the main method of `CustomProcessor`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From our IDE, run the main method of `CustomProducer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output on the console consumer for the `uptimes` topic should be similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have seen how to create our own SerDe to abstract the serialization
    code from our application's main logic. Now you know how a Kafka SerDe works.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build a Java PlainProducer, a consumer, and
    a processor, and we have shown how to build a custom serializer and a custom deserializer.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we learned how to build a Java CustomProducer, a consumer, and a processor,
    and how to run the Java CustomProducer and the processor.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to serialize/deserialize with Kafka using
    JSON, plain, and binary formats. Avro is a common serialization type for Kafka.
    We will see how to use Avro in [Chapter 5](f7fa5729-8bf7-41c8-aba6-aa5f8663394f.xhtml),
    *S**chema Registry*, along with the use of the Kafka schema registry.
  prefs: []
  type: TYPE_NORMAL
