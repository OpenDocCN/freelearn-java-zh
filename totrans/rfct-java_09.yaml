- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Beyond Code – Mastering Software Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越代码 - 掌握软件架构
- en: At this point, everything should be crystal clear about why and how to constantly
    refactor your code; in general, why it’s important to have a clean, readable,
    and easily maintainable code base. But in today’s development world, it’s highly
    unlikely that we’ll have just one application, one component; it’s much more realistic
    to have various components interacting with each other. If it’s true, as it is,
    that according to Conway’s Law, a company is structured and organized in a way
    that mirrors its software systems, it’s crucial to have a cohesive yet scalable
    ecosystem – not just robust but resilient and, frequently mentioned, clean. Because
    even clean code can lead to epic disasters if interactions between various services
    are poorly managed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于为什么和如何不断重构代码的问题应该已经非常清晰了；一般来说，为什么拥有一个干净、可读和易于维护的代码库很重要。但在今天的开发世界中，我们很可能只有一个应用程序、一个组件；更现实的情况是，有各种组件相互交互。如果康威定律确实如此，即一个公司的结构和组织方式反映了其软件系统，那么拥有一个统一且可扩展的生态系统至关重要——不仅强大，而且具有弹性，经常提到的，还要干净。因为即使干净的代码，如果各种服务之间的交互管理不当，也可能导致灾难性的后果。
- en: 'In this chapter, we’ll tackle the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: What is an architecture?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是架构？
- en: Architectural patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构模式
- en: Monolith to microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体到微服务
- en: Bad smells in the microservices architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构中的坏味道
- en: What is an architecture?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是架构？
- en: 'Having come this far, we’ve realized that writing code is just a small part
    of our job. We need to focus on writing code that not only works but is also easy
    to read and maintain. We’ve learned that there are many small adjustments we can
    make to make our work simpler and smoother. Now, let’s take a step back and think
    further: Is our job really only about code? Is writing good code (whatever that
    means) the only thing, even though it’s broad and complex, that we need to do
    well? If we’re asking this question, you can guess that the answer is: not at
    all! Just like in the movie *Ratatouille* where Chef Gusteau says, “*Anyone can
    cook*,” here, we can paraphrase his words and say that *anyone can code*. It takes
    a little, in fact, to learn to write some lines of Java code or maybe even in
    some other simpler language. In recent months, technologies related to **artificial
    intelligence** (**AI**) have exploded, which can literally write code for us.
    But what is really challenging is not just writing code or even pieces of software
    that work together but doing it well. As Robert C. Martin says, “*Getting software
    right* *is hard.*”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这一段旅程，我们已经意识到编写代码只是我们工作的一小部分。我们需要专注于编写不仅能够工作而且易于阅读和维护的代码。我们已经了解到，我们可以进行许多小的调整来使我们的工作更简单、更流畅。现在，让我们退一步，进一步思考：我们的工作真的只是关于代码吗？编写好的代码（无论这意味着什么）是不是我们唯一需要做好的事情，尽管它广泛而复杂？如果我们提出这个问题，你可以猜到答案：绝不是！就像电影《美食总动员》中厨师古斯塔夫说的，“*任何人都可以烹饪*”，在这里，我们可以改写他的话并说，*任何人都可以编写代码*。实际上，学习编写一些Java代码或者甚至在一些更简单的语言中编写代码只需要一点时间。在最近几个月里，与**人工智能**（**AI**）相关的技术爆炸式增长，这实际上可以为我们编写代码。但真正具有挑战性的不仅仅是编写代码或者甚至编写能够协同工作的软件组件，而是要做得好。正如罗伯特·C·马丁所说，“*编写正确的软件*
    *是困难的*。”
- en: Software architecture is like the blueprint for a software system. It’s the
    plan that outlines how different parts of the software work together. This involves
    making decisions about how to design things to meet specific goals. It includes
    elements such as the different pieces of software, how they connect to each other,
    and the rules for organizing them. So, software architecture is basically the
    high-level design that guides the creation of a software system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构就像软件系统的蓝图。它是概述软件不同部分如何协同工作的计划。这包括关于如何设计以满足特定目标的决策。它包括诸如不同的软件组件、它们如何相互连接以及组织它们的规则等元素。因此，软件架构基本上是指导软件系统创建的高级设计。
- en: 'The architecture of a software system is like the design or structure created
    by the people building it. It’s determined by how the system is divided into parts
    (components), how these parts are organized, and how they talk to each other.
    In simpler terms, it’s how the different pieces of the software are put together
    and work together. This is only one definition of architecture, shaped by the
    *Clean Architecture* book by Robert C. Martin. Reading Martin Fowler’s works,
    instead, gives us another (funnier) definition of what architecture is: the collective
    knowledge that experienced developers have about the design of a system and the
    set of decisions you hope to make correctly at the beginning of a project.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统的架构就像构建它的人所创造的设计或结构。它由系统如何划分为部分（组件）、这些部分如何组织以及它们如何相互通信来决定。用更简单的话说，这就是软件的不同部分是如何组合在一起并协同工作的。这是架构的一个定义，由罗伯特·C·马丁的《Clean
    Architecture》一书塑造。相反，阅读马丁·福勒的作品，我们得到了另一个（更有趣）的架构定义：经验丰富的开发者对系统设计和项目开始时希望正确做出的决策集体的知识。
- en: 'We hope it’s a bit clearer what we mean by software architecture, but maybe
    it will be even clearer when we’ve explained its goals. On goals, the ideas seem
    quite clear in literature: good architecture makes things work better. The reason
    for creating a good architecture is to make it easier to develop, deploy, operate,
    and maintain the software system it holds.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这能让我们对软件架构的含义更加清晰，但也许当我们解释了其目标时，它将变得更加清晰。在目标方面，文献中的观点似乎相当明确：良好的架构可以使事物运行得更好。创建良好架构的原因是为了使开发、部署、运行和维护所包含的软件系统变得更加容易。
- en: Development
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发
- en: As long as there’s a small, single team handling the entire project, people
    may think that architecture isn’t that important; in fact, it’s seen as almost
    an obstacle. This is why many projects, especially in the startup phase, often
    don’t have a proper architecture. However, as the project expands, rush to the
    rescue as soon as possible! In fact, it’s challenging to work with different teams
    on the same project, on the same module; it becomes necessary to divide the module
    itself into well-defined parts (“how” is a whole different story). Simply dividing
    the initial component into multiple components is not enough, though. It needs
    to be done carefully, understanding how these components will interact with each
    other. Otherwise, there’s a risk that from a single component, different ones
    may simply develop independently, each doing its own thing. And if everyone goes
    their own way, it’s difficult to work on new features or fix existing problems.
    If a software system is difficult to develop, it’s unlikely to have a long and
    healthy lifespan. Therefore, the system’s architecture should be designed to make
    development easy for the team or teams working on it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有一个小型的单一团队处理整个项目，人们可能会认为架构并不那么重要；实际上，它被视为几乎是一个障碍。这就是为什么许多项目，尤其是在初创阶段，通常没有适当的架构。然而，随着项目的扩展，应尽快采取行动！事实上，与同一项目、同一模块的不同团队合作是一项挑战；这就需要将模块本身划分为定义良好的部分（“如何”则是另一个完全不同的话题）。仅仅将初始组件划分为多个组件是不够的。这需要谨慎进行，理解这些组件将如何相互交互。否则，存在从单个组件中，不同的组件可能简单地独立发展，各自为政的风险。如果每个人都各走各的路，那么在开发新功能或修复现有问题时将变得困难。如果一个软件系统难以开发，那么它不太可能拥有漫长而健康的使用寿命。因此，系统的架构应该设计得使团队或正在工作的团队的开发变得容易。
- en: Deployment
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: '**Deployability** means how easily and reliably software can be set up and
    run in a reasonable amount of time (ideally, with a single click). If there’s
    a problem with the new setup, it should be possible to go back to the previous
    one without too much trouble. With the rise of virtualization and cloud systems,
    and as software systems get bigger, it’s the architect’s job to make sure setting
    up the software is done efficiently and predictably, reducing the overall risk
    for the system.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**可部署性**意味着软件在合理的时间内（理想情况下，只需单击一次）可以轻松且可靠地设置和运行。如果新设置存在问题，应该能够在不太麻烦的情况下回到先前的版本。随着虚拟化和云系统的发展，以及软件系统规模的扩大，确保软件设置高效且可预测，降低系统的整体风险，这是架构师的工作。'
- en: Unfortunately, many times, people don’t think about how to set up a system when
    they’re first building it. This can result in designs that make the system easy
    to create but really hard to get up and running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，很多时候，人们在最初构建系统时并没有考虑如何设置系统。这可能导致设计使得系统易于创建，但真正难以启动和运行。
- en: For example, when starting to build a system, developers might opt for an architecture
    that includes a certain number of services and components. It might seem like
    a good idea for various reasons, such as smoother development and each piece working
    independently. However, during deployment, the team realizes that some of these
    services are interconnected and rely on each other to function properly. Deployment
    then becomes challenging, as you may need to deploy not only one service but also
    interconnected ones. If architects had considered the system setup from the beginning,
    they might have chosen fewer services, a combination of services and in-house
    components, and a more integrated approach to managing connections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当开始构建系统时，开发者可能会选择包含一定数量服务和组件的架构。这可能有各种原因看起来是个好主意，比如更平滑的开发和每个组件独立工作。然而，在部署过程中，团队意识到其中一些服务是相互关联的，并且需要相互依赖才能正常工作。因此，部署变得具有挑战性，因为你可能需要部署的不仅仅是单个服务，还有相互关联的服务。如果架构师从一开始就考虑了系统设置，他们可能会选择更少的服务、服务和内部组件的组合，以及更集成的方式来管理连接。
- en: System operation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统操作
- en: '**System operation** involves the day-to-day management and execution of a
    computer system or software application. It includes tasks such as running the
    software, keeping an eye on its performance, applying updates and fixes, ensuring
    security, handling backups, assisting users, and addressing issues as they arise.
    Essentially, it’s the ongoing effort to keep the system running smoothly and meeting
    user needs.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统操作**涉及对计算机系统或软件应用的日常管理和执行。这包括运行软件、监控其性能、应用更新和修复、确保安全、处理备份、协助用户以及处理出现的问题。本质上，这是持续努力保持系统平稳运行并满足用户需求。'
- en: The influence of architecture on system operation is generally considered not
    as significant as its impact on development, deployment, and maintenance. Most
    operational challenges can be addressed by increasing the system’s hardware resources
    without causing major changes to the software architecture; this scenario is quite
    common. Inefficient software architectures can often be made to function effectively
    by merely adding more storage and servers. The affordability of hardware compared
    to the cost of human resources means that architectures causing obstacles in operation
    are not as expensive as those hindering development, deployment, and maintenance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 架构对系统操作的影响通常被认为不如其对开发、部署和维护的影响显著。大多数操作挑战可以通过增加系统的硬件资源来解决，而无需对软件架构进行重大更改；这种情况相当常见。与人力资源成本相比，硬件的性价比意味着在操作中造成障碍的架构成本并不像阻碍开发、部署和维护的架构那样昂贵。
- en: Just because the impact of bad architecture on operations is easily fixable
    doesn’t mean it’s not an important aspect. Even though the so-called “hardware”
    (which often translates to buying cloud computing services from companies such
    as **Amazon Web Services** (**AWS**), Google, or Microsoft) costs less than people
    and time, it doesn’t mean it’s inexpensive or an insignificant cost. An inefficient
    architecture that requires a disproportionate number of resources compared to
    the value it brings (whether economic or otherwise) should be a concern.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不良架构对操作的影响容易修复，但这并不意味着它不是一个重要的方面。尽管所谓的“硬件”（通常意味着从像**亚马逊网络服务**（**AWS**）、谷歌或微软这样的公司购买云计算服务）的成本低于人力和时间成本，但这并不意味着它便宜或不重要。与它带来的价值（无论是经济上的还是其他方面的）相比，需要不成比例数量的资源的低效架构应该引起关注。
- en: Maintenance
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护
- en: '**Software maintenance** refers to the ongoing process of managing and updating
    software to ensure it continues to meet the needs of users and remains effective
    over time. It involves making modifications, fixing bugs, improving performance,
    and adapting the software to changes in the environment or user requirements.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件维护**指的是持续管理和更新软件的过程，以确保其持续满足用户需求并保持有效性。这包括进行修改、修复错误、提高性能以及使软件适应环境或用户需求的变化。'
- en: 'In this case, we could make a direct comparison with the architecture of buildings
    to understand how it impacts the manageability of a project. Imagine two buildings,
    two residences: one very complicated and sophisticated, unique in its kind; it
    has special aesthetic and technological features created specifically for the
    occasion, refined materials, and unique solutions. The other building is a classic
    European apartment complex, with straight facades and identical windows, common
    and sturdy materials, very similar to others encountered before. In the case that
    I have to make a change or solve a problem, in which building do you think it
    would be easier to operate?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以直接将建筑物的架构与项目可管理性产生的影响进行比较，以理解其影响。想象两座建筑物，两座住宅：一座非常复杂且精致，其种类独一无二；它拥有为特定场合专门创造的特殊美学和技术特征，精选材料，以及独特解决方案。另一座建筑是一座经典的欧洲公寓楼，拥有笔直的立面和相同的窗户，使用常见的坚固材料，与之前遇到的非常相似。如果我要进行更改或解决问题，你认为在哪个建筑中操作会更简单？
- en: Out of all the parts of a computer program, keeping it up and running is the
    most expensive. The constant need for new features and fixing mistakes takes a
    lot of time and effort from people. The main cost of keeping a program going comes
    from searching through the existing code and dealing with risks. Searching through
    the code, called **spelunking** by Robert C. Martin in his book *Clean Architecture*,
    takes time and money to figure out the best way to add something new or fix a
    mistake. When making these changes, there’s always a chance of accidentally causing
    new problems, which adds to the risk and cost.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序的所有部分中，保持其运行是最昂贵的。对新功能和修复错误的持续需求需要人们投入大量时间和精力。保持程序运行的主要成本来自于搜索现有代码和处理风险。搜索代码，如罗伯特·C·马丁在其书籍《Clean
    Architecture》中所称的**洞穴探险**，需要时间和金钱来找出添加新事物或修复错误的最佳方式。在做出这些更改时，总有可能意外地造成新的问题，这增加了风险和成本。
- en: Having a well-thought-out plan for how the program is set up can really help
    cut down on these costs. If the program is split into different parts and each
    part is kept separate through stable connections, it makes it much easier to add
    new things without accidentally causing problems. This kind of planning reduces
    the risk of unintended issues and makes maintenance less costly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序如何设置有一个周密的计划，真的可以帮助减少这些成本。如果程序被分成不同的部分，并且每个部分通过稳定的连接保持独立，那么在不意外造成问题的前提下添加新事物会容易得多。这种规划减少了意外问题的风险，并使维护成本降低。
- en: Now that we have seen what architecture is and why it’s important, let’s discover
    the main types of architecture we can have.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了架构是什么以及为什么它很重要，让我们来探索我们可以拥有的主要架构类型。
- en: Architectural patterns
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构模式
- en: In software, we can organize things in different ways, and these organized structures
    are called **software architecture patterns**. Many of them have been tried and
    proven to work well for solving different problems. Each pattern arranges things
    in a specific way to fix particular issues in software.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，我们可以以不同的方式组织事物，这些组织结构被称为**软件架构模式**。其中许多已经经过尝试并证明对于解决不同问题非常有效。每个模式都以特定的方式安排事物，以解决软件中的特定问题。
- en: But let’s keep it interesting and not dive into a super long list of these patterns.
    Instead, we’ll look at a few of the most important and commonly used ones. This
    way, we can understand the main ideas without getting overwhelmed by all the possibilities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们保持兴趣，不要深入到一个超级长的模式列表中。相反，我们将查看一些最重要和最常用的模式。这样，我们可以理解主要思想，而不会被所有可能性所淹没。
- en: Layered architecture
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构
- en: The **layered architecture pattern** (also called the **n-tier architecture
    pattern**) is probably the most widely used design approach. It’s the go-to standard
    for many Java **Enterprise Edition** (**EE**) applications, and it’s well-known
    among architects, designers, and developers. This pattern closely aligns with
    typical communication and organizational setups in most companies, making it a
    logical and common choice for developing business applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**分层架构模式**（也称为**N层架构模式**）可能是最广泛使用的设计方法。它是许多Java **企业版**（**EE**）应用程序的默认标准，在建筑师、设计师和开发者中广为人知。这种模式与大多数公司典型的沟通和组织设置紧密一致，使其成为开发商业应用的逻辑和常见选择。'
- en: 'In the layered architecture pattern, components are organized into horizontal
    layers, each with a specific role in the application (such as presentation or
    business logic). While the pattern doesn’t prescribe a fixed number of layers,
    common setups have four: **presentation**, **business**, **persistence**, and
    **database**. Sometimes, the business and persistence layers are combined for
    simplicity. Smaller apps might have three layers, while larger ones could have
    five or more.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在分层架构模式中，组件被组织成水平层，每一层在应用程序中都有特定的角色（例如展示或业务逻辑）。虽然该模式没有规定固定层数，但常见的设置有四层：**展示层**、**业务层**、**持久层**和**数据库层**。有时，为了简化，业务层和持久层会合并。小型应用程序可能只有三层，而大型应用程序可能有五层或更多。
- en: 'Each layer has a distinct responsibility. For instance, the presentation layer
    handles user interfaces and communication, while the business layer executes business
    rules. Layers create abstractions, simplifying tasks. The presentation layer focuses
    on displaying information, not retrieving it. Similarly, the business layer concentrates
    on business logic, leaving data retrieval to the persistence layer, which then
    passes data to the business layer for processing and onward to the presentation
    layer for display:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都有其独特的责任。例如，展示层处理用户界面和通信，而业务层执行业务规则。层创建了抽象，简化了任务。展示层专注于显示信息，而不是检索信息。同样，业务层专注于业务逻辑，将数据检索留给持久层，然后持久层将数据传递给业务层进行处理，并最终传递给展示层进行显示：
- en: '![Figure 9.1 – Layered architecture](img/B20912_09_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 分层架构](img/B20912_09_1.jpg)'
- en: Figure 9.1 – Layered architecture
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 分层架构
- en: The layered architecture pattern excels in separating concerns among components.
    Each layer focuses solely on its relevant logic—presentation in the presentation
    layer, business in the business layer, and so forth. This classification simplifies
    role and responsibility models, making development, testing, governance, and maintenance
    straightforward. Defined component interfaces and limited scope contribute to
    this ease.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构模式在分离组件之间的关注点方面表现出色。每一层只关注其相关的逻辑——展示层关注展示，业务层关注业务，等等。这种分类简化了角色和责任模型，使得开发、测试、治理和维护变得简单。定义的组件接口和有限的范围有助于这种简便性。
- en: Notably, every layer in the architecture is marked as closed, a crucial concept
    in this pattern. A **closed layer** means a request must pass through the immediate
    layer below it before reaching the next one beneath. For instance, a request from
    the presentation layer travels through the business layer, then to the persistence
    layer, and finally reaches the database layer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，架构中的每一层都被标记为封闭的，这是该模式中的一个关键概念。**封闭层**意味着请求必须通过其下方的直接层才能到达下一层。例如，来自展示层的请求会穿过业务层，然后到达持久层，最后到达数据库层。
- en: Monolithic application architectures
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用架构
- en: 'In a layered architecture, as we said, the concept involves organizing different
    components or functionalities of a system into distinct layers. But these layers
    can be interpreted in two ways:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在分层架构中，正如我们所说的，概念涉及将系统的不同组件或功能组织成不同的层。但这些层可以有两种解释方式：
- en: '**Different applications/deployments**: In this interpretation, each layer
    is considered a separate application or deployment. Each layer represents a self-contained
    unit with specific responsibilities. For example, you might have a presentation
    layer, business logic layer, and data access layer deployed as separate applications.
    This approach promotes modularity and facilitates scalability and maintenance.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**不同的应用程序/部署**：在这种解释中，每一层被视为一个独立的应用程序或部署。每一层代表一个具有特定责任的独立单元。例如，你可能有展示层、业务逻辑层和数据访问层作为独立的应用程序部署。这种方法促进了模块化，并促进了可扩展性和维护性。'
- en: '**Components inside the same application (monolith or N-tier)**: Alternatively,
    the layers can be viewed as components within the same application. In a monolithic
    architecture or an N-tier architecture, different layers exist within a single
    application’s codebase. For instance, you could have a presentation layer handling
    user interfaces, a business logic layer managing application rules, and a data
    access layer interacting with the database—all within the confines of a single
    application.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**同一应用内部的组件（单体或N层）**：或者，可以将这些层视为同一应用内部的组件。在单体架构或N层架构中，不同的层存在于单个应用代码库中。例如，你可以有一个表示层处理用户界面，一个业务逻辑层管理应用规则，一个数据访问层与数据库交互——所有这些都在单个应用的范围内。'
- en: Both interpretations are valid, and the choice between them depends on the specific
    architectural design goals and requirements of the system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种解释都是有效的，选择哪一种取决于系统的具体架构设计目标和要求。
- en: Microservices
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: There are many lengthy books about **microservices**, and it would be impossible
    to tell you everything here and now. However, we should at least give you a general
    overview of the topic because for years – and perhaps still today – they have
    been one of the main trends in our industry.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**微服务**有很多篇幅很长的书籍，现在不可能在这里全部告诉你。然而，我们至少应该给你一个关于这个主题的概述，因为多年来——也许直到今天——它们一直是我们的行业中的主要趋势之一。
- en: '**Microservices architecture**, commonly abbreviated as microservices, is a
    specific way of structuring applications. In this architectural style, a large
    application is broken down into smaller, independent parts, each with its distinct
    set of responsibilities. This approach enables the creation of more modular and
    manageable components within the overall system. To represent this, we could put
    an example of a very common application, having a microservice dedicated to searching
    for items, another one handling the order, another one dealing with accounting
    issues, and a last one dealing with notifying users via email, push, and so on.
    Here is an example of microservices architecture:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**，通常简称为微服务，是一种特定的应用结构方式。在这种架构风格中，大型应用被分解成更小、更独立的组成部分，每个部分都有其独特的责任集。这种方法使得在整体系统中创建更多模块化和可管理的组件成为可能。为了表示这一点，我们可以举一个非常常见的应用的例子，有一个微服务专门用于搜索项目，另一个处理订单，另一个处理会计问题，最后一个处理通过电子邮件、推送等方式通知用户。以下是一个微服务架构的示例：'
- en: '![Figure 9.2 – An example of microservices architecture](img/B20912_09_2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 微服务架构的示例](img/B20912_09_2.jpg)'
- en: Figure 9.2 – An example of microservices architecture
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 微服务架构的示例
- en: In the context of microservices, an application can consist of numerous internal
    microservices, each handling a specific function. When a user makes a request,
    the microservices work together to compose and fulfill that request. This decentralized
    and modular nature of microservices offers flexibility, scalability, and easier
    maintenance compared to monolithic architectures where all functionalities are
    tightly integrated into a single, large application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的背景下，一个应用可以由许多内部微服务组成，每个微服务处理一个特定的功能。当用户发起请求时，微服务协同工作以组合和满足该请求。与所有功能紧密集成到单个大型应用中的单体架构相比，微服务的这种去中心化和模块化特性提供了灵活性、可扩展性和更易于维护。
- en: Understanding the concept of a service component is crucial within this pattern.
    Instead of viewing services in a microservices architecture, it’s more beneficial
    to consider service components. These components can vary in size, ranging from
    a single module to a substantial part of the application. Service components house
    one or more modules (that is, Java classes) representing either a specialized
    function (such as providing traffic information for a specific location) or an
    autonomous section of a comprehensive business application. Determining the appropriate
    level of granularity for service components stands as a significant challenge
    in the context of microservices architecture. Nobody I know is completely satisfied
    with that!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，理解服务组件的概念至关重要。在微服务架构中，与其将服务视为服务组件，不如考虑服务组件更有益。这些组件的大小可以不同，从单个模块到应用的重要部分。服务组件包含一个或多个模块（即Java类），代表一个特定的功能（例如，为特定位置提供交通信息）或一个综合业务应用的独立部分。在微服务架构的背景下，确定服务组件的适当粒度级别是一个重大的挑战。我所认识的人中没有人对这一点完全满意！
- en: Another essential idea in the microservices architecture pattern is its distributed
    nature. In this framework, all components within the architecture are completely
    independent of each other and are accessed through various remote access protocols
    (such as **Java Message Service** (**JMS**), **Advanced Message Queuing Protocol**
    (**AMQP**), **Representational State Transfer** (**REST**), **Simple Object Access
    Protocol** (**SOAP**), **Remote Method Invocation** (**RMI**), and so on). The
    distributed aspect of this architecture pattern is instrumental in achieving remarkable
    scalability and deployment characteristics.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构模式中的另一个基本思想是其分布式特性。在这个框架中，架构内的所有组件彼此完全独立，并通过各种远程访问协议（如**Java消息服务**（**JMS**）、**高级消息队列协议**（**AMQP**）、**表示状态转换**（**REST**）、**简单对象访问协议**（**SOAP**）、**远程方法调用**（**RMI**）等）进行访问。这种架构模式的分布式特性对于实现显著的扩展性和部署特性至关重要。
- en: In a microservices architecture, finding the right granularity for service components
    is a significant challenge. If they are too coarse-grained, you might miss out
    on the benefits of this pattern (deployment, scalability, testability, and loose
    coupling). On the other hand, overly fine-grained components can lead to service
    orchestration demands, turning your lean microservices architecture into a complex
    **service-oriented architecture** (**SOA**) with added complexity, confusion,
    and cost.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，找到服务组件的正确粒度是一个重大挑战。如果它们过于粗粒度，可能会错过这种模式的好处（部署、可扩展性、可测试性和松散耦合）。另一方面，过于细粒度的组件可能导致服务编排需求，将你的精简微服务架构转变为复杂的**面向服务架构**（**SOA**），增加了复杂性、混乱和成本。
- en: Detecting the granularity challenge is possible by looking for signs such as
    orchestrating service components from the user interface or **application programming
    interface** (**API**) layer, indicating components may be too fine-grained. Inter-service
    communication for a single request may also suggest incorrect granularity or improper
    partitioning based on business functionality.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过寻找诸如从用户界面或**应用程序编程接口**（**API**）层编排服务组件等迹象，可以检测到粒度挑战。对于单个请求的跨服务通信也可能表明粒度不正确或基于业务功能的分区不当。
- en: If service-component orchestration persists regardless of granularity, it might
    signal that a microservices architecture may not be the ideal choice. The distributed
    nature of this pattern makes maintaining a single transactional unit across components
    challenging, requiring complex transaction compensation frameworks for rollback,
    adding unnecessary complexity to this otherwise simple and elegant architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务组件的编排不受粒度影响而持续存在，这可能表明微服务架构可能不是最佳选择。这种模式的分布式特性使得在组件之间维护单个事务单元具有挑战性，需要复杂的补偿框架进行回滚，给这个简单而优雅的架构增加了不必要的复杂性。
- en: 'The microservices architecture offers a myriad of advantages that significantly
    impact the development and operation of large, complex applications:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构提供了许多优势，这些优势显著影响了大型、复杂应用程序的开发和运营：
- en: '**Continuous delivery and deployment**: One of the key strengths of the microservices
    architecture is its facilitation of continuous delivery and deployment. This means
    that updates, enhancements, or new features can be seamlessly integrated into
    the application without disrupting its overall functionality.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付和部署**：微服务架构的关键优势之一是它促进了持续交付和部署。这意味着更新、增强或新功能可以无缝集成到应用程序中，而不会干扰其整体功能。'
- en: '**Modular and easily maintained**: Microservices are designed to be small and
    modular, allowing for easy maintenance. Each service is focused on a specific
    business capability, making it more straightforward to understand, update, and
    troubleshoot.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化和易于维护**：微服务被设计成小而模块化，便于维护。每个服务都专注于特定的业务能力，这使得理解、更新和调试变得更加直接。'
- en: '**Independent deployability**: A notable feature is the ability to independently
    deploy services. This ensures that changes or updates to a particular service
    do not require a comprehensive redeployment of the entire application, leading
    to more efficient development processes.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立部署性**：一个显著的特点是能够独立部署服务。这确保了对特定服务的更改或更新不需要整个应用程序的全面重新部署，从而提高了开发过程的效率。'
- en: '**Scalability on a service level**: Microservices empower teams to independently
    scale services based on their specific demands. This granular scalability optimizes
    resource utilization and responsiveness, enhancing the overall performance of
    the application.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务级别的可伸缩性**：微服务使团队能够根据其特定需求独立扩展服务。这种细粒度的可伸缩性优化了资源利用率和响应速度，提高了应用程序的整体性能。'
- en: '**Autonomous teams**: The microservices architecture fosters team autonomy,
    enabling different teams to work independently on specific services. This autonomy
    streamlines development cycles, allowing teams to innovate and iterate at their
    own pace.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自治团队**：微服务架构促进了团队自治，使不同的团队能够独立地对特定服务进行工作。这种自治简化了开发周期，使团队能够以自己的节奏进行创新和迭代。'
- en: '**Experimentation with new technologies**: Embracing microservices allows for
    easy experimentation and adoption of new technologies. Since services can be built
    and deployed independently, teams can explore and implement cutting-edge tools
    or frameworks without overhauling the entire system.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新技术实验**：拥抱微服务允许轻松地进行新技术实验和采用。由于服务可以独立构建和部署，团队可以探索和实施尖端工具或框架，而无需彻底翻新整个系统。'
- en: '**Enhanced fault isolation**: In the microservices model, faults are isolated
    to individual services, preventing a failure in one service from cascading and
    affecting the entire application. This improves the overall resilience and robustness
    of the system.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的故障隔离**：在微服务模型中，故障被隔离到单个服务中，防止一个服务的故障级联并影响整个应用程序。这提高了系统的整体弹性和鲁棒性。'
- en: 'Of course, no technology is perfect, and the microservices system has some
    problems and challenges. Let’s delve into significant challenges and issues associated
    with the microservices architecture:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有技术是完美的，微服务系统也存在一些问题和挑战。让我们深入了解与微服务架构相关的重大挑战和问题：
- en: '**Service identification**: Determining the optimal set of services can be
    a demanding task. Selecting the right services that effectively represent distinct
    business capabilities requires careful consideration and planning.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务识别**：确定最佳服务集可能是一项艰巨的任务。选择能够有效代表不同业务能力的服务需要仔细考虑和规划。'
- en: '**Complexity of distributed systems**: Microservices involve the creation of
    distributed systems, adding a layer of complexity. This complexity extends to
    the development, testing, and deployment phases, posing challenges in ensuring
    seamless integration and operation.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式系统的复杂性**：微服务涉及分布式系统的创建，增加了复杂性的一层。这种复杂性扩展到开发、测试和部署阶段，确保无缝集成和操作带来了挑战。'
- en: '**Coordination for feature deployment**: Deploying features that span multiple
    services necessitates meticulous coordination. Ensuring that various services
    work harmoniously to deliver a unified functionality demands careful planning
    and execution to avoid disruptions.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能部署的协调**：部署跨越多个服务的功能需要细致的协调。确保各种服务能够和谐地工作以提供统一的功能，需要周密的计划和执行，以避免中断。'
- en: '**Decision-timing dilemma**: Determining the opportune moment to adopt the
    microservices architecture is a challenging decision. Knowing when the benefits
    outweigh the drawbacks and aligning the transition with organizational needs requires
    thoughtful evaluation.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**决策时机困境**：确定采用微服务架构的最佳时机是一个具有挑战性的决策。知道何时收益大于损失，并将过渡与组织需求相协调需要深思熟虑的评估。'
- en: Addressing these challenges is crucial for successfully implementing the microservices
    architecture.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些挑战对于成功实施微服务架构至关重要。
- en: Event-driven architecture
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: 'This is another common type of architectural pattern that can also be seen
    as a nuance of microservices. To put it simply, it involves designing a structure
    that recognizes events happening in the system—something that occurs—and making
    it react by producing some kind of result. The examples of “things that can happen”
    are potentially endless: a user signs up for the platform, a third-party system
    calls one of our webhooks, and an error occurs during some kind of process. For
    each of these events, one or more components will be listening and responding
    to the event itself. But let’s try to be a bit more formal in our definition.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的架构模式类型，也可以被视为微服务的一个细微差别。简单来说，它涉及设计一个结构，以识别系统中发生的事件——即发生的事情——并通过产生某种结果来做出反应。可以发生的事情的例子可能是无限的：用户注册平台、第三方系统调用我们的某个webhook，以及在某个过程中的错误发生。对于这些事件中的每一个，一个或多个组件都将监听并对事件本身做出响应。但让我们尽量在定义上更加正式。
- en: An **event** refers to a change in state or, more expansively, any observable
    occurrence that can be detected and documented by an application or device. These
    events can then be communicated and exchanged with other applications and devices.
    Within your enterprise, every incident—be it customer requests, updates in inventory,
    sensor readings, and the like—constitutes an event.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**指的是状态的变化，或者更广泛地说，任何可以被应用程序或设备检测和记录的可观察事件。然后，这些事件可以与其他应用程序和设备进行通信和交换。在你的企业中，每个事件——无论是客户请求、库存更新、传感器读数等等——都构成一个事件。'
- en: An **event-driven architecture** is a way for decoupled services to talk to
    each other using events, which are like little messages about changes or updates.
    This is a pretty common approach in modern apps with microservices.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动架构**是一种让解耦服务通过事件相互通信的方式，这些事件就像关于变化或更新的小消息。这在现代具有微服务的应用程序中是一种相当常见的方法。'
- en: 'In this setup, there are three main parts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置中，有三个主要部分：
- en: '**Event producers**: These are the creators of events and publish them to the
    router; for example, “a purchase is completed.”'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件生产者**：这些是事件的创建者，并将它们发布到路由器；例如，“购买已完成”。'
- en: '**Event routers or event brokers**: These are the organizers who decide where
    each event should go. For example, you can imagine something like “a completed
    purchase should result in sending an email to the customer.”'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件路由器或事件代理**：这些是决定每个事件应该去哪里的组织者。例如，你可以想象“完成购买应该向客户发送电子邮件”。'
- en: '**Event consumers**: These are the parts of the system that want to know about
    certain events; for example, a component that receives some data about a completed
    purchase and reacts by sending an email to the customer.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件消费者**：这些是系统中想要了解某些事件的组成部分；例如，一个接收有关完成购买数据的组件，并通过向客户发送电子邮件来做出反应。'
- en: The cool thing is these different parts don’t have to know too much about each
    other. They just send out these little event messages, and the other parts can
    choose to listen and react or not. In our examples, the component that completes
    the purchase doesn’t know a thing about what will happen next; it just publishes
    an event. The consumer, who is in charge of sending an email, doesn’t have to
    know anything about the purchase completion process. This makes things flexible
    because, for instance, you can update how the payment system works without messing
    up how the mailing system works. They are like separate teams that can do their
    own thing without always checking with each other. This can often translate into
    two actually different teams working more or less separately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好玩的是，这些不同的部分不必相互了解太多。它们只需发送这些小事件消息，其他部分可以选择是否监听和响应。在我们的例子中，完成购买的组件对接下来会发生什么一无所知；它只是发布了一个事件。负责发送电子邮件的消费者不必了解购买完成过程。这使得事情变得灵活，例如，你可以更新支付系统的工作方式，而不会弄乱邮件系统的工作方式。它们就像独立的团队，可以各自为政，而不必总是相互检查。这通常可以转化为两个实际上不同的团队在某种程度上独立工作。
- en: 'Sometimes, an event can also be referred to as a message; the terms are often
    interchangeable. A bit more specific is the concept of a command: unlike an event
    that defines a change of state in some data or entity within the domain, a command
    explicitly requires something to be done. The implicit aspect is that in this
    case, the one carrying out the action and publishing the event is aware of something
    that is supposed to happen afterward. Technologically, however, almost nothing
    changes. Here is a diagram of event-driven architecture:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，事件也可以被称为消息；这两个术语通常是可互换的。更具体一点的是命令的概念：与定义域内某些数据或实体状态变化的事件不同，命令明确要求执行某些操作。隐含的方面是，在这种情况下，执行动作并发布事件的人意识到之后会发生某些事情。然而，从技术角度来看，几乎没有变化。以下是事件驱动架构的示意图：
- en: '![Figure 9.3 – Event-driven architecture](img/B20912_09_3.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 事件驱动架构](img/B20912_09_3.jpg)'
- en: Figure 9.3 – Event-driven architecture
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 事件驱动架构
- en: 'There are several advantages to embracing an event-driven architecture:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 采用事件驱动架构有几个优点：
- en: 'The first is probably **independent scaling and fault isolation**: by adopting
    an event-driven architecture, the ability to scale and manage failures independently
    becomes a key benefit. As already mentioned, these are also benefits of microservices.
    Through the decoupling of services, each service interacts solely with the event
    router, rendering them agnostic to the existence of other services. Consequently,
    in the event of a failure in one service, the rest can continue to function seamlessly.
    The event router serves as an elastic buffer, adept at handling surges in workloads
    and ensuring overall system stability.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一点是可能**独立扩展和故障隔离**：通过采用事件驱动架构，独立扩展和管理失败的能力成为一项关键好处。如前所述，这些也是微服务的优势。通过服务的解耦，每个服务仅与事件路由器交互，使它们对其他服务的存在无感知。因此，在某个服务发生故障的情况下，其他服务可以继续无缝地运行。事件路由器充当弹性缓冲区，擅长处理工作负载的激增，并确保整体系统稳定性。
- en: The **development is more agile** because the event-driven model eliminates
    the need for custom code to poll, filter, and route events. Instead, the event
    router autonomously manages these tasks, automatically filtering and pushing events
    to consumers. This streamlined process significantly accelerates development cycles
    by minimizing the heavy coordination traditionally required between producer and
    consumer services. Developers can focus more on implementing business logic rather
    than dealing with intricate event-handling intricacies.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发更加敏捷**，因为事件驱动模型消除了需要自定义代码轮询、过滤和路由事件的需求。相反，事件路由器自主管理这些任务，自动过滤并将事件推送到消费者。这个过程简化了，显著加快了开发周期，通过最小化生产者和消费者服务之间传统上所需的繁重协调。开发者可以更多地关注实现业务逻辑，而不是处理复杂的事件处理细节。'
- en: When you have an event router acting as a centralized hub for auditing applications
    and establishing policies, you get **effortless auditing**. These policies can
    dictate access controls, limiting who can publish and subscribe to the router
    and specifying permissions for users and resources to access data. Additionally,
    the event router facilitates the encryption of events both during transit and
    while at rest, enhancing data security measures.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有一个充当审计应用程序集中枢纽并建立策略的事件路由器时，你将获得**轻松的审计**。这些策略可以规定访问控制，限制谁可以发布和订阅路由器，并指定用户和资源访问数据的权限。此外，事件路由器还促进了事件在传输和静止状态下的加密，增强了数据安全措施。
- en: 'You usually also have some **cost reductions**: event-driven architectures
    operate on a push-based model, triggering actions only when an event is present
    in the router. This contrasts with continuous polling, leading to reduced network
    bandwidth consumption, lower CPU utilization, decreased idle fleet capacity, and
    fewer SSL/TLS handshakes. The result is a more cost-effective system that maximizes
    resource efficiency by minimizing unnecessary operations, providing both economic
    and operational benefits.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常你还会有一些**成本降低**：事件驱动架构基于推送模型，仅在路由器中存在事件时触发操作。这与持续轮询形成对比，导致网络带宽消耗减少，CPU利用率降低，空闲车队容量减少，以及SSL/TLS握手次数减少。结果是，一个更经济高效的系统，通过最小化不必要的操作，提供经济和运营上的好处。
- en: 'In the world of event-driven setups, there are two main ways things work: the
    pub/sub model and the event streaming model.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动的设置中，事物运作主要有两种方式：发布/订阅模型和事件流模型。
- en: Pub/sub model
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布/订阅模型
- en: '**Pub/sub** stands for **publish/subscribe** or **publisher/subscriber**. This
    system functions using a messaging framework built on event stream subscriptions.
    Once an event takes place or is published, it is sent to subscribers who have
    expressed interest in that particular information. This method guarantees timely
    notification of relevant parties regarding unfolding events.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Event streaming
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the pub/sub model, the event streaming model involves the recording of
    events in a log. Here, event consumers do not subscribe to an event stream; instead,
    they have the flexibility to read from any segment of the stream and can join
    the stream at their convenience.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some different types of event streaming, the main ones being:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Event stream processing**: Leverages a data streaming platform such as Apache
    Kafka to intake events and handle the processing or transformation of the event
    stream'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple event processing**: An action is promptly triggered in the event consumer
    as soon as an event occurs'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Kafka
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The most widely tool used for event streaming is Apache Kafka. Apache Kafka
    stands out as a powerful distributed data streaming platform, widely recognized
    as a top-tier solution for event processing. Renowned for its versatility, this
    platform excels in managing the seamless flow of event streams in real-time, encompassing
    tasks such as publishing, subscribing, storing, and processing data. Designed
    to meet the demands of diverse use cases, Apache Kafka particularly shines in
    scenarios where high throughput and scalability are paramount.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: One of the distinctive features of Apache Kafka is its ability to efficiently
    handle a spectrum of data-sharing tasks without the need for intricate point-to-point
    integrations. This characteristic not only streamlines the overall architecture
    but also plays a pivotal role in reducing latency to an impressive millisecond
    scale. By offering a robust foundation for real-time data processing, Apache Kafka
    empowers organizations to harness the potential of timely insights and responsive
    analytics.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In essence, Apache Kafka emerges as an indispensable tool for industries and
    applications where the rapid exchange of information is critical. Its architecture
    not only supports the simultaneous handling of numerous events but also ensures
    that the system can effortlessly scale to accommodate growing demands. This combination
    of flexibility, scalability, and low-latency processing positions Apache Kafka
    as a preferred choice for businesses seeking a reliable and efficient solution
    for their data streaming and event processing needs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The natural evolution of an event-driven architecture, especially one that adopts
    the event streaming pattern, is reactive architecture.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Reactive architecture
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, a new way of doing things in the Java world has become popular,
    and it is called the **reactive paradigm**. Let us try to understand the basic
    ideas. As usual, we don’t expect you to fully grasp the reactive paradigm in just
    one part of a book. The *Further reading* section is there for you, so you can
    explore more about it!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，Java领域出现了一种新的做事方式，被称为**响应式范式**。让我们尝试理解其基本思想。像往常一样，我们不期望你仅通过一本书的一部分就能完全掌握响应式范式。*进一步阅读*部分为你提供了探索更多相关内容的途径！
- en: 'The term *reactive* is employed in the realm of reactive systems (not only
    in Java), and it was coined in the 2014 Reactive Manifesto, a collaborative effort
    by the community to develop responsive and distributed systems. The manifesto
    emphasizes the creation of systems that must be:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*响应式*在响应式系统领域（不仅限于Java）中被使用，它是在2014年的响应式宣言中提出的，这是社区为了开发响应式和分布式系统而进行的协作努力。宣言强调必须创建的系统：
- en: '**Responsive**: The system promptly responds with minimal and predictable delays
    to inputs to enhance user experience. For example, in a web application following
    reactive principles, user interface components are designed to update quickly
    in response to user interactions. For instance, when a user clicks a button, the
    system responds immediately, providing feedback without noticeable delays.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：系统对输入做出迅速响应，延迟最小且可预测，以提升用户体验。例如，在遵循响应式原则的Web应用程序中，用户界面组件被设计为对用户交互快速更新。例如，当用户点击按钮时，系统会立即响应，提供反馈而不会出现明显的延迟。'
- en: '**Resilient**: In the face of a component failure, the system gracefully handles
    it, minimizing the impact on overall system availability and responsiveness. For
    example, consider a microservices architecture where one service fails due to
    a temporary issue. A resilient system would handle this failure gracefully, perhaps
    by rerouting requests to an alternative instance of the service, ensuring that
    the overall system remains operational (**Circuit** **Breaker pattern**).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：面对组件故障，系统能够优雅地处理它，最小化对整体系统可用性和响应性的影响。例如，考虑一个微服务架构，其中一个服务因暂时性问题而失败。一个弹性的系统会优雅地处理这个故障，可能通过将请求重定向到服务的替代实例，确保整体系统保持运行（**电路**
    **断路器模式**）。'
- en: Circuit Breaker pattern
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器模式
- en: Connecting to the concept of resilience, it’s worth talking about the **Circuit
    Breaker** pattern; it is a design pattern to improve the resilience of a system.
    It is used to handle faults and failures in a distributed or remote service by
    detecting and preventing repeated failures. The pattern is inspired by the electrical
    circuit breaker, which automatically interrupts the flow of electricity when a
    fault is detected to prevent damage to the electrical system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与弹性概念相关联，值得讨论的是**电路断路器**模式；它是一种设计模式，用于提高系统的弹性。它通过检测和防止重复失败来处理分布式或远程服务中的故障和失败。该模式灵感来源于电气电路断路器，当检测到故障时会自动中断电流的流动，以防止对电气系统的损害。
- en: A circuit breaker operates by wrapping a function call (such as a remote service
    call) and monitoring for failures. When a certain threshold of failures is reached,
    the circuit breaker “trips” and stops allowing calls to that function for a specified
    period. During this time, the system can take alternative actions, such as returning
    a fallback response or retrying the operation after a delay. This prevents the
    system from repeatedly trying to call a failing service, which could lead to degraded
    performance or complete system failure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器通过包装函数调用（如远程服务调用）并监控故障来工作。当达到一定的故障阈值时，电路断路器“跳闸”，停止允许在该函数上调用指定时间段。在这段时间内，系统可以采取替代行动，例如返回回退响应或在延迟后重试操作。这防止了系统反复尝试调用失败的服务，这可能导致性能下降或系统完全故障。
- en: If you’d like to implement a circuit breaker in your Java application, the most
    used libraries are probably **Hystrix** and **Resilience4j**. Developed by Netflix,
    Hystrix is a widely used library for implementing the Circuit Breaker pattern
    in Java. It provides **fault tolerance** (**FT**) and **latency tolerance** (**LT**)
    features for distributed systems. Resilience4j is a lightweight, modular library
    for handling failures in Java 8+ and functional programming styles. It provides
    several resilience patterns, including Circuit Breaker, Rate Limiter, Retry, and
    Bulkhead. If you’re using Spring Boot, **Spring Cloud Circuit Breaker** offers
    a unified abstraction layer for various circuit breaker implementations. This
    framework presents a uniform API that developers can use within their applications,
    granting the flexibility to select the circuit breaker implementation that aligns
    most effectively with their specific application requirements. The supported implementations
    at the moment of writing are Resilience4j and Spring Retry.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Java应用程序中实现熔断器，最常用的库可能是**Hystrix**和**Resilience4j**。由Netflix开发，Hystrix是一个广泛使用的库，用于在Java中实现熔断器模式。它为分布式系统提供了**容错性**（**FT**）和**延迟容忍性**（**LT**）功能。Resilience4j是一个轻量级、模块化的库，用于处理Java
    8+和函数式编程风格的故障。它提供了包括熔断器、速率限制器、重试和隔离舱在内的多个容错模式。如果你使用Spring Boot，**Spring Cloud
    Circuit Breaker**提供了一个统一抽象层，用于各种熔断器实现。这个框架提供了一个统一的API，开发者可以在其应用程序中使用，从而提供了选择与特定应用程序需求最有效匹配的熔断器实现的灵活性。在撰写本文时，支持的实施方案包括Resilience4j和Spring
    Retry。
- en: '**Elastic**: The system can adapt to varying workloads, maintaining consistent
    response times. For example, an elastic system could automatically scale its resources
    up or down based on demand. During peak usage, additional server instances might
    be provisioned to handle the increased load, and they can be scaled down during
    periods of lower demand.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统可以适应不断变化的工作负载，保持一致的响应时间。例如，一个弹性的系统可以根据需求自动扩展或缩减其资源。在高峰使用期间，可能会配置额外的服务器实例来处理增加的负载，在需求较低期间可以缩减规模。'
- en: '**Message-driven**: Systems aligned with the manifesto employ a message-driven
    communication model. For example, in a distributed application, components communicate
    through messages rather than direct method calls: instead of invoking a remote
    service synchronously, a system following the message-driven approach might send
    a message asynchronously and continue processing other tasks while awaiting a
    response.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：与宣言一致的系统采用消息驱动通信模型。例如，在一个分布式应用程序中，组件通过消息而不是直接方法调用进行通信：而不是同步调用远程服务，遵循消息驱动方法的系统可能会异步发送消息，并在等待响应的同时继续处理其他任务。'
- en: A reactive architecture follows all these indications, emphasizing the propagation
    of changes and the declarative specification of the system’s behavior in response
    to those changes. In reactive systems, an often-used paradigm is the Actor Model.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式架构遵循所有这些指示，强调变化的传播和对系统行为声明性规范的系统行为。在反应式系统中，常用的一种范式是actor模型。
- en: The Actor Model
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**actor模型**'
- en: 'I think it’s worth mentioning the **Actor Model** because it’s truly interesting,
    serving as the foundation for reactive systems. The Actor Model is nothing new:
    it was introduced by Carl Eddie Hewitt in 1973 as a theoretical model for managing
    concurrent computation. Its practical relevance became evident as the software
    industry recognized the challenges associated with implementing concurrent and
    distributed applications. In other words: managing threads is not suitable anymore
    and we do not have faster CPUs; we only have CPUs with more cores!'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为值得提及**actor模型**，因为它确实很有趣，是反应式系统的基础。actor模型并非新事物：它由卡尔·爱迪生·休伊特在1973年作为管理并发计算的理论模型引入。随着软件行业认识到实现并发和分布式应用程序的挑战，其实际相关性变得明显。换句话说：管理线程不再适用，我们也没有更快的CPU；我们只有拥有更多核心的CPU！
- en: 'An actor is a *self-contained computational unit*, embodying several crucial
    characteristics that distinguish it within the Actor Model:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个actor是一个*自包含的计算单元*，体现了在actor模型中区分其的几个关键特征：
- en: '**Encapsulation of state and logic**: An actor encapsulates both its state
    and a portion of the application logic. This encapsulation ensures that an actor’s
    internal workings are shielded from direct external access, promoting modular
    and maintainable code.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**封装状态和逻辑**：演员封装了其状态和部分应用程序逻辑。这种封装确保了演员的内部工作不受直接外部访问的干扰，促进了模块化和可维护的代码。'
- en: '**Asynchronous message interaction**: Actors communicate exclusively through
    asynchronous messages, avoiding direct method calls. This design choice enhances
    the responsiveness of the system, as actors can continue processing messages independently
    without waiting for immediate responses.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**异步消息交互**：演员仅通过异步消息进行通信，避免直接方法调用。这种设计选择增强了系统的响应性，因为演员可以在不等待即时响应的情况下独立地继续处理消息。'
- en: '**Unique address and mailbox**: Each actor possesses a unique address and maintains
    a mailbox for incoming messages. The address serves as a distinct identifier in
    the system, while the mailbox provides a mechanism for other actors to deliver
    messages asynchronously.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**唯一的地址和邮箱**：每个演员都有一个唯一的地址，并维护一个用于接收消息的邮箱。地址在系统中作为唯一的标识符，而邮箱为其他演员提供了异步传递消息的机制。'
- en: '**Sequential message processing**: Messages in an actor’s mailbox are processed
    sequentially in the order of their arrival. The default implementation of the
    mailbox often adopts a **First-In-First-Out** (**FIFO**) queue, ensuring predictable
    and ordered execution of messages.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顺序消息处理**：演员邮箱中的消息按照到达顺序顺序处理。邮箱的默认实现通常采用**先进先出**（**FIFO**）队列，确保消息的可预测和有序执行。'
- en: '**Tree-like hierarchy**: The actor system is organized in a hierarchical, tree-like
    structure. This hierarchy facilitates the organization of actors, with each actor
    having a specific place and role within the larger system.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**树状层次结构**：演员系统以层次化的树状结构组织。这种层次结构便于演员的组织，每个演员在更大的系统中都有其特定的位置和角色。'
- en: '**Dynamic actor operations**: Actors can dynamically create other actors, send
    messages to any actor within the system, and initiate their own termination or
    that of actors they have spawned. This dynamic behavior allows for flexible and
    adaptive system architectures.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态演员操作**：演员可以动态创建其他演员，向系统内的任何演员发送消息，并启动他们自己或他们所创建的演员的终止。这种动态行为允许灵活和自适应的系统架构。'
- en: Making programs that do many things at the same time is tricky because we have
    to make sure different parts of the program don’t interfere with each other. The
    Actor Model makes it easier by letting us write code that can run independently
    without getting tangled up in these issues.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同时编写执行多项任务的程序是棘手的，因为我们必须确保程序的不同部分不会相互干扰。演员模型通过允许我们编写可以独立运行且不涉及这些问题的代码，使得这变得更容易。
- en: Instead of directly asking another part of the program to do something and waiting
    for it to finish, we can send a message and keep going. This means the part sending
    the message doesn’t have to wait around for a reply. A system using this feature
    is usually referred to as a **non-blocking system**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必直接要求程序的另一部分执行某事并等待其完成，我们可以发送一条消息并继续进行。这意味着发送消息的部分不需要等待回复。使用此功能的系统通常被称为**非阻塞系统**。
- en: Using messages also helps prevent problems that can happen when many parts of
    the program are working at the same time. Messages are like notes passed between
    different parts, and they get dealt with one after the other, so there’s no confusion.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息还有助于防止当程序的多部分同时工作时可能出现的各种问题。消息就像在不同部分之间传递的笔记，它们一个接一个地处理，因此不会产生混淆。
- en: Another good thing about the Actor Model is that if something goes wrong, such
    as a part of the program not doing what it’s supposed to, the actors can tell
    their “boss” about it. The boss can then decide whether to fix the problem or
    just start over with a fresh attempt. This way, the whole program can keep running
    smoothly even if there are hiccups along the way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型另一个优点是，如果出现问题，例如程序的一部分没有按预期执行，演员可以向他们的“老板”报告。然后，老板可以决定是修复问题还是从头开始新的尝试。这样，即使过程中出现故障，整个程序也可以保持平稳运行。
- en: In Java, you can leverage the Actor Model by using **Akka**, a toolkit and runtime
    for building highly concurrent, distributed, and fault-tolerant systems. It provides
    abstractions for managing concurrency, making it easier to develop scalable and
    resilient applications. In the *Further reading* section, there’s a simple tutorial
    about it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你可以通过使用**Akka**（一个用于构建高度并发、分布式和容错系统的工具包和运行时环境）来利用Actor模型。它提供了管理并发的抽象，使得开发可扩展和健壮的应用程序更加容易。在*进一步阅读*部分，有一个关于它的简单教程。
- en: 'We have quickly covered several broad and somewhat complex concepts; much of
    it relies on modern, non-monolithic architecture. Let’s now say a few words about
    one of the main trends of recent years: breaking the monolith!'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快速覆盖了几个广泛且相对复杂的概念；其中很多都依赖于现代的非单体架构。现在让我们说几句关于近年来主要趋势之一的话：打破单体！
- en: Monolith to microservices
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构到微服务架构
- en: A **monolithic architecture** refers to a traditional approach in software design
    where an entire application is built as a single, unified code base. In a monolithic
    architecture, all components and modules of the application are interconnected
    and interdependent. This means that the code for the user interface, business
    logic, and data access layers, among others, is tightly integrated into a single
    executable or deployment unit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**单体架构**指的是一种传统的软件开发方法，其中整个应用程序作为一个单一的、统一的代码库来构建。在单体架构中，应用程序的所有组件和模块都是相互连接和相互依赖的。这意味着用户界面、业务逻辑和数据访问层等代码紧密集成到一个单一的执行单元或部署单元中。'
- en: In a monolithic architecture, the entire application is developed and maintained
    within a single code base, making it a cohesive unit. All modules and components
    within the application are closely connected and share the same resources, such
    as databases and servers; therefore, the entire application is deployed as a single
    unit, making updates and releases a coordinated process. One advantage of the
    monolithic architecture is that it often uses a uniform technology stack throughout
    the entire system; the main disadvantage is that scaling a monolithic application
    typically involves replicating the entire application, which can be less efficient
    than scaling individual components independently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，整个应用程序是在单个代码库中开发和维护的，使其成为一个统一的单元。应用程序内的所有模块和组件都紧密相连，并共享相同的资源，例如数据库和服务器；因此，整个应用程序作为一个单一单元部署，使得更新和发布成为一个协调的过程。单体架构的一个优点是，它通常在整个系统中使用统一的技术栈；主要缺点是，扩展单体应用程序通常涉及复制整个应用程序，这可能不如独立扩展单个组件那么高效。
- en: While monolithic architectures have been the standard for many years and have
    certain advantages, such as simplicity in development and deployment, they also
    pose challenges, especially as applications grow in size and complexity. The move
    away from monolithic architecture has led to the adoption of alternative architectural
    patterns, the most common being microservices. This has been quite a mantra for
    the last few years, and there are lots of books and articles about that. We’ll
    just say a few words so that you don’t feel completely unprepared!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单体架构多年来一直是标准，并且具有开发部署简单等优势，但它们也带来了挑战，尤其是在应用程序规模和复杂性增长时。从单体架构的转型导致了替代架构模式的采用，其中最常见的是微服务。这已经成为了过去几年的一个口号，有很多关于这个话题的书和文章。我们只是简单地说几句，以免你感到完全未做好准备！
- en: 'Our first piece of advice is: don’t treat a monolith like it was necessarily
    evil because, well, it depends. In some cases, the monolith is OK. For example,
    if you have a small-scale application with limited complexity and traffic, the
    overhead of managing a microservices architecture might outweigh the potential
    benefits, especially if requirements don’t change that much. A monolith can be
    simpler to develop and maintain in such cases. Also, you could have limited resources:
    microservices often require specialized knowledge and additional infrastructure,
    which might not be feasible for smaller teams. Transitioning from a monolith to
    microservices requires time, effort, and potentially additional resources. If
    your organization is constrained in terms of time, budget, or expertise, maintaining
    the monolith might be a pragmatic decision. But the main reason could be that
    your monolith *just works*: if your monolithic application is stable, performs
    well, and meets the current and foreseeable future needs of the business, there
    might not be a compelling reason to undergo the complexity of transitioning to
    microservices.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一条建议是：不要将单体视为必然的邪恶，因为，嗯，这取决于情况。在某些情况下，单体是可以接受的。例如，如果你有一个规模较小、复杂性有限且流量较小的应用程序，管理微服务架构的开销可能超过了潜在的好处，尤其是如果需求变化不大。在这种情况下，单体可能更容易开发和维护。此外，你可能资源有限：微服务通常需要专业知识以及额外的基础设施，这可能对较小的团队来说不可行。从单体到微服务的过渡需要时间、努力，可能还需要额外的资源。如果你的组织在时间、预算或专业知识方面受限，维持单体可能是一个务实的决定。但主要原因可能是你的单体“正好工作”：如果你的单体应用程序稳定、性能良好，并且满足当前和可预见的未来业务需求，那么可能没有充分的理由去经历过渡到微服务的复杂性。
- en: 'While the benefits of microservices are evident, the transition from monolith
    to microservices comes with its own set of challenges. Entire books have been
    written on the argument, so we’ll just give you a couple of hints:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务的优势显而易见，但从单体到微服务的过渡也带来了一系列挑战。关于这个论点的书籍已经写了很多，所以我们只给你提供一两个提示：
- en: '**Data management**: The transition to microservices introduces a paradigm
    shift in data management. In a monolith, data is often stored and accessed within
    a unified database. However, in a microservices architecture, data is distributed
    across multiple services. This decentralization of data can lead to challenges
    in ensuring consistency and maintaining transactional integrity. Organizations
    must grapple with issues such as data synchronization, versioning, and cross-service
    transactions to avoid data inconsistencies and ensure the reliability of their
    applications.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管理**：向微服务架构的过渡在数据管理方面引入了一种范式转变。在单体架构中，数据通常存储和访问在一个统一的数据库中。然而，在微服务架构中，数据分布在多个服务中。这种数据去中心化可能导致确保一致性和维护事务完整性的挑战。组织必须应对数据同步、版本控制和跨服务事务等问题，以避免数据不一致并确保其应用程序的可靠性。'
- en: '**Service communication**: Efficient communication between microservices is
    paramount for the success of the architecture. Unlike monolithic applications,
    where function calls can be internal, microservices communicate over a network.
    Choosing appropriate communication protocols and mechanisms becomes crucial to
    facilitate seamless interactions between services. Decisions regarding synchronous
    or asynchronous communication, API design, and message formats require careful
    consideration to optimize the performance and reliability of the entire system.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务通信**：微服务之间的高效通信对于架构的成功至关重要。与单体应用程序不同，其中函数调用可以是内部的，微服务通过网络进行通信。选择适当的通信协议和机制变得至关重要，以促进服务之间的无缝交互。关于同步或异步通信、API设计和消息格式的决策需要仔细考虑，以优化整个系统的性能和可靠性。'
- en: '**Operational complexity**: The move to microservices introduces a new level
    of operational complexity. Managing a distributed system involves orchestrating
    the deployment and scaling of multiple services. Monitoring the health and performance
    of each service, logging relevant information for debugging purposes, and ensuring
    the overall reliability of the system become intricate tasks. Organizations need
    robust tools and practices for distributed tracing, logging aggregation, and monitoring
    to effectively navigate the operational challenges posed by microservices.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cultural shift**: Beyond technical considerations, transitioning to microservices
    often necessitates a cultural shift within development teams. Embracing a DevOps
    mindset, where development and operations teams collaborate closely throughout
    the **software development life cycle** (**SDLC**), becomes essential. **Continuous
    integration** and **continuous deployment** (**CI/CD**) practices need to be adopted
    to enable rapid and reliable releases. This cultural transformation requires a
    commitment to automation, collaboration, and a shared sense of responsibility
    among team members.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the previous points hides a world of challenges behind them. These challenges,
    while surmountable, underscore the need for a thoughtful and well-executed transition.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be really difficult, naive, and maybe even arrogant to try to guide
    you in just a few words through the transition to adopting a microservices architecture.
    I have been involved several times in projects where this transition took years
    and sometimes wasn’t even fully completed. It’s a lengthy process that requires
    great attention, especially in deciding how big a microservice should be. However,
    we can offer you some insights to understand what to pay attention to if you find
    yourself involved in such a transition (and it’s quite likely!):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Incremental adoption**: One of the best practices for a successful transition
    to microservices involves adopting a strategy of incremental changes rather than
    a sudden, big-bang overhaul. Organizations often find it prudent to start the
    migration process by identifying and transitioning non-critical services first.
    This phased approach allows teams to gain experience with microservices while
    minimizing the impact on the overall system. It also facilitates the identification
    and resolution of challenges on a smaller scale before tackling more critical
    components.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effective communication**: In a microservices architecture, where services
    communicate over a network, establishing clear and effective communication channels
    is paramount. Organizations should define and adhere to well-defined APIs to ensure
    seamless interaction between services. This not only enhances the reliability
    of the system but also facilitates the independence of services, enabling teams
    to evolve and update services without disrupting the entire application. Effective
    communication is foundational to achieving the modularity and flexibility that
    microservices promise.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated testing**: Comprehensive automated testing is a linchpin of successful
    microservices adoption. Given the distributed nature of microservices, thorough
    testing is essential to catch issues early in the development and deployment process.
    Test suites should cover unit testing, integration testing, and **end-to-end**
    testing for each microservice. Automation not only accelerates the testing process
    but also provides a safety net for frequent deployments, ensuring that changes
    to one service do not inadvertently break the functionality of others. Consider
    adopting contract testing.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and logging**: Operational complexities introduced by microservices
    necessitate robust monitoring and logging solutions. Organizations should invest
    in tools that enable real-time monitoring of service health, performance metrics,
    and potential issues. Centralized logging allows for efficient debugging and troubleshooting
    across distributed services. Proactive monitoring and logging not only aid in
    maintaining system reliability but also contribute to a proactive approach to
    system optimization and performance enhancement.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cultural alignment**: Transitioning to a microservices architecture is not
    only a technological shift but also a cultural one. Fostering a culture of collaboration,
    shared responsibility, and continuous learning is crucial for the success of the
    transition. Teams should embrace a DevOps mindset, where development and operations
    collaborate closely, and there is a shared sense of ownership for the entire system.
    Continuous learning and knowledge sharing ensure that teams are equipped to adapt
    to the evolving landscape of microservices and embrace the agility it brings to
    software development.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These best practices try to provide a roadmap for teams and organizations navigating
    the complex terrain of transitioning from monolithic architectures to microservices.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: When you have some kind of microservice architecture in place or, better, while
    designing it, you’ll want to be aware of some bad smells you could spot quite
    easily.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Bad smells in the microservices architecture
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as there are **bad smells** in code – issues that hide between methods
    and classes – there are also problems related to how software components work
    together in a software architecture. These are recurring patterns or, rather,
    anti-patterns, and when we see them, we should be suspicious and take action if
    needed. Let’s take a look at some of the most common ones.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Shared persistence
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “*Don’t cross the streams*,” as the *Ghostbusters* used to say. It’s a bit like
    what happens with shared persistence. We talk about shared persistence when two
    or more microservices share the same persistent data, such as a database, a **Redis**
    instance, or a cache. This can cause a few problems. First, if services *A* and
    *B* try to read and write to the same data layer at the same time, synchronization
    problems can occur. What one service reads might have been written by another,
    and vice versa.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the most significant issue, in my opinion, is the interdependence
    that arises when you need to make changes to the data structure itself. For example,
    simply changing, adding, or removing a column from a database table could become
    a big problem and might require modifying both microservices, even if one of them
    isn’t affected by the change. If we wanted to represent this situation in a very
    simple yet effective way, we would have a diagram like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Two (micro) services rely on the same data storage](img/B20912_09_4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Two (micro) services rely on the same data storage
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious solution is to maintain a separate data storage layer for each
    microservice. This means that each microservice owns its data, and it’s responsible
    for providing functions to access that data. When someone needs to use that data,
    they’ll use the microservice as a kind of **data abstraction**. They won’t need
    to know where or how the data is stored. Data owned by a specific microservice
    should not be duplicated elsewhere.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it’s essential to note that having a non-shared data storage layer
    doesn’t necessarily mean having a separate database for each microservice. It
    depends on the granularity of the service. For example, if you have a microservice
    that handles customers and their shipping addresses (such as in an e-commerce
    platform), you might have a database specific to this service. Customers and addresses
    are likely interconnected, so you might have relational tables linked; for example,
    by a foreign key. If you want to make your microservices more granular, say, a
    customer service and an address service, you can’t have completely separate and
    unrelated databases. However, you can ensure that the customer service writes
    to the `CUSTOMER` table and the address service writes to the `ADDRESS` table.
    These tables will be related by a foreign key but will remain distinct. Data integrity
    will be guaranteed (also) by the properties of the relational database (**ACID
    properties**):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Two services use different tables of the same database, which
    are related by the id-customer_id foreign key relationship](img/B20912_09_5.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Two services use different tables of the same database, which are
    related by the id-customer_id foreign key relationship
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ve told you how it should be, but we also need to tell you that this
    doesn’t always happen, especially during the transition from a monolithic system
    to microservices. You may have to share the data storage layer for a while. However,
    our advice is to avoid this situation as much as possible and resolve this issue
    as soon as you can.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sharing persistence** (data storage) leads to coupling problems, and the
    same goes for sharing libraries. One of the first things we discussed in this
    book, and generally emphasized in studies and work, is the principle of **Don’t
    Repeat Yourself** (**DRY**). Do things once, do them well, and reuse your code
    as much as possible. This is certainly a mantra to follow, but in the case of
    architecture (especially a microservices architecture), one must be very cautious.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine having two services – two components that use the same shared
    library, always written and managed by us. If we need to make a change to this
    library, we will not only have to handle the change in the library itself but
    also update the dependency in the microservices, and perhaps even change the code
    if needed (this depends on whether we change the method signatures or not).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The example we are discussing involves only two microservices and one library.
    However, within an architecture, there can be many interrelated components: component
    *A* is connected to component *B*, which is connected to component *C*, and so
    on. Modifying a library can potentially lead to a difficult-to-control ripple
    effect, triggering a chain of retesting, rebuilding, and redeploying that can
    be quite costly.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: I’m not saying here not to use shared libraries. Shared libraries are crucial
    for avoiding code duplication among software components. Take logging, for instance.
    Custom logic, such as formatting or concealing sensitive data such as customer
    details, is often required. Now, picture each component with its unique implementation.
    Consider the wasted developer hours if it’s not identical across components. Aggregating
    logs becomes challenging, and slight implementation differences can lead to inconsistent
    labeling.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Something such as the recent `log4j` vulnerability poses a significant challenge
    if this implementation is spread all around the code base. Fixing it per microservice
    or component demands substantial effort. Conversely, with a custom logging library
    using `log4j` internally, addressing the vulnerability only would require action
    at a single point. **Logging** is a universal feature in microservices, making
    it an excellent candidate for a shared library. Other examples include security,
    monitoring, async communication, and handling exceptions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Also, adding a middle layer between the code and external tools is really helpful.
    It protects the main part of the program from changes in those tools. This makes
    it easier to put new features in or fix problems. It also makes the code easier
    to read and work on with a team. After a year of doing this, it’s clear that it
    makes our software stronger and more flexible.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: I’m trying to say here that while good architecture implies decoupling the different
    parts of the application, shared libraries do exactly the opposite. On the other
    hand, they reduce repetition, and that’s good! We have to find a balance. There’s
    no one-size-fits-all rule for every situation. You need to consider each case
    individually. In general, it could be said that it’s worth creating a shared library
    whenever you need to write code that doesn’t depend on the specific subject of
    the module you’re working on. The examples mentioned earlier (logging, security,
    monitoring, and so on) are things that can be used in different situations, no
    matter what specific area you’re working in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to handle your shared libraries. You could either set
    up a distinct repository for each needed library or use a single repository (referred
    to as a **monorepo**; more on this in the *Further reading* section) that houses
    multiple libraries. The crucial point is to have some form of separation. For
    instance, you could have a single repository covering monitoring, security, and
    logging projects. Each project would be self-contained, except for any necessary
    dependencies.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s really important to keep the user’s decisions and logic inside a kind
    of protective bubble; this is crucial in programming and when making shared libraries.
    **Encapsulation** is like a shield that stops unwanted access and keeps data safe
    from being leaked. That’s why it’s a must when you’re building shared libraries.
    Let’s imagine you’re making a library with code specific to a certain company,
    such as a tool to put files into storage. The parts that the user works with need
    to be designed in a general way, avoiding names such as *S3FileUploader* (because
    S3 is Amazon’s storage service). But why avoid these names? Well, think about
    this: what if in the future you want to switch to Azure Blob (which is like Microsoft’s
    version of Amazon S3)? If you had named things specifically to Amazon, all your
    users would have to change their ways of doing things. So, it’s better to use
    more general names, such as *FileUploader*. Believe me, it’ll save you a bunch
    of time and work in the long haul.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Keep your library code clean. Even though many people may contribute to the
    shared library, avoid turning it into a big, complicated thing! Before adding
    a new library, think about it a lot. When you do add one, think about how it might
    change and who will use it. Don’t just make it for your own needs; that makes
    it hard for others to use or add to.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Don’t put domain-specific code in there! Even shared business code probably
    doesn’t belong there. Even if it means each component that uses it has to copy
    it, a user model that starts the same for all components is still business-related
    logic that shouldn’t be in the library. That’s because different services might
    need to change later to fit their specific business needs. It’s not good if they
    all use the same model because it might have things that don’t relate to other
    microservices or even break them if they want to rename or change some of the
    logic. So, when working with a single repository, it’s a great idea to use conventional
    commits to talk about changes in the code. Follow some commit conventions you’ll
    find among the team, such as starting each commit with *fix* when you’re fixing
    something. This is helpful when someone else is trying to understand the history
    of the repository, what was done, and where things are in the code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, when you’re dealing with a shared library that is a client
    library to another service, you could think about generating it. Rather than writing
    a shared library to interact with APIs in a system, it’s more effective to create
    an API specification. This specification can then be used to automatically generate
    API clients for various languages and services. Something really cool we did once
    was to include and use a library called **Feign**, a Java-based declarative web
    service client developed by Netflix. It simplifies the creation of HTTP clients
    for RESTful services by allowing developers to define requests using annotations
    and interface methods. Feign integrates with Netflix Ribbon for load balancing,
    supports various data formats, and provides fallback mechanisms for enhanced application
    robustness. It’s commonly used in microservices architectures for efficient communication
    between services.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Direct communication
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary motivations behind designing good architecture is the desire
    for improved flexibility and easier maintenance of the overall system. This flexibility
    is crucial for accommodating changes within the application, including modifications
    to the API of individual services or adjustments to the communication protocols
    between services.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a challenge arises when clients communicate directly with different
    services. This direct communication model diminishes some of the benefits of a
    good architectural design, particularly regarding flexibility. When clients are
    tightly coupled to the specific addresses of other services, the ability to relocate
    or split these services becomes problematic. In essence, the address of a service
    becomes a fixed point, making it difficult to make structural changes to the system
    without impacting its clients. Additionally, when a service is publicly exposed,
    there is a constant need to maintain backward compatibility in its API to avoid
    disrupting existing clients. This is usually considered an anti-pattern, and we’re
    going to represent it with the following diagram, where you can see different
    types of devices connecting directly to the exposed services:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Different clients for different devices directly call the services](img/B20912_09_6.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Different clients for different devices directly call the services
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: There are many possible solutions to avoid this anti-pattern. Let’s see a couple
    of them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An **API gateway** is a server or service that acts as an entry point for a
    collection of services. Its primary role is to provide a centralized and unified
    point of entry for clients (such as mobile apps, web applications, or other services)
    to interact with various components. It basically sits between the client and
    server, providing other essential functions. Here is a diagram of an API gateway:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – All of the clients of the different devices pass through the
    same API gateway](img/B20912_09_7.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – All of the clients of the different devices pass through the same
    API gateway
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, API gateways usually provide **request routing**: an API gateway
    routes incoming requests from clients to the appropriate service(s). It acts as
    a traffic cop, directing requests to the relevant service based on factors such
    as the endpoint, version, or other criteria.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway can **aggregate multiple requests** from clients into a single
    request to reduce the number of round trips between the client and the services.
    This is beneficial for optimizing performance and reducing latency. Similarly,
    the API gateway can **aggregate responses** from multiple services before sending
    them back to the client. This can reduce the number of requests needed from the
    client and enhance overall system efficiency.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Load balancing** distributes incoming requests across multiple instances
    of a service to ensure optimal resource utilization and prevent overload on any
    single instance. The API gateway can handle this load balancing to enhance the
    system’s scalability and reliability.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway usually centralizes **authentication and authorization** processes.
    It can enforce security measures such as validating API keys, handling user authentication,
    and ensuring that only authorized clients can access specific services.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: To improve performance, the API gateway can implement **caching** strategies.
    It can store and retrieve responses from services in a cache, reducing the need
    to recompute or fetch the same data repeatedly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway often includes **monitoring and analytics** tools to track the
    performance and usage of microservices. This information can be valuable for identifying
    bottlenecks, optimizing resource allocation, and ensuring the overall health of
    the system.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: An API gateway can enforce **rate limits** on incoming API requests to prevent
    abuse or overuse of resources. This involves setting a maximum number of requests
    a user or client can make within a specified time frame.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Throttling can also be implemented through **quotas**, where clients are allocated
    a certain number of resources or requests over a defined period. Somehow related
    to quotas is the concept of **monetization**: API gateways can track the usage
    of APIs by clients and implement usage-based billing. This involves charging clients
    based on the number of requests, data transferred, or other relevant metrics.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the API gateway pattern is the **Backend for Frontend** (**BFF**)
    pattern.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Backend For Frontend (BFF)
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *BFF* refers to a design pattern in software development where a separate
    backend is created for each frontend application or user interface. This approach
    is particularly common in the context of microservices architectures and is aimed
    at optimizing the interaction between frontend and backend components.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional web application, there is usually a single backend that serves
    data and functionality to various frontend clients. However, as applications become
    more complex and diverse, with different platforms (web, mobile, and so on) and
    user experiences, managing all these requirements within a single backend can
    become challenging.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The BFF pattern addresses this challenge by creating specialized backend services
    for each frontend or client type. Each BFF is tailored to the specific needs of
    the corresponding frontend, providing a more efficient and targeted interface
    between the two layers. This allows frontend developers to have more control over
    the data and services they need, without being constrained by a monolithic backend
    that serves multiple purposes. Please be mindful that the BFF functions as a “proxy,”
    filtering and adjusting requests from a shared set of backend (BE) services to
    a particular frontend (FE) client. It is essential that the BFF does not duplicate
    backend business functionalities in theory, as doing so would compromise the integrity
    of the application. Here is a diagram of the BFF pattern:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – In BFF, we have a gateway for each type of client](img/B20912_09_8.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – In BFF, we have a gateway for each type of client
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the earlier diagram, in this setup, each device type links to
    its dedicated API gateway tailored to its requirements. These gateways act as
    a kind of cover, hiding the services in the background and decoupling the devices
    from direct connections to these services.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several advantages to using the BFF pattern:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Specialization**: Each BFF can be optimized for the specific requirements
    of its associated frontend, leading to better performance and user experience'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autonomy**: Frontend and backend teams can work more independently, as changes
    to one do not necessarily affect the other, provided the API contracts are maintained'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Different frontends may have varying scalability needs, and
    BFFs allow for more fine-grained scalability planning based on individual requirements'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: BFFs can adapt to the technology stack and architectural choices
    that are most suitable for the specific frontend they serve'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that while the BFF pattern offers advantages, it also
    introduces some complexities, such as the need to manage multiple backend services.
    Proper communication and coordination between frontend and backend teams, as well
    as adherence to well-defined API contracts, are crucial for the success of this
    pattern.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve dived into the meaning of the term *architecture* and
    checked out its main variations. We’ve seen why having a clean, maintainable,
    and scalable architecture is important, and we’ve got some hints on how to achieve
    it (make sure to dig deeper in the *Further reading* section). We’ve looked at
    the main architectural patterns, from the (relatively) simpler ones to the slightly
    more complex ones designed for larger systems. We’ve also discussed what to watch
    out for when trying to break the monolith – moving from a monolithic architecture
    to a microservices one. Speaking of the latter, we’ve taken a quick look at some
    of the most common bad smells you might encounter. Remember – always keep your
    spider senses active!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: As you close this book, remember that writing good code is not a one-time effort
    but a continuous commitment to excellence. Act like a craftsman, constantly refining
    your code to reflect your evolving understanding of best practices and industry
    trends.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The concepts you’ve acquired here will not only result in more readable and
    efficient Java code but will also empower you to collaborate seamlessly with fellow
    developers, ultimately contributing to the success of your projects. As you start
    your coding journey, let the principles of clean code and the art of refactoring
    be your guiding lights, illuminating a path toward software excellence.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: May your code always be clean, your designs elegant, and your ride in the world
    of Java programming be both fulfilling and rewarding.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Happy coding!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Giuseppe Bonocore, *Hands-On Software Architecture with Java*, Packt Publishing
    Ltd.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robert C. Martin, *Clean Architecture*, Prentice Hall
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark Richards, *Software Architecture* *Patterns*, O’Reilly
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Martin Fowler’s work on architecture: [https://martinfowler.com/architecture/](https://martinfowler.com/architecture/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Monorepo* *Explained*: [https://monorepo.tools/](https://monorepo.tools/)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Intro to* *Feign*: [https://www.baeldung.com/intro-to-feign](https://www.baeldung.com/intro-to-feign)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Intro to Apache* *Kafka*: [https://www.baeldung.com/apache-kafka](https://www.baeldung.com/apache-kafka)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Akka: [https://www.baeldung.com/akka-actors-java](https://www.baeldung.com/akka-actors-java)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sam Newman, *Monolith to* *Microservices*, O’Reilly
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
