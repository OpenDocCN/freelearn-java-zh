<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Using a Database"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Using a Database</h1></div></div></div><p>Our application is growing steadily. We now need a place to store the contacts we are going to manage, and an efficient way to do so. We will use the MySQL server, whose installation was outlined in the first chapter of the book, for our data storage needs. Dropwizard provides everything we will need to interact with it.</p><div class="section" title="Preparing the database"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec19"/>Preparing the database</h1></div></div></div><p>It is <a id="id132" class="indexterm"/>time to actually store and retrieve data with our application. We are going to create a connection between our application and a MySQL database.</p><p>We will need an actual database to connect to and query. Since we have MySQL installed, we can also use the <code class="literal">mysql</code> command-line client in order to create a database and some tables in it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec35"/>Getting ready</h2></div></div></div><p>Start the <code class="literal">mysql</code> client by executing the following command in your terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mysql -u root -p</strong></span>
</pre></div><p>As shown in the following screenshot, the MySQL shell will then prompt you to provide your password, which is the password of the MySQL root user that you set during the installation of MySQL:</p><div class="mediaobject"><img src="graphics/9530OS_06_01.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec36"/>How to do it…</h2></div></div></div><p>Let's follow<a id="id133" class="indexterm"/> the next steps in order to prepare our application's database:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the database phonebook by running the following query:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; CREATE DATABASE `phonebook`;</strong></span>
</pre></div></li><li class="listitem">We will need an additional MySQL user with full rights to the newly created database. Create the user and grant appropriate access rights with the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; CREATE USER 'phonebookuser'@'localhost' IDENTIFIED BY'phonebookpassword';</strong></span>
<span class="strong"><strong>&gt; GRANT ALL ON phonebook.* TO 'phonebookuser'@'localhost';</strong></span>
</pre></div></li><li class="listitem">Select <a id="id134" class="indexterm"/>the <code class="literal">phonebook</code> database with the <code class="literal">USE</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; USE `phonebook`;</strong></span>
</pre></div></li><li class="listitem">Create the contact table in order to store some contacts.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; CREATE TABLE IF NOT EXISTS `contact` (</strong></span>
<span class="strong"><strong>    `id` int(11) NOT NULL AUTO_INCREMENT,</strong></span>
<span class="strong"><strong>    `firstName` varchar(255) NOT NULL,</strong></span>
<span class="strong"><strong>    `lastName` varchar(255) NOT NULL,</strong></span>
<span class="strong"><strong>    `phone` varchar(30) NOT NULL,</strong></span>
<span class="strong"><strong>    PRIMARY KEY (`id`)</strong></span>
<span class="strong"><strong>    ) </strong></span>
<span class="strong"><strong>    ENGINE=InnoDB </strong></span>
<span class="strong"><strong>    DEFAULT CHARSET=utf8 </strong></span>
<span class="strong"><strong>    AUTO_INCREMENT=1 ;</strong></span>
</pre></div></li><li class="listitem">Add some test data in the contact table:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; INSERT INTO `contact` VALUES (NUL L, 'John', 'Doe', '+123456789'), (NULL, 'Jane', 'Doe', '+987654321');</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec37"/>How it works…</h2></div></div></div><p>We have just set up our database. With the queries we ran, we created a database along with a database user and a table to hold contact-related information. Our application will be updated in order to store and retrieve information to and from this table.</p></div></div></div>
<div class="section" title="Interacting with the database"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec20"/>Interacting with the database</h1></div></div></div><p>Now we<a id="id135" class="indexterm"/> have a database and data in place. However, in order to be able to connect to the database, we need to include the <code class="literal">mysql jdbc</code> connector in the project. Also, we will need the <code class="literal">dropwizard-jdbi</code> module that will allow us to create a database connection and <span class="strong"><strong>Data Access Objects</strong></span> (<span class="strong"><strong>DAO</strong></span>) through which we will <a id="id136" class="indexterm"/>query the database, making use of the API provided by the<a id="id137" class="indexterm"/> JDBI project (<a class="ulink" href="http://jdbi.org/">http://jdbi.org/</a>).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec38"/>Getting ready</h2></div></div></div><p>Let's see what is needed in order to achieve this. First, add the following dependencies in <code class="literal">pom.xml</code> within the <code class="literal">&lt;dependencies&gt;</code> section:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;io.dropwizard&lt;/groupId&gt;&lt;artifactId&gt;dropwizard-jdbi&lt;/artifactId&gt;&lt;version&gt;0.7.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;</pre></div><p>We are now ready to proceed and update our application. We are going to use JDBI's SQL object API mapping methods to predefine the SQL statements.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>How to do it…</h2></div></div></div><p>Let's see how to connect and interact with the database through our application by following the next steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new package, <code class="literal">com.dwbook.phonebook.dao</code>, and a <code class="literal">ContactDAO</code> interface in it with the following code:<div class="informalexample"><pre class="programlisting">package com.dwbook.phonebook.dao;public interface ContactDAO { }</pre></div></li><li class="listitem">Add the <code class="literal">#getContactById()</code>method, which will allow us to query the database <a id="id138" class="indexterm"/>and retrieve a list of contacts or a specific contact when its ID is given. Use the <code class="literal">@SqlQuery</code> annotation to specify <a id="id139" class="indexterm"/>the SQL query that will be executed when the method is called. You will need to import <code class="literal">org.skife.jdbi.v2.sqlobject.*</code> and <code class="literal">com.dwbook.phonebook.representations.Contact</code>.<div class="informalexample"><pre class="programlisting">@SqlQuery("select * from contact where id = :id")Contact getContactById(@Bind("id") int id);</pre></div></li><li class="listitem">Create <a id="id140" class="indexterm"/>a <code class="literal">com.dwbook.phonebook.dao.mappers</code> package and the <code class="literal">ContactMapper</code> class that implements the map method, as shown in the following code snippet. Mapper classes facilitate the mapping of a <code class="literal">resultset</code> database row to an object. You will need to import <code class="literal">java.sql.ResultSet</code>, <code class="literal">java.sql.SQLException</code>, <code class="literal">org.skife.jdbi.v2.StatementContext</code>, <code class="literal">org.skife.jdbi.v2.tweak.ResultSetMapper</code>, and <code class="literal">com.dwbook.phonebook.representations.Contact</code>.<div class="informalexample"><pre class="programlisting">public class ContactMapper implements ResultSetMapper&lt;Contact&gt; {public Contact map(int index, ResultSet r,StatementContext ctx)throws SQLException {return new Contact(r.getInt("id"), r.getString("firstName"),r.getString("lastName"),r.getString("phone"));}}</pre></div></li><li class="listitem">In <code class="literal">ContactDAO</code>, register your mapper with the <code class="literal">#getContactById()</code> method by <a id="id141" class="indexterm"/>adding the <code class="literal">@Mapper</code> annotation to it (before <a id="id142" class="indexterm"/>the <code class="literal">@SqlQuery</code> <a id="id143" class="indexterm"/>annotation). Import the <code class="literal">com.dwbook.phonebook.dao.mappers.ContactMapper</code> and <code class="literal">org.skife.jdbi.v2.sqlobject.customizers.Mapper</code> classes.<div class="informalexample"><pre class="programlisting">@Mapper(ContactMapper.class)@SqlQuery("select * from contact where id = :id")Contact getContactById(@Bind("id") int id);</pre></div></li><li class="listitem">In the <code class="literal">config.yaml</code> configuration file, add the section database consisting of the minimum set of properties required for establishing a database connection (indented according to the <code class="literal">YAML</code> syntax).<div class="informalexample"><pre class="programlisting">database:driverClass: com.mysql.jdbc.Driveruser: phonebookuserpassword: phonebookpasswordurl: jdbc:mysql://localhost/phonebook</pre></div></li><li class="listitem">Add the database property in the <code class="literal">PhonebookConfiguration</code> class, and create a getter method for it. Import the <code class="literal">io.dropwizard.db.DataSourceFactory</code> class first.<div class="informalexample"><pre class="programlisting">     @JsonProperty
     private DataSourceFactory database = new DataSourceFactory();
  
      public DataSourceFactory getDataSourceFactory() {
          return database;
    }</pre></div></li><li class="listitem">Modify<a id="id144" class="indexterm"/> the <code class="literal">run</code> method in the <code class="literal">App</code> class in order to create a DBIFactory class that will be used to build a <code class="literal">DBI</code> instance, which we will then pass as a parameter to <code class="literal">ContactResource</code>. You will need to import <code class="literal">org.skife.jdbi.v2.DBI</code> and <code class="literal">io.dropwizard.jdbi.DBIFactory</code>.<div class="informalexample"><pre class="programlisting">  @Override
  public void run(PhonebookConfiguration c, Environment e)throws Exception {
    LOGGER.info("Method App#run() called");
    for (int i=0; i &lt; c.getMessageRepetitions(); i++) {
      System.out.println(c.getMessage());
    }
    System.out.println(c.getAdditionalMessage());
    
    // Create a DBI factory and build a JDBI instance
    final DBIFactory factory = new DBIFactory();
    final DBI jdbi = factory
      .build(e, c.getDataSourceFactory(), "mysql");
    // Add the resource to the environment
    e.jersey().register(new ContactResource(jdbi));
  }</pre></div></li><li class="listitem">In the previous step, we passed the <code class="literal">jdbi</code> instance as a parameter to the <code class="literal">ContactResource</code> constructor. However, the constructor <code class="literal">ContactResource(DBI)</code> does not exist (yet), so we need to create it. We will add a private final <code class="literal">ContactDAO</code> member in our resource class using the <code class="literal">onDemand</code> method<a id="id145" class="indexterm"/> and use JDBI to instantiate it. You will also need to add the necessary imports for <code class="literal">DBI</code> and <code class="literal">ContactDAO</code>.<div class="informalexample"><pre class="programlisting">private final ContactDAO contactDao;public ContactResource(DBI jdbi) {contactDao = jdbi.onDemand(ContactDAO.class);}</pre></div></li><li class="listitem">Modify <a id="id146" class="indexterm"/>the <code class="literal">ContactResource#getContact()</code> method class using the <code class="literal">contactDao</code> object so it returns an actual contact from the database.<div class="informalexample"><pre class="programlisting">  @GET
  @Path("/{id}")
  public Response getContact(@PathParam("id") int id) {
    // retrieve information about the contact with theprovided id
    Contact contact = contactDao.getContactById(id);
    return Response
      .ok(contact)
      .build();
  }</pre></div></li><li class="listitem">Rebuild and run the application, providing the updated configuration file as an argument.</li><li class="listitem">Open <a id="id147" class="indexterm"/>your browser and go to <code class="literal">http://localho</code><code class="literal">st:8080/contact/1</code>. You will see a JSON representation of the first row we inserted in the contact table, the one having <code class="literal">id</code> equal to <code class="literal">1</code>, that is, <code class="literal">John Doe</code>. Take a look at the following screenshot which outlines this:<div class="mediaobject"><img src="graphics/9530OS_06_02.jpg" alt="How to do it…"/></div><p>Respectively, the following screenshot shows the output for 
<code class="literal">http://localhost:8080/contact/2</code>:</p><div class="mediaobject"><img src="graphics/9530OS_06_03.jpg" alt="How to do it…"/></div></li><li class="listitem">Now, let's add the methods for creating, updating, and deleting contacts in our DAO. For<a id="id148" class="indexterm"/> inserting new entries, add the <code class="literal">#createContact()</code> method.<div class="informalexample"><pre class="programlisting">  @GetGeneratedKeys
  @SqlUpdate("insert into contact (id, firstName, lastName, phone) values (NULL, :firstName, :lastName, :phone)")
  int createContact(@Bind("firstName") String firstName, @Bind("lastName") String lastName, @Bind("phone") String phone);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Note that since we are updating the database and not querying it (that is, retrieving information), we use the <code class="literal">@SqlUpdate</code> annotation for the SQL query instead <a id="id149" class="indexterm"/>of the <code class="literal">@SqlQuery</code> annotation we used in the <code class="literal">#getContact()</code> method. Also, the <code class="literal">@GetGeneratedKeys</code> annotation is used in order to retrieve the value of the <a id="id150" class="indexterm"/>primary key of the newly inserted row; in this case, the value of the <code class="literal">id</code> field.</p></div></div></li><li class="listitem">For<a id="id151" class="indexterm"/> updating <a id="id152" class="indexterm"/>existing entries, add the <code class="literal">#updateContact()</code> method:<div class="informalexample"><pre class="programlisting">@SqlUpdate("update contact set firstName = :firstName, lastName = :lastName, phone = :phone where id = :id")
void updateContact(@Bind("id") int id, @Bind("firstName") String firstName, @Bind("lastName") String lastName,@Bind("phone") String phone);</pre></div></li><li class="listitem">In order<a id="id153" class="indexterm"/> to delete existing entries, add the <code class="literal">#deleteContact()</code> method:<div class="informalexample"><pre class="programlisting">@SqlUpdate("delete from contact where id = :id")
void deleteContact(@Bind("id") int id);</pre></div></li><li class="listitem">Now that we have the database methods in place, let's use them in the <code class="literal">Resource</code> class so that we actually insert, update, and delete contacts. Modify the <code class="literal">ContactResource#createContact()</code> method<a id="id154" class="indexterm"/> in order to insert the new contact in the database, retrieve its <code class="literal">id</code>, and use it to construct its URI, passing it as a <a id="id155" class="indexterm"/>parameter to the <code class="literal">Response#created()</code> method. For this, we will need to import <code class="literal">java.net.URI and java.net.URISyntaxException</code> first:<div class="informalexample"><pre class="programlisting">  @POST
  public Response createContact(Contact contact) throws URISyntaxException {
    // store the new contact
    int newContactId = contactDao.createContact(contact.getFirstName(), contact.getLastName(), contact.getPhone());
    return Response.created(new URI(String.valueOf(newContactId))).build();
  }</pre></div></li><li class="listitem">In <a id="id156" class="indexterm"/>a similar way, update the <code class="literal">ContactResource#deleteContact()</code> method so that the contacts can indeed be deleted:<div class="informalexample"><pre class="programlisting">  @DELETE
  @Path("/{id}")
  public Response deleteContact(@PathParam("id") int id) {
    // delete the contact with the provided id
    contactDao.deleteContact(id);
    return Response.noContent().build();
  }</pre></div></li><li class="listitem">Finally, let's <a id="id157" class="indexterm"/>also update the <code class="literal">ContactResource#updateContact()</code> method so that our application can update existing contacts while handling the relevant HTTP requests:<div class="informalexample"><pre class="programlisting">  @PUT
  @Path("/{id}")
  public Response updateContact(@PathParam("id") int id, Contact contact) {
    // update the contact with the provided ID
    contactDao.updateContact(id, contact.getFirstName(),
      contact.getLastName(), contact.getPhone());
    return Response.ok(
      new Contact(id, contact.getFirstName(), contact.getLastName(),
          contact.getPhone())).build();
  }</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>How it works…</h2></div></div></div><p>Thanks<a id="id158" class="indexterm"/> to JDBI, our phonebook application can now interact with a database, retrieving, storing, updating, and deleting contacts.</p><p>Let's create a new contact by performing an HTTP POST request with <code class="literal">curl</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl --verbose --header "Content-Type: application/json" -X POST -d '{"firstName": "FOO", "lastName":"BAR</strong></span>
<span class="strong"><strong>", "phone":"987654321"}' </strong></span>
<span class="strong"><strong>http://localhost:8080/contact/</strong></span>
</pre></div><p>The contact is created, and the value of the inserted row's primary key, that is, the contact <code class="literal">id,</code> is <code class="literal">174</code>, as you can see (the <code class="literal">Location</code> response header) in the following screenshot:</p><div class="mediaobject"><img src="graphics/9530OS_06_04.jpg" alt="How it works…"/></div><p>JDBI's SQL Object API simplifies the creation of <code class="literal">DAO</code>. We created the <code class="literal">DAO</code> interfaces on which we can map plain, parameterized SQL queries to specific methods using the <code class="literal">@SqlQuery</code> annotation<a id="id159" class="indexterm"/>; note that apart from the object mapper, no additional implementation is needed.</p><p>Since we are retrieving data from the database and returning a <code class="literal">Contact</code> instance, we needed to create a <code class="literal">Mapper</code> class, which is a class that implements the <code class="literal">org.skife.jdbi.v2.tweak.ResultSetMapper&lt;T&gt;</code> interface for the <code class="literal">Contact</code> class. Its implementation <a id="id160" class="indexterm"/>was fairly simple and straightforward. We created a <code class="literal">Contact</code> object with the values we got from the database <code class="literal">ResultSet</code> object using the <code class="literal">#getLong()</code> and <code class="literal">#getString()</code> methods and providing the column name.</p><p>We used <code class="literal">jdbi</code> to create our <code class="literal">DAO</code> instances within our resource class using the <code class="literal">DBI#onDemand()</code> method<a id="id161" class="indexterm"/>. However, in order to do that, we had to create a <code class="literal">DBI</code> factory and build the <code class="literal">DBI</code> instance prior to registering our resources. Again, this <a id="id162" class="indexterm"/>was pretty simple, and required minor modifications in the <code class="literal">App#run()</code> method.</p><p>The <code class="literal">DBI</code> factory requires the database connection settings in order to build the <code class="literal">DBI</code> instance. Going one step back, we had our configuration class updated to read and expose the <code class="literal">DatabaseConfiguration</code> settings, which were declared in the database section of the applications configuration file, that is, <code class="literal">config.yaml</code>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>There's more…</h2></div></div></div><p>JDBI identifies itself as an SQL convenience library for Java. We used the JDBI SQL Object API where a particular method is mapped to a specific SQL statement. However, this is not the <a id="id163" class="indexterm"/>only way of using JDBI to interact with a database. JDBI exposes another API too, that is, the fluent style API.</p><div class="section" title="The JDBI fluent style API"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec17"/>The JDBI fluent style API</h3></div></div></div><p>The fluent <a id="id164" class="indexterm"/>style API allows us to open and use a database handle to create and execute SQL queries on demand on the fly, instead of using the predefined SQL statements that the SQL Object API utilizes.</p><p>Generally, the type of API that you should use depends on your personal taste, and you can even mix both APIs together.</p></div><div class="section" title="The @MapResultAsBean annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec18"/>The @MapResultAsBean annotation</h3></div></div></div><p>In this <a id="id165" class="indexterm"/>example, we have implemented a mapper and used the <code class="literal">@Mapper</code> annotation in order to map the result of an SQL query to a <code class="literal">Contact</code> instance. An alternative approach would be the use of the <code class="literal">MapResultAsBean</code> annotation.</p><div class="informalexample"><pre class="programlisting">@MapResultAsBean
@SqlQuery("select * from contact where id = :id")
Contact getContactById(@Bind("id") int id);</pre></div><p>By annotating <code class="literal">#getContactById()</code> in this example, we map the result of the SQL query directly to a <code class="literal">Contact</code> instance, without needing to implement a custom mapper. In order for this to work though, the <code class="literal">Contact</code> class should be updated with setters (that is, <code class="literal">setFirstName(String firstName){ .. }</code>). Due to this, the final keyword will have to be removed from the declaration of each member variable.</p></div></div></div></body></html>