["```java\ncase class Ticker(value: String) extends AnyVal \ncase class Price(value: BigDecimal) extends AnyVal \ncase class OrderId(value: Long) extends AnyVal \ncase class CreatedTimestamp(value: Instant) extends AnyVal \ncase class ClientId(value: Long) extends AnyVal \n\nsealed trait Order { \n  def created: CreatedTimestamp \n  def id: OrderId \n  def ticker: Ticker \n  def price: Price \n  def clientId: ClientId \n} \ncase class BuyOrder(created: CreatedTimestamp, id: OrderId, ticker: Ticker, price:   Price, clientId: ClientId) extends Order \n\ncase class SellOrder(created: CreatedTimestamp, id: OrderId, ticker: Ticker, price: Price,clientId: ClientId) extends Order \n\ncase class Execution(created: CreatedTimestamp, id: OrderId, price: Price) \n\n```", "```java\nsealed trait LastHourPnL \ncase object LastHourPositive extends LastHourPnL \ncase object LastHourNegative extends LastHourPnL \n\nsealed trait LastDayPnL \ncase object LastDayPositive extends LastDayPnL \ncase object LastDayNegative extends LastDayPnL \n\nsealed trait LastSevenDayPnL \ncase object LastSevenDayPositive extends LastSevenDayPnL \ncase object LastSevenDayNegative extends LastSevenDayPnL \n\ncase class TradingPerformanceTrend( \n  ticker: Ticker, \n  lastHour: LastHourPnL, \n  lastDay: LastDayPnL, \n  lastSevenDay: LastSevenDayPnL) \n\n```", "```java\ndef trend( \n  now: () => Instant, \n  findOrders: (Interval, Ticker) => List[Order], \n  findExecutions: (Interval, Ticker) => List[Execution], \n  request: GenerateTradingPerformanceTrend): \nList[TradingPerformanceTrend] \n\ncase class GenerateTradingPerformanceTrend( \n  tickers: List[Ticker], clientId: ClientId) \n\n```", "```java\n  def periodPnL( \n    duration: Duration): Map[Ticker, PeriodPnL] = { \n    val currentTime = now() \n    val interval = new Interval(currentTime.minus(duration), currentTime) \n    (for { \n      ticker <- request.tickers \n      orders = findOrders(interval, ticker) \n      executions = findExecutions(interval, ticker) \n      idToExecPrice = executions.groupBy(_.id).mapValues(es => \n        Price.average(es.map(_.price))) \n      signedExecutionPrices = for { \n        o <- orders \n        if o.clientId == request.clientId \n        price <- idToExecPrice.get(o.id).map(p => o match { \n          case _: BuyOrder => Price(p.value * -1) \n          case _: SellOrder => p \n        }).toList \n      } yield price \n      trend = signedExecutionPrices.foldLeft(PnL.zero) { \n        case (pnl, p) => PnL(pnl.value + p.value) \n      } match { \n        case p if p.value >= PnL.zero.value => PeriodPositive \n        case _ => PeriodNegative \n      } \n    } yield ticker -> trend).toMap \n  } \n\n```", "```java\ncase class PnL(value: BigDecimal) extends AnyVal \nobject PnL { \n  val zero: PnL = PnL(BigDecimal(0)) \n} \n\nsealed trait PeriodPnL \ncase object PeriodPositive extends PeriodPnL \ncase object PeriodNegative extends PeriodPnL \n\n```", "```java\nval listView: SeqView[Int, List[Int]] = List(1, 2, 3).view \n\n```", "```java\nprintln(\"List evaluation:\") \nval evens = List(0, 1, 2, 3, 4, 5).map(i => { \n  println(s\"Adding one to $i\") \n  i + 1 \n}).filter(i => { \n  println(s\"Filtering $i\") \n  i % 2 == 0 \n}) \n\nprintln(\"--- Printing first two even elements ---\") \nprintln(evens.take(2)) \n\nprintln(\"View evaluation:\") \nval evensView = List(0, 1, 2, 3, 4, 5).view.map(i => { \n  println(s\"Adding one to $i\") \n  i + 1 \n}).filter(i => { \n  println(s\"Filtering $i\") \n  i % 2 == 0 \n}) \n\nprintln(\"--- Printing first two even elements ---\") \nprintln(evensView.take(2).toList) \n\n```", "```java\nList evaluation: \nAdding one to 0 \nAdding one to 1 \nAdding one to 2 \nAdding one to 3 \nAdding one to 4 \nAdding one to 5 \nFiltering 1 \nFiltering 2 \nFiltering 3 \nFiltering 4 \nFiltering 5 \nFiltering 6 \n--- Printing first two even elements --- \nList(2, 4) \n\n```", "```java\nView evaluation: \n--- Printing first two even elements --- \nAdding one to 0 \nFiltering 1 \nAdding one to 1 \nFiltering 2 \nAdding one to 2 \nFiltering 3 \nAdding one to 3 \nFiltering 4 \nList(2, 4) \n\n```", "```java\nsealed trait PseudoView[A] { \n  def map[B](f: A => B): PseudoView[B] \n  def toList: List[A] \n} \n\n```", "```java\nfinal class InitialView[A](xs: List[A]) extends PseudoView[A] \nfinal class ComposedView[A, B](xs: List[A], fa: A => B) extends PseudoView[B] \n\n```", "```java\nfinal class InitialView[A](xs: List[A]) extends PseudoView[A] { \n  def map[B](f: A => B): PseudoView[B] = new ComposedView[A, B](xs, f) \n  def toList: List[A] = xs \n} \n\n```", "```java\nfinal class ComposedView[A, B](xs: List[A], fa: A => B) extends PseudoView[B] { \n  def map[C](f: B => C): PseudoView[C] = new ComposedView(xs, f.compose(fa)) \n  def toList: List[B] = xs.map(fa) \n} \n\n```", "```java\nobject PseudoView {  \n  def view[A, B](xs: List[A]): PseudoView[A] = new InitialView(xs) \n} \n\n```", "```java\nprintln(\"PseudoView evaluation:\") \nval listPseudoView = PseudoView.view(List(0, 1, 2)).map(i => { \n  println(s\"Adding one to $i\") \n  i + 1 \n}).map(i => { \n  println(s\"Multiplying $i\") \n  i * 2 \n}) \n\nprintln(\"--- Converting PseudoView to List ---\") \nprintln(listPseudoView.toList) \n\n```", "```java\nPseudoView evaluation: \n--- Converting PseudoView to List --- \nAdding one to 0 \nMultiplying 1 \nAdding one to 1 \nMultiplying 2 \nAdding one to 2 \nMultiplying 3 \nList(2, 4, 6) \n\n```", "```java\ntrait Transformed[+B] extends GenTraversableView[B, Coll] { \n  def foreach[U](f: B => U): Unit \n  lazy val underlying = self.underlying \n} \n\n```", "```java\ntrait Filtered extends Transformed[A] { \n  protected[this] val pred: A => Boolean \n  def foreach[U](f: A => U) { \n    for (x <- self) \n      if (pred(x)) f(x) \n  } \n} \n\n```", "```java\n  @Benchmark \n  def singleTransformList(state: ViewState): List[Int] = \n    state.numbers.map(_ * 2) \n\n  @Benchmark \n  def singleTransformView(state: ViewState): Vector[Int] = \n    state.numbers.view.map(_ * 2).toVector \n\n  @Benchmark \n  def twoTransformsList(state: ViewState): List[Int] = \n    state.numbers.map(_ * 2).filter(_ % 3 == 0) \n\n  @Benchmark \n  def twoTransformsView(state: ViewState): Vector[Int] = \n    state.numbers.view.map(_ * 2).filter(_ % 3 == 0).toVector \n\n  @Benchmark \n  def threeTransformsList(state: ViewState): List[Int] = \n    state.numbers.map(_ * 2).map(_ + 7).filter(_ % 3 == 0) \n\n  @Benchmark \n  def threeTransformsView(state: ViewState): Vector[Int] = \n    state.numbers.view.map(_ * 2).map(_ + 7).filter(_ % 3 == 0).toVector \n\n```", "```java\n@State(Scope.Benchmark) \nclass ViewState { \n\n  @Param(Array(\"10\", \"1000\", \"1000000\")) \n  var collectionSize: Int = 0 \n\n  var numbers: List[Int] = Nil \n\n  @Setup \n  def setup(): Unit = { \n    numbers = (for (i <- 1 to collectionSize) yield i).toList \n  } \n} \n\n```", "```java\nsbt 'project chapter5' 'jmh:run ViewBenchmarks -foe true'\n\n```", "```java\nval list: Seq[Int] = List(1, 2, 3) \nval view: Seq[Int] = list.view \nval stream: Seq[Int] = list.toStream \n\n```", "```java\ndef shouldGenerateOrder(xs: Seq[Execution]): Boolean =  \n  xs.size >= 3 \n\n```", "```java\n> val xs = List(1,2,3,4,5).view.map(x => {  println(s\"multiply $x\"); x * 2 }) \nxs: scala.collection.SeqView[Int,Seq[_]] = SeqViewM(...) \n> val evens = xs.filter(_ % 2 == 0).toList \nmultiply 1 \nmultiply 2 \nmultiply 3 \nmultiply 4 \nmultiply 5 \nevens: List[Int] = List(2, 4, 6, 8, 10) \n\n> val odds = xs.filter(_ % 2 != 0).toList \nmultiply 1 \nmultiply 2 \nmultiply 3 \nmultiply 4 \nmultiply 5 \nodds: List[Int] = List() \n\n```", "```java\n> val (evens, odds) = List(1,2,3,4,5).view.map(x => {  println(s\"multiply $x\"); x * 2 }).partition(_ % 2 == 0) \nevens: scala.collection.SeqView[Int,Seq[_]] = SeqViewMF(...) \nodds: scala.collection.SeqView[Int,Seq[_]] = SeqViewMF(...) \n\n> println(evens.toList, odds.toList) \nmultiply 1 \nmultiply 2 \nmultiply 3 \nmultiply 4 \nmultiply 5 \nmultiply 1 \nmultiply 2 \nmultiply 3 \nmultiply 4 \nmultiply 5 \n(List(2, 4, 6, 8, 10),List()) \n\n```", "```java\nexecutions.groupBy(_.id).mapValues(es =>\nPrice.average(es.map(_.price)))\n```", "```java\n> val m = Map(\"a\" -> 1, \"b\" -> 2)\nm: scala.collection.immutable.Map[String,Int] = Map(a -> 1, b -> 2)\n> val m_prime = m.mapValues{ v => println(s\"Mapping $v\"); v * 2}\nMapping 1\nMapping 2\nm_prime: scala.collection.immutable.Map[String,Int] = Map(a -> 2, b -> 4)\n> m_prime.get(\"a\")\nMapping 1\nres0: Option[Int] = Some(2)\n> m_prime.get(\"a\")\nMapping 1\nres1: Option[Int] = Some(2)\n```", "```java\ndef trend( \n  now: () => Instant, \n  findOrders: (Duration, Ticker) => List[Order], \n  findExecutions: (Duration, Ticker) => List[Execution], \n    request: GenerateTradingPerformanceTrend): List[TradingPerformanceTrend] = { \n    def periodPnL( \n      start: Instant => Instant): Map[Ticker, PeriodPnL] = { ... } \n\n    val tickerToLastHour = periodPnL(now => \n      now.minus(Period.hours(1).getMillis)).mapValues { \n      case PeriodPositive => LastHourPositive \n      case PeriodNegative => LastHourNegative \n    } \n    val tickerToLastDay = periodPnL(now => \n      now.minus(Period.days(1).getMillis)).mapValues { \n      case PeriodPositive => LastDayPositive \n      case PeriodNegative => LastDayNegative \n    } \n    val tickerToLastSevenDays = periodPnL(now => \n      now.minus(Period.days(7).getMillis)).mapValues { \n      case PeriodPositive => LastSevenDayPositive \n      case PeriodNegative => LastSevenDayNegative \n    } \n    tickerToLastHour.zip(tickerToLastDay).zip(tickerToLastSevenDays).map({ \n      case (((t, lastHour), (_, lastDay)), (_, lastSevenDays)) => \n        TradingPerformanceTrend(t, lastHour, lastDay, lastSevenDays) \n    }).toList \n  } \n\n```", "```java\nprintln(List(1, 3, 5, 7).zip(List(2, 4, 6))) \n\n```", "```java\nList((1,2), (3,4), (5,6)) \n\n```", "```java\ncase class OrderExecuted(created: CreatedTimestamp, orderId: OrderId, price: Price) \n\n```", "```java\nsealed trait Order { \n  def created: CreatedTimestamp \n  def id: OrderId \n  def ticker: Ticker \n  def price: Price \n  def clientId: ClientId \n  def executionPrice: Option[Price] \n} \n\n```", "```java\nsealed trait OrderBookEvent \ncase class BuyOrderSubmitted(created: CreatedTimestamp,  \n  id: OrderId, ticker: Ticker, price: Price, clientId: ClientId) \n  extends OrderBookEvent \ncase class SellOrderSubmitted(created: CreatedTimestamp,  \n  id: OrderId, ticker: Ticker, price: Price clientId: ClientId) \n  extends OrderBookEvent \ncase class OrderCanceled(created: CreatedTimestamp, id: OrderId) \n  extends OrderBookEvent \ncase class OrderExecuted(created: CreatedTimestamp,  \n  id: OrderId, price: Price) extends OrderBookEvent \n\n```", "```java\n> val days = \"Monday\" :: \"Tuesday\" :: \"Wednesday\" :: Nil \ndays: List[String] = List(Monday, Tuesday, Wednesday) \n\n> val months = \"January\" #:: \"February\" #:: \"March\" #:: Stream.empty \nmonths: scala.collection.immutable.Stream[String] = Stream(January, ?) \n\n```", "```java\nscala> println(months.take(2).toList) \nList(January, February) \nscala> months \nres0: scala.collection.immutable.Stream[String] = Stream(January, February, ?) \n\n```", "```java\nscala> months.take(2) \nres0: scala.collection.immutable.Stream[String] = Stream(January, ?) \n\n```", "```java\ndef powerOf2: Stream[Int] = { \n  def next(n: Int): Stream[Int] = { \n    println(s\"Adding $n\") \n    n #:: next(2 * n) \n  } \n  1 #:: next(1) \n} \n\n```", "```java\nscala> val s = powerOf2 \ns: Stream[Int] = Stream(1, ?) \n\nscala> s.take(8).toList \nAdding 1 \nAdding 2 \nAdding 4 \nAdding 8 \nAdding 16 \nAdding 32 \nAdding 64 \nres0: List[Int] = List(1, 1, 2, 4, 8, 16, 32, 64) \n\nscala> s.take(10).toList \nAdding 128 \nAdding 256 \nres1: List[Int] = List(1, 1, 2, 4, 8, 16, 32, 64, 128, 256) \n\n```", "```java\ndef powerOf2(n: Int): Stream[Int] = math.pow(2, n).toInt #:: powerOf2(n+1) \n\n```", "```java\nscala> powerOf2(3).take(10).toList \nres0: List[Int] = List(8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096) \n\n```", "```java\n       scala> Stream(1,2,3,4) \n       res0: scala.collection.immutable.Stream[Int] = Stream(1, ?) \n       scala> Stream(List(1,2,3,4):_*) \n       res1: scala.collection.immutable.Stream[Int] = Stream(1, ?) \n\n```", "```java\n       scala> Stream.fill(4)(10) \n       res0: scala.collection.immutable.Stream[Int] = Stream(10, ?) \n       scala> res0.toList \n       res1: List[Int] = List(10, 10, 10, 10) \n\n```", "```java\n       scala> Stream.from(4) \n       res0: scala.collection.immutable.Stream[Int] = Stream(4, ?) \n       scala> res0.take(3).toList \n       res1: List[Int] = List(4, 5, 6) \n\n```", "```java\nscala> List(1,2,3,4,5).toStream \nres0: scala.collection.immutable.Stream[Int] = Stream(1, ?) \n\n```", "```java\nscala> val s = Stream(1,2,3,4) \ns: scala.collection.immutable.Stream[Int] = Stream(1, ?) \nscala> s match { \n     | case _ #:: _ #:: i #:: _ => i \n     | } \nres0: Int = 3 \n\n```", "```java\ndef processPnl(e: OrderBookEvent, s: TradeState): (TradeState, Option[PnlEvent]) \n\n```", "```java\nsealed trait PnlEvent \ncase class PnlIncreased(created: EventInstant, clientId: ClientId, \n  ticker: Ticker, profit: Pnl) extends PnlEvent \ncase class PnlDecreased(created: EventInstant, clientId: ClientId, \n  ticker: Ticker, loss: Pnl)extends PnlEvent \n\ncase class Pnl(value: BigDecimal) extends AnyVal { \n  def isProfit: Boolean = value.signum >= 0 \n} \nobject Pnl { \n  def fromExecution(buy: Price, sell: Price): Pnl = \n    Pnl(sell.value - buy.value) \n\n  val zero: Pnl = Pnl(BigDecimal(0)) \n} \n\n```", "```java\ncase class PendingOrder(ticker: Ticker, price: Price,  \n  clientId: ClientId)  \n\n  case class TradeState( \n    pendingBuys: Map[OrderId, PendingOrder], \n    pendingSells: Map[OrderId, PendingOrder]) { \n    def cancelOrder(id: OrderId): TradeState = copy( \n      pendingBuys = pendingBuys - id, pendingSells = pendingSells - id) \n    def addPendingBuy(o: PendingOrder, id: OrderId): TradeState = \n      copy(pendingBuys = pendingBuys + (id -> o)) \n    def addPendingSell(o: PendingOrder, id: OrderId): TradeState = \n      copy(pendingSells = pendingSells + (id -> o)) \n  } \nobject TradeState { \n val empty: TradeState = TradeState(Map.empty, Map.empty) \n} \n\n```", "```java\n  def processPnl( \n    s: TradeState, \n    e: OrderBookEvent): (TradeState, Option[PnlEvent]) = e match { \n    case BuyOrderSubmitted(_, id, t, p, cId) => \n      s.addPendingBuy(PendingOrder(t, p, cId), id) -> None \n    case SellOrderSubmitted(_, id, t, p, cId) => \n      s.addPendingSell(PendingOrder(t, p, cId), id) -> None \n    case OrderCanceled(_, id) => s.cancelOrder(id) -> None \n    case OrderExecuted(ts, id, price) => \n      val (p, o) = (s.pendingBuys.get(id), s.pendingSells.get(id)) match { \n        case (Some(order), None) => \n          Pnl.fromBidExecution(order.price, price) -> order \n        case (None, Some(order)) => \n          Pnl.fromOfferExecution(price, order.price) -> order \n        case error => sys.error( \n          s\"Unsupported retrieval of ID = $id returned: $error\") \n      } \n      s.cancelOrder(id) -> Some( \n        if (p.isProfit) PnlIncreased(ts, o.clientId, o.ticker, p) \n        else PnlDecreased(ts, o.clientId, o.ticker, p)) \n  } \n\n```", "```java\ndef processHourlyPnl(e: PnlEvent, s: HourlyState): (HourlyState, Option[HourlyPnlTrendCalculated]) \n\n```", "```java\ncase class HourlyPnlTrendCalculated( \n      start: HourInstant, \n      clientId: ClientId, \n      ticker: Ticker, \n      pnl: LastHourPnL) \n\n```", "```java\ncase class HourInstant(value: Instant) extends AnyVal { \n  def isSameHour(h: HourInstant): Boolean = \n    h.value.toDateTime.getHourOfDay == value.toDateTime.getHourOfDay \n} \nobject HourInstant { \n  def create(i: EventInstant): HourInstant = \n    HourInstant(i.value.toDateTime.withMillisOfSecond(0) \n     .withSecondOfMinute(0).withMinuteOfHour(0).toInstant) \n} \n\n```", "```java\ncase class HourlyState( \n      keyToHourlyPnl: Map[(ClientId, Ticker), (HourInstant, Pnl)]) \nobject HourlyState { \n val empty: HourlyState = HourlyState(Map.empty) \n} \n\n```", "```java\ndef processHourlyPnl( \n s: HourlyState, \n e: PnlEvent): (HourlyState, Option[HourlyPnlTrendCalculated]) = { \n def processChange( \n   ts: EventInstant, \n   clientId: ClientId, \n   ticker: Ticker, \n   pnl: Pnl): (HourlyState, Option[HourlyPnlTrendCalculated]) = { \n   val (start, p) = s.keyToHourlyPnl.get((clientId, ticker)).fold( \n     (HourInstant.create(ts), Pnl.zero))(identity) \n   start.isSameHour(HourInstant.create(ts)) match { \n     case true => (s.copy(keyToHourlyPnl = s.keyToHourlyPnl + \n       ((clientId, ticker) ->(start, p + pnl))), None) \n     case false => (s.copy(keyToHourlyPnl = \n       s.keyToHourlyPnl + ((clientId, ticker) -> \n         (HourInstant.create(ts), Pnl.zero + pnl))), \n       Some(HourlyPnlTrendCalculated(start, clientId, ticker, \n         p.isProfit match { \n           case true => LastHourPositive \n           case false => LastHourNegative \n         }))) \n   } \n } \n\n e match { \n   case PnlIncreased(ts, clientId, ticker, pnl) => processChange( \n     ts, clientId, ticker, pnl) \n   case PnlDecreased(ts, clientId, ticker, pnl) => processChange( \n     ts, clientId, ticker, pnl) \n } \n} \n\n```", "```java\nval sum = Stream(1, 2, 3, 4, 5).foldLeft(0) { case (acc, i) => acc + i } \nprintln(sum) // prints 15  \n\n```", "```java\ncase class PipelineState(tradeState: TradeState, hourlyState: HourlyState) \nobject PipelineState { \n  val empty: PipelineState = PipelineState(TradeState.empty, HourlyState.empty) \n} \n\n```", "```java\ndef pipeline(initial: PipelineState, f: HourlyPnlTrendCalculated => Unit, xs: List[OrderBookEvent]): PipelineState \n\n```", "```java\ndef pipeline( \n    initial: PipelineState, \n    f: HourlyPnlTrendCalculated => Unit, \n    xs: Stream[OrderBookEvent]): PipelineState = xs.foldLeft(initial) { \n    case (PipelineState(ts, hs), e) => \n      val (tss, pnlEvent) = processPnl(ts, e) \n      PipelineState(tss, \n        pnlEvent.map(processHourlyPnl(hs, _)).fold(hs) { \n          case (hss, Some(hourlyEvent)) => \n            f(hourlyEvent) \n            hss \n          case (hss, None) => hss \n        }) \n  } \n\n```", "```java\nval now = EventInstant(HourInstant.create(EventInstant( \n      new Instant())).value) \n    val Foo = Ticker(\"FOO\") \n\n    pipeline(PipelineState.empty, println, Stream( \n      BuyOrderSubmitted(now, OrderId(1), Foo, Price(21.07), ClientId(1)), \n      OrderExecuted(EventInstant(now.value.plus(Duration.standardMinutes(30))), \n        OrderId(1), Price(21.00)), \n      BuyOrderSubmitted(EventInstant(now.value.plus( \n        Duration.standardMinutes(35))), \n        OrderId(2), Foo, Price(24.02), ClientId(1)), \n      OrderExecuted(EventInstant(now.value.plus(Duration.standardHours(1))), \n        OrderId(2), Price(24.02)))) \n\n```", "```java\nHourlyPnlTrendCalculated(HourInstant(2016-02-15T20:00:00.000Z),ClientId(1),Ticker(FOO),LastHourPositive) \n\n```", "```java\ntrait Iterator[A] { \n  def next: A \n  def hasNext: Boolean \n}\n```", "```java\n  sealed trait Step \n  case object GenerateBuy extends Step \n  case object GenerateSell extends Step \n  case object GenerateCancel extends Step \n  case object GenerateExecution extends Step \n\n  case class Weight(value: Int) extends AnyVal \n  case class GeneratedWeight(value: Int) extends AnyVal \n  case class StepTransitionWeights( \n    buy: Weight, \n    sell: Weight, \n    cancel: Weight, \n    execution: Weight) \n\n```", "```java\n  case class State( \n    pendingOrders: Set[OrderId], \n    step: Step) \n\n```", "```java\ndef nextState( \n      weight: StepTransitionWeights => GeneratedWeight, \n      stepToWeights: Map[Step, StepTransitionWeights], \n      s: State): (State, OrderBookEvent) \n\n```", "```java\nval stepToWeights = Map[Step, StepTransitionWeights]( \n      GenerateBuy -> StepTransitionWeights( \n        Weight(10), Weight(25), Weight(40), Weight(40)), \n      GenerateSell -> StepTransitionWeights( \n        Weight(25), Weight(10), Weight(40), Weight(25)), \n      GenerateCancel -> StepTransitionWeights( \n        Weight(60), Weight(50), Weight(40), Weight(10)), \n      GenerateExecution -> StepTransitionWeights( \n        Weight(30), Weight(30), Weight(60), Weight(25))) \n\n    val next = State.nextState( \n      t => GeneratedWeight(Random.nextInt(t.weightSum.value) + 1), \n      stepToWeights, _: State) \n\n    println(\"State\\tEvent\") \n    Stream.iterate(State.initialBuy) { case (s, e) => next(s) } \n      .take(5) \n      .foreach { case (s, e) => println(s\"$s\\t$e\")  } \n\n```", "```java\nval initialBuy: (State, OrderBookEvent) = { \n      val e = randomBuySubmitted() \n      State(Set(e.id), GenerateBuy) -> e \n    } \n\n```", "```java\n State = State(Set(OrderId(1612147067584751204)),GenerateBuy)\n    Event = BuyOrderSubmitted(EventInstant(2016-02-22T23:52:40.662Z),OrderId(1612147067584751204),Ticker(FOO),Price(32),ClientId(28))\n    State = State(Set(OrderId(1612147067584751204), OrderId(7606120383704417020)),GenerateBuy)\n    Event = BuyOrderSubmitted(EventInstant(2016-02-22T23:52:40.722Z),OrderId(7606120383704417020),Ticker(XYZ),Price(18),ClientId(54))\n    State = State(Set(OrderId(1612147067584751204), OrderId(7606120383704417020), OrderId(5522110701609898973)),GenerateBuy)\n    Event = BuyOrderSubmitted(EventInstant(2016-02-22T23:52:40.723Z),OrderId(5522110701609898973),Ticker(XYZ),Price(62),ClientId(28))\n    State = State(Set(OrderId(7606120383704417020), OrderId(5522110701609898973)),GenerateExecution)\n    Event = OrderExecuted(EventInstant(2016-02-22T23:52:40.725Z),OrderId(1612147067584751204),Price(21))\n    State = State(Set(OrderId(7606120383704417020), OrderId(5522110701609898973), OrderId(5898687547952369568)),GenerateSell)\n    Event = SellOrderSubmitted(EventInstant(2016-02-22T23:52:40.725Z),OrderId(5898687547952369568),Ticker(BAR),Price(76),ClientId(45)) \n```", "```java\n@tailrec \ndef drop[A](s: Stream[A], count: Int): Stream[A] = count match { \n  case 0 => s \n  case n if n > 0 => drop(s.tail, count - 1) \n  case n if n < 0 => throw new Exception(\"cannot drop negative count\") \n} \n\n```", "```java\ndef max(s: => Stream[Int]): Option[Int] = { \n @tailrec \n def loop(ss: Stream[Int], current: Option[Int]): Option[Int] = ss match { \n   case Stream.Empty => current \n   case h #:: rest if current.exists(_ >= h) => loop(rest, current) \n   case h #:: rest => loop(rest, Some(h)) \n } \n loop(s, None) \n} \n\n```", "```java\ndef max(s: => Stream[Int]): Option[Int] = { \n @tailrec \n def loop(ss: Stream[Int], current: Int): Int = ss match { \n   case Stream.Empty => current \n   case h #:: hs if h > current => loop(hs, h) \n   case h #:: hs if h <= current => loop(hs, current) \n } \n\n s match { \n   case Stream.Empty => None \n   case h #:: rest => Some(loop(rest, h)) \n } \n} \n\n```", "```java\ndef range(s: Seq[Int]): Int = s.max - s.min \n\n```", "```java\nval s: Stream[Int] = ??? \nrange(s) \n\n```", "```java\nval s: Stream[Int] = powerOf2(0) \nrange(s) \njava.lang.OutOfMemoryError: GC overhead limit exceeded \n  at .powerOf2(<console>:10) \n  at $anonfun$powerOf2$1.apply(<console>:10) \n  at $anonfun$powerOf2$1.apply(<console>:10) \n  at scala.collection.immutable.Stream$Cons.tail(Stream.scala:1233) \n  at scala.collection.immutable.Stream$Cons.tail(Stream.scala:1223) \n  at scala.collection.immutable.Stream.reduceLeft(Stream.scala:627) \n  at scala.collection.TraversableOnce$class.max(TraversableOnce.scala:229) \n  at scala.collection.AbstractTraversable.max(Traversable.scala:104) \n  at .range(<console>:10) \n  ... 23 elided \n\n```"]