- en: Chapter 8. Making Your Plugin Configurable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A configurable plugin can be very powerful. A single plugin will be able to
    function in different ways, depending on user preferences. Essentially, your plugin's
    configuration file will be similar to the `bukkit.yml` file for your server. It
    will allow you to change settings for the plugin without modifying the Java code.
    This means that you need not rebuild the plugin JAR file every time you wish to
    change a small detail. If your plugin is public or used by someone else, adding
    a `config` file may reduce the time spent on modifying code in the future. The
    users of your plugin can change the settings that are in the `config` file by
    themselves and do not require any additional assistance from you as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand why we would want a variable to be configurable, let's look
    at one of the plugins that we previously talked about. In `MobEnhancer`, we set
    the health of zombies to `40` instead of `20`. Someone else may wish to use your
    plugin, but they want to set the zombies' health to `60`. You can create two versions
    of the plugin, which may become very confusing, or you can have one version that
    is configurable. In the `config` file on your server, you will have the health
    of zombies set to `40`. But on another server, the health will be set to `60`.
    Even if your plugin will be used on only one server, configuration will allow
    for a quick and easy method of changing the amount of health.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five steps to making your plugin configurable, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide exactly which aspects of your plugin will be configurable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `config.yml` file that includes each setting and its default value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to save the default `config` file as well as load/reload the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the configured values and store them in your plugin as class variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that your code references the class variables that the configuration
    settings are loaded into
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The steps need not be performed in this order, but we will discuss them in
    the following order in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Configurable data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a `config.yml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving, loading, and reloading your plugin's configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading values from the configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the configured settings in your plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an `ItemStack` value in the YAML format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the YAML structure and hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing configuration values locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting one class into multiple classes and accessing variables and methods
    from another class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can easily make most variables in your plugin configurable. The following
    table comprises various data types and examples of why you may want them to be
    configurable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data Type | How It Can Be Used |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | To define the number of times an event should occur |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | To set the health of a mob when it spawns |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | To turn a specific feature on or off |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | To change a message that is sent to a player |'
  prefs: []
  type: TYPE_TB
- en: '| `ItemStack` | To make a customized item appear |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding an `ItemStack` value to a configuration file is complicated, but this
    will be explained towards the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make `MobEnhancer` configurable. We want to give the players
    a choice of setting the value of the zombies' health. This will simply be one
    `double` value. Let's expand the plugin to support additional creature types.
    We will create the `config` file first and then adapt the program to be able to
    modify different types of mobs. Therefore, we have decided that the `config` file
    will include a single `double` data type value for each type of mob. This `double`
    value will be the mob's health.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a config.yml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time to start writing the `config.yml` file. Create a new `YAML`
    file in the default package of `MobEnhancer`. The name of this file must be `config.yml`
    in order for it to be properly loaded by Spigot. The following is an example of
    how the `config` file for `MobEnhancer` will appear. Note the comments in the
    example indicated by the `#` character. Remember to always include comments so
    that users know exactly what each setting is for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only a few mobs are included in this `config` file, but the names of all the
    mob types can be found in the API documentation for the `EntityType` class at
    [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html).
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple `YAML` file because it does not contain nested keys. Most of
    your configurations will be this simple, but we will go over some complicated
    ones later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Saving, loading, and reloading the config file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the `config.yml` file and it is located in the default package
    of the plugin, we need to be able to save it to a user''s server. Once the file
    is saved, the user will be able to edit it as they please. Saving the `config`
    file is as simple as adding the following method call to the `onEnable` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will copy `config.yml` to `plugins/MobEnhancer/config.yml`. If the file
    already exists, then this line of code will do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The loading of the `config` file is done automatically by Spigot, and there
    is no need for you to do anything in addition to this in your plugin besides using
    `getConfig` when you actually want to access the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reloading `config.yml` is fairly simple to include; we will add it in the form
    of a command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will put this method inside the `main` class for now. Ensure that the class
    also implements `CommandExecutor`. Do not forget to register the command with
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should also be added to `plugin.yml`, as always. It is a good idea
    to add a permission node at this point too. The new `plugin.yml file` looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, your plugin will have a `reload` command. This means that when you edit
    `config.yml`, you can reload the plugin rather than restarting the entire server.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and storing the configured values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once your configuration file is loaded, you must be able to access the file
    and read the values that are set. The `JavaPlugin` class, which is extended by
    the main class, has a `getConfig` method, which returns `FileConfiguration`. This
    `FileConfiguration` class is what we will use to get the values that we are looking
    for. You will see that the `FileConfiguration` class has methods such as `getInt`,
    `getDouble`, `getString`, and `getBoolean`; all of these methods take a string
    as a parameter. The `string` parameter is the path to the value. To fully understand
    the path, we need to look at a YAML configuration that contains nested keys. An
    example of this is the `plugin.yml` file that we were just working with. If we
    want to get the `MobEnhancer` string from the configuration, then the path will
    be `name`. If we want to retrieve the description of the `mobenhancerreload` command,
    then the path will be `commands.mobenhancerreload.description`. Therefore, the
    Java code needed to retrieve this value will be `getString("commands.mobenhancerreload.description");`.
    The `config.yml` file for `MobEnhancer` is quite simple. In order to get one of
    the double values, we can use the `getDouble()` method with the name of the mob
    as the path. For example, to get the value that is set for the `ZOMBIE Entity`,
    we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a `double` value from one of the following three sources:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FileConfiguration` that has been loaded from `plugins/MobEnhance/config.yml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default `FileConfiguration`, which is the `config.yml` file that is located
    within the default package of the `MobEnhancer` JAR file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value of the data type (`0` for a `double/integer` data type, `false`
    for a Boolean value, and `null` for a String/`ItemStack`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first result that doesn't fail will be returned. A result will fail due
    to an invalid path or an invalid value. In the previous statement, an invalid
    path will occur if the `ZOMBIE` path is not within `config.yml`. An invalid value
    will mean that the value of the given path is not a `double data type`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to read the configured data, let's modify the plugin
    to use these customized values.
  prefs: []
  type: TYPE_NORMAL
- en: Using configured settings within your plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current `EventHandler method` of the `MobEnhancer` plugin sets the health
    of zombies to `40`, where the number 40 is **hardcoded**. This means that the
    value of `40` is a part of the code itself, and this cannot be changed after the
    code is compiled. We wish to make this value **softcoded**, that is, we want to
    retrieve the value from an external source, which is `config.yml` in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `onMobSpawn` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will work from this existing code. The `if` statement is no longer needed,
    because we don''t want to limit the plugin to zombies only. As discussed earlier,
    we also want to replace the hardcoded `40 value` with a `double` value, which
    will be read from the `config` file. Therefore, `40` should be replaced with `getConfig().getDouble(type)`.
    You will also have to change the variable type from `int` to `double`. The `Type`
    in this statement will be a string of the `Entity` type. Some examples of this
    are `ZOMBIE`, `SKELETON`, or any of the other entity types that are listed in
    `config.yml`. We already know that we can get the type of the entity that was
    spawned by using `event.getEntityType()`. However, this gives us `EntityType`
    in the `enum` form, and we require it in the `string` form. The `EntityType` page
    of the Bukkit API documentation informs us that we can call the `getname` method
    to return the string that we are looking for. The new `onMobSpawn` method is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This `EventHandler method` is nearly complete. We are allowing other people
    to set the `health` value. We want to ensure that they are entering a valid number.
    We don''t want the plugin to crash because it is being misused. We know that we
    are receiving a `double` value because even if the user sets a non-numeric value,
    we will be given the default value of `0` instead. However, not every valid double
    value will be useable in our situation. For example, we cannot set the health
    of an entity to a negative value. We also do not want to set the health to `0`,
    because this will instantly kill the entity. Therefore, we should only modify
    the health if the new health is set to a positive number. This can be done with
    a simple `if` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MobEnhancer` plugin is now configurable and supports any type of creature.
    It is no longer limited to just zombies. The finished code will be similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ItemStack within a configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will expand the `MobEnhancer` plugin even further by allowing the
    option of giving armor and weapons to zombies and skeletons. In order to do this,
    we must first learn how to add an `ItemStack` object as an option in a configuration
    file. An `ItemStack` method is more complicated than a simple integer or double.
    It is an object that has many nested values. It may also include a **meta** value,
    which will have more nested values. **Meta** contains additional information for
    the item, such as a custom display name or lines of text that make up the lore
    of the item. The following is a sample of an `ItemStack` method in a `YAML` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once loaded, the item in the results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ItemStack within a configuration](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Only the **type** field is required. You can omit any other segment. The **type**
    refers to the type of material. These materials can be found in the API documentation
    under `org.bukkit.Material`, which can be viewed by visiting [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html).
    The **damage** is used to indicate how much damage an item has taken. For items
    such as `wool`, this will set the color of the wool. The **amount** will set the
    stack size. For example, I may have one sword or twenty logs. The **meta** includes
    additional information such as the color and pattern of a banner or the author
    and number of pages of a book. Given the path, `getConfig().getItemStack("SampleItem");`
    will retrieve the item.
  prefs: []
  type: TYPE_NORMAL
- en: YAML configuration hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note the hierarchy when working with `ItemStack` in YAML. This is similar to
    how commands and permissions have nested values in the `plugin.yml` files. We
    can utilize a hierarchy within the `config` file to make it easier to use and
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to give items to two types of mobs, namely `Zombie` and `Skeleton`.
    Each type will have a unique armor and weapon. This means that we will need 10
    different `ItemStack` classes. We can name them `ZombieHolding`, `SkeletonHolding`,
    `ZombieHelmet`, `SkeletonHelmet`, and so on. However, a hierarchy will be much
    more efficient. We will have a `Zombie` key and a `Skeleton` key. Within each
    zombie and skeleton, we will have a key for each item. The following is a sample
    of the hierarchy of the mob armor segment of the `config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rest of the armor pieces can be added in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to retrieve the `ItemStack` method for the boots of a skeleton,
    we will use `getConfig().getItemStack("Skeleton.boots");`. Remember that the hierarchy
    is conveyed using a period. Here is a section that will be appended to `config.yml`,
    which includes mob armor, as discussed. We also have a `GiveArmorToMobs` Boolean
    value, which will be included to easily disable the mob armor feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Storing configuration values as variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Retrieving a value from your plugin''s `config` file requires more time and
    resources than is required to access a local variable. Therefore, if you will
    be accessing a specific value very often, it is best to store it as a variable.
    We will want to do just this with the `GiveArmorToMobs` Boolean value. It is also
    a good idea to store the `ItemStack` armor locally to prevent creating a new one
    every time it is used. Let''s add the following variables above the methods of
    the main class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will only write the code to set the item that a zombie or skeleton is holding.
    You can add the rest of the armor yourself, as it will be done the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want these values to be automatically stored whenever the `config` file
    is reloaded. Note that when the `config` file is initially loaded, it is actually
    being reloaded. To ensure that our data is saved every time the `config` file
    is reloaded, we will add additional code to the `reloadConfig` method of the plugin.
    This is the method that we call to execute the `/merl` command. The `reloadConfig`
    method is already included in every Java plugin, but we will modify it by overriding
    it. This is a lot like how we override the `onEnable` method. Overriding a method
    will prevent the existing code from being executed. This is not an issue for `onEnable`,
    because the method has no prior existing code. However, `reloadConfig` has the
    code that we still wish to execute. Therefore, we will use the following line
    of code to execute the existing code that we are overriding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code is very important. Once we have it, we can add our own code
    before or after it. In our case, we want to store the values after the `config`
    file has been reloaded. Therefore, the additional code should be placed after
    the preceding line of code. The completed overridden `reloadConfig` method looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last code that we must write is to give armor to specific mobs. We will
    add this to the end of the `onMobSpawn` method. We only want to do this if `giveArmorToMobs`
    is set to `true`. Therefore, the block of code will be placed inside an `if` statement,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve the entity''s armor using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This gives us their equipment slots even though they may not include anything
    in them at the moment. To know more about this object and what you can do with
    it, visit its API documentation at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html).
    Now that we have `EntityEquipment`, setting the pieces of armor is simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two distinct sets of armor. Therefore, we must first check whether
    the entity is either a zombie, or a skeleton. We can do this by using an `if/else`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using a `switch/case` block will be more efficient. Using `switch/case`
    in this scenario will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `If/else` statements are used to check multiple conditions (*Is the entity
    a zombie?* or *Is the entity a skeleton?*). A `switch/case statement` saves time
    by asking a single question (*Which of the following is the type of the entity?*).
    The code within the correct `case` condition will then be executed. When a `break`
    condition is fulfilled, the `switch` statement is exited. If you do not end the
    case with `break`, then you will fall through to the next case and begin executing
    that code. In some circumstances, that is a good thing, but we do not want that
    to happen here. The default case, that is, if none of the other cases match, does
    not need to be included because there is no code in it. However, it does make
    the statement more conclusive, and the Java coding standards released by Oracle
    state that the default case should always be included.
  prefs: []
  type: TYPE_NORMAL
- en: Within each of these cases, we will want to equip the correct set of armor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should check each piece of armor to ensure that it is not `null` before
    applying it using the following code. This will prevent the plugin from crashing
    due to an invalid configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used the `clone` method here on the `ItemStack`. We don't want to hand out
    a single `ItemStack class` to every mob. Instead, we will create its clones so
    that each mob can have its own copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipping the remaining armor and equipping an armor to a skeleton is very
    similar. The overall block of code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `clone` method should be called on each `ItemStack` class so that the original
    items remain undamaged.
  prefs: []
  type: TYPE_NORMAL
- en: With this, the `MobEnhancer` plugin now supports giving armor to mobs. Try it
    out on your server to see how it works. We only discussed giving armor to zombies
    and skeletons because most mobs, including creepers, spiders, and cows, cannot
    wear armor. If you want, try adding armor and items to other mobs to see what
    happens. Also, try giving mobs unique items. For example, skeletons can be given
    a sword or zombies can be given a bow. There is also a skull item that comes in
    different looks; you can make a mob wear it as a mask.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even create skulls that represent a specific player, such as Notch,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing configuration values as variables](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The meta for the `NotchSkull` item is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Play around with your new plugin to see what crazy items you can give to zombies
    and other mobs. The following screenshot illustrates an example of what you can
    accomplish by modifying the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing configuration values as variables](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing variables from another class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MobEnhancer` class is growing in size. There is no need to place all the
    code within a single class. This class is currently extending the `JavaPlugin`
    class as well as implementing both the `Listener` and `CommandExecutor` interfaces.
    The program will be easier to understand if we split these into three unique classes.
    This process is known as **refactoring**. Throughout the process of developing
    software, you will come across code that may be outdated or inefficient and needs
    to be updated. Changing the code in this way is referred to as **refactoring**.
    Don't be discouraged if you need to refactor your code in the future; it is a
    common occurrence in software development, and there are many reasons for it to
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to write more efficient code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API changes or new features require/allow code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existing code is difficult to read or debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method/class has grown too large to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of the code has changed and it should now do something it was not
    originally intended to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will refactor `MobEnhancer` to split the code into three more manageable
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two new classes named `MobSpawnListener` and `MobEnhancerReloadCommand`.
    `MobEnhancer` will still be your main class. Therefore, it will still extend `JavaPlugin`.
    However, the two new classes will implement `Listener` and `CommandExecutor` respectively.
    Move the appropriate methods to their new classes, that is, `onMobSpawn` is an
    event handler and hence it belongs to the `Listener` class, and `onCommand` belongs
    to the `CommandExecutor` class. When moving the methods, you will see that several
    errors are introduced. This is because your methods no longer have access to the
    necessary methods and variables. Let''s first address the `MobEnhancerReloadCommand`
    class, as it has only one error. This error occurs at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `reloadConfig` method is in the `JavaPlugin` class, which is no longer merged
    with the `CommandExector` class. We need to access the `JavaPlugin` object from
    this separate class. The easiest way to do this is by using a static variable.
    If a variable or method is static, then it does not change across different instances
    of the class. This allows us to refer to the variable from a static context. You
    have done this before when using the `Bukkit` class. The methods that you called
    were static. Therefore, you could access them using the `Bukkit` class and not
    a unique `Bukkit` object.
  prefs: []
  type: TYPE_NORMAL
- en: To explain this better, let's imagine that you have a plugin that gives Minecraft
    players bank accounts. Therefore, you will have a class to represent a player's
    bank account. This class can be called `PlayerAccount`. You will have numerous
    `PlayerAccount` objects, one for each player on the server. Within this class,
    you may have a variable that defines a limit of how much money the account can
    hold. Let's name this variable `accountLimit`. If we want each account to have
    a maximum amount of money of `1000`, then the `accountLimit` should be static.
    If we wish to increase the limit to `2000`, then we set `accountLimit` to `2000`
    by using `PlayerAccount.accountLimit = 2000;`. Then, all the players now have
    an account limit of `2000`. If we want some players to have a limit of `1000`
    and others to have a limit of `2000`, then we should not use a static variable.
    Without `accountLimit` being static, if we set `accountLimit` to `2000` for instance
    A of `PlayerAccount`, it would still be `1000` for instance B of `PlayerAccount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storing the plugin as a static variable within the main class will benefit
    us. Above your current variables, add a `static` `JavaPlugin` variable named `plugin`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also instantiate this variable within the `onEnable` method. This can
    simply be done using `plugin = this;`. Now, we can access the plugin instance
    by using `MobEnhancer.plugin`. Therefore, where we previously had `reloadConfig();`,
    we will now have `MobEnhancer.plugin.reloadConfig()`. This will fix the errors
    in `MobEnhancerReloadCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`MobSpawnListener` requires a similar modification, as the plugin object is
    needed to call the `getConfig` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will continue seeing errors in `MobSpawnListener`. It is attempting to
    access variables that are still in the main class. Let''s move the mob armor variables
    to the `Listener` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also modify the `reload` method within `MobEnhancer.java` to match
    the new location of the variables. For example, instead of `giveArmorToMobs`,
    we should now have `MobSpawnListener.giveArmorToMobs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Even with this change, we will still be given an error, which reads `giveArmorToMobs`
    **has private access in** `MobSpawnListener`. Each variable is `private`, which
    means that they cannot be accessed from another class. We wish to be able to access
    them from the other classes. Hence, we will remove the private modifier. After
    doing so, we will be given yet another error. This new error reads **non-static
    variable** `giveArmorToMobs` **cannot be referenced from a static context**. This
    happens because the variables are not defined as static variables. Before you
    simply change these variables so that they can be static, ensure that it makes
    sense for them to be static. Refer to the earlier discussion about when static
    variables should be used. In this situation, we will only have one value of each
    of these variables. Hence, we do want to make them static, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only two lines remaining in the code that require our attention.
    These two lines are used to register the event listener and command executor.
    When calling the `registerEvents` method, two parameters are required. The first
    parameter is `Listener`, and the second one is `Plugin`. The `this` keyword references
    the plugin. Therefore, it is fine as the second parameter. However, for the first
    parameter, you must pass an instance of the `Listener` class. We have done this
    in [Chapter 7](part0051_split_000.html#1GKCM1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 7. The Bukkit Event System"), *The Bukkit Event System*, when creating
    the `NoRain` plugin. The same applies to the command executor. We must pass an
    instance of the `MobEnhancerReloadCommand` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This gets rid of all the errors that resulted from splitting the project into
    multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now familiar with using a `YAML` configuration file. You can load custom
    values from a `config.yml` file and use them within the plugin. Doing so will
    greatly expand your ability to create unique projects that will be beneficial
    to multiple server administrators. Try adding configurable options to some of
    your previous projects. For instance, if you created the plugin that sends a message
    when a creeper is about to explode, add a configuration file to set the area within
    which the players must be in order to see the message. Now that you are introduced
    to `FileConfiguration` which can be used with the Bukkit API, in the next chapter,
    we will save the plugin's data using the same `FileConfiguration` method so that
    we can load it the next time the plugin is enabled.
  prefs: []
  type: TYPE_NORMAL
